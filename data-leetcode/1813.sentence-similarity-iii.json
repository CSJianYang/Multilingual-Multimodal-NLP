[
    {
        "title": "Rotting Oranges",
        "question_content": "You are given an m x n grid where each cell can have one of three values:\n\n\t0 representing an empty cell,\n\t1 representing a fresh orange, or\n\t2 representing a rotten orange.\n\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\n&nbsp;\nExample 1:\n\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4\n\nExample 2:\n\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\nOutput: -1\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n\nExample 3:\n\nInput: grid = [[0,2]]\nOutput: 0\nExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 10\n\tgrid[i][j] is 0, 1, or 2.",
        "solutions": [
            {
                "id": 563686,
                "title": "python-clean-well-explained-faster-than-90",
                "content": "```\\nfrom collections import deque\\n\\n# Time complexity: O(rows * cols) -> each cell is visited at least once\\n# Space complexity: O(rows * cols) -> in the worst case if all the oranges are rotten they will be added to the queue\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # number of rows\\n        rows = len(grid)\\n        if rows == 0:  # check if grid is empty\\n            return -1\\n        \\n        # number of columns\\n        cols = len(grid[0])\\n        \\n        # keep track of fresh oranges\\n        fresh_cnt = 0\\n        \\n        # queue with rotten oranges (for BFS)\\n        rotten = deque()\\n        \\n        # visit each cell in the grid\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    # add the rotten orange coordinates to the queue\\n                    rotten.append((r, c))\\n                elif grid[r][c] == 1:\\n                    # update fresh oranges count\\n                    fresh_cnt += 1\\n        \\n        # keep track of minutes passed.\\n        minutes_passed = 0\\n        \\n        # If there are rotten oranges in the queue and there are still fresh oranges in the grid keep looping\\n        while rotten and fresh_cnt > 0:\\n\\n            # update the number of minutes passed\\n            # it is safe to update the minutes by 1, since we visit oranges level by level in BFS traversal.\\n            minutes_passed += 1\\n            \\n            # process rotten oranges on the current level\\n            for _ in range(len(rotten)):\\n                x, y = rotten.popleft()\\n                \\n                # visit all the adjacent cells\\n                for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    # calculate the coordinates of the adjacent cell\\n                    xx, yy = x + dx, y + dy\\n                    # ignore the cell if it is out of the grid boundary\\n                    if xx < 0 or xx == rows or yy < 0 or yy == cols:\\n                        continue\\n                    # ignore the cell if it is empty \\'0\\' or visited before \\'2\\'\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # update the fresh oranges count\\n                    fresh_cnt -= 1\\n                    \\n                    # mark the current fresh orange as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # add the current rotten to the queue\\n                    rotten.append((xx, yy))\\n\\n        \\n        # return the number of minutes taken to make all the fresh oranges to be rotten\\n        # return -1 if there are fresh oranges left in the grid (there were no adjacent rotten oranges to make them rotten)\\n        return minutes_passed if fresh_cnt == 0 else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\n# Time complexity: O(rows * cols) -> each cell is visited at least once\\n# Space complexity: O(rows * cols) -> in the worst case if all the oranges are rotten they will be added to the queue\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # number of rows\\n        rows = len(grid)\\n        if rows == 0:  # check if grid is empty\\n            return -1\\n        \\n        # number of columns\\n        cols = len(grid[0])\\n        \\n        # keep track of fresh oranges\\n        fresh_cnt = 0\\n        \\n        # queue with rotten oranges (for BFS)\\n        rotten = deque()\\n        \\n        # visit each cell in the grid\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    # add the rotten orange coordinates to the queue\\n                    rotten.append((r, c))\\n                elif grid[r][c] == 1:\\n                    # update fresh oranges count\\n                    fresh_cnt += 1\\n        \\n        # keep track of minutes passed.\\n        minutes_passed = 0\\n        \\n        # If there are rotten oranges in the queue and there are still fresh oranges in the grid keep looping\\n        while rotten and fresh_cnt > 0:\\n\\n            # update the number of minutes passed\\n            # it is safe to update the minutes by 1, since we visit oranges level by level in BFS traversal.\\n            minutes_passed += 1\\n            \\n            # process rotten oranges on the current level\\n            for _ in range(len(rotten)):\\n                x, y = rotten.popleft()\\n                \\n                # visit all the adjacent cells\\n                for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    # calculate the coordinates of the adjacent cell\\n                    xx, yy = x + dx, y + dy\\n                    # ignore the cell if it is out of the grid boundary\\n                    if xx < 0 or xx == rows or yy < 0 or yy == cols:\\n                        continue\\n                    # ignore the cell if it is empty \\'0\\' or visited before \\'2\\'\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # update the fresh oranges count\\n                    fresh_cnt -= 1\\n                    \\n                    # mark the current fresh orange as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # add the current rotten to the queue\\n                    rotten.append((xx, yy))\\n\\n        \\n        # return the number of minutes taken to make all the fresh oranges to be rotten\\n        # return -1 if there are fresh oranges left in the grid (there were no adjacent rotten oranges to make them rotten)\\n        return minutes_passed if fresh_cnt == 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238681,
                "title": "java-clean-bfs-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int count_fresh = 0;\\n        //Put the position of all rotten oranges in queue\\n        //count the number of fresh oranges\\n        for(int i = 0 ; i < rows ; i++) {\\n            for(int j = 0 ; j < cols ; j++) {\\n                if(grid[i][j] == 2) {\\n                    queue.offer(new int[]{i , j});\\n                }\\n                else if(grid[i][j] == 1) {\\n                    count_fresh++;\\n                }\\n            }\\n        }\\n        //if count of fresh oranges is zero --> return 0 \\n        if(count_fresh == 0) return 0;\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        //bfs starting from initially rotten oranges\\n        while(!queue.isEmpty()) {\\n            ++count;\\n            int size = queue.size();\\n            for(int i = 0 ; i < size ; i++) {\\n                int[] point = queue.poll();\\n                for(int dir[] : dirs) {\\n                    int x = point[0] + dir[0];\\n                    int y = point[1] + dir[1];\\n                    //if x or y is out of bound\\n                    //or the orange at (x , y) is already rotten\\n                    //or the cell at (x , y) is empty\\n                        //we do nothing\\n                    if(x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2) continue;\\n                    //mark the orange at (x , y) as rotten\\n                    grid[x][y] = 2;\\n                    //put the new rotten orange at (x , y) in queue\\n                    queue.offer(new int[]{x , y});\\n                    //decrease the count of fresh oranges by 1\\n                    count_fresh--;\\n                }\\n            }\\n        }\\n        return count_fresh == 0 ? count-1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int count_fresh = 0;\\n        //Put the position of all rotten oranges in queue\\n        //count the number of fresh oranges\\n        for(int i = 0 ; i < rows ; i++) {\\n            for(int j = 0 ; j < cols ; j++) {\\n                if(grid[i][j] == 2) {\\n                    queue.offer(new int[]{i , j});\\n                }\\n                else if(grid[i][j] == 1) {\\n                    count_fresh++;\\n                }\\n            }\\n        }\\n        //if count of fresh oranges is zero --> return 0 \\n        if(count_fresh == 0) return 0;\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        //bfs starting from initially rotten oranges\\n        while(!queue.isEmpty()) {\\n            ++count;\\n            int size = queue.size();\\n            for(int i = 0 ; i < size ; i++) {\\n                int[] point = queue.poll();\\n                for(int dir[] : dirs) {\\n                    int x = point[0] + dir[0];\\n                    int y = point[1] + dir[1];\\n                    //if x or y is out of bound\\n                    //or the orange at (x , y) is already rotten\\n                    //or the cell at (x , y) is empty\\n                        //we do nothing\\n                    if(x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2) continue;\\n                    //mark the orange at (x , y) as rotten\\n                    grid[x][y] = 2;\\n                    //put the new rotten orange at (x , y) in queue\\n                    queue.offer(new int[]{x , y});\\n                    //decrease the count of fresh oranges by 1\\n                    count_fresh--;\\n                }\\n            }\\n        }\\n        return count_fresh == 0 ? count-1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588024,
                "title": "c-bfs-100-space-95-time-explanation-of-logic",
                "content": "The trick is to start bfs from all initial rotten oranges simultaneously to get minimum time, this way any oranges that can get rotten due to more than 1 initially rotten oranges will be covered by the nearest one.\\n\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        \\n        vector<int> dir={-1,0,1,0,-1}; //used for finding all 4 adjacent coordinates\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        int fresh=0; //To keep track of all fresh oranges left\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                    q.push({i,j});\\n                if(grid[i][j]==1)\\n                    fresh++;\\n            }\\n        int ans=-1; //initialised to -1 since after each step we increment the time by 1 and initially all rotten oranges started at 0.\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int r=p.first+dir[i];\\n                    int c=p.second+dir[i+1];\\n                    if(r>=0 && r<m && c>=0 && c<n &&grid[r][c]==1)\\n                    {\\n                        grid[r][c]=2;\\n                        q.push({r,c});\\n                        fresh--; // decrement by 1 foreach fresh orange that now is rotten\\n                    }\\n                    \\n                }\\n            }\\n            ans++; //incremented after each minute passes\\n        }\\n        if(fresh>0) return -1; //if fresh>0 that means there are fresh oranges left\\n        if(ans==-1) return 0; //we initialised with -1, so if there were no oranges it\\'d take 0 mins.\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nPlease upvote if you like the solution and explanation.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        \\n        vector<int> dir={-1,0,1,0,-1}; //used for finding all 4 adjacent coordinates\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        int fresh=0; //To keep track of all fresh oranges left\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                    q.push({i,j});\\n                if(grid[i][j]==1)\\n                    fresh++;\\n            }\\n        int ans=-1; //initialised to -1 since after each step we increment the time by 1 and initially all rotten oranges started at 0.\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int r=p.first+dir[i];\\n                    int c=p.second+dir[i+1];\\n                    if(r>=0 && r<m && c>=0 && c<n &&grid[r][c]==1)\\n                    {\\n                        grid[r][c]=2;\\n                        q.push({r,c});\\n                        fresh--; // decrement by 1 foreach fresh orange that now is rotten\\n                    }\\n                    \\n                }\\n            }\\n            ans++; //incremented after each minute passes\\n        }\\n        if(fresh>0) return -1; //if fresh>0 that means there are fresh oranges left\\n        if(ans==-1) return 0; //we initialised with -1, so if there were no oranges it\\'d take 0 mins.\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602284,
                "title": "java-dfs-beats-100",
                "content": "Posting this here since I couldn\\'t find a DFS solution in discussions\\n\\n```\\nclass Solution {\\n    \\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return -1;\\n        \\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                if(grid[i][j] == 2) rotAdjacent(grid, i, j, 2);\\n            }\\n        }\\n        \\n        int minutes = 2;\\n        for(int[] row : grid) {\\n            for(int cell : row) {\\n                if(cell == 1) return -1;\\n                minutes = Math.max(minutes, cell);\\n            }\\n        }\\n        \\n        return minutes - 2;\\n    }\\n    \\n    private void rotAdjacent(int[][] grid, int i, int j, int minutes) {\\n        if(i < 0 || i >= grid.length /* out of bounds */\\n          || j < 0 || j >= grid[0].length /* out of bounds */\\n          || grid[i][j] == 0 /* empty cell */\\n          || (1 < grid[i][j] && grid[i][j] < minutes) /* this orange is already rotten by another rotten orange */\\n          ) return;\\n        else {\\n            grid[i][j] = minutes;\\n            rotAdjacent(grid, i - 1, j, minutes + 1);\\n            rotAdjacent(grid, i + 1, j, minutes + 1);\\n            rotAdjacent(grid, i, j - 1, minutes + 1);\\n            rotAdjacent(grid, i, j + 1, minutes + 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return -1;\\n        \\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                if(grid[i][j] == 2) rotAdjacent(grid, i, j, 2);\\n            }\\n        }\\n        \\n        int minutes = 2;\\n        for(int[] row : grid) {\\n            for(int cell : row) {\\n                if(cell == 1) return -1;\\n                minutes = Math.max(minutes, cell);\\n            }\\n        }\\n        \\n        return minutes - 2;\\n    }\\n    \\n    private void rotAdjacent(int[][] grid, int i, int j, int minutes) {\\n        if(i < 0 || i >= grid.length /* out of bounds */\\n          || j < 0 || j >= grid[0].length /* out of bounds */\\n          || grid[i][j] == 0 /* empty cell */\\n          || (1 < grid[i][j] && grid[i][j] < minutes) /* this orange is already rotten by another rotten orange */\\n          ) return;\\n        else {\\n            grid[i][j] = minutes;\\n            rotAdjacent(grid, i - 1, j, minutes + 1);\\n            rotAdjacent(grid, i + 1, j, minutes + 1);\\n            rotAdjacent(grid, i, j - 1, minutes + 1);\\n            rotAdjacent(grid, i, j + 1, minutes + 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238579,
                "title": "c-java-with-picture-bfs",
                "content": "First, count ```fresh``` oranges. Then, until ```fresh``` is non-zero, perform BFS to rot oranges, decreasing ```fresh```. Count days (```d```) and return it in the end. If, after another day, ```fresh``` does not change, return ```-1```.\\n\\nFor BFS, we can use the day counter (```d + 2```) to only process oranges that rotted yesterday.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1550377228.png)\\n```\\nint rot(vector<vector<int>>& g, int i, int j, int d) {\\n  if (i < 0 || j < 0 || i >= g.size() || j >= g[i].size() || g[i][j] != 1) return 0;\\n  g[i][j] = d + 3;\\n  return 1;\\n}\\nint orangesRotting(vector<vector<int>>& g, int d = 0, int fresh = 0) {\\n  for (auto i = 0; i < g.size(); ++i) \\n    fresh += count_if(begin(g[i]), end(g[i]), [](int j) { return j == 1; });\\n  for (auto old_fresh = fresh; fresh > 0; ++d) {\\n    for (auto i = 0; i < g.size(); ++i)\\n      for (auto j = 0; j < g[i].size(); ++j)\\n        if (g[i][j] == d + 2)\\n          fresh -= rot(g,i+1,j,d) + rot(g,i-1,j,d) + rot(g,i,j+1,d) + rot(g,i,j-1,d);\\n    if (fresh == exchange(old_fresh, fresh)) return -1;\\n  }\\n  return d;\\n}\\n```\\nJava version:\\n```\\nprivate int rot(int[][] g, int i, int j, int d) {\\n  if (i < 0 || j < 0 || i >= g.length || j >= g[i].length || g[i][j] != 1) return 0;\\n  g[i][j] = d + 3;\\n  return 1;\\n}\\npublic int orangesRotting(int[][] g) {\\n  int fresh = 0, d = 0;\\n  for (int i = 0; i < g.length; ++i)\\n    for (int j = 0; j < g[i].length; ++j)\\n      if (g[i][j] == 1) ++fresh;\\n  for (int old_fresh = fresh; fresh > 0; ++d, old_fresh = fresh) {\\n    for (int i = 0; i < g.length; ++i)\\n      for (int j = 0; j < g[i].length; ++j)\\n        if (g[i][j] == d + 2)\\n          fresh -= rot(g, i + 1, j, d) + rot(g, i - 1, j, d) + rot(g, i, j + 1, d) + rot(g, i, j - 1, d);\\n    if (fresh == old_fresh) return -1;\\n  }\\n  return d;\\n}\\n```\\n## Complexity Analysis\\n**Time**: *O(h * w * (h + w))*, where ```h``` and ```w``` are the dimension of the grid. We are scanning *h + w* times (maximum distance between two cells) through all grid cells.\\n**Memory:** O(1).",
                "solutionTags": [],
                "code": "```fresh```\n```fresh```\n```fresh```\n```d```\n```fresh```\n```-1```\n```d + 2```\n```\\nint rot(vector<vector<int>>& g, int i, int j, int d) {\\n  if (i < 0 || j < 0 || i >= g.size() || j >= g[i].size() || g[i][j] != 1) return 0;\\n  g[i][j] = d + 3;\\n  return 1;\\n}\\nint orangesRotting(vector<vector<int>>& g, int d = 0, int fresh = 0) {\\n  for (auto i = 0; i < g.size(); ++i) \\n    fresh += count_if(begin(g[i]), end(g[i]), [](int j) { return j == 1; });\\n  for (auto old_fresh = fresh; fresh > 0; ++d) {\\n    for (auto i = 0; i < g.size(); ++i)\\n      for (auto j = 0; j < g[i].size(); ++j)\\n        if (g[i][j] == d + 2)\\n          fresh -= rot(g,i+1,j,d) + rot(g,i-1,j,d) + rot(g,i,j+1,d) + rot(g,i,j-1,d);\\n    if (fresh == exchange(old_fresh, fresh)) return -1;\\n  }\\n  return d;\\n}\\n```\n```\\nprivate int rot(int[][] g, int i, int j, int d) {\\n  if (i < 0 || j < 0 || i >= g.length || j >= g[i].length || g[i][j] != 1) return 0;\\n  g[i][j] = d + 3;\\n  return 1;\\n}\\npublic int orangesRotting(int[][] g) {\\n  int fresh = 0, d = 0;\\n  for (int i = 0; i < g.length; ++i)\\n    for (int j = 0; j < g[i].length; ++j)\\n      if (g[i][j] == 1) ++fresh;\\n  for (int old_fresh = fresh; fresh > 0; ++d, old_fresh = fresh) {\\n    for (int i = 0; i < g.length; ++i)\\n      for (int j = 0; j < g[i].length; ++j)\\n        if (g[i][j] == d + 2)\\n          fresh -= rot(g, i + 1, j, d) + rot(g, i - 1, j, d) + rot(g, i, j + 1, d) + rot(g, i, j - 1, d);\\n    if (fresh == old_fresh) return -1;\\n  }\\n  return d;\\n}\\n```\n```h```\n```w```",
                "codeTag": "Unknown"
            },
            {
                "id": 388104,
                "title": "python-10-lines-bfs-beat-97",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        row, col = len(grid), len(grid[0])\\n        rotting = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 2}\\n        fresh = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 1}\\n        timer = 0\\n        while fresh:\\n            if not rotting: return -1\\n            rotting = {(i+di, j+dj) for i, j in rotting for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)] if (i+di, j+dj) in fresh}\\n            fresh -= rotting\\n            timer += 1\\n        return timer\\n```\\nThis is why I love coding in Python ;)",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        row, col = len(grid), len(grid[0])\\n        rotting = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 2}\\n        fresh = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 1}\\n        timer = 0\\n        while fresh:\\n            if not rotting: return -1\\n            rotting = {(i+di, j+dj) for i, j in rotting for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)] if (i+di, j+dj) in fresh}\\n            fresh -= rotting\\n            timer += 1\\n        return timer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166554,
                "title": "c-bfs-easiest-beginner-friendly-sol-o-n-2-time-and-o-n-2-space",
                "content": "# Intuition of this Problem:\\nSame type of bfs approach will work as shown in below picture.\\n![image.png](https://assets.leetcode.com/users/images/07344800-1fe0-437c-9914-35050cbc7646_1676003575.8403783.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create a visited grid to store the state of the cell (fresh, rotten, or empty).\\n2. Initialize a queue to store the rotten oranges and count the number of fresh oranges.\\n3. Check if there are no fresh oranges, return 0, or if there are no rotten oranges, return -1.\\n4. Loop while the queue is not empty.\\n    - a. Store the size of the queue.\\n    - b. Loop through the size of the queue.\\n        - i. Get the front cell of the queue.\\n        - ii. Check all four directions of the cell to see if there are any fresh oranges.\\n        - iii. If there is a fresh orange, change its state to rotten and decrement the count of fresh oranges, and push the cell into the queue.\\n    - c. Increment the minutes.\\n1. If there are no fresh oranges, return the minutes.\\n2. If there are still fresh oranges, return -1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited = grid;\\n        //making queue in which we will fill rotten oranges\\n        queue<pair<int, int>> q;\\n        int countFreshOrange = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.push({i, j});\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++;\\n                }\\n            }\\n        }\\n        //q.empty() means there is no rotten orange in the grid and countFreshOrange = 0 means we will rotten the freshoranges in 0 mins\\n        if (countFreshOrange == 0)\\n            return 0;\\n        if (q.empty())\\n            return -1;\\n        \\n        int minutes = -1;\\n        // we will cover four directions i.e. up, down, left, right\\n        vector<pair<int, int>> dirs = {{1, 0},{-1, 0},{0, -1},{0, 1}};\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for (auto [dx, dy] : dirs) {\\n                    int i = x + dx;\\n                    int j = y + dy;\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2;\\n                        countFreshOrange--;\\n                        q.push({i, j});\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        if (countFreshOrange == 0)\\n            return minutes;\\n        return -1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = grid;\\n        Queue<int[]> q = new LinkedList<>();\\n        int countFreshOrange = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.offer(new int[] {i, j});\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++;\\n                }\\n            }\\n        }\\n        if (countFreshOrange == 0)\\n            return 0;\\n        if (q.isEmpty())\\n            return -1;\\n        \\n        int minutes = -1;\\n        int[][] dirs = {{1, 0},{-1, 0},{0, -1},{0, 1}};\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cell = q.poll();\\n                int x = cell[0];\\n                int y = cell[1];\\n                for (int[] dir : dirs) {\\n                    int i = x + dir[0];\\n                    int j = y + dir[1];\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2;\\n                        countFreshOrange--;\\n                        q.offer(new int[] {i, j});\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        if (countFreshOrange == 0)\\n            return minutes;\\n        return -1;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        visited = grid\\n        q = collections.deque()\\n        countFreshOrange = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j] == 2:\\n                    q.append((i, j))\\n                if visited[i][j] == 1:\\n                    countFreshOrange += 1\\n        if countFreshOrange == 0:\\n            return 0\\n        if not q:\\n            return -1\\n        \\n        minutes = -1\\n        dirs = [(1, 0), (-1, 0), (0, -1), (0, 1)]\\n        while q:\\n            size = len(q)\\n            while size > 0:\\n                x, y = q.popleft()\\n                size -= 1\\n                for dx, dy in dirs:\\n                    i, j = x + dx, y + dy\\n                    if 0 <= i < m and 0 <= j < n and visited[i][j] == 1:\\n                        visited[i][j] = 2\\n                        countFreshOrange -= 1\\n                        q.append((i, j))\\n            minutes += 1\\n        \\n        if countFreshOrange == 0:\\n            return minutes\\n        return -1\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(m*n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(m*n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Similar Pattern Problems:\\n1162. As Far from Land as Possible - https://leetcode.com/problems/as-far-from-land-as-possible/description/\\n317. Shortest Distance from All Buildings - https://leetcode.com/problems/shortest-distance-from-all-buildings/description/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited = grid;\\n        //making queue in which we will fill rotten oranges\\n        queue<pair<int, int>> q;\\n        int countFreshOrange = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.push({i, j});\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++;\\n                }\\n            }\\n        }\\n        //q.empty() means there is no rotten orange in the grid and countFreshOrange = 0 means we will rotten the freshoranges in 0 mins\\n        if (countFreshOrange == 0)\\n            return 0;\\n        if (q.empty())\\n            return -1;\\n        \\n        int minutes = -1;\\n        // we will cover four directions i.e. up, down, left, right\\n        vector<pair<int, int>> dirs = {{1, 0},{-1, 0},{0, -1},{0, 1}};\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for (auto [dx, dy] : dirs) {\\n                    int i = x + dx;\\n                    int j = y + dy;\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2;\\n                        countFreshOrange--;\\n                        q.push({i, j});\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        if (countFreshOrange == 0)\\n            return minutes;\\n        return -1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = grid;\\n        Queue<int[]> q = new LinkedList<>();\\n        int countFreshOrange = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.offer(new int[] {i, j});\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++;\\n                }\\n            }\\n        }\\n        if (countFreshOrange == 0)\\n            return 0;\\n        if (q.isEmpty())\\n            return -1;\\n        \\n        int minutes = -1;\\n        int[][] dirs = {{1, 0},{-1, 0},{0, -1},{0, 1}};\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cell = q.poll();\\n                int x = cell[0];\\n                int y = cell[1];\\n                for (int[] dir : dirs) {\\n                    int i = x + dir[0];\\n                    int j = y + dir[1];\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2;\\n                        countFreshOrange--;\\n                        q.offer(new int[] {i, j});\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        if (countFreshOrange == 0)\\n            return minutes;\\n        return -1;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        visited = grid\\n        q = collections.deque()\\n        countFreshOrange = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j] == 2:\\n                    q.append((i, j))\\n                if visited[i][j] == 1:\\n                    countFreshOrange += 1\\n        if countFreshOrange == 0:\\n            return 0\\n        if not q:\\n            return -1\\n        \\n        minutes = -1\\n        dirs = [(1, 0), (-1, 0), (0, -1), (0, 1)]\\n        while q:\\n            size = len(q)\\n            while size > 0:\\n                x, y = q.popleft()\\n                size -= 1\\n                for dx, dy in dirs:\\n                    i, j = x + dx, y + dy\\n                    if 0 <= i < m and 0 <= j < n and visited[i][j] == 1:\\n                        visited[i][j] = 2\\n                        countFreshOrange -= 1\\n                        q.append((i, j))\\n            minutes += 1\\n        \\n        if countFreshOrange == 0:\\n            return minutes\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781642,
                "title": "python-clean-bfs-solution-explained",
                "content": "This is graph traversal problem, so here we have a choise: to use `dfs` or to use `bfs`. What is asked: minimum number of minutes passed until there is no fresh orange. In graphs it means to find the greatest distance from rotten oranges to any other orange. Usually, if we need to find the distances, we use `bfs`. So, let me define my variables:\\n\\n1. `m` and `n` are dimensions of our `grid`, also we have `queue` to run our `bfs` and also we want to count number of fresh oranges: we need this to check in the end if all oranges become rotten or not.\\n2. We put all rotten oranges coordinates to our `queue`, so we are going to start from all of them. Also we count number of fresh oranges.\\n3. Define directions we can go: four of them and put `levels = 0`.\\n\\nNow, we traverse our `grid`, using `bfs`, using level by level traversal: it means, that each time, when we have some elements in `queue`, we popleft all of them and put new neighbours to the end. In this way each time we reach line `levels += 1`, we have nodes with distance which is `1` bigger than previous level. In the end `levels - 1` will be our answer, because one time in the end when we do not have anythin to add, `levels` still be incremented by one.\\n\\nFinally, we check if we still have fresh oranges, and if yes, return `-1`. If not, we need to return `max(levels-1, 0)`, because it can happen, that our queue was empty in the beginning and we do not need to subtract `1`.\\n\\n**Complexity**: time complexity is `O(mn)`, because we first traverse our grid to fill `queue` and found number of fresh oranges. Then we use classical `bfs`, so each node will be added and removed from `queue` at most `1` time. Space complexity is also can be `O(mn)`, we can have for example `O(mn)` rotten oranges in the very beginnig.\\n\\n```\\nclass Solution:\\n    def orangesRotting(self, grid):\\n        m, n, queue, fresh = len(grid), len(grid[0]), deque(), 0\\n        for i,j in product(range(m), range(n)):\\n            if grid[i][j] == 2: queue.append((i,j))\\n            if grid[i][j] == 1: fresh += 1\\n        dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        levels = 0\\n        \\n        while queue:\\n            levels += 1\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                for dx, dy in dirs:\\n                    if 0<=x+dx<m and 0<=y+dy<n and grid[x+dx][y+dy] == 1:\\n                        fresh -= 1\\n                        grid[x+dx][y+dy] = 2\\n                        queue.append((x+dx, y+dy))\\n                        \\n        return -1 if fresh != 0 else max(levels-1, 0)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid):\\n        m, n, queue, fresh = len(grid), len(grid[0]), deque(), 0\\n        for i,j in product(range(m), range(n)):\\n            if grid[i][j] == 2: queue.append((i,j))\\n            if grid[i][j] == 1: fresh += 1\\n        dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        levels = 0\\n        \\n        while queue:\\n            levels += 1\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                for dx, dy in dirs:\\n                    if 0<=x+dx<m and 0<=y+dy<n and grid[x+dx][y+dy] == 1:\\n                        fresh -= 1\\n                        grid[x+dx][y+dy] = 2\\n                        queue.append((x+dx, y+dy))\\n                        \\n        return -1 if fresh != 0 else max(levels-1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238540,
                "title": "python-simple-bfs-solution",
                "content": "simple bfs solution use `all` rotten orange as start position\\n\\nmoreover, I use `cnt` to count the number of `1`, when one fresh orange become rotten orange, `cnt -= 1` ,and once bfs over, the `cnt` should be `0`.\\n\\n```python\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        n,m = len(grid), len(grid[0])\\n        Q = collections.deque([])\\n        cnt = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1: cnt += 1\\n                if grid[i][j] == 2: Q.append((i,j))\\n        res = 0\\n        while Q:\\n            for _ in range(len(Q)):\\n                i,j = Q.popleft()\\n                for x, y in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:\\n                    if 0<=x<n and 0<=y<m and grid[x][y] == 1:\\n                        grid[x][y] = 2\\n                        cnt -= 1\\n                        Q.append((x,y))\\n            res += 1\\n        return max(0, res-1) if cnt == 0 else -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        n,m = len(grid), len(grid[0])\\n        Q = collections.deque([])\\n        cnt = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1: cnt += 1\\n                if grid[i][j] == 2: Q.append((i,j))\\n        res = 0\\n        while Q:\\n            for _ in range(len(Q)):\\n                i,j = Q.popleft()\\n                for x, y in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:\\n                    if 0<=x<n and 0<=y<m and grid[x][y] == 1:\\n                        grid[x][y] = 2\\n                        cnt -= 1\\n                        Q.append((x,y))\\n            res += 1\\n        return max(0, res-1) if cnt == 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304875,
                "title": "java-awesome-bfs-solution-very-easy-to-understand",
                "content": "Firstly, we traverse the whole grid to find out the positions of rotten oranges and compute the total num of orange as well, enqueue the positions of rotten oranges into a queue;\\nSecondly, dequeue to get the position of a rotten orange. Due to the infection, the fresh oranges near the rotten orange become rotten. So we check the cell in the left/right/top/down of the rotten orange, if it is a fresh orange, enqueue it. Continue to dequeue until all rotten oranges of last round are removed from the queue\\n\\nHere are the code\\n```java\\nclass Solution {\\n    // store the position of rotten orange\\n    static class Position {\\n        int x;\\n        int y;\\n        Position(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n\\t\\n    public int orangesRotting(int[][] grid) {\\n        Queue<Position> q = new LinkedList<>();\\n        int total = 0, rotten = 0, time = 0;\\n\\t\\t\\n\\t\\t// traverse the grid, offer position of rotten orange into queue, and count the total num of orange\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 || grid[i][j] == 2) total++;\\n                if (grid[i][j] == 2) q.offer(new Position(i, j));\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if there is no orange, return 0;\\n        if (total == 0) return 0;\\n\\t\\t\\n        while (! q.isEmpty() && rotten < total) {\\n\\t\\t\\t// size is the num of rotten oranges of the last round\\n            int size = q.size();\\n\\t\\t\\t\\n\\t\\t\\t// count the num of rotten oranges, if it equals to total num, return time;\\n            rotten += size;\\n            if (rotten == total) return time;\\n\\t\\t\\t\\n\\t\\t\\t// every round, time ++\\n            time++;\\n\\t\\t\\t\\n\\t\\t\\t// Continue to dequeue until all rotten oranges of last round are removed from the queue\\n            for (int i = 0; i < size; i++) {\\n                Position p = q.peek();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the cell in the left/right/top/down of the rotten orange, if it is a fresh orange, enqueue it.\\n                if (p.x + 1 < grid.length && grid[p.x + 1][p.y] == 1) {\\n                    grid[p.x + 1][p.y] = 2;\\n                    q.offer(new Position(p.x + 1, p.y));\\n                }\\n                if (p.x - 1 >= 0 && grid[p.x - 1][p.y] == 1) {\\n                    grid[p.x - 1][p.y] = 2;\\n                    q.offer(new Position(p.x - 1, p.y));\\n                }\\n                if (p.y + 1 < grid[0].length && grid[p.x][p.y + 1] == 1) {\\n                    grid[p.x][p.y + 1] = 2;\\n                    q.offer(new Position(p.x, p.y + 1));\\n                }\\n                if (p.y - 1 >= 0 && grid[p.x][p.y - 1] == 1) {\\n                    grid[p.x][p.y - 1] = 2;\\n                    q.offer(new Position(p.x, p.y - 1));\\n                }\\n                q.poll();\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    // store the position of rotten orange\\n    static class Position {\\n        int x;\\n        int y;\\n        Position(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n\\t\\n    public int orangesRotting(int[][] grid) {\\n        Queue<Position> q = new LinkedList<>();\\n        int total = 0, rotten = 0, time = 0;\\n\\t\\t\\n\\t\\t// traverse the grid, offer position of rotten orange into queue, and count the total num of orange\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 || grid[i][j] == 2) total++;\\n                if (grid[i][j] == 2) q.offer(new Position(i, j));\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if there is no orange, return 0;\\n        if (total == 0) return 0;\\n\\t\\t\\n        while (! q.isEmpty() && rotten < total) {\\n\\t\\t\\t// size is the num of rotten oranges of the last round\\n            int size = q.size();\\n\\t\\t\\t\\n\\t\\t\\t// count the num of rotten oranges, if it equals to total num, return time;\\n            rotten += size;\\n            if (rotten == total) return time;\\n\\t\\t\\t\\n\\t\\t\\t// every round, time ++\\n            time++;\\n\\t\\t\\t\\n\\t\\t\\t// Continue to dequeue until all rotten oranges of last round are removed from the queue\\n            for (int i = 0; i < size; i++) {\\n                Position p = q.peek();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the cell in the left/right/top/down of the rotten orange, if it is a fresh orange, enqueue it.\\n                if (p.x + 1 < grid.length && grid[p.x + 1][p.y] == 1) {\\n                    grid[p.x + 1][p.y] = 2;\\n                    q.offer(new Position(p.x + 1, p.y));\\n                }\\n                if (p.x - 1 >= 0 && grid[p.x - 1][p.y] == 1) {\\n                    grid[p.x - 1][p.y] = 2;\\n                    q.offer(new Position(p.x - 1, p.y));\\n                }\\n                if (p.y + 1 < grid[0].length && grid[p.x][p.y + 1] == 1) {\\n                    grid[p.x][p.y + 1] = 2;\\n                    q.offer(new Position(p.x, p.y + 1));\\n                }\\n                if (p.y - 1 >= 0 && grid[p.x][p.y - 1] == 1) {\\n                    grid[p.x][p.y - 1] = 2;\\n                    q.offer(new Position(p.x, p.y - 1));\\n                }\\n                q.poll();\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546489,
                "title": "python-bfs-easy-to-understand-with-explanation",
                "content": "### Preamble\\n\\nI\\'ve posted a solution about a similar problem before: [#980 Uinque Paths III](https://leetcode.com/problems/unique-paths-iii/). In my opinion, the solution to this problem follows a similar train of thought, albeit using a different recursive method (BFS instead of DFS). You can read my post for problem #980 [here](https://leetcode.com/problems/unique-paths-iii/discuss/1535158/Python-Backtracking:-Easy-to-understand-with-Explanation) to understand the thought process better before continuing with this post.\\n\\n---\\n\\n### Introduction\\n\\nThe goal is to traverse from every rotting orange (`grid[x][y] == 2`) through every fresh orange (`grid[x][y] == 1`) until all fresh oranges have been visited once (i.e. all fresh oranges have rotten) or no more traversion is possible (i.e. no adjacent fresh oranges are found).\\n\\nSince, for each passing minute, all adjacent fresh oranges become rotten, we need to recursively check for the coordinates of rotting oranges after each iteration. More specifically, we only need to keep track of the oranges that have rotten in that iteration, since 1) that particular coordinate has never been reached before and thus needs to be checked for adjacent oranges; and 2) all previous coordinates have been checked previously and need not be checked again. For this purpose, we can implement a queue:\\n\\n```python\\nfrom collections import deque\\nqueue = deque()\\n# populate with coordinates of rotten oranges\\nfor _ in range(len(queue)):\\n\\tx, y = queue.popleft()  # remove coordinate to check for adjacent fresh oranges\\n\\t# check for fresh oranges...\\n\\tqueue.append((i, j))  # add new rotten orange coordinate\\n```\\n\\nWe also need to keep track of all fresh oranges, since this is our success condition. Fresh oranges are: 1) to be visited, otherwise we should return `-1` if the orange stays fresh, and 2) visited only once, since upon visiting it becomes rotten. To perform `(x, y) in lst` checks and the deletion of `(x, y)` in O(1) time, we can utilise a set:\\n\\n```python\\nvisit = set()\\n# populate with coordinates of fresh oranges\\nwhile visit:\\n\\t# check if adjacent coordinates are rotten oranges...\\n\\tvisit.remove((x, y))  # remove new rotten orange\\n```\\n\\nThis leaves us with the initial population of the data structures, and the actual BFS. We can thus derive the following implementation:\\n\\n1. Loop through `grid` and find the fresh and rotten oranges.\\n2. While there are fresh and rotten oranges to loop through, determine if any fresh oranges will become rotten in that iteration. Repeat for as many iterations as needed (BFS style).\\n3. Return the number of iterations, checking if there are fresh oranges remaining.\\n\\n---\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visit, curr = set(), deque()\\n\\t\\t# find all fresh and rotten oranges\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 2:\\n                    curr.append((i, j))\\n        result = 0\\n        while visit and curr:\\n\\t\\t\\t# BFS iteration\\n            for _ in range(len(curr)):\\n                i, j = curr.popleft()  # obtain recent rotten orange\\n                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                    if coord in visit:  # check if adjacent orange is fresh\\n                        visit.remove(coord)\\n                        curr.append(coord)\\n            result += 1\\n\\t\\t# check if fresh oranges remain and return accordingly\\n        return -1 if visit else result\\n```\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/22554cf6-69a9-4982-99c1-dab6c0dad0f5_1635479399.4226873.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```python\\nfrom collections import deque\\nqueue = deque()\\n# populate with coordinates of rotten oranges\\nfor _ in range(len(queue)):\\n\\tx, y = queue.popleft()  # remove coordinate to check for adjacent fresh oranges\\n\\t# check for fresh oranges...\\n\\tqueue.append((i, j))  # add new rotten orange coordinate\\n```\n```python\\nvisit = set()\\n# populate with coordinates of fresh oranges\\nwhile visit:\\n\\t# check if adjacent coordinates are rotten oranges...\\n\\tvisit.remove((x, y))  # remove new rotten orange\\n```\n```python\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visit, curr = set(), deque()\\n\\t\\t# find all fresh and rotten oranges\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 2:\\n                    curr.append((i, j))\\n        result = 0\\n        while visit and curr:\\n\\t\\t\\t# BFS iteration\\n            for _ in range(len(curr)):\\n                i, j = curr.popleft()  # obtain recent rotten orange\\n                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                    if coord in visit:  # check if adjacent orange is fresh\\n                        visit.remove(coord)\\n                        curr.append(coord)\\n            result += 1\\n\\t\\t# check if fresh oranges remain and return accordingly\\n        return -1 if visit else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241139,
                "title": "c-super-easy-and-clean-solution-beats-100-time-and-100-space",
                "content": "```\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ct=0, res=-1;\\n        queue<vector<int>> q;\\n        vector<vector<int>> dir={{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for(int i=0;i<grid.size();i++) {\\n            for(int j=0;j<grid[0].size();j++) {\\n                if(grid[i][j]>0) ct++;\\n                if(grid[i][j]==2) q.push({i, j});\\n            }\\n        }\\n        while(!q.empty()) {\\n            res++;\\n            int size=q.size();\\n            for(int k=0;k<size;k++) {\\n                vector<int> cur=q.front();\\n                ct--;\\n                q.pop();\\n                for(int i=0;i<4;i++) {\\n                    int x=cur[0]+dir[i][0], y=cur[1]+dir[i][1];\\n                    if(x>=grid.size()||x<0||y>=grid[0].size()||y<0||grid[x][y]!=1) continue;\\n                    grid[x][y]=2;\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        if(ct==0) return max(0, res);\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ct=0, res=-1;\\n        queue<vector<int>> q;\\n        vector<vector<int>> dir={{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for(int i=0;i<grid.size();i++) {\\n            for(int j=0;j<grid[0].size();j++) {\\n                if(grid[i][j]>0) ct++;\\n                if(grid[i][j]==2) q.push({i, j});\\n            }\\n        }\\n        while(!q.empty()) {\\n            res++;\\n            int size=q.size();\\n            for(int k=0;k<size;k++) {\\n                vector<int> cur=q.front();\\n                ct--;\\n                q.pop();\\n                for(int i=0;i<4;i++) {\\n                    int x=cur[0]+dir[i][0], y=cur[1]+dir[i][1];\\n                    if(x>=grid.size()||x<0||y>=grid[0].size()||y<0||grid[x][y]!=1) continue;\\n                    grid[x][y]=2;\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        if(ct==0) return max(0, res);\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 782041,
                "title": "c-with-comments-very-easy-to-read-and-understand-covers-pitfalls-no-prerequisites",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        // initialize a queue which will help us find answer\\n        \\n        queue<pair<int,int> > q; \\n        \\n        int n=grid.size(),m=grid[0].size(),ans=0,ones=0,twos=0;\\n        \\n        // n is the number of columns and m is the number of rows\\n        // \\'ans\\' stands for \\'answer\\' which we will return at the end ;) .\\n        \\n        \\n        //  now lets traverse through the grid\\n        //  Observe that, here we are not using \\'auto\\' because we need to store positions of \\'2\\'s\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    twos++;// here we count the number of \\'2\\'s in the grid\\n                    \\n                    q.push(make_pair(i,j));\\n                    \\n                    // here we collect all positions of \\'2\\'s in our queue \\n                    // so that our search can be initialised fron them\\n                    \\n                }\\n                else if(grid[i][j]==1)ones++; // here we count the number of \\'1\\'s in the grid\\n            }\\n        }\\n        \\n        // Observe that, in this loop we have visited each cell, so time complexity has reached O(n*m) .  \\n        \\n        \\n        // ******************* Actual Solution Starts Here, Have Fun :)  ************* .\\n        \\n        // if there are no fresh oranges (ones) present, time required is zero\\n        if(ones==0)return 0; \\n        \\n        // Now as the control has passed the above conditions, it means it has some fresh oranes. \\n        // Hence, If there are no rotten oranges, fresh oranges will not rot and we will have to return (-1) . \\n        \\n        else if(twos==0)return -1;\\n        \\n        // Now we will have to do Breadth-First-Search to find the minimum time\\n        \\n        int cnt1=twos,cnt2=0;\\n        // cnt1 stores the number of unvisited nodes or oranges which are \\n        // going to affect its neighbours at the current moment\\n        \\n        // cnt2 is going to store number of childs of the oranges in the current level\\n        // Don\\'t worry if you didn\\'t get that line, I got you covered below ;) .\\n        \\n        **// Observe that, The first level is already rotten, \\n        // still we are counting it and hence at the end we return (ans-1) instead of ans . **\\n        \\n        while(!q.empty()){\\n            pair<int,int> p=q.front();\\n            q.pop();\\n            int y=p.first,x=p.second;\\n            // Everytime we pop, unvisited oranges in current level decreases by one, hence cnt1-- .\\n            cnt1--;\\n            \\n            // Now we put forward four conditions to check in four directions of the current orange\\n            // But for that to work, the position should exist , \\n            // i.e.  it should not cross the bounds of the grid\\n            \\n            if(y>0){\\n                if(grid[y-1][x]==1){\\n                    cnt2++;\\n                    grid[y-1][x]=2;\\n                    ones--; \\n                    // one became two \\n                    // and number of childs i.e. cnt2 increased by one\\n                    // and lets add it to the queue to check if it has any children later\\n                    q.push(make_pair(y-1,x));\\n                }\\n            }\\n            if(y<n-1){\\n                if(grid[y+1][x]==1){\\n                    cnt2++;\\n                    grid[y+1][x]=2;\\n                    ones--;\\n                    q.push(make_pair(y+1,x));\\n                }\\n            }\\n            if(x>0){\\n                if(grid[y][x-1]==1){\\n                    cnt2++;\\n                    grid[y][x-1]=2;\\n                    ones--;\\n                    q.push(make_pair(y,x-1));\\n                }\\n            }\\n            if(x<m-1){\\n                if(grid[y][x+1]==1){\\n                    cnt2++;\\n                    ones--;\\n                    grid[y][x+1]=2;\\n                    q.push(make_pair(y,x+1));\\n                }\\n            }\\n            if(cnt1==0){\\n                // cnt1 is zero means we have completed traversing the current level of the graph\\n                // and hence one unit of time is passed. Hence we increrment ans\\n                // lets go to next level, for that cnt2 becomes cnt1 and cnt2 becomes zero, \\n                // i.e. children are upgraded to current generation and child count start again from zero.\\n                ans++;\\n                cnt1=cnt2;\\n                cnt2=0;\\n            }\\n        }\\n        \\n        // if there are some ones\\' which are  still not visited, then they will never get rotten, \\n\\t\\t// Good for them xD .\\n        if(ones>0)return -1; \\n        \\n        // else\\n        return ans-1;\\n        \\n    }\\n\\t\\n// We have traversed the graph level-by-level, hence this technique is called as\\n// Breadth First Search or BFS.\\n    \\n    // I am sure you have understood the solution :) .\\n    // If Not, Feel free to comment.    \\n    \\n    // Don\\'t hesitate in Upvoting and sharing this solution if you like it ;)) .\\n\\t// Happy Coding :) .\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        // initialize a queue which will help us find answer\\n        \\n        queue<pair<int,int> > q; \\n        \\n        int n=grid.size(),m=grid[0].size(),ans=0,ones=0,twos=0;\\n        \\n        // n is the number of columns and m is the number of rows\\n        // \\'ans\\' stands for \\'answer\\' which we will return at the end ;) .\\n        \\n        \\n        //  now lets traverse through the grid\\n        //  Observe that, here we are not using \\'auto\\' because we need to store positions of \\'2\\'s\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    twos++;// here we count the number of \\'2\\'s in the grid\\n                    \\n                    q.push(make_pair(i,j));\\n                    \\n                    // here we collect all positions of \\'2\\'s in our queue \\n                    // so that our search can be initialised fron them\\n                    \\n                }\\n                else if(grid[i][j]==1)ones++; // here we count the number of \\'1\\'s in the grid\\n            }\\n        }\\n        \\n        // Observe that, in this loop we have visited each cell, so time complexity has reached O(n*m) .  \\n        \\n        \\n        // ******************* Actual Solution Starts Here, Have Fun :)  ************* .\\n        \\n        // if there are no fresh oranges (ones) present, time required is zero\\n        if(ones==0)return 0; \\n        \\n        // Now as the control has passed the above conditions, it means it has some fresh oranes. \\n        // Hence, If there are no rotten oranges, fresh oranges will not rot and we will have to return (-1) . \\n        \\n        else if(twos==0)return -1;\\n        \\n        // Now we will have to do Breadth-First-Search to find the minimum time\\n        \\n        int cnt1=twos,cnt2=0;\\n        // cnt1 stores the number of unvisited nodes or oranges which are \\n        // going to affect its neighbours at the current moment\\n        \\n        // cnt2 is going to store number of childs of the oranges in the current level\\n        // Don\\'t worry if you didn\\'t get that line, I got you covered below ;) .\\n        \\n        **// Observe that, The first level is already rotten, \\n        // still we are counting it and hence at the end we return (ans-1) instead of ans . **\\n        \\n        while(!q.empty()){\\n            pair<int,int> p=q.front();\\n            q.pop();\\n            int y=p.first,x=p.second;\\n            // Everytime we pop, unvisited oranges in current level decreases by one, hence cnt1-- .\\n            cnt1--;\\n            \\n            // Now we put forward four conditions to check in four directions of the current orange\\n            // But for that to work, the position should exist , \\n            // i.e.  it should not cross the bounds of the grid\\n            \\n            if(y>0){\\n                if(grid[y-1][x]==1){\\n                    cnt2++;\\n                    grid[y-1][x]=2;\\n                    ones--; \\n                    // one became two \\n                    // and number of childs i.e. cnt2 increased by one\\n                    // and lets add it to the queue to check if it has any children later\\n                    q.push(make_pair(y-1,x));\\n                }\\n            }\\n            if(y<n-1){\\n                if(grid[y+1][x]==1){\\n                    cnt2++;\\n                    grid[y+1][x]=2;\\n                    ones--;\\n                    q.push(make_pair(y+1,x));\\n                }\\n            }\\n            if(x>0){\\n                if(grid[y][x-1]==1){\\n                    cnt2++;\\n                    grid[y][x-1]=2;\\n                    ones--;\\n                    q.push(make_pair(y,x-1));\\n                }\\n            }\\n            if(x<m-1){\\n                if(grid[y][x+1]==1){\\n                    cnt2++;\\n                    ones--;\\n                    grid[y][x+1]=2;\\n                    q.push(make_pair(y,x+1));\\n                }\\n            }\\n            if(cnt1==0){\\n                // cnt1 is zero means we have completed traversing the current level of the graph\\n                // and hence one unit of time is passed. Hence we increrment ans\\n                // lets go to next level, for that cnt2 becomes cnt1 and cnt2 becomes zero, \\n                // i.e. children are upgraded to current generation and child count start again from zero.\\n                ans++;\\n                cnt1=cnt2;\\n                cnt2=0;\\n            }\\n        }\\n        \\n        // if there are some ones\\' which are  still not visited, then they will never get rotten, \\n\\t\\t// Good for them xD .\\n        if(ones>0)return -1; \\n        \\n        // else\\n        return ans-1;\\n        \\n    }\\n\\t\\n// We have traversed the graph level-by-level, hence this technique is called as\\n// Breadth First Search or BFS.\\n    \\n    // I am sure you have understood the solution :) .\\n    // If Not, Feel free to comment.    \\n    \\n    // Don\\'t hesitate in Upvoting and sharing this solution if you like it ;)) .\\n\\t// Happy Coding :) .\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892106,
                "title": "easy-c-bfs-solution-well-explained",
                "content": "```\\n/* (https://leetcode.com/problems/rotting-oranges/submissions/)\\n\\nSolution based on BFS.\\n*/\\nclass Solution\\n{\\npublic:\\n    int orangesRotting(vector<vector<int>> &grid)\\n    {\\n        if (grid.empty()) // if there is no orange.\\n            return 0;\\n\\n        int countFreshOranges = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        queue<pair<int, int>> q; // queue to store the index of the cell where rotten oranges are placed.\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                    countFreshOranges++;\\n                else if (grid[i][j] == 2)\\n                    q.push({i, j});\\n            }\\n        }\\n\\n        int time = 0;\\n        // four adjacent positions at which the oranged placed will get rotten.\\n        vector<pair<int, int>> dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n\\n        while (countFreshOranges != 0 && !q.empty())\\n        {\\n            int qsize = q.size();\\n\\n            for (int i = 0; i < qsize; i++)\\n            {\\n                int rottenI = q.front().first;\\n                int rottenJ = q.front().second;\\n                q.pop();\\n\\n                for (auto d : dirs)\\n                {\\n                    int newX = rottenI + d.first;\\n                    int newY = rottenJ + d.second;\\n                    // if we got any fresh orange adjacent to the rotten orange then it will get rotten and\\n                    // count of fresh oranges will reduce and we will push the new index of rotten orange in \\n                    // the queue.\\n                    if (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == 1)\\n                    {\\n                        grid[newX][newY] = 2;\\n                        countFreshOranges--;\\n                        q.push({newX, newY});\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return countFreshOranges == 0 ? time : -1;\\n    }\\n};\\n```\\n**If you like the solution then please upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/* (https://leetcode.com/problems/rotting-oranges/submissions/)\\n\\nSolution based on BFS.\\n*/\\nclass Solution\\n{\\npublic:\\n    int orangesRotting(vector<vector<int>> &grid)\\n    {\\n        if (grid.empty()) // if there is no orange.\\n            return 0;\\n\\n        int countFreshOranges = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        queue<pair<int, int>> q; // queue to store the index of the cell where rotten oranges are placed.\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                    countFreshOranges++;\\n                else if (grid[i][j] == 2)\\n                    q.push({i, j});\\n            }\\n        }\\n\\n        int time = 0;\\n        // four adjacent positions at which the oranged placed will get rotten.\\n        vector<pair<int, int>> dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n\\n        while (countFreshOranges != 0 && !q.empty())\\n        {\\n            int qsize = q.size();\\n\\n            for (int i = 0; i < qsize; i++)\\n            {\\n                int rottenI = q.front().first;\\n                int rottenJ = q.front().second;\\n                q.pop();\\n\\n                for (auto d : dirs)\\n                {\\n                    int newX = rottenI + d.first;\\n                    int newY = rottenJ + d.second;\\n                    // if we got any fresh orange adjacent to the rotten orange then it will get rotten and\\n                    // count of fresh oranges will reduce and we will push the new index of rotten orange in \\n                    // the queue.\\n                    if (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == 1)\\n                    {\\n                        grid[newX][newY] = 2;\\n                        countFreshOranges--;\\n                        q.push({newX, newY});\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return countFreshOranges == 0 ? time : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858396,
                "title": "javascript-clean-bfs-w-explanation-99-5",
                "content": "![image](https://assets.leetcode.com/users/images/41c78fd9-b93d-4cd0-9fcb-f49d94318d25_1647533000.361992.png)\\n\\nVersion w/o Explanation: (Commented version below)\\n```\\nvar orangesRotting = function(grid) {\\n  let queue = [], oranges = 0, time = 0;\\n  \\n  for (let r = 0; r < grid.length; r++) {\\n    for (let c = 0; c < grid[r].length; c++) {\\n      if (grid[r][c] === 1) oranges++\\n      else if (grid[r][c] === 2) queue.push([r,c,0]);\\n    }\\n  }\\n    \\n  const dirs = [[0,1], [1,0], [0,-1], [-1,0]];\\n  const endR = grid.length - 1, endC = grid[0].length - 1;\\n  \\n  while (queue.length && oranges) {\\n    const [curR, curC, mins] = queue.shift();\\n    \\n    if (grid[curR][curC] === 1) {\\n      grid[curR][curC] = 2;\\n      oranges--;\\n      time = mins;\\n    }\\n\\n    for (let [addR, addC] of dirs) {\\n      const [newR, newC] = [curR + addR, curC + addC];\\n      if (newR < 0 || newR > endR || newC < 0 || newC > endC) continue;\\n      if (grid[newR][newC] === 1) {\\n        queue.push([newR, newC, mins + 1])\\n      }\\n    }\\n  }\\n  \\n  return oranges ? -1 : time;\\n};\\n```\\n\\nVersion w/ Explanation:\\n```\\nvar orangesRotting = function(grid) {\\n  //Initialize queue for our BFS, Number of fresh oranges, and time to be returned.\\n  let queue = [], oranges = 0, time = 0;\\n  \\n  //Traverse matrix.  If we find a fresh orange, increment orange count.\\n  //If we find a rotten one, add it to the queue.\\n  for (let r = 0; r < grid.length; r++) {\\n    for (let c = 0; c < grid[r].length; c++) {\\n      if (grid[r][c] === 1) oranges++\\n      else if (grid[r][c] === 2) queue.push([r,c,0]);\\n    }\\n  }\\n    \\n  //Dirs will help us check neighbors during our BFS.  Adding these coordinates\\n  //to a point just gets right, left, up and down.  endR and endC are used later\\n  //to make sure neighbor coords are within grid.\\n  const dirs = [[0,1], [1,0], [0,-1], [-1,0]];\\n  const endR = grid.length - 1, endC = grid[0].length - 1;\\n  \\n  //Loop while queue is not empty and there are still fresh oranges.\\n  while (queue.length && oranges) {\\n  \\n\\t//Entry within queue can be destructured to make it easier to work with.\\n\\t//Each queue entry has a row, column and number of minutes taken for\\n\\t//infection to reach.\\n    const [curR, curC, mins] = queue.shift();\\n    \\n\\t//If orange is still fresh, we mark it as rotten, decrement our fresh oranges\\n\\t//count and set time to = mins.  Since we BFSing, the time it takes to infect\\n\\t//the last orange will be the time to infect all.  Once all oranges have\\n\\t//been infected, our orange count will = 0 and our condition in while loop\\n\\t//will stop the loop.  Time can then be returned.\\n    if (grid[curR][curC] === 1) {\\n      grid[curR][curC] = 2;\\n      oranges--;\\n      time = mins;\\n    }\\n\\n    //Here\\'s where our dir array above comes in handy.  We destructure\\n\\t//each entry and add it to our current to get neighbor coords below.\\n    for (let [addR, addC] of dirs) {\\n\\t\\n\\t  //Here we obtain our new or neighbor coordinates by adding currentRow\\n\\t  //and addRow of dir.  Same for col.\\n      const [newR, newC] = [curR + addR, curC + addC];\\n\\t  \\n\\t  //Here we check to make sure new coordinates lie within the grid.\\n      if (newR < 0 || newR > endR || newC < 0 || newC > endC) continue;\\n\\t  \\n\\t  //If neighbor coord is valid, and there is a fresh orange at those coordinates\\n\\t  //we push coordinates to our BFS to be infected next.  We also increment the\\n\\t  //mins count to track time taken to spread to that orange.\\n      if (grid[newR][newC] === 1) {\\n        queue.push([newR, newC, mins + 1])\\n      }\\n    }\\n  }\\n  \\n  //If we still have uninfected oranges, we return -1 because it won\\'t spread\\n  //to all.  Otherwise, we simply return the time from initial infected to last\\n  //infected orange.\\n  return oranges ? -1 : time;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar orangesRotting = function(grid) {\\n  let queue = [], oranges = 0, time = 0;\\n  \\n  for (let r = 0; r < grid.length; r++) {\\n    for (let c = 0; c < grid[r].length; c++) {\\n      if (grid[r][c] === 1) oranges++\\n      else if (grid[r][c] === 2) queue.push([r,c,0]);\\n    }\\n  }\\n    \\n  const dirs = [[0,1], [1,0], [0,-1], [-1,0]];\\n  const endR = grid.length - 1, endC = grid[0].length - 1;\\n  \\n  while (queue.length && oranges) {\\n    const [curR, curC, mins] = queue.shift();\\n    \\n    if (grid[curR][curC] === 1) {\\n      grid[curR][curC] = 2;\\n      oranges--;\\n      time = mins;\\n    }\\n\\n    for (let [addR, addC] of dirs) {\\n      const [newR, newC] = [curR + addR, curC + addC];\\n      if (newR < 0 || newR > endR || newC < 0 || newC > endC) continue;\\n      if (grid[newR][newC] === 1) {\\n        queue.push([newR, newC, mins + 1])\\n      }\\n    }\\n  }\\n  \\n  return oranges ? -1 : time;\\n};\\n```\n```\\nvar orangesRotting = function(grid) {\\n  //Initialize queue for our BFS, Number of fresh oranges, and time to be returned.\\n  let queue = [], oranges = 0, time = 0;\\n  \\n  //Traverse matrix.  If we find a fresh orange, increment orange count.\\n  //If we find a rotten one, add it to the queue.\\n  for (let r = 0; r < grid.length; r++) {\\n    for (let c = 0; c < grid[r].length; c++) {\\n      if (grid[r][c] === 1) oranges++\\n      else if (grid[r][c] === 2) queue.push([r,c,0]);\\n    }\\n  }\\n    \\n  //Dirs will help us check neighbors during our BFS.  Adding these coordinates\\n  //to a point just gets right, left, up and down.  endR and endC are used later\\n  //to make sure neighbor coords are within grid.\\n  const dirs = [[0,1], [1,0], [0,-1], [-1,0]];\\n  const endR = grid.length - 1, endC = grid[0].length - 1;\\n  \\n  //Loop while queue is not empty and there are still fresh oranges.\\n  while (queue.length && oranges) {\\n  \\n\\t//Entry within queue can be destructured to make it easier to work with.\\n\\t//Each queue entry has a row, column and number of minutes taken for\\n\\t//infection to reach.\\n    const [curR, curC, mins] = queue.shift();\\n    \\n\\t//If orange is still fresh, we mark it as rotten, decrement our fresh oranges\\n\\t//count and set time to = mins.  Since we BFSing, the time it takes to infect\\n\\t//the last orange will be the time to infect all.  Once all oranges have\\n\\t//been infected, our orange count will = 0 and our condition in while loop\\n\\t//will stop the loop.  Time can then be returned.\\n    if (grid[curR][curC] === 1) {\\n      grid[curR][curC] = 2;\\n      oranges--;\\n      time = mins;\\n    }\\n\\n    //Here\\'s where our dir array above comes in handy.  We destructure\\n\\t//each entry and add it to our current to get neighbor coords below.\\n    for (let [addR, addC] of dirs) {\\n\\t\\n\\t  //Here we obtain our new or neighbor coordinates by adding currentRow\\n\\t  //and addRow of dir.  Same for col.\\n      const [newR, newC] = [curR + addR, curC + addC];\\n\\t  \\n\\t  //Here we check to make sure new coordinates lie within the grid.\\n      if (newR < 0 || newR > endR || newC < 0 || newC > endC) continue;\\n\\t  \\n\\t  //If neighbor coord is valid, and there is a fresh orange at those coordinates\\n\\t  //we push coordinates to our BFS to be infected next.  We also increment the\\n\\t  //mins count to track time taken to spread to that orange.\\n      if (grid[newR][newC] === 1) {\\n        queue.push([newR, newC, mins + 1])\\n      }\\n    }\\n  }\\n  \\n  //If we still have uninfected oranges, we return -1 because it won\\'t spread\\n  //to all.  Otherwise, we simply return the time from initial infected to last\\n  //infected orange.\\n  return oranges ? -1 : time;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515257,
                "title": "javascript-bfs-solution",
                "content": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n  const height = grid.length;\\n  const width = grid[0].length;\\n  let fresh = 0;\\n  const queue = [];\\n  for (let i = 0; i < height; i++) {\\n    for (let j = 0; j < width; j++) {\\n      if (grid[i][j] === 2) queue.push([i, j]);\\n      if (grid[i][j] === 1) fresh++;\\n    }\\n  }\\n  let minute = 0;\\n  while (queue.length) {\\n    const size = queue.length;\\n    for (let i = 0; i < size; i++) {\\n      const [x, y] = queue.shift();\\n      if (x - 1 >= 0 && grid[x - 1][y] === 1) {\\n        grid[x - 1][y] = 2;\\n        fresh--;\\n        queue.push([x - 1, y]);\\n      }\\n      if (x + 1 < height && grid[x + 1][y] === 1) {\\n        grid[x + 1][y] = 2;\\n        fresh--;\\n        queue.push([x + 1, y]);\\n      }\\n      if (y - 1 >= 0 && grid[x][y - 1] === 1) {\\n        grid[x][y - 1] = 2;\\n        fresh--;\\n        queue.push([x, y - 1]);\\n      }\\n      if (y + 1 < width && grid[x][y + 1] === 1) {\\n        grid[x][y + 1] = 2;\\n        fresh--;\\n        queue.push([x, y + 1]);\\n      }\\n    }\\n    if (queue.length > 0) minute++;\\n  }\\n  return fresh === 0 ? minute : -1;\\n};\\n```\\n\\n* 303/303 cases passed (64 ms)\\n* Your runtime beats 88.77 % of javascript submissions\\n* Your memory usage beats 50 % of javascript submissions (36.8 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n  const height = grid.length;\\n  const width = grid[0].length;\\n  let fresh = 0;\\n  const queue = [];\\n  for (let i = 0; i < height; i++) {\\n    for (let j = 0; j < width; j++) {\\n      if (grid[i][j] === 2) queue.push([i, j]);\\n      if (grid[i][j] === 1) fresh++;\\n    }\\n  }\\n  let minute = 0;\\n  while (queue.length) {\\n    const size = queue.length;\\n    for (let i = 0; i < size; i++) {\\n      const [x, y] = queue.shift();\\n      if (x - 1 >= 0 && grid[x - 1][y] === 1) {\\n        grid[x - 1][y] = 2;\\n        fresh--;\\n        queue.push([x - 1, y]);\\n      }\\n      if (x + 1 < height && grid[x + 1][y] === 1) {\\n        grid[x + 1][y] = 2;\\n        fresh--;\\n        queue.push([x + 1, y]);\\n      }\\n      if (y - 1 >= 0 && grid[x][y - 1] === 1) {\\n        grid[x][y - 1] = 2;\\n        fresh--;\\n        queue.push([x, y - 1]);\\n      }\\n      if (y + 1 < width && grid[x][y + 1] === 1) {\\n        grid[x][y + 1] = 2;\\n        fresh--;\\n        queue.push([x, y + 1]);\\n      }\\n    }\\n    if (queue.length > 0) minute++;\\n  }\\n  return fresh === 0 ? minute : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517522,
                "title": "java-tc-o-m-n-sc-o-m-n-optimized-bfs-solution",
                "content": "```java\\n/**\\n * Optimized BFS Solution. Find all rotten oranges and add them to a queue.\\n * Start the BFS from this level and rot all the neighboring oranges. Continue\\n * till all levels are exhausted or all oranges have become rotten.\\n *\\n * Time Complexity: O(2 * M * N) --> Each cell in the grid is visited maximum\\n * twice.\\n *\\n * Space Complexity: O(M * N) --> Queue Size\\n *\\n * M = Number of rows. N = Number of columns\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    public int orangesRotting(int[][] grid) {\\n        if (grid == null) {\\n            throw new IllegalArgumentException(\"Input grid is null\");\\n        }\\n        if (grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return grid[0][0] == 1 ? -1 : 0;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        int freshOrangesCount = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(i * cols + j);\\n                } else if (grid[i][j] == 1) {\\n                    freshOrangesCount++;\\n                }\\n            }\\n        }\\n\\n        int time = 0;\\n        // freshOrangesCount != 0 ==> This check ensure we are not continuing once all\\n        // fresh oranges have become rotten.\\n        while (freshOrangesCount != 0 && !queue.isEmpty()) {\\n            int levelSize = queue.size();\\n            time++; // Time elapsed after neighbors of this level have become rotten.\\n            for (int i = 0; i < levelSize && freshOrangesCount != 0; i++) {\\n                int cur = queue.poll();\\n                int row = cur / cols;\\n                int col = cur % cols;\\n                for (int[] d : DIRS) {\\n                    int x = row + d[0];\\n                    int y = col + d[1];\\n                    if (x < 0 || x >= rows || y < 0 || y >= cols || grid[x][y] != 1) {\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;\\n                    freshOrangesCount--;\\n                    if (freshOrangesCount == 0) {\\n                        break;\\n                    }\\n                    queue.offer(x * cols + y);\\n                }\\n            }\\n        }\\n\\n        return freshOrangesCount == 0 ? time : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Optimized BFS Solution. Find all rotten oranges and add them to a queue.\\n * Start the BFS from this level and rot all the neighboring oranges. Continue\\n * till all levels are exhausted or all oranges have become rotten.\\n *\\n * Time Complexity: O(2 * M * N) --> Each cell in the grid is visited maximum\\n * twice.\\n *\\n * Space Complexity: O(M * N) --> Queue Size\\n *\\n * M = Number of rows. N = Number of columns\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    public int orangesRotting(int[][] grid) {\\n        if (grid == null) {\\n            throw new IllegalArgumentException(\"Input grid is null\");\\n        }\\n        if (grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return grid[0][0] == 1 ? -1 : 0;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        int freshOrangesCount = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(i * cols + j);\\n                } else if (grid[i][j] == 1) {\\n                    freshOrangesCount++;\\n                }\\n            }\\n        }\\n\\n        int time = 0;\\n        // freshOrangesCount != 0 ==> This check ensure we are not continuing once all\\n        // fresh oranges have become rotten.\\n        while (freshOrangesCount != 0 && !queue.isEmpty()) {\\n            int levelSize = queue.size();\\n            time++; // Time elapsed after neighbors of this level have become rotten.\\n            for (int i = 0; i < levelSize && freshOrangesCount != 0; i++) {\\n                int cur = queue.poll();\\n                int row = cur / cols;\\n                int col = cur % cols;\\n                for (int[] d : DIRS) {\\n                    int x = row + d[0];\\n                    int y = col + d[1];\\n                    if (x < 0 || x >= rows || y < 0 || y >= cols || grid[x][y] != 1) {\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;\\n                    freshOrangesCount--;\\n                    if (freshOrangesCount == 0) {\\n                        break;\\n                    }\\n                    queue.offer(x * cols + y);\\n                }\\n            }\\n        }\\n\\n        return freshOrangesCount == 0 ? time : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248472,
                "title": "javascript-bfs-100-simple",
                "content": "```\\nvar orangesRotting = function(grid) {\\n    let q = [];\\n    let numFresh = 0;\\n    let minutes = 0;\\n    // Push rotten oranges to the stack and count fresh oranges\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === 2)\\n                q.push([i,j]);\\n            if (grid[i][j] === 1)\\n                numFresh++;\\n        }\\n    }\\n\\t\\n    while (q.length && numFresh) {\\n\\t\\tlet newQ = []; // queue for next minute\\n        while (q.length) {\\n            let badOrange = q.shift();\\n            let newRottens = infectOthers(grid, badOrange[0], badOrange[1], newQ);\\n            numFresh -= newRottens;\\n        }\\n        \\n        minutes++;\\n        q = newQ;\\n    }\\n    if (numFresh !== 0)\\n\\t\\treturn -1;\\n\\treturn minutes;\\n};\\n\\n// Infect surrounding oranges\\n// Return the number of newly infected oranges\\nvar infectOthers = function(grid, i, j, q) {\\n    let infected = 0;\\n    if (i > 0 && grid[i-1][j] === 1) {\\n        grid[i-1][j]++;\\n        infected++;\\n        q.push([i-1,j]);\\n    }\\n    if (j > 0 && grid[i][j-1] === 1) {\\n        grid[i][j-1]++;\\n        infected++;\\n        q.push([i,j-1]);\\n    }\\n    if (i < grid.length-1 && grid[i+1][j] === 1) {\\n        grid[i+1][j]++;\\n        infected++;\\n        q.push([i+1,j]);\\n    } \\n    if (j < grid[0].length-1 && grid[i][j+1] === 1) {\\n        grid[i][j+1]++;\\n        infected++;\\n        q.push([i,j+1]);\\n    }\\n    \\n    return infected;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar orangesRotting = function(grid) {\\n    let q = [];\\n    let numFresh = 0;\\n    let minutes = 0;\\n    // Push rotten oranges to the stack and count fresh oranges\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === 2)\\n                q.push([i,j]);\\n            if (grid[i][j] === 1)\\n                numFresh++;\\n        }\\n    }\\n\\t\\n    while (q.length && numFresh) {\\n\\t\\tlet newQ = []; // queue for next minute\\n        while (q.length) {\\n            let badOrange = q.shift();\\n            let newRottens = infectOthers(grid, badOrange[0], badOrange[1], newQ);\\n            numFresh -= newRottens;\\n        }\\n        \\n        minutes++;\\n        q = newQ;\\n    }\\n    if (numFresh !== 0)\\n\\t\\treturn -1;\\n\\treturn minutes;\\n};\\n\\n// Infect surrounding oranges\\n// Return the number of newly infected oranges\\nvar infectOthers = function(grid, i, j, q) {\\n    let infected = 0;\\n    if (i > 0 && grid[i-1][j] === 1) {\\n        grid[i-1][j]++;\\n        infected++;\\n        q.push([i-1,j]);\\n    }\\n    if (j > 0 && grid[i][j-1] === 1) {\\n        grid[i][j-1]++;\\n        infected++;\\n        q.push([i,j-1]);\\n    }\\n    if (i < grid.length-1 && grid[i+1][j] === 1) {\\n        grid[i+1][j]++;\\n        infected++;\\n        q.push([i+1,j]);\\n    } \\n    if (j < grid[0].length-1 && grid[i][j+1] === 1) {\\n        grid[i][j+1]++;\\n        infected++;\\n        q.push([i,j+1]);\\n    }\\n    \\n    return infected;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546757,
                "title": "c-clean-code-100-faster",
                "content": "<br>\\n\\n**Approach:** \\n* Store position of all initially rotten oranges\\n* Count all fresh oranges at start\\n* Start traversing from rotten oranges, go to it\\'s 4 adjacent positions and if the orange is fresh, then rot it, decrease the count of fresh oranges\\n* Increase the time after repeating above step for all currently rotten oranges\\n* At last, if any fresh orange is remaining then return -1, if time is -1 (Didn\\'t start trsversing) then return 0, else return time taken to rot all oranges\\n\\n<br>\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int fresh = 0, time = -1;\\n        \\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        queue<pair<int, int>> q;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1) fresh++;\\n                else if(grid[i][j] == 2) q.push({i, j});\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++) {\\n                auto cur = q.front();\\n                q.pop();\\n                for(auto dir: dirs) {\\n                    int x = cur.first + dir.first;\\n                    int y = cur.second + dir.second;\\n                    if(x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == 1) {\\n                        grid[x][y] = 2;\\n                        q.push({x, y});\\n                        fresh--;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        \\n        return (fresh > 0) ? -1 : ((time == -1) ? 0 : time);\\n    }\\n};\\n```\\n\\n<br>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int fresh = 0, time = -1;\\n        \\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        queue<pair<int, int>> q;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1) fresh++;\\n                else if(grid[i][j] == 2) q.push({i, j});\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++) {\\n                auto cur = q.front();\\n                q.pop();\\n                for(auto dir: dirs) {\\n                    int x = cur.first + dir.first;\\n                    int y = cur.second + dir.second;\\n                    if(x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == 1) {\\n                        grid[x][y] = 2;\\n                        q.push({x, y});\\n                        fresh--;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        \\n        return (fresh > 0) ? -1 : ((time == -1) ? 0 : time);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502466,
                "title": "java-bfs-easy-solution",
                "content": "```\\nclass Solution {\\n    public static int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int minutes = -1;\\n        int freshCount = 0;\\n\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 2) queue.offer(new int[]{i, j}); //gathering rotten oranges to queue\\n                else if(grid[i][j] == 1) freshCount++;\\n            }\\n        }\\n\\n        if(freshCount == 0) return 0; //there is no fresh orange.\\n        if(queue.size() == 0) return -1; //there is noting to rotten.\\n\\n        while (!queue.isEmpty()) {\\n            minutes++;\\n            int size = queue.size(); //Rotten oranges simultaneously affect adjacent fresh oranges.\\n            for(int i = 0; i < size; i++) {\\n                //if using queue.size() instead of size, it will be not working properly, beacuse queue is changeable.\\n                int[] now = queue.poll();\\n                for (int[] dir : dirs) { //find fresh oragnes from adjacent directions.\\n                    int x = now[0] + dir[0];\\n                    int y = now[1] + dir[1];\\n\\n                    if (x > grid.length - 1 || x < 0 || y > grid[0].length - 1 || y < 0) continue;\\n                    if (grid[x][y] == 1) {\\n                        queue.offer(new int[]{x, y});\\n                        grid[x][y] = 2; //rotten..!!\\n                        freshCount--;\\n                    }\\n                }\\n            }\\n        }\\n        //if freshCount is not 0, it means that all fresh orange couldn\\'t be rotten.\\n        return freshCount != 0 ? -1 : minutes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public static int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int minutes = -1;\\n        int freshCount = 0;\\n\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 2) queue.offer(new int[]{i, j}); //gathering rotten oranges to queue\\n                else if(grid[i][j] == 1) freshCount++;\\n            }\\n        }\\n\\n        if(freshCount == 0) return 0; //there is no fresh orange.\\n        if(queue.size() == 0) return -1; //there is noting to rotten.\\n\\n        while (!queue.isEmpty()) {\\n            minutes++;\\n            int size = queue.size(); //Rotten oranges simultaneously affect adjacent fresh oranges.\\n            for(int i = 0; i < size; i++) {\\n                //if using queue.size() instead of size, it will be not working properly, beacuse queue is changeable.\\n                int[] now = queue.poll();\\n                for (int[] dir : dirs) { //find fresh oragnes from adjacent directions.\\n                    int x = now[0] + dir[0];\\n                    int y = now[1] + dir[1];\\n\\n                    if (x > grid.length - 1 || x < 0 || y > grid[0].length - 1 || y < 0) continue;\\n                    if (grid[x][y] == 1) {\\n                        queue.offer(new int[]{x, y});\\n                        grid[x][y] = 2; //rotten..!!\\n                        freshCount--;\\n                    }\\n                }\\n            }\\n        }\\n        //if freshCount is not 0, it means that all fresh orange couldn\\'t be rotten.\\n        return freshCount != 0 ? -1 : minutes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452718,
                "title": "python3-breadth-first-search-time",
                "content": "* flip the rotten orange \\'2\\' to \\'0\\' then you don\\'t need a visited set to avoid duplicate caculation.\\n```\\nfrom collections import deque\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        queue = ((0,0))\\n        [2,2,0]\\n        [2,1,0]\\n        [0,1,1]\\n        \\n        \"\"\"\\n        # put all the rotten orange into our tast queue.\\n        l = 0\\n        queue = deque([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 2:\\n                    queue.append((i,j,l))\\n                    grid[i][j] = 0\\n        \\n\\n        while queue:\\n            I,J,l = queue.popleft()\\n            print(I,J)\\n            for i,j in [I -1,J],[I+1,J],[I,J-1],[I,J+1]:\\n                if 0 <= i < len(grid) and 0<=j<len(grid[0]) and grid[i][j] == 1:\\n                    queue.append((i,j,l+1))\\n                    grid[i][j] = 0\\n        #print(grid)\\n        if any(1 in row for row in grid):\\n            return -1\\n        else:\\n            return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        queue = ((0,0))\\n        [2,2,0]\\n        [2,1,0]\\n        [0,1,1]\\n        \\n        \"\"\"\\n        # put all the rotten orange into our tast queue.\\n        l = 0\\n        queue = deque([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 2:\\n                    queue.append((i,j,l))\\n                    grid[i][j] = 0\\n        \\n\\n        while queue:\\n            I,J,l = queue.popleft()\\n            print(I,J)\\n            for i,j in [I -1,J],[I+1,J],[I,J-1],[I,J+1]:\\n                if 0 <= i < len(grid) and 0<=j<len(grid[0]) and grid[i][j] == 1:\\n                    queue.append((i,j,l+1))\\n                    grid[i][j] = 0\\n        #print(grid)\\n        if any(1 in row for row in grid):\\n            return -1\\n        else:\\n            return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551658,
                "title": "python-readable-bfs-solution-beat-94",
                "content": "![image](https://assets.leetcode.com/users/jefferyzzy/image_1585196075.png)\\n\\n* Add all fresh oranges to fresh_set and append all rotten oranges to rotten_queue.\\n* Use BFS to find all fresh oranges that adjacent to the current rotten orange, turn these fresh oranges to rotten and remove these from fresh_set. In the meantime, track the steps of turning. \\n* After we finish the turning, if there is still a fresh orange in fresh_set, return -1 otherwist return the step.\\n\\nTime complexity is O(mn) where m is size of row and n is size of columns\\n\\n```\\ndef orangesRotting(self, grid: List[List[int]]) -> int:\\n        row, col = len(grid), len(grid[0])\\n        dirs = [(-1,0),(0,1),(1,0),(0,-1)]\\n        fresh_set=set()\\n        rotten = collections.deque()\\n        step = 0\\n        for x in range(row):\\n            for y in range(col):\\n                if grid[x][y]==1:\\n                    fresh_set.add((x,y))\\n                elif grid[x][y]==2:\\n                    rotten.append([x,y,step])\\n        while rotten:\\n            x,y,step = rotten.popleft()\\n            for dx, dy in dirs:\\n                if 0<=x+dx<row and 0<=y+dy<col and grid[x+dx][y+dy] == 1:\\n                    grid[x+dx][y+dy]=2\\n                    fresh_set.remove((x+dx,y+dy))\\n                    rotten.append([x+dx,y+dy,step+1])\\n        return step if not fresh_set else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef orangesRotting(self, grid: List[List[int]]) -> int:\\n        row, col = len(grid), len(grid[0])\\n        dirs = [(-1,0),(0,1),(1,0),(0,-1)]\\n        fresh_set=set()\\n        rotten = collections.deque()\\n        step = 0\\n        for x in range(row):\\n            for y in range(col):\\n                if grid[x][y]==1:\\n                    fresh_set.add((x,y))\\n                elif grid[x][y]==2:\\n                    rotten.append([x,y,step])\\n        while rotten:\\n            x,y,step = rotten.popleft()\\n            for dx, dy in dirs:\\n                if 0<=x+dx<row and 0<=y+dy<col and grid[x+dx][y+dy] == 1:\\n                    grid[x+dx][y+dy]=2\\n                    fresh_set.remove((x+dx,y+dy))\\n                    rotten.append([x+dx,y+dy,step+1])\\n        return step if not fresh_set else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1362979,
                "title": "python-bfs-the-most-standard-answer-template-for-bfs-question",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        \"\"\"\\n        Step 1: recogonise this is a BFS problem with 4 direction finding neighbor\\n        Step 2: before we go into BFS, we need to do some preparation steps\\n        Step 3: run BFS\\n        \\n        When should we run BFS? It has 2 cases:\\n        One is after finding all the initial elements,\\n        the other is after finding exactly one initial element\\n        In this question, we should note that if we have 2 rotten orange in the beginning, they will infect at the same time. \\n\\t\\t\\n\\t\\tFor example, if the other one has fresh neighbor, the 2nd rotten orange will infect also in the beginning. \\n\\t\\tSo we can not write BFS after finding exactly one rotten orange, we need to put them into the same level at the initial.\\n        put all the initial elements into the queue. for example, we have rotten orange in position 1 and 3. So the level is\\n        1  3\\n        2  4\\n        5\\n        8\\n        9\\n        \"\"\"\\n        \\n        # Step 1: Some standard preparation work\\n        # (1). Define a row and col. (note, it depends on the question. We do not need to define\\n        # this on some questions which does not have the coordinates. This is problem is actually\\n        # array, so we need to create this.)\\n        # this is the standard writing form to define the row and col for 2-dim array\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        # we should always think if it is a 0 matrix. In this question, we do not need to judge\\n        # since row and col is >= 1. Otherwise, we judge it like\\n        # if row == 0:\\n        #   return -1\\n        \\n        # In this question, when we return the steps after finishing?\\n        # What is the judging standard for finishing?\\n        # That is, if all the fresh oranges disappear, it means finishing\\n        # So we need to set a count for fresh orange\\n        # Do we need to also set a count for rotten orange? It seems not necessary, since\\n        # it will not act any role on the question\\n        fresh_orange = 0\\n        \\n        # (2). Define the queue and put the initial positions into the queue.\\n        # here is also depended on the proble on if we need to put coordinate into the queue\\n        # or the object itself into the queue. For example, should we put grid[0][0]\\n        # or (0, 0) into the queue? I can not say definitely on the standard, but if we meet\\n        # an array problem, we usually use coordinate.\\n        # this is the standard process to create a queue\\n        # Note here, if we come across some problems that let us solve the \\n        # symmetric problem on tree, we may need to put two root into the queue as a pair\\n        queue = deque()\\n        \\n        # to put the initial elements into the queue, we need to decide whether we let the\\n        # BFS be righ after the first one element, or we choose all the initial coordinate into the queue\\n        # first we choose all the initial elements into the queue\\n        # the standard process to find the initial elements by traversing the array\\n        # row = 3, so range(3) will be 0, 1, 2; col = 3, range(3) will be 0, 1, 2.\\n        # So we can traverse the whole coordinates\\n        for i in range(row):\\n            for j in range(col):\\n                # put what into the queue first? that is, the rotten one, grid[i][j] = 2\\n                if grid[i][j] == 2:\\n                    queue.append((i, j))\\n                # also we update the number of fresh orange\\n                elif grid[i][j] == 1:\\n                    fresh_orange += 1\\n        \\n        # Now it is time for BFS. The rule is first in, first out.\\n        # Our queue now has all the rotten oranges. For example, if 1, 3 is the rotten orange\\n        # the queue now is\\n        # ------------------------------------------------\\n        # 1  3 |\\n        # ------------------------------------------------\\n        # Now we do BFS to take out the 1st element\\n        \\n        count = 0\\n        # When is the situation to go into this BFS?\\n        # first, we need to assure our queue is not empty, that is, it must have rotten orange.\\n        # if rotten orange is 0, then it will not go into this while loop.\\n        # and when all the oranges are rotten, also not go into this while loop.\\n        while queue and fresh_orange > 0:\\n            # we need to take out the 1st element\\n            # how to do this? a standard process is below\\n            # len(queue) = 2 now, range(2) is 0, 1\\n            # this shows that, in this level, it will traverse all the elements in this level\\n            # while control the traversal from level to level\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n            \\n                # after finding the first element, we need to think if we should judge something\\n                # the judge is depending on the question requirement\\n                # In this question, looks nothing needs to be judged. So we safely find the neighbor\\n                # a standard process for finding the neighbor is regularly 4 directions below\\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    \\n                    # the candidate neighbor is here\\n                    # In other question, we may find the neighbor for example like this\\n                    # node.left; 0 -> 9, 1; a -> z, b... depending on the question\\n                    xx, yy = x + dx, y + dy\\n                    \\n                    # we first consider if this neighbor is out of the border\\n                    if xx < 0 or xx == row or yy < 0 or yy == col:\\n                        continue\\n                    \\n                    # we also need to consider, if this neighbor is fresh or empty, we continue\\n                    # note, some problems need us to judge on the 1st element, not neighbor\\n                    # so judging the 1st element or its neighbor, depending on the question\\n                    # grid[xx][yy] == 0 assures we skip the empty cell\\n                    # grid[xx][yy] == 2 assures we skip the rotten orange. This rotten orange\\n                    # may already exist, or it is the one that we marked before\\n                    # If we do not skip, then the rotten orange that we mark before will\\n                    # be added again into the queue. That is chaotic\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # so the left coordinates are the expected fresh orange\\n                    # we have found our expected neighbor, now we put them into the queue\\n                    queue.append((xx, yy))\\n                    \\n                    # we mark the neighbor as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # we subtract our fresh orange with -1\\n                    fresh_orange -= 1\\n                \\n                    # after this cycle of finding, the queue will be\\n                    # ------------------------------------------------\\n                    #   3  |  2  4  |\\n                    # ------------------------------------------------\\n                    \\n                # this level of for loop to connitue to execute 3, after that, the queue will be\\n                # ------------------------------------------------\\n                #      |  2  4  |\\n                # ------------------------------------------------\\n            \\n            # while loop assures we do this level by level\\n            # ------------------------------------------------\\n            #      |  2  4  |\\n            # ------------------------------------------------\\n        \\n            # after finishing each level, we count + 1\\n            # here if we write count + 1 in the beginning of the while loop  \\n            # the number will not right\\n            # the difference is that, we count before finding neighbor or after finding neighbor\\n            # In this case, when we find a neighbor, the minute will add 1, so we write in the end\\n            count += 1\\n            \\n        # Finally, we show the final result\\n        # Note, this is a simple writing method\\n        return count if fresh_orange == 0 else -1\\n        \\n        # if we write in standard, it will be\\n        \"\"\"\\n        if fresh_orange == 0:\\n            return count\\n        else:\\n            return -1\\n        \"\"\"\\n\\n        \\n\"\"\"\\nThe whole process is: ( note I assume rotten is 1, 3 initially, not the example 1)\\n------------------------------------------------\\n1  3  |\\n------------------------------------------------\\n------------------------------------------------\\n   3  |  2  4  |\\n------------------------------------------------\\n------------------------------------------------\\n      |  2  4  |\\n------------------------------------------------\\n------------------------------------------------\\n      |     4  |  5\\n------------------------------------------------\\n------------------------------------------------\\n      |        |  5  |\\n------------------------------------------------\\n------------------------------------------------\\n      |        |     |  8  |\\n------------------------------------------------\\n------------------------------------------------\\n      |        |     |     |  9\\n------------------------------------------------\\nthe level is \\n1  3\\n2  4\\n5\\n8\\n9\\n\"\"\"   \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        \"\"\"\\n        Step 1: recogonise this is a BFS problem with 4 direction finding neighbor\\n        Step 2: before we go into BFS, we need to do some preparation steps\\n        Step 3: run BFS\\n        \\n        When should we run BFS? It has 2 cases:\\n        One is after finding all the initial elements,\\n        the other is after finding exactly one initial element\\n        In this question, we should note that if we have 2 rotten orange in the beginning, they will infect at the same time. \\n\\t\\t\\n\\t\\tFor example, if the other one has fresh neighbor, the 2nd rotten orange will infect also in the beginning. \\n\\t\\tSo we can not write BFS after finding exactly one rotten orange, we need to put them into the same level at the initial.\\n        put all the initial elements into the queue. for example, we have rotten orange in position 1 and 3. So the level is\\n        1  3\\n        2  4\\n        5\\n        8\\n        9\\n        \"\"\"\\n        \\n        # Step 1: Some standard preparation work\\n        # (1). Define a row and col. (note, it depends on the question. We do not need to define\\n        # this on some questions which does not have the coordinates. This is problem is actually\\n        # array, so we need to create this.)\\n        # this is the standard writing form to define the row and col for 2-dim array\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        # we should always think if it is a 0 matrix. In this question, we do not need to judge\\n        # since row and col is >= 1. Otherwise, we judge it like\\n        # if row == 0:\\n        #   return -1\\n        \\n        # In this question, when we return the steps after finishing?\\n        # What is the judging standard for finishing?\\n        # That is, if all the fresh oranges disappear, it means finishing\\n        # So we need to set a count for fresh orange\\n        # Do we need to also set a count for rotten orange? It seems not necessary, since\\n        # it will not act any role on the question\\n        fresh_orange = 0\\n        \\n        # (2). Define the queue and put the initial positions into the queue.\\n        # here is also depended on the proble on if we need to put coordinate into the queue\\n        # or the object itself into the queue. For example, should we put grid[0][0]\\n        # or (0, 0) into the queue? I can not say definitely on the standard, but if we meet\\n        # an array problem, we usually use coordinate.\\n        # this is the standard process to create a queue\\n        # Note here, if we come across some problems that let us solve the \\n        # symmetric problem on tree, we may need to put two root into the queue as a pair\\n        queue = deque()\\n        \\n        # to put the initial elements into the queue, we need to decide whether we let the\\n        # BFS be righ after the first one element, or we choose all the initial coordinate into the queue\\n        # first we choose all the initial elements into the queue\\n        # the standard process to find the initial elements by traversing the array\\n        # row = 3, so range(3) will be 0, 1, 2; col = 3, range(3) will be 0, 1, 2.\\n        # So we can traverse the whole coordinates\\n        for i in range(row):\\n            for j in range(col):\\n                # put what into the queue first? that is, the rotten one, grid[i][j] = 2\\n                if grid[i][j] == 2:\\n                    queue.append((i, j))\\n                # also we update the number of fresh orange\\n                elif grid[i][j] == 1:\\n                    fresh_orange += 1\\n        \\n        # Now it is time for BFS. The rule is first in, first out.\\n        # Our queue now has all the rotten oranges. For example, if 1, 3 is the rotten orange\\n        # the queue now is\\n        # ------------------------------------------------\\n        # 1  3 |\\n        # ------------------------------------------------\\n        # Now we do BFS to take out the 1st element\\n        \\n        count = 0\\n        # When is the situation to go into this BFS?\\n        # first, we need to assure our queue is not empty, that is, it must have rotten orange.\\n        # if rotten orange is 0, then it will not go into this while loop.\\n        # and when all the oranges are rotten, also not go into this while loop.\\n        while queue and fresh_orange > 0:\\n            # we need to take out the 1st element\\n            # how to do this? a standard process is below\\n            # len(queue) = 2 now, range(2) is 0, 1\\n            # this shows that, in this level, it will traverse all the elements in this level\\n            # while control the traversal from level to level\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n            \\n                # after finding the first element, we need to think if we should judge something\\n                # the judge is depending on the question requirement\\n                # In this question, looks nothing needs to be judged. So we safely find the neighbor\\n                # a standard process for finding the neighbor is regularly 4 directions below\\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    \\n                    # the candidate neighbor is here\\n                    # In other question, we may find the neighbor for example like this\\n                    # node.left; 0 -> 9, 1; a -> z, b... depending on the question\\n                    xx, yy = x + dx, y + dy\\n                    \\n                    # we first consider if this neighbor is out of the border\\n                    if xx < 0 or xx == row or yy < 0 or yy == col:\\n                        continue\\n                    \\n                    # we also need to consider, if this neighbor is fresh or empty, we continue\\n                    # note, some problems need us to judge on the 1st element, not neighbor\\n                    # so judging the 1st element or its neighbor, depending on the question\\n                    # grid[xx][yy] == 0 assures we skip the empty cell\\n                    # grid[xx][yy] == 2 assures we skip the rotten orange. This rotten orange\\n                    # may already exist, or it is the one that we marked before\\n                    # If we do not skip, then the rotten orange that we mark before will\\n                    # be added again into the queue. That is chaotic\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # so the left coordinates are the expected fresh orange\\n                    # we have found our expected neighbor, now we put them into the queue\\n                    queue.append((xx, yy))\\n                    \\n                    # we mark the neighbor as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # we subtract our fresh orange with -1\\n                    fresh_orange -= 1\\n                \\n                    # after this cycle of finding, the queue will be\\n                    # ------------------------------------------------\\n                    #   3  |  2  4  |\\n                    # ------------------------------------------------\\n                    \\n                # this level of for loop to connitue to execute 3, after that, the queue will be\\n                # ------------------------------------------------\\n                #      |  2  4  |\\n                # ------------------------------------------------\\n            \\n            # while loop assures we do this level by level\\n            # ------------------------------------------------\\n            #      |  2  4  |\\n            # ------------------------------------------------\\n        \\n            # after finishing each level, we count + 1\\n            # here if we write count + 1 in the beginning of the while loop  \\n            # the number will not right\\n            # the difference is that, we count before finding neighbor or after finding neighbor\\n            # In this case, when we find a neighbor, the minute will add 1, so we write in the end\\n            count += 1\\n            \\n        # Finally, we show the final result\\n        # Note, this is a simple writing method\\n        return count if fresh_orange == 0 else -1\\n        \\n        # if we write in standard, it will be\\n        \"\"\"\\n        if fresh_orange == 0:\\n            return count\\n        else:\\n            return -1\\n        \"\"\"\\n\\n        \\n\"\"\"\\nThe whole process is: ( note I assume rotten is 1, 3 initially, not the example 1)\\n------------------------------------------------\\n1  3  |\\n------------------------------------------------\\n------------------------------------------------\\n   3  |  2  4  |\\n------------------------------------------------\\n------------------------------------------------\\n      |  2  4  |\\n------------------------------------------------\\n------------------------------------------------\\n      |     4  |  5\\n------------------------------------------------\\n------------------------------------------------\\n      |        |  5  |\\n------------------------------------------------\\n------------------------------------------------\\n      |        |     |  8  |\\n------------------------------------------------\\n------------------------------------------------\\n      |        |     |     |  9\\n------------------------------------------------\\nthe level is \\n1  3\\n2  4\\n5\\n8\\n9\\n\"\"\"   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 518991,
                "title": "simple-java-with-detailed-explanation",
                "content": "```\\n\\t // classic BFS: keep adding rotten oranges at each level and for every rotten orange, modify its adjacent fresh oranges to rotten and keep adding them to queue till there are no more rotten oranges\\n    // TC: O(n) - where N is the number of cells in the grid. SC: O(N) - for queue space\\n    private static int orangesRotting(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        int freshOranges = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < columns; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(new int[]{i, j});   // add rotten oranges to queue in the first level\\n                }\\n                if (grid[i][j] == 1) {\\n                    freshOranges++;    // count of fresh oranges. this is useful for us (in the end) to check if all the fresh oranges have rotten or not and return the value accordingly  \\n                }\\n            }\\n        }\\n\\n        int days = 0;   // this is basically number of levels in BFS / level order traversal\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // all the possible adjacent directions of a grid value \\n        while (!queue.isEmpty() && freshOranges > 0) {    // continue the BFS till there are no more valid fresh oranges that can rotten \\n            int queueSize = queue.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                int[] node = queue.poll();\\n                for (int[] dir : directions) {\\n                    int x = node[0] + dir[0];\\n                    int y = node[1] + dir[1];\\n\\n                    if (x < 0 || y < 0 || x >= rows || y >= columns || grid[x][y] == 0 || grid[x][y] == 2) {   // exceeded the boundary or the grid value is not a fresh orange, in that case just continue the loop\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;    // mark the orange from fresh -> rotten\\n                    queue.offer(new int[]{x, y});  // add the rotten orange to queue \\n                    freshOranges--;\\n                }\\n            }\\n            days++;   // increment the level \\n        }\\n        return freshOranges == 0 ? days : -1;  // fact that there are no fresh oranges in the grid means all the fresh oranges in the grid have been rotten  \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t // classic BFS: keep adding rotten oranges at each level and for every rotten orange, modify its adjacent fresh oranges to rotten and keep adding them to queue till there are no more rotten oranges\\n    // TC: O(n) - where N is the number of cells in the grid. SC: O(N) - for queue space\\n    private static int orangesRotting(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        int freshOranges = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < columns; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(new int[]{i, j});   // add rotten oranges to queue in the first level\\n                }\\n                if (grid[i][j] == 1) {\\n                    freshOranges++;    // count of fresh oranges. this is useful for us (in the end) to check if all the fresh oranges have rotten or not and return the value accordingly  \\n                }\\n            }\\n        }\\n\\n        int days = 0;   // this is basically number of levels in BFS / level order traversal\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // all the possible adjacent directions of a grid value \\n        while (!queue.isEmpty() && freshOranges > 0) {    // continue the BFS till there are no more valid fresh oranges that can rotten \\n            int queueSize = queue.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                int[] node = queue.poll();\\n                for (int[] dir : directions) {\\n                    int x = node[0] + dir[0];\\n                    int y = node[1] + dir[1];\\n\\n                    if (x < 0 || y < 0 || x >= rows || y >= columns || grid[x][y] == 0 || grid[x][y] == 2) {   // exceeded the boundary or the grid value is not a fresh orange, in that case just continue the loop\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;    // mark the orange from fresh -> rotten\\n                    queue.offer(new int[]{x, y});  // add the rotten orange to queue \\n                    freshOranges--;\\n                }\\n            }\\n            days++;   // increment the level \\n        }\\n        return freshOranges == 0 ? days : -1;  // fact that there are no fresh oranges in the grid means all the fresh oranges in the grid have been rotten  \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978015,
                "title": "read-this-if-you-are-a-noob-like-me-dfs-full-commentary",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,int i,int j,int time) {\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || grid[i][j]==0 \\n|| 1 < grid[i][j] && grid[i][j]<time) /*THIS LAST CONDITION DENOTES THAT IF THE ORANGE IS ALREADY ROTTEN BY SOME OTHER ORANGE ALREADY, IMAGEINE grid[i][j]=3 (WHICH MEANS THAT THIS GRID WAS ALREADY CHANGED BY SOME OTHER ORANGE,OTHERWISE, IT WOULD HAVE BEEN 2 )AND TIME IS 4 , NOW  1 < grid[i][j](which is 3) && grid[i][j] < 4  */ return; \\n        grid[i][j]=time; // Assign the current time to the grid\\n        dfs(grid,i-1,j,grid[i][j]+1); // Recursive call to all 4 sides one by one and by incrementing tine by +1\\n        dfs(grid,i+1,j,grid[i][j]+1);\\n        dfs(grid,i,j-1,grid[i][j]+1);\\n        dfs(grid,i,j+1,grid[i][j]+1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n         for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                if(grid[i][j] == 2) dfs(grid, i, j,grid[i][j]);  // We have to proceed on those orananges which are rotten already and start a recursive call AND THE REASON WHY WE ARE SENDING 2 IS BECAUSE WE CANNOT MARK TIME AS 0,1,2 SINCE THEY ARE ALREADY BEING USED BY THE QUESION(empty cell, fresh orange,rotten orange) ITSELF\\n            }\\n        }\\n        int totalTime=2;// WE PICKED ToTAL TIME 2 BECAUSE AFTER THE COMPLETION OF THE DFS CALLS, THE MATRIX WILL BE FILLED WITH VALUES>=2.\\n        for(int i=0;i<grid.size();i++) {\\n            for(int j=0;j<grid[0].size();j++) {\\n                cout<<grid[i][j]<<\" \";\\n                if(grid[i][j]==1) return -1; // AND IF BY ANY MEANS, ANY VALUE IS 1, THAT MEANS WE WERE NOT ABLE TO ROT THAT ORANGE\\n                totalTime=max(grid[i][j],totalTime);// OTHERWISE, SELECT THE MAX TIME TO ROT\\n            }\\n            cout<<endl;\\n        }\\n        return totalTime-2;// THIS IS IMPORTANT, REMEMBER HOW WE SET TOTALTIME AS 2 ABOVE, WE ARE GONNA SUBTRACT 2 FROM THE TOTAL TIME, SO IF TOTALTIME WAS 2, ACTUAL TIME WILL BE 2-2=0 THAT MEANS, NO ORANGES TO ROT, similarly IF THE TOTAL TIME WAS 8, THAT MEANS THE ACTUAL TIME WAS 8-2=6 SECS/MINS/HRS TO ROT ALL THE ORANGES\\n    }\\n};\\n```\\n\\n\\n`For N rows and columns, I guess TC will be O(N^2)?.` **Please comment if I\\'m wrong with the complexity.**\\n\\n```\\nRuntime: 4 ms, faster than 90.04% of C++ online submissions for Rotting Oranges.\\nMemory Usage: 13 MB, less than 99.45% of C++ online submissions for Rotting Oranges.\\n```\\n\\nFeel free to ask any questions below!.",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,int i,int j,int time) {\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || grid[i][j]==0 \\n|| 1 < grid[i][j] && grid[i][j]<time) /*THIS LAST CONDITION DENOTES THAT IF THE ORANGE IS ALREADY ROTTEN BY SOME OTHER ORANGE ALREADY, IMAGEINE grid[i][j]=3 (WHICH MEANS THAT THIS GRID WAS ALREADY CHANGED BY SOME OTHER ORANGE,OTHERWISE, IT WOULD HAVE BEEN 2 )AND TIME IS 4 , NOW  1 < grid[i][j](which is 3) && grid[i][j] < 4  */ return; \\n        grid[i][j]=time; // Assign the current time to the grid\\n        dfs(grid,i-1,j,grid[i][j]+1); // Recursive call to all 4 sides one by one and by incrementing tine by +1\\n        dfs(grid,i+1,j,grid[i][j]+1);\\n        dfs(grid,i,j-1,grid[i][j]+1);\\n        dfs(grid,i,j+1,grid[i][j]+1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n         for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                if(grid[i][j] == 2) dfs(grid, i, j,grid[i][j]);  // We have to proceed on those orananges which are rotten already and start a recursive call AND THE REASON WHY WE ARE SENDING 2 IS BECAUSE WE CANNOT MARK TIME AS 0,1,2 SINCE THEY ARE ALREADY BEING USED BY THE QUESION(empty cell, fresh orange,rotten orange) ITSELF\\n            }\\n        }\\n        int totalTime=2;// WE PICKED ToTAL TIME 2 BECAUSE AFTER THE COMPLETION OF THE DFS CALLS, THE MATRIX WILL BE FILLED WITH VALUES>=2.\\n        for(int i=0;i<grid.size();i++) {\\n            for(int j=0;j<grid[0].size();j++) {\\n                cout<<grid[i][j]<<\" \";\\n                if(grid[i][j]==1) return -1; // AND IF BY ANY MEANS, ANY VALUE IS 1, THAT MEANS WE WERE NOT ABLE TO ROT THAT ORANGE\\n                totalTime=max(grid[i][j],totalTime);// OTHERWISE, SELECT THE MAX TIME TO ROT\\n            }\\n            cout<<endl;\\n        }\\n        return totalTime-2;// THIS IS IMPORTANT, REMEMBER HOW WE SET TOTALTIME AS 2 ABOVE, WE ARE GONNA SUBTRACT 2 FROM THE TOTAL TIME, SO IF TOTALTIME WAS 2, ACTUAL TIME WILL BE 2-2=0 THAT MEANS, NO ORANGES TO ROT, similarly IF THE TOTAL TIME WAS 8, THAT MEANS THE ACTUAL TIME WAS 8-2=6 SECS/MINS/HRS TO ROT ALL THE ORANGES\\n    }\\n};\\n```\n```\\nRuntime: 4 ms, faster than 90.04% of C++ online submissions for Rotting Oranges.\\nMemory Usage: 13 MB, less than 99.45% of C++ online submissions for Rotting Oranges.\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1807141,
                "title": "full-explanation-c-bfs-well-explained",
                "content": "**Strategy:** \\nThe idea is to count fresh oranges and store indices of all rotten oranges given in the starting. Then traverse through these stored indices and if any fresh orange is found in all the four directions of these indices, we will make it rotten orange and reduce the fresh oranges count by one. At last, if fresh oranges count is 0, we will return total time elapsed till now. Else return -1. \\n\\n*So, how we should store and traverse through the rotten orange indices and count time elapsed?* \\nAnswer is to use **BFS(Breadth First Search)** technique. The key observation to use this technique is that assume all the initial rotten oranges are at level 0. Then the adjacent fresh oranges to these rotten oranges are in level 1 and are rotten on day 1 and the next in level 2 and rotten on day 2 and so on.  This is similar to level order traversal and therefore, the time required to rot all the possible fresh oranges will be equal to the number of levels.\\nAs we will be using BFS, so we will store indices of rotten oranges in queue.\\n\\n**Approach:**\\n1. Initialize a queue for breadth first search in which we will store indices of rotten oranges and freshOranges variable to count number of fresh oranges present in the grid initially. Also initialize our answer variable time.\\n\\t```\\n\\tint freshOranges = 0, time = 0;\\n\\tqueue<pair<int, int>> q; \\n\\t```\\n2. Iterate over the entire grid and add indices of all the rotten oranges in the queue and also keep counting the number of fresh oranges.\\n\\t```\\n\\tfor(int i = 0; i < grid.size(); i++) {\\n\\t\\tfor(int j = 0; j < grid[0].size(); j++) {\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t\\tfreshOranges++;\\n\\t\\t\\telse if(grid[i][j] == 2)\\n\\t\\t\\t\\tq.push({i, j});\\n\\t\\t}\\n\\t}\\n\\t```\\n* *Here we can simply return 0 if fresh oranges count is still 0 after traversing the entire gird as all the oranges given in the grid are already rotten, so 0 time will be taken to rot them.*\\n3. Now traverse the queue in level order fashion.\\n\\t```\\n\\twhile(!q.empty()) {\\n\\t\\tint n = q.size();\\n        while(n--) {\\n               //code\\n\\t\\t }\\n    }\\n\\t```\\n\\t\\n\\tAt every level, take out front of queue and check in its all four directions, whether a fresh orange is present or not, taking care of boundary conditions. If a fresh orange is found, make it rotten, push its index in the queue and decrement fresh oranges count by one.\\n\\t```cpp\\n\\tint x = q.front().first;\\n\\tint y = q.front().second;\\n\\tq.pop();\\n\\t//top\\n\\tif(x - 1 >= 0 && grid[x-1][y] == 1) {\\n\\t\\tgrid[x-1][y] = 2;\\n\\t\\tq.push({x-1, y});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//left\\n\\tif(y - 1 >= 0 && grid[x][y-1] == 1) {\\n\\t\\tgrid[x][y-1] = 2;\\n\\t\\tq.push({x, y-1});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//down\\n\\tif(x + 1 < grid.size() && grid[x+1][y] == 1) {\\n\\t\\tgrid[x+1][y] = 2;\\n\\t\\tq.push({x+1, y});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//right\\n\\tif(y + 1 < grid[0].size() && grid[x][[y+1] == 1) {\\n\\t\\tgrid[x][y+1] = 2;\\n\\t\\tq.push({x, y+1});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t```\\n\\t* *Here we can make our code more readable by changing the instructions, like make an array of dx and dy for the adjacent indices i.e.,*\\n\\t\\t```\\n\\t\\tint dx[] = {0, 0, 1, -1};\\n\\t\\tint dy[] = {1, -1, 0, 0};\\n\\t\\t```\\n\\t\\t*and check for adjacent oranges as*\\n\\t\\t```\\n\\t\\tfor(int i = 0; i < 4; ++i) {\\n\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n            if(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\tgrid[nx][ny] = 2;\\n                q.push({nx, ny});\\n                freshOranges--;\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t```\\n\\tAfter traversal of one complete level, we will increment time by one if the queue is not empty. We are incrementing time by checking this conditions as in the last level all oranges will be already rotten. So we don\\'t want to increment our time in that situation.\\n\\t\\n\\t\\n\\tSo, we ended with:\\n\\t```cpp\\n\\twhile(!q.empty()) {\\n\\t\\tint n = q.size();\\n\\t\\twhile(n--) {\\n\\t\\t\\tint x = q.front().first, y = q.front().second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor(int i = 0; i < 4; ++i) {\\n\\t\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n\\t\\t\\t\\tif(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\t\\tgrid[nx][ny] = 2;\\n\\t\\t\\t\\t\\tq.push({nx, ny});\\n\\t\\t\\t\\t\\tfreshOranges--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!q.empty())\\n\\t\\t\\ttime++;\\n\\t}\\n\\t```\\n4.\\tAt last, If the number of fresh oranges after the entire process is zero, then return the time elapsed till now. Else return -1 indicating that it\\u2019s impossible to rot all the oranges.\\n\\t```\\n\\tif(freshOranges == 0)\\n\\t\\treturn time;\\n\\telse\\n\\t\\treturn -1;\\n\\t```\\n\\n**Dry Run:**\\nLets\\' take an example, grid = [[2,1,1],[1,1,0],[0,1,1]]\\n![image](https://assets.leetcode.com/users/images/65b22705-0cc9-4afb-93d1-3b6d0ce91b85_1646064148.1020083.jpeg)\\n![image](https://assets.leetcode.com/users/images/7454109f-fa58-409f-8a4a-618f6ea605c1_1646064162.615776.jpeg)\\n![image](https://assets.leetcode.com/users/images/8ae4ec0f-f5eb-4505-8932-a0f00ead3f77_1646064173.1493309.jpeg)\\n![image](https://assets.leetcode.com/users/images/f0122139-e1cf-49fe-8125-cfc8848cf244_1646064181.6202948.jpeg)\\n\\n\\n**Complete Code:**\\n```\\nint orangesRotting(vector<vector<int>>& grid) {        \\n\\tint freshOranges = 0, time = 0;\\n    queue<pair<int, int>> q;\\n        \\n    for(int i = 0; i < grid.size(); i++) {\\n\\t\\tfor(int j = 0; j < grid[0].size(); j++) {\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t\\tfreshOranges++;\\n            else if(grid[i][j] == 2)\\n\\t\\t\\t\\tq.push({i, j});\\n        }\\n    }\\n        \\n\\tint dx[] = {0, 0, 1, -1};\\n    int dy[] = {1, -1, 0, 0};\\n        \\n    while(!q.empty()) {\\n\\t\\tint n = q.size();\\n        while(n--) {\\n\\t\\t\\tint x = q.front().first, y = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < 4; ++i) {\\n\\t\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n                if(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\t\\tgrid[nx][ny] = 2;\\n                    q.push({nx, ny});\\n                    freshOranges--;\\n                }\\n            }\\n        }\\n        if(!q.empty())\\n            time++;\\n    }\\n        \\n    if(freshOranges == 0)\\n        return time;\\n    else\\n        return -1;\\n}\\n```\\n\\t\\n\\n\\t\\n\\t\\n\\t\\n\\n**Complexity Analysis:**\\n* *Time Complexity -* `O(n x m) + O(n x m)`  =>  `O(n x m)`\\n\\t* `O(n x m)` for first traversal \\n\\t* `O(n x m)` for queue traversal (*Worst Case when there is only one fresh orange and that too in last*)\\n* *Space Complexity -* `O(n x m)`\\n\\tExtra space for queue (*Worst Case: when all given oranges are rotten*)\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\tint freshOranges = 0, time = 0;\\n\\tqueue<pair<int, int>> q; \\n\\t```\n```\\n\\tfor(int i = 0; i < grid.size(); i++) {\\n\\t\\tfor(int j = 0; j < grid[0].size(); j++) {\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t\\tfreshOranges++;\\n\\t\\t\\telse if(grid[i][j] == 2)\\n\\t\\t\\t\\tq.push({i, j});\\n\\t\\t}\\n\\t}\\n\\t```\n```\\n\\twhile(!q.empty()) {\\n\\t\\tint n = q.size();\\n        while(n--) {\\n               //code\\n\\t\\t }\\n    }\\n\\t```\n```cpp\\n\\tint x = q.front().first;\\n\\tint y = q.front().second;\\n\\tq.pop();\\n\\t//top\\n\\tif(x - 1 >= 0 && grid[x-1][y] == 1) {\\n\\t\\tgrid[x-1][y] = 2;\\n\\t\\tq.push({x-1, y});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//left\\n\\tif(y - 1 >= 0 && grid[x][y-1] == 1) {\\n\\t\\tgrid[x][y-1] = 2;\\n\\t\\tq.push({x, y-1});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//down\\n\\tif(x + 1 < grid.size() && grid[x+1][y] == 1) {\\n\\t\\tgrid[x+1][y] = 2;\\n\\t\\tq.push({x+1, y});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//right\\n\\tif(y + 1 < grid[0].size() && grid[x][[y+1] == 1) {\\n\\t\\tgrid[x][y+1] = 2;\\n\\t\\tq.push({x, y+1});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t```\n```\\n\\t\\tint dx[] = {0, 0, 1, -1};\\n\\t\\tint dy[] = {1, -1, 0, 0};\\n\\t\\t```\n```\\n\\t\\tfor(int i = 0; i < 4; ++i) {\\n\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n            if(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\tgrid[nx][ny] = 2;\\n                q.push({nx, ny});\\n                freshOranges--;\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t```\n```cpp\\n\\twhile(!q.empty()) {\\n\\t\\tint n = q.size();\\n\\t\\twhile(n--) {\\n\\t\\t\\tint x = q.front().first, y = q.front().second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor(int i = 0; i < 4; ++i) {\\n\\t\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n\\t\\t\\t\\tif(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\t\\tgrid[nx][ny] = 2;\\n\\t\\t\\t\\t\\tq.push({nx, ny});\\n\\t\\t\\t\\t\\tfreshOranges--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!q.empty())\\n\\t\\t\\ttime++;\\n\\t}\\n\\t```\n```\\n\\tif(freshOranges == 0)\\n\\t\\treturn time;\\n\\telse\\n\\t\\treturn -1;\\n\\t```\n```\\nint orangesRotting(vector<vector<int>>& grid) {        \\n\\tint freshOranges = 0, time = 0;\\n    queue<pair<int, int>> q;\\n        \\n    for(int i = 0; i < grid.size(); i++) {\\n\\t\\tfor(int j = 0; j < grid[0].size(); j++) {\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t\\tfreshOranges++;\\n            else if(grid[i][j] == 2)\\n\\t\\t\\t\\tq.push({i, j});\\n        }\\n    }\\n        \\n\\tint dx[] = {0, 0, 1, -1};\\n    int dy[] = {1, -1, 0, 0};\\n        \\n    while(!q.empty()) {\\n\\t\\tint n = q.size();\\n        while(n--) {\\n\\t\\t\\tint x = q.front().first, y = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < 4; ++i) {\\n\\t\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n                if(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\t\\tgrid[nx][ny] = 2;\\n                    q.push({nx, ny});\\n                    freshOranges--;\\n                }\\n            }\\n        }\\n        if(!q.empty())\\n            time++;\\n    }\\n        \\n    if(freshOranges == 0)\\n        return time;\\n    else\\n        return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485756,
                "title": "bfs-with-no-map-visited-and-no-loop-after-the-bfs-to-count-with-some-explanation",
                "content": "It\\'s a pretty standard, simple BFS. We count total number of fresh oranges and push all rotten oranges to queue.\\nThen for every rotten orange at this level, we run a loop numer of items in this level times, have a counter if this level turned any fresh orange to rotten. The process continues until queue is empty. We subtract every time we turn a fresh to rotten, and push the new rotten orange and in the end if we still have fresh oranges left, we couldn\\'t infect(or reach) them all, otherwise we did!\\nUsing visited as predecessor for finding the path is a good idea though, except we don\\'t need that in this question.\\n```\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int min = 0, fresh = 0;\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++)\\n                if(grid[i][j] == 1) fresh++;\\n                else if(grid[i][j] == 2) q.push({i, j});\\n        }\\n        vector<pair<int, int>> dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n        while(!q.empty()) {\\n            int n = q.size();\\n            bool rotten = false;\\n            for(int i = 0; i < n; i++) {\\n                auto x = q.front();\\n                q.pop();\\n                for(auto cur: dirs) {\\n                    int i = x.first + cur.first;\\n                    int j = x.second + cur.second;\\n                    if(i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size() && grid[i][j] == 1) {\\n                        grid[i][j] = 2;\\n                        q.push({i, j});\\n                        fresh--;\\n                        rotten = true;\\n                    }\\n                }\\n            }\\n            if(rotten) min++;\\n        } \\n        return fresh ? -1 : min;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int min = 0, fresh = 0;\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++)\\n                if(grid[i][j] == 1) fresh++;\\n                else if(grid[i][j] == 2) q.push({i, j});\\n        }\\n        vector<pair<int, int>> dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n        while(!q.empty()) {\\n            int n = q.size();\\n            bool rotten = false;\\n            for(int i = 0; i < n; i++) {\\n                auto x = q.front();\\n                q.pop();\\n                for(auto cur: dirs) {\\n                    int i = x.first + cur.first;\\n                    int j = x.second + cur.second;\\n                    if(i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size() && grid[i][j] == 1) {\\n                        grid[i][j] = 2;\\n                        q.push({i, j});\\n                        fresh--;\\n                        rotten = true;\\n                    }\\n                }\\n            }\\n            if(rotten) min++;\\n        } \\n        return fresh ? -1 : min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 239032,
                "title": "python-solution",
                "content": "Idea: We do BFS simultaneously from all rotten oranges, while using a counter to keep track of the number of fresh oranges that has become rotten. Once the counter is equal to the total number of fresh oranges, we return the number of days elapsed. If after the BFS, the counter is less than the total number of fresh oranges, we return `-1`.\\n\\nTime complexity: `O(n)`, space complexity: `O(n)`, where `n` is the total number of cells.\\n\\n```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        m = len(grid[0])\\n        count = 0\\n        q = collections.deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                elif grid[i][j] == 2:\\n                    q.append((i,j,0))\\n        seen = set()\\n        while q:\\n            y, x, d = q.popleft()\\n            dirs = {(y-1,x),(y+1,x),(y,x+1),(y,x-1)}\\n            for y1,x1 in dirs:\\n                if 0 <= y1 < n and 0 <= x1 < m and (y1, x1) not in seen and grid[y1][x1] == 1:\\n                    seen.add((y1,x1))\\n                    count -= 1\\n                    if count == 0:\\n                        return d+1\\n                    q.append((y1, x1, d+1))\\n        return 0 if count == 0 else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        m = len(grid[0])\\n        count = 0\\n        q = collections.deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                elif grid[i][j] == 2:\\n                    q.append((i,j,0))\\n        seen = set()\\n        while q:\\n            y, x, d = q.popleft()\\n            dirs = {(y-1,x),(y+1,x),(y,x+1),(y,x-1)}\\n            for y1,x1 in dirs:\\n                if 0 <= y1 < n and 0 <= x1 < m and (y1, x1) not in seen and grid[y1][x1] == 1:\\n                    seen.add((y1,x1))\\n                    count -= 1\\n                    if count == 0:\\n                        return d+1\\n                    q.append((y1, x1, d+1))\\n        return 0 if count == 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239659,
                "title": "dfs-bfs-clean-code",
                "content": "If we regard initially rotten oranges to start nodes, and perform **DFS** traversal, then newly rotten oranges will be \"new\" start nodes, etc.\\n\\n**How shall we tell whether all fresh oranges are able to be rotten?**\\nWe can keep track of number of fresh oranges left during the DFS traversal.\\nIf no newly rotten oranges invovled (thus not able to keep traversing), but there are still fresh oranges, we simply return -1.\\n\\n> DFS\\n```\\nclass Solution {\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int numFreshOranges = 0;\\n        Set<Integer> curRotten = new HashSet<>();\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++) \\n                if (grid[i][j] == 1)\\n                    numFreshOranges++;\\n                else if (grid[i][j] == 2)\\n                    curRotten.add(i * grid[0].length + j);\\n        return rottenFrom(grid, numFreshOranges, curRotten);\\n    }\\n            \\n    private int rottenFrom(int[][] grid, int numFreshOranges, Set<Integer> curRotten) {\\n        if (0 == numFreshOranges) {\\n            return 0;\\n        } else if (curRotten.isEmpty()) {\\n            return -1;\\n        } else {\\n            Set<Integer> nextRotten = new HashSet<>();\\n            \\n            for (int rottenMark : curRotten) {\\n                int x = rottenMark / grid[0].length, y = rottenMark % grid[0].length;\\n                for (int[] direction : directions) {\\n                    int nx = x + direction[0], ny = y + direction[1];\\n                    if (nx < grid.length && nx >= 0 && ny < grid[0].length && ny >= 0 && grid[nx][ny] == 1) { // grid[nx][ny] is rotten.\\n                        numFreshOranges--;\\n                        grid[nx][ny] = 2;\\n                        nextRotten.add(nx * grid[0].length + ny);\\n                    }\\n                }\\n            }\\n\\n            int minutes = rottenFrom(grid, numFreshOranges, nextRotten);\\n            return minutes == -1 ? minutes : minutes + 1;\\n        }\\n    }\\n\\n}\\n```\\n\\n> BFS\\n```\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    private int rows, cols;\\n\\n    public int orangesRotting(int[][] grid) {\\n        rows = grid.length;\\n        cols = grid[0].length;\\n        int numEmpty = 0, minutes = 0;\\n        Deque<Integer> queue = new LinkedList<>();\\n        Set<Integer> rottenSet = new HashSet<>();\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 0) { // empty\\n                    numEmpty++;\\n                } else if (grid[i][j] == 2) { // rotten\\n                    rottenSet.add(i * cols + j);\\n                    queue.offer(i * cols + j);\\n                }\\n            }\\n        }\\n        \\n        // Breadth first search.\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int toRot = queue.poll();\\n                int x = toRot / cols;\\n                int y = toRot % cols;\\n                rottenAround(grid, queue, x, y, rottenSet);\\n            }\\n            minutes++;\\n        }\\n        \\n        if (rottenSet.size() != rows * cols - numEmpty)\\n            return -1;\\n        else\\n            return (minutes > 0) ? minutes - 1 : minutes;\\n    }\\n\\n    private void rottenAround(int[][] grid, Deque<Integer> queue, int x, int y, Set<Integer> rottenSet) {\\n        for (int[] direction : directions) {\\n            int nx = x + direction[0];\\n            int ny = y + direction[1];\\n            int nmark = nx * cols + ny;\\n            if (nx < rows && nx >= 0 && ny < cols && ny >= 0 && grid[nx][ny] == 1 && !rottenSet.contains(nmark)) {\\n                rottenSet.add(nmark);\\n                queue.add(nmark);\\n            }\\n        }\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int numFreshOranges = 0;\\n        Set<Integer> curRotten = new HashSet<>();\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++) \\n                if (grid[i][j] == 1)\\n                    numFreshOranges++;\\n                else if (grid[i][j] == 2)\\n                    curRotten.add(i * grid[0].length + j);\\n        return rottenFrom(grid, numFreshOranges, curRotten);\\n    }\\n            \\n    private int rottenFrom(int[][] grid, int numFreshOranges, Set<Integer> curRotten) {\\n        if (0 == numFreshOranges) {\\n            return 0;\\n        } else if (curRotten.isEmpty()) {\\n            return -1;\\n        } else {\\n            Set<Integer> nextRotten = new HashSet<>();\\n            \\n            for (int rottenMark : curRotten) {\\n                int x = rottenMark / grid[0].length, y = rottenMark % grid[0].length;\\n                for (int[] direction : directions) {\\n                    int nx = x + direction[0], ny = y + direction[1];\\n                    if (nx < grid.length && nx >= 0 && ny < grid[0].length && ny >= 0 && grid[nx][ny] == 1) { // grid[nx][ny] is rotten.\\n                        numFreshOranges--;\\n                        grid[nx][ny] = 2;\\n                        nextRotten.add(nx * grid[0].length + ny);\\n                    }\\n                }\\n            }\\n\\n            int minutes = rottenFrom(grid, numFreshOranges, nextRotten);\\n            return minutes == -1 ? minutes : minutes + 1;\\n        }\\n    }\\n\\n}\\n```\n```\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    private int rows, cols;\\n\\n    public int orangesRotting(int[][] grid) {\\n        rows = grid.length;\\n        cols = grid[0].length;\\n        int numEmpty = 0, minutes = 0;\\n        Deque<Integer> queue = new LinkedList<>();\\n        Set<Integer> rottenSet = new HashSet<>();\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 0) { // empty\\n                    numEmpty++;\\n                } else if (grid[i][j] == 2) { // rotten\\n                    rottenSet.add(i * cols + j);\\n                    queue.offer(i * cols + j);\\n                }\\n            }\\n        }\\n        \\n        // Breadth first search.\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int toRot = queue.poll();\\n                int x = toRot / cols;\\n                int y = toRot % cols;\\n                rottenAround(grid, queue, x, y, rottenSet);\\n            }\\n            minutes++;\\n        }\\n        \\n        if (rottenSet.size() != rows * cols - numEmpty)\\n            return -1;\\n        else\\n            return (minutes > 0) ? minutes - 1 : minutes;\\n    }\\n\\n    private void rottenAround(int[][] grid, Deque<Integer> queue, int x, int y, Set<Integer> rottenSet) {\\n        for (int[] direction : directions) {\\n            int nx = x + direction[0];\\n            int ny = y + direction[1];\\n            int nmark = nx * cols + ny;\\n            if (nx < rows && nx >= 0 && ny < cols && ny >= 0 && grid[nx][ny] == 1 && !rottenSet.contains(nmark)) {\\n                rottenSet.add(nmark);\\n                queue.add(nmark);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280964,
                "title": "python-44-ms-faster-than-99-87",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        rotten = []\\n        # build initial array of rotten oranges\\n        rows = len(grid)\\n        columns = len(grid[0])\\n        for i in range(rows):\\n            for j in range(columns):\\n                if grid[i][j] == 2:\\n                    rotten.append((i, j))\\n\\n        # get unvisited neighbors of all rotten oranges\\n        def add_neighbors(rotten):\\n            neighbors = []\\n            for i, j in rotten:\\n                if i > 0 and grid[i - 1][j] == 1:\\n                    neighbors.append((i - 1, j))\\n                    grid[i-1][j] = 2\\n                if j > 0 and grid[i][j - 1] == 1:\\n                    neighbors.append((i, j - 1))\\n                    grid[i][j-1] = 2\\n                if i < rows - 1 and grid[i + 1][j] == 1:\\n                    neighbors.append((i + 1, j))\\n                    grid[i + 1][j] = 2\\n                if j < columns - 1 and grid[i][j + 1] == 1:\\n                    neighbors.append((i, j + 1))\\n                    grid[i][j+1] = 2\\n            return neighbors\\n\\n        minutes = 0\\n        while (1):\\n            rotten = add_neighbors(rotten)\\n            if len(rotten) == 0:\\n                break\\n            minutes += 1\\n\\n        for i in range(rows):\\n            for j in range(columns):\\n                if grid[i][j] == 1:\\n                    return -1\\n\\n        return minutes\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        rotten = []\\n        # build initial array of rotten oranges\\n        rows = len(grid)\\n        columns = len(grid[0])\\n        for i in range(rows):\\n            for j in range(columns):\\n                if grid[i][j] == 2:\\n                    rotten.append((i, j))\\n\\n        # get unvisited neighbors of all rotten oranges\\n        def add_neighbors(rotten):\\n            neighbors = []\\n            for i, j in rotten:\\n                if i > 0 and grid[i - 1][j] == 1:\\n                    neighbors.append((i - 1, j))\\n                    grid[i-1][j] = 2\\n                if j > 0 and grid[i][j - 1] == 1:\\n                    neighbors.append((i, j - 1))\\n                    grid[i][j-1] = 2\\n                if i < rows - 1 and grid[i + 1][j] == 1:\\n                    neighbors.append((i + 1, j))\\n                    grid[i + 1][j] = 2\\n                if j < columns - 1 and grid[i][j + 1] == 1:\\n                    neighbors.append((i, j + 1))\\n                    grid[i][j+1] = 2\\n            return neighbors\\n\\n        minutes = 0\\n        while (1):\\n            rotten = add_neighbors(rotten)\\n            if len(rotten) == 0:\\n                break\\n            minutes += 1\\n\\n        for i in range(rows):\\n            for j in range(columns):\\n                if grid[i][j] == 1:\\n                    return -1\\n\\n        return minutes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395202,
                "title": "c-bfs-each-line-clearly-explained-4ms",
                "content": "# Feel free to post your doubts in comment\\n **Give a like if it helped you**\\n\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Question involves BFS\\n        // there can be multiple rotten oranges, so its a multi source BFS\\n        // since we need to get the time also when the orange is rotting\\n        // and for any orange that will be time(parent)+1\\n        // so we can take queue of  ( vector of size 3 ) \\n        // v[0]:row , v[1]:column , v[2]:time\\n        int time = 0; // to get the max time\\n        queue<vector<int>> q;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        // insert all the rotten oranges as source in queue\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==2 )\\n                    q.push( {i,j,0} );\\n            }\\n        }     \\n        \\n        int x[]={0,0,1,-1};\\n        int y[]={1,-1,0,0};\\n        \\n        while( !q.empty() ){\\n            \\n            auto f = q.front(); // rotten orange at the front of queue\\n            \\n            // now check all its adjacent cells\\n            for( int i=0; i<4; i++){\\n                int r=f[0]+x[i] ,c=f[1]+y[i];\\n                if( r<0 || r>=n || c<0 || c>=m || grid[r][c]!=1 ) continue; // check if it is valid fresh orange cell\\n                grid[r][c]=2; // make the fresh orange as rotten\\n                int t = f[2] + 1; // time at which this orange became rotten\\n                time = max( time, t ); // update the max time to return ans answer\\n                q.push( {r,c,t} ); // push this rotten orange to queue\\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        // now the max time is stored in \"time\"\\n        // but before returning this we need to check if there is any fresh orange left\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==1 )\\n                    return -1;\\n            }\\n        } \\n        \\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Question involves BFS\\n        // there can be multiple rotten oranges, so its a multi source BFS\\n        // since we need to get the time also when the orange is rotting\\n        // and for any orange that will be time(parent)+1\\n        // so we can take queue of  ( vector of size 3 ) \\n        // v[0]:row , v[1]:column , v[2]:time\\n        int time = 0; // to get the max time\\n        queue<vector<int>> q;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        // insert all the rotten oranges as source in queue\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==2 )\\n                    q.push( {i,j,0} );\\n            }\\n        }     \\n        \\n        int x[]={0,0,1,-1};\\n        int y[]={1,-1,0,0};\\n        \\n        while( !q.empty() ){\\n            \\n            auto f = q.front(); // rotten orange at the front of queue\\n            \\n            // now check all its adjacent cells\\n            for( int i=0; i<4; i++){\\n                int r=f[0]+x[i] ,c=f[1]+y[i];\\n                if( r<0 || r>=n || c<0 || c>=m || grid[r][c]!=1 ) continue; // check if it is valid fresh orange cell\\n                grid[r][c]=2; // make the fresh orange as rotten\\n                int t = f[2] + 1; // time at which this orange became rotten\\n                time = max( time, t ); // update the max time to return ans answer\\n                q.push( {r,c,t} ); // push this rotten orange to queue\\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        // now the max time is stored in \"time\"\\n        // but before returning this we need to check if there is any fresh orange left\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==1 )\\n                    return -1;\\n            }\\n        } \\n        \\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782483,
                "title": "easy-to-understand-fastest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if (grid.empty())\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tint countFreshOranges = 0;\\n\\t\\tsize_t m = grid.size();\\n\\t\\tsize_t n = grid[0].size();\\n\\t\\tqueue<pair<int, int>> q;\\n\\n\\t\\tfor (size_t i = 0; i < m; ++i)\\n\\t\\t{\\n\\t\\t\\tfor (size_t j = 0; j < n; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++countFreshOranges;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (grid[i][j] == 2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push({ i, j });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint time = 0;\\n\\t\\tvector<pair<int, int>> dirs = { {0, 1}, {1, 0}, {-1, 0}, {0, -1} };\\n\\n\\t\\twhile (countFreshOranges != 0 && !q.empty())\\n\\t\\t{\\n\\t\\t\\tsize_t qsize = q.size();\\n\\n\\t\\t\\tfor (size_t i = 0; i < qsize; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto [rottenI, rottenJ] = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor (const auto& d : dirs)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint newX = rottenI + d.first;\\n\\t\\t\\t\\t\\tint newY = rottenJ + d.second;\\n\\t\\t\\t\\t\\tif (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == 1)\\n\\t\\t\\t\\t\\t{\\n                        grid[newX][newY] = 2;\\n\\t\\t\\t\\t\\t\\t--countFreshOranges;\\n\\t\\t\\t\\t\\t\\tq.push({ newX, newY });\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t++time;\\n\\t\\t}\\n\\t\\treturn countFreshOranges == 0 ? time : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if (grid.empty())\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tint countFreshOranges = 0;\\n\\t\\tsize_t m = grid.size();\\n\\t\\tsize_t n = grid[0].size();\\n\\t\\tqueue<pair<int, int>> q;\\n\\n\\t\\tfor (size_t i = 0; i < m; ++i)\\n\\t\\t{\\n\\t\\t\\tfor (size_t j = 0; j < n; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++countFreshOranges;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (grid[i][j] == 2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push({ i, j });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint time = 0;\\n\\t\\tvector<pair<int, int>> dirs = { {0, 1}, {1, 0}, {-1, 0}, {0, -1} };\\n\\n\\t\\twhile (countFreshOranges != 0 && !q.empty())\\n\\t\\t{\\n\\t\\t\\tsize_t qsize = q.size();\\n\\n\\t\\t\\tfor (size_t i = 0; i < qsize; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto [rottenI, rottenJ] = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor (const auto& d : dirs)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint newX = rottenI + d.first;\\n\\t\\t\\t\\t\\tint newY = rottenJ + d.second;\\n\\t\\t\\t\\t\\tif (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == 1)\\n\\t\\t\\t\\t\\t{\\n                        grid[newX][newY] = 2;\\n\\t\\t\\t\\t\\t\\t--countFreshOranges;\\n\\t\\t\\t\\t\\t\\tq.push({ newX, newY });\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t++time;\\n\\t\\t}\\n\\t\\treturn countFreshOranges == 0 ? time : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781882,
                "title": "python-by-bfs-timestamp-w-demo",
                "content": "Python by BFS + timestamp\\n\\n---\\n\\n**Demo**\\n\\n![image](https://assets.leetcode.com/users/images/5290c275-c04e-42b8-9fe5-29930811a80d_1597835250.418689.png)\\n\\nInitial State\\n\\n![image](https://assets.leetcode.com/users/images/ee379b21-3755-494d-aa27-9d9fc2dca7f9_1597835275.0473213.png)\\n\\nStart BFS to infect oranges\\n\\n![image](https://assets.leetcode.com/users/images/59633ce4-b149-46cd-bc76-1d7f0aa7594f_1597835297.3446114.png)\\n\\n![image](https://assets.leetcode.com/users/images/fb3617b6-5813-4e57-9897-e611e17cf39d_1597835308.5351524.png)\\n\\n![image](https://assets.leetcode.com/users/images/c5ac7438-6bc3-4f2c-b109-a5097c398b55_1597835319.6775134.png)\\n\\n![image](https://assets.leetcode.com/users/images/067ea220-c6a3-4225-b64f-85ff78966eb0_1597835333.6524165.png)\\n\\n\\n\\n\\n---\\n\\n```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # Constant for grid state\\n        VISITED = -1\\n        EMPTY = 0\\n        FRESH = 1\\n        ROTTEN = 2\\n        \\n        # Get dimension of grid\\n        h, w = len(grid), len(grid[0])\\n        \\n        # record for fresh oranges\\n        fresh_count = 0\\n        \\n        # record for position of initial rotten oranges\\n        rotten_grid = []       \\n        \\n        # board prescan for parameter initialization\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if grid[y][x] == FRESH:\\n                    fresh_count += 1\\n                    \\n                elif grid[y][x] == ROTTEN:\\n                    rotten_grid.append( (x, y, 0) )\\n                    \\n        traversal_queue = deque(rotten_grid)\\n        \\n        time_record = 0\\n        \\n        # BFS to rotting oranges\\n        while traversal_queue and fresh_count:\\n            \\n            x, y, time_stamp = traversal_queue.popleft()\\n            \\n            for dx, dy in ( (-1, 0), (+1, 0), (0, -1), (0, +1) ):\\n                \\n                next_x, next_y = x + dx, y + dy\\n                \\n                if 0 <= next_x < w and 0 <= next_y < h and grid[next_y][next_x] == FRESH:\\n                    \\n                    fresh_count -= 1\\n                    grid[next_y][next_x] = VISITED\\n                    \\n                    # update time record\\n                    time_record = time_stamp + 1 \\n                    \\n                    # adding current rotten orange to traversal queue\\n                    traversal_queue.append( (next_x, next_y, time_stamp + 1) )\\n        \\n        \\n        # ================================\\n        # All oranges are infected\\n        if fresh_count == 0:\\n            return time_record\\n        \\n        # Some orange remains finally\\n        return -1\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about deque](https://docs.python.org/3/library/collections.html#collections.deque)\\n\\n[2] [Wiki: BFS](https://en.wikipedia.org/wiki/Breadth-first_search)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # Constant for grid state\\n        VISITED = -1\\n        EMPTY = 0\\n        FRESH = 1\\n        ROTTEN = 2\\n        \\n        # Get dimension of grid\\n        h, w = len(grid), len(grid[0])\\n        \\n        # record for fresh oranges\\n        fresh_count = 0\\n        \\n        # record for position of initial rotten oranges\\n        rotten_grid = []       \\n        \\n        # board prescan for parameter initialization\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if grid[y][x] == FRESH:\\n                    fresh_count += 1\\n                    \\n                elif grid[y][x] == ROTTEN:\\n                    rotten_grid.append( (x, y, 0) )\\n                    \\n        traversal_queue = deque(rotten_grid)\\n        \\n        time_record = 0\\n        \\n        # BFS to rotting oranges\\n        while traversal_queue and fresh_count:\\n            \\n            x, y, time_stamp = traversal_queue.popleft()\\n            \\n            for dx, dy in ( (-1, 0), (+1, 0), (0, -1), (0, +1) ):\\n                \\n                next_x, next_y = x + dx, y + dy\\n                \\n                if 0 <= next_x < w and 0 <= next_y < h and grid[next_y][next_x] == FRESH:\\n                    \\n                    fresh_count -= 1\\n                    grid[next_y][next_x] = VISITED\\n                    \\n                    # update time record\\n                    time_record = time_stamp + 1 \\n                    \\n                    # adding current rotten orange to traversal queue\\n                    traversal_queue.append( (next_x, next_y, time_stamp + 1) )\\n        \\n        \\n        # ================================\\n        # All oranges are infected\\n        if fresh_count == 0:\\n            return time_record\\n        \\n        # Some orange remains finally\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781550,
                "title": "c-3-solutions-compared-and-explained-trading-space-for-time-90-time-100-space",
                "content": "Ah, nothing beats stretching your mind in the morning with a nice finite state machine - I guess?\\n\\nAnyway, the problem is pretty straightforward to understand, but not so trivial to execute properly: first of all I declare at class level 2 variables, `maxX` and `maxY`, that I initialised respectively as the number of columns `- 1` and the number of rowss `- 1` first thing when I start my main function.\\n\\nI then declare my usual accumulator `res` to keep track of how many ticks I go with my machine and `freshCount`, that will tell me if there are still fresh oranges around.\\n\\nA convenient vector `toRot` will then store the oranges that I found need to change state to rotten (`2`) in the next tick, avoding me the expensive functional approach of cloning the grid at each step: thanks, but no thanks.\\n\\nOkay, now we are ready to go - first time I used a `do {} while ()` loop in a while, but I think it is the most appropriate here, since we need to run it at least once, to know if there are still fresh oranges and optionally gather other info on the grid.\\n\\nAt each tick (ie: each iteration of the loop), we also start with a nice reset of `freshCount`, `hasRotted`, and `toRot`, then we have the typical nested `for` loop you always do when navigating grid (and always remember you need to use the `y` first when accessing elements with the `[]` operator).\\n\\nIf we find a fresh (`1`) orange, two things can happen (*tertium non datur* in boolean logic):\\n* it has rotten neighbours and if so, we add its coordinates to `toRot` and set `hasRotted` to `true`;\\n* it does not have rotten neighbours, so we increment `freshCount` by `1`.\\n\\nWe shamelessly ignore empty (`0`) or already rotten (`2`) cells, as they are inconsequential while looping; we check the rotten ones only as neighbours, using our handy and pretty straightforward `hasRottenNeighbour` helper that, as the name implies, returns a `true` value if any of the adjacent cells is rotten.\\n\\nOnce done with the 2 nested loops, we can safely update the grid, taking all the coordinates we collected into `toRot` and setting them to `2`; `res` is increased everytime `hasRotted` is `true`.\\n\\nIf a loop goes by without `hasRotted` being set to `true`, we exit and we are ready to return `-1` is there are still fresh oranges as represented by a truthy (ie: `!0`) value of `freshCount` or `res` otherwise.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, freshCount;\\n        bool hasRotted;\\n        vector<pair<int, int>> toRot;\\n        do {\\n            // resetting tracking variables\\n            freshCount = 0;\\n            hasRotted = false;\\n            toRot.clear();\\n            // looping through the grid\\n            for (int y = 0; y <= maxY; y++) {\\n                for (int x = 0; x <= maxX; x++) {\\n                    if (grid[y][x] == 1) {\\n                        if (hasRottenNeighbour(grid, x, y)) {\\n                            toRot.push_back({x, y});\\n                            hasRotted = true;\\n                        }\\n                        else freshCount++;\\n                    }\\n                }\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotted;\\n        } while (hasRotted);\\n        return freshCount ? -1 : res;\\n    }\\n};\\n```\\n\\nVariant tracking and looping only through fresh oranges stored in `currFresh`, which basically equates trading some space to get a faster execution (~96% Time, ~70% Space). The rest of the logic is mostly the same:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, x, y;\\n        bool hasRotten;\\n        vector<pair<int, int>> toRot, prevFresh, currFresh;\\n        // looping through the grid to find the fresh ones\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                if (grid[y][x] == 1) currFresh.push_back({x, y});\\n            }\\n        }\\n        do {\\n            prevFresh = currFresh;\\n            // resetting tracking variables\\n            hasRotten = false;\\n            toRot.clear();\\n            currFresh.clear();\\n            // looping only through all the fresh oranges from the previous tick\\n            for (auto e: prevFresh) {\\n                x = e.first;\\n                y = e.second;\\n                if (hasRottenNeighbour(grid, x, y)) {\\n                    toRot.push_back({x, y});\\n                    hasRotten = true;\\n                }\\n                else currFresh.push_back({x, y});\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotten;\\n        } while (hasRotten);\\n        return currFresh.size() ? -1 : res;\\n    }\\n};\\n```\\n\\nYou might think `queue`s would work much better, but I guess unless you have a significantly bigger grid, that is hardly the case, giving me more or less the same performance of the one above with 2 vectors to keep track of the fresh ones:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, x, y, qLen;\\n        bool hasRotten;\\n        vector<pair<int, int>> toRot;\\n        queue<pair<int, int>> currFresh;\\n        // looping through the grid to find the fresh ones\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                if (grid[y][x] == 1) currFresh.push({x, y});\\n            }\\n        }\\n        do {\\n            // resetting tracking variables\\n            hasRotten = false;\\n            toRot.clear();\\n            qLen = currFresh.size();\\n            // looping only through all the fresh oranges from the previous tick\\n            for (int i = 0; i < qLen; i++) {\\n                x = currFresh.front().first;\\n                y = currFresh.front().second;\\n                currFresh.pop();\\n                if (hasRottenNeighbour(grid, x, y)) {\\n                    toRot.push_back({x, y});\\n                    hasRotten = true;\\n                }\\n                else currFresh.push({x, y});\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotten;\\n        } while (hasRotten);\\n        return qLen ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, freshCount;\\n        bool hasRotted;\\n        vector<pair<int, int>> toRot;\\n        do {\\n            // resetting tracking variables\\n            freshCount = 0;\\n            hasRotted = false;\\n            toRot.clear();\\n            // looping through the grid\\n            for (int y = 0; y <= maxY; y++) {\\n                for (int x = 0; x <= maxX; x++) {\\n                    if (grid[y][x] == 1) {\\n                        if (hasRottenNeighbour(grid, x, y)) {\\n                            toRot.push_back({x, y});\\n                            hasRotted = true;\\n                        }\\n                        else freshCount++;\\n                    }\\n                }\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotted;\\n        } while (hasRotted);\\n        return freshCount ? -1 : res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, x, y;\\n        bool hasRotten;\\n        vector<pair<int, int>> toRot, prevFresh, currFresh;\\n        // looping through the grid to find the fresh ones\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                if (grid[y][x] == 1) currFresh.push_back({x, y});\\n            }\\n        }\\n        do {\\n            prevFresh = currFresh;\\n            // resetting tracking variables\\n            hasRotten = false;\\n            toRot.clear();\\n            currFresh.clear();\\n            // looping only through all the fresh oranges from the previous tick\\n            for (auto e: prevFresh) {\\n                x = e.first;\\n                y = e.second;\\n                if (hasRottenNeighbour(grid, x, y)) {\\n                    toRot.push_back({x, y});\\n                    hasRotten = true;\\n                }\\n                else currFresh.push_back({x, y});\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotten;\\n        } while (hasRotten);\\n        return currFresh.size() ? -1 : res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, x, y, qLen;\\n        bool hasRotten;\\n        vector<pair<int, int>> toRot;\\n        queue<pair<int, int>> currFresh;\\n        // looping through the grid to find the fresh ones\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                if (grid[y][x] == 1) currFresh.push({x, y});\\n            }\\n        }\\n        do {\\n            // resetting tracking variables\\n            hasRotten = false;\\n            toRot.clear();\\n            qLen = currFresh.size();\\n            // looping only through all the fresh oranges from the previous tick\\n            for (int i = 0; i < qLen; i++) {\\n                x = currFresh.front().first;\\n                y = currFresh.front().second;\\n                currFresh.pop();\\n                if (hasRottenNeighbour(grid, x, y)) {\\n                    toRot.push_back({x, y});\\n                    hasRotten = true;\\n                }\\n                else currFresh.push({x, y});\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotten;\\n        } while (hasRotten);\\n        return qLen ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444291,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Use BFS - search level by level, each level = another minute\\n2. Get the original rotten oranges, and start bfs from them\\n``` javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n    let queue = [];\\n    let minutes = 0;\\n    let fresh = 0;\\n    for (let i=0;i<grid.length;i++) {\\n        for (let j=0;j<grid[0].length;j++) {\\n            if (grid[i][j]==1) fresh++;\\n            if (grid[i][j]==2) queue.push([i, j]);\\n        }\\n    }\\n\\n    while (queue.length!=0 && fresh) {\\n        let dR = [0,-1,0,1];\\n        let dC = [-1,0,1,0];\\n        \\n        let next = [];\\n        while (queue.length!=0 ) {\\n            let current = queue.shift();\\n            for (let i=0;i<dR.length;i++) {\\n                let nR = current[0]+dR[i];\\n                let nC = current[1]+dC[i];\\n                if (nR>=0 && nC>=0 && nR<grid.length && nC<grid[0].length) {\\n                    if (grid[nR][nC]==1) {\\n                        grid[nR][nC]=2;\\n                        fresh--;\\n                        next.push([nR,nC]);\\n                    }\\n                }\\n            }\\n        }\\n        minutes++;\\n        queue = next;\\n    }\\n\\n    return fresh==0?minutes:-1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n    let queue = [];\\n    let minutes = 0;\\n    let fresh = 0;\\n    for (let i=0;i<grid.length;i++) {\\n        for (let j=0;j<grid[0].length;j++) {\\n            if (grid[i][j]==1) fresh++;\\n            if (grid[i][j]==2) queue.push([i, j]);\\n        }\\n    }\\n\\n    while (queue.length!=0 && fresh) {\\n        let dR = [0,-1,0,1];\\n        let dC = [-1,0,1,0];\\n        \\n        let next = [];\\n        while (queue.length!=0 ) {\\n            let current = queue.shift();\\n            for (let i=0;i<dR.length;i++) {\\n                let nR = current[0]+dR[i];\\n                let nC = current[1]+dC[i];\\n                if (nR>=0 && nC>=0 && nR<grid.length && nC<grid[0].length) {\\n                    if (grid[nR][nC]==1) {\\n                        grid[nR][nC]=2;\\n                        fresh--;\\n                        next.push([nR,nC]);\\n                    }\\n                }\\n            }\\n        }\\n        minutes++;\\n        queue = next;\\n    }\\n\\n    return fresh==0?minutes:-1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 243995,
                "title": "the-marker-technique-and-a-trick-to-avoid-corner-cases",
                "content": "**Note**--- This code is not as compact and short as other codes posted here. I\\'m just posting it here to introduce the concept of ***Marker*** during level order traversal, which essentially avoids using another queue to denote the end of a level. Moreover, a lot of questions on matrices often require checking for boundary cases, (which can lead to Segmentation fault if not done properly). Below, I\\'ve included a simple trick to get rid of this problem. \\n\\n* We create a boolean function **legal()** which takes 2 parameters as input, the row and the column number of a particular cell and returns **True** if that cell is within bounds, else it returns **False**. This way we can stop worrying about corner cases if we use the **legal()** function before accessing any cell.\\n* We create a **Marker**, namely the pair **(-1,-1)** and push it into the queue whenever a level finishes. Whenever we pop a marker, it denotes the completion of another level, so any popping of a marker would immediately be followed by pushing of another marker. \\n\\n\\n**Credits** ---- Both the **Marker** technique and the **legal()** technique is inspired by the general coding style of **GeekForGeeks**.\\n```\\nclass Solution\\n{\\n    int ROW, COL;\\n    vector<vector<bool>> visited;\\n    queue<pair<int,int>> myQueue;\\npublic:\\n    bool legal(int row, int col);\\n    void visitTheCell(int i, int j, vector<vector<int>> &mat);\\n    int orangesRotting(vector<vector<int>>& grid);\\n};\\n\\n/* Utility function to check if the index is in bounds or not */\\nbool Solution :: legal(int row, int col)\\n{\\n    if(row>=0 && row<ROW && col>=0 && col<COL) return true;\\n    else return false;\\n}\\n\\n/* This function visits the cell (i,j) given the constraints */\\nvoid Solution :: visitTheCell(int i, int j, vector<vector<int>> &mat)\\n{\\n    // In bounds and not visited and should contain fresh oranges\\n    if(legal(i,j) && !visited[i][j] && mat[i][j]==1)\\n    {\\n        // Push it on the queue to rot other oranges, and visit it\\n        myQueue.push(make_pair(i,j));\\n        visited[i][j] = true;\\n    }\\n}\\n\\nint Solution :: orangesRotting(vector<vector<int>> &mat)\\n{\\n    ROW = mat.size();\\n    COL = mat[0].size();\\n    \\n    // Set the delimiter to record time\\n    auto deLimiter = make_pair(-1,-1);\\n\\n    // Resize the viisted matrix and set it to false\\n    visited.resize(ROW);\\n    for(auto &row_vec : visited)\\n        row_vec.resize(COL);\\n    \\n    // Traverse the matrix and store the cells with rotten oranges\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(mat[i][j] == 2) myQueue.push(make_pair(i,j));\\n            \\n    // Now that all the rottten oranges are stored, Push the deLimiter\\n    myQueue.push(deLimiter);\\n    \\n    // Create the counter from -1 as the first deLimiter is misleading, the first set of oranges\\n    // take no time to rot as they are already rotted\\n    int __time=-1;\\n    \\n    // Apply BFS\\n    while(!myQueue.empty())\\n    {\\n        while(myQueue.front()!=deLimiter)\\n        {\\n            // Extract the current element and rot all the neighbours\\n            auto current = myQueue.front();\\n            myQueue.pop();\\n            \\n            // Store the location of cells\\n            int i, j;\\n            i = current.first;\\n            j = current.second;\\n            \\n            // Visit all the neighbours\\n            \\n            // Up \\n            visitTheCell(i-1,j,mat);\\n            \\n            // Down\\n            visitTheCell(i+1,j,mat);\\n            \\n            // Left\\n            visitTheCell(i,j-1,mat);\\n            \\n            // Right\\n            visitTheCell(i,j+1,mat);\\n        }\\n        \\n        // So now we have a deLimiter, pop it and see if the queue is empty\\n        // If it is not, insert a new deLimiter\\n        \\n        myQueue.pop();\\n        \\n        // Increase the time as delimiter has been popped \\n        __time++;\\n        \\n        // Check if deLimiter has to be pushed\\n        if(!myQueue.empty()) myQueue.push(deLimiter);\\n    }\\n    \\n    bool isFreshOrangeLeft = false;\\n    \\n    // Traverse and check if all the oranges have been rotted or not\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(mat[i][j]==1 && !visited[i][j]) isFreshOrangeLeft = true;\\n    \\n    if(isFreshOrangeLeft) return -1;\\n    else return __time;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    int ROW, COL;\\n    vector<vector<bool>> visited;\\n    queue<pair<int,int>> myQueue;\\npublic:\\n    bool legal(int row, int col);\\n    void visitTheCell(int i, int j, vector<vector<int>> &mat);\\n    int orangesRotting(vector<vector<int>>& grid);\\n};\\n\\n/* Utility function to check if the index is in bounds or not */\\nbool Solution :: legal(int row, int col)\\n{\\n    if(row>=0 && row<ROW && col>=0 && col<COL) return true;\\n    else return false;\\n}\\n\\n/* This function visits the cell (i,j) given the constraints */\\nvoid Solution :: visitTheCell(int i, int j, vector<vector<int>> &mat)\\n{\\n    // In bounds and not visited and should contain fresh oranges\\n    if(legal(i,j) && !visited[i][j] && mat[i][j]==1)\\n    {\\n        // Push it on the queue to rot other oranges, and visit it\\n        myQueue.push(make_pair(i,j));\\n        visited[i][j] = true;\\n    }\\n}\\n\\nint Solution :: orangesRotting(vector<vector<int>> &mat)\\n{\\n    ROW = mat.size();\\n    COL = mat[0].size();\\n    \\n    // Set the delimiter to record time\\n    auto deLimiter = make_pair(-1,-1);\\n\\n    // Resize the viisted matrix and set it to false\\n    visited.resize(ROW);\\n    for(auto &row_vec : visited)\\n        row_vec.resize(COL);\\n    \\n    // Traverse the matrix and store the cells with rotten oranges\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(mat[i][j] == 2) myQueue.push(make_pair(i,j));\\n            \\n    // Now that all the rottten oranges are stored, Push the deLimiter\\n    myQueue.push(deLimiter);\\n    \\n    // Create the counter from -1 as the first deLimiter is misleading, the first set of oranges\\n    // take no time to rot as they are already rotted\\n    int __time=-1;\\n    \\n    // Apply BFS\\n    while(!myQueue.empty())\\n    {\\n        while(myQueue.front()!=deLimiter)\\n        {\\n            // Extract the current element and rot all the neighbours\\n            auto current = myQueue.front();\\n            myQueue.pop();\\n            \\n            // Store the location of cells\\n            int i, j;\\n            i = current.first;\\n            j = current.second;\\n            \\n            // Visit all the neighbours\\n            \\n            // Up \\n            visitTheCell(i-1,j,mat);\\n            \\n            // Down\\n            visitTheCell(i+1,j,mat);\\n            \\n            // Left\\n            visitTheCell(i,j-1,mat);\\n            \\n            // Right\\n            visitTheCell(i,j+1,mat);\\n        }\\n        \\n        // So now we have a deLimiter, pop it and see if the queue is empty\\n        // If it is not, insert a new deLimiter\\n        \\n        myQueue.pop();\\n        \\n        // Increase the time as delimiter has been popped \\n        __time++;\\n        \\n        // Check if deLimiter has to be pushed\\n        if(!myQueue.empty()) myQueue.push(deLimiter);\\n    }\\n    \\n    bool isFreshOrangeLeft = false;\\n    \\n    // Traverse and check if all the oranges have been rotted or not\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(mat[i][j]==1 && !visited[i][j]) isFreshOrangeLeft = true;\\n    \\n    if(isFreshOrangeLeft) return -1;\\n    else return __time;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781863,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList();\\n        int freshCount = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if (grid[i][j] == 2)\\n                    queue.add(new int[]{i, j});\\n                if (grid[i][j] == 1)\\n                    freshCount ++;\\n            }\\n        }\\n        int time = 0;\\n        int [][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        while(!queue.isEmpty() && freshCount > 0){\\n            time ++;\\n            int size = queue.size();\\n            while(size > 0){\\n                int [] xy = queue.poll();\\n                for(int [] d : directions){\\n                    int x = xy[0] + d[0];\\n                    int y = xy[1] + d[1];\\n                    if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0 || grid[x][y] == 2)\\n                        continue;\\n                    queue.add(new int []{x, y});\\n                    grid[x][y] = 2;\\n                    freshCount --;\\n                } \\n                size --;\\n            }\\n        }\\n        return freshCount == 0 ? time : -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList();\\n        int freshCount = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if (grid[i][j] == 2)\\n                    queue.add(new int[]{i, j});\\n                if (grid[i][j] == 1)\\n                    freshCount ++;\\n            }\\n        }\\n        int time = 0;\\n        int [][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        while(!queue.isEmpty() && freshCount > 0){\\n            time ++;\\n            int size = queue.size();\\n            while(size > 0){\\n                int [] xy = queue.poll();\\n                for(int [] d : directions){\\n                    int x = xy[0] + d[0];\\n                    int y = xy[1] + d[1];\\n                    if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0 || grid[x][y] == 2)\\n                        continue;\\n                    queue.add(new int []{x, y});\\n                    grid[x][y] = 2;\\n                    freshCount --;\\n                } \\n                size --;\\n            }\\n        }\\n        return freshCount == 0 ? time : -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734240,
                "title": "python3-solution-using-two-sets-beats-99-with-explanation",
                "content": "We don\\'t need to traverse the whole grid in every iteration. Specially if the oranges are scarse in the grid, traversing the whole grid will waste a lot of time. What I do, is that I use two sets to save the coordinates of the fresh and rotten oranges. So in my code fresh_coords is the set of the coordinates for the fresh oranges and rotten_coords is the set of coordinates for the rotten ones.\\n\\nAt every iteration, I check the neigbors of the fresh oranges, if there is a rotten orange in the 4 directional neighbors, I add that coordinate to the newly_rotten set. At the end, if the newly_rotten set is empty, it means that there is no way to rotten all of the oragnes. If it is not empty, I just remove those coordinates from the fresh_coords and add them to the rotten_coords, without changing anything in the grid. \\n\\nThis solution runs very fast, because number of fresh oranges will be decreasing over time, and as a result the outer most loop which is ```for fresh in fresh_coords: ```  will become shorter.\\n\\n```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        if not grid:\\n            return 0\\n        fresh_coords = set()\\n        rotten_coords = set()\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid[i][j] == 1:\\n                    fresh_coords.add((i, j))\\n                elif grid[i][j] == 2:\\n                    rotten_coords.add((i, j))\\n                    \\n        return self.recursive(fresh_coords, rotten_coords, rows, cols)\\n        \\n    \\n    def recursive(self, fresh_coords, rotten_coords, rows, cols):\\n        if not fresh_coords:\\n            return 0\\n        if not rotten_coords:\\n            return -1\\n        newly_rotten = set()\\n        \\n        # start finding newly rotten oranges\\n        for fresh in fresh_coords:\\n            for neighbor in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\\n                x = fresh[0] + neighbor[0]\\n                y = fresh[1] + neighbor[1]\\n                if x >= 0 and x < rows and y >= 0 and y < cols and (x, y) in rotten_coords:\\n                    newly_rotten.add(fresh)\\n                            \\n        \\'\\'\\'\\n\\t\\tif there is no newly_rotten orange, it means there is no way to \\n\\t\\treach the fresh ones; remember that we have already made \\n\\t\\tsure that there are fresh oranges in the grid by checking the \\n\\t\\tnumber of fresh ones at the start of the recursive function.\\n\\t\\t\\'\\'\\'\\n        if not newly_rotten:\\n            return -1\\n        else:\\n            for coords in newly_rotten:\\n                fresh_coords.remove(coords)\\n                rotten_coords.add(coords)\\n                \\n            temp = self.recursive(fresh_coords, rotten_coords, rows, cols)\\n            if temp == -1:\\n                return -1\\n            else:\\n                return 1 + temp\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```for fresh in fresh_coords: ```\n```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        if not grid:\\n            return 0\\n        fresh_coords = set()\\n        rotten_coords = set()\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid[i][j] == 1:\\n                    fresh_coords.add((i, j))\\n                elif grid[i][j] == 2:\\n                    rotten_coords.add((i, j))\\n                    \\n        return self.recursive(fresh_coords, rotten_coords, rows, cols)\\n        \\n    \\n    def recursive(self, fresh_coords, rotten_coords, rows, cols):\\n        if not fresh_coords:\\n            return 0\\n        if not rotten_coords:\\n            return -1\\n        newly_rotten = set()\\n        \\n        # start finding newly rotten oranges\\n        for fresh in fresh_coords:\\n            for neighbor in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\\n                x = fresh[0] + neighbor[0]\\n                y = fresh[1] + neighbor[1]\\n                if x >= 0 and x < rows and y >= 0 and y < cols and (x, y) in rotten_coords:\\n                    newly_rotten.add(fresh)\\n                            \\n        \\'\\'\\'\\n\\t\\tif there is no newly_rotten orange, it means there is no way to \\n\\t\\treach the fresh ones; remember that we have already made \\n\\t\\tsure that there are fresh oranges in the grid by checking the \\n\\t\\tnumber of fresh ones at the start of the recursive function.\\n\\t\\t\\'\\'\\'\\n        if not newly_rotten:\\n            return -1\\n        else:\\n            for coords in newly_rotten:\\n                fresh_coords.remove(coords)\\n                rotten_coords.add(coords)\\n                \\n            temp = self.recursive(fresh_coords, rotten_coords, rows, cols)\\n            if temp == -1:\\n                return -1\\n            else:\\n                return 1 + temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531264,
                "title": "easy-java-not-much-to-say-about-this",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m=grid.length,n=grid[0].length,i,j,k=0,fresh=0,fr;\\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(grid[i][j]==1) fresh++;\\n        while(fresh>0){\\n            fr=fresh;\\n            for(i=0;i<m;i++){\\n                for(j=0;j<n;j++){\\n                    if(grid[i][j]==2){\\n                        if(i+1<m && grid[i+1][j]==1) {grid[i+1][j]=3;fresh--;}\\n                        if(i-1>=0 && grid[i-1][j]==1) {grid[i-1][j]=3;fresh--;}\\n                        if(j-1>=0 && grid[i][j-1]==1) {grid[i][j-1]=3;fresh--;}\\n                        if(j+1<n && grid[i][j+1]==1) {grid[i][j+1]=3;fresh--;}\\n                    }\\n                }\\n            }\\n            for(i=0;i<m;i++)\\n                for(j=0;j<n;j++)\\n                    if(grid[i][j]==3) grid[i][j]=2;\\n            if(fr==fresh) return -1;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m=grid.length,n=grid[0].length,i,j,k=0,fresh=0,fr;\\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(grid[i][j]==1) fresh++;\\n        while(fresh>0){\\n            fr=fresh;\\n            for(i=0;i<m;i++){\\n                for(j=0;j<n;j++){\\n                    if(grid[i][j]==2){\\n                        if(i+1<m && grid[i+1][j]==1) {grid[i+1][j]=3;fresh--;}\\n                        if(i-1>=0 && grid[i-1][j]==1) {grid[i-1][j]=3;fresh--;}\\n                        if(j-1>=0 && grid[i][j-1]==1) {grid[i][j-1]=3;fresh--;}\\n                        if(j+1<n && grid[i][j+1]==1) {grid[i][j+1]=3;fresh--;}\\n                    }\\n                }\\n            }\\n            for(i=0;i<m;i++)\\n                for(j=0;j<n;j++)\\n                    if(grid[i][j]==3) grid[i][j]=2;\\n            if(fr==fresh) return -1;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278351,
                "title": "c-dfs-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid, int i, int j, int min=2)\\n    {\\n        if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or  grid[i][j]==0 or (1 < grid[i][j] and grid[i][j] < min))return ;\\n        grid[i][j]=min; // Assign the current minute to the grid\\n        dfs(grid,i+1,j,min+1);  // Recursive call to all 4 sides one by one and by incrementing tine by +1\\n         dfs(grid,i-1,j,min+1);\\n         dfs(grid,i,j+1,min+1);\\n         dfs(grid,i,j-1,min+1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==2) dfs(grid,i,j); // We have to proceed on those orananges which are rotten already and start a recursive call and the reason why we are sending 2 is because we cannot mark time as 0,1,2 Since they are being used in the question (empty cell, fresh orange,rotten orange) \\n            }\\n        }\\n        int min=2;\\n        for(auto &i:grid)\\n        {\\n            for(auto &j:i)\\n            {\\n                if(j==1) return -1; // if by any means, any value is 1, that means we weren\\'t able to rot that orange, Here min= Total time (minutes)\\n                min=max(min,j);  // otherwise, maximum time to rot.\\n            }\\n        }\\n        return min-2;\\n    }\\n};\\n```\\n**Kindly upvote, if you like the solution :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid, int i, int j, int min=2)\\n    {\\n        if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or  grid[i][j]==0 or (1 < grid[i][j] and grid[i][j] < min))return ;\\n        grid[i][j]=min; // Assign the current minute to the grid\\n        dfs(grid,i+1,j,min+1);  // Recursive call to all 4 sides one by one and by incrementing tine by +1\\n         dfs(grid,i-1,j,min+1);\\n         dfs(grid,i,j+1,min+1);\\n         dfs(grid,i,j-1,min+1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==2) dfs(grid,i,j); // We have to proceed on those orananges which are rotten already and start a recursive call and the reason why we are sending 2 is because we cannot mark time as 0,1,2 Since they are being used in the question (empty cell, fresh orange,rotten orange) \\n            }\\n        }\\n        int min=2;\\n        for(auto &i:grid)\\n        {\\n            for(auto &j:i)\\n            {\\n                if(j==1) return -1; // if by any means, any value is 1, that means we weren\\'t able to rot that orange, Here min= Total time (minutes)\\n                min=max(min,j);  // otherwise, maximum time to rot.\\n            }\\n        }\\n        return min-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755398,
                "title": "java-with-comments-100-accepted",
                "content": "**Upvote if you like**\\n\\n```\\nclass Solution {\\n    \\n    class indexies{\\n        int x;\\n        int y;\\n        \\n        indexies(int x,int y){\\n            this.x=x;\\n            this.y=y;\\n        }\\n        \\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        \\n        Queue<indexies> q=new LinkedList<>();\\n        int ones=0;\\n        int m=grid.length,n=grid[0].length;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t\\t//rotton oranges positions\\n                if(grid[i][j]==2){\\n                    q.add(new indexies(i,j));\\n                }\\n\\t\\t\\t\\t//count the fresh oranges\\n                else if(grid[i][j]==1){\\n                    ones++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//if no rotton but we have fresh oranges so 0 time taken\\n        if(q.size()==0 && ones>0) \\n            return -1;\\n\\t\\t//we don\\'t have any fresh oranges\\n        if(ones==0)\\n            return 0;\\n        \\n        int ans=0;\\n        \\n        int dir[][]={{0,1},{0,-1},{-1,0},{1,0}};\\n        \\n        while(!q.isEmpty()){\\n            \\n\\t\\t\\t//add and travel\\n            int size=q.size();\\n            boolean f=false;              \\n            \\n\\t\\t\\t//moves to add rotton vertices\\n            for(int ii=0;ii<size;ii++){\\n                indexies temp=q.poll();\\n            \\n                //move to all the adjacent vertices\\n                for(int i=0;i<4;i++){\\n                    int new_x=temp.x+dir[i][0];\\n                    int new_y=temp.y+dir[i][1];\\n                \\n                    //if we find fresh anywhere in the grid\\n                    if(new_x>=0 && new_y>=0 && new_x<m && new_y<n && grid[new_x][new_y]==1){\\n                        \\n\\t\\t\\t\\t\\t\\t//make it rotton and add position\\n                        grid[new_x][new_y]=2;\\n                        q.add(new indexies(new_x,new_y));\\n                        ones--;\\n                        \\n                        //we take the time to make all the adjacent fresh to rotton\\n                        //means we found the fresh oranges and make it rotton\\n                        f=true;\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            //if we found fresh and make it rotton means we consume time so increase it\\n            if(f){\\n                ans++;\\n            }\\n            \\n        }\\n        \\n        //somwhere in the grid fresh is present means no possible way\\n        if(ones>0)\\n            return -1;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class indexies{\\n        int x;\\n        int y;\\n        \\n        indexies(int x,int y){\\n            this.x=x;\\n            this.y=y;\\n        }\\n        \\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        \\n        Queue<indexies> q=new LinkedList<>();\\n        int ones=0;\\n        int m=grid.length,n=grid[0].length;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t\\t//rotton oranges positions\\n                if(grid[i][j]==2){\\n                    q.add(new indexies(i,j));\\n                }\\n\\t\\t\\t\\t//count the fresh oranges\\n                else if(grid[i][j]==1){\\n                    ones++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//if no rotton but we have fresh oranges so 0 time taken\\n        if(q.size()==0 && ones>0) \\n            return -1;\\n\\t\\t//we don\\'t have any fresh oranges\\n        if(ones==0)\\n            return 0;\\n        \\n        int ans=0;\\n        \\n        int dir[][]={{0,1},{0,-1},{-1,0},{1,0}};\\n        \\n        while(!q.isEmpty()){\\n            \\n\\t\\t\\t//add and travel\\n            int size=q.size();\\n            boolean f=false;              \\n            \\n\\t\\t\\t//moves to add rotton vertices\\n            for(int ii=0;ii<size;ii++){\\n                indexies temp=q.poll();\\n            \\n                //move to all the adjacent vertices\\n                for(int i=0;i<4;i++){\\n                    int new_x=temp.x+dir[i][0];\\n                    int new_y=temp.y+dir[i][1];\\n                \\n                    //if we find fresh anywhere in the grid\\n                    if(new_x>=0 && new_y>=0 && new_x<m && new_y<n && grid[new_x][new_y]==1){\\n                        \\n\\t\\t\\t\\t\\t\\t//make it rotton and add position\\n                        grid[new_x][new_y]=2;\\n                        q.add(new indexies(new_x,new_y));\\n                        ones--;\\n                        \\n                        //we take the time to make all the adjacent fresh to rotton\\n                        //means we found the fresh oranges and make it rotton\\n                        f=true;\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            //if we found fresh and make it rotton means we consume time so increase it\\n            if(f){\\n                ans++;\\n            }\\n            \\n        }\\n        \\n        //somwhere in the grid fresh is present means no possible way\\n        if(ones>0)\\n            return -1;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641680,
                "title": "java-bfs-detailed-explanation",
                "content": "```\\nclass Solution {\\n    \\n      public class Pair {\\n    int row;\\n    int col;\\n\\n    Pair(int row, int col) {\\n      this.row = row;\\n      this.col = col;\\n    }\\n\\n  }\\n\\n    public int orangesRotting(int[][] grid) {\\n            \\n    //   Step1:- we are going to add those element index in the queue whose value is 2 and along with that we are also going to the value on how many times 1 is present and we will use it further to see if it is possible to rotten all the oranges or not\\n    \\n    ArrayDeque <Pair> q=new ArrayDeque<>();\\n    int fone=0;//frequency of one\\n    \\n    for(int i =0;i<grid.length;i++){\\n        for(int j=0;j<grid[0].length;j++){\\n            if(grid[i][j]==2){\\n                q.add(new Pair(i,j));\\n            }\\n            else if(grid[i][j]==1){\\n                fone++;\\n            }\\n        }\\n    }\\n    \\n    if(fone==0){\\n        return 0; //no one i.e nothing is fresh so nothing will got rotten\\n    }\\n    \\n    // here we have used 2 loops first loop is just used to find level and in 2nd loop we are applying BFS algo levelwise\\n    \\n    int level=-1;\\n\\n    int [][] dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n    while(q.size()!=0){\\n        int size=q.size();\\n        level++;\\n        \\n        // Inner loop\\n        while(size>0){\\n            Pair rem=q.removeFirst();\\n            \\n            // Now we will travel in all 4 direction\\n            \\n            for(int i =0;i<dirs.length;i++){\\n                int newrow=rem.row+dirs[i][0];\\n                int newcoloum=rem.col+dirs[i][1];\\n                \\n                if(newrow>=0 && newcoloum>=0 && newrow<grid.length && newcoloum<grid[0].length && grid[newrow][newcoloum]==1){\\n                    // whose value is 1 we will change its value 0 to as now they would be rotted\\n                q.add(new Pair(newrow,newcoloum));\\n                fone--;//as if(fone==0) then all fresh would be rottened so we are decreasing its value\\n                grid[newrow][newcoloum]=0;\\n                    \\n                }\\n            }\\n            size--;\\n        }\\n    }\\n    \\n    if(fone!=0){\\n        return -1;\\n    }\\n    return level;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n      public class Pair {\\n    int row;\\n    int col;\\n\\n    Pair(int row, int col) {\\n      this.row = row;\\n      this.col = col;\\n    }\\n\\n  }\\n\\n    public int orangesRotting(int[][] grid) {\\n            \\n    //   Step1:- we are going to add those element index in the queue whose value is 2 and along with that we are also going to the value on how many times 1 is present and we will use it further to see if it is possible to rotten all the oranges or not\\n    \\n    ArrayDeque <Pair> q=new ArrayDeque<>();\\n    int fone=0;//frequency of one\\n    \\n    for(int i =0;i<grid.length;i++){\\n        for(int j=0;j<grid[0].length;j++){\\n            if(grid[i][j]==2){\\n                q.add(new Pair(i,j));\\n            }\\n            else if(grid[i][j]==1){\\n                fone++;\\n            }\\n        }\\n    }\\n    \\n    if(fone==0){\\n        return 0; //no one i.e nothing is fresh so nothing will got rotten\\n    }\\n    \\n    // here we have used 2 loops first loop is just used to find level and in 2nd loop we are applying BFS algo levelwise\\n    \\n    int level=-1;\\n\\n    int [][] dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n    while(q.size()!=0){\\n        int size=q.size();\\n        level++;\\n        \\n        // Inner loop\\n        while(size>0){\\n            Pair rem=q.removeFirst();\\n            \\n            // Now we will travel in all 4 direction\\n            \\n            for(int i =0;i<dirs.length;i++){\\n                int newrow=rem.row+dirs[i][0];\\n                int newcoloum=rem.col+dirs[i][1];\\n                \\n                if(newrow>=0 && newcoloum>=0 && newrow<grid.length && newcoloum<grid[0].length && grid[newrow][newcoloum]==1){\\n                    // whose value is 1 we will change its value 0 to as now they would be rotted\\n                q.add(new Pair(newrow,newcoloum));\\n                fone--;//as if(fone==0) then all fresh would be rottened so we are decreasing its value\\n                grid[newrow][newcoloum]=0;\\n                    \\n                }\\n            }\\n            size--;\\n        }\\n    }\\n    \\n    if(fone!=0){\\n        return -1;\\n    }\\n    return level;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547456,
                "title": "clean-go-solution-using-bfs-beats-100",
                "content": "```\\nvar directions = [4][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\\n\\nconst (\\n\\tFresh  = 1\\n\\tRotten = 2\\n)\\n\\nfunc orangesRotting(grid [][]int) int {\\n\\tm, n := len(grid), len(grid[0])\\n\\tvar rotten [][2]int\\n\\n\\tfresh := 0\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tswitch grid[i][j] {\\n\\t\\t\\tcase Fresh:\\n\\t\\t\\t\\tfresh++\\n\\t\\t\\tcase Rotten:\\n\\t\\t\\t\\trotten = append(rotten, [2]int{i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif fresh == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tminutes := 0\\n\\tfor len(rotten) > 0 {\\n\\t\\tfor _, o := range rotten {\\n\\t\\t\\tfor _, dir := range directions {\\n\\t\\t\\t\\tx, y := o[0]+dir[0], o[1]+dir[1]\\n\\t\\t\\t\\tif x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == Fresh {\\n\\t\\t\\t\\t\\tgrid[x][y] = Rotten\\n\\t\\t\\t\\t\\trotten = append(rotten, [2]int{x, y})\\n\\t\\t\\t\\t\\tfresh--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\trotten = rotten[1:]\\n\\t\\t}\\n\\n\\t\\tminutes++\\n\\t\\tif fresh == 0 {\\n\\t\\t\\treturn minutes\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar directions = [4][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\\n\\nconst (\\n\\tFresh  = 1\\n\\tRotten = 2\\n)\\n\\nfunc orangesRotting(grid [][]int) int {\\n\\tm, n := len(grid), len(grid[0])\\n\\tvar rotten [][2]int\\n\\n\\tfresh := 0\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tswitch grid[i][j] {\\n\\t\\t\\tcase Fresh:\\n\\t\\t\\t\\tfresh++\\n\\t\\t\\tcase Rotten:\\n\\t\\t\\t\\trotten = append(rotten, [2]int{i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif fresh == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tminutes := 0\\n\\tfor len(rotten) > 0 {\\n\\t\\tfor _, o := range rotten {\\n\\t\\t\\tfor _, dir := range directions {\\n\\t\\t\\t\\tx, y := o[0]+dir[0], o[1]+dir[1]\\n\\t\\t\\t\\tif x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == Fresh {\\n\\t\\t\\t\\t\\tgrid[x][y] = Rotten\\n\\t\\t\\t\\t\\trotten = append(rotten, [2]int{x, y})\\n\\t\\t\\t\\t\\tfresh--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\trotten = rotten[1:]\\n\\t\\t}\\n\\n\\t\\tminutes++\\n\\t\\tif fresh == 0 {\\n\\t\\t\\treturn minutes\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519411,
                "title": "c-bfs-solution-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if(grid.empty())return 0; //this is base case.. if we don\\'t have any orange to rotten then it will take 0 days\\n        \\n        int count=0,days=0,total=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 2){ //this is done to push all the rotten oranges to the queue\\n                    q.push({i,j});\\n                }\\n                if(grid[i][j] != 0){ //this is helpful when we have to check that all the oranges are rotten or not in future\\n                    total++;\\n                }\\n            }\\n        }\\n        //this are the only directions in which our bfs will go.. so i used arrays for x and y coordinate\\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        \\n        while(!q.empty()){\\n            int k = q.size(); // at one day we can rot this many oranges\\n            count += k;\\n            while(k--){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                \\n                for(int i=0;i<4;i++){ // by using this loop we may go in four possible directions..\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[i];\\n                    //now we have check the conditions for bounds and if there is blank space or already rotten orange then we will simply ignore\\n                    if(nx<0 || nx>=m || ny>=n || ny<0 || grid[nx][ny] != 1)continue;\\n                    grid[nx][ny] = 2; //after that we will mark the orange as rotten and push it into our queue data structure\\n                    q.push({nx,ny});\\n                }\\n            }\\n            if(!q.empty())days++; //this is used to check how many days are required to rotten all the oranges\\n        }\\n        return total == count ? days : -1; //if the total elements leaving blank space is equal to the elements pushed inside the queue then we can say our all oranges are rottened and we will simply return days otherwise we will return -1..\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if(grid.empty())return 0; //this is base case.. if we don\\'t have any orange to rotten then it will take 0 days\\n        \\n        int count=0,days=0,total=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 2){ //this is done to push all the rotten oranges to the queue\\n                    q.push({i,j});\\n                }\\n                if(grid[i][j] != 0){ //this is helpful when we have to check that all the oranges are rotten or not in future\\n                    total++;\\n                }\\n            }\\n        }\\n        //this are the only directions in which our bfs will go.. so i used arrays for x and y coordinate\\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        \\n        while(!q.empty()){\\n            int k = q.size(); // at one day we can rot this many oranges\\n            count += k;\\n            while(k--){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                \\n                for(int i=0;i<4;i++){ // by using this loop we may go in four possible directions..\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[i];\\n                    //now we have check the conditions for bounds and if there is blank space or already rotten orange then we will simply ignore\\n                    if(nx<0 || nx>=m || ny>=n || ny<0 || grid[nx][ny] != 1)continue;\\n                    grid[nx][ny] = 2; //after that we will mark the orange as rotten and push it into our queue data structure\\n                    q.push({nx,ny});\\n                }\\n            }\\n            if(!q.empty())days++; //this is used to check how many days are required to rotten all the oranges\\n        }\\n        return total == count ? days : -1; //if the total elements leaving blank space is equal to the elements pushed inside the queue then we can say our all oranges are rottened and we will simply return days otherwise we will return -1..\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458694,
                "title": "javascript-simple-solution-w-comments",
                "content": "```\\n/**\\n * BFS\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 100 ms, faster than 29.24% of JavaScript online submissions for Rotting Oranges.\\n// Memory Usage: 42.2 MB, less than 23.98% of JavaScript online submissions for Rotting Oranges.\\nconst orangesRotting = grid => {\\n\\t// there can be multiple rotten fruits\\n\\tconst getRotten = () => {\\n\\t\\tlet [start, fresh] = [[], 0];\\n\\n\\t\\tfor (let i = 0; i < grid.length; i++) {\\n\\t\\t\\tfor (let j = 0; j < grid[0].length; j++) {\\n\\t\\t\\t\\tif (grid[i][j] === 2) start.push([i, j]);\\n\\t\\t\\t\\telse if (grid[i][j] === 1) fresh++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn [start, fresh];\\n\\t};\\n\\n\\tconst directions = [\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[1, 0],\\n\\t\\t[0, -1],\\n\\t];\\n\\tlet [start, fresh] = getRotten();\\n\\tlet queue = [...start]; // there can be mutiple rotten\\n\\tlet output = 0;\\n\\t\\n\\t// while fresh fruits are left && queue\\n\\twhile (fresh && queue.length) {\\n\\t\\tconst len = queue.length;\\n\\n\\t\\tfor (let i = 0; i < len; i++) {\\n\\t\\t\\tconst [row, col] = queue.shift();\\n\\n\\t\\t\\tfor (const [dx, dy] of directions) {\\n\\t\\t\\t\\tconst x = row + dx;\\n\\t\\t\\t\\tconst y = col + dy;\\n\\n\\t\\t\\t\\t// if invaid continue\\n\\t\\t\\t\\tif (x < 0 || x >= grid.length) continue;\\n\\t\\t\\t\\tif (y < 0 || y >= grid[0].length) continue;\\n\\t\\t\\t\\tif (grid[x][y] === 0 || grid[x][y] === 2) continue;\\n\\n\\t\\t\\t\\tqueue.push([x, y]);\\n\\t\\t\\t\\tgrid[x][y] = 2;\\n\\t\\t\\t\\tfresh--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\toutput++;\\n\\t}\\n\\n\\treturn fresh === 0 ? output : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * BFS\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 100 ms, faster than 29.24% of JavaScript online submissions for Rotting Oranges.\\n// Memory Usage: 42.2 MB, less than 23.98% of JavaScript online submissions for Rotting Oranges.\\nconst orangesRotting = grid => {\\n\\t// there can be multiple rotten fruits\\n\\tconst getRotten = () => {\\n\\t\\tlet [start, fresh] = [[], 0];\\n\\n\\t\\tfor (let i = 0; i < grid.length; i++) {\\n\\t\\t\\tfor (let j = 0; j < grid[0].length; j++) {\\n\\t\\t\\t\\tif (grid[i][j] === 2) start.push([i, j]);\\n\\t\\t\\t\\telse if (grid[i][j] === 1) fresh++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn [start, fresh];\\n\\t};\\n\\n\\tconst directions = [\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[1, 0],\\n\\t\\t[0, -1],\\n\\t];\\n\\tlet [start, fresh] = getRotten();\\n\\tlet queue = [...start]; // there can be mutiple rotten\\n\\tlet output = 0;\\n\\t\\n\\t// while fresh fruits are left && queue\\n\\twhile (fresh && queue.length) {\\n\\t\\tconst len = queue.length;\\n\\n\\t\\tfor (let i = 0; i < len; i++) {\\n\\t\\t\\tconst [row, col] = queue.shift();\\n\\n\\t\\t\\tfor (const [dx, dy] of directions) {\\n\\t\\t\\t\\tconst x = row + dx;\\n\\t\\t\\t\\tconst y = col + dy;\\n\\n\\t\\t\\t\\t// if invaid continue\\n\\t\\t\\t\\tif (x < 0 || x >= grid.length) continue;\\n\\t\\t\\t\\tif (y < 0 || y >= grid[0].length) continue;\\n\\t\\t\\t\\tif (grid[x][y] === 0 || grid[x][y] === 2) continue;\\n\\n\\t\\t\\t\\tqueue.push([x, y]);\\n\\t\\t\\t\\tgrid[x][y] = 2;\\n\\t\\t\\t\\tfresh--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\toutput++;\\n\\t}\\n\\n\\treturn fresh === 0 ? output : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476286,
                "title": "python-simplest-bfs-solution-ever",
                "content": "Most intuitive Python solution among all. \\nSimply count all \\'good\\' oranges to make sure all are rot at the end.\\nAdd rotten oranges to deque: row, col, level. Level represents depth of tree.\\n\\nEach new BFS itteration, append to queue level+1. \\n\\n```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        N = len(grid)\\n        M = len(grid[0])\\n        Q = collections.deque()\\n        totalGood = 0\\n        #Find all good and append all rotten to queue\\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == 1:\\n                    totalGood += 1\\n                if grid[i][j] == 2:\\n                    Q.appendleft((i,j,0))\\n        \\n        maxLevel = 0\\n        while Q:\\n            r, c, level = Q.pop()\\n            #Check all neighboors\\n            for x, y in [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]:\\n                if (0 <= x < N) and (0 <= y < M) and grid[x][y] == 1:\\n                    grid[x][y] = 2 #Set to 2 - mark rotten or visited\\n                    totalGood -= 1\\n                    Q.appendleft((x,y, level+1))\\n                    if level+1 > maxLevel:\\n                        maxLevel = level+1   \\n        \\n        if totalGood > 0:\\n            return -1\\n        return maxLevel\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        N = len(grid)\\n        M = len(grid[0])\\n        Q = collections.deque()\\n        totalGood = 0\\n        #Find all good and append all rotten to queue\\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == 1:\\n                    totalGood += 1\\n                if grid[i][j] == 2:\\n                    Q.appendleft((i,j,0))\\n        \\n        maxLevel = 0\\n        while Q:\\n            r, c, level = Q.pop()\\n            #Check all neighboors\\n            for x, y in [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]:\\n                if (0 <= x < N) and (0 <= y < M) and grid[x][y] == 1:\\n                    grid[x][y] = 2 #Set to 2 - mark rotten or visited\\n                    totalGood -= 1\\n                    Q.appendleft((x,y, level+1))\\n                    if level+1 > maxLevel:\\n                        maxLevel = level+1   \\n        \\n        if totalGood > 0:\\n            return -1\\n        return maxLevel\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839084,
                "title": "c-rotting-oranges-with-queue",
                "content": "**Description**\\n\\nFind the minimum number of units of time that must elapse until no cell has a fresh orange.\\n\\n**Program**\\n\\n```cpp []\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        queue<pair<int, int>> queue;\\n        int fresh = 0;\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                // count total fresh oranges\\n                if (grid[r][c] == 1) {\\n                    fresh++;\\n                }\\n                // add rotten orange to queue\\n                if (grid[r][c] == 2) {\\n                    queue.push({r, c});\\n                }\\n            }\\n        }\\n        int result = 0;\\n        vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        // now queue should have all initial rotten oranges\\n        while (!queue.empty() && fresh > 0) {\\n            int size = queue.size();\\n            // the rotting process should be done by all rotten oranges in a unit time\\n            for (int i = 0; i < size; i++) {\\n                // get row and col of rotten orange\\n                auto [r, c] = queue.front();\\n                queue.pop();\\n                // check all four directions for fresh orange\\n                for (int j = 0; j < 4; j++) {\\n                    int x = r + dirs[j][0];\\n                    int y = c + dirs[j][1];\\n                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] != 1) {\\n                        continue;\\n                    }\\n                    // make fresh orange rotten and add to queue\\n                    grid[x][y] = 2;\\n                    queue.push({x, y});\\n                    // decrement count of fresh oranges\\n                    fresh--;\\n                }\\n            }\\n            // increment unit of time when rotting is done by all oranges in the queue\\n            result++;\\n        }\\n        return fresh == 0 ? result : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        queue<pair<int, int>> queue;\\n        int fresh = 0;\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                // count total fresh oranges\\n                if (grid[r][c] == 1) {\\n                    fresh++;\\n                }\\n                // add rotten orange to queue\\n                if (grid[r][c] == 2) {\\n                    queue.push({r, c});\\n                }\\n            }\\n        }\\n        int result = 0;\\n        vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        // now queue should have all initial rotten oranges\\n        while (!queue.empty() && fresh > 0) {\\n            int size = queue.size();\\n            // the rotting process should be done by all rotten oranges in a unit time\\n            for (int i = 0; i < size; i++) {\\n                // get row and col of rotten orange\\n                auto [r, c] = queue.front();\\n                queue.pop();\\n                // check all four directions for fresh orange\\n                for (int j = 0; j < 4; j++) {\\n                    int x = r + dirs[j][0];\\n                    int y = c + dirs[j][1];\\n                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] != 1) {\\n                        continue;\\n                    }\\n                    // make fresh orange rotten and add to queue\\n                    grid[x][y] = 2;\\n                    queue.push({x, y});\\n                    // decrement count of fresh oranges\\n                    fresh--;\\n                }\\n            }\\n            // increment unit of time when rotting is done by all oranges in the queue\\n            result++;\\n        }\\n        return fresh == 0 ? result : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412389,
                "title": "simple-bfs-soultion-with-easy-understanding",
                "content": "This is a very good question for people learning graphs and its traversal .Here we have to simultaneously start our bfs from multiple points ,and also mark visited according to the time of traversal from a particular point . So, a point or node could appear in bfs from a point ,but may have already been visited from any other point. \\n\\nSo, here first we store all the rotten oranges in a queue and also store our time as 0, then call the bfs . Bfs starts firstly from all nodes already in queue and then when we are changing the fresh oranges to rotten , we increase our timer by 1, in this way we traverse to all the nodes or cells level order wise and keep increasing time . Our answer will be maximum time by any bfs traversal as our goal is to make all oranges rotten . \\n\\nIf even after bfs we could not rot all fresh oranges we return -1.\\n```\\n    int bfs(vector<vector<int>>& grid,queue<pair<pair<int,int>,int>>& q,vector<vector<int>> &vis,int n,int m){\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            pair<pair<int,int>,int> p=q.front();q.pop();\\n            int r=p.first.first,c=p.first.second,t=p.second;\\n            ans=max(ans,t);\\n            // cout<<r<<\" \"<<c<<\" \"<<grid[r][c]<<\" \"<<ans<<endl;\\n            if(r>0){\\n                if(grid[r-1][c]==1 && vis[r-1][c]==0){\\n                    vis[r-1][c]=1;q.push({{r-1,c},t+1});grid[r-1][c]=2;}\\n            }\\n            if(r<n-1){\\n                if(grid[r+1][c]==1 && vis[r+1][c]==0){vis[r+1][c]=1;q.push({{r+1,c},t+1});grid[r+1][c]=2;}\\n            }\\n            if(c<m-1){\\n                if(grid[r][c+1]==1 && vis[r][c+1]==0){vis[r][c+1]=1;q.push({{r,c+1},t+1});grid[r][c+1]=2;}\\n            }\\n             if(c>0){\\n                if(grid[r][c-1]==1 && vis[r][c-1]==0){vis[r][c-1]=1;q.push({{r,c-1},t+1});grid[r][c-1]=2;}\\n            }\\n            \\n        }\\n         return ans;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid.size();int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>> q;bool done=false;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2 && vis[i][j]==0){\\n                    done=true;q.push({{i,j},0});\\n                }\\n            }\\n        }\\n        int ans=bfs(grid,q,vis,n,m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1) return -1;\\n            }}\\n      \\n        return done?ans:0;\\n    }\\n```\\n\\nIt would be a pleasure if you upvote this and appreciate my effort put in ....",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n    int bfs(vector<vector<int>>& grid,queue<pair<pair<int,int>,int>>& q,vector<vector<int>> &vis,int n,int m){\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            pair<pair<int,int>,int> p=q.front();q.pop();\\n            int r=p.first.first,c=p.first.second,t=p.second;\\n            ans=max(ans,t);\\n            // cout<<r<<\" \"<<c<<\" \"<<grid[r][c]<<\" \"<<ans<<endl;\\n            if(r>0){\\n                if(grid[r-1][c]==1 && vis[r-1][c]==0){\\n                    vis[r-1][c]=1;q.push({{r-1,c},t+1});grid[r-1][c]=2;}\\n            }\\n            if(r<n-1){\\n                if(grid[r+1][c]==1 && vis[r+1][c]==0){vis[r+1][c]=1;q.push({{r+1,c},t+1});grid[r+1][c]=2;}\\n            }\\n            if(c<m-1){\\n                if(grid[r][c+1]==1 && vis[r][c+1]==0){vis[r][c+1]=1;q.push({{r,c+1},t+1});grid[r][c+1]=2;}\\n            }\\n             if(c>0){\\n                if(grid[r][c-1]==1 && vis[r][c-1]==0){vis[r][c-1]=1;q.push({{r,c-1},t+1});grid[r][c-1]=2;}\\n            }\\n            \\n        }\\n         return ans;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid.size();int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>> q;bool done=false;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2 && vis[i][j]==0){\\n                    done=true;q.push({{i,j},0});\\n                }\\n            }\\n        }\\n        int ans=bfs(grid,q,vis,n,m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1) return -1;\\n            }}\\n      \\n        return done?ans:0;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2053319,
                "title": "javascript-clean-and-easy-to-understand-bfs-solution",
                "content": "first count how many cells are fresh and push rottens direction to a queue,\\nthen while we have fresh maintain rotten queue:\\n\\t* update grid with new rottens\\n\\t* add new rottens to torrens queue\\n\\t* decrease from remain fresh cell\\n\\tand repeat these step till fresh ends.\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n    \\n    const rows = grid.length, cols = grid[0].length, UpDown = [1, -1, 0, 0], LeftRight = [0, 0, 1, -1]; \\n    let queueRotten = [], minute = 0, fresh = 0;\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < cols; c++) {\\n            if(grid[r][c] === 2) queueRotten.push([r, c])\\n            else if(grid[r][c] === 1) fresh++;\\n        }\\n    }\\n    \\n    while(fresh && queueRotten.length) {\\n        const next = [];\\n        minute++;\\n        \\n        for(let [r, c] of queueRotten) {\\n            \\n            for(let i = 0; i < 4; i++) {\\n                const x = r + UpDown[i], y = c + LeftRight[i];\\n                \\n                if(x < rows && x >= 0 && \\n                   y < cols && y >= 0 && \\n                   grid[x][y] === 1) {\\n                    fresh--;\\n                    grid[x][y] = 2;\\n                    next.push([x, y]);\\n                }\\n            }\\n        }\\n        queueRotten = next;\\n    }\\n    return !fresh ? minute : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n    \\n    const rows = grid.length, cols = grid[0].length, UpDown = [1, -1, 0, 0], LeftRight = [0, 0, 1, -1]; \\n    let queueRotten = [], minute = 0, fresh = 0;\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < cols; c++) {\\n            if(grid[r][c] === 2) queueRotten.push([r, c])\\n            else if(grid[r][c] === 1) fresh++;\\n        }\\n    }\\n    \\n    while(fresh && queueRotten.length) {\\n        const next = [];\\n        minute++;\\n        \\n        for(let [r, c] of queueRotten) {\\n            \\n            for(let i = 0; i < 4; i++) {\\n                const x = r + UpDown[i], y = c + LeftRight[i];\\n                \\n                if(x < rows && x >= 0 && \\n                   y < cols && y >= 0 && \\n                   grid[x][y] === 1) {\\n                    fresh--;\\n                    grid[x][y] = 2;\\n                    next.push([x, y]);\\n                }\\n            }\\n        }\\n        queueRotten = next;\\n    }\\n    return !fresh ? minute : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1741380,
                "title": "java-bfs-1ms",
                "content": "- Since adjacent nodes of 2 will get rotten first, and it speards on, we can use BFS(Travels adjacent nodes first). \\n- There may be multiple 2\\'s so, we can store all the 2\\'s pos in queue first and \\nperform BFS.\\n- while Performing bfs mark 1\\'s as 2\\'s and maintain the time when it got rotten\\n- Then check if any 1\\'s are left after bfs traversal if so, return -1 else return time\\n\\n\\n#### BFS\\n```\\nclass Pair{\\n    int row;\\n    int col;\\n    int time;\\n    \\n    Pair(int row,int col,int time){\\n        this.row=row;\\n        this.col=col;\\n        this.time=time;\\n    }\\n}\\n\\nclass Solution {\\n    int dir[][] = {{-1,0},{1,0},{0,1},{0,-1}};\\n\\n    public int orangesRotting(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int count=0,max=0;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[row][col];\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j]==2){\\n                    queue.add(new Pair(i,j,0));\\n                }\\n            }\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            Pair p = queue.remove();\\n            visited[p.row][p.col]=true;\\n            \\n            for(int dr[] : dir){\\n                int i = p.row+dr[0];\\n                int j = p.col+dr[1];\\n                \\n                if(isValidDir(i,j,grid) && grid[i][j]==1 && !visited[i][j]){\\n                    grid[i][j]=2;\\n                    queue.add(new Pair(i,j,p.time+1));\\n                }\\n            }\\n            max=Math.max(max,p.time);\\n        }\\n        \\n        for(int rows[] : grid){\\n            for(int cols : rows){\\n                if(cols==1) count++;\\n            }\\n        }\\n        \\n        return count>0 ? -1 : max;\\n    }\\n    \\n    private boolean isValidDir(int i,int j,int grid[][]){\\n        if(i<0 || i>=grid.length||\\n           j<0 || j>=grid[0].length){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Pair{\\n    int row;\\n    int col;\\n    int time;\\n    \\n    Pair(int row,int col,int time){\\n        this.row=row;\\n        this.col=col;\\n        this.time=time;\\n    }\\n}\\n\\nclass Solution {\\n    int dir[][] = {{-1,0},{1,0},{0,1},{0,-1}};\\n\\n    public int orangesRotting(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int count=0,max=0;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[row][col];\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j]==2){\\n                    queue.add(new Pair(i,j,0));\\n                }\\n            }\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            Pair p = queue.remove();\\n            visited[p.row][p.col]=true;\\n            \\n            for(int dr[] : dir){\\n                int i = p.row+dr[0];\\n                int j = p.col+dr[1];\\n                \\n                if(isValidDir(i,j,grid) && grid[i][j]==1 && !visited[i][j]){\\n                    grid[i][j]=2;\\n                    queue.add(new Pair(i,j,p.time+1));\\n                }\\n            }\\n            max=Math.max(max,p.time);\\n        }\\n        \\n        for(int rows[] : grid){\\n            for(int cols : rows){\\n                if(cols==1) count++;\\n            }\\n        }\\n        \\n        return count>0 ? -1 : max;\\n    }\\n    \\n    private boolean isValidDir(int i,int j,int grid[][]){\\n        if(i<0 || i>=grid.length||\\n           j<0 || j>=grid[0].length){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541505,
                "title": "simple-and-concise-c-to-understand-using-dfs-4ms",
                "content": "```\\nvoid dfs(int ** grid, int row, int col, int x, int y, int minutes)\\n{\\n    if(x<0 || x>=row || y<0 || y>=col || grid[x][y] == 0)\\n        return;\\n    if(grid[x][y] == 1 || grid[x][y] >= minutes)\\n    {\\n        grid[x][y] = minutes;\\n        dfs(grid, row, col, x+1, y, minutes+1);\\n        dfs(grid, row, col, x-1, y, minutes+1);\\n        dfs(grid, row, col, x, y-1, minutes+1);\\n        dfs(grid, row, col, x, y+1, minutes+1);\\n    }\\n}\\n\\nint orangesRotting(int** grid, int gridSize, int* gridColSize){\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 2)\\n                dfs(grid, gridSize, *gridColSize, i, j, 2);\\n    int min = 2;\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 1)\\n                return -1;\\n            else\\n                min = min < grid[i][j] ? grid[i][j] : min;\\n    return min-2;   \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid dfs(int ** grid, int row, int col, int x, int y, int minutes)\\n{\\n    if(x<0 || x>=row || y<0 || y>=col || grid[x][y] == 0)\\n        return;\\n    if(grid[x][y] == 1 || grid[x][y] >= minutes)\\n    {\\n        grid[x][y] = minutes;\\n        dfs(grid, row, col, x+1, y, minutes+1);\\n        dfs(grid, row, col, x-1, y, minutes+1);\\n        dfs(grid, row, col, x, y-1, minutes+1);\\n        dfs(grid, row, col, x, y+1, minutes+1);\\n    }\\n}\\n\\nint orangesRotting(int** grid, int gridSize, int* gridColSize){\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 2)\\n                dfs(grid, gridSize, *gridColSize, i, j, 2);\\n    int min = 2;\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 1)\\n                return -1;\\n            else\\n                min = min < grid[i][j] ? grid[i][j] : min;\\n    return min-2;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1375583,
                "title": "java-bfs-dfs-solution-with-explanation-in-comments",
                "content": "BFS Solution \\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        //BFS Solution\\n        \\n        //Base case\\n        if(grid == null || grid.length == 0)\\n            return -1;\\n        \\n        //First thing is we need a source in BFS. So we take the ones where values are 2 ie rotten\\n        Queue<int []> q = new LinkedList<>();\\n        \\n        int rowLen = grid.length;\\n        int colLen = grid[0].length;\\n        \\n        int freshCount = 0;\\n        for(int i = 0; i<rowLen; i++){\\n            for(int j =0; j<colLen; j++){\\n                if(grid[i][j] == 1)\\n                    freshCount++;\\n                else if(grid[i][j] == 2)\\n                    q.offer(new int[] {i,j}); // adding the rotten one to queue for being the source\\n            }\\n        }\\n        \\n        if(freshCount == 0) // No fresh oranges originally in grid \\n            return 0;\\n        \\n        int[][] directions = {{-1,0},{1,0},{0,-1} ,{0,1}}; //top, bottom, left, right\\n        int time = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i =0; i<size; i++){\\n                int[] rotten = q.poll();\\n                //Move in 4 direction around the rotten to make fresh oranges rotten\\n                for(int [] dir : directions){\\n                    int r = dir[0] + rotten[0];\\n                    int c = dir[1] + rotten[1];\\n                    \\n                    //Checking boundary conditions along with the if fresh\\n                    if(r>=0 && r<rowLen && c>=0 && c<colLen && grid[r][c] == 1 ){\\n                        grid[r][c] = 2; // rot it first\\n                        q.add(new int[] {r,c}); // add it in the queue for next process\\n                        freshCount--; // Reduce the fresh orange count as we rotted one\\n                    }\\n                }\\n            }\\n            time++; // After subesquent level count is increased.\\n        }\\n        if(freshCount!=0)  return -1; // Means fresh orange still there and impossible to rot;\\n        \\n        if(time>0)\\n            return time-1; // as after last level we still increase the count. So we decrease 1.\\n        else\\n            return 0; // No fresh oranges originally in grid \\n    }\\n}\\n```\\n----------------------------\\nDFS Solution :\\n```\\nclass Solution {\\n    int rowLen;\\n    int colLen;\\n    public int orangesRotting(int[][] grid) {\\n        \\n        //Base case\\n        if(grid == null || grid.length ==0)\\n            return -1;\\n        rowLen = grid.length;\\n        colLen = grid[0].length;\\n        int time = 0;\\n        for(int i = 0; i<rowLen; i++){\\n            for(int j =0; j<colLen; j++){\\n                if(grid[i][j] == 2 ){// if rotten\\n                    makeRotten(grid,i,j,2);\\n                }\\n            }\\n        }\\n        \\n        \\n        int minutes = 2;\\n        for(int[] row : grid) {\\n            for(int cell : row) {\\n                if(cell == 1)  // could not rot completely\\n                    return -1;\\n                else\\n                    minutes = Math.max(minutes, cell);\\n            }\\n        }\\n        return minutes - 2;\\n    }\\n    \\n    public void makeRotten(int[][] grid, int row, int col, int time){\\n        \\n         //Base Case\\n        if(row < 0 || row >= rowLen || col < 0 || col >= colLen || grid[row][col] == 0) \\n            //grid[row][col] == 0 : Empty Cell\\n            return;\\n        \\n        //Action\\n        //grid[row][col]< time ; grid[row][col] >1 : Already rotten as any value >= 2 is rotten\\n        //As sometimes time>2 and grid[i][j] == 2 ie >1 so it is already rotten so return simply\\n        if(grid[row][col] < time && grid[row][col] > 1) \\n            return ;\\n       \\n        //Recursion Logic\\n        int[][] directions ={{1,0},{-1,0},{0,-1},{0,1}};  //bottom,top,left,right\\n        grid[row][col] = time; // making it rotten as we have initially passed 2 for this function\\n        for(int[] dir : directions){\\n            int r = dir[0] + row;\\n            int c = dir[1] + col;\\n            makeRotten(grid,r,c,time+1);\\n                \\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        //BFS Solution\\n        \\n        //Base case\\n        if(grid == null || grid.length == 0)\\n            return -1;\\n        \\n        //First thing is we need a source in BFS. So we take the ones where values are 2 ie rotten\\n        Queue<int []> q = new LinkedList<>();\\n        \\n        int rowLen = grid.length;\\n        int colLen = grid[0].length;\\n        \\n        int freshCount = 0;\\n        for(int i = 0; i<rowLen; i++){\\n            for(int j =0; j<colLen; j++){\\n                if(grid[i][j] == 1)\\n                    freshCount++;\\n                else if(grid[i][j] == 2)\\n                    q.offer(new int[] {i,j}); // adding the rotten one to queue for being the source\\n            }\\n        }\\n        \\n        if(freshCount == 0) // No fresh oranges originally in grid \\n            return 0;\\n        \\n        int[][] directions = {{-1,0},{1,0},{0,-1} ,{0,1}}; //top, bottom, left, right\\n        int time = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i =0; i<size; i++){\\n                int[] rotten = q.poll();\\n                //Move in 4 direction around the rotten to make fresh oranges rotten\\n                for(int [] dir : directions){\\n                    int r = dir[0] + rotten[0];\\n                    int c = dir[1] + rotten[1];\\n                    \\n                    //Checking boundary conditions along with the if fresh\\n                    if(r>=0 && r<rowLen && c>=0 && c<colLen && grid[r][c] == 1 ){\\n                        grid[r][c] = 2; // rot it first\\n                        q.add(new int[] {r,c}); // add it in the queue for next process\\n                        freshCount--; // Reduce the fresh orange count as we rotted one\\n                    }\\n                }\\n            }\\n            time++; // After subesquent level count is increased.\\n        }\\n        if(freshCount!=0)  return -1; // Means fresh orange still there and impossible to rot;\\n        \\n        if(time>0)\\n            return time-1; // as after last level we still increase the count. So we decrease 1.\\n        else\\n            return 0; // No fresh oranges originally in grid \\n    }\\n}\\n```\n```\\nclass Solution {\\n    int rowLen;\\n    int colLen;\\n    public int orangesRotting(int[][] grid) {\\n        \\n        //Base case\\n        if(grid == null || grid.length ==0)\\n            return -1;\\n        rowLen = grid.length;\\n        colLen = grid[0].length;\\n        int time = 0;\\n        for(int i = 0; i<rowLen; i++){\\n            for(int j =0; j<colLen; j++){\\n                if(grid[i][j] == 2 ){// if rotten\\n                    makeRotten(grid,i,j,2);\\n                }\\n            }\\n        }\\n        \\n        \\n        int minutes = 2;\\n        for(int[] row : grid) {\\n            for(int cell : row) {\\n                if(cell == 1)  // could not rot completely\\n                    return -1;\\n                else\\n                    minutes = Math.max(minutes, cell);\\n            }\\n        }\\n        return minutes - 2;\\n    }\\n    \\n    public void makeRotten(int[][] grid, int row, int col, int time){\\n        \\n         //Base Case\\n        if(row < 0 || row >= rowLen || col < 0 || col >= colLen || grid[row][col] == 0) \\n            //grid[row][col] == 0 : Empty Cell\\n            return;\\n        \\n        //Action\\n        //grid[row][col]< time ; grid[row][col] >1 : Already rotten as any value >= 2 is rotten\\n        //As sometimes time>2 and grid[i][j] == 2 ie >1 so it is already rotten so return simply\\n        if(grid[row][col] < time && grid[row][col] > 1) \\n            return ;\\n       \\n        //Recursion Logic\\n        int[][] directions ={{1,0},{-1,0},{0,-1},{0,1}};  //bottom,top,left,right\\n        grid[row][col] = time; // making it rotten as we have initially passed 2 for this function\\n        for(int[] dir : directions){\\n            int r = dir[0] + row;\\n            int c = dir[1] + col;\\n            makeRotten(grid,r,c,time+1);\\n                \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343055,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int count_fresh = 0;\\n        for(int i = 0 ; i < rows ; i++) {\\n            for(int j = 0 ; j < cols ; j++) {\\n                if(grid[i][j] == 2) {\\n                    queue.offer(new int[]{i , j});\\n                }\\n                else if(grid[i][j] == 1) {\\n                    count_fresh++;\\n                }\\n            }\\n        }\\n\\n        if(count_fresh == 0) return 0;\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n\\n        while(!queue.isEmpty()) {\\n            ++count;\\n            int size = queue.size();\\n            for(int i = 0 ; i < size ; i++) {\\n                int[] point = queue.poll();\\n                for(int dir[] : dirs) {\\n                    int x = point[0] + dir[0];\\n                    int y = point[1] + dir[1];\\n                    if(x < 0 || y < 0 || x >= rows || \\n                       y >= cols || grid[x][y] == 0 || grid[x][y] == 2) \\n                        continue;\\n\\n                    grid[x][y] = 2;\\n                    queue.offer(new int[]{x , y});\\n                    count_fresh--;\\n                }\\n            }\\n        }\\n        return count_fresh == 0 ? count-1 : -1;\\n    }\\n}\\n```\\n\\nRuntime: 2 ms, faster than 90.53% of Java online submissions for Rotting Oranges.\\nMemory Usage: 41 MB, less than 46.21% of Java online submissions for Rotting Oranges.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int count_fresh = 0;\\n        for(int i = 0 ; i < rows ; i++) {\\n            for(int j = 0 ; j < cols ; j++) {\\n                if(grid[i][j] == 2) {\\n                    queue.offer(new int[]{i , j});\\n                }\\n                else if(grid[i][j] == 1) {\\n                    count_fresh++;\\n                }\\n            }\\n        }\\n\\n        if(count_fresh == 0) return 0;\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n\\n        while(!queue.isEmpty()) {\\n            ++count;\\n            int size = queue.size();\\n            for(int i = 0 ; i < size ; i++) {\\n                int[] point = queue.poll();\\n                for(int dir[] : dirs) {\\n                    int x = point[0] + dir[0];\\n                    int y = point[1] + dir[1];\\n                    if(x < 0 || y < 0 || x >= rows || \\n                       y >= cols || grid[x][y] == 0 || grid[x][y] == 2) \\n                        continue;\\n\\n                    grid[x][y] = 2;\\n                    queue.offer(new int[]{x , y});\\n                    count_fresh--;\\n                }\\n            }\\n        }\\n        return count_fresh == 0 ? count-1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249889,
                "title": "simple-java-easy-to-understand-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int min = 2;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 2) {\\n                    spread(i, j, grid, 2);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    return -1;\\n                }\\n                min = Math.max(min, grid[i][j]);\\n            }\\n        }\\n\\n        return min - 2;\\n    }\\n\\n    private void spread(int i, int j, int[][] grid, int t) {\\n        int count = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (j < 0 || i < 0 || i >= m || j >= n || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < t)) {\\n            return;\\n        } \\n        grid[i][j] = t;  \\n        spread(i + 1, j, grid, t + 1);\\n        spread(i - 1, j, grid, t + 1);\\n        spread(i, j + 1, grid, t + 1);\\n        spread(i, j - 1, grid, t + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int min = 2;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 2) {\\n                    spread(i, j, grid, 2);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    return -1;\\n                }\\n                min = Math.max(min, grid[i][j]);\\n            }\\n        }\\n\\n        return min - 2;\\n    }\\n\\n    private void spread(int i, int j, int[][] grid, int t) {\\n        int count = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (j < 0 || i < 0 || i >= m || j >= n || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < t)) {\\n            return;\\n        } \\n        grid[i][j] = t;  \\n        spread(i + 1, j, grid, t + 1);\\n        spread(i - 1, j, grid, t + 1);\\n        spread(i, j + 1, grid, t + 1);\\n        spread(i, j - 1, grid, t + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108765,
                "title": "bfs-easy-to-understand-explained-c",
                "content": "# Approach\\nUsing, bfs traversal as we do it at a same time and level wise. Not, dfs bcs it doesn\\'t ensures min time to rotten oranges.\\n\\n# Complexity\\n- Time complexity:\\nO(n*m + 4nm)  --> O(n*m)\\n\\n- Space complexity:\\nO(nm) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size() ; \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int maxTime=0,freshOrange=0;\\n           //{{row,col},time}\\n        queue<pair<pair<int,int>,int>>q;\\n        //find rotten orange and push in queue as doing bfs traversal \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j]=2;\\n                }\\n                 if(grid[i][j]==1) freshOrange++;\\n            }\\n        }\\n    //traverse all 4 neighbours\\n      vector<int>delRow={-1,0,+1,0};\\n      vector<int>delCol={0,-1,0,+1};\\n\\n\\n    while(!q.empty()){\\n        int row = q.front().first.first;\\n        int col = q.front().first.second;\\n        int time = q.front().second;\\n        q.pop();\\n        maxTime=max(maxTime,time);\\n\\n        for(int i=0;i<4;i++){\\n            int nrow = row+delRow[i];\\n            int ncol = col+delCol[i];\\n\\n            //check valid \\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0 && grid[nrow][ncol]==1){\\n                //mark visited \\n                vis[nrow][ncol]=2;\\n                q.push({{nrow,ncol},time+1});\\n                freshOrange--;//freshOrange that are pushed in queue\\n            }\\n        }\\n    }\\n\\n     if(freshOrange!=0) return -1; //as freshOrange still left \\n         return maxTime;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size() ; \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int maxTime=0,freshOrange=0;\\n           //{{row,col},time}\\n        queue<pair<pair<int,int>,int>>q;\\n        //find rotten orange and push in queue as doing bfs traversal \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j]=2;\\n                }\\n                 if(grid[i][j]==1) freshOrange++;\\n            }\\n        }\\n    //traverse all 4 neighbours\\n      vector<int>delRow={-1,0,+1,0};\\n      vector<int>delCol={0,-1,0,+1};\\n\\n\\n    while(!q.empty()){\\n        int row = q.front().first.first;\\n        int col = q.front().first.second;\\n        int time = q.front().second;\\n        q.pop();\\n        maxTime=max(maxTime,time);\\n\\n        for(int i=0;i<4;i++){\\n            int nrow = row+delRow[i];\\n            int ncol = col+delCol[i];\\n\\n            //check valid \\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0 && grid[nrow][ncol]==1){\\n                //mark visited \\n                vis[nrow][ncol]=2;\\n                q.push({{nrow,ncol},time+1});\\n                freshOrange--;//freshOrange that are pushed in queue\\n            }\\n        }\\n    }\\n\\n     if(freshOrange!=0) return -1; //as freshOrange still left \\n         return maxTime;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935122,
                "title": "simple-bfs-striver-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<pair<int,int>,int>> q;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int vis[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j =0; j<n;j++){\\n                if(grid[i][j]==2){\\n                    vis[i][j]=1;\\n                    q.push({{i,j},0});\\n                }\\n                else{\\n                    vis[i][j]=0; // Fresh oranges marked with \\n                }\\n            }\\n        }\\n              int delrow[] = {-1,0,1,0}; //Left right up down traversal\\n              int delcol[] = {0,-1,0,1};\\n                //Simple bfs\\n              int tm=0;\\n              while(!q.empty()){\\n                  int r = q.front().first.first;\\n                  int c = q.front().first.second;\\n                  int t = q.front().second;\\n                  tm = max(tm,t);\\n                  q.pop();\\n                  //Checking in its all adjacent directions\\n                     for(int i=0;i<4;i++){\\n                   int nrow = r+delrow[i];\\n                   int ncol = c+delcol[i];  \\n                   if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && \\n                   grid[nrow][ncol] == 1 && vis[nrow][ncol] != 2){ //If Fresh and not visited\\n                       q.push({{nrow,ncol},t+1});\\n                       vis[nrow][ncol]=2; //Visited marked with 2\\n                   }\\n              }\\n            \\n              }\\n              //Checking if there is still a fresh orange left in the grid\\n              for(int i=0;i<m;i++){\\n                  for(int j=0;j<n;j++){\\n                      if(vis[i][j] !=2 && grid[i][j]== 1){\\n                         return -1;\\n                      }\\n                  }\\n              }\\n     return tm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<pair<int,int>,int>> q;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int vis[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j =0; j<n;j++){\\n                if(grid[i][j]==2){\\n                    vis[i][j]=1;\\n                    q.push({{i,j},0});\\n                }\\n                else{\\n                    vis[i][j]=0; // Fresh oranges marked with \\n                }\\n            }\\n        }\\n              int delrow[] = {-1,0,1,0}; //Left right up down traversal\\n              int delcol[] = {0,-1,0,1};\\n                //Simple bfs\\n              int tm=0;\\n              while(!q.empty()){\\n                  int r = q.front().first.first;\\n                  int c = q.front().first.second;\\n                  int t = q.front().second;\\n                  tm = max(tm,t);\\n                  q.pop();\\n                  //Checking in its all adjacent directions\\n                     for(int i=0;i<4;i++){\\n                   int nrow = r+delrow[i];\\n                   int ncol = c+delcol[i];  \\n                   if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && \\n                   grid[nrow][ncol] == 1 && vis[nrow][ncol] != 2){ //If Fresh and not visited\\n                       q.push({{nrow,ncol},t+1});\\n                       vis[nrow][ncol]=2; //Visited marked with 2\\n                   }\\n              }\\n            \\n              }\\n              //Checking if there is still a fresh orange left in the grid\\n              for(int i=0;i<m;i++){\\n                  for(int j=0;j<n;j++){\\n                      if(vis[i][j] !=2 && grid[i][j]== 1){\\n                         return -1;\\n                      }\\n                  }\\n              }\\n     return tm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255751,
                "title": "c-simple-bfs-clean-code-fully-commented-edge-cases-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Using BFS : \\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        vector<int> dir={-1,0,1,0,-1}; // used for finding all 4 adjacent coordinates\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        int fresh=0;              // To keep track of all fresh oranges left\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                    q.push({i,j}); // push all rotten oranges\\n                if(grid[i][j]==1)\\n                    fresh++;\\n            }\\n        \\n        int ans=-1; // initialised to -1 since after each step we increment the time by 1 and initially all rotten oranges started at 0.\\n        \\n        // BFS \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int r = p.first + dir[i];\\n                    int c = p.second + dir[i+1];\\n                    if(r>=0 && r<m && c>=0 && c<n && grid[r][c]==1)\\n                    {\\n                        grid[r][c]=2;\\n                        q.push({r,c}); // push that rotten orange that becomes rotten from fresh\\n                        fresh--;       // decrement by 1 for each fresh orange that now is rotten\\n                    }\\n                    \\n                }\\n            }\\n            ans++; // incremented after each minute passes\\n        }\\n        \\n        if(fresh>0) return -1; //if fresh>0 that means there are fresh oranges left\\n        if(ans==-1) return 0; //we initialised with -1, so if there were no oranges it\\'d take 0 mins.\\n        return ans;\\n    }\\n};\\n```\\n*Thanks for upvoting !*\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Using BFS : \\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        vector<int> dir={-1,0,1,0,-1}; // used for finding all 4 adjacent coordinates\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        int fresh=0;              // To keep track of all fresh oranges left\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                    q.push({i,j}); // push all rotten oranges\\n                if(grid[i][j]==1)\\n                    fresh++;\\n            }\\n        \\n        int ans=-1; // initialised to -1 since after each step we increment the time by 1 and initially all rotten oranges started at 0.\\n        \\n        // BFS \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int r = p.first + dir[i];\\n                    int c = p.second + dir[i+1];\\n                    if(r>=0 && r<m && c>=0 && c<n && grid[r][c]==1)\\n                    {\\n                        grid[r][c]=2;\\n                        q.push({r,c}); // push that rotten orange that becomes rotten from fresh\\n                        fresh--;       // decrement by 1 for each fresh orange that now is rotten\\n                    }\\n                    \\n                }\\n            }\\n            ans++; // incremented after each minute passes\\n        }\\n        \\n        if(fresh>0) return -1; //if fresh>0 that means there are fresh oranges left\\n        if(ans==-1) return 0; //we initialised with -1, so if there were no oranges it\\'d take 0 mins.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546608,
                "title": "python-simple-intuitive-faster-than-99-9-does-not-modify-input-set-ops-bfs",
                "content": "Please feel free to ask questions or give suggestions. **Upvote** if you like the solution.\\n**Idea**: \\n1. Figure out initial fresh and rotten. \\n2. At the end of every minute, find out all fresh oranges that were neighbouring some rotten. All of these will now become our rotten. Remove from fresh any such oranges.\\n3. Repeat step 2 until we have no more fresh oranges or unexplored rotten\\n```\\ndef orangesRotting(self, grid: List[List[int]]) -> int:\\n\\t# One pass to fill up initial fresh and rotten\\n\\tfresh = set()\\n\\tunvisited_rotten = set()\\n\\tfor i, row in enumerate(grid):\\n\\t\\tfor j, cell in enumerate(row):\\n\\t\\t\\tif cell==2:\\n\\t\\t\\t\\tunvisited_rotten.add((i, j))\\n\\t\\t\\telif cell: # not 0 or 2\\n\\t\\t\\t\\tfresh.add((i, j))\\n\\t\\t\\t\\t\\n\\tminutes = 0\\n\\t# While there\\'s still fresh oranges and unexplored rotten oranges\\n\\twhile fresh and unvisited_rotten:\\n\\t\\t# Fresh oranges adjacent to any last rotten become rotten now \\n\\t\\tunvisited_rotten = set().union(*[fresh & {(i, j+1), (i+1, j), (i-1, j), (i, j-1)} for i, j in unvisited_rotten])\\n\\t\\tfresh -= unvisited_rotten\\n\\n\\t\\tminutes += 1\\n\\n\\t# Impossible if all rotten were exhausted but fresh still left, otherwise it took minutes time\\n\\treturn -1 if fresh else minutes\\n\\n```\\n**FAQ**:\\n**Q.**: Don\\'t you think, checking for isolated oranges and returning -1 straight away will be faster?\\n**A**: That is worth trying, when filling up fresh and unvisted_rotten in the first half, in the case of fresh oranges, we could instead do:\\n```\\nelif cell: # not 0 or 2\\n\\t# Has an adjacent orange\\n\\tif any(0<=ni<len(grid) and 0<=nj<len(grid[0]) and grid[ni][nj] for ni, nj in [(i, j+1), (i+1, j), (i-1, j), (i, j-1)]):\\n\\t\\tfresh.add((i, j))\\n\\telse:\\n\\t\\treturn -1\\n```\\nThis does not seem to improve performance for the leetcode tests.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\ndef orangesRotting(self, grid: List[List[int]]) -> int:\\n\\t# One pass to fill up initial fresh and rotten\\n\\tfresh = set()\\n\\tunvisited_rotten = set()\\n\\tfor i, row in enumerate(grid):\\n\\t\\tfor j, cell in enumerate(row):\\n\\t\\t\\tif cell==2:\\n\\t\\t\\t\\tunvisited_rotten.add((i, j))\\n\\t\\t\\telif cell: # not 0 or 2\\n\\t\\t\\t\\tfresh.add((i, j))\\n\\t\\t\\t\\t\\n\\tminutes = 0\\n\\t# While there\\'s still fresh oranges and unexplored rotten oranges\\n\\twhile fresh and unvisited_rotten:\\n\\t\\t# Fresh oranges adjacent to any last rotten become rotten now \\n\\t\\tunvisited_rotten = set().union(*[fresh & {(i, j+1), (i+1, j), (i-1, j), (i, j-1)} for i, j in unvisited_rotten])\\n\\t\\tfresh -= unvisited_rotten\\n\\n\\t\\tminutes += 1\\n\\n\\t# Impossible if all rotten were exhausted but fresh still left, otherwise it took minutes time\\n\\treturn -1 if fresh else minutes\\n\\n```\n```\\nelif cell: # not 0 or 2\\n\\t# Has an adjacent orange\\n\\tif any(0<=ni<len(grid) and 0<=nj<len(grid[0]) and grid[ni][nj] for ni, nj in [(i, j+1), (i+1, j), (i-1, j), (i, j-1)]):\\n\\t\\tfresh.add((i, j))\\n\\telse:\\n\\t\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1546311,
                "title": "java-simple-standard-bfs-clean-and-concise",
                "content": "**Idea**\\nJust use QUEUE to store all rotten oranges index and count of the number of fresh oranges initially then,\\nWhile travelling through those rotten oranges index store the index of it\\'s adjacent fresh oranges which now become the rotten one and iterate until all fresh oranges become rotten.\\nMake the index of the rotten one empty i.e assign 0 to it as we dont want to store their index again!\\n\\nAfter all that process still we left with fresh oranges then returned -1.\\n\\n````\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n     \\n        int i,j,n=grid.length,m=grid[0].length,ans=0,frsh=0;\\n        Queue<int[]> queue=new LinkedList();\\n        \\n        for(i=0;i<n;i++)\\n            for(j=0;j<m;j++) {\\n                if(grid[i][j]==2) {\\n\\n                    queue.add(new int[]{i,j});  grid[i][j]=0;\\n                }\\n                else if(grid[i][j]==1)\\n                    frsh++;\\n\\t\\t\\t}\\n        \\n        while(!queue.isEmpty())  {\\n            \\n            int size=queue.size();\\n            while(size-->0)\\n            {\\n                int tm[]=queue.poll();\\n                i=tm[0];\\n                j=tm[1];\\n                if(i+1<n&&grid[i+1][j]==1) {\\n                    \\n                    queue.add(new int[]{i+1,j});  grid[i+1][j]=0; frsh--;\\n                }\\n                if(j+1<m&&grid[i][j+1]==1) {\\n                    \\n                    queue.add(new int[]{i,j+1});  grid[i][j+1]=0; frsh--;\\n                }\\n                if(i-1>=0&&grid[i-1][j]==1) {\\n                    \\n                    queue.add(new int[]{i-1,j});  grid[i-1][j]=0;  frsh--;\\n                }\\n                if(j-1>=0&&grid[i][j-1]==1) {\\n                    \\n                    queue.add(new int[]{i,j-1});  grid[i][j-1]=0;  frsh--;\\n                }\\n            }\\n            if(queue.size()>0)\\n                ans++; \\n        }\\n        \\n        if(frsh>0)\\n            return -1;\\n        return ans;\\n    }\\n}\\n````\\n\\nIf this post was helpful then please upvote it :))",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "````\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n     \\n        int i,j,n=grid.length,m=grid[0].length,ans=0,frsh=0;\\n        Queue<int[]> queue=new LinkedList();\\n        \\n        for(i=0;i<n;i++)\\n            for(j=0;j<m;j++) {\\n                if(grid[i][j]==2) {\\n\\n                    queue.add(new int[]{i,j});  grid[i][j]=0;\\n                }\\n                else if(grid[i][j]==1)\\n                    frsh++;\\n\\t\\t\\t}\\n        \\n        while(!queue.isEmpty())  {\\n            \\n            int size=queue.size();\\n            while(size-->0)\\n            {\\n                int tm[]=queue.poll();\\n                i=tm[0];\\n                j=tm[1];\\n                if(i+1<n&&grid[i+1][j]==1) {\\n                    \\n                    queue.add(new int[]{i+1,j});  grid[i+1][j]=0; frsh--;\\n                }\\n                if(j+1<m&&grid[i][j+1]==1) {\\n                    \\n                    queue.add(new int[]{i,j+1});  grid[i][j+1]=0; frsh--;\\n                }\\n                if(i-1>=0&&grid[i-1][j]==1) {\\n                    \\n                    queue.add(new int[]{i-1,j});  grid[i-1][j]=0;  frsh--;\\n                }\\n                if(j-1>=0&&grid[i][j-1]==1) {\\n                    \\n                    queue.add(new int[]{i,j-1});  grid[i][j-1]=0;  frsh--;\\n                }\\n            }\\n            if(queue.size()>0)\\n                ans++; \\n        }\\n        \\n        if(frsh>0)\\n            return -1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492830,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int mnts = 2;\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 2)     mark(grid, i, j, mnts);\\n            }\\n        }\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 1) return -1;\\n                mnts = Math.max(mnts, grid[i][j]);\\n            }\\n        }\\n        return mnts-2;\\n    }\\n    private void mark(int[][] grid, int i, int j, int mnts){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < mnts))\\n            return;\\n        grid[i][j] = mnts;\\n        mark(grid, i+1, j, mnts+1);\\n        mark(grid, i-1, j, mnts+1);\\n        mark(grid, i, j+1, mnts+1);\\n        mark(grid, i, j-1, mnts+1);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar orangesRotting = function(grid) {\\n    let mnts = 2\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j] == 2)     mark(grid, i, j, mnts)\\n        }\\n    }\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j] == 1) return -1\\n            mnts = Math.max(mnts, grid[i][j])\\n        }\\n    }\\n    return mnts-2\\n};\\n\\nfunction mark(grid, i, j, mnts){\\n    if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < mnts))\\n        return\\n    grid[i][j] = mnts\\n    mark(grid, i+1, j, mnts+1)\\n    mark(grid, i-1, j, mnts+1)\\n    mark(grid, i, j+1, mnts+1)\\n    mark(grid, i, j-1, mnts+1)\\n}\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        mnts = 2\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 2:\\n                    self.mark(grid, i, j, mnts)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    return -1\\n                mnts = max(mnts, grid[i][j])\\n        return mnts-2\\n    def mark(self, grid, i, j, mnts):\\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0 or (grid[i][j] > 1 and grid[i][j] < mnts):\\n            return\\n        grid[i][j] = mnts\\n        self.mark(grid, i+1, j, mnts+1)\\n        self.mark(grid, i-1, j, mnts+1)\\n        self.mark(grid, i, j+1, mnts+1)\\n        self.mark(grid, i, j-1, mnts+1)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int mnts = 2;\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 2)     mark(grid, i, j, mnts);\\n            }\\n        }\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 1) return -1;\\n                mnts = Math.max(mnts, grid[i][j]);\\n            }\\n        }\\n        return mnts-2;\\n    }\\n    private void mark(int[][] grid, int i, int j, int mnts){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < mnts))\\n            return;\\n        grid[i][j] = mnts;\\n        mark(grid, i+1, j, mnts+1);\\n        mark(grid, i-1, j, mnts+1);\\n        mark(grid, i, j+1, mnts+1);\\n        mark(grid, i, j-1, mnts+1);\\n    }\\n}\\n```\n```\\nvar orangesRotting = function(grid) {\\n    let mnts = 2\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j] == 2)     mark(grid, i, j, mnts)\\n        }\\n    }\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j] == 1) return -1\\n            mnts = Math.max(mnts, grid[i][j])\\n        }\\n    }\\n    return mnts-2\\n};\\n\\nfunction mark(grid, i, j, mnts){\\n    if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < mnts))\\n        return\\n    grid[i][j] = mnts\\n    mark(grid, i+1, j, mnts+1)\\n    mark(grid, i-1, j, mnts+1)\\n    mark(grid, i, j+1, mnts+1)\\n    mark(grid, i, j-1, mnts+1)\\n}\\n```\n```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        mnts = 2\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 2:\\n                    self.mark(grid, i, j, mnts)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    return -1\\n                mnts = max(mnts, grid[i][j])\\n        return mnts-2\\n    def mark(self, grid, i, j, mnts):\\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0 or (grid[i][j] > 1 and grid[i][j] < mnts):\\n            return\\n        grid[i][j] = mnts\\n        self.mark(grid, i+1, j, mnts+1)\\n        self.mark(grid, i-1, j, mnts+1)\\n        self.mark(grid, i, j+1, mnts+1)\\n        self.mark(grid, i, j-1, mnts+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120339,
                "title": "two-sets-solution-99-speed",
                "content": "Runtime: 40 ms, faster than 99.05% of Python3 online submissions for Rotting Oranges.\\nMemory Usage: 13.9 MB, less than 99.71% of Python3 online submissions for Rotting Oranges.\\n\\nI got lucky with the servers!:)))))\\n```\\nclass Solution:\\n    def orangesRotting(self, grid) -> int:\\n        fresh = set()\\n        rotten = set()\\n        minute = 0\\n        for r, row in enumerate(grid):\\n            for c, v in enumerate(row):\\n                if v == 1:\\n                    fresh.add((r, c))\\n                elif v == 2:\\n                    rotten.add((r, c))\\n        while rotten and fresh:\\n            new_rot = set()\\n            for r, c in rotten:\\n                for i, j in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                    new_tpl = (r + i, c + j)\\n                    if new_tpl in fresh:\\n                        fresh.remove(new_tpl)\\n                        new_rot.add(new_tpl)\\n            rotten = new_rot\\n            minute += 1\\n        return minute if not fresh else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid) -> int:\\n        fresh = set()\\n        rotten = set()\\n        minute = 0\\n        for r, row in enumerate(grid):\\n            for c, v in enumerate(row):\\n                if v == 1:\\n                    fresh.add((r, c))\\n                elif v == 2:\\n                    rotten.add((r, c))\\n        while rotten and fresh:\\n            new_rot = set()\\n            for r, c in rotten:\\n                for i, j in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                    new_tpl = (r + i, c + j)\\n                    if new_tpl in fresh:\\n                        fresh.remove(new_tpl)\\n                        new_rot.add(new_tpl)\\n            rotten = new_rot\\n            minute += 1\\n        return minute if not fresh else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858666,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Queue<int[]> Q = new LinkedList<>();\\n        int fresh=0;     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1) fresh++; //fresh count\\n                else if(grid[i][j]==2) Q.offer(new int[]{i,j}); // add rotton oranges to the queue\\n            }\\n        }\\n        \\n        if(fresh==0) return 0; \\n        \\n        int moves[][] = new int[][]{{0,1},{1,0},{-1,0},{0,-1}}; // 4 directions to moves\\n        int minute=-1; //here minute represents bfs level\\n        \\n        while(!Q.isEmpty()){\\n            int size = Q.size(); // to keep track of the current level elements \\n            minute++; \\n            while(size-- > 0){\\n                int[] d = Q.poll(); // poll the rotten orange\\n                for(int[] dir : moves){ //visit all 4 directions\\n                    int x = d[0]+dir[0];\\n                    int y = d[1]+dir[1];\\n                    if(x<0 || y<0 || x>= m || y>=n || grid[x][y]==0 || grid[x][y]==2) continue; //already rotten or invalid coordinate\\n                    grid[x][y] = 2; // mark the adjacent orange as visited( rotten)\\n                    fresh--; // decrease the fresh count\\n                    Q.offer(new int[]{x,y}); // add this rotten orange for next minute(level)\\n                }\\n            }\\n        }\\n             \\n        return fresh==0 ? minute : -1;        \\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Queue<int[]> Q = new LinkedList<>();\\n        int fresh=0;     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1) fresh++; //fresh count\\n                else if(grid[i][j]==2) Q.offer(new int[]{i,j}); // add rotton oranges to the queue\\n            }\\n        }\\n        \\n        if(fresh==0) return 0; \\n        \\n        int moves[][] = new int[][]{{0,1},{1,0},{-1,0},{0,-1}}; // 4 directions to moves\\n        int minute=-1; //here minute represents bfs level\\n        \\n        while(!Q.isEmpty()){\\n            int size = Q.size(); // to keep track of the current level elements \\n            minute++; \\n            while(size-- > 0){\\n                int[] d = Q.poll(); // poll the rotten orange\\n                for(int[] dir : moves){ //visit all 4 directions\\n                    int x = d[0]+dir[0];\\n                    int y = d[1]+dir[1];\\n                    if(x<0 || y<0 || x>= m || y>=n || grid[x][y]==0 || grid[x][y]==2) continue; //already rotten or invalid coordinate\\n                    grid[x][y] = 2; // mark the adjacent orange as visited( rotten)\\n                    fresh--; // decrease the fresh count\\n                    Q.offer(new int[]{x,y}); // add this rotten orange for next minute(level)\\n                }\\n            }\\n        }\\n             \\n        return fresh==0 ? minute : -1;        \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843694,
                "title": "python-dfs-solution",
                "content": "Similar to number of Islands problem, use a recursive function to count the time it takes to affect each orange. traverse through grid again to ensure there is no untouched fresh orange. return largest number which represents the total minutes to reach the last fresh fruit and make it rotten.\\n```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int: \\n        maxx = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 2:\\n                    self.dfs(grid, i, j, 0, True)\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 1:\\n                    return -1\\n                maxx = max(abs(grid[i][j]), maxx)\\n\\n        return maxx\\n    \\n    def dfs(self, grid, i, j, counter, start):\\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[i]) or grid[i][j] == 0 or (grid[i][j] < 0 and -grid[i][j] < counter):\\n            return \\n        if start is False and grid[i][j] == 2:\\n            return \\n        \\n        grid[i][j] = -counter\\n            \\n        self.dfs(grid, i+1, j, counter + 1, False)\\n        self.dfs(grid, i-1, j, counter + 1, False)\\n        self.dfs(grid, i, j+1, counter + 1, False)\\n        self.dfs(grid, i, j-1, counter + 1, False)",
                "solutionTags": [],
                "code": "Similar to number of Islands problem, use a recursive function to count the time it takes to affect each orange. traverse through grid again to ensure there is no untouched fresh orange. return largest number which represents the total minutes to reach the last fresh fruit and make it rotten.\\n```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int: \\n        maxx = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 2:\\n                    self.dfs(grid, i, j, 0, True)\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 1:\\n                    return -1\\n                maxx = max(abs(grid[i][j]), maxx)\\n\\n        return maxx\\n    \\n    def dfs(self, grid, i, j, counter, start):\\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[i]) or grid[i][j] == 0 or (grid[i][j] < 0 and -grid[i][j] < counter):\\n            return \\n        if start is False and grid[i][j] == 2:\\n            return \\n        \\n        grid[i][j] = -counter\\n            \\n        self.dfs(grid, i+1, j, counter + 1, False)\\n        self.dfs(grid, i-1, j, counter + 1, False)\\n        self.dfs(grid, i, j+1, counter + 1, False)\\n        self.dfs(grid, i, j-1, counter + 1, False)",
                "codeTag": "Java"
            },
            {
                "id": 783122,
                "title": "easy-to-understand-c-bfs-solution-code-commented",
                "content": "##### Observations:\\n- If we look the problem closely we get the intuition same as when we do a BFS traversal on a 2D plane.\\n- The only thing is we should keep track of the number of levels we traversed.\\n- And also we should make sure that : for one traversal **atleast** one cell is affected by the current cell.\\n- If we affect atleast one cell in the current timestamp we can increment our global time.\\n\\nHope you understand. Below is the C++ implementation of the same idea.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        auto isValid = [m, n](int i, int j){\\n            if (i >= 0 && i < m && j >= 0 && j < n)\\n                return true;\\n            return false;\\n\\t\\t\\t};    // simple function to check whether a cell is valid or not\\n\\t\\t\\t// this is a lambda function : you can create your own normal function by passing m and n parameters\\n        \\n        int time = 0;    // we keep track of the time elapsed\\n\\t\\t\\n        std::queue<std::pair<int, int>> q;\\n        \\n        vector<vector<int>> dir = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};   // 4 directions for each cell\\n        \\n        // First Fill the rotten co-ordinates\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (grid[i][j] == 2)\\n                    q.push({i, j});\\n            }\\n        }\\n        \\n        while (!q.empty())\\n        {\\n            int size = q.size();\\n            int affected = 0;\\n\\t\\t\\t// Here is the trick\\n\\t\\t\\t// Imagine there are two rotten oranges at first : then both consitute for a single unit of time\\n\\t\\t\\t// so we take the queue size and pop that many elements in the queue\\n\\t\\t\\t// Uncomment the below cout statements to get a clear understanding\\n            for (int i = 0; i < size; ++i) \\n            {\\n                auto f = q.front();\\n                q.pop();\\n                // cout << \"from \" << f.first << \" \" << f.second << endl;\\n                for (auto &d : dir)\\n                {\\n                    int xx = f.first + d[0];\\n                    int yy = f.second + d[1];\\n                    if (isValid(xx, yy) && grid[xx][yy] == 1)\\n                    {\\n                        ++affected;\\n                        // cout << \"    affected \" << xx << \" \" << yy << endl;\\n                        grid[xx][yy] = 2;\\n                        q.push({xx, yy});\\n                    }\\n                }\\n            }\\n            if (affected > 0)\\n                    ++time;\\n        }\\n        \\n        // Now confirming all are affected\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (grid[i][j] == 1)\\n                    return -1; // if not affected return -1 :)\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```\\nIf you like the solution please upvote :)\\nThank You",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        auto isValid = [m, n](int i, int j){\\n            if (i >= 0 && i < m && j >= 0 && j < n)\\n                return true;\\n            return false;\\n\\t\\t\\t};    // simple function to check whether a cell is valid or not\\n\\t\\t\\t// this is a lambda function : you can create your own normal function by passing m and n parameters\\n        \\n        int time = 0;    // we keep track of the time elapsed\\n\\t\\t\\n        std::queue<std::pair<int, int>> q;\\n        \\n        vector<vector<int>> dir = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};   // 4 directions for each cell\\n        \\n        // First Fill the rotten co-ordinates\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (grid[i][j] == 2)\\n                    q.push({i, j});\\n            }\\n        }\\n        \\n        while (!q.empty())\\n        {\\n            int size = q.size();\\n            int affected = 0;\\n\\t\\t\\t// Here is the trick\\n\\t\\t\\t// Imagine there are two rotten oranges at first : then both consitute for a single unit of time\\n\\t\\t\\t// so we take the queue size and pop that many elements in the queue\\n\\t\\t\\t// Uncomment the below cout statements to get a clear understanding\\n            for (int i = 0; i < size; ++i) \\n            {\\n                auto f = q.front();\\n                q.pop();\\n                // cout << \"from \" << f.first << \" \" << f.second << endl;\\n                for (auto &d : dir)\\n                {\\n                    int xx = f.first + d[0];\\n                    int yy = f.second + d[1];\\n                    if (isValid(xx, yy) && grid[xx][yy] == 1)\\n                    {\\n                        ++affected;\\n                        // cout << \"    affected \" << xx << \" \" << yy << endl;\\n                        grid[xx][yy] = 2;\\n                        q.push({xx, yy});\\n                    }\\n                }\\n            }\\n            if (affected > 0)\\n                    ++time;\\n        }\\n        \\n        // Now confirming all are affected\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (grid[i][j] == 1)\\n                    return -1; // if not affected return -1 :)\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 781944,
                "title": "python-simple-and-easy-to-understand-no-bfs",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        # store in dictionary all coordinations of oranges, sorted by rotten/fresh/empty\\n        my_dict = defaultdict(list)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                my_dict[grid[i][j]].append([i, j])\\n                \\n        count = 0\\n        while len(my_dict[1]) > 0:\\n            count += 1\\n            prev_len = len(my_dict[1])\\n            add_list = []\\n            # if there are no rotten oranges\\n            if len(my_dict[2]) == 0: \\n                # and there are no fresh ones\\n                if len(my_dict[1]) == 0:\\n                    return 0\\n                # there are fresh ones but no rotten\\n                else:\\n                    return -1\\n                \\n            # check all four sides of each rotten orange\\n            for x, y in my_dict[2]:\\n\\t\\t\\t\\t# top:\\n                if x > 0 and [x - 1, y] in my_dict[1]:\\n                    my_dict[1].remove([x - 1, y])\\n                    add_list.append([x - 1, y])\\n            \\n\\t\\t\\t\\t# right:\\n                if y < len(grid[0]) and [x, y + 1] in my_dict[1]:\\n                    my_dict[1].remove([x, y + 1])\\n                    add_list.append([x, y + 1])\\n                    \\n\\t\\t\\t\\t# down:\\n                if x < len(grid) and [x + 1, y] in my_dict[1]:\\n                    my_dict[1].remove([x + 1, y])\\n                    add_list.append([x + 1, y])\\n                    \\n\\t\\t\\t\\t# left:\\n                if y > 0 and [x, y - 1] in my_dict[1]:\\n                    my_dict[1].remove([x, y - 1])\\n                    add_list.append([x, y - 1])\\n                    \\n            my_dict[2].remove([x,y])\\n            my_dict[2] += add_list\\n            if prev_len == len(my_dict[1]):\\n                return -1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        # store in dictionary all coordinations of oranges, sorted by rotten/fresh/empty\\n        my_dict = defaultdict(list)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                my_dict[grid[i][j]].append([i, j])\\n                \\n        count = 0\\n        while len(my_dict[1]) > 0:\\n            count += 1\\n            prev_len = len(my_dict[1])\\n            add_list = []\\n            # if there are no rotten oranges\\n            if len(my_dict[2]) == 0: \\n                # and there are no fresh ones\\n                if len(my_dict[1]) == 0:\\n                    return 0\\n                # there are fresh ones but no rotten\\n                else:\\n                    return -1\\n                \\n            # check all four sides of each rotten orange\\n            for x, y in my_dict[2]:\\n\\t\\t\\t\\t# top:\\n                if x > 0 and [x - 1, y] in my_dict[1]:\\n                    my_dict[1].remove([x - 1, y])\\n                    add_list.append([x - 1, y])\\n            \\n\\t\\t\\t\\t# right:\\n                if y < len(grid[0]) and [x, y + 1] in my_dict[1]:\\n                    my_dict[1].remove([x, y + 1])\\n                    add_list.append([x, y + 1])\\n                    \\n\\t\\t\\t\\t# down:\\n                if x < len(grid) and [x + 1, y] in my_dict[1]:\\n                    my_dict[1].remove([x + 1, y])\\n                    add_list.append([x + 1, y])\\n                    \\n\\t\\t\\t\\t# left:\\n                if y > 0 and [x, y - 1] in my_dict[1]:\\n                    my_dict[1].remove([x, y - 1])\\n                    add_list.append([x, y - 1])\\n                    \\n            my_dict[2].remove([x,y])\\n            my_dict[2] += add_list\\n            if prev_len == len(my_dict[1]):\\n                return -1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570014,
                "title": "very-straightforward-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //T(n) = O(m*n*lg(m*n))\\n    //S(n) = O(m*n*lg(m*n))\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if(grid.empty()){\\n            return -1;\\n        }\\n        set<pair<int,int>> fresh;\\n        set<pair<int,int>> rotten;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                if(grid[i][j] == 1){\\n                    fresh.insert({i,j});\\n                }\\n                if(grid[i][j] == 2){\\n                    rotten.insert({i,j});\\n                }\\n            }\\n        }\\n        int move = 0;\\n        vector<vector<int>> directions = {{1,0},{-1,0},{0,1},{0,-1}};\\n        while(fresh.size() > 0){\\n            set<pair<int,int>> temprot;\\n            for(auto v : rotten){\\n                int row = v.first;\\n                int col = v.second;\\n                //check\\n                \\n                for(auto d : directions){\\n                    int x = row + d[0];\\n                    int y = col + d[1];\\n                    if(fresh.find({x,y}) != fresh.end()){\\n                        fresh.erase({x,y});\\n                        temprot.insert({x,y});\\n                    }\\n                }\\n            }\\n            if(temprot.size() == 0){\\n                return -1;\\n            }\\n            for(auto v : temprot){\\n                rotten.insert(v);\\n            }\\n            move++;\\n        }\\n        return move;    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    //T(n) = O(m*n*lg(m*n))\\n    //S(n) = O(m*n*lg(m*n))\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if(grid.empty()){\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 563875,
                "title": "c-solution",
                "content": "**Solution: BFS**\\n\\nStarting from all rotten oranges, use BFS to traverse the graph. Each rotten orange will rot its adjacent fresh oranges during each recursion. Time complexity and space complexity are both O(m * n).\\n\\nNote: why return  ```time - 1```? \\n\\nwhile loop logic traverses the graph and rot the fresh oranges. For the last group of rotten orange(s), ```time``` will increment by 1 even though they won\\'t rot fresh oranges, so we need time - 1. An alternative way is to ensure ```fresh > 0``` before starting BFS.\\n\\n\\n\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        \\n        if(grid == null || grid[0].Length == 0)\\n            return 0;\\n        \\n        int m = grid.Length, n = grid[0].Length;\\n        int fresh = 0;\\n        \\n        Queue<(int,int)> queue = new Queue<(int,int)>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    fresh++;\\n                else if(grid[i][j] == 2)\\n                    queue.Enqueue((i,j));\\n            }\\n        }\\n        \\n        if(fresh == 0)\\n            return 0;\\n        \\n        int time = 0;\\n        int[,] dir = new int[,]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n        while(queue.Count > 0)\\n        {\\n            time++;\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                var curr = queue.Dequeue();\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    int newRow = curr.Item1 + dir[j,0];\\n                    int newCol = curr.Item2 + dir[j,1];\\n                    \\n                    if(newRow >= 0 && newRow < m && newCol >=0 && newCol < n && grid[newRow][newCol] == 1)\\n                    {\\n                        grid[newRow][newCol] = 2;\\n                        queue.Enqueue((newRow,newCol));\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return fresh == 0? time - 1: -1;\\n    }\\n}\\n```\\n\\n**Solution: BFS + check fresh before BFS**\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        \\n        if(grid == null || grid[0].Length == 0)\\n            return 0;\\n        \\n        int m = grid.Length, n = grid[0].Length;\\n        int fresh = 0;\\n        \\n        Queue<(int,int)> queue = new Queue<(int,int)>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    fresh++;\\n                else if(grid[i][j] == 2)\\n                    queue.Enqueue((i,j));\\n            }\\n        }\\n        \\n        if(fresh == 0)\\n            return 0;\\n        \\n        int time = 0;\\n        int[,] dir = new int[,]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n\\t\\t\\n\\t\\t// check fresh before BFS traverse the graph\\n        while(queue.Count > 0 && fresh > 0)\\n        {\\n            time++;\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                var curr = queue.Dequeue();\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    int newRow = curr.Item1 + dir[j,0];\\n                    int newCol = curr.Item2 + dir[j,1];\\n                    \\n                    if(newRow >= 0 && newRow < m && newCol >=0 && newCol < n && grid[newRow][newCol] == 1)\\n                    {\\n                        grid[newRow][newCol] = 2;\\n                        queue.Enqueue((newRow,newCol));\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return fresh == 0? time: -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```time - 1```\n```time```\n```fresh > 0```\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        \\n        if(grid == null || grid[0].Length == 0)\\n            return 0;\\n        \\n        int m = grid.Length, n = grid[0].Length;\\n        int fresh = 0;\\n        \\n        Queue<(int,int)> queue = new Queue<(int,int)>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    fresh++;\\n                else if(grid[i][j] == 2)\\n                    queue.Enqueue((i,j));\\n            }\\n        }\\n        \\n        if(fresh == 0)\\n            return 0;\\n        \\n        int time = 0;\\n        int[,] dir = new int[,]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n        while(queue.Count > 0)\\n        {\\n            time++;\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                var curr = queue.Dequeue();\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    int newRow = curr.Item1 + dir[j,0];\\n                    int newCol = curr.Item2 + dir[j,1];\\n                    \\n                    if(newRow >= 0 && newRow < m && newCol >=0 && newCol < n && grid[newRow][newCol] == 1)\\n                    {\\n                        grid[newRow][newCol] = 2;\\n                        queue.Enqueue((newRow,newCol));\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return fresh == 0? time - 1: -1;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        \\n        if(grid == null || grid[0].Length == 0)\\n            return 0;\\n        \\n        int m = grid.Length, n = grid[0].Length;\\n        int fresh = 0;\\n        \\n        Queue<(int,int)> queue = new Queue<(int,int)>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    fresh++;\\n                else if(grid[i][j] == 2)\\n                    queue.Enqueue((i,j));\\n            }\\n        }\\n        \\n        if(fresh == 0)\\n            return 0;\\n        \\n        int time = 0;\\n        int[,] dir = new int[,]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n\\t\\t\\n\\t\\t// check fresh before BFS traverse the graph\\n        while(queue.Count > 0 && fresh > 0)\\n        {\\n            time++;\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                var curr = queue.Dequeue();\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    int newRow = curr.Item1 + dir[j,0];\\n                    int newCol = curr.Item2 + dir[j,1];\\n                    \\n                    if(newRow >= 0 && newRow < m && newCol >=0 && newCol < n && grid[newRow][newCol] == 1)\\n                    {\\n                        grid[newRow][newCol] = 2;\\n                        queue.Enqueue((newRow,newCol));\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return fresh == 0? time: -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529492,
                "title": "clean-understandable-professional-code",
                "content": "What do i mean by CUPC(clean understandable professional code)\\nNo hacks that make the code run faster.\\nNo Weird assumptions that may fool the system.\\nNo shit variable or random data structures that if used in real life woul mean being fired from job.\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        //Build a list of all the rotten apples\\n\\t\\t// This will be used for the BFS\\n        Queue<Identifier> queue = new LinkedList<>();\\n        for(int i =0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                if(2==grid[i][j]){\\n                    queue.add(new Identifier(i,j,0));\\n                }\\n            }\\n        }\\n        //depth = day\\n        int day=0;\\n        while(!queue.isEmpty()){\\n            Identifier badOrange = queue.remove();\\n            if(day<=badOrange.day){\\n                day=badOrange.day;\\n            }\\n\\t\\t\\t// look at all the adjecent cells for good oranges. \\n\\t\\t\\t//Add the newly spoilt oranges to the list and update the value so that we don\\'t end up in a cycle\\n            //up\\n            if(badOrange.row -1>=0 && grid[badOrange.row-1][badOrange.column]==1){\\n                grid[badOrange.row-1][badOrange.column]=2;\\n                queue.add(new Identifier(badOrange.row-1,badOrange.column, day+1));\\n            }\\n            //down\\n            if(badOrange.row+1< grid.length && grid[badOrange.row+1][badOrange.column]==1){\\n                grid[badOrange.row+1][badOrange.column]=2;\\n                queue.add(new Identifier(badOrange.row+1,badOrange.column, day+1));\\n            }\\n            //left\\n            if(badOrange.column-1>=0 && grid[badOrange.row][badOrange.column-1]==1){\\n                grid[badOrange.row][badOrange.column-1]=2;\\n                queue.add(new Identifier(badOrange.row,badOrange.column-1, day+1));\\n            }\\n            //right\\n            if(badOrange.column+1<grid[0].length && grid[badOrange.row][badOrange.column+1]==1){\\n                grid[badOrange.row][badOrange.column+1]=2;\\n                queue.add(new Identifier(badOrange.row,badOrange.column+1, day+1));\\n            }\\n        }\\n        //final check to see if any straggling oranges remain\\n        for(int i =0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                int val = grid[i][j];\\n                if(val!=2 && val !=0){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return day;\\n    }\\n}\\nclass Identifier{\\n    int row, column, day;\\n    public Identifier(int row, int column, int day){\\n        this.row = row;\\n        this.column = column;\\n        this.day = day;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        //Build a list of all the rotten apples\\n\\t\\t// This will be used for the BFS\\n        Queue<Identifier> queue = new LinkedList<>();\\n        for(int i =0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                if(2==grid[i][j]){\\n                    queue.add(new Identifier(i,j,0));\\n                }\\n            }\\n        }\\n        //depth = day\\n        int day=0;\\n        while(!queue.isEmpty()){\\n            Identifier badOrange = queue.remove();\\n            if(day<=badOrange.day){\\n                day=badOrange.day;\\n            }\\n\\t\\t\\t// look at all the adjecent cells for good oranges. \\n\\t\\t\\t//Add the newly spoilt oranges to the list and update the value so that we don\\'t end up in a cycle\\n            //up\\n            if(badOrange.row -1>=0 && grid[badOrange.row-1][badOrange.column]==1){\\n                grid[badOrange.row-1][badOrange.column]=2;\\n                queue.add(new Identifier(badOrange.row-1,badOrange.column, day+1));\\n            }\\n            //down\\n            if(badOrange.row+1< grid.length && grid[badOrange.row+1][badOrange.column]==1){\\n                grid[badOrange.row+1][badOrange.column]=2;\\n                queue.add(new Identifier(badOrange.row+1,badOrange.column, day+1));\\n            }\\n            //left\\n            if(badOrange.column-1>=0 && grid[badOrange.row][badOrange.column-1]==1){\\n                grid[badOrange.row][badOrange.column-1]=2;\\n                queue.add(new Identifier(badOrange.row,badOrange.column-1, day+1));\\n            }\\n            //right\\n            if(badOrange.column+1<grid[0].length && grid[badOrange.row][badOrange.column+1]==1){\\n                grid[badOrange.row][badOrange.column+1]=2;\\n                queue.add(new Identifier(badOrange.row,badOrange.column+1, day+1));\\n            }\\n        }\\n        //final check to see if any straggling oranges remain\\n        for(int i =0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                int val = grid[i][j];\\n                if(val!=2 && val !=0){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return day;\\n    }\\n}\\nclass Identifier{\\n    int row, column, day;\\n    public Identifier(int row, int column, int day){\\n        this.row = row;\\n        this.column = column;\\n        this.day = day;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305746,
                "title": "java-95",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length, n = m == 0 ? 0 : grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        int cnt = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 2)\\n                    q.add(new int[]{i, j});\\n                else if(grid[i][j] == 1)\\n                    cnt++;\\n            }\\n        }\\n        if(cnt == 0) return 0;\\n        \\n        int min = 0;\\n        int[][] dir = {{0, 1}, {1,0}, {-1, 0}, {0,-1}};\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                int[] cur = q.poll();\\n                for(int[] d : dir) {\\n                    int x = cur[0] + d[0], y = cur[1] + d[1];\\n                    if(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] != 1)\\n                        continue;\\n                    grid[x][y] = 2;\\n                    cnt--;\\n                    q.add(new int[]{x, y});\\n                }\\n            }\\n            min++;\\n        }\\n        return cnt == 0 ? min - 1: -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length, n = m == 0 ? 0 : grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        int cnt = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 2)\\n                    q.add(new int[]{i, j}",
                "codeTag": "Java"
            },
            {
                "id": 238890,
                "title": "java-o-n-2-time-o-1-space-accepted-simple-approach-simulate-the-rotting",
                "content": "This was a contest question, so I justed quickly coded up the first thing that came to mind, instead of trying to come up with something optimal.  Obviously the O(n) BFS solutions are faster, but this is easier to come up with and understand.  It also has the advantage of being O(1) space instead of O(n) space.\\n```\\n    public int orangesRotting(int[][] grid) {\\n        int minutes=-1;\\n\\n        // brute-force propagation of rotten-ness.\\n        for( boolean changed=true; changed; minutes++ ) {\\n            changed=false;\\n            \\n            // mark all fresh oranges with rotten neighbors\\n            for( int i=0; i<grid.length; i++ )\\n                for( int j=0; j<grid[i].length; j++ )\\n                    if( grid[i][j]==1 && rottenNeighbor( grid, i, j ) ) {\\n                        grid[i][j]=-2;\\n                        changed=true;\\n                    }\\n            \\n            // flip marked oranges to now be rotten\\n            if( changed ) for( int i=0; i<grid.length; i++ )\\n                for( int j=0; j<grid[i].length; j++ )\\n                    if( grid[i][j]==-2 ) grid[i][j]=2;\\n        }\\n\\n        // Check if there\\'s any fresh oranges left:\\n        for( int i=0; i<grid.length; i++ )\\n            for( int j=0; j<grid[i].length; j++ )\\n                if( grid[i][j]==1 ) return -1;\\n        \\n        return minutes;\\n    }\\n    \\n    private static boolean rottenNeighbor( int[][] grid, int x, int y ) {\\n        if( x>0 && grid[x-1][y]==2 ) return true;\\n        if( y>0 && grid[x][y-1]==2 ) return true;\\n        if( (x+1)<grid.length && grid[x+1][y]==2 ) return true;\\n        if( (y+1)<grid[x].length && grid[x][y+1]==2 ) return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int orangesRotting(int[][] grid) {\\n        int minutes=-1;\\n\\n        // brute-force propagation of rotten-ness.\\n        for( boolean changed=true; changed; minutes++ ) {\\n            changed=false;\\n            \\n            // mark all fresh oranges with rotten neighbors\\n            for( int i=0; i<grid.length; i++ )\\n                for( int j=0; j<grid[i].length; j++ )\\n                    if( grid[i][j]==1 && rottenNeighbor( grid, i, j ) ) {\\n                        grid[i][j]=-2;\\n                        changed=true;\\n                    }\\n            \\n            // flip marked oranges to now be rotten\\n            if( changed ) for( int i=0; i<grid.length; i++ )\\n                for( int j=0; j<grid[i].length; j++ )\\n                    if( grid[i][j]==-2 ) grid[i][j]=2;\\n        }\\n\\n        // Check if there\\'s any fresh oranges left:\\n        for( int i=0; i<grid.length; i++ )\\n            for( int j=0; j<grid[i].length; j++ )\\n                if( grid[i][j]==1 ) return -1;\\n        \\n        return minutes;\\n    }\\n    \\n    private static boolean rottenNeighbor( int[][] grid, int x, int y ) {\\n        if( x>0 && grid[x-1][y]==2 ) return true;\\n        if( y>0 && grid[x][y-1]==2 ) return true;\\n        if( (x+1)<grid.length && grid[x+1][y]==2 ) return true;\\n        if( (y+1)<grid[x].length && grid[x][y+1]==2 ) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650187,
                "title": "most-optimized-c-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int i,j,a=grid.size(),b=grid[0].size();\\n        int x = 0;\\n        queue<vector<int>> q;\\n        vector<int> v;\\n        for(i = 0; i < a; i++){\\n            for(j = 0; j < b; j++){\\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                    grid[i][j] = 0;\\n                }\\n                x += (grid[i][j]==1);\\n            }\\n        }\\n        if(x==0)return 0;\\n        int ans = -1,n;\\n        while(!q.empty()){\\n            ans++;\\n            n = q.size();\\n            while(n--){v = q.front();\\n            q.pop();\\n            if(v[0]+1<a&&grid[v[0]+1][v[1]]==1){\\n                q.push({v[0]+1,v[1]});\\n                x--;\\n                grid[v[0]+1][v[1]]=0;\\n            }\\n            if(v[1]+1<b&&grid[v[0]][v[1]+1]==1){\\n                q.push({v[0],v[1]+1});\\n                x--;\\n                grid[v[0]][v[1]+1]=0;\\n            }\\n            if(v[0]-1>=0&&grid[v[0]-1][v[1]]==1){\\n                q.push({v[0]-1,v[1]});\\n                x--;\\n                grid[v[0]-1][v[1]]=0;\\n            }\\n            if(v[1]-1>=0&&grid[v[0]][v[1]-1]==1){\\n                q.push({v[0],v[1]-1});\\n                x--;\\n                grid[v[0]][v[1]-1]=0;\\n            }}\\n        }\\n        return (x==0)?ans:-1;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int i,j,a=grid.size(),b=grid[0].size();\\n        int x = 0;\\n        queue<vector<int>> q;\\n        vector<int> v;\\n        for(i = 0; i < a; i++){\\n            for(j = 0; j < b; j++){\\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                    grid[i][j] = 0;\\n                }\\n                x += (grid[i][j]==1);\\n            }\\n        }\\n        if(x==0)return 0;\\n        int ans = -1,n;\\n        while(!q.empty()){\\n            ans++;\\n            n = q.size();\\n            while(n--){v = q.front();\\n            q.pop();\\n            if(v[0]+1<a&&grid[v[0]+1][v[1]]==1){\\n                q.push({v[0]+1,v[1]});\\n                x--;\\n                grid[v[0]+1][v[1]]=0;\\n            }\\n            if(v[1]+1<b&&grid[v[0]][v[1]+1]==1){\\n                q.push({v[0],v[1]+1});\\n                x--;\\n                grid[v[0]][v[1]+1]=0;\\n            }\\n            if(v[0]-1>=0&&grid[v[0]-1][v[1]]==1){\\n                q.push({v[0]-1,v[1]});\\n                x--;\\n                grid[v[0]-1][v[1]]=0;\\n            }\\n            if(v[1]-1>=0&&grid[v[0]][v[1]-1]==1){\\n                q.push({v[0],v[1]-1});\\n                x--;\\n                grid[v[0]][v[1]-1]=0;\\n            }}\\n        }\\n        return (x==0)?ans:-1;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450905,
                "title": "iterative-bfs-solution-explanation-commentaries",
                "content": "# Intuition\\nThe approach used is a Breadth-First Search (BFS) algorithm, implemented with a Queue data structure, to traverse the grid of oranges, track rotten oranges and count fresh oranges.\\n\\n# Approach\\nThe algorithm starts by initializing a queue to store the coordinates of rotten oranges found in the grid. Then, the grid is traversed to count the number of fresh oranges and add the rotten oranges\\' coordinates to the queue. If there are no fresh oranges, the function returns 0 because there is no need for any minute to elapse.\\n\\nThe while loop iterates until the queue is empty. In each iteration, the size of the queue is obtained to process all the elements currently in the queue, which are the rotten oranges found in the previous minute.\\n\\nFor each rotten orange, its adjacent cells are checked, and if they are fresh oranges, they are marked as rotten, added to the queue, and the counter of fresh oranges is decremented. The BFS algorithm continues to the next level by processing all the fresh oranges found in the previous level.\\n\\nAt each iteration of the while loop, the time variable is incremented to keep track of the minutes that have elapsed since the first rotten orange was found.\\n\\nFinally, if there are no fresh oranges left, the function returns the elapsed time. Otherwise, it returns -1 to indicate that there are still fresh oranges left that cannot be rotten.\\n\\n# Complexity\\n- Time complexity:\\nO(n * m), where n and m are the dimensions of the grid because the BFS algorithm must visit every cell in the grid\\n\\n- Space complexity:\\nO(n * m), the queue can store up to all the fresh oranges in the worst-case scenario.\\n\\n# Code\\n```\\nclass Solution {\\n    // initialize time variable to 0\\n    private int time = 0;\\n\\n    public int orangesRotting(int[][] grid) {\\n        // get dimensions of grid\\n        int y = grid.length;\\n        int x = grid[0].length;\\n\\n        // create queue to store rotten oranges\\n        Queue<int[]> rotten = new LinkedList<>();\\n\\n        // count number of fresh oranges\\n        int freshOranges = 0;\\n\\n        // traverse grid to find rotten and fresh oranges\\n        for (int i = 0; i < y; i++) {\\n            for (int j = 0; j < x; j++) {\\n                if (grid[i][j] == 2) { // if cell contains a rotten orange\\n                    rotten.offer(new int[]{i, j}); // add its coordinates to the queue\\n                } else if (grid[i][j] == 1) { // if cell contains a fresh orange\\n                    freshOranges++; // increment counter of fresh oranges\\n                }\\n            }\\n        }\\n\\n        // if there are no fresh oranges, return 0\\n        if (freshOranges == 0) {\\n            return 0;\\n        }\\n\\n        // use BFS algorithm to find minimum time to rot all fresh oranges\\n        while (!rotten.isEmpty()) { // while there are still rotten oranges to process\\n            int size = rotten.size(); // get size of current level of BFS tree\\n\\n            // process all rotten oranges in current level of BFS tree\\n            for (int i = 0; i < size; i++) {\\n                int[] temp = rotten.poll(); // get coordinates of next rotten orange\\n                assert temp != null; // make sure coordinates are not null\\n                int row = temp[0]; // get row coordinate\\n                int col = temp[1]; // get column coordinate\\n\\n                // check adjacent cells to see if they are fresh oranges\\n                // if so, mark them as rotten, add to queue, and decrement counter of fresh oranges\\n                if (row > 0 && grid[row - 1][col] == 1) {\\n                    rotten.offer(new int[]{row - 1, col});\\n                    grid[row - 1][col] = 2;\\n                    freshOranges--;\\n                }\\n                if (row < y - 1 && grid[row + 1][col] == 1) {\\n                    rotten.offer(new int[]{row + 1, col});\\n                    grid[row + 1][col] = 2;\\n                    freshOranges--;\\n                }\\n                if (col > 0 && grid[row][col - 1] == 1) {\\n                    rotten.offer(new int[]{row, col - 1});\\n                    grid[row][col - 1] = 2;\\n                    freshOranges--;\\n                }\\n                if (col < x - 1 && grid[row][col + 1] == 1) {\\n                    rotten.offer(new int[]{row, col + 1});\\n                    grid[row][col + 1] = 2;\\n                    freshOranges--;\\n                }\\n            }\\n\\n            time++; // increment time counter for each level of BFS tree\\n        }\\n\\n        // if there are still fresh oranges, return -1 to indicate it is impossible to rot all of them\\n        // otherwise, return elapsed time\\n        return freshOranges == 0 ? time - 1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    // initialize time variable to 0\\n    private int time = 0;\\n\\n    public int orangesRotting(int[][] grid) {\\n        // get dimensions of grid\\n        int y = grid.length;\\n        int x = grid[0].length;\\n\\n        // create queue to store rotten oranges\\n        Queue<int[]> rotten = new LinkedList<>();\\n\\n        // count number of fresh oranges\\n        int freshOranges = 0;\\n\\n        // traverse grid to find rotten and fresh oranges\\n        for (int i = 0; i < y; i++) {\\n            for (int j = 0; j < x; j++) {\\n                if (grid[i][j] == 2) { // if cell contains a rotten orange\\n                    rotten.offer(new int[]{i, j}); // add its coordinates to the queue\\n                } else if (grid[i][j] == 1) { // if cell contains a fresh orange\\n                    freshOranges++; // increment counter of fresh oranges\\n                }\\n            }\\n        }\\n\\n        // if there are no fresh oranges, return 0\\n        if (freshOranges == 0) {\\n            return 0;\\n        }\\n\\n        // use BFS algorithm to find minimum time to rot all fresh oranges\\n        while (!rotten.isEmpty()) { // while there are still rotten oranges to process\\n            int size = rotten.size(); // get size of current level of BFS tree\\n\\n            // process all rotten oranges in current level of BFS tree\\n            for (int i = 0; i < size; i++) {\\n                int[] temp = rotten.poll(); // get coordinates of next rotten orange\\n                assert temp != null; // make sure coordinates are not null\\n                int row = temp[0]; // get row coordinate\\n                int col = temp[1]; // get column coordinate\\n\\n                // check adjacent cells to see if they are fresh oranges\\n                // if so, mark them as rotten, add to queue, and decrement counter of fresh oranges\\n                if (row > 0 && grid[row - 1][col] == 1) {\\n                    rotten.offer(new int[]{row - 1, col});\\n                    grid[row - 1][col] = 2;\\n                    freshOranges--;\\n                }\\n                if (row < y - 1 && grid[row + 1][col] == 1) {\\n                    rotten.offer(new int[]{row + 1, col});\\n                    grid[row + 1][col] = 2;\\n                    freshOranges--;\\n                }\\n                if (col > 0 && grid[row][col - 1] == 1) {\\n                    rotten.offer(new int[]{row, col - 1});\\n                    grid[row][col - 1] = 2;\\n                    freshOranges--;\\n                }\\n                if (col < x - 1 && grid[row][col + 1] == 1) {\\n                    rotten.offer(new int[]{row, col + 1});\\n                    grid[row][col + 1] = 2;\\n                    freshOranges--;\\n                }\\n            }\\n\\n            time++; // increment time counter for each level of BFS tree\\n        }\\n\\n        // if there are still fresh oranges, return -1 to indicate it is impossible to rot all of them\\n        // otherwise, return elapsed time\\n        return freshOranges == 0 ? time - 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284695,
                "title": "best-o-n-m-solution",
                "content": "# Approach\\nUsing BFS Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        queue <pair<pair<int, int>, int>> q;\\n        int cntFresh = 0;\\n        int visited[row][col];\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 2) {\\n                    q.push({{i, j}, 0});\\n                    visited[i][j] = 2;\\n                } else {\\n                    visited[i][j] = 0;\\n                }\\n                if (grid[i][j] == 1)\\n                    cntFresh++;\\n            }\\n        }\\n        int time = 0;\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        int cnt = 0;\\n        while (!q.empty()) {\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            time = max(time, t);\\n            for (int i = 0; i < 4; i++) {\\n                int nrow = r + drow[i];\\n                int ncol = c + dcol[i];\\n                if (nrow >= 0 && nrow < row && ncol >= 0 && ncol < col &&\\n                    visited[nrow][ncol] == 0 && grid[nrow][ncol] == 1) {\\n                        q.push({{nrow, ncol}, t + 1});\\n                        visited[nrow][ncol] = 2;\\n                        cnt++;\\n                    }\\n            }\\n        }\\n        if (cntFresh != cnt)\\n            return -1;\\n        return time;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        queue <pair<pair<int, int>, int>> q;\\n        int cntFresh = 0;\\n        int visited[row][col];\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 2) {\\n                    q.push({{i, j}, 0});\\n                    visited[i][j] = 2;\\n                } else {\\n                    visited[i][j] = 0;\\n                }\\n                if (grid[i][j] == 1)\\n                    cntFresh++;\\n            }\\n        }\\n        int time = 0;\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        int cnt = 0;\\n        while (!q.empty()) {\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            time = max(time, t);\\n            for (int i = 0; i < 4; i++) {\\n                int nrow = r + drow[i];\\n                int ncol = c + dcol[i];\\n                if (nrow >= 0 && nrow < row && ncol >= 0 && ncol < col &&\\n                    visited[nrow][ncol] == 0 && grid[nrow][ncol] == 1) {\\n                        q.push({{nrow, ncol}, t + 1});\\n                        visited[nrow][ncol] = 2;\\n                        cnt++;\\n                    }\\n            }\\n        }\\n        if (cntFresh != cnt)\\n            return -1;\\n        return time;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251088,
                "title": "bfs-approach-96-7-beats",
                "content": "# Intuition\\n![download (1).jfif](https://assets.leetcode.com/users/images/be6b9763-87cd-40de-9a17-f820422fbc87_1678376852.3238225.jpeg)\\nBFS approach\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // {{row,col},time}\\n        queue<pair<pair<int,int>, int> >q;\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j]=2; //mark vis as 2\\n                }\\n                else{\\n                    vis[i][j]=0;  //mark vis as 0\\n                }\\n            }\\n        }\\n        int time=0;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        while(!q.empty()){\\n        int r=q.front().first.first;\\n        int c=q.front().first.second;\\n        int t=q.front().second;\\n        tm=max(tm,t);\\n        q.pop();\\n       \\n\\n        for(int i=0;i<4;i++){\\n//to check in all direction up,left,right,down\\n            int nrow=r+drow[i];\\n            int ncol=c+dcol[i];\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]!=2 &&\\n            grid[nrow][ncol]==1){\\n                q.push({{nrow,ncol},t+1});\\n                vis[nrow][ncol]=2;\\n\\n        }\\n        \\n        }\\n\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]!=2 && grid[i][j]==1){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n\\n//please upvote!!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // {{row,col},time}\\n        queue<pair<pair<int,int>, int> >q;\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j]=2; //mark vis as 2\\n                }\\n                else{\\n                    vis[i][j]=0;  //mark vis as 0\\n                }\\n            }\\n        }\\n        int time=0;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        while(!q.empty()){\\n        int r=q.front().first.first;\\n        int c=q.front().first.second;\\n        int t=q.front().second;\\n        tm=max(tm,t);\\n        q.pop();\\n       \\n\\n        for(int i=0;i<4;i++){\\n//to check in all direction up,left,right,down\\n            int nrow=r+drow[i];\\n            int ncol=c+dcol[i];\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]!=2 &&\\n            grid[nrow][ncol]==1){\\n                q.push({{nrow,ncol},t+1});\\n                vis[nrow][ncol]=2;\\n\\n        }\\n        \\n        }\\n\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]!=2 && grid[i][j]==1){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n\\n//please upvote!!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110427,
                "title": "c-0-ms-100-faster-bfs",
                "content": "# Intuition\\nBFS\\n\\n# Approach\\nGraph BFS\\n\\n# Complexity\\n- Time complexity:\\nO(n * m) + O(n * m)*4\\n\\n- Space complexity:\\nO(node)\\n\\n# Code\\n```\\nstruct node{\\n  int x , y , time;\\n    node(int _x,int _y,int _time){\\n        x = _x;\\n        y = _y;\\n        time = _time;\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<node> q;\\n        int cntoranges = 0;\\n        for(int i  =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 2){\\n                    q.push(node(i,j,0));\\n                }\\n                if(grid[i][j] != 0) cntoranges++;\\n                \\n            }\\n            \\n        }\\n        int ans = 0;\\n        int cnt =0;\\n        while(!q.empty()){\\n            int x = q.front().x;\\n            int y = q.front().y;\\n            int time = q.front().time;\\n            q.pop();\\n            ans = max(ans , time);\\n            cnt++;\\n            int dx[] = {-1, 0 ,1 , 0};\\n            int dy[] = {0 , -1, 0,1};\\n            for(int i =0;i<4;i++){\\n                int newx  = x + dx[i];\\n                int newy = y + dy[i];\\n                if(newx >=0 && newy >=0 && newx<n && newy<m && grid[newx][newy] == 1){\\n                    grid[newx][newy] = 2;\\n                    q.push(node(newx , newy , time+1));\\n                    \\n                }\\n            }\\n        }\\n        if(cnt == cntoranges) return ans;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct node{\\n  int x , y , time;\\n    node(int _x,int _y,int _time){\\n        x = _x;\\n        y = _y;\\n        time = _time;\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<node> q;\\n        int cntoranges = 0;\\n        for(int i  =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 2){\\n                    q.push(node(i,j,0));\\n                }\\n                if(grid[i][j] != 0) cntoranges++;\\n                \\n            }\\n            \\n        }\\n        int ans = 0;\\n        int cnt =0;\\n        while(!q.empty()){\\n            int x = q.front().x;\\n            int y = q.front().y;\\n            int time = q.front().time;\\n            q.pop();\\n            ans = max(ans , time);\\n            cnt++;\\n            int dx[] = {-1, 0 ,1 , 0};\\n            int dy[] = {0 , -1, 0,1};\\n            for(int i =0;i<4;i++){\\n                int newx  = x + dx[i];\\n                int newy = y + dy[i];\\n                if(newx >=0 && newy >=0 && newx<n && newy<m && grid[newx][newy] == 1){\\n                    grid[newx][newy] = 2;\\n                    q.push(node(newx , newy , time+1));\\n                    \\n                }\\n            }\\n        }\\n        if(cnt == cntoranges) return ans;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935767,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ans=-1;\\n        int fresh=0;\\n        \\n        queue<pair<int,int>> q;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                fresh++;\\n                if(grid[i][j]==2)\\n                    q.push({i,j});\\n            }\\n        }\\n        // int d[5]={0, -1, 0, 1, 0};\\n        vector<int> d={-1,0,1,0,-1};\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(int j=0;j<4;j++)\\n                {\\n                    int r=p.first+d[j];\\n                    int c=p.second+d[j+1];\\n                    if(r>=0 && c>=0 && r<grid.size() && c<grid[0].size() && grid[r][c]==1)\\n                    {\\n                        fresh--;\\n                        grid[r][c]=2;\\n                        q.push({r,c});\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        if(fresh>0)\\n            return -1;\\n        if(ans==-1)\\n            return 0;\\n\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ans=-1;\\n        int fresh=0;\\n        \\n        queue<pair<int,int>> q;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                fresh++;\\n                if(grid[i][j]==2)\\n                    q.push({i,j});\\n            }\\n        }\\n        // int d[5]={0, -1, 0, 1, 0};\\n        vector<int> d={-1,0,1,0,-1};\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(int j=0;j<4;j++)\\n                {\\n                    int r=p.first+d[j];\\n                    int c=p.second+d[j+1];\\n                    if(r>=0 && c>=0 && r<grid.size() && c<grid[0].size() && grid[r][c]==1)\\n                    {\\n                        fresh--;\\n                        grid[r][c]=2;\\n                        q.push({r,c});\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        if(fresh>0)\\n            return -1;\\n        if(ans==-1)\\n            return 0;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813476,
                "title": "java-solution-using-bfs",
                "content": "Similar to question 01-Matrix. for explaination refer below page\\nhttps://leetcode.com/problems/01-matrix/discuss/1715389/SImple-java-solution-with-comments-or-bfs\\n\\nApproach 1\\n```\\n    public int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        init(grid,queue);\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int level=0;\\n        int[][] dirs={{-1,0},{1,0},{0,-1},{0,1}};\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            level++;\\n            while(size-->0) {\\n                int[] rc = queue.poll();\\n                for(int[] dir:dirs) {\\n                    int r=rc[0]+dir[0];\\n                    int c=rc[1]+dir[1];\\n                    if(r<0||c<0||r>=m||c>=n||grid[r][c]!=1) {\\n                        continue;\\n                    }\\n                    grid[r][c]=2;\\n                    queue.add(new int[]{r,c});\\n                    \\n                }\\n            }\\n        }\\n\\t\\t//check if 1 still exists\\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                if(grid[i][j]==1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        return level==0?0:level-1;\\n    }\\n    \\n    private void init(int[][] grid,Queue<int[]> queue) {\\n        \\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                if(grid[i][j]==2) {\\n                    queue.add(new int[]{i,j});\\n                }\\n            }\\n        }\\n        \\n    }\\n```\\nApproach 2\\n```\\npublic int orangesRotting(int[][] grid) {\\n\\t\\tQueue<int[]> queue = new LinkedList<>();\\n\\t\\tint fresh = init(grid, queue);\\n\\t\\tif (fresh == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint m = grid.length;\\n\\t\\tint n = grid[0].length;\\n\\t\\tint level = 0;\\n\\t\\tint[][] dirs = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tlevel++;\\n\\t\\t\\twhile (size-- > 0) {\\n\\t\\t\\t\\tint[] rc = queue.poll();\\n\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\tint r = rc[0] + dir[0];\\n\\t\\t\\t\\t\\tint c = rc[1] + dir[1];\\n\\t\\t\\t\\t\\tif (r < 0 || c < 0 || r >= m || c >= n || grid[r][c] != 1) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgrid[r][c] = 2;\\n\\t\\t\\t\\t\\tqueue.add(new int[] { r, c });\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn fresh == 0 ? level - 1 : -1;\\n\\t}\\n\\n\\tprivate int init(int[][] grid, Queue<int[]> queue) {\\n\\t\\tint c = 0;\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < grid[i].length; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 2) {\\n\\t\\t\\t\\t\\tqueue.add(new int[] { i, j });\\n\\t\\t\\t\\t} else if (grid[i][j] == 1) {\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn c;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\n    public int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        init(grid,queue);\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int level=0;\\n        int[][] dirs={{-1,0},{1,0},{0,-1},{0,1}};\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            level++;\\n            while(size-->0) {\\n                int[] rc = queue.poll();\\n                for(int[] dir:dirs) {\\n                    int r=rc[0]+dir[0];\\n                    int c=rc[1]+dir[1];\\n                    if(r<0||c<0||r>=m||c>=n||grid[r][c]!=1) {\\n                        continue;\\n                    }\\n                    grid[r][c]=2;\\n                    queue.add(new int[]{r,c});\\n                    \\n                }\\n            }\\n        }\\n\\t\\t//check if 1 still exists\\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                if(grid[i][j]==1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        return level==0?0:level-1;\\n    }\\n    \\n    private void init(int[][] grid,Queue<int[]> queue) {\\n        \\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                if(grid[i][j]==2) {\\n                    queue.add(new int[]{i,j});\\n                }\\n            }\\n        }\\n        \\n    }\\n```\n```\\npublic int orangesRotting(int[][] grid) {\\n\\t\\tQueue<int[]> queue = new LinkedList<>();\\n\\t\\tint fresh = init(grid, queue);\\n\\t\\tif (fresh == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint m = grid.length;\\n\\t\\tint n = grid[0].length;\\n\\t\\tint level = 0;\\n\\t\\tint[][] dirs = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tlevel++;\\n\\t\\t\\twhile (size-- > 0) {\\n\\t\\t\\t\\tint[] rc = queue.poll();\\n\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\tint r = rc[0] + dir[0];\\n\\t\\t\\t\\t\\tint c = rc[1] + dir[1];\\n\\t\\t\\t\\t\\tif (r < 0 || c < 0 || r >= m || c >= n || grid[r][c] != 1) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgrid[r][c] = 2;\\n\\t\\t\\t\\t\\tqueue.add(new int[] { r, c });\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn fresh == 0 ? level - 1 : -1;\\n\\t}\\n\\n\\tprivate int init(int[][] grid, Queue<int[]> queue) {\\n\\t\\tint c = 0;\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < grid[i].length; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 2) {\\n\\t\\t\\t\\t\\tqueue.add(new int[] { i, j });\\n\\t\\t\\t\\t} else if (grid[i][j] == 1) {\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn c;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2778560,
                "title": "java-bfs-a-bit-oop-clean",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n\\n        Queue<Orange> q = new LinkedList<>();\\n        int[][] visited = new int[m][n];\\n\\n        int fresh = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 2) {\\n                    q.offer(new Orange(i, j, 0));\\n                    visited[i][j] = 2;\\n                }\\n\\n                if (grid[i][j] == 1) fresh++;\\n            }\\n        }\\n\\n        int time = 0;\\n        int spoiled = 0;\\n\\n        int[] rowDir = {1, -1, 0, 0};\\n        int[] colDir = {0, 0, 1, -1};\\n\\n        while (!q.isEmpty()) {\\n            Orange o = q.poll();\\n            int r = o.row;\\n            int c = o.col;\\n            int t = o.time;\\n\\n            time = Math.max(time, t);\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nRow = r + rowDir[i];\\n                int nCol = c + colDir[i];\\n\\n                if (nRow >= 0 && nRow < m && nCol >= 0 && nCol < n &&\\n                    visited[nRow][nCol] != 2 && grid[nRow][nCol] == 1) {\\n                    q.offer(new Orange(nRow, nCol, t + 1));\\n                    visited[nRow][nCol] = 2;\\n                    spoiled++;\\n                }\\n            }\\n\\n        }\\n\\n        return spoiled == fresh ? time : -1;\\n    }\\n\\n    class Orange {\\n        int row;\\n        int col;\\n        int time;\\n\\n        public Orange(int row, int col, int time) {\\n            this.row = row;\\n            this.col = col;\\n            this.time = time;\\n        }\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n\\n        Queue<Orange> q = new LinkedList<>();\\n        int[][] visited = new int[m][n];\\n\\n        int fresh = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 2) {\\n                    q.offer(new Orange(i, j, 0));\\n                    visited[i][j] = 2;\\n                }\\n\\n                if (grid[i][j] == 1) fresh++;\\n            }\\n        }\\n\\n        int time = 0;\\n        int spoiled = 0;\\n\\n        int[] rowDir = {1, -1, 0, 0};\\n        int[] colDir = {0, 0, 1, -1};\\n\\n        while (!q.isEmpty()) {\\n            Orange o = q.poll();\\n            int r = o.row;\\n            int c = o.col;\\n            int t = o.time;\\n\\n            time = Math.max(time, t);\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nRow = r + rowDir[i];\\n                int nCol = c + colDir[i];\\n\\n                if (nRow >= 0 && nRow < m && nCol >= 0 && nCol < n &&\\n                    visited[nRow][nCol] != 2 && grid[nRow][nCol] == 1) {\\n                    q.offer(new Orange(nRow, nCol, t + 1));\\n                    visited[nRow][nCol] = 2;\\n                    spoiled++;\\n                }\\n            }\\n\\n        }\\n\\n        return spoiled == fresh ? time : -1;\\n    }\\n\\n    class Orange {\\n        int row;\\n        int col;\\n        int time;\\n\\n        public Orange(int row, int col, int time) {\\n            this.row = row;\\n            this.col = col;\\n            this.time = time;\\n        }\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755528,
                "title": "java-easy-and-fast-explained-dfs-solution-100-97-fastest",
                "content": "It is not difficult to come up with a solution using **DFS** for the cases specified in the description of the problem. The point is that we start with an element with a value of 2 and go up, down, left, and right, changing the value to a negative minute value in `nextMin`. We store the value in an array `memo` so that our number of minutes has a reference.\\n\\n**BUT!** The difficulty is that, for example, ***there will be a rotten orange on the top left and bottom right, and they are combined with fresh ones***. In this case, there is a risk of calculating the maximum value once, giving 4 and forgetting, but this is not true! We have to return not 4, but 2, because the rot comes from two sides.\\nTherefore, when we return to the orange with a value of 2, and look up, down, left and right - we need to pay attention so that the value of minutes is greater than what we plan to set. If so, we set the updated, smaller value.\\n\\n*Then we will first write 1, 2, 3, 4, and then rewrite it to 1, 2, 2, 1. Number of minutes: 2.* We do not change old values that are only minutes or less, so there will be no unnecessary actions.\\n\\n```\\nclass Solution {\\n    public static int orangesRotting(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 2) dfs(grid, i, j, -1, new int[1]);\\n            }\\n        }\\n\\n        int maxMinutes = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                int elem = grid[i][j];\\n                if (elem == 1) return -1;\\n                else if (elem < 0) maxMinutes = Math.min(elem, maxMinutes);\\n            }\\n        }\\n\\n        return maxMinutes == 0 ? 0 : -maxMinutes - 1;\\n    }\\n\\n    private static int dfs(int[][] grid, int i, int j, int nextMin, int[] memo) {\\n        grid[i][j] = nextMin; // rotten-stepped\\n        if (memo[0] > nextMin) memo[0] = nextMin;\\n\\n        nextMin--;\\n        if (i < grid.length - 1 && (grid[i + 1][j] == 1 || grid[i + 1][j] < nextMin))\\n            dfs(grid, i + 1, j, nextMin, memo);\\n\\n        if (i > 0 && (grid[i - 1][j] == 1 || grid[i - 1][j] < nextMin))\\n            dfs(grid, i - 1, j, nextMin, memo);\\n\\n        if (j < grid[i].length - 1 && (grid[i][j + 1] == 1 || grid[i][j + 1] < nextMin))\\n            dfs(grid, i, j + 1, nextMin, memo);\\n\\n        if (j > 0 && (grid[i][j - 1] == 1 || grid[i][j - 1] < nextMin))\\n            dfs(grid, i, j - 1, nextMin, memo);\\n\\n        return memo[0];\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/0f84a950-ca45-4866-ace8-1e850a152b50_1667041210.8465068.png)\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public static int orangesRotting(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 2) dfs(grid, i, j, -1, new int[1]);\\n            }\\n        }\\n\\n        int maxMinutes = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                int elem = grid[i][j];\\n                if (elem == 1) return -1;\\n                else if (elem < 0) maxMinutes = Math.min(elem, maxMinutes);\\n            }\\n        }\\n\\n        return maxMinutes == 0 ? 0 : -maxMinutes - 1;\\n    }\\n\\n    private static int dfs(int[][] grid, int i, int j, int nextMin, int[] memo) {\\n        grid[i][j] = nextMin; // rotten-stepped\\n        if (memo[0] > nextMin) memo[0] = nextMin;\\n\\n        nextMin--;\\n        if (i < grid.length - 1 && (grid[i + 1][j] == 1 || grid[i + 1][j] < nextMin))\\n            dfs(grid, i + 1, j, nextMin, memo);\\n\\n        if (i > 0 && (grid[i - 1][j] == 1 || grid[i - 1][j] < nextMin))\\n            dfs(grid, i - 1, j, nextMin, memo);\\n\\n        if (j < grid[i].length - 1 && (grid[i][j + 1] == 1 || grid[i][j + 1] < nextMin))\\n            dfs(grid, i, j + 1, nextMin, memo);\\n\\n        if (j > 0 && (grid[i][j - 1] == 1 || grid[i][j - 1] < nextMin))\\n            dfs(grid, i, j - 1, nextMin, memo);\\n\\n        return memo[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720672,
                "title": "fully-xplained-python-code",
                "content": "```\\nfrom collections import deque\\n\\n# Time complexity: O(rows * cols) -> each cell is visited at least once\\n# Space complexity: O(rows * cols) -> in the worst case if all the oranges are rotten they will be added to the queue\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # number of rows\\n        rows = len(grid)\\n        if rows == 0:  # check if grid is empty\\n            return -1\\n        \\n        # number of columns\\n        cols = len(grid[0])\\n        \\n        # keep track of fresh oranges\\n        fresh_cnt = 0\\n        \\n        # queue with rotten oranges (for BFS)\\n        rotten = deque()\\n        \\n        # visit each cell in the grid\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    # add the rotten orange coordinates to the queue\\n                    rotten.append((r, c))\\n                elif grid[r][c] == 1:\\n                    # update fresh oranges count\\n                    fresh_cnt += 1\\n        \\n        # keep track of minutes passed.\\n        minutes_passed = 0\\n        \\n        # If there are rotten oranges in the queue and there are still fresh oranges in the grid keep looping\\n        while rotten and fresh_cnt > 0:\\n\\n            # update the number of minutes passed\\n            # it is safe to update the minutes by 1, since we visit oranges level by level in BFS traversal.\\n            minutes_passed += 1\\n            \\n            # process rotten oranges on the current level\\n            for _ in range(len(rotten)):\\n                x, y = rotten.popleft()\\n                \\n                # visit all the adjacent cells\\n                for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    # calculate the coordinates of the adjacent cell\\n                    xx, yy = x + dx, y + dy\\n                    # ignore the cell if it is out of the grid boundary\\n                    if xx < 0 or xx == rows or yy < 0 or yy == cols:\\n                        continue\\n                    # ignore the cell if it is empty \\'0\\' or visited before \\'2\\'\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # update the fresh oranges count\\n                    fresh_cnt -= 1\\n                    \\n                    # mark the current fresh orange as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # add the current rotten to the queue\\n                    rotten.append((xx, yy))\\n\\n        \\n        # return the number of minutes taken to make all the fresh oranges to be rotten\\n        # return -1 if there are fresh oranges left in the grid (there were no adjacent rotten oranges to make them rotten)\\n        return minutes_passed if fresh_cnt == 0 else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque\\n\\n# Time complexity: O(rows * cols) -> each cell is visited at least once\\n# Space complexity: O(rows * cols) -> in the worst case if all the oranges are rotten they will be added to the queue\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # number of rows\\n        rows = len(grid)\\n        if rows == 0:  # check if grid is empty\\n            return -1\\n        \\n        # number of columns\\n        cols = len(grid[0])\\n        \\n        # keep track of fresh oranges\\n        fresh_cnt = 0\\n        \\n        # queue with rotten oranges (for BFS)\\n        rotten = deque()\\n        \\n        # visit each cell in the grid\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    # add the rotten orange coordinates to the queue\\n                    rotten.append((r, c))\\n                elif grid[r][c] == 1:\\n                    # update fresh oranges count\\n                    fresh_cnt += 1\\n        \\n        # keep track of minutes passed.\\n        minutes_passed = 0\\n        \\n        # If there are rotten oranges in the queue and there are still fresh oranges in the grid keep looping\\n        while rotten and fresh_cnt > 0:\\n\\n            # update the number of minutes passed\\n            # it is safe to update the minutes by 1, since we visit oranges level by level in BFS traversal.\\n            minutes_passed += 1\\n            \\n            # process rotten oranges on the current level\\n            for _ in range(len(rotten)):\\n                x, y = rotten.popleft()\\n                \\n                # visit all the adjacent cells\\n                for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    # calculate the coordinates of the adjacent cell\\n                    xx, yy = x + dx, y + dy\\n                    # ignore the cell if it is out of the grid boundary\\n                    if xx < 0 or xx == rows or yy < 0 or yy == cols:\\n                        continue\\n                    # ignore the cell if it is empty \\'0\\' or visited before \\'2\\'\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # update the fresh oranges count\\n                    fresh_cnt -= 1\\n                    \\n                    # mark the current fresh orange as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # add the current rotten to the queue\\n                    rotten.append((xx, yy))\\n\\n        \\n        # return the number of minutes taken to make all the fresh oranges to be rotten\\n        # return -1 if there are fresh oranges left in the grid (there were no adjacent rotten oranges to make them rotten)\\n        return minutes_passed if fresh_cnt == 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666987,
                "title": "java-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int time = 0;\\n        int[][] visited = new int[n][m];\\n        Queue<int[]> q = new LinkedList<int[]>();\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] == 2 && visited[i][j] == 0) {\\n                    q.add(new int[]{i,j});\\n                }\\n                  \\n            }\\n        }\\n        time = bfs(grid, visited, q);\\n        for(int i=0; i<n; i++) {\\n                    for(int j=0; j<m; j++) {\\n                        if(grid[i][j] == 1 ) {\\n                         return -1;\\n                        }\\n                       \\n                    }\\n                }\\n\\n        return Math.max(time-1, 0);\\n    }\\n\\n    public int bfs(int[][] grid, int[][] visited, Queue<int[]> q) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int count = 0;\\n        int[][] dir = {{-1,0}, {0,-1}, {1,0}, {0,1}};\\n\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            count++;\\n            while(size-- >0) {\\n            int[] temp = q.poll();\\n            visited[temp[0]][temp[1]] = 1;\\n            for(int[] k: dir) {\\n                int x = temp[0]+k[0];\\n                int y = temp[1]+k[1];\\n                if(x>=0 && x<n && y>=0 && y<m && visited[x][y] == 0 && grid[x][y] == 1) {\\n                    grid[x][y] = 2;\\n                    q.add(new int[]{x,y});\\n                }\\n            }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int time = 0;\\n        int[][] visited = new int[n][m];\\n        Queue<int[]> q = new LinkedList<int[]>();\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] == 2 && visited[i][j] == 0) {\\n                    q.add(new int[]{i,j});\\n                }\\n                  \\n            }\\n        }\\n        time = bfs(grid, visited, q);\\n        for(int i=0; i<n; i++) {\\n                    for(int j=0; j<m; j++) {\\n                        if(grid[i][j] == 1 ) {\\n                         return -1;\\n                        }\\n                       \\n                    }\\n                }\\n\\n        return Math.max(time-1, 0);\\n    }\\n\\n    public int bfs(int[][] grid, int[][] visited, Queue<int[]> q) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int count = 0;\\n        int[][] dir = {{-1,0}, {0,-1}, {1,0}, {0,1}};\\n\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            count++;\\n            while(size-- >0) {\\n            int[] temp = q.poll();\\n            visited[temp[0]][temp[1]] = 1;\\n            for(int[] k: dir) {\\n                int x = temp[0]+k[0];\\n                int y = temp[1]+k[1];\\n                if(x>=0 && x<n && y>=0 && y<m && visited[x][y] == 0 && grid[x][y] == 1) {\\n                    grid[x][y] = 2;\\n                    q.add(new int[]{x,y});\\n                }\\n            }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423956,
                "title": "simple-c-explanation-using-bfs-traversal-striver-explanation",
                "content": "int orangesRotting(vector<vector<int>> &grid)\\n{\\n    queue<pair<pair<int, int>, int>> q;\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int cnt=0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < m; j++)\\n        {\\n            if (grid[i][j] == 2)\\n                q.push({{i, j}, 0});\\n            else if (grid[i][j] == 1)\\n                cnt++;\\n        }\\n    }\\n    if(cnt==0)\\n    return 0;\\n        \\n    int time = 0;\\n    while (q.size())\\n    {\\n        pair<int, int> idx = q.front().first;\\n        int x = idx.first;\\n        int y = idx.second;\\n            time = q.front().second;\\n        q.pop();\\n        if (x - 1 >= 0 && grid[x - 1][y] == 1)\\n        { // left\\n            grid[x - 1][y] = 2;\\n            q.push({{x - 1, y}, time + 1});\\n            cnt--;\\n        }\\n        if (x + 1 < n && grid[x + 1][y] == 1)\\n        { // right\\n            grid[x + 1][y] = 2;\\n            q.push({{x + 1, y}, time + 1});\\n            cnt--;\\n        }\\n        if (y - 1 >= 0 && grid[x][y-1] == 1)\\n        { // bottom\\n            grid[x][y-1] = 2;\\n            q.push({{x, y-1}, time + 1});cnt--;\\n        }\\n        if (y+ 1 < m && grid[x][y+1] == 1)\\n        { // top\\n            grid[x][y+1] = 2;\\n            q.push({{x, y+1}, time + 1});cnt--;\\n        }\\n    }\\n    return (cnt==0)?time:-1;\\n}",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "int orangesRotting(vector<vector<int>> &grid)\\n{\\n    queue<pair<pair<int, int>, int>> q;\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int cnt=0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < m; j++)\\n        {\\n            if (grid[i][j] == 2)\\n                q.push({{i, j}, 0});\\n            else if (grid[i][j] == 1)\\n                cnt++;\\n        }\\n    }\\n    if(cnt==0)\\n    return 0;\\n        \\n    int time = 0;\\n    while (q.size())\\n    {\\n        pair<int, int> idx = q.front().first;\\n        int x = idx.first;\\n        int y = idx.second;\\n            time = q.front().second;\\n        q.pop();\\n        if (x - 1 >= 0 && grid[x - 1][y] == 1)\\n        { // left\\n            grid[x - 1][y] = 2;\\n            q.push({{x - 1, y}, time + 1});\\n            cnt--;\\n        }\\n        if (x + 1 < n && grid[x + 1][y] == 1)\\n        { // right\\n            grid[x + 1][y] = 2;\\n            q.push({{x + 1, y}, time + 1});\\n            cnt--;\\n        }\\n        if (y - 1 >= 0 && grid[x][y-1] == 1)\\n        { // bottom\\n            grid[x][y-1] = 2;\\n            q.push({{x, y-1}, time + 1});cnt--;\\n        }\\n        if (y+ 1 < m && grid[x][y+1] == 1)\\n        { // top\\n            grid[x][y+1] = 2;\\n            q.push({{x, y+1}, time + 1});cnt--;\\n        }\\n    }\\n    return (cnt==0)?time:-1;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2321090,
                "title": "line-to-line-explaination-bfs-easy-java-code",
                "content": "class Solution {\\n\\n    public int orangesRotting(int[][] grid) {\\n        \\n        if(grid.length == 0)\\n            return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        Queue<int[]> q = new LinkedList<>();        //to store the rotten oranges of the grid\\n        int TotalOranges=0;                         //to get count of total oranges (rotten + Fresh)\\n        \\n        for(int i=0;i<row;i++){                     //to traverse row\\n            for(int j=0;j<col;j++){                 //to traverse each column\\n                \\n                if(grid[i][j] == 2){                //if that orange is rotten, store it into the queue\\n                    q.add(new int[]{i,j});\\n                }\\n                \\n                if(grid[i][j]!=0)                   //if that cell is not empty, then definitly have rotten or fresh orange\\n                    TotalOranges++;                 //count increase by 1\\n                \\n            }\\n        }\\n        \\n        if(TotalOranges==0) return 0;               //if there is no orange in grid, then there is no need to count how much time require!\\n        \\n        //bfs\\n        int min=0, rottedOranges=0;                 \\n        int[] xAxis = {0,0,-1,1};                   // xAxis and yAxis array are use to move in adjacent cells that are one step up, down, left and right\\n        int[] yAxis = {-1,1,0,0};                   // when the xAxis value is 0 and yAxis value is -1 then it means we move one step towards left\\n        \\n        while(!q.isEmpty()){                        //while queue is not empty\\n            int rottenSize = q.size();              //size of queue gives us the idea of rotten oranges(fresh conv. into rotten oranges, add into the queue)\\n            rottedOranges += q.size();              //so how much amount of rotten oranges are present (or added into) the queue, keep count of it.\\n            \\n            while(rottenSize>0){                    //in each pass we pop all the rotten oranges currently present in the queue & make adjacent fresh into\\n                int[] rotten = q.poll();            //rotten and add into the queue in this while loop\\n                for(int i=0; i<4; i++){             //According to problem statement, we to move one step in each directiom(up,down,left,right)\\n                    int x = rotten[0] + xAxis[i];   //on whatever cell we are just add the xAxis & yAxis accordinly in row & col to move in all 4 direction\\n                    int y = rotten[1] + yAxis[i];\\n\\n                    if(x<0 || x>=row || y<0 || y>=col || grid[x][y] == 0 || grid[x][y] == 2)        //Our boundary Condition, if we come out from the grid\\n                        continue;\\n\\n                    grid[x][y] = 2;             //mark that orange as rotten\\n                    q.add(new int[]{x,y});      //add into the queue\\n\\n                }\\n                rottenSize--;                   //decrease the size of rottenOranges in the queue, because one is popped out from the queue\\n            }\\n            \\n            min++;                              //after each pass increase a minute\\n        }\\n        \\n        return (rottedOranges==TotalOranges )? min-1:-1;            //if rottedOranges are equal to TotalOranges then it means no fresh orange left, so return min else -1\\n        \\n    }\\n}\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\n    public int orangesRotting(int[][] grid) {\\n        \\n        if(grid.length == 0)\\n            return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        Queue<int[]> q = new LinkedList<>();        //to store the rotten oranges of the grid\\n        int TotalOranges=0;                         //to get count of total oranges (rotten + Fresh)\\n        \\n        for(int i=0;i<row;i++){                     //to traverse row\\n            for(int j=0;j<col;j++){                 //to traverse each column\\n                \\n                if(grid[i][j] == 2){                //if that orange is rotten, store it into the queue\\n                    q.add(new int[]{i,j}",
                "codeTag": "Java"
            },
            {
                "id": 2082234,
                "title": "simple-bfs-solution-in-cpp-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n\\t\\tint x[] = {-1, 1, 0, 0};\\n        int y[] = {0, 0, -1, 1};\\n        queue<pair<int, int>>q;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 2)q.push({i, j});         //pushing all the (possibilities where we need to start)\\n            }\\n        }\\n        int ans = 0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            int flag = 0;\\n            while(n--){                  //all rotted oranges will spoil near by oranges which is fresh in unit time \\n                auto curr = q.front();\\n                q.pop();\\n                for(int i = 0; i < 4; i++){\\n                    int new_x = curr.first + x[i];\\n                    int new_y = curr.second + y[i];\\n                    if(new_x >= 0 and new_x < grid.size() and new_y >= 0 and new_y < grid[0].size() and grid[new_x][new_y] == 1){\\n                        q.push({new_x, new_y});\\n                        grid[new_x][new_y] = 2;\\n                        flag = 1;           //for checking that we rotted or not\\n                    }\\n                }\\n            }\\n            if(flag == 1)ans++;         //if we go from 2 to 1, then it is unit time (how many doesn\\'t matter) thats y we keep flag above\\n        }\\n        for(int i = 0; i < grid.size(); i++){         //checking for unrotten oranges which can\\'t be reached\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 1)return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n***For Advanced DSA Solutions refer to README file***\\nhttps://github.com/teja963/Advanced-DSA\\n***Find Helpful Upvote it***\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n\\t\\tint x[] = {-1, 1, 0, 0};\\n        int y[] = {0, 0, -1, 1};\\n        queue<pair<int, int>>q;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 2)q.push({i, j});         //pushing all the (possibilities where we need to start)\\n            }\\n        }\\n        int ans = 0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            int flag = 0;\\n            while(n--){                  //all rotted oranges will spoil near by oranges which is fresh in unit time \\n                auto curr = q.front();\\n                q.pop();\\n                for(int i = 0; i < 4; i++){\\n                    int new_x = curr.first + x[i];\\n                    int new_y = curr.second + y[i];\\n                    if(new_x >= 0 and new_x < grid.size() and new_y >= 0 and new_y < grid[0].size() and grid[new_x][new_y] == 1){\\n                        q.push({new_x, new_y});\\n                        grid[new_x][new_y] = 2;\\n                        flag = 1;           //for checking that we rotted or not\\n                    }\\n                }\\n            }\\n            if(flag == 1)ans++;         //if we go from 2 to 1, then it is unit time (how many doesn\\'t matter) thats y we keep flag above\\n        }\\n        for(int i = 0; i < grid.size(); i++){         //checking for unrotten oranges which can\\'t be reached\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 1)return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786056,
                "title": "python-3-70ms-bfs-solution",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visit, curr = set(), deque()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 2:\\n                    curr.append((i, j))\\n        result = 0\\n        while visit and curr:\\n            for _ in range(len(curr)):\\n                i, j = curr.popleft()\\n                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                    if coord in visit:\\n                        visit.remove(coord)\\n                        curr.append(coord)\\n            result += 1\\n        return -1 if visit else result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visit, curr = set(), deque()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 2:\\n                    curr.append((i, j))\\n        result = 0\\n        while visit and curr:\\n            for _ in range(len(curr)):\\n                i, j = curr.popleft()\\n                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                    if coord in visit:\\n                        visit.remove(coord)\\n                        curr.append(coord)\\n            result += 1\\n        return -1 if visit else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780023,
                "title": "easy-c-solution-using-bfs-explained-with-comments-t-c-o-m-n",
                "content": "**Please upvote if it helped you : ) !!!\\n*Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& mat) {\\n        int m=mat[0].size();\\n        int n=mat.size();\\n        int tot=0;\\n        \\n       queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]!=0){tot++;}    // maintaining count of number of total oranges\\n                if(mat[i][j]==2)\\n                {\\n                    q.push({i,j}); // pushing rotten oranges inside queue for out approach\\n                }\\n            }\\n        }\\n        int cn=0;\\n        \\n        int dir[4][2] = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } }; // directions \\n        int days=0;\\n        \\n        while(q.empty()==false)\\n        {\\n            int si=q.size(); // looping till its size\\n            \\n            cn+=si; // updating all rotten oranges\\n            while(si--)\\n            {\\n                auto it=q.front();\\n                q.pop();\\n                int r=it.first;\\n                int c=it.second;\\n                // getting row and col of rotten oranges \\n                \\n                for(int i=0;i<4;i++)  // iterating in all 4 directions \\n                {\\n                    int fir=r+dir[i][0];\\n                    int sec=c+dir[i][1];\\n                        \\n                    // Boundary condition checks\\n                    \\n                    if(fir>=0 and fir<n and sec<m and sec>=0 and mat[fir][sec]==1)\\n                    {\\n                        mat[fir][sec]=2;\\n                        q.push({fir,sec});\\n                    }\\n                }\\n            }\\n            if(!q.empty()){\\n                \\n                 days++;            // if size of queue is greater than 0 it means that \\n                                    // it still has some oranges to be processed\\n            } \\n        }     \\n     \\n        if(cn!=tot) // if not then it means we have still some oranges left\\n        {\\n            return -1;\\n        }\\n            \\n        return days;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& mat) {\\n        int m=mat[0].size();\\n        int n=mat.size();\\n        int tot=0;\\n        \\n       queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]!=0){tot++;}    // maintaining count of number of total oranges\\n                if(mat[i][j]==2)\\n                {\\n                    q.push({i,j}); // pushing rotten oranges inside queue for out approach\\n                }\\n            }\\n        }\\n        int cn=0;\\n        \\n        int dir[4][2] = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } }; // directions \\n        int days=0;\\n        \\n        while(q.empty()==false)\\n        {\\n            int si=q.size(); // looping till its size\\n            \\n            cn+=si; // updating all rotten oranges\\n            while(si--)\\n            {\\n                auto it=q.front();\\n                q.pop();\\n                int r=it.first;\\n                int c=it.second;\\n                // getting row and col of rotten oranges \\n                \\n                for(int i=0;i<4;i++)  // iterating in all 4 directions \\n                {\\n                    int fir=r+dir[i][0];\\n                    int sec=c+dir[i][1];\\n                        \\n                    // Boundary condition checks\\n                    \\n                    if(fir>=0 and fir<n and sec<m and sec>=0 and mat[fir][sec]==1)\\n                    {\\n                        mat[fir][sec]=2;\\n                        q.push({fir,sec});\\n                    }\\n                }\\n            }\\n            if(!q.empty()){\\n                \\n                 days++;            // if size of queue is greater than 0 it means that \\n                                    // it still has some oranges to be processed\\n            } \\n        }     \\n     \\n        if(cn!=tot) // if not then it means we have still some oranges left\\n        {\\n            return -1;\\n        }\\n            \\n        return days;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546770,
                "title": "3-different-ways-recursion-iterative-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n**1. Iterative**\\n\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {  \\n        var EMPTY = 0;\\n        var FRESH = 1;\\n        var ROTTEN = 2;\\n        \\n        var elapsed = 0;\\n        var freshCount = 0;\\n        var queue = new Queue<KeyValuePair<int, int>>();\\n        \\n        // Get fresh cell count and rotten cell coordinates\\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                if (grid[row][col] == FRESH) {\\n                    ++freshCount;\\n                } else if (grid[row][col] == ROTTEN) {\\n                    queue.Enqueue(new KeyValuePair<int, int>(row, col));\\n                }                \\n            }          \\n        }\\n        \\n        // Search directions\\n        var directions = new List<KeyValuePair<int, int>>() {\\n            // Right\\n            new KeyValuePair<int, int>(0, 1),\\n            // Left\\n            new KeyValuePair<int, int>(0, -1),\\n            // Top\\n            new KeyValuePair<int, int>(-1, 0),\\n            // Bottom\\n            new KeyValuePair<int, int>(1, 0),\\n        };\\n        \\n        // Look for fresh cells to turn rotten\\t\\t\\n        while (queue.Count > 0) {            \\n            for (int itemCount = queue.Count; itemCount > 0; --itemCount) {\\n                var current = queue.Peek();\\n                queue.Dequeue();\\n                \\n                // Get the coordinates of the rotten cell\\n                var row = current.Key;\\n                var col = current.Value;\\n                \\n                // Search right, left, top, bottom to see if a fresh cell can become rotton\\n                foreach (var direction in directions) {\\n                    var newRow = row + direction.Key;\\n                    var newCol = col + direction.Value;\\n                    \\n                    // If the cell is fresh in this direction, make it rotten\\n                    if (IsValidCell(grid, newRow, newCol) && grid[newRow][newCol] == FRESH) {\\n                        grid[newRow][newCol] = ROTTEN;\\n                        queue.Enqueue(new KeyValuePair<int, int>(newRow, newCol));\\n                        --freshCount;                        \\n                    }\\n                }       \\n            }\\n            \\n            // Increment elapsed time\\n            if (queue.Count > 0) {\\n                ++elapsed;\\n            }\\n        }\\n        \\n        return freshCount > 0 ? -1 : elapsed;\\n    }\\n    \\n    private bool IsValidCell(int[][] grid, int row, int col) {\\n        return row >= 0 && row < grid.Length && col >= 0 && col < grid[row].Length;\\n    }\\n}\\n```\\n\\nThe following are 2 different solutions using recursion.\\n\\nThe general idea for both solutions are the same. For any given fresh orange, we try to compute the shortest path to a rotten orange (as this would be the one responsible for rotting the orange in question in the minimum time steps, before any other rotten orange). \\n\\nWe compute the max of all these shortest paths to rot all the fresh oranges.\\n\\n**2. Keeping Track Rows Visited**\\n\\nIn this solution, we compute the max of all these shortest paths from a fresh to a rotten cell\\n\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {    \\n        var result = 0;\\n        \\n        // 2D array to keep track of paths visited\\n        var visited = new bool[grid.Length][];\\n        for (int row = 0; row < grid.Length; ++row) {\\n            visited[row] = new bool[grid[row].Length];\\n        } \\n        \\n        // The Answer is the max of all shortest distances to a rotten cell\\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell is fresh, get distance to rotten\\n                if (grid[row][col] == 1) {\\n                    result = Math.Max(result, ShortestPath(grid, row, col, 0, visited));\\n                }                \\n            }          \\n        }        \\n        return result == int.MaxValue ? -1 : result;\\n    }\\n    \\n    // Compute shortest distance to a rotten cell\\n    private int ShortestPath(int[][] grid, int row, int col, int depth, bool[][] visited) {\\n        // Make sure parameters are in bounds\\n        if (row < 0 || row >= grid.Length || col < 0 || col >= grid[row].Length) {\\n            return int.MaxValue;\\n        }    \\n                    \\n        // Cell is rotten\\n        if (grid[row][col] == 2) {\\n            return depth;\\n        }\\n        \\n        // Path been visited\\n        if (visited[row][col]) {\\n            return int.MaxValue;\\n        }       \\n        \\n        var distance = int.MaxValue;\\n        \\n        // Set path as visited\\n        visited[row][col] = true;\\n        \\n        // Cell is fresh, keep searching\\n        if (grid[row][col] == 1) {\\n            // Search right\\n            distance = Math.Min(distance, ShortestPath(grid, row, col + 1, depth + 1, visited));\\n\\n            // Search left\\n            distance = Math.Min(distance, ShortestPath(grid, row, col - 1, depth + 1, visited)); \\n\\n            // Search top\\n            distance = Math.Min(distance, ShortestPath(grid, row + 1, col, depth + 1, visited));\\n\\n            // Search bottom\\n            distance = Math.Min(distance, ShortestPath(grid, row - 1, col, depth + 1, visited)); \\n        }\\n        \\n        // Set path as un visited\\n        visited[row][col] = false;\\n        \\n        return distance;\\n    }\\n}\\n```\\n\\n**3. Timestamp Difference**\\n\\nIn this solution, we set a timestamp when a fresh cell becomes rotten, and use that to compute the result\\n\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {    \\n        // Set a value other than 0,1,2 as the initial timestamp offset\\n        // when a cell becomes rotten\\n        var offset = 1987;\\n        \\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell is rotten, try to infect fresh cells\\n                if (grid[row][col] == 2) {\\n                    grid[row][col] = offset;\\n                    Search(grid, row, col, offset);\\n                }                \\n            }          \\n        }\\n        \\n        var result = 0;        \\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell was unable to be turned rotten\\n                if (grid[row][col] == 1) {\\n                    return -1;\\n                }\\n                // Get the timestamp when this cell became rotten, minus offset\\n                result = Math.Max(result, grid[row][col] - offset);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void Search(int[][] grid, int row, int col, int timestamp) {\\n        // Make sure parameters are in bounds\\n        if (row < 0 || row >= grid.Length || col < 0 || col >= grid[row].Length) {\\n            return;\\n        }       \\n        \\n        // Cell is empty\\n        if (grid[row][col] == 0) {\\n            return;\\n        }     \\n        \\n        // Cell is already rotten\\n        if (grid[row][col] == 2) {\\n            return;\\n        }         \\n        \\n        // Cell was made rotten by another rotten cell\\n        if (grid[row][col] > 2 && grid[row][col] < timestamp) {         \\n            return;\\n        }\\n        \\n        // Set the timestamp when this cell becomes rotten\\n        grid[row][col] = timestamp;\\n                \\n        // Search right\\n        Search(grid, row, col + 1, timestamp + 1);\\n        \\n        // Search left\\n        Search(grid, row, col - 1, timestamp + 1); \\n        \\n        // Search top\\n        Search(grid, row + 1, col, timestamp + 1);\\n        \\n        // Search bottom\\n        Search(grid, row - 1, col, timestamp + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {  \\n        var EMPTY = 0;\\n        var FRESH = 1;\\n        var ROTTEN = 2;\\n        \\n        var elapsed = 0;\\n        var freshCount = 0;\\n        var queue = new Queue<KeyValuePair<int, int>>();\\n        \\n        // Get fresh cell count and rotten cell coordinates\\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                if (grid[row][col] == FRESH) {\\n                    ++freshCount;\\n                } else if (grid[row][col] == ROTTEN) {\\n                    queue.Enqueue(new KeyValuePair<int, int>(row, col));\\n                }                \\n            }          \\n        }\\n        \\n        // Search directions\\n        var directions = new List<KeyValuePair<int, int>>() {\\n            // Right\\n            new KeyValuePair<int, int>(0, 1),\\n            // Left\\n            new KeyValuePair<int, int>(0, -1),\\n            // Top\\n            new KeyValuePair<int, int>(-1, 0),\\n            // Bottom\\n            new KeyValuePair<int, int>(1, 0),\\n        };\\n        \\n        // Look for fresh cells to turn rotten\\t\\t\\n        while (queue.Count > 0) {            \\n            for (int itemCount = queue.Count; itemCount > 0; --itemCount) {\\n                var current = queue.Peek();\\n                queue.Dequeue();\\n                \\n                // Get the coordinates of the rotten cell\\n                var row = current.Key;\\n                var col = current.Value;\\n                \\n                // Search right, left, top, bottom to see if a fresh cell can become rotton\\n                foreach (var direction in directions) {\\n                    var newRow = row + direction.Key;\\n                    var newCol = col + direction.Value;\\n                    \\n                    // If the cell is fresh in this direction, make it rotten\\n                    if (IsValidCell(grid, newRow, newCol) && grid[newRow][newCol] == FRESH) {\\n                        grid[newRow][newCol] = ROTTEN;\\n                        queue.Enqueue(new KeyValuePair<int, int>(newRow, newCol));\\n                        --freshCount;                        \\n                    }\\n                }       \\n            }\\n            \\n            // Increment elapsed time\\n            if (queue.Count > 0) {\\n                ++elapsed;\\n            }\\n        }\\n        \\n        return freshCount > 0 ? -1 : elapsed;\\n    }\\n    \\n    private bool IsValidCell(int[][] grid, int row, int col) {\\n        return row >= 0 && row < grid.Length && col >= 0 && col < grid[row].Length;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {    \\n        var result = 0;\\n        \\n        // 2D array to keep track of paths visited\\n        var visited = new bool[grid.Length][];\\n        for (int row = 0; row < grid.Length; ++row) {\\n            visited[row] = new bool[grid[row].Length];\\n        } \\n        \\n        // The Answer is the max of all shortest distances to a rotten cell\\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell is fresh, get distance to rotten\\n                if (grid[row][col] == 1) {\\n                    result = Math.Max(result, ShortestPath(grid, row, col, 0, visited));\\n                }                \\n            }          \\n        }        \\n        return result == int.MaxValue ? -1 : result;\\n    }\\n    \\n    // Compute shortest distance to a rotten cell\\n    private int ShortestPath(int[][] grid, int row, int col, int depth, bool[][] visited) {\\n        // Make sure parameters are in bounds\\n        if (row < 0 || row >= grid.Length || col < 0 || col >= grid[row].Length) {\\n            return int.MaxValue;\\n        }    \\n                    \\n        // Cell is rotten\\n        if (grid[row][col] == 2) {\\n            return depth;\\n        }\\n        \\n        // Path been visited\\n        if (visited[row][col]) {\\n            return int.MaxValue;\\n        }       \\n        \\n        var distance = int.MaxValue;\\n        \\n        // Set path as visited\\n        visited[row][col] = true;\\n        \\n        // Cell is fresh, keep searching\\n        if (grid[row][col] == 1) {\\n            // Search right\\n            distance = Math.Min(distance, ShortestPath(grid, row, col + 1, depth + 1, visited));\\n\\n            // Search left\\n            distance = Math.Min(distance, ShortestPath(grid, row, col - 1, depth + 1, visited)); \\n\\n            // Search top\\n            distance = Math.Min(distance, ShortestPath(grid, row + 1, col, depth + 1, visited));\\n\\n            // Search bottom\\n            distance = Math.Min(distance, ShortestPath(grid, row - 1, col, depth + 1, visited)); \\n        }\\n        \\n        // Set path as un visited\\n        visited[row][col] = false;\\n        \\n        return distance;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {    \\n        // Set a value other than 0,1,2 as the initial timestamp offset\\n        // when a cell becomes rotten\\n        var offset = 1987;\\n        \\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell is rotten, try to infect fresh cells\\n                if (grid[row][col] == 2) {\\n                    grid[row][col] = offset;\\n                    Search(grid, row, col, offset);\\n                }                \\n            }          \\n        }\\n        \\n        var result = 0;        \\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell was unable to be turned rotten\\n                if (grid[row][col] == 1) {\\n                    return -1;\\n                }\\n                // Get the timestamp when this cell became rotten, minus offset\\n                result = Math.Max(result, grid[row][col] - offset);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void Search(int[][] grid, int row, int col, int timestamp) {\\n        // Make sure parameters are in bounds\\n        if (row < 0 || row >= grid.Length || col < 0 || col >= grid[row].Length) {\\n            return;\\n        }       \\n        \\n        // Cell is empty\\n        if (grid[row][col] == 0) {\\n            return;\\n        }     \\n        \\n        // Cell is already rotten\\n        if (grid[row][col] == 2) {\\n            return;\\n        }         \\n        \\n        // Cell was made rotten by another rotten cell\\n        if (grid[row][col] > 2 && grid[row][col] < timestamp) {         \\n            return;\\n        }\\n        \\n        // Set the timestamp when this cell becomes rotten\\n        grid[row][col] = timestamp;\\n                \\n        // Search right\\n        Search(grid, row, col + 1, timestamp + 1);\\n        \\n        // Search left\\n        Search(grid, row, col - 1, timestamp + 1); \\n        \\n        // Search top\\n        Search(grid, row + 1, col, timestamp + 1);\\n        \\n        // Search bottom\\n        Search(grid, row - 1, col, timestamp + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461265,
                "title": "well-explained-easy-approach-94-faster",
                "content": "## IDEA :\\n\\uD83D\\uDC49*First form the list of all rotten cells with their cell number and time as 0.\\n\\uD83D\\uDC49 Now poping one by one from left of queue of rotten list.\\n\\uD83D\\uDC49 Change this cell to empty and call **Convert** Function to change all the 4-Directional fresh cells(if exists) to empty and also add them in rotten cells. With time extended by 1.\\n\\uD83D\\uDC49 At last you will be with the last minute.\\n\\uD83D\\uDC49 Check if any cell is with fresh orange then return -1 else return the last minute.*\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        m,n,l = len(grid),len(grid[0]),0\\n        rot = []\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==2:\\n                    rot.append([i,j,l])\\n                \\n        def convert(i,j,l):\\n            nonlocal rot\\n            if i<0 or i>=m or j<0 or j>=n or grid[i][j]==0:\\n                return\\n            if grid[i][j]==1:\\n                rot.append([i,j,l+1])\\n                grid[i][j]=0\\n        \\n        while rot:\\n            a,b,l = rot.pop(0)\\n            grid[a][b] = 0\\n            convert(a+1,b,l)\\n            convert(a-1,b,l)\\n            convert(a,b+1,l)\\n            convert(a,b-1,l)    \\n\\n        # Checking any 1 exist in grid\\n\\t\\tfor r in grid:\\n            if 1 in r:\\n                return -1\\n            \\n        return l\\n\\nFeel free to ask if you have any doubts \\uD83E\\uDD17\\nThanks and Upvote if you got any help !! \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "## IDEA :\\n\\uD83D\\uDC49*First form the list of all rotten cells with their cell number and time as 0.\\n\\uD83D\\uDC49 Now poping one by one from left of queue of rotten list.\\n\\uD83D\\uDC49 Change this cell to empty and call **Convert** Function to change all the 4-Directional fresh cells(if exists) to empty and also add them in rotten cells. With time extended by 1.\\n\\uD83D\\uDC49 At last you will be with the last minute.\\n\\uD83D\\uDC49 Check if any cell is with fresh orange then return -1 else return the last minute.*\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        m,n,l = len(grid),len(grid[0]),0\\n        rot = []\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==2:\\n                    rot.append([i,j,l])\\n                \\n        def convert(i,j,l):\\n            nonlocal rot\\n            if i<0 or i>=m or j<0 or j>=n or grid[i][j]==0:\\n                return\\n            if grid[i][j]==1:\\n                rot.append([i,j,l+1])\\n                grid[i][j]=0\\n        \\n        while rot:\\n            a,b,l = rot.pop(0)\\n            grid[a][b] = 0\\n            convert(a+1,b,l)\\n            convert(a-1,b,l)\\n            convert(a,b+1,l)\\n            convert(a,b-1,l)    \\n\\n        # Checking any 1 exist in grid\\n\\t\\tfor r in grid:\\n            if 1 in r:\\n                return -1\\n            \\n        return l\\n\\nFeel free to ask if you have any doubts \\uD83E\\uDD17\\nThanks and Upvote if you got any help !! \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1414614,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int i, int j, int n, int m){\\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\\n        return 1;\\n    }\\n    bool allRotten(vector<vector<int>> &a){\\n        int i,j,n=a.size(),m=a[0].size();\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(a[i][j]==1) return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int orangesRotting(vector<vector<int>>& a) {\\n        int i,j,n=a.size(),m=a[0].size(),timeFrame,x,y;\\n        queue<vector<int>> q;\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(a[i][j]==2){\\n                    q.push({0,i,j});\\n                }\\n            }\\n        }\\n        while(q.size()){\\n            vector<int> v=q.front(); q.pop();\\n            timeFrame=v[0], x=v[1], y=v[2];\\n            if(isSafe(x-1,y,n,m) && a[x-1][y]==1){\\n                a[x-1][y]=2;\\n                q.push({timeFrame+1, x-1, y});\\n            }\\n            if(isSafe(x+1,y,n,m) && a[x+1][y]==1){\\n                a[x+1][y]=2;\\n                q.push({timeFrame+1, x+1, y});\\n            }\\n            if(isSafe(x,y-1,n,m) && a[x][y-1]==1){\\n                a[x][y-1]=2;\\n                q.push({timeFrame+1, x, y-1});\\n            }\\n            if(isSafe(x,y+1,n,m) && a[x][y+1]==1){\\n                a[x][y+1]=2;\\n                q.push({timeFrame+1, x, y+1});\\n            }\\n        }\\n        if(allRotten(a)) return timeFrame;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int i, int j, int n, int m){\\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\\n        return 1;\\n    }\\n    bool allRotten(vector<vector<int>> &a){\\n        int i,j,n=a.size(),m=a[0].size();\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(a[i][j]==1) return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int orangesRotting(vector<vector<int>>& a) {\\n        int i,j,n=a.size(),m=a[0].size(),timeFrame,x,y;\\n        queue<vector<int>> q;\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(a[i][j]==2){\\n                    q.push({0,i,j});\\n                }\\n            }\\n        }\\n        while(q.size()){\\n            vector<int> v=q.front(); q.pop();\\n            timeFrame=v[0], x=v[1], y=v[2];\\n            if(isSafe(x-1,y,n,m) && a[x-1][y]==1){\\n                a[x-1][y]=2;\\n                q.push({timeFrame+1, x-1, y});\\n            }\\n            if(isSafe(x+1,y,n,m) && a[x+1][y]==1){\\n                a[x+1][y]=2;\\n                q.push({timeFrame+1, x+1, y});\\n            }\\n            if(isSafe(x,y-1,n,m) && a[x][y-1]==1){\\n                a[x][y-1]=2;\\n                q.push({timeFrame+1, x, y-1});\\n            }\\n            if(isSafe(x,y+1,n,m) && a[x][y+1]==1){\\n                a[x][y+1]=2;\\n                q.push({timeFrame+1, x, y+1});\\n            }\\n        }\\n        if(allRotten(a)) return timeFrame;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411913,
                "title": "this-is-the-simplest-solution",
                "content": "This is a pretty common problem and gfg gave a very complicated solution! \\n```\\nclass Solution {\\npublic:\\n    \\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0}; \\n    int m , n;\\n    \\n    bool valid(int x , int y, vector<vector<int>>& grid){\\n        return (x>=0 && y>= 0 && x<m && y<n && grid[x][y] == 1) ; \\n    }\\n    \\n    bool check(vector<vector<int>>& grid){\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1)\\n                    return 0;\\n            }\\n        }\\n        return 1; \\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ans = 0 ; m =grid.size() , n = grid[0].size();\\n        queue<pair<int,int>> q; \\n        vector<vector<bool>> visited(m,vector<bool>(n,0)); \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){\\n                    q.push({i,j}); \\n                    visited[i][j] = 1; \\n                }\\n            }\\n        }        \\n        if((q.empty() && check(grid)) || q.size() == m*n)\\n            return 0;\\n        \\n        while(!q.empty()){\\n            int size = q.size(); \\n            for(int i=0;i<size;i++){\\n                auto curr = q.front();\\n                q.pop(); \\n                for(int j=0;j<4;j++){\\n                    int x = curr.first + dx[j] , y = curr.second + dy[j]; \\n                    if(valid(x,y,grid) && !visited[x][y]) {\\n                        grid[x][y] = 2; \\n                        visited[x][y] = 1; \\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            ans++; \\n        }\\n        \\n        return check(grid) ?  ans-1 : -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0}; \\n    int m , n;\\n    \\n    bool valid(int x , int y, vector<vector<int>>& grid){\\n        return (x>=0 && y>= 0 && x<m && y<n && grid[x][y] == 1) ; \\n    }\\n    \\n    bool check(vector<vector<int>>& grid){\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1)\\n                    return 0;\\n            }\\n        }\\n        return 1; \\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ans = 0 ; m =grid.size() , n = grid[0].size();\\n        queue<pair<int,int>> q; \\n        vector<vector<bool>> visited(m,vector<bool>(n,0)); \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){\\n                    q.push({i,j}); \\n                    visited[i][j] = 1; \\n                }\\n            }\\n        }        \\n        if((q.empty() && check(grid)) || q.size() == m*n)\\n            return 0;\\n        \\n        while(!q.empty()){\\n            int size = q.size(); \\n            for(int i=0;i<size;i++){\\n                auto curr = q.front();\\n                q.pop(); \\n                for(int j=0;j<4;j++){\\n                    int x = curr.first + dx[j] , y = curr.second + dy[j]; \\n                    if(valid(x,y,grid) && !visited[x][y]) {\\n                        grid[x][y] = 2; \\n                        visited[x][y] = 1; \\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            ans++; \\n        }\\n        \\n        return check(grid) ?  ans-1 : -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314753,
                "title": "easy-java-solution-t-c-o-n-m-s-c-o-n",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        \\n        Queue<Pair> q = new LinkedList<Pair>();\\n\\t\\t\\n        int r = grid.length;\\n        int c = grid[0].length;\\n\\t\\tint fresh = 0, rotten = 0;\\n\\t\\tfor(int i=0;i<r;i++) {\\n\\t\\t\\t\\n\\t\\t\\tfor(int j=0;j<c;j++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(grid[i][j]==2) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tq.add(new Pair(i,j));\\n\\t\\t\\t\\t\\trotten++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(grid[i][j]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(rotten==0 && fresh>0) {\\n\\t\\t\\t\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n        \\n\\t\\t\\n\\t\\tint time = 0;\\n\\t\\t\\n\\t\\twhile(!q.isEmpty() && fresh>0) {\\n\\t\\t\\t\\n\\t\\t\\ttime++;\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\n\\t\\t\\twhile(size-- >0 && fresh>0) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tPair g = q.peek();\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint x = g.first;\\n\\t\\t\\t\\tint y = g.second;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(isSafe(x-1,y,r,c) && grid[x-1][y]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x-1,y));\\n\\t\\t\\t\\t\\tgrid[x-1][y] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x,y-1,r,c) && grid[x][y-1]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x,y-1));\\n\\t\\t\\t\\t\\tgrid[x][y-1] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x+1,y,r,c) && grid[x+1][y]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x+1,y));\\n\\t\\t\\t\\t\\tgrid[x+1][y] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x,y+1,r,c) && grid[x][y+1]==1) {\\n\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x,y+1));\\n\\t\\t\\t\\t\\tgrid[x][y+1] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\tif(fresh==0) return time;\\n\\t\\treturn -1;\\n    }\\n    boolean isSafe(int x, int y, int r, int c) {\\n\\t\\t\\n\\t\\tif(x>=0 && y>=0 && x<r && y<c) return true;\\n\\t\\treturn false;\\n\\t}\\n}\\n\\nclass Pair{\\n\\t\\n\\tint first;\\n\\tint second;\\n\\t\\n\\tpublic Pair(int first, int second) {\\n\\t\\t\\n\\t\\tthis.first = first;\\n\\t\\tthis.second = second;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        \\n        Queue<Pair> q = new LinkedList<Pair>();\\n\\t\\t\\n        int r = grid.length;\\n        int c = grid[0].length;\\n\\t\\tint fresh = 0, rotten = 0;\\n\\t\\tfor(int i=0;i<r;i++) {\\n\\t\\t\\t\\n\\t\\t\\tfor(int j=0;j<c;j++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(grid[i][j]==2) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tq.add(new Pair(i,j));\\n\\t\\t\\t\\t\\trotten++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(grid[i][j]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(rotten==0 && fresh>0) {\\n\\t\\t\\t\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n        \\n\\t\\t\\n\\t\\tint time = 0;\\n\\t\\t\\n\\t\\twhile(!q.isEmpty() && fresh>0) {\\n\\t\\t\\t\\n\\t\\t\\ttime++;\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\n\\t\\t\\twhile(size-- >0 && fresh>0) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tPair g = q.peek();\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint x = g.first;\\n\\t\\t\\t\\tint y = g.second;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(isSafe(x-1,y,r,c) && grid[x-1][y]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x-1,y));\\n\\t\\t\\t\\t\\tgrid[x-1][y] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x,y-1,r,c) && grid[x][y-1]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x,y-1));\\n\\t\\t\\t\\t\\tgrid[x][y-1] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x+1,y,r,c) && grid[x+1][y]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x+1,y));\\n\\t\\t\\t\\t\\tgrid[x+1][y] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x,y+1,r,c) && grid[x][y+1]==1) {\\n\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x,y+1));\\n\\t\\t\\t\\t\\tgrid[x][y+1] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\tif(fresh==0) return time;\\n\\t\\treturn -1;\\n    }\\n    boolean isSafe(int x, int y, int r, int c) {\\n\\t\\t\\n\\t\\tif(x>=0 && y>=0 && x<r && y<c) return true;\\n\\t\\treturn false;\\n\\t}\\n}\\n\\nclass Pair{\\n\\t\\n\\tint first;\\n\\tint second;\\n\\t\\n\\tpublic Pair(int first, int second) {\\n\\t\\t\\n\\t\\tthis.first = first;\\n\\t\\tthis.second = second;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291966,
                "title": "java-do-checkout-for-detailed-explanation-3-approaches-using-bfs-o-m-n-complexity",
                "content": "**Do vote up if you like it :)**\\n\\nCreating a Pair class to keep track of the x and y coordinate,\\nx and y coordinate would be there to keep track of which grid is being processed.\\n\\nThe idea is to put all the grid with value = 2 in queue by iterating the whole grid and also count one, one needs to be counted because there can be some grid with value = 1, which would be surrounded by all 0\\'s therefore that grid with value = 1 cannot be rotten ever.\\n\\nNow, While we are processing queue (simple bfs) we reach to each of the neighbours of that polled currentPair, if that i, j is within the grid and grid value of that i and j is 1, then we keep adding the neighbours of 2 which is 1 in the queue and also we keep on subtracting freshOranges(ones) each time and also to keep track of visited grids we mark it as 2.\\nNow, observe that if all ones would have been processed then countOnes will eventually become 0, if not then returning -1, simply because freshOrange(ones)s is not 0, that means there was some grid which could not be reached from any 2\\'s of the grid.\\n```\\nclass Solution {\\n    \\n    static class Pair {\\n        int x;\\n        int y;\\n        \\n        public Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(new Pair(i, j));\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int time = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Pair currentPair = queue.poll();\\n\\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = currentPair.x + dir[d][0];\\n                    int c = currentPair.y + dir[d][1];\\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(new Pair(r, c));\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n------------------------------------------------------------\\nIn case you did not understand the level concept then here\\'s another way out.\\nKeep an additional time field in the Pair class to keep track to the dist or time from the parent 2 to 1.\\nAlso, x and y coordinate would be there to keep track of which grid is being processed.\\nRest would work the same as the above explantion.\\n```\\nclass Solution {\\n    \\n    static class Pair {\\n        int x;\\n        int y;\\n        int time;\\n        \\n        public Pair(int x, int y, int time) {\\n            this.x = x;\\n            this.y = y;\\n            this.time = time;\\n        }\\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(new Pair(i, j, 0));\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Pair currentPair = queue.poll();\\n                int time = currentPair.time;\\n                \\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = currentPair.x + dir[d][0];\\n                    int c = currentPair.y + dir[d][1];\\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(new Pair(r, c, time + 1));\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n-------------------------------------------------------------\\n2D into 1D\\nWithout Pair class\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(i * m + j);\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int time = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int idx = queue.poll();\\n                int x = idx / m;\\n                int y = idx % m;\\n                \\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = x + dir[d][0];\\n                    int c = y + dir[d][1];\\n                    \\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(r * m + c);\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n------------------------------------------------------------------------------",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    static class Pair {\\n        int x;\\n        int y;\\n        \\n        public Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(new Pair(i, j));\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int time = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Pair currentPair = queue.poll();\\n\\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = currentPair.x + dir[d][0];\\n                    int c = currentPair.y + dir[d][1];\\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(new Pair(r, c));\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    static class Pair {\\n        int x;\\n        int y;\\n        int time;\\n        \\n        public Pair(int x, int y, int time) {\\n            this.x = x;\\n            this.y = y;\\n            this.time = time;\\n        }\\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(new Pair(i, j, 0));\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Pair currentPair = queue.poll();\\n                int time = currentPair.time;\\n                \\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = currentPair.x + dir[d][0];\\n                    int c = currentPair.y + dir[d][1];\\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(new Pair(r, c, time + 1));\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(i * m + j);\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int time = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int idx = queue.poll();\\n                int x = idx / m;\\n                int y = idx % m;\\n                \\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = x + dir[d][0];\\n                    int c = y + dir[d][1];\\n                    \\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(r * m + c);\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274017,
                "title": "dfs-soln-with-o-1-space-faster-then-94",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,vector<vector<int>>& grid,int timer)\\n    {\\n        if(i>=0&&j>=0&&j<grid[0].size()&&i<grid.size()&&(grid[i][j]==1||grid[i][j]<timer))\\n            return 1;\\n        return 0;\\n    }\\n    void dfs(int i,int j,vector<vector<int>>& grid,int timer)\\n  {\\n      grid[i][j]=timer;\\n      timer--;\\n       if(check(i-1,j,grid,timer))\\n       dfs(i-1,j,grid,timer);\\n       if(check(i+1,j,grid,timer))\\n       dfs(i+1,j,grid,timer);\\n       if(check(i,j-1,grid,timer))\\n       dfs(i,j-1,grid,timer);\\n       if(check(i,j+1,grid,timer))\\n       dfs(i,j+1,grid,timer);\\n       \\n  }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n           for(int i=0;i<grid.size();i++)\\n           {\\n               for(int j=0;j<grid[0].size();j++)\\n               {\\n                   if(grid[i][j]==2)\\n                   dfs(i,j,grid,0);\\n               }\\n           }\\n           int  min=0;\\n            for(int i=0;i<grid.size();i++)\\n                   {\\n                   for(int j=0;j<grid[0].size();j++)\\n               {\\n                   if(grid[i][j]==1)\\n                   return -1;\\n                   //cout<<grid[i][j]<<\" \";\\n                   if(grid[i][j]<min)\\n               min=grid[i][j];\\n               }\\n              // cout<<endl;\\n                   }\\n               return -min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,vector<vector<int>>& grid,int timer)\\n    {\\n        if(i>=0&&j>=0&&j<grid[0].size()&&i<grid.size()&&(grid[i][j]==1||grid[i][j]<timer))\\n            return 1;\\n        return 0;\\n    }\\n    void dfs(int i,int j,vector<vector<int>>& grid,int timer)\\n  {\\n      grid[i][j]=timer;\\n      timer--;\\n       if(check(i-1,j,grid,timer))\\n       dfs(i-1,j,grid,timer);\\n       if(check(i+1,j,grid,timer))\\n       dfs(i+1,j,grid,timer);\\n       if(check(i,j-1,grid,timer))\\n       dfs(i,j-1,grid,timer);\\n       if(check(i,j+1,grid,timer))\\n       dfs(i,j+1,grid,timer);\\n       \\n  }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n           for(int i=0;i<grid.size();i++)\\n           {\\n               for(int j=0;j<grid[0].size();j++)\\n               {\\n                   if(grid[i][j]==2)\\n                   dfs(i,j,grid,0);\\n               }\\n           }\\n           int  min=0;\\n            for(int i=0;i<grid.size();i++)\\n                   {\\n                   for(int j=0;j<grid[0].size();j++)\\n               {\\n                   if(grid[i][j]==1)\\n                   return -1;\\n                   //cout<<grid[i][j]<<\" \";\\n                   if(grid[i][j]<min)\\n               min=grid[i][j];\\n               }\\n              // cout<<endl;\\n                   }\\n               return -min;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1255777,
                "title": "simple-c-soln",
                "content": "```\\nint dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\\n    int orangesRotting(vector<vector<int>>&arr) {\\n        int m=arr.size();\\n        int n=arr[0].size();\\n        int time=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(arr[i][j]==2){\\n                    q.push({i,j});\\n                    arr[i][j]=-1;\\n                }\\n            }         \\n        }\\n        while(q.size()){\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                pair<int,int>curr=q.front();\\n                q.pop();\\n                for(int j=0;j<4;j++){\\n                    int r=curr.first+dir[j][0];\\n                    int c=curr.second+dir[j][1];\\n                    if(r<0||c<0||r>m-1||c>n-1||arr[r][c]!=1)\\n                        continue;\\n                    q.push({r,c});\\n                    arr[r][c]=-1;\\n                }\\n            }\\n            time++;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(arr[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        return time!=0? time-1:time;;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\\n    int orangesRotting(vector<vector<int>>&arr) {\\n        int m=arr.size();\\n        int n=arr[0].size();\\n        int time=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(arr[i][j]==2){\\n                    q.push({i,j});\\n                    arr[i][j]=-1;\\n                }\\n            }         \\n        }\\n        while(q.size()){\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                pair<int,int>curr=q.front();\\n                q.pop();\\n                for(int j=0;j<4;j++){\\n                    int r=curr.first+dir[j][0];\\n                    int c=curr.second+dir[j][1];\\n                    if(r<0||c<0||r>m-1||c>n-1||arr[r][c]!=1)\\n                        continue;\\n                    q.push({r,c});\\n                    arr[r][c]=-1;\\n                }\\n            }\\n            time++;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(arr[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        return time!=0? time-1:time;;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1231899,
                "title": "easy-solution-for-beginners",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n    // to change the fresh oranges which will rot due to their neighbours\\n    void cor(vector<vector<int>> &grid) { \\n        int r=grid.size(), c=grid[0].size();\\n        for (auto i=0;i<r;i++) for (auto j=0;j<c;j++) if(grid[i][j]==3) grid[i][j]=2;\\n    }\\n    \\n\\t// here we see whether there is a fresh orange in the neighbourhood of a rotten orange. If yes, we\\'ll mark that \\'3\\' which will later be marked \\'2\\'(rotten) using cor()\\n    void repair(vector<vector<int>> &grid, int i, int j) { \\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return;\\n        \\n        if(grid[i][j]==1) grid[i][j]=3;\\n        return;\\n    }\\n    \\n\\t// we check whether there are any fresh oranges left in the grid\\n    bool check(vector<vector<int>> grid) { \\n        int r=grid.size(), c=grid[0].size();\\n        for (auto i=0;i<r;i++) for (auto j=0;j<c;j++) if(grid[i][j]==1) return true;\\n        return false;\\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int r=grid.size(), c=grid[0].size();\\n        int ans=0; //to count the number of minutes\\n\\n        while(check(grid)) {\\n\\t\\t// observing the boundary conditions, if the count of minutes turns out to be more than let\\'s say 100, than there is some fresh orange who is living in a full healthy neighbourhood. In short, mission failed for rotten oranges\\n            if(ans>100) return -1; \\n            ans++;\\n            for (auto i=0;i<r;i++) {\\n                for (auto j=0;j<c;j++) \\n                    if(grid[i][j]==2) {\\n\\t\\t\\t\\t\\t// Taking a stroll in the neighbourhood of this rotten orange\\n                        repair(grid,i-1,j);\\n                        repair(grid,i,j-1);\\n                        repair(grid,i,j+1);\\n                        repair(grid,i+1,j);\\n                    }\\n            }\\n            \\n            cor(grid);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n    // to change the fresh oranges which will rot due to their neighbours\\n    void cor(vector<vector<int>> &grid) { \\n        int r=grid.size(), c=grid[0].size();\\n        for (auto i=0;i<r;i++) for (auto j=0;j<c;j++) if(grid[i][j]==3) grid[i][j]=2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 910426,
                "title": "bfs-js-solution",
                "content": "```\\nvar orangesRotting = function(grid) {\\n    if (grid.length === 0 || grid[0].length === 0) {\\n        return -1;\\n    }\\n    let DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    let height = grid.length, width = grid[0].length;\\n    let fresh = 0;\\n    let queue = [], depth = 0;\\n    // Get the number of fresh oranges at start and\\n    // collect starting points of BFS traversal\\n    for (let i = 0; i < height; i++) {\\n        for (let j = 0; j < width; j++) {\\n            if (grid[i][j] === 1) {\\n                fresh++;\\n            } else if (grid[i][j] === 2) {\\n                queue.push([i, j]);\\n            }\\n        }\\n    }\\n    if (fresh === 0) {\\n        return 0;\\n    }\\n    while (queue.length > 0) {\\n        let queueLen = queue.length;\\n        let rot = 0;\\n        for (let i = 0; i < queueLen; i++) {\\n            let [row, col] = queue.shift();\\n            if (grid[row][col] === 1) {\\n                rot++;\\n                grid[row][col] = 2;\\n            }\\n            for (let dir of DIRECTIONS) {\\n                let newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < height \\n                    && newCol >= 0 && newCol < width\\n                   && grid[newRow][newCol] === 1) {\\n                    queue.push([newRow, newCol]);\\n                }\\n            }\\n        }\\n        if (rot > 0) {\\n            fresh -= rot;\\n            depth++;\\n        }\\n    }\\n    return fresh === 0 ? depth : -1;\\n};\\n\\n/*\\nSolution\\n\\n1. Perform BFS traversal at each rotten orange simultaneously\\n2. Check if there is no fresh orange at the end of traversal\\n3. The depth of the traversal is equivalent to the number of minutes elapsed\\n\\nTime Complexity: O(m*n) where m = the number of rows, n = the number of columns\\nSpace Complexity: O(m*n)\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar orangesRotting = function(grid) {\\n    if (grid.length === 0 || grid[0].length === 0) {\\n        return -1;\\n    }\\n    let DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    let height = grid.length, width = grid[0].length;\\n    let fresh = 0;\\n    let queue = [], depth = 0;\\n    // Get the number of fresh oranges at start and\\n    // collect starting points of BFS traversal\\n    for (let i = 0; i < height; i++) {\\n        for (let j = 0; j < width; j++) {\\n            if (grid[i][j] === 1) {\\n                fresh++;\\n            } else if (grid[i][j] === 2) {\\n                queue.push([i, j]);\\n            }\\n        }\\n    }\\n    if (fresh === 0) {\\n        return 0;\\n    }\\n    while (queue.length > 0) {\\n        let queueLen = queue.length;\\n        let rot = 0;\\n        for (let i = 0; i < queueLen; i++) {\\n            let [row, col] = queue.shift();\\n            if (grid[row][col] === 1) {\\n                rot++;\\n                grid[row][col] = 2;\\n            }\\n            for (let dir of DIRECTIONS) {\\n                let newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < height \\n                    && newCol >= 0 && newCol < width\\n                   && grid[newRow][newCol] === 1) {\\n                    queue.push([newRow, newCol]);\\n                }\\n            }\\n        }\\n        if (rot > 0) {\\n            fresh -= rot;\\n            depth++;\\n        }\\n    }\\n    return fresh === 0 ? depth : -1;\\n};\\n\\n/*\\nSolution\\n\\n1. Perform BFS traversal at each rotten orange simultaneously\\n2. Check if there is no fresh orange at the end of traversal\\n3. The depth of the traversal is equivalent to the number of minutes elapsed\\n\\nTime Complexity: O(m*n) where m = the number of rows, n = the number of columns\\nSpace Complexity: O(m*n)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 907086,
                "title": "c-solution-using-queue-runtime-80-ms-faster-than-100-00",
                "content": "```\\npublic class Solution \\n{\\n    private int minutes = 0;\\n    \\n    public int OrangesRotting(int[][] grid) \\n    {\\n        var freshCount = 0;\\n        var rottenCoordinates = new Queue<(int i, int j)>();\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            var row = grid[i];\\n            for (int j = 0; j < row.Length; j++)\\n            {\\n                if (row[j] == 1)\\n                {\\n                    freshCount++;\\n                }\\n                \\n                if (row[j] == 2)\\n                {\\n                    rottenCoordinates.Enqueue((i, j));\\n                }\\n            }\\n        }\\n        \\n        if (freshCount == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        var minutes = -1;\\n        while (rottenCoordinates.Count > 0)\\n        {\\n            var count = rottenCoordinates.Count;\\n            \\n            while (count > 0)\\n            {\\n                var coordinates = rottenCoordinates.Dequeue();\\n                var i = coordinates.i;\\n                var j = coordinates.j;\\n                \\n                if (j < grid[i].Length - 1 && grid[i][j + 1] == 1)\\n                {\\n                    rottenCoordinates.Enqueue((i, j + 1));\\n                    grid[i][j + 1] = 2;\\n                    freshCount--;\\n                }\\n                \\n                if (i > 0 && grid[i - 1][j] == 1)\\n                {\\n                    rottenCoordinates.Enqueue((i - 1, j));\\n                    grid[i - 1][j] = 2;\\n                    freshCount--;\\n                }\\n                \\n                if (j > 0 && grid[i][j - 1] == 1)\\n                {\\n                    rottenCoordinates.Enqueue((i, j - 1));\\n                    grid[i][j - 1] = 2;\\n                    freshCount--;\\n                }\\n                \\n                if (i < grid.Length - 1 && grid[i + 1][j] == 1)\\n                {\\n                    rottenCoordinates.Enqueue((i + 1, j));\\n                    grid[i + 1][j] = 2;\\n                    freshCount--;\\n                }\\n                \\n                count--;\\n            }\\n            \\n            minutes++;\\n        }\\n        \\n        return freshCount > 0 ? -1 : minutes;\\n    }\\n}",
                "solutionTags": [
                    "Queue"
                ],
                "code": "class Solution \\n{\\n    private int minutes = 0;\\n    \\n    public int OrangesRotting(int[][] grid) \\n    {\\n        var freshCount = 0;\\n        var rottenCoordinates = new Queue<(int i, int j)>();\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            var row = grid[i];\\n            for (int j = 0; j < row.Length; j++)\\n            {\\n                if (row[j] == 1)\\n                {\\n                    freshCount++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 781645,
                "title": "c-simple-bfs-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0,};\\n    int dy[4]={0,0,-1,1};\\n    \\n    vector<vector<int>> grd;\\n    int ans=0,n,m;\\n    \\n    void bfs(){\\n        queue<pair<int,int>> qu;\\n        \\n        //pushing every rotten orange in queue\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grd[i][j]==2) qu.push({i,j});\\n        \\n        while(!qu.empty()){\\n            int sz=qu.size();\\n            //pushed is used to know whether next level of fresh oranges (next layer of bfs) are there\\n            bool pushed=false;\\n            \\n            //loop used to traverse all rotten oranges which are in queue\\n            for(int i=0;i<sz;i++){\\n                int x=qu.front().first,y=qu.front().second;\\n                qu.pop();\\n                for(int k=0;k<4;k++){\\n                    //if coordinates are invalid then skip\\n                    if(x+dx[k]<0 or y+dy[k]<0 or x+dx[k]>=grd.size() or y+dy[k]>=grd[0].size()) continue;\\n                    //if they are and valid and we encounter fresh orange then push that into queue\\n                    if(grd[x+dx[k]][y+dy[k]]==1){\\n                        //pushed is also made true confirming there is another layer also\\n                        qu.push({x+dx[k],y+dy[k]}),pushed=true;\\n                        //fresh orange converted into rotten orange \\n                        grd[x+dx[k]][y+dy[k]]=2;    \\n                    } \\n                }\\n            }\\n            //confirming that this is not last layer and increamenting ans\\n            if(pushed) ans++;\\n        }\\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        grd=grid,n=grd.size(),m=grd[0].size();\\n        //breadth first search over the grid\\n        bfs();\\n        //if there is still some fresh oranges return -1 else return the ans\\n        for(auto it:grd) for(auto jt:it) if(jt==1) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0,};\\n    int dy[4]={0,0,-1,1};\\n    \\n    vector<vector<int>> grd;\\n    int ans=0,n,m;\\n    \\n    void bfs(){\\n        queue<pair<int,int>> qu;\\n        \\n        //pushing every rotten orange in queue\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grd[i][j]==2) qu.push({i,j});\\n        \\n        while(!qu.empty()){\\n            int sz=qu.size();\\n            //pushed is used to know whether next level of fresh oranges (next layer of bfs) are there\\n            bool pushed=false;\\n            \\n            //loop used to traverse all rotten oranges which are in queue\\n            for(int i=0;i<sz;i++){\\n                int x=qu.front().first,y=qu.front().second;\\n                qu.pop();\\n                for(int k=0;k<4;k++){\\n                    //if coordinates are invalid then skip\\n                    if(x+dx[k]<0 or y+dy[k]<0 or x+dx[k]>=grd.size() or y+dy[k]>=grd[0].size()) continue;\\n                    //if they are and valid and we encounter fresh orange then push that into queue\\n                    if(grd[x+dx[k]][y+dy[k]]==1){\\n                        //pushed is also made true confirming there is another layer also\\n                        qu.push({x+dx[k],y+dy[k]}),pushed=true;\\n                        //fresh orange converted into rotten orange \\n                        grd[x+dx[k]][y+dy[k]]=2;    \\n                    } \\n                }\\n            }\\n            //confirming that this is not last layer and increamenting ans\\n            if(pushed) ans++;\\n        }\\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        grd=grid,n=grd.size(),m=grd[0].size();\\n        //breadth first search over the grid\\n        bfs();\\n        //if there is still some fresh oranges return -1 else return the ans\\n        for(auto it:grd) for(auto jt:it) if(jt==1) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751708,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\nstruct Test{\\n    int x,y,z;\\n};\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int numFresh = 0;\\n        queue<Test> q;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 2) q.push({i,j,0});\\n                if(grid[i][j] == 1) numFresh++;\\n            }\\n        }\\n        int res = 0;\\n        while(!q.empty()){\\n            Test pos = q.front();\\n            q.pop();\\n            int row = pos.x;\\n            int col = pos.y;\\n            int minute = pos.z;\\n            if(row != 0){\\n                if(grid[row-1][col] == 1){\\n                    q.push({row-1,col,minute + 1});\\n                    grid[row-1][col] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(row != grid.size() - 1){\\n                if(grid[row+1][col] == 1){\\n                    q.push({row+1,col,minute + 1});\\n                    grid[row+1][col] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(col != 0){\\n                if(grid[row][col-1] == 1){\\n                    q.push({row,col-1,minute + 1});\\n                    grid[row][col-1] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(col != grid[0].size()-1){\\n                if(grid[row][col+1] == 1){\\n                    q.push({row,col+1,minute + 1});\\n                    grid[row][col+1] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            res = minute;\\n\\n        }\\n        if(numFresh == 0){\\n            return res;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nstruct Test{\\n    int x,y,z;\\n};\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int numFresh = 0;\\n        queue<Test> q;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 2) q.push({i,j,0});\\n                if(grid[i][j] == 1) numFresh++;\\n            }\\n        }\\n        int res = 0;\\n        while(!q.empty()){\\n            Test pos = q.front();\\n            q.pop();\\n            int row = pos.x;\\n            int col = pos.y;\\n            int minute = pos.z;\\n            if(row != 0){\\n                if(grid[row-1][col] == 1){\\n                    q.push({row-1,col,minute + 1});\\n                    grid[row-1][col] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(row != grid.size() - 1){\\n                if(grid[row+1][col] == 1){\\n                    q.push({row+1,col,minute + 1});\\n                    grid[row+1][col] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(col != 0){\\n                if(grid[row][col-1] == 1){\\n                    q.push({row,col-1,minute + 1});\\n                    grid[row][col-1] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(col != grid[0].size()-1){\\n                if(grid[row][col+1] == 1){\\n                    q.push({row,col+1,minute + 1});\\n                    grid[row][col+1] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            res = minute;\\n\\n        }\\n        if(numFresh == 0){\\n            return res;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656460,
                "title": "simple-solution-in-the-lines-of-number-of-islands-problem",
                "content": "```\\nclass Solution {\\n    \\n    // bfs .. lets make queue.\\n    Queue<Node> queue = new LinkedList<Node>();\\n\\n    public int orangesRotting(int[][] grid) {\\n    int max = 0;\\n\\n        for(int i=0;i<grid.length;i++) {\\n            \\n            for(int j=0;j<grid[i].length;j++) {\\n        \\n                if (grid[i][j]==2) {\\n                    Node node = new Node();\\n                    node.point.x = i;\\n                    node.point.y = j;\\n                    queue.add(node);\\n                } \\n            }\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            Node node = queue.poll();\\n            int i = node.point.x;\\n            int j = node.point.y;\\n            int minutes = node.minutes;\\n            if (max<minutes)\\n                max = minutes;\\n           \\n            makeRotten(i+1, j,minutes, grid );\\n            makeRotten(i-1, j,minutes, grid);\\n            makeRotten(i, j+1,minutes, grid);\\n            makeRotten(i, j-1,minutes, grid);\\n\\n        }\\n        \\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n        \\n                if (grid[i][j]==1) {\\n                   return -1;\\n                } \\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public boolean makeRotten(int i, int j,int minutes, int[][] grid) {\\n                \\n        // if no fresh orange found then return \\n        if (i<0 || i>=grid.length || j<0 || j>=grid[i].length ||\\n           grid[i][j]!=1) {\\n            return false;\\n        }\\n         \\n       // if fresh orange found then make it to rotten and add to queue with counter incremented \\n        grid[i][j]=2;\\n        Node node = new Node();\\n        node.point.x=i;\\n        node.point.y=j;\\n        node.minutes = minutes+1;\\n        queue.add(node); \\n        return true;\\n         \\n    }\\n    \\nclass Node {\\n    \\n    public int minutes;\\n    public Point point;\\n    \\n    public Node() {\\n        minutes = 0;\\n        point = new Point();\\n        point.x = 0;\\n        point.y = 0;\\n    }\\n}\\n    \\nclass Point {\\n    \\n    public int x;\\n    public int y;\\n}    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // bfs .. lets make queue.\\n    Queue<Node> queue = new LinkedList<Node>();\\n\\n    public int orangesRotting(int[][] grid) {\\n    int max = 0;\\n\\n        for(int i=0;i<grid.length;i++) {\\n            \\n            for(int j=0;j<grid[i].length;j++) {\\n        \\n                if (grid[i][j]==2) {\\n                    Node node = new Node();\\n                    node.point.x = i;\\n                    node.point.y = j;\\n                    queue.add(node);\\n                } \\n            }\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            Node node = queue.poll();\\n            int i = node.point.x;\\n            int j = node.point.y;\\n            int minutes = node.minutes;\\n            if (max<minutes)\\n                max = minutes;\\n           \\n            makeRotten(i+1, j,minutes, grid );\\n            makeRotten(i-1, j,minutes, grid);\\n            makeRotten(i, j+1,minutes, grid);\\n            makeRotten(i, j-1,minutes, grid);\\n\\n        }\\n        \\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n        \\n                if (grid[i][j]==1) {\\n                   return -1;\\n                } \\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public boolean makeRotten(int i, int j,int minutes, int[][] grid) {\\n                \\n        // if no fresh orange found then return \\n        if (i<0 || i>=grid.length || j<0 || j>=grid[i].length ||\\n           grid[i][j]!=1) {\\n            return false;\\n        }\\n         \\n       // if fresh orange found then make it to rotten and add to queue with counter incremented \\n        grid[i][j]=2;\\n        Node node = new Node();\\n        node.point.x=i;\\n        node.point.y=j;\\n        node.minutes = minutes+1;\\n        queue.add(node); \\n        return true;\\n         \\n    }\\n    \\nclass Node {\\n    \\n    public int minutes;\\n    public Point point;\\n    \\n    public Node() {\\n        minutes = 0;\\n        point = new Point();\\n        point.x = 0;\\n        point.y = 0;\\n    }\\n}\\n    \\nclass Point {\\n    \\n    public int x;\\n    public int y;\\n}    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649989,
                "title": "c-bfs-with-explanation-for-beginners",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {        \\n        queue<pair<int,int>> rottenOrangesQ;\\n        int freshOrganges = 0;\\n        for(int i=0; i<grid.size(); ++i)\\n        {\\n            for(int j=0; j<grid[0].size(); ++j)\\n            {\\n                if(grid[i][j] == 2)\\n                   rottenOrangesQ.push({i,j});//rottenOranges\\n                else if(grid[i][j] == 1)\\n                    freshOrganges++;//freshOrganges count\\n            }\\n        }\\n        \\n        if(freshOrganges == 0)//No fresh orange, return 0 days\\n            return 0;\\n        \\n        if(rottenOrangesQ.size() == 0)//No rotten oranges, simply return -1;\\n            return -1;\\n        \\n        int days = 0;\\n        vector<pair<int,int>> directions ={{-1,0},{0,1},{1,0},{0,-1}};//all four directions.\\n        while(!rottenOrangesQ.empty() && freshOrganges>0)//Run until no rotten oranges left in q.\\n        {\\n            int size = rottenOrangesQ.size();//same as level orer.\\n            for(int rottenOranges=0; rottenOranges<size; ++rottenOranges)\\n            {\\n                auto coordinates= rottenOrangesQ.front(); rottenOrangesQ.pop();//take rotten orange coordinate\\n                for(auto dir:directions)//navigate in all four direction.\\n                {\\n                    int i = coordinates.first+dir.first;\\n                    int j = coordinates.second+dir.second;\\n                    if(i<0 || j<0 || i==grid.size() || j==grid[i].size() || grid[i][j] != 1)\\n                        continue;\\n                    \\n                    grid[i][j]=2;\\n                    rottenOrangesQ.push({i,j});//Add new cordinate as rotten orange.\\n                    freshOrganges--;\\n                }\\n            }\\n            days++;\\n        }\\n        if(freshOrganges>0)\\n            return -1;\\n        return days;    \\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {        \\n        queue<pair<int,int>> rottenOrangesQ;\\n        int freshOrganges = 0;\\n        for(int i=0; i<grid.size(); ++i)\\n        {\\n            for(int j=0; j<grid[0].size(); ++j)\\n            {\\n                if(grid[i][j] == 2)\\n                   rottenOrangesQ.push({i,j});//rottenOranges\\n                else if(grid[i][j] == 1)\\n                    freshOrganges++;//freshOrganges count\\n            }\\n        }\\n        \\n        if(freshOrganges == 0)//No fresh orange, return 0 days\\n            return 0;\\n        \\n        if(rottenOrangesQ.size() == 0)//No rotten oranges, simply return -1;\\n            return -1;\\n        \\n        int days = 0;\\n        vector<pair<int,int>> directions ={{-1,0},{0,1},{1,0},{0,-1}};//all four directions.\\n        while(!rottenOrangesQ.empty() && freshOrganges>0)//Run until no rotten oranges left in q.\\n        {\\n            int size = rottenOrangesQ.size();//same as level orer.\\n            for(int rottenOranges=0; rottenOranges<size; ++rottenOranges)\\n            {\\n                auto coordinates= rottenOrangesQ.front(); rottenOrangesQ.pop();//take rotten orange coordinate\\n                for(auto dir:directions)//navigate in all four direction.\\n                {\\n                    int i = coordinates.first+dir.first;\\n                    int j = coordinates.second+dir.second;\\n                    if(i<0 || j<0 || i==grid.size() || j==grid[i].size() || grid[i][j] != 1)\\n                        continue;\\n                    \\n                    grid[i][j]=2;\\n                    rottenOrangesQ.push({i,j});//Add new cordinate as rotten orange.\\n                    freshOrganges--;\\n                }\\n            }\\n            days++;\\n        }\\n        if(freshOrganges>0)\\n            return -1;\\n        return days;    \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645705,
                "title": "java-bfs-solution",
                "content": "My intuitive BFS solution.\\n1. Initial state: Find all rotten oranges.\\n2. Start: A rotten orange starts rotting its neighbors as time goes by.\\n3. End: Check if all oranges are rotten. If yes, return ```time```. Otherwise, return ```-1```.\\n\\n```\\nclass Solution {\\n    int[] dir = new int[] { 0, 1, 0, -1, 0 };\\n    public int orangesRotting(int[][] grid) {\\n        // Init: Find all rotten oranges\\n        int time = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 2) queue.add(new int[]{ i, j });\\n            }\\n        }\\n        \\n        // Start: A rotten orange starts rotting its neighbors as time goes by\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();\\n                // Find its unrotten neighbors\\n                for(int j = 0; j < 4; j++) {\\n                    int x = cur[0] + dir[j], y = cur[1] + dir[j+1];\\n                    if(0 <= x && 0 <= y && x < grid.length && y < grid[0].length && grid[x][y] == 1) {\\n                        grid[x][y] = 2; \\n                        queue.add(new int[]{ x, y });\\n                    }\\n                }\\n            }\\n            if(!queue.isEmpty()) time++;\\n        }\\n\\n        // End: Check if all oranges are rotten. If yes, return time. Otherwise, return -1.\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) return -1;\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```time```\n```-1```\n```\\nclass Solution {\\n    int[] dir = new int[] { 0, 1, 0, -1, 0 };\\n    public int orangesRotting(int[][] grid) {\\n        // Init: Find all rotten oranges\\n        int time = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 2) queue.add(new int[]{ i, j });\\n            }\\n        }\\n        \\n        // Start: A rotten orange starts rotting its neighbors as time goes by\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();\\n                // Find its unrotten neighbors\\n                for(int j = 0; j < 4; j++) {\\n                    int x = cur[0] + dir[j], y = cur[1] + dir[j+1];\\n                    if(0 <= x && 0 <= y && x < grid.length && y < grid[0].length && grid[x][y] == 1) {\\n                        grid[x][y] = 2; \\n                        queue.add(new int[]{ x, y });\\n                    }\\n                }\\n            }\\n            if(!queue.isEmpty()) time++;\\n        }\\n\\n        // End: Check if all oranges are rotten. If yes, return time. Otherwise, return -1.\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) return -1;\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569248,
                "title": "alternate-approach-bfs-o-n-height-but-constant-space-easy-to-understand-modular-code",
                "content": "The idea is to do BFS using the given input array.\\n\\nEvery minute, just find and set the ones that are going to rot, to the current minute in the input array.\\nTo illustrate the idea, consider how it would play out - \\nStart by marking all fresh ones adjacent to the rotten ones with value 2 as 3.\\nThen, mark all fresh ones adjacent to the rotten ones with value 3 as 4.\\nThen, mark all fresh ones adjacent to the rotten ones with value 4 as 5.\\n...\\nKeep doing this until that are no more adjacent fresh oranges to rot.\\nNote: One can start timer at minute 2 as it\\'s the time elapsed that matters. \\n\\nTime - O (N * Height)\\nSpace - O (1) \\nThis offcourse assumes that the input can be modified.  \\n\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int time = 2;\\n        boolean moreToRot = true;\\n        while (moreToRot) {\\n            moreToRot = rotNextMinuteOnes(grid, time);\\n            if (moreToRot) time++;\\n        }\\n        return allRotten(grid) ? time - 2 : -1;\\n    }\\n    \\n    private boolean rotNextMinuteOnes(int[][] grid, int time) {\\n        boolean moreToRot = false;\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                moreToRot = rotAdjacentIfJustRotten(grid, i, j, time) || moreToRot;\\n        return moreToRot;\\n    }\\n    \\n    private boolean rotAdjacentIfJustRotten(int[][] grid, int i, int j, int time) {\\n        if (grid[i][j] != time) return false;\\n        boolean right = rotIfFresh(grid, i, j + 1, time + 1);\\n        boolean bottom = rotIfFresh(grid, i + 1, j, time + 1);\\n        boolean left = rotIfFresh(grid, i, j - 1, time + 1);\\n        boolean up = rotIfFresh(grid, i - 1, j, time + 1);\\n        return right || bottom || left || up;\\n    }\\n    \\n    private boolean rotIfFresh(int[][] grid, int i, int j, int time) {\\n        if (i < 0 || i >= grid.length) return false;\\n        if (j < 0 || j >= grid[0].length) return false;\\n        if (grid[i][j] != 1) return false;\\n        grid[i][j] = time;\\n        return true;\\n    }\\n    \\n    private boolean allRotten(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int time = 2;\\n        boolean moreToRot = true;\\n        while (moreToRot) {\\n            moreToRot = rotNextMinuteOnes(grid, time);\\n            if (moreToRot) time++;\\n        }\\n        return allRotten(grid) ? time - 2 : -1;\\n    }\\n    \\n    private boolean rotNextMinuteOnes(int[][] grid, int time) {\\n        boolean moreToRot = false;\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                moreToRot = rotAdjacentIfJustRotten(grid, i, j, time) || moreToRot;\\n        return moreToRot;\\n    }\\n    \\n    private boolean rotAdjacentIfJustRotten(int[][] grid, int i, int j, int time) {\\n        if (grid[i][j] != time) return false;\\n        boolean right = rotIfFresh(grid, i, j + 1, time + 1);\\n        boolean bottom = rotIfFresh(grid, i + 1, j, time + 1);\\n        boolean left = rotIfFresh(grid, i, j - 1, time + 1);\\n        boolean up = rotIfFresh(grid, i - 1, j, time + 1);\\n        return right || bottom || left || up;\\n    }\\n    \\n    private boolean rotIfFresh(int[][] grid, int i, int j, int time) {\\n        if (i < 0 || i >= grid.length) return false;\\n        if (j < 0 || j >= grid[0].length) return false;\\n        if (grid[i][j] != 1) return false;\\n        grid[i][j] = time;\\n        return true;\\n    }\\n    \\n    private boolean allRotten(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560328,
                "title": "c-bfs-runtime-error-addition-of-unsigned-offset",
                "content": "I am getting this error on running the following code. \\n\\nruntime erroe:addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\nSUMMARY: undefined-Behaviour......\\n\\nPlease help me out.\\n\"\"\"\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int rows=grid[0].size();\\n        int cols=grid.size();\\n        queue<vector<int>> q;\\n        int res;\\n        vector<int>qc={0,0,grid[0][0]};\\n        q.push(qc);\\n        \\n        while(!q.empty())\\n        {\\n            vector<int> temp=q.front();\\n            q.pop();\\n            res++;\\n            if(temp[2]==2)\\n            {\\n                if(temp[0]-1>=0)\\n                { if(grid[temp[0]-1][temp[1]]==1)\\n                {grid[temp[0]-1][temp[1]]=2;\\n                    q.push({temp[0]-1,temp[1],2});\\n                }\\n                }\\n                \\n                 if(temp[0]+1<rows)\\n                {\\n                     if( grid[temp[0]+1][temp[1]]==1)\\n                     {\\n                    grid[temp[0]-1][temp[1]]=2;\\n                    q.push({temp[0]+1,temp[1],2});\\n                }\\n                 }\\n                 if(temp[1]-1>=0 )\\n                { if(grid[temp[0]][temp[1]-1]==1)\\n                {\\n                    grid[temp[0]-1][temp[1]]=2;\\n                    q.push({temp[0],temp[1]-1,2});\\n                }\\n                }\\n                 if(temp[1]+1<cols )\\n                { if(grid[temp[0]][temp[1]+1]==1)\\n                {\\n                    grid[temp[0]-1][temp[1]]=2;\\n                    q.push({temp[0],temp[1]+1,2});\\n                }\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int i=0;i<rows;++i)\\n            for(int j=0;j<cols;++j)\\n                if(grid[i][j]==1)\\n                    return -1;\\n        \\n        return res;\\n    }\\n};\\n\"\"\"\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int rows=grid[0].size();\\n        int cols=grid.size();\\n        queue<vector<int>> q;\\n        int res;\\n        vector<int>qc={0,0,grid[0][0]}",
                "codeTag": "Java"
            },
            {
                "id": 380667,
                "title": "2ms-readable-java-solution-bfs",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        int numFresh = 0;\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.add(new int[]{ j, i });\\n                } else if (grid[i][j] == 1) {\\n                    numFresh++;\\n                }\\n            }\\n        }\\n        \\n        if (numFresh == 0) return 0;\\n        \\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int minutes = 0;\\n                \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int k = 0; k < size; k++) {\\n                int[] coordinate = queue.poll();\\n                \\n                for (int[] dir: dirs) {\\n                    int x = coordinate[0] + dir[0];\\n                    int y = coordinate[1] + dir[1];\\n                    \\n                    if (x < 0 || y < 0 || x >= cols || y >= rows) continue;\\n                    \\n                    if (grid[y][x] == 1) {\\n                        grid[y][x] = 2;\\n                        queue.add(new int[]{ x, y });\\n                        numFresh--;\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        return numFresh > 0 ? -1 : minutes-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        int numFresh = 0;\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.add(new int[]{ j, i });\\n                } else if (grid[i][j] == 1) {\\n                    numFresh++;\\n                }\\n            }\\n        }\\n        \\n        if (numFresh == 0) return 0;\\n        \\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int minutes = 0;\\n                \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int k = 0; k < size; k++) {\\n                int[] coordinate = queue.poll();\\n                \\n                for (int[] dir: dirs) {\\n                    int x = coordinate[0] + dir[0];\\n                    int y = coordinate[1] + dir[1];\\n                    \\n                    if (x < 0 || y < 0 || x >= cols || y >= rows) continue;\\n                    \\n                    if (grid[y][x] == 1) {\\n                        grid[y][x] = 2;\\n                        queue.add(new int[]{ x, y });\\n                        numFresh--;\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        return numFresh > 0 ? -1 : minutes-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368827,
                "title": "c-solution-100",
                "content": "```\\n public int OrangesRotting(int[][] grid)\\n        {\\n            // create direction array to navigate\\n            int[][] dirs = { new[] { 0, -1 }, new[] { 0, 1 }, new[] { -1, 0 }, new[] { 1, 0 } };\\n            // rotten orange queue. \\n            var rottenQueue= new Queue<O>();\\n            var countFresh = 0;\\n            // add the location for all the rotten orange in queue , and processes one orange at a time, and one layer. \\n            for (int i = 0; i < grid.Length; i++)\\n            {\\n                for (int j = 0; j < grid[0].Length; j++)\\n                {\\n                    if (grid[i][j] == 2)\\n                    {\\n                        rottenQueue.Enqueue(new O(i,j,0));\\n                    }\\n                    if (grid[i][j] == 1)\\n                    {\\n                        countFresh++;\\n                    }\\n                }\\n            }\\n            var minute = 0;\\n            while (rottenQueue.Count>0)\\n            {\\n                var o = rottenQueue.Dequeue();\\n                // navigate in all four direction. \\n                foreach (var dir in dirs)\\n                {\\n                    var x = o.X + dir[0];\\n                    var y = o.Y + dir[1];\\n                    // check for boundary condition and , check if the the orange is fresh then only process it.\\n                    if(x<0||x>=grid.Length||y<0||y>=grid[0].Length|| grid[x][y] != 1) continue;\\n                    // increment the layer of rotten orange\\n                    rottenQueue.Enqueue(new O(x,y,o.Layer+1));\\n                    // set orange to rotten\\n                    grid[x][y] = 2;\\n                    // decrement fresh count.\\n                    countFresh--;\\n                }\\n                // replace max layer count.\\n                minute = Math.Max(minute, o.Layer);\\n            }\\n            // if there is still fresh orange left then return -1;\\n            return countFresh >0?-1:minute;\\n\\n        }\\n\\n        public class O\\n        {\\n            public int X { get; }\\n            public int Y { get; }\\n            public int Layer { get; }\\n\\n            public O(int x,int y, int layer)\\n            {\\n                X = x;\\n                Y = y;\\n                Layer = layer;\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n public int OrangesRotting(int[][] grid)\\n        {\\n            // create direction array to navigate\\n            int[][] dirs = { new[] { 0, -1 }, new[] { 0, 1 }, new[] { -1, 0 }, new[] { 1, 0 } };\\n            // rotten orange queue. \\n            var rottenQueue= new Queue<O>();\\n            var countFresh = 0;\\n            // add the location for all the rotten orange in queue , and processes one orange at a time, and one layer. \\n            for (int i = 0; i < grid.Length; i++)\\n            {\\n                for (int j = 0; j < grid[0].Length; j++)\\n                {\\n                    if (grid[i][j] == 2)\\n                    {\\n                        rottenQueue.Enqueue(new O(i,j,0));\\n                    }\\n                    if (grid[i][j] == 1)\\n                    {\\n                        countFresh++;\\n                    }\\n                }\\n            }\\n            var minute = 0;\\n            while (rottenQueue.Count>0)\\n            {\\n                var o = rottenQueue.Dequeue();\\n                // navigate in all four direction. \\n                foreach (var dir in dirs)\\n                {\\n                    var x = o.X + dir[0];\\n                    var y = o.Y + dir[1];\\n                    // check for boundary condition and , check if the the orange is fresh then only process it.\\n                    if(x<0||x>=grid.Length||y<0||y>=grid[0].Length|| grid[x][y] != 1) continue;\\n                    // increment the layer of rotten orange\\n                    rottenQueue.Enqueue(new O(x,y,o.Layer+1));\\n                    // set orange to rotten\\n                    grid[x][y] = 2;\\n                    // decrement fresh count.\\n                    countFresh--;\\n                }\\n                // replace max layer count.\\n                minute = Math.Max(minute, o.Layer);\\n            }\\n            // if there is still fresh orange left then return -1;\\n            return countFresh >0?-1:minute;\\n\\n        }\\n\\n        public class O\\n        {\\n            public int X { get; }\\n            public int Y { get; }\\n            public int Layer { get; }\\n\\n            public O(int x,int y, int layer)\\n            {\\n                X = x;\\n                Y = y;\\n                Layer = layer;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342939,
                "title": "python-dp-solution",
                "content": "Although BFS can be used to solve the problem, I just want to provide a alternative.\\nIf we let DP[i][j][t] be the days to rot good oranges at step t, then\\nDP[i][j][t] = 1 + min(DP[x][y][t - 1]) for x, y is neighbor of i, j and grid[x][y] != 0\\n\\nInitial conditions are DP[i][j][t] = 0 if grid[i][j] = 2 and DP[i][j][t] = infinity if grid[i][j] != 2\\n\\nAt step mxn, all oranges that can be rotten will get rotten. These are oranges that can be reached from \"2\".\\n\\nBelow is my python implementation\\n\\n```python\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        DP = [[[float(\\'inf\\') for k in range(m*n)] for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                for t in range(m*n):\\n                    if grid[i][j] == 2:\\n                        DP[i][j][t] = 0\\n                    else:\\n                        DP[i][j][t] = float(\\'inf\\')\\n                    \\n        for t in range(1, m*n):\\n            for i in range(m):\\n                for j in range(n):\\n                    if i + 1 < m and grid[i + 1][j] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i + 1][j][t - 1])\\n                    if i - 1 >= 0 and grid[i - 1][j] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i - 1][j][t - 1])\\n                    if j + 1 < n and grid[i][j + 1] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i][j + 1][t - 1])\\n                    if j - 1 >= 0 and grid[i][j - 1] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i][j - 1][t - 1])\\n                        \\n        res = -float(\\'inf\\')\\n        noOnesFlag = True\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1 and DP[i][j][m*n - 1] > res:\\n                    res = DP[i][j][m*n - 1]\\n                    noOnesFlag = False\\n        if noOnesFlag == True:\\n            return 0\\n        return res if res < float(\\'inf\\') else -1\\n                \\n```",
                "solutionTags": [],
                "code": "```python\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        DP = [[[float(\\'inf\\') for k in range(m*n)] for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                for t in range(m*n):\\n                    if grid[i][j] == 2:\\n                        DP[i][j][t] = 0\\n                    else:\\n                        DP[i][j][t] = float(\\'inf\\')\\n                    \\n        for t in range(1, m*n):\\n            for i in range(m):\\n                for j in range(n):\\n                    if i + 1 < m and grid[i + 1][j] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i + 1][j][t - 1])\\n                    if i - 1 >= 0 and grid[i - 1][j] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i - 1][j][t - 1])\\n                    if j + 1 < n and grid[i][j + 1] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i][j + 1][t - 1])\\n                    if j - 1 >= 0 and grid[i][j - 1] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i][j - 1][t - 1])\\n                        \\n        res = -float(\\'inf\\')\\n        noOnesFlag = True\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1 and DP[i][j][m*n - 1] > res:\\n                    res = DP[i][j][m*n - 1]\\n                    noOnesFlag = False\\n        if noOnesFlag == True:\\n            return 0\\n        return res if res < float(\\'inf\\') else -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 287516,
                "title": "java-dfs-solution",
                "content": "```\\n    private int row, col;\\n    public int orangesRotting(int[][] grid) {\\n        row = grid.length;\\n        col = grid[0].length;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 2) {\\n                    dfs(grid, i, j , 0, true);\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int[] ints : grid) {\\n            for (int anInt : ints) {\\n                if (anInt == 1) {\\n                    return -1;\\n                }\\n                max = Math.min(max, anInt);\\n            }\\n        }\\n        return -max;\\n    }\\n\\n\\n    private void dfs(int[][] grid, int i, int j, int dist, boolean begin) {\\n        if (i >= row || i < 0 || j >= col || j < 0 || grid[i][j] == 0 || grid[i][j] < 0 && -grid[i][j] < dist) return;\\n\\n        if (grid[i][j] == 2 && !begin) {\\n            return;\\n        }\\n        grid[i][j] = -dist;\\n        dfs(grid, i + 1, j, dist + 1, false);\\n        dfs(grid, i - 1, j, dist + 1, false);\\n        dfs(grid, i, j - 1, dist + 1, false);\\n        dfs(grid, i, j + 1, dist + 1, false);\\n    }\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    private int row, col;\\n    public int orangesRotting(int[][] grid) {\\n        row = grid.length;\\n        col = grid[0].length;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 2) {\\n                    dfs(grid, i, j , 0, true);\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int[] ints : grid) {\\n            for (int anInt : ints) {\\n                if (anInt == 1) {\\n                    return -1;\\n                }\\n                max = Math.min(max, anInt);\\n            }\\n        }\\n        return -max;\\n    }\\n\\n\\n    private void dfs(int[][] grid, int i, int j, int dist, boolean begin) {\\n        if (i >= row || i < 0 || j >= col || j < 0 || grid[i][j] == 0 || grid[i][j] < 0 && -grid[i][j] < dist) return;\\n\\n        if (grid[i][j] == 2 && !begin) {\\n            return;\\n        }\\n        grid[i][j] = -dist;\\n        dfs(grid, i + 1, j, dist + 1, false);\\n        dfs(grid, i - 1, j, dist + 1, false);\\n        dfs(grid, i, j - 1, dist + 1, false);\\n        dfs(grid, i, j + 1, dist + 1, false);\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964616,
                "title": "efficient-bfs-method-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUpon observing example 1, we can notice that the way a rotten orange make its neighbors go rotten is by each level (go north, go east, go south, go west). Therefore, we use BFS and we only need to do it once. \\n\\nOur starting position is rotten oranges since our goal is to make its neighbors go rotten and calculate the total time to make all fresh oranges rotten. Since there could be multiple rotten oranges initially, we push all of their coordinates into a queue while traversing the grid, and start to pop them out while adding their neighbors. Every time we pop/add queue.size() of elements, one second elapses and we can increment our time counter.\\n\\nOnce we finish bfs, if there are still fresh oranges left, we know its impossible to make all fresh oranges go rotten. Sometimes, this happens when we have some fresh oranges isolated from the main block of rotten and fresh oranges. If that\\'s the case, we return -1. We can calculate the amount of fresh oranges in the same loop we populate the queue with initially rotten oranges. Then, we decrement the count for fresh oranges  every time we make a fresh orange rotten in the big while loop when we do BFS. If fresh count != 0, we should return -1 in the end because some fresh oranges remain fresh. \\n\\nIf you are interested in more details, you can search up Neetcode\\'s Youtube video about this problem. Although it\\'s in Python, it helps me a lot to understand. Thank you!  \\nhttps://www.youtube.com/watch?v=y704fEOx0s0\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(row * col)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n      int row = grid.size();\\n      int col = grid[0].size();\\n      int time = 0;\\n\\n      // count the total number of fresh oranges so that we can track if every orange goes rotten eventually\\n      int freshCount = 0;\\n      \\n      // store the locations of initially rotten oranges. Later, we will conduct BFS starting from these locations\\n      queue<pair<int, int>> rotOranges;\\n\\n      // update freshCount and rotOranges\\n      for(int r = 0; r < row; r++){\\n        for (int c = 0; c < col; c++){\\n          if(grid[r][c] == 1){\\n            freshCount++;\\n          } else if(grid[r][c] == 2){\\n              rotOranges.push({r, c});\\n            }\\n          } \\n        }\\n\\n      // directions (N, E, S, W) to explore\\n      vector<pair<int, int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n      while(freshCount > 0 && !rotOranges.empty()){\\n        int n = rotOranges.size();\\n        for(int i = 0; i < n; i++){\\n          pair<int, int> toPop = rotOranges.front();\\n          rotOranges.pop();\\n\\n          // check four directions and make neighbors go rotten if possible\\n          for(auto d: directions){\\n            int r = toPop.first + d.first;\\n            int c = toPop.second + d.second;\\n            if(r >= 0 && r < row && c >= 0 && c < col && grid[r][c] == 1){\\n              grid[r][c] = 2;\\n              freshCount--;\\n              rotOranges.push({r, c});\\n            }\\n          }\\n        }\\n        time++;\\n      }\\n\\n      if(freshCount != 0) {\\n        return -1;\\n      }\\n      return time;\\n    }\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n      int row = grid.size();\\n      int col = grid[0].size();\\n      int time = 0;\\n\\n      // count the total number of fresh oranges so that we can track if every orange goes rotten eventually\\n      int freshCount = 0;\\n      \\n      // store the locations of initially rotten oranges. Later, we will conduct BFS starting from these locations\\n      queue<pair<int, int>> rotOranges;\\n\\n      // update freshCount and rotOranges\\n      for(int r = 0; r < row; r++){\\n        for (int c = 0; c < col; c++){\\n          if(grid[r][c] == 1){\\n            freshCount++;\\n          } else if(grid[r][c] == 2){\\n              rotOranges.push({r, c});\\n            }\\n          } \\n        }\\n\\n      // directions (N, E, S, W) to explore\\n      vector<pair<int, int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n      while(freshCount > 0 && !rotOranges.empty()){\\n        int n = rotOranges.size();\\n        for(int i = 0; i < n; i++){\\n          pair<int, int> toPop = rotOranges.front();\\n          rotOranges.pop();\\n\\n          // check four directions and make neighbors go rotten if possible\\n          for(auto d: directions){\\n            int r = toPop.first + d.first;\\n            int c = toPop.second + d.second;\\n            if(r >= 0 && r < row && c >= 0 && c < col && grid[r][c] == 1){\\n              grid[r][c] = 2;\\n              freshCount--;\\n              rotOranges.push({r, c});\\n            }\\n          }\\n        }\\n        time++;\\n      }\\n\\n      if(freshCount != 0) {\\n        return -1;\\n      }\\n      return time;\\n    }\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961474,
                "title": "best-solution-you-can-get",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n\\n# Approach\\nGet the dimensions of the grid (m rows and n columns).\\n\\nCreate a copy of the grid named visited to keep track of the state of each orange (0 for empty, 1 for fresh, and 2 for rotten).\\n\\nInitialize a queue named q to store the coordinates of the initially rotten oranges.\\n\\nInitialize countFreshOrange to keep track of the number of fresh oranges.\\n\\nIterate through the entire grid using two nested loops to:\\n\\nPush the coordinates of rotten oranges into the queue (q).\\nCount the number of fresh oranges and increment countFreshOrange.\\nCheck if there are no fresh oranges (countFreshOrange == 0). If there are none, return 0, as the grid is already in the desired state.\\n\\nCheck if there are no initially rotten oranges in the grid (q.empty()). If so, it\\'s not possible to rot all fresh oranges, and thus return -1.\\n\\nInitialize minutes to -1. This variable will keep track of the time passed as we simulate the rotting process.\\n\\nDefine the four possible directions to move: up, down, left, and right, using the dirs vector.\\n\\nBegin the BFS traversal loop:\\n\\nFor each iteration of the outer loop, process all oranges in the queue that are at the same level of rotting (i.e., were rotten for the same number of minutes).\\nFor each orange in the current level, get its coordinates from the front of the queue.\\nFor each direction in the dirs vector, calculate the new coordinates (i, j) based on the current orange\\'s coordinates (x, y).\\nCheck if the new coordinates are within the grid boundaries and if the orange at those coordinates is fresh (denoted by visited[i][j] == 1).\\nIf the conditions are met, mark the orange as rotten (visited[i][j] = 2), decrement the count of fresh oranges, and push the newly rotten orange into the queue for processing in the next level.\\nAfter processing all oranges at the current level, increment the minutes counter.\\n\\nAfter the BFS traversal is complete, check if there are any remaining fresh oranges. If there are none (countFreshOrange == 0), return the value of minutes, indicating the minimum time taken to rot all oranges.\\n\\nIf there are still fresh oranges left, it means they couldn\\'t be rotten, so return -1 to indicate that it\\'s not possible to rot all oranges.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m * n).\\n\\n\\n- Space complexity:O(m * n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(); // Number of rows in the grid\\n        int n = grid[0].size(); // Number of columns in the grid\\n        \\n        // Create a copy of the grid called \"visited\" to track the state of oranges\\n        vector<vector<int>> visited = grid;\\n        \\n        // Create a queue to store the coordinates of rotten oranges\\n        queue<pair<int, int>> q;\\n        \\n        int countFreshOrange = 0; // Count of fresh oranges\\n        \\n        // Iterate through the grid to populate the queue and count fresh oranges\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.push({i, j}); // Add rotten oranges to the queue\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++; // Count fresh oranges\\n                }\\n            }\\n        }\\n        \\n        // If there are no fresh oranges, return 0 as they are already rotten\\n        if (countFreshOrange == 0)\\n            return 0;\\n        \\n        // If there are no rotten oranges initially, but there are fresh oranges, \\n        // we cannot make them all rotten, so return -1\\n        if (q.empty())\\n            return -1;\\n        \\n        int minutes = -1; // Initialize the time counter\\n        \\n        // Define the four possible directions to move: up, down, left, right\\n        vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\\n        \\n        // Start the BFS traversal of the grid\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) { // Process each level of oranges separately\\n                auto [x, y] = q.front(); // Get the coordinates of the current rotten orange\\n                q.pop();\\n                \\n                // Check all four directions for neighboring fresh oranges\\n                for (auto [dx, dy] : dirs) {\\n                    int i = x + dx; // New row coordinate\\n                    int j = y + dy; // New column coordinate\\n                    \\n                    // Check if the new coordinates are within the grid boundaries\\n                    // and if the orange at the new coordinates is fresh\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2; // Rot the fresh orange\\n                        countFreshOrange--; // Decrement the count of fresh oranges\\n                        q.push({i, j}); // Add the newly rotten orange to the queue\\n                    }\\n                }\\n            }\\n            minutes++; // Increment the time counter after processing each level\\n        }\\n        \\n        // If there are still fresh oranges left, return -1, as they couldn\\'t be rotten\\n        if (countFreshOrange > 0)\\n            return -1;\\n        \\n        return minutes; // Return the total time taken to rot all oranges\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(); // Number of rows in the grid\\n        int n = grid[0].size(); // Number of columns in the grid\\n        \\n        // Create a copy of the grid called \"visited\" to track the state of oranges\\n        vector<vector<int>> visited = grid;\\n        \\n        // Create a queue to store the coordinates of rotten oranges\\n        queue<pair<int, int>> q;\\n        \\n        int countFreshOrange = 0; // Count of fresh oranges\\n        \\n        // Iterate through the grid to populate the queue and count fresh oranges\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.push({i, j}); // Add rotten oranges to the queue\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++; // Count fresh oranges\\n                }\\n            }\\n        }\\n        \\n        // If there are no fresh oranges, return 0 as they are already rotten\\n        if (countFreshOrange == 0)\\n            return 0;\\n        \\n        // If there are no rotten oranges initially, but there are fresh oranges, \\n        // we cannot make them all rotten, so return -1\\n        if (q.empty())\\n            return -1;\\n        \\n        int minutes = -1; // Initialize the time counter\\n        \\n        // Define the four possible directions to move: up, down, left, right\\n        vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\\n        \\n        // Start the BFS traversal of the grid\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) { // Process each level of oranges separately\\n                auto [x, y] = q.front(); // Get the coordinates of the current rotten orange\\n                q.pop();\\n                \\n                // Check all four directions for neighboring fresh oranges\\n                for (auto [dx, dy] : dirs) {\\n                    int i = x + dx; // New row coordinate\\n                    int j = y + dy; // New column coordinate\\n                    \\n                    // Check if the new coordinates are within the grid boundaries\\n                    // and if the orange at the new coordinates is fresh\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2; // Rot the fresh orange\\n                        countFreshOrange--; // Decrement the count of fresh oranges\\n                        q.push({i, j}); // Add the newly rotten orange to the queue\\n                    }\\n                }\\n            }\\n            minutes++; // Increment the time counter after processing each level\\n        }\\n        \\n        // If there are still fresh oranges left, return -1, as they couldn\\'t be rotten\\n        if (countFreshOrange > 0)\\n            return -1;\\n        \\n        return minutes; // Return the total time taken to rot all oranges\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892319,
                "title": "c-bfs-with-explanation",
                "content": "Time Complexity: O(n * m)\\nSpace Complexity: O(n * m)\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int count_fresh_orange = 0;  // Count of fresh oranges\\n        int ans = 0;  // count time\\n\\n        // Queue to store the positions of rotten oranges\\n        queue<pair<int, int>> q;\\n\\n        // Count fresh oranges and enqueue rotten oranges\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    count_fresh_orange++;  // Count the number of fresh oranges\\n                }\\n                else if (grid[i][j] == 2) {\\n                    q.push({i, j});   // Enqueue rotten orange\\n                }\\n            }\\n        }\\n\\n        int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // Possible directions for rotting\\n\\n        // Perform BFS\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {   // If there are 2 rotten oranges, they can rot other fresh oranges simultaneously\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n\\n                for (int i = 0; i < 4; i++) {\\n                    int xi = x + dir[i][0];\\n                    int yi = y + dir[i][1];\\n                    if (xi >= 0 && xi < n && yi >= 0 && yi < m && grid[xi][yi] == 1) {\\n                        count_fresh_orange--;\\n                        grid[xi][yi] = 2;  // Mark the orange as rotten\\n                        q.push({xi, yi});  // Enqueue the newly rotten orange\\n                    }\\n                }\\n            }\\n            ans++;  // Increment time \\n        }\\n\\n        if (count_fresh_orange > 0) {\\n            return -1;  // Not all oranges can be rotten\\n        }\\n\\n        // Subtract 1 from ans since we started counting from 0\\n        return ans > 0 ? ans - 1 : 0;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/f243e411-0738-4df6-87e0-e07e1ff1b12b_1691699262.5035586.webp)\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int count_fresh_orange = 0;  // Count of fresh oranges\\n        int ans = 0;  // count time\\n\\n        // Queue to store the positions of rotten oranges\\n        queue<pair<int, int>> q;\\n\\n        // Count fresh oranges and enqueue rotten oranges\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    count_fresh_orange++;  // Count the number of fresh oranges\\n                }\\n                else if (grid[i][j] == 2) {\\n                    q.push({i, j});   // Enqueue rotten orange\\n                }\\n            }\\n        }\\n\\n        int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // Possible directions for rotting\\n\\n        // Perform BFS\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {   // If there are 2 rotten oranges, they can rot other fresh oranges simultaneously\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n\\n                for (int i = 0; i < 4; i++) {\\n                    int xi = x + dir[i][0];\\n                    int yi = y + dir[i][1];\\n                    if (xi >= 0 && xi < n && yi >= 0 && yi < m && grid[xi][yi] == 1) {\\n                        count_fresh_orange--;\\n                        grid[xi][yi] = 2;  // Mark the orange as rotten\\n                        q.push({xi, yi});  // Enqueue the newly rotten orange\\n                    }\\n                }\\n            }\\n            ans++;  // Increment time \\n        }\\n\\n        if (count_fresh_orange > 0) {\\n            return -1;  // Not all oranges can be rotten\\n        }\\n\\n        // Subtract 1 from ans since we started counting from 0\\n        return ans > 0 ? ans - 1 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868827,
                "title": "c-clean-bfs-solution",
                "content": "# BFS\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();    \\n        int time = 0;\\n\\n        // row, col, time\\n        queue<array<int, 3>> Q;\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] == 2)\\n                    Q.push({r, c, 0});\\n            }\\n        }\\n\\n        int DIR[][2] = { {0, -1}, {1, 0}, {0, 1}, {-1, 0} };\\n\\n        while (!Q.empty()) {\\n            int r = Q.front()[0];\\n            int c = Q.front()[1];\\n            int t = Q.front()[2];\\n            Q.pop();\\n\\n            time = max(time, t);\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + DIR[i][0], nc = c + DIR[i][1];\\n                if (nr < 0 || nc < 0 || nr == m || nc == n || grid[nr][nc] != 1)\\n                    continue;\\n                grid[nr][nc] = 2; // rotten\\n                Q.push({nr, nc, t + 1});\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    return -1;\\n            }\\n        }\\n\\n        return time; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();    \\n        int time = 0;\\n\\n        // row, col, time\\n        queue<array<int, 3>> Q;\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] == 2)\\n                    Q.push({r, c, 0});\\n            }\\n        }\\n\\n        int DIR[][2] = { {0, -1}, {1, 0}, {0, 1}, {-1, 0} };\\n\\n        while (!Q.empty()) {\\n            int r = Q.front()[0];\\n            int c = Q.front()[1];\\n            int t = Q.front()[2];\\n            Q.pop();\\n\\n            time = max(time, t);\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + DIR[i][0], nc = c + DIR[i][1];\\n                if (nr < 0 || nc < 0 || nr == m || nc == n || grid[nr][nc] != 1)\\n                    continue;\\n                grid[nr][nc] = 2; // rotten\\n                Q.push({nr, nc, t + 1});\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    return -1;\\n            }\\n        }\\n\\n        return time; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783534,
                "title": "100-working-java-bfs-algorithm-solution",
                "content": "# Intuition\\nThere are two common approaches to solve this problem: BFS and DFS. Both algorithms are recursive, but they differ in their traversal strategies.\\n\\nDFS (Depth First Search) visits each node as far as possible before backtracking. It explores the deepest levels of the graph, marking nodes as visited. This approach might take longer because it visits every node before completing the traversal.\\n\\nBFS (Breadth First Search) traverses the graph level by level. It moves horizontally to the next level after completing the current level. In this problem, using BFS is more efficient because it allows us to cover more nodes (rotten more oranges) in less time.\\n\\n# Approach\\nTo implement the BFS approach, we can use a Queue data structure to maintain the order of traversal and keep track of visited vertices. We also create a \"visited\" array to store all the visited nodes or rotten oranges.\\n\\nInitially, we add all the initially rotten oranges to the Queue and mark them as visited in the \"visited\" array.\\n\\nTo determine the neighboring nodes or oranges, we maintain two arrays: \"delRow\" and \"delCol\". By adding the corresponding values from these arrays, we can access the neighboring elements of the current node. This process is explained further in the code.\\n\\nWe remove the first node from the Queue and check its neighboring nodes. If a neighboring node is not visited and is a fresh orange, we rot it and mark it as visited.\\n\\nEvery time we rot neighboring oranges, we increment the time.\\n\\nAfter this process, if any fresh oranges remain, we return -1, indicating that it\\'s impossible to rot all the oranges.\\n\\n\\n# Complexity\\n- Time complexity:\\nN*M + (N*M)*4\\n\\n- Space complexity:\\n O(N*M)\\n\\n\\n# Code\\n```\\nclass Pair{\\n    int row;\\n    int col;\\n    int tm;\\n    public Pair(int row, int col, int tm){\\n        this.row = row;\\n        this.col = col;\\n        this.tm = tm;\\n    }\\n}\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int vis[][] = new int[n][m];\\n        Queue<Pair> q = new LinkedList<>();\\n        int cntFresh = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 2){\\n                    q.add(new Pair(i,j,0));\\n                    vis[i][j] = 2;\\n                }else{\\n                    vis[i][j] = 0;\\n                }\\n                if(grid[i][j] == 1){\\n                    cntFresh++;\\n                }\\n            }\\n        }\\n        int tm = 0;\\n        int count = 0;\\n        int delRow[] = {-1, 0, 1, 0};\\n        int delCol[] = {0, 1, 0, -1};\\n        while(!q.isEmpty()){\\n            int row = q.peek().row;\\n            int col = q.peek().col;\\n            int time = q.peek().tm;\\n            tm = Math.max(tm, time);\\n            q.remove();\\n            for(int i=0; i<4; i++){\\n                int nrow = row + delRow[i];\\n                int ncol = col + delCol[i];\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m\\n                && vis[nrow][ncol] == 0 && grid[nrow][ncol] == 1){\\n                    q.add(new Pair(nrow,ncol,tm+1));\\n                    vis[nrow][ncol] = 2;\\n                    count++;\\n                }\\n            }\\n        }\\n        if(cntFresh != count) return -1;\\n        return tm;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Pair{\\n    int row;\\n    int col;\\n    int tm;\\n    public Pair(int row, int col, int tm){\\n        this.row = row;\\n        this.col = col;\\n        this.tm = tm;\\n    }\\n}\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int vis[][] = new int[n][m];\\n        Queue<Pair> q = new LinkedList<>();\\n        int cntFresh = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 2){\\n                    q.add(new Pair(i,j,0));\\n                    vis[i][j] = 2;\\n                }else{\\n                    vis[i][j] = 0;\\n                }\\n                if(grid[i][j] == 1){\\n                    cntFresh++;\\n                }\\n            }\\n        }\\n        int tm = 0;\\n        int count = 0;\\n        int delRow[] = {-1, 0, 1, 0};\\n        int delCol[] = {0, 1, 0, -1};\\n        while(!q.isEmpty()){\\n            int row = q.peek().row;\\n            int col = q.peek().col;\\n            int time = q.peek().tm;\\n            tm = Math.max(tm, time);\\n            q.remove();\\n            for(int i=0; i<4; i++){\\n                int nrow = row + delRow[i];\\n                int ncol = col + delCol[i];\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m\\n                && vis[nrow][ncol] == 0 && grid[nrow][ncol] == 1){\\n                    q.add(new Pair(nrow,ncol,tm+1));\\n                    vis[nrow][ncol] = 2;\\n                    count++;\\n                }\\n            }\\n        }\\n        if(cntFresh != count) return -1;\\n        return tm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731200,
                "title": "easy-to-understand-java-rotten-oranges-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## Why i used BFS here?\\n```\\nA rotten orange can rot fresh orange neighbours that are at a distance of 1 or at the same level. It means each of them got rotten at a similar level or stage, implying we need to visit the same level at the same time. Hence, level-wise traversal is BFS traversal.\\nIf we use DFS traversal then all neighbouring fresh oranges will be visited depth-wise. But here it is not the case to rot all the oranges, we need to find the minimum time to rot them all, which is possible only when we are in neighbouring directions at an equal pace. We want to rotten them simultaneously.\\n\\nSo, BFS traversal will be used to solve this problem.\\n``` \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First i will make a queue storing row, col, time.\\n2. Make a visited array of same length as grid\\n3. traverse in the grid and add all possible rotten oranges in the queue and mark them 2 in visited array and simultaneously count number of frease oranges also.\\n4. delRow & delCol are possible 4 directions index\\n5. loop in the queue utill it will empty and assign row, col, time and add neighbors to the queue and mark them visited in visited array.\\n6. Return answer.\\n\\n# Complexity\\n- Time complexity: $$O(N*M*4)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int r;\\n    int c;\\n    int t;\\n    Pair(int r, int c, int t){\\n        this.r = r;\\n        this.c = c;\\n        this.t = t;\\n    }\\n}\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int ans_time = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        int[][] visited = new int[n][m]; // to mark roten oranges\\n        int cntFreash = 0; // Counting Freash orange\\n\\n        // travers in grid to find out possible position of rotten orange and also count freash oranges\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 2){\\n                    q.add(new Pair(i,j,0));\\n                    visited[i][j] = 2;\\n                }else if(grid[i][j] == 1){\\n                    cntFreash++;\\n                }else{\\n                    visited[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int[] delRow = {-1, 0, +1, 0};\\n        int[] delCol = {0, +1, 0, -1};\\n        int cnt = 0; // keep track of rotten orange\\n        // BFS Traversal\\n        while(!q.isEmpty()){\\n            int row = q.peek().r;\\n            int col = q.peek().c;\\n            int time = q.peek().t;\\n            ans_time = Math.max(ans_time, time);\\n            q.remove();\\n            // now i have to check for neighbours in four directions\\n            for(int i = 0; i < 4; i++){\\n                int nrow = row + delRow[i];\\n                int ncol = col + delCol[i];\\n\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && visited[nrow][ncol] == 0 && \\n                grid[nrow][ncol] == 1){\\n                    q.add(new Pair(nrow, ncol, time + 1));\\n                    visited[nrow][ncol] = 2;\\n                    cnt++;\\n                }   \\n            }\\n        }\\n        \\n        if(cnt != cntFreash) return -1;\\n        return ans_time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nA rotten orange can rot fresh orange neighbours that are at a distance of 1 or at the same level. It means each of them got rotten at a similar level or stage, implying we need to visit the same level at the same time. Hence, level-wise traversal is BFS traversal.\\nIf we use DFS traversal then all neighbouring fresh oranges will be visited depth-wise. But here it is not the case to rot all the oranges, we need to find the minimum time to rot them all, which is possible only when we are in neighbouring directions at an equal pace. We want to rotten them simultaneously.\\n\\nSo, BFS traversal will be used to solve this problem.\\n```\n```\\nclass Pair{\\n    int r;\\n    int c;\\n    int t;\\n    Pair(int r, int c, int t){\\n        this.r = r;\\n        this.c = c;\\n        this.t = t;\\n    }\\n}\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int ans_time = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        int[][] visited = new int[n][m]; // to mark roten oranges\\n        int cntFreash = 0; // Counting Freash orange\\n\\n        // travers in grid to find out possible position of rotten orange and also count freash oranges\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 2){\\n                    q.add(new Pair(i,j,0));\\n                    visited[i][j] = 2;\\n                }else if(grid[i][j] == 1){\\n                    cntFreash++;\\n                }else{\\n                    visited[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int[] delRow = {-1, 0, +1, 0};\\n        int[] delCol = {0, +1, 0, -1};\\n        int cnt = 0; // keep track of rotten orange\\n        // BFS Traversal\\n        while(!q.isEmpty()){\\n            int row = q.peek().r;\\n            int col = q.peek().c;\\n            int time = q.peek().t;\\n            ans_time = Math.max(ans_time, time);\\n            q.remove();\\n            // now i have to check for neighbours in four directions\\n            for(int i = 0; i < 4; i++){\\n                int nrow = row + delRow[i];\\n                int ncol = col + delCol[i];\\n\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && visited[nrow][ncol] == 0 && \\n                grid[nrow][ncol] == 1){\\n                    q.add(new Pair(nrow, ncol, time + 1));\\n                    visited[nrow][ncol] = 2;\\n                    cnt++;\\n                }   \\n            }\\n        }\\n        \\n        if(cnt != cntFreash) return -1;\\n        return ans_time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703665,
                "title": "easy-to-understand-c-using-two-stacks-queue-alternative-bfs",
                "content": "**Approach**\\nIn this approach, i have used 2 stacks s1 and s2 to implement the solution. Stack s1 stores the oraanges to be rotten. Then, those oranges are transferred to stack s2 which calls the solve function to rot any neighbouring oranges if there.\\nFirstly, the grid is iterated over to find if there any rotten oranges using ```if(grid[i][j]==2)``` and if present, they are pushed to stack s1. Now, we check for the base case when all the cells are empty using ```if(s1.empty() and !ones)``` and if true return 0. Then until s1 is not empty, we increment minutes, and empty s1 by marking those oranges as rotten and push them to s2.\\n(Why empty s1? Because when we call solve function from the contents of s2, the neighbouring fresh oranges will be pushed into s1. So, we need to make sure s1 is empty so that the next top element from s1 would be an orange that got rotten in the next minute only.)\\nNow, we emtpy s2 by calling solve function to push into s1 the neighbouring oranges that are fresh but will get rotten in the next minute due to the parent rotten orange.\\nWhen s1 is finally empty, it is because no other oranges could get rotten anymore. Which gives way to 2 cases -\\n1. All oranges got rotten.\\n2. There are some oranges which didn\\'t get rotten.\\n\\nSo, we check for the later case by iterating through grid to find a fresh orange using ```if(grid[i][j]==1)``` and if true, we return -1 meaning all oranges couldn\\'t get rotten. If false, we return ```minutes-1``` as minutes gets incremented once even after all oranges gor rotten for the final iteration when s1 is empty after all the solve function calls from elements in s2.\\n\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    stack<pair<int,int>> s1,s2;\\n    \\n    bool valid(int i,int j,vector<vector<int>>& grid){\\n        if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or grid[i][j]==0)return false;\\n        return true;\\n    }\\n    void solve(int i,int j,vector<vector<int>>& grid){\\n        \\n        if(valid(i+1,j,grid) and grid[i+1][j]==1)\\n            s1.push({i+1,j});\\n        if(valid(i-1,j,grid) and grid[i-1][j]==1)\\n            s1.push({i-1,j});\\n        if(valid(i,j-1,grid) and grid[i][j-1]==1)\\n            s1.push({i,j-1});\\n        if(valid(i,j+1,grid) and grid[i][j+1]==1)\\n            s1.push({i,j+1});\\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        bool ones=false;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==2)\\n                    s1.push({i,j});\\n                if(grid[i][j]==1)\\n                    ones=true;\\n            }\\n        }\\n        if(s1.empty() and !ones)return 0;\\n        int minutes=0;\\n        \\n        while(!s1.empty()){\\n            minutes++;\\n            \\n            while(!s1.empty()){\\n                grid[s1.top().first][s1.top().second]=2;\\n                s2.push(s1.top());\\n                s1.pop();\\n            }\\n            \\n            while(!s2.empty()){\\n                solve(s2.top().first,s2.top().second,grid);\\n                s2.pop();\\n            }\\n        }\\n        \\n         for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        \\n        return minutes-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Breadth-First Search"
                ],
                "code": "```if(grid[i][j]==2)```\n```if(s1.empty() and !ones)```\n```if(grid[i][j]==1)```\n```minutes-1```\n```\\nclass Solution {\\npublic:\\n    stack<pair<int,int>> s1,s2;\\n    \\n    bool valid(int i,int j,vector<vector<int>>& grid){\\n        if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or grid[i][j]==0)return false;\\n        return true;\\n    }\\n    void solve(int i,int j,vector<vector<int>>& grid){\\n        \\n        if(valid(i+1,j,grid) and grid[i+1][j]==1)\\n            s1.push({i+1,j});\\n        if(valid(i-1,j,grid) and grid[i-1][j]==1)\\n            s1.push({i-1,j});\\n        if(valid(i,j-1,grid) and grid[i][j-1]==1)\\n            s1.push({i,j-1});\\n        if(valid(i,j+1,grid) and grid[i][j+1]==1)\\n            s1.push({i,j+1});\\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        bool ones=false;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==2)\\n                    s1.push({i,j});\\n                if(grid[i][j]==1)\\n                    ones=true;\\n            }\\n        }\\n        if(s1.empty() and !ones)return 0;\\n        int minutes=0;\\n        \\n        while(!s1.empty()){\\n            minutes++;\\n            \\n            while(!s1.empty()){\\n                grid[s1.top().first][s1.top().second]=2;\\n                s2.push(s1.top());\\n                s1.pop();\\n            }\\n            \\n            while(!s2.empty()){\\n                solve(s2.top().first,s2.top().second,grid);\\n                s2.pop();\\n            }\\n        }\\n        \\n         for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        \\n        return minutes-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679126,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<pair<int,int>,int>> q;\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j] = 2;\\n                }\\n            }\\n        }\\n        int tm = 0;\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n        while(!q.empty()){\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            tm = max(tm,t);\\n            for(int i=0;i<4;i++){\\n                int nrow = r + drow[i];\\n                int ncol = c + dcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]!=2\\n                      && grid[nrow][ncol] == 1)\\n                {\\n                    q.push({{nrow,ncol},t+1});\\n                    vis[nrow][ncol] = 2;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1 && vis[i][j] != 2) return -1;\\n            }\\n        }\\n        return tm;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<pair<int,int>,int>> q;\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j] = 2;\\n                }\\n            }\\n        }\\n        int tm = 0;\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n        while(!q.empty()){\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            tm = max(tm,t);\\n            for(int i=0;i<4;i++){\\n                int nrow = r + drow[i];\\n                int ncol = c + dcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]!=2\\n                      && grid[nrow][ncol] == 1)\\n                {\\n                    q.push({{nrow,ncol},t+1});\\n                    vis[nrow][ncol] = 2;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1 && vis[i][j] != 2) return -1;\\n            }\\n        }\\n        return tm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490056,
                "title": "c-code-begginer-friendly-100-best",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\n    int bfs(queue<pair<int, int>> que, vector<vector<int>> &grid, int r[], int c[]){\\n        int time = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        while(!que.empty()){\\n            int size = que.size();\\n            bool isRotten = false;  // if rotten oranges can\\'t rotten any oranges\\n\\n            for(int i=0; i<size; i++){\\n                int row = que.front().first;\\n                int col = que.front().second;\\n\\n                que.pop();\\n\\n                for(int i=0; i<4; i++){\\n                    int nr = row + r[i];\\n                    int nc = col + c[i];\\n\\n                    if(nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc] == 1){\\n                        isRotten = true;\\n                        grid[nr][nc] = 2;\\n                        que.push({nr,nc});\\n                    } \\n                }\\n            }\\n\\n            if(isRotten) time++;\\n        }\\n\\n        return time;\\n    }\\n\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int, int>> que;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // checking the rotten oranges in the grid the pushing it to que\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 2){\\n                    que.push({i,j});\\n                }\\n            }\\n        }\\n\\n        int r[4] = {-1, 1, 0, 0};\\n        int c[4] = {0, 0, -1, 1}; \\n\\n        int rottenTime = bfs(que, grid, r, c);\\n\\n        // checking if any not rotten oranges left, if yes then returning -1\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 1) return -1;\\n            }\\n        }\\n\\n        return rottenTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    int bfs(queue<pair<int, int>> que, vector<vector<int>> &grid, int r[], int c[]){\\n        int time = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        while(!que.empty()){\\n            int size = que.size();\\n            bool isRotten = false;  // if rotten oranges can\\'t rotten any oranges\\n\\n            for(int i=0; i<size; i++){\\n                int row = que.front().first;\\n                int col = que.front().second;\\n\\n                que.pop();\\n\\n                for(int i=0; i<4; i++){\\n                    int nr = row + r[i];\\n                    int nc = col + c[i];\\n\\n                    if(nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc] == 1){\\n                        isRotten = true;\\n                        grid[nr][nc] = 2;\\n                        que.push({nr,nc});\\n                    } \\n                }\\n            }\\n\\n            if(isRotten) time++;\\n        }\\n\\n        return time;\\n    }\\n\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int, int>> que;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // checking the rotten oranges in the grid the pushing it to que\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 2){\\n                    que.push({i,j});\\n                }\\n            }\\n        }\\n\\n        int r[4] = {-1, 1, 0, 0};\\n        int c[4] = {0, 0, -1, 1}; \\n\\n        int rottenTime = bfs(que, grid, r, c);\\n\\n        // checking if any not rotten oranges left, if yes then returning -1\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 1) return -1;\\n            }\\n        }\\n\\n        return rottenTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375216,
                "title": "well-commented-c-code-using-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int vis[n][m];\\n        // queue will store coordinates and corresponding time\\n        queue<pair<pair<int, int>, int>> q;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 2){\\n                    // initial vertices will be the rotten ones\\n                    q.push({{i,j}, 0});\\n                    vis[i][j] = 2;\\n                }\\n            }\\n        }\\n\\n        // initializing directions for bfs traversal\\n        int dx[] = {-1,0,1,0};\\n        int dy[] = {0,-1,0,1};\\n        int time = 0;\\n\\n        while(!q.empty())\\n        {\\n            int r = q.front().first.first, c = q.front().first.second, t = q.front().second;\\n            time = max(time, t);\\n            q.pop();\\n            for(int i = 0; i < 4; i++){\\n                int nrow = r + dx[i], ncol = c + dy[i];\\n                // if all conditions satisfy then push the neighbouring row, col into the queue\\n                // while also updating the time and vis\\n                if (nrow >= 0 && ncol >= 0 && nrow < n && ncol < m && vis[nrow][ncol] != 2 && grid[nrow][ncol] == 1)\\n                {\\n                    q.push({{nrow, ncol}, t + 1});\\n                    vis[nrow][ncol] = 2;\\n                }\\n            }\\n        }\\n\\n        // in the end check for the -1 case\\n        // this happens when for any (i,j) vis != 2 and the grid val = 1\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(vis[i][j] != 2 && grid[i][j] == 1){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int vis[n][m];\\n        // queue will store coordinates and corresponding time\\n        queue<pair<pair<int, int>, int>> q;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 2){\\n                    // initial vertices will be the rotten ones\\n                    q.push({{i,j}, 0});\\n                    vis[i][j] = 2;\\n                }\\n            }\\n        }\\n\\n        // initializing directions for bfs traversal\\n        int dx[] = {-1,0,1,0};\\n        int dy[] = {0,-1,0,1};\\n        int time = 0;\\n\\n        while(!q.empty())\\n        {\\n            int r = q.front().first.first, c = q.front().first.second, t = q.front().second;\\n            time = max(time, t);\\n            q.pop();\\n            for(int i = 0; i < 4; i++){\\n                int nrow = r + dx[i], ncol = c + dy[i];\\n                // if all conditions satisfy then push the neighbouring row, col into the queue\\n                // while also updating the time and vis\\n                if (nrow >= 0 && ncol >= 0 && nrow < n && ncol < m && vis[nrow][ncol] != 2 && grid[nrow][ncol] == 1)\\n                {\\n                    q.push({{nrow, ncol}, t + 1});\\n                    vis[nrow][ncol] = 2;\\n                }\\n            }\\n        }\\n\\n        // in the end check for the -1 case\\n        // this happens when for any (i,j) vis != 2 and the grid val = 1\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(vis[i][j] != 2 && grid[i][j] == 1){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354232,
                "title": "c-easy-and-understanding-solution-with-bfs",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        Queue<IList<int>> rottenOranges = new Queue<IList<int>>();\\n        int time = 0, freshOranges = 0;\\n\\n        int rows = grid.Length, cols = grid[0].Length;\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                if(grid[row][col] == 1) freshOranges++;\\n                else if(grid[row][col] == 2) rottenOranges.Enqueue(new List<int> { row, col });\\n            }\\n        }\\n\\n        var directions = new List<IList<int>> {\\n            new List<int> { 1, 0 },\\n            new List<int> { -1, 0 },\\n            new List<int> { 0, 1 },\\n            new List<int> { 0, -1 }\\n        };\\n        while(rottenOranges.Count > 0 && freshOranges > 0) {\\n            int size = rottenOranges.Count;\\n\\n            for(int ind = 0; ind < size; ind++) {\\n                var inds = rottenOranges.Dequeue();\\n                int row = inds[0];\\n                int col = inds[1];\\n\\n                foreach(var dir in directions) {\\n                    int rowInd = row + dir[0];\\n                    int colInd = col + dir[1];\\n\\n                    if(rowInd < 0 || rowInd >= rows ||\\n                       colInd < 0 || colInd >= cols ||\\n                       grid[rowInd][colInd] != 1) continue;\\n\\n                    grid[rowInd][colInd] = 2;\\n                    rottenOranges.Enqueue(new List<int> { rowInd, colInd });\\n                    freshOranges--;\\n                }\\n            }\\n\\n            time++;\\n        }\\n\\n        return freshOranges == 0 ? time : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        Queue<IList<int>> rottenOranges = new Queue<IList<int>>();\\n        int time = 0, freshOranges = 0;\\n\\n        int rows = grid.Length, cols = grid[0].Length;\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                if(grid[row][col] == 1) freshOranges++;\\n                else if(grid[row][col] == 2) rottenOranges.Enqueue(new List<int> { row, col });\\n            }\\n        }\\n\\n        var directions = new List<IList<int>> {\\n            new List<int> { 1, 0 },\\n            new List<int> { -1, 0 },\\n            new List<int> { 0, 1 },\\n            new List<int> { 0, -1 }\\n        };\\n        while(rottenOranges.Count > 0 && freshOranges > 0) {\\n            int size = rottenOranges.Count;\\n\\n            for(int ind = 0; ind < size; ind++) {\\n                var inds = rottenOranges.Dequeue();\\n                int row = inds[0];\\n                int col = inds[1];\\n\\n                foreach(var dir in directions) {\\n                    int rowInd = row + dir[0];\\n                    int colInd = col + dir[1];\\n\\n                    if(rowInd < 0 || rowInd >= rows ||\\n                       colInd < 0 || colInd >= cols ||\\n                       grid[rowInd][colInd] != 1) continue;\\n\\n                    grid[rowInd][colInd] = 2;\\n                    rottenOranges.Enqueue(new List<int> { rowInd, colInd });\\n                    freshOranges--;\\n                }\\n            }\\n\\n            time++;\\n        }\\n\\n        return freshOranges == 0 ? time : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196790,
                "title": "c-using-bfs-beats-100-t-c-o-n-2-s-c-o-n-2",
                "content": "```\\nclass Solution {\\n\\t/*\\n\\t\\tTime Complexity : O(N^2)\\n\\t\\tSpace Complexity : O(N^2)\\n\\t*/\\n    \\n\\tint m, n;\\n    \\n    bool isValid(int i, int j){\\n        if(i>=0 && i<m && j>=0 && j<n) return true;\\n        return false;\\n    }\\n    \\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        int freshOranges = 0;\\n        queue<pair<int, int>> q1;\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1){\\n                    freshOranges++;\\n                }else if(grid[i][j] == 2){\\n                    q1.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        vector<int> x = {+1, -1, 0, 0};\\n        vector<int> y = {0, 0, +1, -1};\\n        \\n        int time = 0;\\n        \\n        while(!q1.empty()){\\n            int size = q1.size();\\n            \\n            while(size--){\\n                pair<int, int> curr = q1.front();\\n                q1.pop();\\n                \\n                for(int k=0; k<4; k++){\\n                    int newX = curr.first + x[k];\\n                    int newY = curr.second + y[k];\\n                    \\n                    if(isValid(newX, newY) && grid[newX][newY] == 1){\\n                        grid[newX][newY] = 2;\\n                        q1.push({newX, newY});\\n                        freshOranges--;\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        if(freshOranges > 0) return -1;\\n        return --time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\t/*\\n\\t\\tTime Complexity : O(N^2)\\n\\t\\tSpace Complexity : O(N^2)\\n\\t*/\\n    \\n\\tint m, n;\\n    \\n    bool isValid(int i, int j){\\n        if(i>=0 && i<m && j>=0 && j<n) return true;\\n        return false;\\n    }\\n    \\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        int freshOranges = 0;\\n        queue<pair<int, int>> q1;\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1){\\n                    freshOranges++;\\n                }else if(grid[i][j] == 2){\\n                    q1.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        vector<int> x = {+1, -1, 0, 0};\\n        vector<int> y = {0, 0, +1, -1};\\n        \\n        int time = 0;\\n        \\n        while(!q1.empty()){\\n            int size = q1.size();\\n            \\n            while(size--){\\n                pair<int, int> curr = q1.front();\\n                q1.pop();\\n                \\n                for(int k=0; k<4; k++){\\n                    int newX = curr.first + x[k];\\n                    int newY = curr.second + y[k];\\n                    \\n                    if(isValid(newX, newY) && grid[newX][newY] == 1){\\n                        grid[newX][newY] = 2;\\n                        q1.push({newX, newY});\\n                        freshOranges--;\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        if(freshOranges > 0) return -1;\\n        return --time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158808,
                "title": "c-easytounderstand-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep (coordinates,time) in queue and do BFS \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncollect all rotten apples first with time=0 in queue and change them to taken bt changing their grid[i][j] to 0(suppose)\\n\\nnow start performing BFS by pushing all 4 direction apples which are not rotten and mark them taken by changing their grid[i][j] to 0(suppose)\\n\\nfind maximum value of time and return it\\n# Complexity\\n- Time complexity:O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(mn) (queue)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid){\\n        int ans=0;\\n\\n        queue<vector<int>> q;\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        bool all0=true;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0) all0=false;\\n                if(grid[i][j]==2){\\n                    q.push({i,j,0});\\n                    grid[i][j]=0;\\n                }\\n            }\\n        }\\n        if(all0) return 0;\\n        if(q.empty()) return -1;\\n     \\n        while(!q.empty()){\\n            auto v=q.front();\\n            int i=v[0], j=v[1];\\n\\n            if(i+1<m && grid[i+1][j]==1){\\n                q.push({i+1,j,v[2]+1});\\n                grid[i+1][j]=0;\\n            }\\n            if(i-1>=0 && grid[i-1][j]==1){\\n                q.push({i-1,j,v[2]+1});\\n                grid[i-1][j]=0;\\n            }\\n            if(j+1<n && grid[i][j+1]==1){\\n                q.push({i,j+1,v[2]+1});\\n                grid[i][j+1]=0;\\n            }\\n            if(j-1>=0 && grid[i][j-1]==1){\\n                q.push({i,j-1,v[2]+1});\\n                grid[i][j-1]=0;\\n            }\\n            ans=max(ans,v[2]);\\n            q.pop(); \\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid){\\n        int ans=0;\\n\\n        queue<vector<int>> q;\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        bool all0=true;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0) all0=false;\\n                if(grid[i][j]==2){\\n                    q.push({i,j,0});\\n                    grid[i][j]=0;\\n                }\\n            }\\n        }\\n        if(all0) return 0;\\n        if(q.empty()) return -1;\\n     \\n        while(!q.empty()){\\n            auto v=q.front();\\n            int i=v[0], j=v[1];\\n\\n            if(i+1<m && grid[i+1][j]==1){\\n                q.push({i+1,j,v[2]+1});\\n                grid[i+1][j]=0;\\n            }\\n            if(i-1>=0 && grid[i-1][j]==1){\\n                q.push({i-1,j,v[2]+1});\\n                grid[i-1][j]=0;\\n            }\\n            if(j+1<n && grid[i][j+1]==1){\\n                q.push({i,j+1,v[2]+1});\\n                grid[i][j+1]=0;\\n            }\\n            if(j-1>=0 && grid[i][j-1]==1){\\n                q.push({i,j-1,v[2]+1});\\n                grid[i][j-1]=0;\\n            }\\n            ans=max(ans,v[2]);\\n            q.pop(); \\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073064,
                "title": "c-solution-using-bfs-graphs",
                "content": "\\n\\t\\n\\tint orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n       \\n        queue<pair<pair<int,int>,int>>q; \\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        \\n        for (int i = 0; i < n; i++) \\n        {\\n            for (int j = 0; j < m; j++) \\n            {\\n                if (grid[i][j] == 2) \\n                {\\n                    q.push({{i, j}, 0}); \\n                    vis[i][j] = 2;\\n                }\\n                else \\n                    vis[i][j] = 0;\\n            }\\n        }\\n        \\n        vector<vector<int>>d={{-1,0},{0,-1},{1,0},{0,1}};\\n        int time=0;\\n        \\n        while (!q.empty())\\n        {\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            \\n            time=max(time,t);\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int nr=r+d[i][0];\\n                int nc=c+d[i][1];\\n                \\n                        if(nr<n && nc<m && nr>=0 && nc>=0 && grid[nr][nc]==1 &&vis[nr][nc]!=2)\\n                {\\n                    q.push({{nr,nc},t+1});\\n                    vis[nr][nc]=2;\\n                }\\n                    \\n            }   \\n        }\\n        \\n        \\n        for (int i = 0; i < n; i++) \\n        {\\n            for (int j = 0; j < m; j++) \\n            {\\n                if(vis[i][j]!=2 && grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        return time;    \\n    }\\n\\t\\n# \\tPlease Upvote if you find it helpful",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "\\n\\t\\n\\tint orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n       \\n        queue<pair<pair<int,int>,int>>q; \\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        \\n        for (int i = 0; i < n; i++) \\n        {\\n            for (int j = 0; j < m; j++) \\n            {\\n                if (grid[i][j] == 2) \\n                {\\n                    q.push({{i, j}, 0}); \\n                    vis[i][j] = 2;\\n                }\\n                else \\n                    vis[i][j] = 0;\\n            }\\n        }\\n        \\n        vector<vector<int>>d={{-1,0},{0,-1},{1,0},{0,1}};\\n        int time=0;\\n        \\n        while (!q.empty())\\n        {\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            \\n            time=max(time,t);\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int nr=r+d[i][0];\\n                int nc=c+d[i][1];\\n                \\n                        if(nr<n && nc<m && nr>=0 && nc>=0 && grid[nr][nc]==1 &&vis[nr][nc]!=2)\\n                {\\n                    q.push({{nr,nc},t+1});\\n                    vis[nr][nc]=2;\\n                }\\n                    \\n            }   \\n        }\\n        \\n        \\n        for (int i = 0; i < n; i++) \\n        {\\n            for (int j = 0; j < m; j++) \\n            {\\n                if(vis[i][j]!=2 && grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        return time;    \\n    }\\n\\t\\n# \\tPlease Upvote if you find it helpful",
                "codeTag": "Unknown"
            },
            {
                "id": 2963373,
                "title": "c-easy-bfs-graph-traversal-clean-easy-code",
                "content": "![image](https://assets.leetcode.com/users/images/0cd3b45b-05cd-4555-95a5-77cd3f8ea552_1672237797.2517793.png)\\n\\n**T->O(4 X nm) ~ O(nm) && S->O(nm)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<pair<int,int>> dir={{-1,0},{1,0},{0,1},{0,-1}};\\n\\t\\t\\tint orangesRotting(vector<vector<int>>& grid) {\\n\\t\\t\\t\\tint n=grid.size();\\n\\t\\t\\t\\tint m=grid[0].size();\\n\\t\\t\\t\\tvector<vector<int>> vis(n,vector<int>(m,0));\\n\\t\\t//      {{r,c},t}\\n\\t\\t\\t\\tqueue<pair<pair<int,int>,int>>q;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\t\\t\\t\\tif(grid[i][j]==2){\\n\\t\\t\\t\\t\\t\\t\\tq.push({{i,j},0});\\n\\t\\t\\t\\t\\t\\t\\tvis[i][j]=2;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint time=0;\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tauto node=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tint t=node.second;\\n\\t\\t\\t\\t\\ttime=max(time,t);\\n\\t\\t\\t\\t\\tfor(auto d:dir){\\n\\t\\t\\t\\t\\t\\tint new_r=node.first.first+d.first;\\n\\t\\t\\t\\t\\t\\tint new_c=node.first.second+d.second;\\n\\t\\t\\t\\t\\t\\tif(new_r<n && new_r>=0 && new_c<m && new_c>=0 && vis[new_r][new_c]!=2 && grid[new_r][new_c]==1){\\n\\t\\t\\t\\t\\t\\t\\tq.push({{new_r,new_c},t+1});\\n\\t\\t\\t\\t\\t\\t\\tvis[new_r][new_c]=2;\\n\\t\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\t\\t\\t\\tif(grid[i][j]==1 && vis[i][j]!=2) return -1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn time;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<pair<int,int>> dir={{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2893338,
                "title": "c-solution-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        queue<pair<int,int>> q;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){ // push all rotten oranges\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        int time=0;\\n        vector<pair<int,int>> validmove={{1,0},{-1,0},{0,-1},{0,1}};\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            bool is_any_rotten=false;\\n            for(int i=0;i<size;i++){\\n\\n                auto p=q.front();\\n                q.pop();\\n                int x1=p.first;\\n                int y1=p.second;\\n\\n                for(int k=0;k<4;k++){\\n                    int x=x1+validmove[k].first;\\n                    int y=y1+validmove[k].second;\\n                    if(x<0 || x>=m || y<0 || y>=n || grid[x][y]!=1){\\n                        continue;\\n                    }\\n                \\n                    is_any_rotten=true;\\n                    grid[x][y]=2;\\n                    q.push({x,y});\\n                }\\n                \\n            }\\n            if(is_any_rotten)\\n                time++;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){ // checking is any fresh oraneg reamin\\n                   return -1;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        queue<pair<int,int>> q;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){ // push all rotten oranges\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        int time=0;\\n        vector<pair<int,int>> validmove={{1,0},{-1,0},{0,-1},{0,1}};\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            bool is_any_rotten=false;\\n            for(int i=0;i<size;i++){\\n\\n                auto p=q.front();\\n                q.pop();\\n                int x1=p.first;\\n                int y1=p.second;\\n\\n                for(int k=0;k<4;k++){\\n                    int x=x1+validmove[k].first;\\n                    int y=y1+validmove[k].second;\\n                    if(x<0 || x>=m || y<0 || y>=n || grid[x][y]!=1){\\n                        continue;\\n                    }\\n                \\n                    is_any_rotten=true;\\n                    grid[x][y]=2;\\n                    q.push({x,y});\\n                }\\n                \\n            }\\n            if(is_any_rotten)\\n                time++;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){ // checking is any fresh oraneg reamin\\n                   return -1;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881317,
                "title": "c-bfs-easy-intuitive-solution",
                "content": "**INTUITION**\\n\\n\\u2705Firstly we create a queue which store the indices of the rotten oranges.\\n\\u2705Then for each entry in queue if any fresh orange is present we mark it as rotten. And push it in our queue\\n\\u2705Then the number of times it runs is the number of elapses it take to make all fresh oranges to rotten. \\n\\u2705If queue becomes empty and our fresh oranges remained in the grid then we return -1 as it is impossible to make those fresh oranges to rotten\\n\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int fresh=0,time_elapse=0;\\n        vector<int>offset={0,1,0,-1,0}; /// for traversing up down left right in grid\\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1)fresh++;\\n                else if(grid[i][j]==2)q.push({i,j});\\n            }\\n        }\\n        \\n        while(q.size() && fresh){\\n            time_elapse++;\\n            int n=q.size();\\n            \\n            for(int i=0;i<n;i++){\\n                \\n                auto [r,c]=q.front();q.pop();\\n                \\n                for(int j=0;j<4;j++){\\n                    int nr=r+offset[j],nc=c+offset[j+1];\\n                    if(nr<0 || nc<0 || nr>=grid.size() || nc>=grid[0].size() || grid[nr][nc]!=1)continue;\\n                    fresh--;\\n                    grid[nr][nc]=2;\\n                    q.push({nr,nc});\\n                }\\n                \\n            }\\n            \\n        }\\n        return fresh?-1:time_elapse;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int fresh=0,time_elapse=0;\\n        vector<int>offset={0,1,0,-1,0}; /// for traversing up down left right in grid\\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1)fresh++;\\n                else if(grid[i][j]==2)q.push({i,j});\\n            }\\n        }\\n        \\n        while(q.size() && fresh){\\n            time_elapse++;\\n            int n=q.size();\\n            \\n            for(int i=0;i<n;i++){\\n                \\n                auto [r,c]=q.front();q.pop();\\n                \\n                for(int j=0;j<4;j++){\\n                    int nr=r+offset[j],nc=c+offset[j+1];\\n                    if(nr<0 || nc<0 || nr>=grid.size() || nc>=grid[0].size() || grid[nr][nc]!=1)continue;\\n                    fresh--;\\n                    grid[nr][nc]=2;\\n                    q.push({nr,nc});\\n                }\\n                \\n            }\\n            \\n        }\\n        return fresh?-1:time_elapse;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849762,
                "title": "dfs-recursion-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid,int i,int j,int min){ \\nif(i<0 || j<0 || j>grid[0].size()-1 || i>grid.size()-1 ||  grid[i][j]==0 ||(1<grid[i][j] && grid[i][j]<min)){\\n            return ;\\n        }\\n          grid[i][j]=min;                                                                                          \\n       dfs(grid,i+1,j,min+1); \\n       dfs(grid,i,j+1,min+1); \\n       dfs(grid,i-1,j,min+1); \\n       dfs(grid,i,j-1,min+1);                                                                                                                          \\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int min=2;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(n==1 && m==1){\\n            if(grid[0][0]==1){\\n                return -1;\\n            }\\n             if(grid[0][0]==0){\\n                return 0;\\n            }\\n             if(grid[0][0]==2){\\n                return 0;\\n            }\\n        }\\n       \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    dfs(grid,i,j,min);\\n                }\\n            }\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    return -1;\\n                }\\n               maxi=max(maxi,grid[i][j]); \\n              \\n            }\\n        }\\n       \\n        if(maxi==0){\\n            return 0;\\n        }\\n        return  maxi-2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid,int i,int j,int min){ \\nif(i<0 || j<0 || j>grid[0].size()-1 || i>grid.size()-1 ||  grid[i][j]==0 ||(1<grid[i][j] && grid[i][j]<min)){\\n            return ;\\n        }\\n          grid[i][j]=min;                                                                                          \\n       dfs(grid,i+1,j,min+1); \\n       dfs(grid,i,j+1,min+1); \\n       dfs(grid,i-1,j,min+1); \\n       dfs(grid,i,j-1,min+1);                                                                                                                          \\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int min=2;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(n==1 && m==1){\\n            if(grid[0][0]==1){\\n                return -1;\\n            }\\n             if(grid[0][0]==0){\\n                return 0;\\n            }\\n             if(grid[0][0]==2){\\n                return 0;\\n            }\\n        }\\n       \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    dfs(grid,i,j,min);\\n                }\\n            }\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    return -1;\\n                }\\n               maxi=max(maxi,grid[i][j]); \\n              \\n            }\\n        }\\n       \\n        if(maxi==0){\\n            return 0;\\n        }\\n        return  maxi-2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793051,
                "title": "fully-explained-cpp-solution",
                "content": "# Intuition\\nWe have to do level order traversal on the indices with rotten oranges and increase the time accordingly.\\n**Why BFS?**\\nBecause BFS will give the minimum time as asked in question and we have to travel level wise simultaneously.\\n\\n\\n# Approach\\n1. Find out the indices of element with value = 2(rotten oranges), push them into queue, also add time = 0, initially.\\n```\\nqueue<pair<pair<int, int>, int>> q;\\nif(grid[i][j] == 2)\\n    q.push({{i, j}, 0});\\n```\\nAlso, take a visited matrix and initialze it with values of grid matrix. \\n\\n2. Until queue become empty, \\n- Store the front element of the queue, and pop it.\\n- For that particular element, traverse in four directions and add those indices to the queue if *it is in the range of size, index is not empty i.e. != 0 and it is not already rotted i.e it is != 2*.\\n- While adding it to the queue, increase the timings by 1 and marks that index as 2 in visited matrix i.e it is rotten by that time.\\n```\\nq.push({{newRow, newCol}, time+1});\\n    visited[newRow][newCol] = 2;\\n```\\n\\n\\n3. Check if the visited matrix still contains any fresh oranges i.e value is 1 , return -1 because after traversing it cant be rotted. Otherwise return the time.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(m x n)\\n\\n- Space complexity:\\nO(m x n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        //pair of pair for marking indices and time simulateneously\\n        queue<pair<pair<int, int>, int>> q;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n//It is important to calculate the number of times fresh  oranges occur in the grid. \\n//If there is no fresh oranges simply return 0. \\n//IF there are no rotten eggs, then return -1. \\n        int count_of_one = 0;\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0; j < cols; j++)\\n            {\\n                if(grid[i][j] == 2)\\n                    q.push({{i, j}, 0});\\n                if(grid[i][j] == 1)\\n                    count_of_one++;\\n            }\\n        }\\n        if(count_of_one == 0) return 0;\\n        if(q.empty()) return -1;\\n//make a visited matrix. Initialize it with elements of grid.\\n        vector<vector<int>> visited(rows, vector<int>(cols, 0));\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0; j < cols; j++)\\n            {\\n                visited[i][j] = grid[i][j];\\n            }\\n        }\\n//to travel in 4 directions we will use two arrays\\n        int delRow[] = {-1, 0, 1, 0};\\n        int delCol[] = {0, 1, 0, -1};\\n\\n//NOW perform BFS on the grid, because we need a level order traversal\\n        int time = 0;\\n        while(!q.empty())\\n        {\\n            pair<pair<int, int>, int> p = q.front();\\n            q.pop();\\n            pair<int, int> index = p.first;\\n            time = p.second;\\n\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int newRow = delRow[i] + index.first;\\n                int newCol = delCol[i] + index.second;\\n\\n                if(newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && visited[newRow][newCol] != 2 && visited[newRow][newCol] != 0)\\n                {\\n                    q.push({{newRow, newCol}, time+1});\\n                    visited[newRow][newCol] = 2;\\n                }\\n            }\\n        }\\n//if there is still any 1 in the visited matrix, then it is because some fresh oranges are still left. So return -1 in this case.\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0;  j < cols; j++)\\n            {\\n                if(visited[i][j] == 1)\\n                    return -1;\\n            }\\n        }\\n//otherwise return time.\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nqueue<pair<pair<int, int>, int>> q;\\nif(grid[i][j] == 2)\\n    q.push({{i, j}, 0});\\n```\n```\\nq.push({{newRow, newCol}, time+1});\\n    visited[newRow][newCol] = 2;\\n```\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        //pair of pair for marking indices and time simulateneously\\n        queue<pair<pair<int, int>, int>> q;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n//It is important to calculate the number of times fresh  oranges occur in the grid. \\n//If there is no fresh oranges simply return 0. \\n//IF there are no rotten eggs, then return -1. \\n        int count_of_one = 0;\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0; j < cols; j++)\\n            {\\n                if(grid[i][j] == 2)\\n                    q.push({{i, j}, 0});\\n                if(grid[i][j] == 1)\\n                    count_of_one++;\\n            }\\n        }\\n        if(count_of_one == 0) return 0;\\n        if(q.empty()) return -1;\\n//make a visited matrix. Initialize it with elements of grid.\\n        vector<vector<int>> visited(rows, vector<int>(cols, 0));\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0; j < cols; j++)\\n            {\\n                visited[i][j] = grid[i][j];\\n            }\\n        }\\n//to travel in 4 directions we will use two arrays\\n        int delRow[] = {-1, 0, 1, 0};\\n        int delCol[] = {0, 1, 0, -1};\\n\\n//NOW perform BFS on the grid, because we need a level order traversal\\n        int time = 0;\\n        while(!q.empty())\\n        {\\n            pair<pair<int, int>, int> p = q.front();\\n            q.pop();\\n            pair<int, int> index = p.first;\\n            time = p.second;\\n\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int newRow = delRow[i] + index.first;\\n                int newCol = delCol[i] + index.second;\\n\\n                if(newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && visited[newRow][newCol] != 2 && visited[newRow][newCol] != 0)\\n                {\\n                    q.push({{newRow, newCol}, time+1});\\n                    visited[newRow][newCol] = 2;\\n                }\\n            }\\n        }\\n//if there is still any 1 in the visited matrix, then it is because some fresh oranges are still left. So return -1 in this case.\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0;  j < cols; j++)\\n            {\\n                if(visited[i][j] == 1)\\n                    return -1;\\n            }\\n        }\\n//otherwise return time.\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665570,
                "title": "bfs-solution-in-python",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visited,queue=set(),deque()\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col]==1:\\n                    visited.add((row,col))\\n                elif grid[row][col]==2:\\n                    queue.append((row,col))\\n        ans=0\\n        while visited and queue:\\n            for _ in range(len(queue)):\\n                r,c=queue.popleft()\\n                for neighbours in ((r,c-1),(r,c+1),(r-1,c),(r+1,c)):\\n                    if neighbours in visited:\\n                        visited.remove(neighbours)\\n                        queue.append(neighbours)\\n            ans+=1\\n        return -1 if visited else ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visited,queue=set(),deque()\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col]==1:\\n                    visited.add((row,col))\\n                elif grid[row][col]==2:\\n                    queue.append((row,col))\\n        ans=0\\n        while visited and queue:\\n            for _ in range(len(queue)):\\n                r,c=queue.popleft()\\n                for neighbours in ((r,c-1),(r,c+1),(r-1,c),(r+1,c)):\\n                    if neighbours in visited:\\n                        visited.remove(neighbours)\\n                        queue.append(neighbours)\\n            ans+=1\\n        return -1 if visited else ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647595,
                "title": "java-2ms-bfs-solution-faster-than-96-78-with-explaination",
                "content": "**Note:** the same solution when runned at different times produce different runtimes,so it is adviced to not get disappointed about this ,rest assured this is a one of the best bfs solutions for this question.these submissions hold the the same code.\\n![image](https://assets.leetcode.com/users/images/e0d98959-c60b-47a0-a907-570f43c598a4_1664644212.1830633.png)\\nif your solution is getting a high run time,here are some quick suggestions \\n*  keep a variable which keeps count of ones \\n*  keeping count of ones help in breaking the while loop as soon as all the oranges are rooten and prevents us from traversing the whole array in the worst case.\\n*  another use is to just check at the end if all the oranges are rotten or not.\\n**Approach**\\n*  if all zero or all two return 0\\n*  if all one return -1\\n* store the intially rotten tomatos in the queue so that we have starting point of infection, and apply bfs on them.\\n*  keep count of total unrotten tomatos and as soon as every tomato is wrotten terminate the loop.\\n* store the location of the rotten tomato and the time elepsed yet in the queue ,you can use different methods to do this,i just stored an array of size 3 in queue where i,j and time elepsed are stored respectively\\n*  rott the adjacent fresh oranges to these and store them in the queue.\\n*  store the time elapsed to reach previous fresh tomato + 1 for the current tomato in a variable ans.\\n*  when completed return ans.\\n**Code**\\n```\\nclass Solution {\\n    int[][] arr;\\n    boolean inRange(int i,int j){//range validator\\n        return !(i<0||i>arr.length-1||j<0||j>arr[0].length-1);\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        arr=grid;\\n        //possible movements\\n        int[] u={0,0,-1,1};\\n        int[] v={1,-1,0,0};\\n        Queue<int[]> q=new LinkedList<>();\\n        int zero=0,two=0,one=0;\\n // ------------------------------------------------------------------------------            \\n        //count the zeros,twos and ones and store rotten tomatos into queue \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0) zero++;\\n                else if(grid[i][j]==1) one++;\\n                else two++;\\n                if(grid[i][j]==2){\\n                q.add(new int[]{i,j,0});\\n                }\\n            }\\n        }\\n// ------------------------------------------------------------------------------     \\n        int ans=0;\\n        //optional as this check has no effect in long run\\n        int size=grid.length*grid[0].length;\\n        if(zero==size||two==size) return 0;\\n        if(one==size) return -1;\\n// ------------------------------------------------------------------------------        \\n        while(!q.isEmpty()){\\n                    size=q.size();\\n                    for(int k=0;k<size;k++){\\n                        int[] temp=q.poll();\\n                        int cost=temp[2];\\n                        for(int l=0;l<4;l++){\\n                            int a=temp[0]+u[l];\\n                            int b=temp[1]+v[l];\\n                            if(inRange(a,b) && grid[a][b]==1){//adding an adjacent fresh tomato into queue and rotting it.\\n                                q.add(new int[]{a,b,cost+1});\\n                                grid[a][b]=2;\\n                                ans=cost+1;//storing time elapsed.\\n                                one--;//reducing the count of fresh tomatos\\n                            }\\n                        }\\n                        if(one<=0) break;//if no fresh tomatos left break\\n                    }\\n                }\\n// -----------------------------------------------------------------------------            \\n        if(one!=0) return -1; //it is not possible to rott all tomatos\\n        return ans;    \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    int[][] arr;\\n    boolean inRange(int i,int j){//range validator\\n        return !(i<0||i>arr.length-1||j<0||j>arr[0].length-1);\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        arr=grid;\\n        //possible movements\\n        int[] u={0,0,-1,1};\\n        int[] v={1,-1,0,0};\\n        Queue<int[]> q=new LinkedList<>();\\n        int zero=0,two=0,one=0;\\n // ------------------------------------------------------------------------------            \\n        //count the zeros,twos and ones and store rotten tomatos into queue \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0) zero++;\\n                else if(grid[i][j]==1) one++;\\n                else two++;\\n                if(grid[i][j]==2){\\n                q.add(new int[]{i,j,0});\\n                }\\n            }\\n        }\\n// ------------------------------------------------------------------------------     \\n        int ans=0;\\n        //optional as this check has no effect in long run\\n        int size=grid.length*grid[0].length;\\n        if(zero==size||two==size) return 0;\\n        if(one==size) return -1;\\n// ------------------------------------------------------------------------------        \\n        while(!q.isEmpty()){\\n                    size=q.size();\\n                    for(int k=0;k<size;k++){\\n                        int[] temp=q.poll();\\n                        int cost=temp[2];\\n                        for(int l=0;l<4;l++){\\n                            int a=temp[0]+u[l];\\n                            int b=temp[1]+v[l];\\n                            if(inRange(a,b) && grid[a][b]==1){//adding an adjacent fresh tomato into queue and rotting it.\\n                                q.add(new int[]{a,b,cost+1});\\n                                grid[a][b]=2;\\n                                ans=cost+1;//storing time elapsed.\\n                                one--;//reducing the count of fresh tomatos\\n                            }\\n                        }\\n                        if(one<=0) break;//if no fresh tomatos left break\\n                    }\\n                }\\n// -----------------------------------------------------------------------------            \\n        if(one!=0) return -1; //it is not possible to rott all tomatos\\n        return ans;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584200,
                "title": "c-dfs-different-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void helper(vector<vector<int>>& grid, int i, int j, int time)\\n    {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[i].size() || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < time))\\n            return;\\n        grid[i][j] = time;\\n        helper(grid, i + 1, j, time + 1);\\n        helper(grid, i - 1, j, time + 1);\\n        helper(grid, i, j + 1, time + 1);\\n        helper(grid, i, j - 1, time + 1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int time = 2;\\n        for(int i = 0 ; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[i].size(); j++)\\n            {\\n                if(grid[i][j] == 2)\\n                {\\n                    helper(grid, i, j, time);\\n                }\\n            }\\n        }\\n        int ans = 2;\\n        for(int i = 0 ; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[i].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    return -1;\\n                ans = max(ans, grid[i][j]);\\n            }\\n        }\\n        return ans - 2;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void helper(vector<vector<int>>& grid, int i, int j, int time)\\n    {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[i].size() || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < time))\\n            return;\\n        grid[i][j] = time;\\n        helper(grid, i + 1, j, time + 1);\\n        helper(grid, i - 1, j, time + 1);\\n        helper(grid, i, j + 1, time + 1);\\n        helper(grid, i, j - 1, time + 1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int time = 2;\\n        for(int i = 0 ; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[i].size(); j++)\\n            {\\n                if(grid[i][j] == 2)\\n                {\\n                    helper(grid, i, j, time);\\n                }\\n            }\\n        }\\n        int ans = 2;\\n        for(int i = 0 ; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[i].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    return -1;\\n                ans = max(ans, grid[i][j]);\\n            }\\n        }\\n        return ans - 2;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446082,
                "title": "bfs-easyyyyy-python",
                "content": "```\\n def orangesRotting(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        Fresh = 0  #count of fresh apples\\n        rotten = 0 # count of apples which which will be rotten\\n        \\n        \\n        visited=[[0 for i in range(m)]for j in range(n)]\\n        queue=[]\\n        for i in range(n):\\n            for j in range(m):\\n                if(grid[i][j]==2):\\n                    queue.append([i,j,0])\\n                    visited[i][j]=1\\n                if(grid[i][j]==1):\\n                    Fresh+=1\\n        if(Fresh==0):\\n            return 0 \\n        \\n        while queue:\\n                row = queue[0][0]\\n                col = queue[0][1]\\n                \\n                t = queue[0][2]\\n                queue.pop(0)\\n                for i,j in [(1,0),(0,1),(0,-1),(-1,0)]:\\n                    newRow = row+i\\n                    newCol = col+j\\n                    \\n                    if(newRow>=0 and newRow<n and newCol>=0 and newCol<m and grid[newRow][newCol]==1 and visited[newRow][newCol]!=1):\\n                        queue.append([newRow,newCol,t+1])\\n                        visited[newRow][newCol]=1\\n                        rotten+=1\\n        \\n        \\n        if(rotten!=Fresh):\\n            return -1\\n        return t\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n def orangesRotting(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        Fresh = 0  #count of fresh apples\\n        rotten = 0 # count of apples which which will be rotten\\n        \\n        \\n        visited=[[0 for i in range(m)]for j in range(n)]\\n        queue=[]\\n        for i in range(n):\\n            for j in range(m):\\n                if(grid[i][j]==2):\\n                    queue.append([i,j,0])\\n                    visited[i][j]=1\\n                if(grid[i][j]==1):\\n                    Fresh+=1\\n        if(Fresh==0):\\n            return 0 \\n        \\n        while queue:\\n                row = queue[0][0]\\n                col = queue[0][1]\\n                \\n                t = queue[0][2]\\n                queue.pop(0)\\n                for i,j in [(1,0),(0,1),(0,-1),(-1,0)]:\\n                    newRow = row+i\\n                    newCol = col+j\\n                    \\n                    if(newRow>=0 and newRow<n and newCol>=0 and newCol<m and grid[newRow][newCol]==1 and visited[newRow][newCol]!=1):\\n                        queue.append([newRow,newCol,t+1])\\n                        visited[newRow][newCol]=1\\n                        rotten+=1\\n        \\n        \\n        if(rotten!=Fresh):\\n            return -1\\n        return t\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2417466,
                "title": "c-solution-bfs-traversal-using-queue-easy-approach",
                "content": "```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Finding the size of grid\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        // Making visited array\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        // Making queue  to store row , col , time\\n        queue<pair<pair<int,int>,int>> q;\\n        int fcount = 0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                // marking visited array 2 if found rotten orange\\n                if(grid[i][j] == 2){\\n                    visited[i][j] = 2;\\n                    q.push({{i,j},0});\\n                }\\n                \\n                // finding no of fresh orange\\n                if(grid[i][j] == 1){\\n                    fcount++;\\n                }\\n                \\n            }\\n        }\\n        \\n        // doing bfs traversal\\n        int dr[] = {-1,0,1,0};\\n        int dc[] = {0,1,0,-1};\\n        int tmax = 0;\\n        \\n        int count = 0;\\n        while(!q.empty()){\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            tmax = max(tmax,t);\\n            \\n            for(int i=0;i<4;i++){\\n                int row = r + dr[i];\\n                int col = c + dc[i];\\n                // base case\\n                if(row >= 0 && col >= 0 && row < n && col < m && grid[row][col] == 1 && visited[row][col] != 2){\\n                    visited[row][col] = 2;\\n                    q.push({{row,col},t + 1});\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        // checking if all fresh orange got rotten or not\\n        if(fcount != count){\\n            return -1;\\n        }\\n        \\n        return tmax;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Finding the size of grid\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        // Making visited array\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        // Making queue  to store row , col , time\\n        queue<pair<pair<int,int>,int>> q;\\n        int fcount = 0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                // marking visited array 2 if found rotten orange\\n                if(grid[i][j] == 2){\\n                    visited[i][j] = 2;\\n                    q.push({{i,j},0});\\n                }\\n                \\n                // finding no of fresh orange\\n                if(grid[i][j] == 1){\\n                    fcount++;\\n                }\\n                \\n            }\\n        }\\n        \\n        // doing bfs traversal\\n        int dr[] = {-1,0,1,0};\\n        int dc[] = {0,1,0,-1};\\n        int tmax = 0;\\n        \\n        int count = 0;\\n        while(!q.empty()){\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            tmax = max(tmax,t);\\n            \\n            for(int i=0;i<4;i++){\\n                int row = r + dr[i];\\n                int col = c + dc[i];\\n                // base case\\n                if(row >= 0 && col >= 0 && row < n && col < m && grid[row][col] == 1 && visited[row][col] != 2){\\n                    visited[row][col] = 2;\\n                    q.push({{row,col},t + 1});\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        // checking if all fresh orange got rotten or not\\n        if(fcount != count){\\n            return -1;\\n        }\\n        \\n        return tmax;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354411,
                "title": "python-easy-to-understand-sol-with-explanation",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # This step is standard for a matrix\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        # No need to check if the matrix is empty. [(row, col) >= 1] Given in Constraints\\n        \\n        # For keeping the track of number of fresh oranges\\n        fresh_oranges = 0 \\n        \\n        # For storing the position of rotten oranges\\n        queue = deque()\\n        \\n        # Adding Rotten oranges to the queue, Counting number of fresh oranges\\n        for i in range(0, row):\\n            for j in range(0, col):\\n                \\n                if grid[i][j] == 2:\\n                    queue.append((i, j))\\n                elif grid[i][j] == 1:\\n                    fresh_oranges += 1\\n        \\n        # Initializing time variable\\n        time = 0\\n        \\n        while queue and fresh_oranges > 0:\\n            \\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                \\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    \\n                    xx, yy = x + dx, y + dy\\n                    \\n                    # Condition for boundry of the matrix\\n                    if xx < 0 or xx == row or yy < 0 or yy == col:\\n                        continue\\n                    \\n                    # For avoiding adding oranges that are alredy rotten to the queue\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                    \\n                    # Adding position of fresh oranges which became rotten\\n                    queue.append((xx, yy))\\n                    \\n                    # making the orange rotten in the matrix\\n                    grid[xx][yy] = 2\\n                    \\n                    # reducing the number of fresh oranges by one\\n                    fresh_oranges -= 1\\n            \\n            # Increasing the time variable by one \\n            time += 1\\n        \\n        return time if fresh_oranges == 0 else -1\\n    \\n\\'\\'\\'\\n\\n#### Please Upvote if you find this solution Helpful !!!",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # This step is standard for a matrix\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        # No need to check if the matrix is empty. [(row, col) >= 1] Given in Constraints\\n        \\n        # For keeping the track of number of fresh oranges\\n        fresh_oranges = 0 \\n        \\n        # For storing the position of rotten oranges\\n        queue = deque()\\n        \\n        # Adding Rotten oranges to the queue, Counting number of fresh oranges\\n        for i in range(0, row):\\n            for j in range(0, col):\\n                \\n                if grid[i][j] == 2:\\n                    queue.append((i, j))\\n                elif grid[i][j] == 1:\\n                    fresh_oranges += 1\\n        \\n        # Initializing time variable\\n        time = 0\\n        \\n        while queue and fresh_oranges > 0:\\n            \\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                \\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    \\n                    xx, yy = x + dx, y + dy\\n                    \\n                    # Condition for boundry of the matrix\\n                    if xx < 0 or xx == row or yy < 0 or yy == col:\\n                        continue\\n                    \\n                    # For avoiding adding oranges that are alredy rotten to the queue\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                    \\n                    # Adding position of fresh oranges which became rotten\\n                    queue.append((xx, yy))\\n                    \\n                    # making the orange rotten in the matrix\\n                    grid[xx][yy] = 2\\n                    \\n                    # reducing the number of fresh oranges by one\\n                    fresh_oranges -= 1\\n            \\n            # Increasing the time variable by one \\n            time += 1\\n        \\n        return time if fresh_oranges == 0 else -1\\n    \\n\\'\\'\\'\\n\\n#### Please Upvote if you find this solution Helpful !!!",
                "codeTag": "Java"
            },
            {
                "id": 2344451,
                "title": "c-multi-source-bfs-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(); // No of rows\\n        int m = grid[0].size(); // No of columns\\n        \\n\\t\\t//to store  min visited time and initial time as infinity\\n        vector<vector<int> > time(n,vector<int>(m,1e8));\\n        \\n\\t\\t\\n\\t\\tqueue<pair<int,int> > q;\\n\\t\\t\\n\\t\\t// adding all rotten oranges as source with time 0\\n        for(int i=0;i<n;i++)\\n\\t\\t{    \\n            for(int j=0;j<m;j++)\\n\\t\\t\\t{\\n                if(grid[i][j]==2)\\n\\t\\t\\t\\t{\\n                    q.push({i,j}); \\n                    time[i][j] = 0;\\n                }    \\n            }\\n        }\\n        \\n\\t\\t//direction vector\\'s\\n        int dx[4] = {1,0,0,-1};\\n        int dy[4] = {0,1,-1,0};\\n        \\n\\t\\t\\n\\t\\t// BFS\\n        while(q.size()){\\n            \\n            auto [x,y] = q.front(); q.pop();\\n            \\n            for(int i=0;i<4;i++)\\n\\t\\t\\t{\\n                \\n                int newx = dx[i] + x;\\n                int newy = dy[i] + y;\\n                \\n                if( newx<0 or newy<0 or newx>=n or newy>=m or grid[newx][newy]==0 ) continue;\\n                \\n                if( time[newx][newy] > (1 + time[x][y]) )  // checking for better time \\n\\t\\t\\t\\t{\\n                    time[newx][newy] = 1 + time[x][y];\\n                    q.push({newx,newy});\\n                }\\n                \\n            }    \\n            \\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++)\\n\\t\\t{\\n            for(int j=0;j<m;j++)\\n\\t\\t\\t{\\n                if(grid[i][j]==1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// if there is orange which is unvisited then answer will be -1\\n\\t\\t\\t\\t\\t\\tif(time[i][j]==(1e8))  return -1;\\n\\t\\t\\t\\t\\t\\tans = max(ans,time[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(); // No of rows\\n        int m = grid[0].size(); // No of columns\\n        \\n\\t\\t//to store  min visited time and initial time as infinity\\n        vector<vector<int> > time(n,vector<int>(m,1e8));\\n        \\n\\t\\t\\n\\t\\tqueue<pair<int,int> > q;\\n\\t\\t\\n\\t\\t// adding all rotten oranges as source with time 0\\n        for(int i=0;i<n;i++)\\n\\t\\t{    \\n            for(int j=0;j<m;j++)\\n\\t\\t\\t{\\n                if(grid[i][j]==2)\\n\\t\\t\\t\\t{\\n                    q.push({i,j}); \\n                    time[i][j] = 0;\\n                }    \\n            }\\n        }\\n        \\n\\t\\t//direction vector\\'s\\n        int dx[4] = {1,0,0,-1};\\n        int dy[4] = {0,1,-1,0};\\n        \\n\\t\\t\\n\\t\\t// BFS\\n        while(q.size()){\\n            \\n            auto [x,y] = q.front(); q.pop();\\n            \\n            for(int i=0;i<4;i++)\\n\\t\\t\\t{\\n                \\n                int newx = dx[i] + x;\\n                int newy = dy[i] + y;\\n                \\n                if( newx<0 or newy<0 or newx>=n or newy>=m or grid[newx][newy]==0 ) continue;\\n                \\n                if( time[newx][newy] > (1 + time[x][y]) )  // checking for better time \\n\\t\\t\\t\\t{\\n                    time[newx][newy] = 1 + time[x][y];\\n                    q.push({newx,newy});\\n                }\\n                \\n            }    \\n            \\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++)\\n\\t\\t{\\n            for(int j=0;j<m;j++)\\n\\t\\t\\t{\\n                if(grid[i][j]==1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// if there is orange which is unvisited then answer will be -1\\n\\t\\t\\t\\t\\t\\tif(time[i][j]==(1e8))  return -1;\\n\\t\\t\\t\\t\\t\\tans = max(ans,time[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342575,
                "title": "bfs-o-m-n-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();// store grid row size\\n        int n = grid[0].size();// store grid coloum size\\n        \\n        vector<vector<int>> toVisit;// to store rotten orrange cells to be visited.\\n        \\n        int i,j,time=0;\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                    toVisit.push_back({i,j}); // if cell is rooten than add it to toVisit.\\n                }\\n            }\\n        }\\n        \\n        toVisit.push_back({-1,-1});// adding a time breaker for each iteration.\\n        int r,c;\\n        \\n        while(!toVisit.empty())\\n        {\\n            while(toVisit.front()[0]!=-1)// run till it hits breaker\\n            {\\n                r=toVisit.front()[0];// get current row\\n                c=toVisit.front()[1];// get current coloum\\n                \\n                toVisit.erase(toVisit.begin());// erase current cell\\n                \\n                if(r>0)// check for up cell\\n                {\\n                    if(grid[r-1][c]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r-1][c]=2;\\n                        toVisit.push_back({r-1,c});\\n                    }\\n                }\\n                if(r<m-1)// check for down cell\\n                {\\n                    if(grid[r+1][c]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r+1][c]=2;\\n                        toVisit.push_back({r+1,c});\\n                    }\\n                }\\n                if(c>0)// check for left cell\\n                {\\n                    if(grid[r][c-1]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r][c-1]=2;\\n                        toVisit.push_back({r,c-1});                 \\n                    }\\n                }\\n                if(c<n-1)// check for right cell\\n                {\\n                    if(grid[r][c+1]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r][c+1]=2;\\n                        toVisit.push_back({r,c+1});\\n                    }\\n                }\\n            }\\n            \\n            toVisit.erase(toVisit.begin());// erase the time breaker\\n            if(!toVisit.empty())// add time breaker if toVisit is not empty\\n                toVisit.push_back({-1,-1});\\n            \\n            time++;//increment time\\n        }\\n        \\n        int check=0;// to check for fresh orange\\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    check=1;\\n                }\\n            }\\n        }\\n        \\n        if(check==1)\\n            return -1;\\n        else\\n            return time-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();// store grid row size\\n        int n = grid[0].size();// store grid coloum size\\n        \\n        vector<vector<int>> toVisit;// to store rotten orrange cells to be visited.\\n        \\n        int i,j,time=0;\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                    toVisit.push_back({i,j}); // if cell is rooten than add it to toVisit.\\n                }\\n            }\\n        }\\n        \\n        toVisit.push_back({-1,-1});// adding a time breaker for each iteration.\\n        int r,c;\\n        \\n        while(!toVisit.empty())\\n        {\\n            while(toVisit.front()[0]!=-1)// run till it hits breaker\\n            {\\n                r=toVisit.front()[0];// get current row\\n                c=toVisit.front()[1];// get current coloum\\n                \\n                toVisit.erase(toVisit.begin());// erase current cell\\n                \\n                if(r>0)// check for up cell\\n                {\\n                    if(grid[r-1][c]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r-1][c]=2;\\n                        toVisit.push_back({r-1,c});\\n                    }\\n                }\\n                if(r<m-1)// check for down cell\\n                {\\n                    if(grid[r+1][c]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r+1][c]=2;\\n                        toVisit.push_back({r+1,c});\\n                    }\\n                }\\n                if(c>0)// check for left cell\\n                {\\n                    if(grid[r][c-1]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r][c-1]=2;\\n                        toVisit.push_back({r,c-1});                 \\n                    }\\n                }\\n                if(c<n-1)// check for right cell\\n                {\\n                    if(grid[r][c+1]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r][c+1]=2;\\n                        toVisit.push_back({r,c+1});\\n                    }\\n                }\\n            }\\n            \\n            toVisit.erase(toVisit.begin());// erase the time breaker\\n            if(!toVisit.empty())// add time breaker if toVisit is not empty\\n                toVisit.push_back({-1,-1});\\n            \\n            time++;//increment time\\n        }\\n        \\n        int check=0;// to check for fresh orange\\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    check=1;\\n                }\\n            }\\n        }\\n        \\n        if(check==1)\\n            return -1;\\n        else\\n            return time-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271868,
                "title": "c-clean-and-commented-solution-bfs-faster-than-92",
                "content": "***Please upvote if you like the solution. :)***\\n```\\nclass Solution {\\npublic:\\n    // direction vectors to find adjacent coordinates.\\n    vector <int> dx = { -1, 0, 1, 0};\\n    vector <int> dy = {0, 1, 0, -1};\\n\\n    // Function to check if the cell is inside the grid and contains a fresh orange.\\n    bool isValid(int x, int y, vector<vector<int>>& grid) {\\n        if (x >= grid.size() || y >= grid[0].size() || x < 0 || y < 0)return false;\\n        if (grid[x][y] != 1)return false;\\n        return true;\\n    }\\n\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Variables to keep the count of fresh and total number of oranges.\\n        int fresh = 0;\\n        int total = 0;\\n        queue <pair<int, int>> rotten;\\n\\n        // Initialising the queue with rotten oranges at time = 0 and counting oranges.\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1)fresh++, total++;\\n                else if (grid[i][j] == 2) {\\n                    rotten.push({i, j});\\n                    total++;\\n                }\\n            }\\n        }\\n\\n        // If the grid has no fresh oranges, return 0.\\n        if (fresh == 0) {\\n            return 0;\\n        }\\n        // If the grid has no rotten oranges, return -1.\\n        if (total == fresh) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n        // Traversing the grid with standard BFS algorithm.\\n        // Checking for adjacent coordinates of each rotten orange till the queue is not empty.\\n        while (!rotten.empty()) {\\n            // Increasing the minutes count.\\n            ans++;\\n            /**\\n             * Each minute sz number of rotten oranges will be checked for adjacent fresh ones.\\n             * sz being the number of coordinates currently in the queue.\\n            */\\n            int sz = rotten.size();\\n            while (sz--) {\\n                int nodex = rotten.front().first;\\n                int nodey = rotten.front().second;\\n                rotten.pop();\\n\\n                for (int i = 0; i < 4; i++) {\\n                    if (isValid(nodex + dx[i], nodey + dy[i], grid)) {\\n                        // This fresh orange is marked rotten in the grid and pushed into the queue.\\n                        grid[nodex + dx[i]][nodey + dy[i]] = 2;\\n                        rotten.push({nodex + dx[i], nodey + dy[i]});\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        // If any fresh orange still remains, return -1.\\n        if (fresh > 0)return -1;\\n        /**\\n         * Else return (ans - 1), reducing ans by 1 because the last set of rotten oranges in the queue will not\\n         * have any adjacent fresh oranges to rot but the loop will still increment 1 to our ans.\\n        */\\n        return ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // direction vectors to find adjacent coordinates.\\n    vector <int> dx = { -1, 0, 1, 0};\\n    vector <int> dy = {0, 1, 0, -1};\\n\\n    // Function to check if the cell is inside the grid and contains a fresh orange.\\n    bool isValid(int x, int y, vector<vector<int>>& grid) {\\n        if (x >= grid.size() || y >= grid[0].size() || x < 0 || y < 0)return false;\\n        if (grid[x][y] != 1)return false;\\n        return true;\\n    }\\n\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Variables to keep the count of fresh and total number of oranges.\\n        int fresh = 0;\\n        int total = 0;\\n        queue <pair<int, int>> rotten;\\n\\n        // Initialising the queue with rotten oranges at time = 0 and counting oranges.\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1)fresh++, total++;\\n                else if (grid[i][j] == 2) {\\n                    rotten.push({i, j});\\n                    total++;\\n                }\\n            }\\n        }\\n\\n        // If the grid has no fresh oranges, return 0.\\n        if (fresh == 0) {\\n            return 0;\\n        }\\n        // If the grid has no rotten oranges, return -1.\\n        if (total == fresh) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n        // Traversing the grid with standard BFS algorithm.\\n        // Checking for adjacent coordinates of each rotten orange till the queue is not empty.\\n        while (!rotten.empty()) {\\n            // Increasing the minutes count.\\n            ans++;\\n            /**\\n             * Each minute sz number of rotten oranges will be checked for adjacent fresh ones.\\n             * sz being the number of coordinates currently in the queue.\\n            */\\n            int sz = rotten.size();\\n            while (sz--) {\\n                int nodex = rotten.front().first;\\n                int nodey = rotten.front().second;\\n                rotten.pop();\\n\\n                for (int i = 0; i < 4; i++) {\\n                    if (isValid(nodex + dx[i], nodey + dy[i], grid)) {\\n                        // This fresh orange is marked rotten in the grid and pushed into the queue.\\n                        grid[nodex + dx[i]][nodey + dy[i]] = 2;\\n                        rotten.push({nodex + dx[i], nodey + dy[i]});\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        // If any fresh orange still remains, return -1.\\n        if (fresh > 0)return -1;\\n        /**\\n         * Else return (ans - 1), reducing ans by 1 because the last set of rotten oranges in the queue will not\\n         * have any adjacent fresh oranges to rot but the loop will still increment 1 to our ans.\\n        */\\n        return ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185266,
                "title": "python-simple-bfs-solution",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        q = deque()\\n        fresh, time = 0, 0\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    q.append([r,c])\\n                if grid[r][c] == 1:\\n                    fresh += 1\\n        directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n        while q and fresh > 0:\\n            for i in range(len(q)):\\n                r, c = q.popleft()\\n                for dr, dc in directions:\\n                    row = dr + r\\n                    col = dc + c\\n                    if row < 0 or row == rows or col < 0 or col == cols or grid[row][col] != 1:\\n                        continue\\n                    grid[row][col] = 2\\n                    fresh -= 1\\n                    q.append([row, col])\\n            time += 1\\n        return time if fresh == 0 else -1\\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        q = deque()\\n        fresh, time = 0, 0\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    q.append([r,c])\\n                if grid[r][c] == 1:\\n                    fresh += 1\\n        directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n        while q and fresh > 0:\\n            for i in range(len(q)):\\n                r, c = q.popleft()\\n                for dr, dc in directions:\\n                    row = dr + r\\n                    col = dc + c\\n                    if row < 0 or row == rows or col < 0 or col == cols or grid[row][col] != 1:\\n                        continue\\n                    grid[row][col] = 2\\n                    fresh -= 1\\n                    q.append([row, col])\\n            time += 1\\n        return time if fresh == 0 else -1\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836596,
                "title": "java-clean-bfs-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int freshOranges = 0;\\n        for(int i = 0 ; i < rows; i++){\\n            for(int j = 0 ; j < cols ; j++){\\n                if(grid[i][j] == 2){\\n                    //add rotten oranges to queue\\n                    queue.offer(new int[]{i, j});\\n                }\\n                if(grid[i][j] == 1){\\n                    freshOranges++;\\n                }\\n            }\\n        }\\n        int minutes = 0; // this is basically number of levels in BFS\\n        int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        //continue the bfs till there are no more valid fresh oranges that can be rotten\\n        while(!queue.isEmpty() && freshOranges > 0){\\n            int sz = queue.size();\\n            for(int i = 0 ; i < sz ; i++){\\n                int[] node = queue.poll();\\n                for(int[] d : dir){\\n                    int x = node[0] + d[0];\\n                    int y = node[1] + d[1];\\n                    //checking if node is a fresh orange which lies inside the matrix\\n                    if(x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2){\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;\\n                    queue.offer(new int[]{x,y});\\n                    freshOranges--;\\n                }\\n            }\\n            minutes++;\\n        }\\n        return freshOranges == 0 ? minutes : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int freshOranges = 0;\\n        for(int i = 0 ; i < rows; i++){\\n            for(int j = 0 ; j < cols ; j++){\\n                if(grid[i][j] == 2){\\n                    //add rotten oranges to queue\\n                    queue.offer(new int[]{i, j});\\n                }\\n                if(grid[i][j] == 1){\\n                    freshOranges++;\\n                }\\n            }\\n        }\\n        int minutes = 0; // this is basically number of levels in BFS\\n        int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        //continue the bfs till there are no more valid fresh oranges that can be rotten\\n        while(!queue.isEmpty() && freshOranges > 0){\\n            int sz = queue.size();\\n            for(int i = 0 ; i < sz ; i++){\\n                int[] node = queue.poll();\\n                for(int[] d : dir){\\n                    int x = node[0] + d[0];\\n                    int y = node[1] + d[1];\\n                    //checking if node is a fresh orange which lies inside the matrix\\n                    if(x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2){\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;\\n                    queue.offer(new int[]{x,y});\\n                    freshOranges--;\\n                }\\n            }\\n            minutes++;\\n        }\\n        return freshOranges == 0 ? minutes : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832041,
                "title": "c-easy-to-understand-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        int ones=0,twos=0,ans=0;\\n        \\n        //Count number of 2\\'s and 1\\'s and push all 2\\'s in the queue\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j] == 2){\\n                    twos++;\\n                    q.push({i,j});\\n                }\\n                else if(grid[i][j]==1){\\n                    ones++;\\n                }\\n            }\\n        }\\n        \\n        //if there are no fresh oranges present(i.e number of ones is equal to zero), time required will also be zero\\n        if(ones == 0) return 0;\\n        \\n        //else if there are no rotten oranges, fresh oranges will not rot and we will have to return (-1)\\n        else if(twos == 0) return -1;\\n        \\n        // count1 stores the number of unvisited nodes or oranges which are \\n        // going to affect its neighbours at that moment\\n        // count2 is going to store number of children nodes of the oranges in the current level\\n        int count1=twos, count2=0;\\n        // assuming the first level is already rotten, we are counting it and so at the end we will return (ans-1) instead of ans. \\n\\t\\t//(If you want to return ans, you can initialize ans as -1 above\\uD83D\\uDE09 )\\n        \\n        //BFS traversal\\n        while(!q.empty()){\\n            int i = q.front().first;\\n            int j = q.front().second;\\n            q.pop();\\n            // Everytime we pop, unvisited oranges in current level decreases by one, hence count1-- (That is decrementing number of 2\\'s)\\n            count1--;\\n            \\n            //there are four conditions(Top, Bottom, Left, Right) to check for the current orange\\n\\t\\t\\t//and it should not cross the bounds of the grid so using checkValid Function at the end\\n            \\n            //Check for Top Direction\\n            if(checkValid(i+1,j,rows,cols) && grid[i+1][j]==1){\\n                // 1(fresh orange) becomes 2 (Rotten Orange) \\n                // and number of children i.e. count2 increased by one\\n                // and push it to queue to further check its children nodes\\n                q.push({i+1,j});\\n                grid[i+1][j] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Bottom Direction\\n            if(checkValid(i-1,j,rows,cols) && grid[i-1][j]==1){\\n                q.push({i-1,j});\\n                grid[i-1][j] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Left Direction\\n            if(checkValid(i,j-1,rows,cols) && grid[i][j-1]==1){\\n                q.push({i,j-1});\\n                grid[i][j-1] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Right Direction\\n                if(checkValid(i,j+1,rows,cols) && grid[i][j+1]==1){\\n                q.push({i,j+1});\\n                grid[i][j+1] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            \\n            if(count1 == 0){ //Traversed for all 2\\'s\\n                // count1 is zero means we have completed traversing the current level of the graph\\n                // and hence one unit of time is passed. So we increrment ans\\n                // going to the next level, for that count2 becomes count1 and count2 becomes zero, \\n                // i.e. children nodes become parent nodes to their children and child count again re-initialised to zero.\\n                ans++;\\n                count1 = count2;\\n                count2 = 0;\\n            }\\n        }\\n        \\n        //If there are still some numbers of fresh oranges left(isolation condition)\\n        //so in that case return -1;\\n        if(ones > 0) return -1;\\n        \\n        //else return our answer\\n        return ans-1;\\n    }\\n    \\n    //Function to check out of bound condition\\n    bool checkValid(int i,int j,int rows, int cols){\\n        if(i<0 || i>=rows || j<0 || j>=cols){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n<em>Happy Coding!</em>\\uD83C\\uDF89\\uD83E\\uDD42 \\n\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        int ones=0,twos=0,ans=0;\\n        \\n        //Count number of 2\\'s and 1\\'s and push all 2\\'s in the queue\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j] == 2){\\n                    twos++;\\n                    q.push({i,j});\\n                }\\n                else if(grid[i][j]==1){\\n                    ones++;\\n                }\\n            }\\n        }\\n        \\n        //if there are no fresh oranges present(i.e number of ones is equal to zero), time required will also be zero\\n        if(ones == 0) return 0;\\n        \\n        //else if there are no rotten oranges, fresh oranges will not rot and we will have to return (-1)\\n        else if(twos == 0) return -1;\\n        \\n        // count1 stores the number of unvisited nodes or oranges which are \\n        // going to affect its neighbours at that moment\\n        // count2 is going to store number of children nodes of the oranges in the current level\\n        int count1=twos, count2=0;\\n        // assuming the first level is already rotten, we are counting it and so at the end we will return (ans-1) instead of ans. \\n\\t\\t//(If you want to return ans, you can initialize ans as -1 above\\uD83D\\uDE09 )\\n        \\n        //BFS traversal\\n        while(!q.empty()){\\n            int i = q.front().first;\\n            int j = q.front().second;\\n            q.pop();\\n            // Everytime we pop, unvisited oranges in current level decreases by one, hence count1-- (That is decrementing number of 2\\'s)\\n            count1--;\\n            \\n            //there are four conditions(Top, Bottom, Left, Right) to check for the current orange\\n\\t\\t\\t//and it should not cross the bounds of the grid so using checkValid Function at the end\\n            \\n            //Check for Top Direction\\n            if(checkValid(i+1,j,rows,cols) && grid[i+1][j]==1){\\n                // 1(fresh orange) becomes 2 (Rotten Orange) \\n                // and number of children i.e. count2 increased by one\\n                // and push it to queue to further check its children nodes\\n                q.push({i+1,j});\\n                grid[i+1][j] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Bottom Direction\\n            if(checkValid(i-1,j,rows,cols) && grid[i-1][j]==1){\\n                q.push({i-1,j});\\n                grid[i-1][j] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Left Direction\\n            if(checkValid(i,j-1,rows,cols) && grid[i][j-1]==1){\\n                q.push({i,j-1});\\n                grid[i][j-1] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Right Direction\\n                if(checkValid(i,j+1,rows,cols) && grid[i][j+1]==1){\\n                q.push({i,j+1});\\n                grid[i][j+1] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            \\n            if(count1 == 0){ //Traversed for all 2\\'s\\n                // count1 is zero means we have completed traversing the current level of the graph\\n                // and hence one unit of time is passed. So we increrment ans\\n                // going to the next level, for that count2 becomes count1 and count2 becomes zero, \\n                // i.e. children nodes become parent nodes to their children and child count again re-initialised to zero.\\n                ans++;\\n                count1 = count2;\\n                count2 = 0;\\n            }\\n        }\\n        \\n        //If there are still some numbers of fresh oranges left(isolation condition)\\n        //so in that case return -1;\\n        if(ones > 0) return -1;\\n        \\n        //else return our answer\\n        return ans-1;\\n    }\\n    \\n    //Function to check out of bound condition\\n    bool checkValid(int i,int j,int rows, int cols){\\n        if(i<0 || i>=rows || j<0 || j>=cols){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777879,
                "title": "c-bfs-using-queue-well-explained-with-comments-tc-o-m-n",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if(grid.empty()) return 0;\\n        int m=grid.size(), n=grid[0].size(), days=0, tot=0, cnt=0;\\n        queue<pair<int, int>>q;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0) tot++;//count total oranges\\n                if(grid[i][j]==2) q.push({i, j});//keep track of rotten orange\\n            }\\n        }\\n        //store the all possible directions\\n        int dx[4]={0, 0, 1, -1};\\n        int dy[4]={1, -1, 0, 0};\\n        \\n        while(!q.empty()){\\n            int k=q.size();\\n            cnt+=k;//updating total rotten orange\\n            while(k--){//do the following steps untill all rotten orange in queue are processed\\n                int x=q.front().first, y=q.front().second;\\n                q.pop();\\n                for(int i=0;i<4;i++){\\n                    int nx=x + dx[i], ny= y+ dy[i];//in each itration nx & ny go to all possible direction\\n                    //checking boundery cases & avoid the rotten orange cells & empty cells\\n                    if(nx< 0 || ny< 0 || nx>=m || ny>=n || grid[nx][ny]!=1) continue;\\n                    grid[nx][ny]=2;//other wise marks the cell as rotten\\n                    q.push({nx,ny});//update the queue with new rotten cells\\n                }\\n            }\\n            if(!q.empty()) days++;//if queue is not empty, then is makes sure that there is some rotten oranges,and they take another days or times  \\n        }\\n        return tot==cnt? days: -1;//if all oranges are rotten, then return the days count ,other wise -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if(grid.empty()) return 0;\\n        int m=grid.size(), n=grid[0].size(), days=0, tot=0, cnt=0;\\n        queue<pair<int, int>>q;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0) tot++;//count total oranges\\n                if(grid[i][j]==2) q.push({i, j});//keep track of rotten orange\\n            }\\n        }\\n        //store the all possible directions\\n        int dx[4]={0, 0, 1, -1};\\n        int dy[4]={1, -1, 0, 0};\\n        \\n        while(!q.empty()){\\n            int k=q.size();\\n            cnt+=k;//updating total rotten orange\\n            while(k--){//do the following steps untill all rotten orange in queue are processed\\n                int x=q.front().first, y=q.front().second;\\n                q.pop();\\n                for(int i=0;i<4;i++){\\n                    int nx=x + dx[i], ny= y+ dy[i];//in each itration nx & ny go to all possible direction\\n                    //checking boundery cases & avoid the rotten orange cells & empty cells\\n                    if(nx< 0 || ny< 0 || nx>=m || ny>=n || grid[nx][ny]!=1) continue;\\n                    grid[nx][ny]=2;//other wise marks the cell as rotten\\n                    q.push({nx,ny});//update the queue with new rotten cells\\n                }\\n            }\\n            if(!q.empty()) days++;//if queue is not empty, then is makes sure that there is some rotten oranges,and they take another days or times  \\n        }\\n        return tot==cnt? days: -1;//if all oranges are rotten, then return the days count ,other wise -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765779,
                "title": "multi-source-bfs-heavily-commented-rotting-oranges",
                "content": "```\\nint dx[]={1,-1,0,0};\\nint dy[]={0,0,-1,1};\\n\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n        //we will start from all the rotten oranges at the same time,\\n        //so we will push all of them into the queue.            \\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                    \\n        // time taken to reach a rotten orage from a rotten orage \\n        //i.e., form itself to itself is 0 .           \\n                    grid[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n        // we will work on negative values on minutes to use this value as visited\\n\\t\\t// as grid dosent contain any negative values.\\n        \\n        int minutes=-1;\\n        int ans=0;\\n        while(!q.empty()){\\n            int len=q.size();\\n            \\n        // end of this for loop indicated 1 minutes elapsed .        \\n            for(int k=0;k<len;k++){\\n                int ii=q.front().first;\\n                int jj=q.front().second;\\n                q.pop();\\n                \\n        // checking all the four direction from the rotten orange .         \\n                for(int i=0;i<4;i++){  \\n                int row=ii+dx[i];\\n                int col=jj+dy[i];\\n                if(row<0 or col<0 or col>m-1 or row>n-1 or grid[row][col]<=0)\\n                    continue;\\n                grid[row][col]=minutes;\\n                q.push({row,col});\\n                ans=min(ans,grid[row][col]);\\n            }\\n            }\\n            minutes--;\\n        }\\n        \\n        \\n        // checking if there any oranges left which is not rotten\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        \\n        return -1*ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nint dx[]={1,-1,0,0};\\nint dy[]={0,0,-1,1};\\n\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n        //we will start from all the rotten oranges at the same time,\\n        //so we will push all of them into the queue.            \\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                    \\n        // time taken to reach a rotten orage from a rotten orage \\n        //i.e., form itself to itself is 0 .           \\n                    grid[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n        // we will work on negative values on minutes to use this value as visited\\n\\t\\t// as grid dosent contain any negative values.\\n        \\n        int minutes=-1;\\n        int ans=0;\\n        while(!q.empty()){\\n            int len=q.size();\\n            \\n        // end of this for loop indicated 1 minutes elapsed .        \\n            for(int k=0;k<len;k++){\\n                int ii=q.front().first;\\n                int jj=q.front().second;\\n                q.pop();\\n                \\n        // checking all the four direction from the rotten orange .         \\n                for(int i=0;i<4;i++){  \\n                int row=ii+dx[i];\\n                int col=jj+dy[i];\\n                if(row<0 or col<0 or col>m-1 or row>n-1 or grid[row][col]<=0)\\n                    continue;\\n                grid[row][col]=minutes;\\n                q.push({row,col});\\n                ans=min(ans,grid[row][col]);\\n            }\\n            }\\n            minutes--;\\n        }\\n        \\n        \\n        // checking if there any oranges left which is not rotten\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        \\n        return -1*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724350,
                "title": "easiest-c-solution-upvote-to-keep-on-top",
                "content": "/*Runtime: 3 ms, faster than 94.30% of C++ online submissions for Rotting Oranges.*/\\n\\n\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int c = 0,fresh=0;\\n        int n= grid[0].size();\\n        queue<pair<int,int>> rotten;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                   rotten.push({i,j});      //push the rotten one\\'s into the queue\\n                }\\n                if(grid[i][j]==1)       \\n                     ++fresh;           //count fresh oranges    \\n            }\\n        }\\n        \\n        while(!rotten.empty())          //while queue is not empty\\n        {\\n            int num = rotten.size();\\n            for(int i=0;i<num;i++)\\n            {\\n                int x =rotten.front().first;\\n                int y= rotten.front().second;\\n                rotten.pop();\\n                if(x>0 && grid[x-1][y]==1)\\n                {\\n                    grid[x-1][y]=2;\\n                    --fresh;\\n                    rotten.push({x-1,y});\\n                }\\n                if(y>0 && grid[x][y-1]==1)\\n                {\\n                    grid[x][y-1]=2;\\n                    --fresh;                    \\n                    rotten.push({x,y-1});\\n                }\\n                if(x<m-1 && grid[x+1][y]==1)\\n                {\\n                    grid[x+1][y]=2;\\n                    --fresh;\\n                    rotten.push({x+1,y});\\n                    \\n                }\\n                if(y<n-1 && grid[x][y+1]==1)\\n                {\\n                    grid[x][y+1]=2;\\n                    --fresh;\\n                    rotten.push({x,y+1});\\n                    \\n                } \\n            }\\n            if(!rotten.empty())\\n                ++c;\\n            \\n            \\n            \\n        }\\n    return fresh==0?c:-1;       // if fresh is 0 then return time otherwise -1\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int c = 0,fresh=0;\\n        int n= grid[0].size();\\n        queue<pair<int,int>> rotten;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                   rotten.push({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 1586822,
                "title": "java-easy-solution-brute-and-optimised-bfs",
                "content": "# Optimised\\n```java\\npublic int orangesRotting(int[][] grid) {\\n\\tint fresh_oranges = 0;\\n\\tint row = grid.length, col = grid[0].length;\\n\\tQueue<ArrayList<Integer>> queue = new LinkedList<>(); \\n\\tfor(int i = 0; i < row; i++) {\\n\\t\\tfor(int j = 0; j < col; j++) {\\n\\t\\t\\tif(grid[i][j] == 2) {\\n\\t\\t\\t\\tArrayList l = new ArrayList<>();\\n\\t\\t\\t\\tl.add(i); l.add(j);\\n\\t\\t\\t\\tqueue.add(l);\\n\\t\\t\\t} \\n\\t\\t\\telse if(grid[i][j] == 1) {\\n\\t\\t\\t\\tfresh_oranges++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif(fresh_oranges == 0) return 0;\\n\\n\\tint minutes = -1; // because count of minute is starting from 0\\n\\tint[][] directions = {{-1,0}, {1, 0}, {0, -1}, {0, 1}}; // up down left right\\n\\n\\twhile(!queue.isEmpty()) {\\n\\t\\tminutes++;\\n\\n\\t\\tint queue_length = queue.size();\\n\\t\\tfor(int i = 0; i < queue_length; i++) {\\n\\t\\t\\tArrayList<Integer> coordinates = queue.poll();\\n\\n\\t\\t\\tfor(int[] direction: directions) {\\n\\t\\t\\t\\tint x = coordinates.get(0) + direction[0];\\n\\t\\t\\t\\tint y = coordinates.get(1) + direction[1];\\n\\n\\t\\t\\t\\tif(x < 0 || y < 0 || x >= row || y >= col || grid[x][y] == 0 || grid[x][y] == 2) continue; // continue if either out of range or apple is not fresh\\n\\n\\t\\t\\t\\tgrid[x][y] = 2;\\n\\t\\t\\t\\tArrayList<Integer> l = new ArrayList<>();\\n\\t\\t\\t\\tl.add(x); l.add(y);\\n\\t\\t\\t\\tqueue.add(l);\\n\\t\\t\\t\\tfresh_oranges--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif(fresh_oranges == 0) return minutes;\\n\\treturn -1;\\n}\\n```\\n\\n**Explanation**\\nBFS (Breadth First Search) is used in this method as we can think of this grid as a graph and these oranges connected. We need to find number of minutes including 0 required for all the oranges to get rotten.\\n\\nThe following steps are used:-\\n- count the number of fresh oranges present in the grid as well as put the row and column indices of those oranges that are rotten.\\n- if the number of fresh oranges is 0 it means that all the oranges are already rotten and we can just return 0.\\n- else we will iterate through all the entries in the queue and make adjacent oranges rotten.\\n- iterate and check for all four directions and if grid entry for those indices is 1 then enter them into queue as well as set them to 2. Don\\'t forget to reduce the count of fresh oranges.\\n- at last check if fresh oranges count is 0 return minutes else return -1.\\n\\nIllustration for example in question:-\\n\\n![image](https://assets.leetcode.com/users/images/f7b075b7-dc2c-4c1b-81f3-475c5a4d3023_1637344486.197861.png)\\n\\n\\n---\\n\\n\\n# Brute\\n```java\\npublic int orangesRotting(int[][] grid) {\\n        int totalorange = 0, freshorange = 0, minutes = 0;\\n        int row = grid.length, col = grid[0].length;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == 1) {\\n                    freshorange++;\\n                    totalorange++;\\n                }\\n                if(grid[i][j] == 2)\\n                    totalorange++;\\n            }\\n        }\\n        if(totalorange == freshorange) return -1;\\n\\n        while(freshorange != 0) {\\n            for(int i = 0; i < row; i++) {\\n                for(int j = 0; j < col; j++) {\\n                    if(grid[i][j] == 0) continue;\\n                    if(grid[i][j] == 2) {\\n                        // top\\n                        if(i-1 >= 0 && grid[i-1][j] == 1) {\\n                            grid[i-1][j] = 3;\\n                            freshorange--;\\n                        }\\n                        // left\\n                        if(j-1 >= 0 && grid[i][j-1] == 1) {\\n                            grid[i][j-1] = 3;\\n                            freshorange--;\\n                        }\\n                        // right\\n                        if(j+1 < col && grid[i][j+1] == 1) {\\n                            grid[i][j+1] = 3;\\n                            freshorange--;\\n                        }\\n                        // down\\n                        if(i+1 < row && grid[i+1][j] == 1) {\\n                            grid[i+1][j] = 3;\\n                            freshorange--;\\n                        }\\n                    }\\n                }\\n            }\\n            for(int i = 0; i < row; i++)\\n                for(int j = 0; j < col; j++)\\n                    if(grid[i][j] == 3)\\n                        grid[i][j] = 2;\\n\\n            minutes++;\\n        }\\n        return minutes;\\n}\\n```\\n\\nHope it helps\\nDo upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\npublic int orangesRotting(int[][] grid) {\\n\\tint fresh_oranges = 0;\\n\\tint row = grid.length, col = grid[0].length;\\n\\tQueue<ArrayList<Integer>> queue = new LinkedList<>(); \\n\\tfor(int i = 0; i < row; i++) {\\n\\t\\tfor(int j = 0; j < col; j++) {\\n\\t\\t\\tif(grid[i][j] == 2) {\\n\\t\\t\\t\\tArrayList l = new ArrayList<>();\\n\\t\\t\\t\\tl.add(i); l.add(j);\\n\\t\\t\\t\\tqueue.add(l);\\n\\t\\t\\t} \\n\\t\\t\\telse if(grid[i][j] == 1) {\\n\\t\\t\\t\\tfresh_oranges++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif(fresh_oranges == 0) return 0;\\n\\n\\tint minutes = -1; // because count of minute is starting from 0\\n\\tint[][] directions = {{-1,0}, {1, 0}, {0, -1}, {0, 1}}; // up down left right\\n\\n\\twhile(!queue.isEmpty()) {\\n\\t\\tminutes++;\\n\\n\\t\\tint queue_length = queue.size();\\n\\t\\tfor(int i = 0; i < queue_length; i++) {\\n\\t\\t\\tArrayList<Integer> coordinates = queue.poll();\\n\\n\\t\\t\\tfor(int[] direction: directions) {\\n\\t\\t\\t\\tint x = coordinates.get(0) + direction[0];\\n\\t\\t\\t\\tint y = coordinates.get(1) + direction[1];\\n\\n\\t\\t\\t\\tif(x < 0 || y < 0 || x >= row || y >= col || grid[x][y] == 0 || grid[x][y] == 2) continue; // continue if either out of range or apple is not fresh\\n\\n\\t\\t\\t\\tgrid[x][y] = 2;\\n\\t\\t\\t\\tArrayList<Integer> l = new ArrayList<>();\\n\\t\\t\\t\\tl.add(x); l.add(y);\\n\\t\\t\\t\\tqueue.add(l);\\n\\t\\t\\t\\tfresh_oranges--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif(fresh_oranges == 0) return minutes;\\n\\treturn -1;\\n}\\n```\n```java\\npublic int orangesRotting(int[][] grid) {\\n        int totalorange = 0, freshorange = 0, minutes = 0;\\n        int row = grid.length, col = grid[0].length;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == 1) {\\n                    freshorange++;\\n                    totalorange++;\\n                }\\n                if(grid[i][j] == 2)\\n                    totalorange++;\\n            }\\n        }\\n        if(totalorange == freshorange) return -1;\\n\\n        while(freshorange != 0) {\\n            for(int i = 0; i < row; i++) {\\n                for(int j = 0; j < col; j++) {\\n                    if(grid[i][j] == 0) continue;\\n                    if(grid[i][j] == 2) {\\n                        // top\\n                        if(i-1 >= 0 && grid[i-1][j] == 1) {\\n                            grid[i-1][j] = 3;\\n                            freshorange--;\\n                        }\\n                        // left\\n                        if(j-1 >= 0 && grid[i][j-1] == 1) {\\n                            grid[i][j-1] = 3;\\n                            freshorange--;\\n                        }\\n                        // right\\n                        if(j+1 < col && grid[i][j+1] == 1) {\\n                            grid[i][j+1] = 3;\\n                            freshorange--;\\n                        }\\n                        // down\\n                        if(i+1 < row && grid[i+1][j] == 1) {\\n                            grid[i+1][j] = 3;\\n                            freshorange--;\\n                        }\\n                    }\\n                }\\n            }\\n            for(int i = 0; i < row; i++)\\n                for(int j = 0; j < col; j++)\\n                    if(grid[i][j] == 3)\\n                        grid[i][j] = 2;\\n\\n            minutes++;\\n        }\\n        return minutes;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1547247,
                "title": "java-97-71-bfs",
                "content": "This approach uses:\\n* a queue to track rotten oranges whose neighbors have not yet been checked\\n* a counter for the number of fresh oranges remaining in the grid\\n* an iteration counter (turns).\\n\\nIn each BFS iteration, the algorithm checks the neighbors of each rotten orange, and \"rots\" them, by placing the newly rotten orange location at the end of the queue, and decrementing the fresh count.  When the fresh count hits zero, the iteration counter is the answer.  If the queue is empty at the start of any iteration, then there are fresh oranges that will never rot, and we return -1.\\n```\\nclass Solution {\\n    private static final int FRESH = 1;\\n    private static final int ROTTEN = 2;\\n    \\n    public int orangesRotting(int[][] grid) {\\n        final int m = grid.length;\\n        final int n = grid[0].length;\\n        \\n        // Scan for rotten oranges, and place in a queue.\\n        // Also count fresh oranges.\\n        int freshCount = 0;\\n        ArrayDeque<Integer> queue = new ArrayDeque<Integer>();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                switch (grid[i][j]) {\\n                    case FRESH: freshCount++; break;\\n                    case ROTTEN: queue.add(i * n + j); break;\\n                }\\n        if (freshCount == 0) return 0;\\n        \\n        // Use BFS to rot the oranges, and count the number of iterations\\n        int turns = 0;\\n        while (freshCount > 0 && !queue.isEmpty()) {\\n            turns++;\\n            \\n            // Pull each of the rotten oranges from the queue\\n            int queueSize = queue.size();\\n            for (int k = 0; k < queueSize; k++) {\\n                int ij = queue.pollFirst();\\n                int i = ij / n;\\n                int j = ij % n;\\n                \\n                // Find any adjacent fresh oranges, and rot them.\\n                // Decrement the fresh count, and queue the newly rotted orange.\\n                if (i > 0 && grid[i-1][j] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i-1][j] = ROTTEN;\\n                    queue.add((i-1) * n + j);\\n                }\\n                if (i < m-1 && grid[i+1][j] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i+1][j] = ROTTEN;\\n                    queue.add((i+1) * n + j);\\n                }\\n                if (j > 0 && grid[i][j-1] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i][j-1] = ROTTEN;\\n                    queue.add(i * n + j - 1);\\n                }\\n                if (j < n-1 && grid[i][j+1] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i][j+1] = ROTTEN;\\n                    queue.add(i * n + j + 1);\\n                }\\n            }\\n        }\\n        if (freshCount > 0) return -1;\\n        return turns;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int FRESH = 1;\\n    private static final int ROTTEN = 2;\\n    \\n    public int orangesRotting(int[][] grid) {\\n        final int m = grid.length;\\n        final int n = grid[0].length;\\n        \\n        // Scan for rotten oranges, and place in a queue.\\n        // Also count fresh oranges.\\n        int freshCount = 0;\\n        ArrayDeque<Integer> queue = new ArrayDeque<Integer>();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                switch (grid[i][j]) {\\n                    case FRESH: freshCount++; break;\\n                    case ROTTEN: queue.add(i * n + j); break;\\n                }\\n        if (freshCount == 0) return 0;\\n        \\n        // Use BFS to rot the oranges, and count the number of iterations\\n        int turns = 0;\\n        while (freshCount > 0 && !queue.isEmpty()) {\\n            turns++;\\n            \\n            // Pull each of the rotten oranges from the queue\\n            int queueSize = queue.size();\\n            for (int k = 0; k < queueSize; k++) {\\n                int ij = queue.pollFirst();\\n                int i = ij / n;\\n                int j = ij % n;\\n                \\n                // Find any adjacent fresh oranges, and rot them.\\n                // Decrement the fresh count, and queue the newly rotted orange.\\n                if (i > 0 && grid[i-1][j] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i-1][j] = ROTTEN;\\n                    queue.add((i-1) * n + j);\\n                }\\n                if (i < m-1 && grid[i+1][j] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i+1][j] = ROTTEN;\\n                    queue.add((i+1) * n + j);\\n                }\\n                if (j > 0 && grid[i][j-1] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i][j-1] = ROTTEN;\\n                    queue.add(i * n + j - 1);\\n                }\\n                if (j < n-1 && grid[i][j+1] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i][j+1] = ROTTEN;\\n                    queue.add(i * n + j + 1);\\n                }\\n            }\\n        }\\n        if (freshCount > 0) return -1;\\n        return turns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547204,
                "title": "python3-bfs",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        que = []\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 2:\\n                    que.append((i, j))\\n        adj = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        t = 0\\n        while que:\\n            f = 0\\n            for i in range(len(que)):\\n                u = que.pop(0)\\n                for v in adj:\\n                    if u[0]+v[0] > -1 and u[1]+v[1] > -1 and u[0]+v[0] < n and u[1]+v[1] < m and grid[u[0]+v[0]][u[1]+v[1]] == 1:\\n                        f = 1\\n                        grid[u[0]+v[0]][u[1]+v[1]] = 2\\n                        que.append((u[0]+v[0], u[1]+v[1]))\\n            t += f\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1:\\n                    return -1\\n        return t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        que = []\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 2:\\n                    que.append((i, j))\\n        adj = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        t = 0\\n        while que:\\n            f = 0\\n            for i in range(len(que)):\\n                u = que.pop(0)\\n                for v in adj:\\n                    if u[0]+v[0] > -1 and u[1]+v[1] > -1 and u[0]+v[0] < n and u[1]+v[1] < m and grid[u[0]+v[0]][u[1]+v[1]] == 1:\\n                        f = 1\\n                        grid[u[0]+v[0]][u[1]+v[1]] = 2\\n                        que.append((u[0]+v[0], u[1]+v[1]))\\n            t += f\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1:\\n                    return -1\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523794,
                "title": "c-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        int m=grid.size();\\n        \\n        queue<pair<int,int>>q;\\n        //to move in four direction\\n        vector<int> dir={-1,0,1,0,-1};\\n        //to count how many fresh oranges we have to rot\\n        int fresh_oranges=0;\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                }\\n                if(grid[i][j]==1)\\n                    fresh_oranges++;\\n            }\\n        }\\n        \\n        int ans=-1;\\n        \\n        while(!q.empty()){\\n            \\n            int N=q.size();\\n            \\n            for(int i=0;i<N;i++){\\n                pair<int,int>tmp=q.front();\\n                q.pop();\\n                //initializing this loop for the movement in four direction\\n                for(int j=0;j<4;j++){\\n                    \\n                    int a=tmp.first+dir[j];\\n                    int b=tmp.second+dir[j+1];\\n                    //we would perform any operation only when encountered with a fresh oranges\\n                    //checking the boundaries and fresh oranges\\n                    if(a>=0 && a<m && b<n && b>=0 && grid[a][b]==1){\\n                        \\n                        grid[a][b]=2;\\n                        q.push({a,b});\\n                        fresh_oranges--;\\n                    }\\n                }\\n                \\n            }\\n            ans++;\\n            \\n        }\\n        //if perfoming all operation still fresh oranges have been left\\n        if(fresh_oranges>0) return -1;\\n        \\n        return ans==-1?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        int m=grid.size();\\n        \\n        queue<pair<int,int>>q;\\n        //to move in four direction\\n        vector<int> dir={-1,0,1,0,-1};\\n        //to count how many fresh oranges we have to rot\\n        int fresh_oranges=0;\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                }\\n                if(grid[i][j]==1)\\n                    fresh_oranges++;\\n            }\\n        }\\n        \\n        int ans=-1;\\n        \\n        while(!q.empty()){\\n            \\n            int N=q.size();\\n            \\n            for(int i=0;i<N;i++){\\n                pair<int,int>tmp=q.front();\\n                q.pop();\\n                //initializing this loop for the movement in four direction\\n                for(int j=0;j<4;j++){\\n                    \\n                    int a=tmp.first+dir[j];\\n                    int b=tmp.second+dir[j+1];\\n                    //we would perform any operation only when encountered with a fresh oranges\\n                    //checking the boundaries and fresh oranges\\n                    if(a>=0 && a<m && b<n && b>=0 && grid[a][b]==1){\\n                        \\n                        grid[a][b]=2;\\n                        q.push({a,b});\\n                        fresh_oranges--;\\n                    }\\n                }\\n                \\n            }\\n            ans++;\\n            \\n        }\\n        //if perfoming all operation still fresh oranges have been left\\n        if(fresh_oranges>0) return -1;\\n        \\n        return ans==-1?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461002,
                "title": "c-beginner-easy-to-understand-explained-bfs-multisource",
                "content": "# ***Approach***\\n```\\nTime : O(m * n)\\nSpace : O(m * n) , required for queue\\nThis is a very good MultiSource bfs problem\\n\\nAlgo steps:\\n    (1) Push all rotten oranges to queue\\n    (2) check for edge cases\\n    \\n        if in our grid we don\\'t have any rotten oranges:\\n            if fresh_orange_exists:\\n                return -1; // as no rotten orange exists!!!\\n            else\\n                return 0; // both rotten and fresh orange doesn\\'t exists\\n\\n    (3) Use multisource BFS to rot all fresh oranges adjacent to rotten oranges\\n        Logic for pushing oranges to queue for a given rotten orange!!!\\n            check all four directions UP,DOWN,LEFT,RIGHT\\n            then check \\n            if(neighbor isin grid boundary AND neighbor is a fresh orange)\\n                make it rotten , push it to queue\\n    (4) After bfs is completed check\\n            if any fresh orange still exist , \\n                return -1 , as we can\\'t rot all fresh oranges\\n            else\\n                return minutes;\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>> &grid) {\\n        queue<pair<int,int>> q;\\n        bool fresh_orange_exists = false;\\n        \\n        // Pushing all rotten oranges to q\\n        for(int i = 0 ; i < grid.size() ; ++i)\\n            for(int j = 0 ; j < grid[0].size() ; ++j)\\n                if(grid[i][j] == 2)\\n                    q.push(make_pair(i , j));\\n                else if(grid[i][j] == 1)\\n                    fresh_orange_exists = true;\\n        \\n        \\n        if(q.empty())// means no rotten orange exists initially\\n            if(fresh_orange_exists)\\n                return -1;\\n            else\\n                return 0;\\n        \\n        int minutes = -1;\\n        \\n        // Multisource BFS\\n        while(q.empty() == false)\\n        {\\n            int n = q.size();\\n            while(n)\\n            {\\n                int i = q.front().first;\\n                int j = q.front().second;\\n                q.pop();\\n                \\n                // pushing all fresh oranges neighboring to current rotten orange\\n                // LOGIC : if(neighbor isin grid boundary and is a fresh orange)\\n                //                make it rotten , push it to queue\\n                if(i - 1 >= 0 and grid[i - 1][j] == 1) // UP\\n                    grid[i - 1][j] = 2 , q.push(make_pair(i - 1 , j));\\n                if(i + 1 < grid.size() and grid[i + 1][j] == 1) // DOWN\\n                    grid[i + 1][j] = 2 , q.push(make_pair(i + 1 , j));\\n                if(j - 1 >= 0 and grid[i][j - 1] == 1) // LEFT\\n                    grid[i][j - 1] = 2 , q.push(make_pair(i , j - 1));\\n                if(j + 1 < grid[0].size() and grid[i][j + 1] == 1) // RIGHT\\n                    grid[i][j + 1] = 2 , q.push(make_pair(i , j + 1));\\n                \\n                n -= 1;\\n            }\\n            minutes += 1;\\n        }\\n        \\n        for(int i = 0 ; i < grid.size() ; ++i)\\n            for(int j = 0 ; j < grid[0].size() ; ++j)\\n                if(grid[i][j] == 1)\\n                    return -1; // All oranges can\\'t be made rotten\\n        \\n        return minutes;\\n    }\\n};\\n```\\n# ***If you liked the Solution , Please Upvote :)***",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nTime : O(m * n)\\nSpace : O(m * n) , required for queue\\nThis is a very good MultiSource bfs problem\\n\\nAlgo steps:\\n    (1) Push all rotten oranges to queue\\n    (2) check for edge cases\\n    \\n        if in our grid we don\\'t have any rotten oranges:\\n            if fresh_orange_exists:\\n                return -1; // as no rotten orange exists!!!\\n            else\\n                return 0; // both rotten and fresh orange doesn\\'t exists\\n\\n    (3) Use multisource BFS to rot all fresh oranges adjacent to rotten oranges\\n        Logic for pushing oranges to queue for a given rotten orange!!!\\n            check all four directions UP,DOWN,LEFT,RIGHT\\n            then check \\n            if(neighbor isin grid boundary AND neighbor is a fresh orange)\\n                make it rotten , push it to queue\\n    (4) After bfs is completed check\\n            if any fresh orange still exist , \\n                return -1 , as we can\\'t rot all fresh oranges\\n            else\\n                return minutes;\\n```\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>> &grid) {\\n        queue<pair<int,int>> q;\\n        bool fresh_orange_exists = false;\\n        \\n        // Pushing all rotten oranges to q\\n        for(int i = 0 ; i < grid.size() ; ++i)\\n            for(int j = 0 ; j < grid[0].size() ; ++j)\\n                if(grid[i][j] == 2)\\n                    q.push(make_pair(i , j));\\n                else if(grid[i][j] == 1)\\n                    fresh_orange_exists = true;\\n        \\n        \\n        if(q.empty())// means no rotten orange exists initially\\n            if(fresh_orange_exists)\\n                return -1;\\n            else\\n                return 0;\\n        \\n        int minutes = -1;\\n        \\n        // Multisource BFS\\n        while(q.empty() == false)\\n        {\\n            int n = q.size();\\n            while(n)\\n            {\\n                int i = q.front().first;\\n                int j = q.front().second;\\n                q.pop();\\n                \\n                // pushing all fresh oranges neighboring to current rotten orange\\n                // LOGIC : if(neighbor isin grid boundary and is a fresh orange)\\n                //                make it rotten , push it to queue\\n                if(i - 1 >= 0 and grid[i - 1][j] == 1) // UP\\n                    grid[i - 1][j] = 2 , q.push(make_pair(i - 1 , j));\\n                if(i + 1 < grid.size() and grid[i + 1][j] == 1) // DOWN\\n                    grid[i + 1][j] = 2 , q.push(make_pair(i + 1 , j));\\n                if(j - 1 >= 0 and grid[i][j - 1] == 1) // LEFT\\n                    grid[i][j - 1] = 2 , q.push(make_pair(i , j - 1));\\n                if(j + 1 < grid[0].size() and grid[i][j + 1] == 1) // RIGHT\\n                    grid[i][j + 1] = 2 , q.push(make_pair(i , j + 1));\\n                \\n                n -= 1;\\n            }\\n            minutes += 1;\\n        }\\n        \\n        for(int i = 0 ; i < grid.size() ; ++i)\\n            for(int j = 0 ; j < grid[0].size() ; ++j)\\n                if(grid[i][j] == 1)\\n                    return -1; // All oranges can\\'t be made rotten\\n        \\n        return minutes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454981,
                "title": "python-bfs-clean-concise",
                "content": "**Solution 1: BFS**\\n```python\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m, n, remainFreshOrange = len(grid), len(grid[0]), 0\\n        bfs = deque([])\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 2:\\n                    bfs.append((r, c))\\n                    grid[r][c] = 0\\n                elif grid[r][c] == 1:\\n                    remainFreshOrange += 1\\n            \\n        DIR = [0, 1, 0, -1, 0]\\n        minute = 0\\n        while bfs and remainFreshOrange > 0:\\n            for _ in range(len(bfs)):\\n                r, c = bfs.popleft()\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] != 1: continue\\n                    grid[nr][nc] = 0\\n                    remainFreshOrange -= 1\\n                    bfs.append((nr, nc))\\n            minute += 1\\n        if remainFreshOrange > 0: return -1\\n        return minute\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 10` is number of rows, `N <= 10` is number of columns in the grid.\\n- Space: `O(M*N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m, n, remainFreshOrange = len(grid), len(grid[0]), 0\\n        bfs = deque([])\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 2:\\n                    bfs.append((r, c))\\n                    grid[r][c] = 0\\n                elif grid[r][c] == 1:\\n                    remainFreshOrange += 1\\n            \\n        DIR = [0, 1, 0, -1, 0]\\n        minute = 0\\n        while bfs and remainFreshOrange > 0:\\n            for _ in range(len(bfs)):\\n                r, c = bfs.popleft()\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] != 1: continue\\n                    grid[nr][nc] = 0\\n                    remainFreshOrange -= 1\\n                    bfs.append((nr, nc))\\n            minute += 1\\n        if remainFreshOrange > 0: return -1\\n        return minute\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368883,
                "title": "easy-and-readable-code-python-bfs",
                "content": "**PLEASE DO UPVOTE IF U FIND MY CODE HELPFUL**\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    \\n    def isValid(self, li, r, c, n, m):\\n        if 0<=r<n and 0<=c<m and li[r][c] == 1: #if fresh return\\n            return True\\n        return False\\n        \\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n            0 -> empty\\n            1 -> fresh\\n            2 -> Rotten\\n            \\n            Return -1 if any fresh orange is isolated and cannot be rotten\\n            \\n            In the starting time frame there may be multiple starting points\\n            So perform a scan on matrix and add them to queue (store the position in the matrix)\\n            every element should be in the form of at which time this is rotten\\n        \"\"\"\\n        n,m = len(grid), len(grid[0])\\n        queue = deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 2: #rotten orange\\n                    queue.append((0, i, j))\\n                    \\n        ################INITIAL PROCESSING IS DONE#################\\n        row,col = [0, -1, 0, 1], [-1, 0,  1, 0]\\n        last_time = 0\\n        while len(queue):\\n            for _ in range(len(queue)): #going level wise\\n                time, i, j = queue.popleft()\\n                last_time = time\\n                for k in range(4):\\n                    nr, nc = i+row[k], j+col[k]\\n                    if self.isValid(grid, nr, nc, n, m): #check neighbors for fresh orange\\n                        grid[nr][nc] = 2 \\n                        queue.append((time+1, nr, nc))\\n        \\n        ########FINAL CHECK IF THERE ARE ANY FRESH ORANGES LEFT######\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1: #According to question\\n                    return -1\\n        \\n        return last_time  #this says that last time you havent found the fresh oranges that to be rotten\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    \\n    def isValid(self, li, r, c, n, m):\\n        if 0<=r<n and 0<=c<m and li[r][c] == 1: #if fresh return\\n            return True\\n        return False\\n        \\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n            0 -> empty\\n            1 -> fresh\\n            2 -> Rotten\\n            \\n            Return -1 if any fresh orange is isolated and cannot be rotten\\n            \\n            In the starting time frame there may be multiple starting points\\n            So perform a scan on matrix and add them to queue (store the position in the matrix)\\n            every element should be in the form of at which time this is rotten\\n        \"\"\"\\n        n,m = len(grid), len(grid[0])\\n        queue = deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 2: #rotten orange\\n                    queue.append((0, i, j))\\n                    \\n        ################INITIAL PROCESSING IS DONE#################\\n        row,col = [0, -1, 0, 1], [-1, 0,  1, 0]\\n        last_time = 0\\n        while len(queue):\\n            for _ in range(len(queue)): #going level wise\\n                time, i, j = queue.popleft()\\n                last_time = time\\n                for k in range(4):\\n                    nr, nc = i+row[k], j+col[k]\\n                    if self.isValid(grid, nr, nc, n, m): #check neighbors for fresh orange\\n                        grid[nr][nc] = 2 \\n                        queue.append((time+1, nr, nc))\\n        \\n        ########FINAL CHECK IF THERE ARE ANY FRESH ORANGES LEFT######\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1: #According to question\\n                    return -1\\n        \\n        return last_time  #this says that last time you havent found the fresh oranges that to be rotten\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360125,
                "title": "java-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public class Pair{\\n        int x, y;\\n        Pair(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, time = -1;\\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        Queue<Pair> q = new ArrayDeque<>();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j] == 2)\\n                    q.add(new Pair(i, j));\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Pair rem = q.remove();\\n                for(int i = 0; i < 4; i++){\\n                    int x = rem.x + dirs[i][0], y = rem.y + dirs[i][1];\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 1){\\n                        grid[x][y] = 2;\\n                        q.add(new Pair(x, y));\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j] == 1)\\n                    return -1;\\n        return Math.max(time, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public class Pair{\\n        int x, y;\\n        Pair(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, time = -1;\\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        Queue<Pair> q = new ArrayDeque<>();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j] == 2)\\n                    q.add(new Pair(i, j));\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Pair rem = q.remove();\\n                for(int i = 0; i < 4; i++){\\n                    int x = rem.x + dirs[i][0], y = rem.y + dirs[i][1];\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 1){\\n                        grid[x][y] = 2;\\n                        q.add(new Pair(x, y));\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j] == 1)\\n                    return -1;\\n        return Math.max(time, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568275,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1566630,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1916457,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1721818,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1575167,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1988569,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1575546,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1569791,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1569434,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1691989,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1568275,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1566630,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1916457,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1721818,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1575167,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1988569,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1575546,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1569791,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1569434,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1691989,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1883231,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1923991,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1787700,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1572458,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1972347,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1796687,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1719170,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 2062374,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 2055019,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 2036241,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 2025528,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 2017847,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 2004585,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1994628,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1937174,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1922325,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1883066,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1840088,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1816825,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1804791,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Good Nodes in Binary Tree",
        "question_content": "<p>Given a binary tree <code>root</code>, a node <em>X</em> in the tree is named&nbsp;<strong>good</strong> if in the path from root to <em>X</em> there are no nodes with a value <em>greater than</em> X.</p>\r\n\r\n<p>Return the number of <strong>good</strong> nodes in the binary tree.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png\" style=\"width: 263px; height: 156px;\" /></strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [3,1,4,3,null,1,5]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> Nodes in blue are <strong>good</strong>.\r\nRoot Node (3) is always a good node.\r\nNode 4 -&gt; (3,4) is the maximum value in the path starting from the root.\r\nNode 5 -&gt; (3,4,5) is the maximum value in the path\r\nNode 3 -&gt; (3,1,3) is the maximum value in the path.</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png\" style=\"width: 157px; height: 161px;\" /></strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [3,3,null,4,2]\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> Node 2 -&gt; (3, 3, 2) is not good, because &quot;3&quot; is higher than it.</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [1]\r\n<strong>Output:</strong> 1\r\n<strong>Explanation:</strong> Root is considered as <strong>good</strong>.</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li>The number of nodes in the binary tree is in the range&nbsp;<code>[1, 10^5]</code>.</li>\r\n\t<li>Each node&#39;s value is between <code>[-10^4, 10^4]</code>.</li>\r\n</ul>",
        "solutions": [
            {
                "id": 635259,
                "title": "java-c-python-one-line",
                "content": "## **Explanation**:\\nRecord the maximum value along the path from the root to the node.\\n\\nTime `O(N)`\\nSpace `O(height)`\\n<br>\\n\\n**Java:**\\n```java\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return goodNodes(root, -10000);\\n    }\\n\\n    public int goodNodes(TreeNode root, int ma) {\\n        if (root == null) return 0;\\n        int res = root.val >= ma ? 1 : 0;\\n        res += goodNodes(root.left, Math.max(ma, root.val));\\n        res += goodNodes(root.right, Math.max(ma, root.val));\\n        return res;\\n    }\\n}\\n```\\n\\n**C++:**\\n```cpp\\n    int goodNodes(TreeNode* r, int ma = -10000) {\\n        return r ? goodNodes(r->left, max(ma, r->val)) + goodNodes(r->right, max(ma, r->val)) + (r->val >= ma) : 0;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def goodNodes(self, r, ma=-10000):\\n        return self.goodNodes(r.left, max(ma, r.val)) + self.goodNodes(r.right, max(ma, r.val)) + (r.val >= ma) if r else 0\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return goodNodes(root, -10000);\\n    }\\n\\n    public int goodNodes(TreeNode root, int ma) {\\n        if (root == null) return 0;\\n        int res = root.val >= ma ? 1 : 0;\\n        res += goodNodes(root.left, Math.max(ma, root.val));\\n        res += goodNodes(root.right, Math.max(ma, root.val));\\n        return res;\\n    }\\n}\\n```\n```cpp\\n    int goodNodes(TreeNode* r, int ma = -10000) {\\n        return r ? goodNodes(r->left, max(ma, r->val)) + goodNodes(r->right, max(ma, r->val)) + (r->val >= ma) : 0;\\n    }\\n```\n```py\\n    def goodNodes(self, r, ma=-10000):\\n        return self.goodNodes(r.left, max(ma, r.val)) + self.goodNodes(r.right, max(ma, r.val)) + (r.val >= ma) if r else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512547,
                "title": "c-python-c-97-dfs-detailed-graph-explantion-beginner-friendly-easy-to-understand",
                "content": "**Idea:**\\n1. DFS through every path, and keep tracking of biggest value(curMax) in the path.\\n2. If current node is `>=` the biggest value in the path, we add the answer by one.\\n\\nHere\\'s an example to show how the code works:\\n![image](https://assets.leetcode.com/users/images/b4ddf956-c833-4c7a-8b73-d24801729198_1662013636.4763367.png)\\n(In **Python**, we use list as a global valuable)\\n<iframe src=\"https://leetcode.com/playground/EunmHB7o/shared\" frameBorder=\"0\" width=\"1000\" height=\"400\"></iframe>\\n\\n**Please UPVOTE if you LIKE!!!**\\n![image](https://assets.leetcode.com/users/images/7ff39551-e702-480a-adbe-c9f5bb4e6471_1662013651.851416.png)\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "**Idea:**\\n1. DFS through every path, and keep tracking of biggest value(curMax) in the path.\\n2. If current node is `>=` the biggest value in the path, we add the answer by one.\\n\\nHere\\'s an example to show how the code works:\\n![image](https://assets.leetcode.com/users/images/b4ddf956-c833-4c7a-8b73-d24801729198_1662013636.4763367.png)\\n(In **Python**, we use list as a global valuable)\\n<iframe src=\"https://leetcode.com/playground/EunmHB7o/shared\" frameBorder=\"0\" width=\"1000\" height=\"400\"></iframe>\\n\\n**Please UPVOTE if you LIKE!!!**\\n![image](https://assets.leetcode.com/users/images/7ff39551-e702-480a-adbe-c9f5bb4e6471_1662013651.851416.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 635258,
                "title": "java-python-3-simple-recursive-and-iterative-dfs-codes-w-brief-explanation-and-analysis",
                "content": "**Two DFS methods**\\n\\n----\\n\\n**Method 1: recursive version**\\n\\n1. Update the maximum value found while recurse down to the paths from root to leaves;\\n2. If node value >= current maximum, count it in.\\n3. return the total number after the completion of all recursions.\\n\\n```java\\n    public int goodNodes(TreeNode root) {\\n        return preorder(root, root.val);\\n    }\\n    private int preorder(TreeNode n, int v) {\\n        if (n == null) // base cases.\\n            return 0;\\n        int max = Math.max(n.val, v); // maximum so far on the path.\\n        return (n.val >= v ? 1 : 0) + preorder(n.left, max) + preorder(n.right, max); // recurse to children.\\n    }\\n```\\n```python\\n    def goodNodes(self, root: TreeNode) -> int:\\n       \\n        def count(node: TreeNode, v: int) -> int:\\n            if node is None:\\n                return 0\\n            mx = max(node.val, v)\\n            return (node.val >= v) + count(node.left, mx) + count(node.right, mx)\\n        \\n        return count(root, root.val)\\n```\\n\\n----\\n\\n**Method 2: Iterative version**\\nCombine TreeNode with current path maximum into a `Node / tuple`, put it into a stack and do iterative DFS to count good nodes.\\n```java\\nclass Node {\\n    TreeNode tn;\\n    int currentMax = Integer.MIN_VALUE;\\n    public Node(TreeNode n, int mx) {\\n        tn = n;\\n        currentMax = Math.max(mx, n.val);\\n    }\\n}\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        Deque<Node> stk = new ArrayDeque<>();\\n        stk.push(new Node(root, root.val));\\n        int cnt = 0;\\n        while (!stk.isEmpty()) {\\n            Node cur = stk.pop();\\n            cnt += cur.tn.val >= cur.currentMax ? 1 : 0;\\n            for (TreeNode kid : new TreeNode[]{cur.tn.left, cur.tn.right}) {\\n                if (kid != null) {\\n                    stk.push(new Node(kid, cur.currentMax));\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n\\n```python\\n    def goodNodes(self, root: TreeNode) -> int:\\n        cnt = 0\\n        stk = [(root, root.val)]\\n        while stk:\\n            cur, current_max = stk.pop()\\n            cnt += cur.val >= current_max\\n            for kid in cur.left, cur.right:\\n                if kid:\\n                    stk.append((kid, max(cur.val, current_max)))\\n        return cnt\\n```\\n\\n----\\n\\n**Analysis:**\\nFor both methods,\\nTime: `O(n)`, space: `O(h)`, where `n` and `h` are the number and height of the binary tree, respectively.",
                "solutionTags": [],
                "code": "```java\\n    public int goodNodes(TreeNode root) {\\n        return preorder(root, root.val);\\n    }\\n    private int preorder(TreeNode n, int v) {\\n        if (n == null) // base cases.\\n            return 0;\\n        int max = Math.max(n.val, v); // maximum so far on the path.\\n        return (n.val >= v ? 1 : 0) + preorder(n.left, max) + preorder(n.right, max); // recurse to children.\\n    }\\n```\n```python\\n    def goodNodes(self, root: TreeNode) -> int:\\n       \\n        def count(node: TreeNode, v: int) -> int:\\n            if node is None:\\n                return 0\\n            mx = max(node.val, v)\\n            return (node.val >= v) + count(node.left, mx) + count(node.right, mx)\\n        \\n        return count(root, root.val)\\n```\n```java\\nclass Node {\\n    TreeNode tn;\\n    int currentMax = Integer.MIN_VALUE;\\n    public Node(TreeNode n, int mx) {\\n        tn = n;\\n        currentMax = Math.max(mx, n.val);\\n    }\\n}\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        Deque<Node> stk = new ArrayDeque<>();\\n        stk.push(new Node(root, root.val));\\n        int cnt = 0;\\n        while (!stk.isEmpty()) {\\n            Node cur = stk.pop();\\n            cnt += cur.tn.val >= cur.currentMax ? 1 : 0;\\n            for (TreeNode kid : new TreeNode[]{cur.tn.left, cur.tn.right}) {\\n                if (kid != null) {\\n                    stk.push(new Node(kid, cur.currentMax));\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```python\\n    def goodNodes(self, root: TreeNode) -> int:\\n        cnt = 0\\n        stk = [(root, root.val)]\\n        while stk:\\n            cur, current_max = stk.pop()\\n            cnt += cur.val >= current_max\\n            for kid in cur.left, cur.right:\\n                if kid:\\n                    stk.append((kid, max(cur.val, current_max)))\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635351,
                "title": "bfs-with-maxvalue-template-of-similar-problems-python",
                "content": "From very First problem I used to apply BFS only so i have come up with this soln.\\nevery Easy/Mediam level Tree Problems has same concept of travesal of tree and keep track of other parameter like path or sum etc... you can use Same template given hear or your Own..\\n\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n\\t\\n\\t\\tans = 0\\n        q = deque()\\n\\t\\t\\n        q.append((root,-inf))\\n        \\'\\'\\'perform bfs  with track of maxval till perant node\\'\\'\\'\\t\\n\\n        while q:\\n            node,maxval = q.popleft()\\n\\t\\t\\t \\'\\'\\'if curr node has max or eqvalue till current max\\'\\'\\'\\n            if node.val >= maxval:  \\n                ans += 1\\n\\t\\t\\t\\t\\n            if node.left:    #new max update\\n                q.append((node.left,max(maxval,node.val)))\\n            \\n            if node.right:\\n                q.append((node.right,max(maxval,node.val)))\\n                \\n        return ans\\n```\\nhear listed a few problems you can do with same template..\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/)\\n```\\ndef hasPathSum(self, root: TreeNode, sumT: int) -> bool:\\n        if not root:\\n            return False\\n        q = deque()\\n        q.append((root,0))        # track of path\\n        while q:\\n            node,value = q.popleft()\\n            print(value)\\n            if not node.left and not node.right:\\n                if sumT == value + node.val:\\n                    return True\\n            if node.left:\\n                q.append((node.left,value+node.val))\\n            if node.right:\\n                q.append((node.right,value+node.val))\\n        return False\\n```\\n\\n[100.Same Tree](https://leetcode.com/problems/same-tree/)\\n```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        queue = deque()\\n        queue.append(p)\\n        queue.append(q)\\n        while queue:\\n            node1= queue.popleft()\\n            node2 = queue.popleft()\\n            \\n            if not node1 and not node2:      # track of same node you can define fun isMatch(n1,n2) and based on that track or return also\\n                continue\\n            \\n            if not node1 or not node2:\\n                return False\\n            \\n            if node1.val != node2.val:\\n                return False\\n            \\n            queue.append(node1.left)\\n            queue.append(node2.left)\\n            queue.append(node1.right)\\n            queue.append(node2.right)\\n            \\n        return True\\n```\\n[101.symmetric-tree](https://leetcode.com/problems/symmetric-tree/)\\n```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n#         q = deque()\\n#         q.append(root)\\n#         q.append(root)\\n#         while q:\\n#             t1 = q.popleft()\\n#             t2 = q.popleft()\\n            \\n#             if not t1 and not t2:\\n#                 continue\\n#             if not t1 or not t2:\\n#                 return False\\n#             if t1.val != t2.val:\\n#                 return False\\n            \\n#             q.append(t1.right)\\n#             q.append(t2.left)\\n#             q.append(t1.left)\\n#             q.append(t2.right)\\n#         return True\\n```\\n[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)\\n```\\ndef levelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\n        if not root:\\n            return []\\n        q=deque()\\n        q.append((root,1))\\n        answer = defaultdict(list)        #track of level order nodes\\n        \\n        while q:\\n            node,depth= q.popleft()\\n            answer[depth].append(node.val)\\n            if node.left:\\n                q.append((node.left,depth+1))\\n            if node.right:\\n                q.append((node.right,depth+1))\\n        return answer.values()\\n```\\n[103. Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)\\n```\\n def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        ans = defaultdict(list)\\n        if not root:\\n            return None\\n        q = deque()\\n        q.append((root,0))\\n        \\n        while q:\\n            node,depth = q.popleft()\\n            ans[depth].append(node.val)\\n            if node.left :\\n                q.append((node.left,depth+1))\\n            if node.right :\\n                q.append((node.right,depth+1))\\n        ct = 0        \\n        for i in ans:\\n            if ct % 2 :\\n                ans[i] = reversed(ans[i])\\n            ct+=1\\n        return ans.values()\\n```\\n\\nAnd Many More [257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) [404. Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves/) [1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/)\\n\\nfor N-array tree\\n[559. Maximum Depth of N-ary Tree](https://leetcode.com/problems/maximum-depth-of-n-ary-tree/)\\n```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        \\n\\n    \\n        if not root:\\n            return 0\\n        q=deque()\\n        maxdepth=-(math.inf)\\n        q.append((root,1))\\n        while q:\\n            node,depth = q.popleft()\\n            if not node.children:\\n                maxdepth=max(maxdepth,depth)\\n                \\n            for i in  node.children:\\n                q.append((i,depth+1))\\n           \\n        return maxdepth\\n```\\n\\nYou can also find By your self many more examples...by your own.. find and try to applay this kind of methods and thinks in that way also a bit.. thank you. happy coding.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n\\t\\n\\t\\tans = 0\\n        q = deque()\\n\\t\\t\\n        q.append((root,-inf))\\n        \\'\\'\\'perform bfs  with track of maxval till perant node\\'\\'\\'\\t\\n\\n        while q:\\n            node,maxval = q.popleft()\\n\\t\\t\\t \\'\\'\\'if curr node has max or eqvalue till current max\\'\\'\\'\\n            if node.val >= maxval:  \\n                ans += 1\\n\\t\\t\\t\\t\\n            if node.left:    #new max update\\n                q.append((node.left,max(maxval,node.val)))\\n            \\n            if node.right:\\n                q.append((node.right,max(maxval,node.val)))\\n                \\n        return ans\\n```\n```\\ndef hasPathSum(self, root: TreeNode, sumT: int) -> bool:\\n        if not root:\\n            return False\\n        q = deque()\\n        q.append((root,0))        # track of path\\n        while q:\\n            node,value = q.popleft()\\n            print(value)\\n            if not node.left and not node.right:\\n                if sumT == value + node.val:\\n                    return True\\n            if node.left:\\n                q.append((node.left,value+node.val))\\n            if node.right:\\n                q.append((node.right,value+node.val))\\n        return False\\n```\n```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        queue = deque()\\n        queue.append(p)\\n        queue.append(q)\\n        while queue:\\n            node1= queue.popleft()\\n            node2 = queue.popleft()\\n            \\n            if not node1 and not node2:      # track of same node you can define fun isMatch(n1,n2) and based on that track or return also\\n                continue\\n            \\n            if not node1 or not node2:\\n                return False\\n            \\n            if node1.val != node2.val:\\n                return False\\n            \\n            queue.append(node1.left)\\n            queue.append(node2.left)\\n            queue.append(node1.right)\\n            queue.append(node2.right)\\n            \\n        return True\\n```\n```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n#         q = deque()\\n#         q.append(root)\\n#         q.append(root)\\n#         while q:\\n#             t1 = q.popleft()\\n#             t2 = q.popleft()\\n            \\n#             if not t1 and not t2:\\n#                 continue\\n#             if not t1 or not t2:\\n#                 return False\\n#             if t1.val != t2.val:\\n#                 return False\\n            \\n#             q.append(t1.right)\\n#             q.append(t2.left)\\n#             q.append(t1.left)\\n#             q.append(t2.right)\\n#         return True\\n```\n```\\ndef levelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\n        if not root:\\n            return []\\n        q=deque()\\n        q.append((root,1))\\n        answer = defaultdict(list)        #track of level order nodes\\n        \\n        while q:\\n            node,depth= q.popleft()\\n            answer[depth].append(node.val)\\n            if node.left:\\n                q.append((node.left,depth+1))\\n            if node.right:\\n                q.append((node.right,depth+1))\\n        return answer.values()\\n```\n```\\n def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        ans = defaultdict(list)\\n        if not root:\\n            return None\\n        q = deque()\\n        q.append((root,0))\\n        \\n        while q:\\n            node,depth = q.popleft()\\n            ans[depth].append(node.val)\\n            if node.left :\\n                q.append((node.left,depth+1))\\n            if node.right :\\n                q.append((node.right,depth+1))\\n        ct = 0        \\n        for i in ans:\\n            if ct % 2 :\\n                ans[i] = reversed(ans[i])\\n            ct+=1\\n        return ans.values()\\n```\n```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        \\n\\n    \\n        if not root:\\n            return 0\\n        q=deque()\\n        maxdepth=-(math.inf)\\n        q.append((root,1))\\n        while q:\\n            node,depth = q.popleft()\\n            if not node.children:\\n                maxdepth=max(maxdepth,depth)\\n                \\n            for i in  node.children:\\n                q.append((i,depth+1))\\n           \\n        return maxdepth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635419,
                "title": "c-preorder-traversal-simple-logic-detail-explanation",
                "content": "**logic** : \\n* preorder traverse  the tree\\n* for every recurson call apart from the parent node also pass the maximum value seen so far\\n* if the current node value is greater or equal to maximum seen till now then increase count and update that maximum \\n\\n```\\nclass Solution {\\n    int ans=0;\\n    void pre(TreeNode* root,int max){\\n        if(!root)return;\\n        if(root->val >= max){ ans++; max=root->val; }\\n        pre(root->left,max);\\n        pre(root->right,max);\\n    }\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        pre(root,INT_MIN);\\n        return ans;\\n    }\\n};\\n```\\nthankyou | please upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    void pre(TreeNode* root,int max){\\n        if(!root)return;\\n        if(root->val >= max){ ans++; max=root->val; }\\n        pre(root->left,max);\\n        pre(root->right,max);\\n    }\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        pre(root,INT_MIN);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511520,
                "title": "c-python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**APPROACH**\\n\\nAny sort of traversal would work here.\\nWhile traversing the tree, keep a variable that stores the maximum value till now in the path.\\nCompare it with node value to decide whether it is a ood node or not.\\n\\n\\n**BASE CASE**\\n* Return ```0```, whenever ```root == NULL```\\n\\n**RECURSIVE CALL**\\n* Call the funtion for both ```root->left``` and ```root->right``` and changing the max value to ```max(max_till_now,root->val)```\\n\\n**SELF-WORK**\\n* Get answer recursively for next nodes.\\n* If ```root->val > max_value_till_now``` increment the answer by one.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* root,int hi){\\n        if (root){\\n            int k=solve(root->left, max(hi,root->val)) + solve(root->right, max(hi,root->val));\\n            if (root->val>=hi){\\n                k++;\\n            }\\n            return k;\\n        }\\n        return 0;\\n    }\\n    int goodNodes(TreeNode* root) {\\n        return solve(root,-10001);\\n    }\\n};\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def solve(root,val):\\n            if root:\\n                k = solve(root.left, max(val,root.val)) + solve(root.right, max(val,root.val))\\n                if root.val >= val:\\n                    k+=1\\n                return k\\n            return 0\\n        return solve(root,root.val)\\n```\\n![image](https://assets.leetcode.com/users/images/304c24f3-aa82-4a6a-b561-6d2aa723e8b4_1661995426.5540051.webp)\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```0```\n```root == NULL```\n```root->left```\n```root->right```\n```max(max_till_now,root->val)```\n```root->val > max_value_till_now```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* root,int hi){\\n        if (root){\\n            int k=solve(root->left, max(hi,root->val)) + solve(root->right, max(hi,root->val));\\n            if (root->val>=hi){\\n                k++;\\n            }\\n            return k;\\n        }\\n        return 0;\\n    }\\n    int goodNodes(TreeNode* root) {\\n        return solve(root,-10001);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def solve(root,val):\\n            if root:\\n                k = solve(root.left, max(val,root.val)) + solve(root.right, max(val,root.val))\\n                if root.val >= val:\\n                    k+=1\\n                return k\\n            return 0\\n        return solve(root,root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635555,
                "title": "java-100-simple-easy-code-using-pre-order-tree-traversal",
                "content": "```\\nclass Solution {\\n    int good;\\n    public int goodNodes(TreeNode root) {\\n        good = 0;\\n        cal(root, Integer.MIN_VALUE);\\n        return good;\\n    }\\n    void cal(TreeNode root, int max){\\n        if(root == null) return;\\n        if(root.val >= max) good++;\\n        max = Math.max(max, root.val);\\n        cal(root.left, max);\\n        cal(root.right, max);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    int good;\\n    public int goodNodes(TreeNode root) {\\n        good = 0;\\n        cal(root, Integer.MIN_VALUE);\\n        return good;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 635203,
                "title": "c-one-liner",
                "content": "```cpp\\nint goodNodes(TreeNode* root, int val = INT_MIN) {\\n    return root == nullptr ? 0 : (val <= root->val) \\n        + goodNodes(root->left, max(root->val, val))\\n            + goodNodes(root->right, max(root->val, val));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint goodNodes(TreeNode* root, int val = INT_MIN) {\\n    return root == nullptr ? 0 : (val <= root->val) \\n        + goodNodes(root->left, max(root->val, val))\\n            + goodNodes(root->right, max(root->val, val));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1408493,
                "title": "python-dfs-keep-max-so-far-clean-concise",
                "content": "**Idea**\\n- Just `dfs` from the root down to its descendant nodes and keep `maxSoFar`.\\n- If the value of current node >= maxSofar then we increase count by one since it\\'s a good node.\\n\\n```python\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def dfs(root, maxSoFar):\\n            nonlocal ans\\n            if root == None: return\\n            if maxSoFar <= root.val:\\n                ans += 1\\n            maxSoFar = max(maxSoFar, root.val)\\n            dfs(root.left, maxSoFar)\\n            dfs(root.right, maxSoFar)\\n\\n        ans = 0\\n        dfs(root, root.val)\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N` is the number of nodes in the binary tree.\\n- Space: `O(H)`, where `H` is the height of binary tree.\\n\\n**Short Version**\\n```python\\nclass Solution:\\n    def goodNodes(self, root: TreeNode, curMax = -math.inf) -> int:\\n        if root == None: return 0\\n        return (curMax <= root.val) + self.goodNodes(root.left, max(curMax, root.val)) + self.goodNodes(root.right, max(curMax, root.val))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def dfs(root, maxSoFar):\\n            nonlocal ans\\n            if root == None: return\\n            if maxSoFar <= root.val:\\n                ans += 1\\n            maxSoFar = max(maxSoFar, root.val)\\n            dfs(root.left, maxSoFar)\\n            dfs(root.right, maxSoFar)\\n\\n        ans = 0\\n        dfs(root, root.val)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def goodNodes(self, root: TreeNode, curMax = -math.inf) -> int:\\n        if root == None: return 0\\n        return (curMax <= root.val) + self.goodNodes(root.left, max(curMax, root.val)) + self.goodNodes(root.right, max(curMax, root.val))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409366,
                "title": "c-preorder-traversal-explained-o-n",
                "content": "Simple Easy to understand solution. Basically intution is to use recursion as always we do in Tree problems.\\n\\n* Idea is simple, we track the maximum value until now.  If curr node value is greater than or equal to maximum then it is good node and increment. Other wise continue moving down in pre-order way in left and right subtree.\\n\\n* Now at each node in preorder traversal, we have 2 cases : \\n\\t\\n\\t1. if *value of current node < maximum value until now*, we do nothing as it is not a good node candidate.\\n\\t2. else if *value of current node >= maximum value until now*, we have found a good node. \\n\\n\\t\\t\\t\\t-> increament the goodNode counter for current node ans \\n\\t\\t\\t\\t\\t i.e goodNode++\\n\\t\\t\\t\\t-> update the maximum value, \\n\\t\\t\\t\\t\\t-> As from now we have to find a node with value greater than current max value for a possible good node candidate\\n\\t\\t\\t\\t\\t\\ti.e maxVal = root->val\\n\\n* Now, we move down and try to find more good nodes in left substree and right subtree and get those **good nodes count**. \\n* In the end we return count of good node along with left and right good nodes count.\\n\\t \\n\\t\\tgoodNode + solve(root->left, maxVal) + solve(root->right, maxVal)\\n\\t\\t\\t \\n* Also, in the base condition as it is the terminating condition,  we return zero when node is NULL.\\n\\t\\n\\t\\tif(!root) return 0;\\n\\n# Code : \\n\\n```\\nint solve(TreeNode* root, int maxVal)\\n{\\n\\tif(!root) return 0;\\n\\n\\tint goodNode = 0;\\n\\tif(root->val >= maxVal)\\n\\t{\\n\\t\\tmaxVal = root->val;\\n\\t\\tgoodNode++;\\n\\t}\\n\\n\\treturn goodNode + solve(root->left, maxVal) + solve(root->right, maxVal);\\n}\\n    \\nint goodNodes(TreeNode* root) {\\n        \\n\\tif(!root) return 0;\\n\\treturn solve(root, root->val);\\n}\\n```\\n**Time : O(N) as we traverse through each and every node only once.**\\n\\n*I hope you understood the explanation. Do upvote if you liked*\\nAlso feel free to ask any doubt or correct me :)",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nint solve(TreeNode* root, int maxVal)\\n{\\n\\tif(!root) return 0;\\n\\n\\tint goodNode = 0;\\n\\tif(root->val >= maxVal)\\n\\t{\\n\\t\\tmaxVal = root->val;\\n\\t\\tgoodNode++;\\n\\t}\\n\\n\\treturn goodNode + solve(root->left, maxVal) + solve(root->right, maxVal);\\n}\\n    \\nint goodNodes(TreeNode* root) {\\n        \\n\\tif(!root) return 0;\\n\\treturn solve(root, root->val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511620,
                "title": "easy-java-solution-100-faster-beginner-friendly-with-comments",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nint count = 0; // global variable to count\\n\\n    public int goodNodes(TreeNode root) {\\n        helper(root, root.val);\\n        return count; // returning the count value\\n    }\\n\\n    private void helper(TreeNode root, int max) {\\n        if (root != null) {\\n            if (root.val >= max) { // if root.val > the max value of path from root of the tree to current node \\n                count++; //increment count\\n            }\\n            helper(root.left, Math.max(root.val, max));  // updating max value of current path and traversing left to the current node\\n            helper(root.right, Math.max(root.val, max));  // updating max value of current path and traversing right to the current node\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nint count = 0; // global variable to count\\n\\n    public int goodNodes(TreeNode root) {\\n        helper(root, root.val);\\n        return count; // returning the count value\\n    }\\n\\n    private void helper(TreeNode root, int max) {\\n        if (root != null) {\\n            if (root.val >= max) { // if root.val > the max value of path from root of the tree to current node \\n                count++; //increment count\\n            }\\n            helper(root.left, Math.max(root.val, max));  // updating max value of current path and traversing left to the current node\\n            helper(root.right, Math.max(root.val, max));  // updating max value of current path and traversing right to the current node\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1408637,
                "title": "c-preorder-logic-explained-clearly-tc-o-n-sc-o-n",
                "content": "**Thought Process**\\n* Question say that, **path from root to X there are no nodes with a value greater than X**\\n* In other words, how many **elements in the path maintain ascending order** ? \\n* What can be the best way to check if the ascending order is maintained or not ? \\n   ***While traversing from root to any node, we can keep a variable having the maximum value till now***\\n\\n**How to implement ? (recursive implementation)**\\n1. Initially **let the max value be int_min**\\n2. At every node check **if ( node value )  >= ( max till now from root )**\\n\\t* \\tif **greater**, **increase the count**( bcz. we got one good node ) and **update the max value** which we need to pass for left and right subtree\\n3. Now get the **count for left and right subtree recursively** passing the updated max value as argument\\n4. so final ans will be  count( left subtree ) + count( right subtree ) + ( 1 or 0 as per step 2 )\\n\\n**Explanation on Time Complexity and Space complexity**( Read this after reading code )\\n* Its a preorder traversal , so we will be **visiting all thee nodes 1 time, let there be N nodes, so time complexity is O(N)**\\n* **Space complexity is just bcz. of recursive stack**, .... what will be the **max size of stack** ???? .... it will be the **height of the binary tree**, which is **N** in worst case , so the Space complexity is O(N)\\n\\n**Here is the final code :**\\n```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root, int maxFromRoot=INT_MIN) {\\n        \\n        // base case of recursion \\n        if( root == NULL) return 0; \\n        \\n        int count = 0;\\n        \\n        // if the root value is >= max value till now \\n        // we got a one good node, so increase the count \\n        // also update the max value which we are going to pass for left and right subtree\\n        if( root->val >= maxFromRoot){ \\n            count++;\\n            maxFromRoot = root->val;\\n        }\\n        \\n        // recursive call for sub problem \\n        count += goodNodes( root->left , maxFromRoot );\\n        count += goodNodes( root->right , maxFromRoot );\\n        \\n        // returning the final ans\\n        return count;\\n    }\\n};\\n```\\n\\n**Give it an upvote if it helped you.\\nHaving doubt ? Post in comment section !**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root, int maxFromRoot=INT_MIN) {\\n        \\n        // base case of recursion \\n        if( root == NULL) return 0; \\n        \\n        int count = 0;\\n        \\n        // if the root value is >= max value till now \\n        // we got a one good node, so increase the count \\n        // also update the max value which we are going to pass for left and right subtree\\n        if( root->val >= maxFromRoot){ \\n            count++;\\n            maxFromRoot = root->val;\\n        }\\n        \\n        // recursive call for sub problem \\n        count += goodNodes( root->left , maxFromRoot );\\n        count += goodNodes( root->right , maxFromRoot );\\n        \\n        // returning the final ans\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511705,
                "title": "leetcode-the-hard-way-dfs-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n**C++**\\n\\n```cpp\\n// Time complexity: O(N) as we visit every node only once.\\n// Space complexity: O(H) where H is the height of the tree.\\n// In the worst case, H would be N given that the tree only has one path.\\n\\nclass Solution {\\npublic:\\n    // the idea is to record the max value from the root to the node\\n    // we can first initialise mx as INT_MIN \\n    int goodNodes(TreeNode* root, int mx = INT_MIN) {\\n        // if the root is null, we return 0\\n        if (!root) return 0;\\n        // then we can break it into 3 parts\\n        // the first part is the current node\\n        // if the current node value is greater than the maximum value so far\\n        // that means the current node is a good node\\n        // hence we add 1, else add 0\\n        return (mx <= root->val ? 1 : 0) + \\n                // the second part is the result of the left sub-tree\\n                // we traverse it with the updated maximum value at the current point\\n                // we don\\'t need to check if root->left is null or not here\\n                // as we cover the null case in the first line\\n                goodNodes(root->left, max(root->val, mx)) + \\n                // the last part is the result of the right sub-tree\\n                // we traverse it with the updated maximum value at the current point\\n                // we don\\'t need to check if root->right is null or not here\\n                // as we cover the null case in the first line\\n                goodNodes(root->right, max(root->val, mx));\\n    }\\n};\\n```\\n\\n**Python3**\\n\\n```python\\n# Time complexity: O(N) as we visit every node only once.\\n# Space complexity: O(H) where H is the height of the tree.\\n# In the worst case, H would be N given that the tree only has one path.\\nclass Solution:\\n    # the idea is to record the max value from the root to the node\\n    # we can first initialise mx as -10000 \\n    def goodNodes(self, root: TreeNode, mx = -10000) -> int:\\n        # if the root is null, we return 0\\n        if root is None: return 0\\n        return (\\n            # then we can break it into 3 parts\\n            # the first part is the current node\\n            # if the current node value is greater than the maximum value so far\\n            # that means the current node is a good node\\n            # hence we add 1, else add 0\\n            (1 if mx <= root.val else 0) + \\n            # the second part is the result of the left sub-tree\\n            # we traverse it with the updated maximum value at the current point\\n            # we don\\'t need to check if root.left is null or not here\\n            # as we cover the null case in the first line\\n            self.goodNodes(root.left, max(root.val, mx)) +\\n            # the last part is the result of the right sub-tree\\n            # we traverse it with the updated maximum value at the current point\\n            # we don\\'t need to check if root.right is null or not here\\n            # as we cover the null case in the first line\\n            self.goodNodes(root.right, max(root.val, mx))\\n        )\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\n// Time complexity: O(N) as we visit every node only once.\\n// Space complexity: O(H) where H is the height of the tree.\\n// In the worst case, H would be N given that the tree only has one path.\\n\\nclass Solution {\\npublic:\\n    // the idea is to record the max value from the root to the node\\n    // we can first initialise mx as INT_MIN \\n    int goodNodes(TreeNode* root, int mx = INT_MIN) {\\n        // if the root is null, we return 0\\n        if (!root) return 0;\\n        // then we can break it into 3 parts\\n        // the first part is the current node\\n        // if the current node value is greater than the maximum value so far\\n        // that means the current node is a good node\\n        // hence we add 1, else add 0\\n        return (mx <= root->val ? 1 : 0) + \\n                // the second part is the result of the left sub-tree\\n                // we traverse it with the updated maximum value at the current point\\n                // we don\\'t need to check if root->left is null or not here\\n                // as we cover the null case in the first line\\n                goodNodes(root->left, max(root->val, mx)) + \\n                // the last part is the result of the right sub-tree\\n                // we traverse it with the updated maximum value at the current point\\n                // we don\\'t need to check if root->right is null or not here\\n                // as we cover the null case in the first line\\n                goodNodes(root->right, max(root->val, mx));\\n    }\\n};\\n```\n```python\\n# Time complexity: O(N) as we visit every node only once.\\n# Space complexity: O(H) where H is the height of the tree.\\n# In the worst case, H would be N given that the tree only has one path.\\nclass Solution:\\n    # the idea is to record the max value from the root to the node\\n    # we can first initialise mx as -10000 \\n    def goodNodes(self, root: TreeNode, mx = -10000) -> int:\\n        # if the root is null, we return 0\\n        if root is None: return 0\\n        return (\\n            # then we can break it into 3 parts\\n            # the first part is the current node\\n            # if the current node value is greater than the maximum value so far\\n            # that means the current node is a good node\\n            # hence we add 1, else add 0\\n            (1 if mx <= root.val else 0) + \\n            # the second part is the result of the left sub-tree\\n            # we traverse it with the updated maximum value at the current point\\n            # we don\\'t need to check if root.left is null or not here\\n            # as we cover the null case in the first line\\n            self.goodNodes(root.left, max(root.val, mx)) +\\n            # the last part is the result of the right sub-tree\\n            # we traverse it with the updated maximum value at the current point\\n            # we don\\'t need to check if root.right is null or not here\\n            # as we cover the null case in the first line\\n            self.goodNodes(root.right, max(root.val, mx))\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511753,
                "title": "explained-java-beats-100-of-solutions",
                "content": "**PLEASE UPVOTE IF THIS HELPS!**\\n\\n**Intuition**\\nFor each path all we really need to check is that the current point we are looking at is the largest one we have seen so far in our path from the root, so this is a manual search over all nodes while keeping reference to the largest value we have seen in our path.\\n\\n**Solution: Java**\\n\\n```java\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        if(root == null){ return 0; }\\n        int count = 1;\\n        \\n        count += dfs(root.left, root.val);\\n        count += dfs(root.right, root.val);\\n        return count;\\n    }\\n    \\n    public int dfs(TreeNode root, int currentMax){\\n        \\n        int amount = 0; \\n        if(root == null){ return 0; }\\n        if(root.val >= currentMax){\\n            amount++; \\n            currentMax = root.val;\\n        }\\n        \\n        amount += dfs(root.left, currentMax);\\n        amount += dfs(root.right, currentMax);\\n        return amount; \\n    }\\n}\\n```\\n\\n**Explanation:**\\nTime complexity: **O(# of nodes in tree)**\\nSpace complexity: **O(h) where h is the height of the tree**\\n\\nCheckout my youtube channel for upcoming videos: **https://www.youtube.com/channel/UCfvW4KQXzpE3ZZqNxAHnaPQ**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        if(root == null){ return 0; }\\n        int count = 1;\\n        \\n        count += dfs(root.left, root.val);\\n        count += dfs(root.right, root.val);\\n        return count;\\n    }\\n    \\n    public int dfs(TreeNode root, int currentMax){\\n        \\n        int amount = 0; \\n        if(root == null){ return 0; }\\n        if(root.val >= currentMax){\\n            amount++; \\n            currentMax = root.val;\\n        }\\n        \\n        amount += dfs(root.left, currentMax);\\n        amount += dfs(root.right, currentMax);\\n        return amount; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816519,
                "title": "c-easy-dfs-solution",
                "content": "Just Iterate Through All The Paths Via DFS \\n-maintain maxsofar : path\\'s max value \\n-maintain counter cc : if path satisfies our constraints : cc+=1\\n\\n```\\nclass Solution {\\npublic:\\n    int cc = 0;  \\n    void dfs(TreeNode* root, int maxSoFar) {   //maintain maxsofar : path\\'s max value \\n        \\n        if(root) {\\n            if(root->val >= maxSoFar) cc++;      //        maintain counter cc : if path satisfies our constraints : cc+=1\\n            \\n            dfs(root->left, max(maxSoFar,root->val));\\n            dfs(root->right, max(maxSoFar,root->val));\\n        }\\n    }\\n    int goodNodes(TreeNode* root) {\\n        dfs(root, INT_MIN);\\n        return cc;\\n    }\\n};\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int cc = 0;  \\n    void dfs(TreeNode* root, int maxSoFar) {   //maintain maxsofar : path\\'s max value \\n        \\n        if(root) {\\n            if(root->val >= maxSoFar) cc++;      //        maintain counter cc : if path satisfies our constraints : cc+=1\\n            \\n            dfs(root->left, max(maxSoFar,root->val));\\n            dfs(root->right, max(maxSoFar,root->val));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2511440,
                "title": "c-pre-order-traversal-intuitive-approach",
                "content": "**Upvote if you like the post :)**\\n\\n**What the problem actually says?**\\n`Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.`\\n\\n**Visual Demonstration Below(Showing the Good Nodes) :-**\\n![image](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)\\n\\n**Intuition**:\\n* Firstly we will traverse in `PreOrder` manner.\\n* Keep a `maxi` variable passing in the recursion calls except for the parent node\\n* If at any time the current node value is `>=` the maxi seen so far then just update the maxi and increase the counter;  \\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void pre(TreeNode* root,int maxi){\\n        if(!root) return;\\n        if(root->val>=maxi){\\n            ans++;\\n            maxi = root->val;\\n        }\\n        pre(root->left,maxi);\\n        pre(root->right,maxi);\\n    }\\n    int goodNodes(TreeNode* root) {\\n        pre(root,INT_MIN);\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity**: **O(N)**\\n**Space Complexity**: **O(N)** for recursion stack space.\\n****",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void pre(TreeNode* root,int maxi){\\n        if(!root) return;\\n        if(root->val>=maxi){\\n            ans++;\\n            maxi = root->val;\\n        }\\n        pre(root->left,maxi);\\n        pre(root->right,maxi);\\n    }\\n    int goodNodes(TreeNode* root) {\\n        pre(root,INT_MIN);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409127,
                "title": "python-easy-dfs-recursion",
                "content": "# Count Good Nodes in Binary Tree\\n**Idea**\\n* Starting from root node we traverse every path and calculate maximum till that node i.e. `max_so_far` \\n* Now compare whether current node is greater than `max_so_far` which we call good node `good` \\n* Then check and find number of good nodes in either left or right and then finally return total nodes \\n\\nWe shall achieve our goal with the help of **DFS** by taking one path at a time from root to the leaf nodes\\n\\n**For better understanding let\\'s take example**,\\n```\\n    7\\n   / \\\\\\n  8   3\\n /   / \\\\\\n2   11  5\\n```\\n*Notations :-*\\n* `<max_so_far(msf)> <current node> <max_so_far updated(msfu)>`\\n* `total no. of good nodes(tgn = 0)`\\n\\n```\\n                      (msf = -10^5) 7 (msfu = 7)                               |tgn = 1\\n                          /              \\\\                                     |\\n            (msf = 7) 8 (msfu = 8)     (msf = 7) 3 (msfu = 7)                  |tgn = 2\\n                 /                         /               \\\\                   |\\n(msf = 8) 2 (msfu = 8)     (msf = 7) 11 (msfu = 11)     (msf = 7) 5 (msfu = 7) |tgn = 3\\n```\\n\\n**Complexity**\\n* **Time Complexity**  :-   `O(n)`, where n is the no. of nodes\\n* **Space Complexity** :- `O(log(n))`, Since maximum recursion depth can reach only height of binary tree\\n\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def dfs(node, max_so_far):\\n\\t\\t\\t#if there is no node then there is no good nodes so return 0\\n            if not node:\\n                return 0\\n\\t\\t\\t\\n\\t\\t\\t#if current node is good then 1 otherwise 0\\n            good = 1 if node.val>=max_so_far else 0\\n\\t\\t\\t\\n\\t\\t\\t#Checking if current node is greater than max_so_far , if yes then update max_so_far to current node\\'s value\\n            max_so_far = max(max_so_far, node.val)\\n            \\n\\t\\t\\t#returning total of current good , no. of good nodes in left and right\\n            return good + dfs(node.left, max_so_far) + dfs(node.right, max_so_far)\\n        \\n        return dfs(root, -int(1e5))#Since constraints are [-10^4, 10^4] so we take -10^5 as maximum\\n```\\n\\n*Please upvote if you like the solution and comment if have any queries*",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n    7\\n   / \\\\\\n  8   3\\n /   / \\\\\\n2   11  5\\n```\n```\\n                      (msf = -10^5) 7 (msfu = 7)                               |tgn = 1\\n                          /              \\\\                                     |\\n            (msf = 7) 8 (msfu = 8)     (msf = 7) 3 (msfu = 7)                  |tgn = 2\\n                 /                         /               \\\\                   |\\n(msf = 8) 2 (msfu = 8)     (msf = 7) 11 (msfu = 11)     (msf = 7) 5 (msfu = 7) |tgn = 3\\n```\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def dfs(node, max_so_far):\\n\\t\\t\\t#if there is no node then there is no good nodes so return 0\\n            if not node:\\n                return 0\\n\\t\\t\\t\\n\\t\\t\\t#if current node is good then 1 otherwise 0\\n            good = 1 if node.val>=max_so_far else 0\\n\\t\\t\\t\\n\\t\\t\\t#Checking if current node is greater than max_so_far , if yes then update max_so_far to current node\\'s value\\n            max_so_far = max(max_so_far, node.val)\\n            \\n\\t\\t\\t#returning total of current good , no. of good nodes in left and right\\n            return good + dfs(node.left, max_so_far) + dfs(node.right, max_so_far)\\n        \\n        return dfs(root, -int(1e5))#Since constraints are [-10^4, 10^4] so we take -10^5 as maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635254,
                "title": "python-easy-recursive-dfs-solution-o-n-time-and-space-solution",
                "content": "Just keep track of current biggest value seen so far (from root to current node).\\n - If the node\\'s value is not smaller than the biggest one seen: add 1 to the result.\\n\\n\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        self.res = 0\\n\\n        def sol_rec(cur, val):\\n            if cur.val >= val: self.res += 1\\n            if cur.left: sol_rec(cur.left, max(val, cur.val))\\n            if cur.right: sol_rec(cur.right, max(val, cur.val))\\n\\n        sol_rec(root, root.val)\\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        self.res = 0\\n\\n        def sol_rec(cur, val):\\n            if cur.val >= val: self.res += 1\\n            if cur.left: sol_rec(cur.left, max(val, cur.val))\\n            if cur.right: sol_rec(cur.right, max(val, cur.val))\\n\\n        sol_rec(root, root.val)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326049,
                "title": "python-dfs-iterative-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n# Intuition\\nThe problem asks us to return the number of good nodes in a binary tree. A node is considered good if there are no nodes with a value greater than it in the path from root to that node. This means that we need to keep track of the maximum value we have seen so far while traversing from root to each node and compare it with the current node\\'s value.\\n\\n# Approach\\n1. We start by initializing a stack with a tuple containing the root node and negative infinity (i.e., `(root,float(\\'-inf\\'))`).\\n2. We also initialize a variable `count` to keep track of the number of good nodes we have seen so far.\\n3. We use a while loop to iterate over our stack until it is empty.\\n4. For each iteration, we pop a tuple from our stack containing a node and the maximum value we have seen so far in its path from root (i.e., `node, maxNum = stack.pop()`).\\n5. We then check if this node\\'s value is greater than or equal to `maxNum`. If it is, we increment our `count` variable by 1 since this node is considered good.\\n6. We update our `maxNum` variable by taking the maximum between `maxNum` and this node\\'s value (i.e., `maxNum = max(maxNum,node.val)`).\\n7. If this node has left or right children, we add them to our stack along with our updated `maxNum` value (i.e., `stack.append((node.left,maxNum))` and `stack.append((node.right,maxNum))`).\\n8. Finally, after all nodes have been processed, we return our count variable which contains the number of good nodes in our binary tree.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the number of nodes in the tree since we visit each node once.\\n- Space complexity: $$O(n)$$ where n is also the number of nodes in tree since in worst case scenario when tree is skewed all n nodes will be stored on stack.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        stack = [(root,float(\\'-inf\\'))]\\n        count = 0\\n        while stack:\\n            node, maxNum = stack.pop()\\n            if node.val>=maxNum:\\n                count+=1\\n            maxNum = max(maxNum,node.val)\\n            if node.left:\\n                stack.append((node.left,maxNum))\\n            if node.right:\\n                stack.append((node.right,maxNum))\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        stack = [(root,float(\\'-inf\\'))]\\n        count = 0\\n        while stack:\\n            node, maxNum = stack.pop()\\n            if node.val>=maxNum:\\n                count+=1\\n            maxNum = max(maxNum,node.val)\\n            if node.left:\\n                stack.append((node.left,maxNum))\\n            if node.right:\\n                stack.append((node.right,maxNum))\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408574,
                "title": "python-simple-dfs-explained",
                "content": "In this problem we need to traverse tree and find all nodes which have all ancestors less or equal than given node. Let us traverse our tree and change its nodes, such that in each `node` we will keep the biggest value on path `node -> .. -> root`.\\n\\n1. We update `self.count` if `child.val >= root.val`, that is node `child` is good.\\n2. We update value for `child`, in this case when we run recursion for this node, we know the biggest value on the path between this node and root.\\n3. Finally, we run recursion for every children.\\n\\n#### Complexity\\nIt is just `O(n)` for time and `O(h)` for additional space, because we use recursion.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def __init__(self):\\n        self.count = 0\\n\\n    def goodNodes(self, root):\\n        for child in filter(None, [root.left, root.right]):\\n            self.count += child.val >= root.val\\n            child.val = max(child.val, root.val)\\n            self.goodNodes(child)\\n  \\n        return self.count + 1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def __init__(self):\\n        self.count = 0\\n\\n    def goodNodes(self, root):\\n        for child in filter(None, [root.left, root.right]):\\n            self.count += child.val >= root.val\\n            child.val = max(child.val, root.val)\\n            self.goodNodes(child)\\n  \\n        return self.count + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149232,
                "title": "swift-count-good-nodes-in-binary-tree-xctestcases",
                "content": "#### Solution:\\n\\n```swift\\nclass Solution {\\n    private func dfs(_ root: TreeNode?, max num: Int) -> Int {\\n        guard let root = root else { return 0 }\\n        \\n        var count = 0\\n        root.val >= num ? count += 1 : nil\\n        \\n        let m = max(num, root.val)\\n        count += dfs(root.left, max: m)\\n        count += dfs(root.right, max: m)\\n        \\n        return count\\n    }\\n\\n    func goodNodes(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        return dfs(root, max: root.val)\\n    }\\n}\\n```\\n\\n#### Tests:\\n\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.082 (0.083) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    \\n    func testExample1() {\\n        let tree = TreeNode([3,1,4,3,nil,1,5])\\n        XCTAssert(s.goodNodes(tree) == 4) // success\\n    }\\n    \\n    func testExample2() {\\n        let tree = TreeNode([3,3,nil,4,2])\\n        XCTAssert(s.goodNodes(tree) == 3) // success\\n    }\\n    \\n    func testExample3() {\\n        let tree = TreeNode([1])\\n        XCTAssert(s.goodNodes(tree) == 1) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n#### TreeNode:\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    \\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    private func dfs(_ root: TreeNode?, max num: Int) -> Int {\\n        guard let root = root else { return 0 }\\n        \\n        var count = 0\\n        root.val >= num ? count += 1 : nil\\n        \\n        let m = max(num, root.val)\\n        count += dfs(root.left, max: m)\\n        count += dfs(root.right, max: m)\\n        \\n        return count\\n    }\\n\\n    func goodNodes(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        return dfs(root, max: root.val)\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.082 (0.083) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    \\n    func testExample1() {\\n        let tree = TreeNode([3,1,4,3,nil,1,5])\\n        XCTAssert(s.goodNodes(tree) == 4) // success\\n    }\\n    \\n    func testExample2() {\\n        let tree = TreeNode([3,3,nil,4,2])\\n        XCTAssert(s.goodNodes(tree) == 3) // success\\n    }\\n    \\n    func testExample3() {\\n        let tree = TreeNode([1])\\n        XCTAssert(s.goodNodes(tree) == 1) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    \\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511542,
                "title": "1-line-c-solution-with-code",
                "content": "Set max value as smaller then the smallest possible value\\nthen if root is null then answer will be 0\\nif root is not null then answer will be summation of answer of left subtree, right subtree and if root value is greater then or equal to the current max(maxi) variable.\\n\\n```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root,int maxi=-100000) {\\n        if(root==nullptr)\\n            return 0;\\n        return goodNodes(root->left,max(maxi,root->val))+goodNodes(root->right,max(maxi,root->val))+(root->val>=maxi);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root,int maxi=-100000) {\\n        if(root==nullptr)\\n            return 0;\\n        return goodNodes(root->left,max(maxi,root->val))+goodNodes(root->right,max(maxi,root->val))+(root->val>=maxi);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408534,
                "title": "count-good-nodes-in-binary-tree-dfs-w-explanation-c-python-java",
                "content": "*Hint-*\\nUse DFS (Depth First Search) to traverse the tree, and constantly keep track of the current path maximum.\\n\\n**Idea-**\\n`dfs` from the root down to its descendant nodes and keep `mx` (the maximum value).\\nIf the value of `current node >= mx` then we increase count by one since it\\'s a good node.\\n\\n**Solution**\\n`In C++`\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode * root, int maxi){\\n        if(root){\\n            if(root->val>=maxi) ans++;\\n            dfs(root->left, max(maxi, root->val));\\n            dfs(root->right, max(maxi, root->val));\\n        }\\n    }\\n    int goodNodes(TreeNode* root) {\\n        dfs(root,INT_MIN);\\n        return ans;\\n    }\\n};\\n```\\n`In Python3`\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def dfs(root, mx):\\n            nonlocal ans\\n            if root == None: return\\n            if mx <= root.val:\\n                ans += 1\\n            mx = max(mx, root.val)\\n            dfs(root.left, mx)\\n            dfs(root.right, mx)\\n\\n        ans = 0\\n        dfs(root, root.val)\\n        return ans\\n```\\n`In JAVA`\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution \\n{\\n    int count = 0;\\n    public int goodNodes(TreeNode root) \\n    {\\n        dfs(root , Integer.MIN_VALUE);\\n        return count;\\n    }\\n    void dfs(TreeNode root , int max)\\n    {\\n        if(root==null)\\n            return;\\n        \\n        if(root.val>=max)\\n            count++;\\n        \\n        dfs(root.left , Math.max(max , root.val));\\n        dfs(root.right , Math.max(max , root.val));\\n    }\\n}\\n```\\n**Time Complexity**: `O(N)`, where N is the number of nodes in the binary tree.\\n**Space Complexity**: `O(H)`, where H is the height of binary tree.\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode * root, int maxi){\\n        if(root){\\n            if(root->val>=maxi) ans++;\\n            dfs(root->left, max(maxi, root->val));\\n            dfs(root->right, max(maxi, root->val));\\n        }\\n    }\\n    int goodNodes(TreeNode* root) {\\n        dfs(root,INT_MIN);\\n        return ans;\\n    }\\n};\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def dfs(root, mx):\\n            nonlocal ans\\n            if root == None: return\\n            if mx <= root.val:\\n                ans += 1\\n            mx = max(mx, root.val)\\n            dfs(root.left, mx)\\n            dfs(root.right, mx)\\n\\n        ans = 0\\n        dfs(root, root.val)\\n        return ans\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution \\n{\\n    int count = 0;\\n    public int goodNodes(TreeNode root) \\n    {\\n        dfs(root , Integer.MIN_VALUE);\\n        return count;\\n    }\\n    void dfs(TreeNode root , int max)\\n    {\\n        if(root==null)\\n            return;\\n        \\n        if(root.val>=max)\\n            count++;\\n        \\n        dfs(root.left , Math.max(max , root.val));\\n        dfs(root.right , Math.max(max , root.val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050335,
                "title": "iterative-using-bfs-and-using-dfs-and-recursive-solution",
                "content": "Recursive: Time Complexity - O(n) and space complexity O(n)\\n\\n```\\nclass Solution {\\n    int count = 0;\\n    void findGoodNode(TreeNode root, int max) {\\n        if(root == null) return;\\n        if(root.val >= max) count++;\\n        if(root.left != null)\\n        findGoodNode(root.left,Math.max(root.left.val,max));\\n        if(root.right != null)\\n        findGoodNode(root.right,Math.max(root.right.val,max));\\n    }\\n    public int goodNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        findGoodNode(root,root.val);\\n        return count;\\n    }\\n}\\n```\\n\\n\\nIterative solution using bfs:\\n\\n```\\nclass Solution {\\n    class Pair{\\n        TreeNode root;\\n        int val;\\n        Pair(TreeNode root, int val) {\\n            this.root = root;\\n            this.val = val;\\n        }\\n    }\\n    public int goodNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        int count = 0 ;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(root,root.val));\\n        while(!q.isEmpty()) {\\n            Pair p = q.poll();\\n            TreeNode t = p.root;\\n            if(t.val >= p.val) {\\n                count++;\\n            }\\n            if(t.left != null) {\\n                q.offer(new Pair(t.left, Math.max(t.left.val,p.val)));\\n            }\\n            if(t.right != null) {\\n                q.offer(new Pair(t.right, Math.max(t.right.val,p.val)));\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nIterative solution using dfs:\\n```\\nclass Solution {\\n    class Pair{\\n        TreeNode root;\\n        int val;\\n        Pair(TreeNode root, int val) {\\n            this.root = root;\\n            this.val = val;\\n        }\\n    }\\n    public int goodNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        int count=0;\\n        Stack<Pair> s = new Stack<>();\\n        s.push(new Pair(root,root.val));\\n        while(!s.isEmpty()) {\\n            Pair p = s.peek();\\n            TreeNode t  =p.root;\\n            if(t.left == null && t.right == null) {\\n                s.pop();\\n                if(t.val >= p.val) count++;\\n            } else if(t.left != null) {\\n                s.push(new Pair(t.left, Math.max(t.left.val, p.val)));\\n                t.left = null;\\n            } else if(t.right != null) {\\n                s.push(new Pair(t.right, Math.max(t.right.val, p.val)));\\n                t.right = null;\\n            }\\n        }\\n        \\n     return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    void findGoodNode(TreeNode root, int max) {\\n        if(root == null) return;\\n        if(root.val >= max) count++;\\n        if(root.left != null)\\n        findGoodNode(root.left,Math.max(root.left.val,max));\\n        if(root.right != null)\\n        findGoodNode(root.right,Math.max(root.right.val,max));\\n    }\\n    public int goodNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        findGoodNode(root,root.val);\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    class Pair{\\n        TreeNode root;\\n        int val;\\n        Pair(TreeNode root, int val) {\\n            this.root = root;\\n            this.val = val;\\n        }\\n    }\\n    public int goodNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        int count = 0 ;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(root,root.val));\\n        while(!q.isEmpty()) {\\n            Pair p = q.poll();\\n            TreeNode t = p.root;\\n            if(t.val >= p.val) {\\n                count++;\\n            }\\n            if(t.left != null) {\\n                q.offer(new Pair(t.left, Math.max(t.left.val,p.val)));\\n            }\\n            if(t.right != null) {\\n                q.offer(new Pair(t.right, Math.max(t.right.val,p.val)));\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    class Pair{\\n        TreeNode root;\\n        int val;\\n        Pair(TreeNode root, int val) {\\n            this.root = root;\\n            this.val = val;\\n        }\\n    }\\n    public int goodNodes(TreeNode root) {\\n        if(root == null) return 0;\\n        int count=0;\\n        Stack<Pair> s = new Stack<>();\\n        s.push(new Pair(root,root.val));\\n        while(!s.isEmpty()) {\\n            Pair p = s.peek();\\n            TreeNode t  =p.root;\\n            if(t.left == null && t.right == null) {\\n                s.pop();\\n                if(t.val >= p.val) count++;\\n            } else if(t.left != null) {\\n                s.push(new Pair(t.left, Math.max(t.left.val, p.val)));\\n                t.left = null;\\n            } else if(t.right != null) {\\n                s.push(new Pair(t.right, Math.max(t.right.val, p.val)));\\n                t.right = null;\\n            }\\n        }\\n        \\n     return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513498,
                "title": "java-easy-solution-commented",
                "content": "```\\n// TC - O(n)\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        \\n        if(root == null) return 0;\\n        return count(root, root.val);\\n    }\\n    \\n    private int count(TreeNode node, int max){\\n        \\n        if(node == null) return 0; \\n        \\n        max = Math.max(node.val, max); // max node value in current path\\n        int left = count(node.left, max); // count all good nodes in left\\n        int right = count(node.right, max); // count all good nodes in right\\n        \\n        int res = left + right;\\n        if(node.val >= max) res++; // if current node is good, add that in res\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// TC - O(n)\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        \\n        if(root == null) return 0;\\n        return count(root, root.val);\\n    }\\n    \\n    private int count(TreeNode node, int max){\\n        \\n        if(node == null) return 0; \\n        \\n        max = Math.max(node.val, max); // max node value in current path\\n        int left = count(node.left, max); // count all good nodes in left\\n        int right = count(node.right, max); // count all good nodes in right\\n        \\n        int res = left + right;\\n        if(node.val >= max) res++; // if current node is good, add that in res\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512851,
                "title": "c-3-different-solutions-easy-to-understand",
                "content": "**Solution 1: recursive DFS**\\n\\nThis is just a recursive preorder traversal.\\n\\n```\\n    int goodNodes(TreeNode* root) {\\n        return goodNodes(root, numeric_limits<int>::min());\\n    }\\n    \\n    int goodNodes(TreeNode* node, int mx) {\\n        if (!node) return 0;\\n        \\n        int ans = node->val >= mx;\\n        mx = max(mx, node->val);\\n        \\n        ans += goodNodes(node->left, mx);\\n        ans += goodNodes(node->right, mx);\\n        \\n        return ans;\\n    }\\n```\\n\\nIf we are willing to use default arguments, we can even do this with a single function:\\n\\n```\\n    int goodNodes(TreeNode* node, int mx = numeric_limits<int>::min()) {\\n        if (!node) return 0;\\n        \\n        int ans = node->val >= mx;\\n        mx = max(mx, node->val);\\n        \\n        ans += goodNodes(node->left, mx);\\n        ans += goodNodes(node->right, mx);\\n        \\n        return ans;\\n    }\\n```\\n\\nIf we push a bit harder on this idea, we can even turn this into a \"one liner\". It\\'s a bit long for one line so I have wrapped it:\\n\\n```\\n    int goodNodes(TreeNode* node, int mx = numeric_limits<int>::min()) {\\n        return !node ? 0 : (node->val >= mx) +\\n            goodNodes(node->left, max(node->val, mx)) +\\n            goodNodes(node->right, max(node->val, mx));\\n    }\\n```\\n\\n**Solution 2: iterative DFS**\\nPreorder traversal can be easily done with a ```stack<>``` as well:\\n\\n```\\n    int goodNodes(TreeNode* root) {\\n        if (!root) return 0;\\n\\n        stack<pair<TreeNode*, int>> st;\\n        st.push({root, numeric_limits<int>::min()});\\n        int ans = 0;\\n        while (!empty(st)) {\\n            auto [node, mx] = st.top(); st.pop();\\n            \\n            ans += node->val >= mx;\\n            mx = max(mx, node->val);\\n            if (node->left) st.push({node->left, mx});\\n            if (node->right) st.push({node->right, mx});\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n**Solution 3: iterative BFS**\\n\\nSolution 2 can easily be turned into a BFS, by replacing the ```stack<>``` with a ```queue<>```.\\n\\n```\\n    int goodNodes(TreeNode* root) {\\n        if (!root) return 0;\\n\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, numeric_limits<int>::min()});\\n        int ans = 0;\\n        while (!empty(q)) {\\n            auto [node, mx] = q.front(); q.pop();\\n            \\n            ans += node->val >= mx;\\n            mx = max(mx, node->val);\\n            if (node->left) q.push({node->left, mx});\\n            if (node->right) q.push({node->right, mx});\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nAs always feedback is welcome, and please upvote if you like this post.\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    int goodNodes(TreeNode* root) {\\n        return goodNodes(root, numeric_limits<int>::min());\\n    }\\n    \\n    int goodNodes(TreeNode* node, int mx) {\\n        if (!node) return 0;\\n        \\n        int ans = node->val >= mx;\\n        mx = max(mx, node->val);\\n        \\n        ans += goodNodes(node->left, mx);\\n        ans += goodNodes(node->right, mx);\\n        \\n        return ans;\\n    }\\n```\n```\\n    int goodNodes(TreeNode* node, int mx = numeric_limits<int>::min()) {\\n        if (!node) return 0;\\n        \\n        int ans = node->val >= mx;\\n        mx = max(mx, node->val);\\n        \\n        ans += goodNodes(node->left, mx);\\n        ans += goodNodes(node->right, mx);\\n        \\n        return ans;\\n    }\\n```\n```\\n    int goodNodes(TreeNode* node, int mx = numeric_limits<int>::min()) {\\n        return !node ? 0 : (node->val >= mx) +\\n            goodNodes(node->left, max(node->val, mx)) +\\n            goodNodes(node->right, max(node->val, mx));\\n    }\\n```\n```stack<>```\n```\\n    int goodNodes(TreeNode* root) {\\n        if (!root) return 0;\\n\\n        stack<pair<TreeNode*, int>> st;\\n        st.push({root, numeric_limits<int>::min()});\\n        int ans = 0;\\n        while (!empty(st)) {\\n            auto [node, mx] = st.top(); st.pop();\\n            \\n            ans += node->val >= mx;\\n            mx = max(mx, node->val);\\n            if (node->left) st.push({node->left, mx});\\n            if (node->right) st.push({node->right, mx});\\n        }\\n        \\n        return ans;\\n    }\\n```\n```stack<>```\n```queue<>```\n```\\n    int goodNodes(TreeNode* root) {\\n        if (!root) return 0;\\n\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, numeric_limits<int>::min()});\\n        int ans = 0;\\n        while (!empty(q)) {\\n            auto [node, mx] = q.front(); q.pop();\\n            \\n            ans += node->val >= mx;\\n            mx = max(mx, node->val);\\n            if (node->left) q.push({node->left, mx});\\n            if (node->right) q.push({node->right, mx});\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511560,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using DFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(height of tree i.e. O(logN))***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int count = 0;\\n    \\n    void dfs(TreeNode* root, int maxi)\\n    {\\n        // base case\\n        \\n        if(root == NULL)\\n            return;\\n        \\n        // if max. value of ancestors is less than or equal to curr node then increment count\\n        \\n        if(root -> val >= maxi)\\n        {\\n            count++;\\n        }\\n        \\n        // update maxi\\n        \\n        maxi = max(maxi, root -> val);\\n        \\n        // call for left subtree\\n        \\n        dfs(root -> left, maxi);\\n        \\n        // call for right subtree\\n        \\n        dfs(root -> right, maxi);\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return 0;\\n        \\n        dfs(root, root -> val);\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count = 0;\\n    \\n    void dfs(TreeNode* root, int maxi)\\n    {\\n        // base case\\n        \\n        if(root == NULL)\\n            return;\\n        \\n        // if max. value of ancestors is less than or equal to curr node then increment count\\n        \\n        if(root -> val >= maxi)\\n        {\\n            count++;\\n        }\\n        \\n        // update maxi\\n        \\n        maxi = max(maxi, root -> val);\\n        \\n        // call for left subtree\\n        \\n        dfs(root -> left, maxi);\\n        \\n        // call for right subtree\\n        \\n        dfs(root -> right, maxi);\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return 0;\\n        \\n        dfs(root, root -> val);\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511367,
                "title": "daily-leetcoding-challenge-september-day-1",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/count-good-nodes-in-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search, Recursion\n\n  \n**Approach 2:** Depth First Search, Iterative\n\n  \n**Approach 3:** Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/count-good-nodes-in-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1138384,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return goodNodes(root, root.val);\\n    }\\n    \\n    public int goodNodes(TreeNode root, int maxParent) {\\n        if (root == null) return 0;    \\n\\t\\t\\n        maxParent = Math.max(root.val, maxParent);\\n\\t\\t\\n        return (maxParent > root.val ? 0 : 1) + goodNodes(root.left, maxParent) + goodNodes(root.right, maxParent);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return goodNodes(root, root.val);\\n    }\\n    \\n    public int goodNodes(TreeNode root, int maxParent) {\\n        if (root == null) return 0;    \\n\\t\\t\\n        maxParent = Math.max(root.val, maxParent);\\n\\t\\t\\n        return (maxParent > root.val ? 0 : 1) + goodNodes(root.left, maxParent) + goodNodes(root.right, maxParent);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635288,
                "title": "simple-tree-traversal-java-explained",
                "content": "1) Traverse the tree in preorder fashion.\\n2) For every node X, `max` is the maximum values so far from root to that node.\\n3) For the left and right childrens of X , `max` would be `max` of X and current value of node X itself.\\n4) At end of traversal of both left and right subtrees, add 1 to the total if current node is good Node. `((root.val >= max)?1:0) ` is used for that. \\n```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return goodNodesUtil(root,root.val);\\n    }\\n    \\n    int goodNodesUtil(TreeNode root,int max){\\n        if(root == null)\\n            return 0;\\n\\n        return goodNodesUtil(root.left,Math.max(max,root.val)) + \\n            goodNodesUtil(root.right,Math.max(max,root.val)) + ((root.val >= max)?1:0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return goodNodesUtil(root,root.val);\\n    }\\n    \\n    int goodNodesUtil(TreeNode root,int max){\\n        if(root == null)\\n            return 0;\\n\\n        return goodNodesUtil(root.left,Math.max(max,root.val)) + \\n            goodNodesUtil(root.right,Math.max(max,root.val)) + ((root.val >= max)?1:0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515365,
                "title": "c-dfs-explained-intuitive-approach-beginner-friendly-easy-to-understand",
                "content": "**IDEA**: DFS through every path, and keep tracking of maximum value(hi) in the path.\\nIf current node value is >= the biggest value in the path, we add the answer by one, otherwise add nothing and move in the path.\\n\\n**Time Complexity: O(N)\\nSpace Complexity: O(N) for recursion stack space.**\\n\\n```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* curr, int hi = -10005) {\\n        if(!curr) return 0;\\n\\t\\t\\n        if(curr->val >= hi) \\n\\t\\t\\treturn 1 + goodNodes(curr->left, max(curr->val, hi)) + goodNodes(curr->right, max(curr->val, hi)); \\n        else \\n\\t\\t\\treturn goodNodes(curr->left, max(curr->val, hi)) + goodNodes(curr->right, max(curr->val, hi)); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* curr, int hi = -10005) {\\n        if(!curr) return 0;\\n\\t\\t\\n        if(curr->val >= hi) \\n\\t\\t\\treturn 1 + goodNodes(curr->left, max(curr->val, hi)) + goodNodes(curr->right, max(curr->val, hi)); \\n        else \\n\\t\\t\\treturn goodNodes(curr->left, max(curr->val, hi)) + goodNodes(curr->right, max(curr->val, hi)); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512118,
                "title": "3-lines-of-code-easy-c",
                "content": "```\\n  int goodNodes(TreeNode* root,int high=INT_MIN) {\\n      \\n        if(!root)return 0;\\n        int data = root->val;\\n        return (data>=high)+goodNodes(root->left,max(high,data))+goodNodes(root->right,max(high,data));    \\n }\\n```\\nKeep a variable (high) for keeping track of the highest value we have seen as we traverse the tree .",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int goodNodes(TreeNode* root,int high=INT_MIN) {\\n      \\n        if(!root)return 0;\\n        int data = root->val;\\n        return (data>=high)+goodNodes(root->left,max(high,data))+goodNodes(root->right,max(high,data));    \\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511509,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n      \\n      def checkNode(node,val):\\n        if(node == None):\\n          return 0\\n        \\n        op = 0\\n        if(node.val >= val):\\n          op = 1\\n        \\n        val = max(val,node.val)\\n        return op + checkNode(node.left,val) + checkNode(node.right,val)\\n          \\n        \\n      return checkNode(root,root.val)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n      \\n      def checkNode(node,val):\\n        if(node == None):\\n          return 0\\n        \\n        op = 0\\n        if(node.val >= val):\\n          op = 1\\n        \\n        val = max(val,node.val)\\n        return op + checkNode(node.left,val) + checkNode(node.right,val)\\n          \\n        \\n      return checkNode(root,root.val)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401644,
                "title": "c-recursive-solution-easy-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void goody(TreeNode* root, int mx, int &c)\\n    {\\n        if(!root)return;\\n        if(mx <= root->val)                    //we simply keep the track of the maximum element along the path\\n        {\\n            mx=root->val;\\n            ++c;                                    //increment the result if number is greater or equal to max element\\n        }\\n        \\n        goody(root->left,mx,c);\\n        goody(root->right,mx,c);\\n        \\n    }\\n    int goodNodes(TreeNode* root) {\\n        \\n        int c=0,mx=INT_MIN;\\n        goody(root,mx,c);\\n        return c;\\n    }\\n};\\n```\\n\\n***Please upvote if you find this helpful to keep me motivated. :)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void goody(TreeNode* root, int mx, int &c)\\n    {\\n        if(!root)return;\\n        if(mx <= root->val)                    //we simply keep the track of the maximum element along the path\\n        {\\n            mx=root->val;\\n            ++c;                                    //increment the result if number is greater or equal to max element\\n        }\\n        \\n        goody(root->left,mx,c);\\n        goody(root->right,mx,c);\\n        \\n    }\\n    int goodNodes(TreeNode* root) {\\n        \\n        int c=0,mx=INT_MIN;\\n        goody(root,mx,c);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703869,
                "title": "javascript-best-solution-beats-99-04-till-date",
                "content": "```\\nvar goodNodes = function(root) {\\n    let good = 0;\\n    function trav(node, max){\\n        if(!node) return;\\n        if(node.val >= max) ++good;\\n        max = Math.max(max, node.val);\\n        trav(node.left, max);\\n        trav(node.right, max); \\n    }\\n    trav(root, root.val);\\n    return good;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar goodNodes = function(root) {\\n    let good = 0;\\n    function trav(node, max){\\n        if(!node) return;\\n        if(node.val >= max) ++good;\\n        max = Math.max(max, node.val);\\n        trav(node.left, max);\\n        trav(node.right, max); \\n    }\\n    trav(root, root.val);\\n    return good;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 635447,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q;\\n        int m = INT_MIN;\\n        q.push({root, m});\\n        int count = 0;\\n        while (!q.empty()) {\\n            auto temp = q.front();\\n            q.pop();\\n            TreeNode* node = temp.first;\\n            int num = temp.second;\\n            if (node->val >= num) {\\n                count++;\\n            }\\n            m = max (node->val, num);\\n            if (node->left) {\\n                q.push({node->left, m});\\n            }\\n            if (node->right) {\\n                q.push({node->right, m});\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q;\\n        int m = INT_MIN;\\n        q.push({root, m});\\n        int count = 0;\\n        while (!q.empty()) {\\n            auto temp = q.front();\\n            q.pop();\\n            TreeNode* node = temp.first;\\n            int num = temp.second;\\n            if (node->val >= num) {\\n                count++;\\n            }\\n            m = max (node->val, num);\\n            if (node->left) {\\n                q.push({node->left, m});\\n            }\\n            if (node->right) {\\n                q.push({node->right, m});\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041228,
                "title": "easy-to-understand-iterative-depth-first-traversal-c",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n /**\\n auto replace\\n pair<TreeNode*, int> nodePair = s.top();\\nTreeNode* node = nodePair.first;\\nint maxVal = nodePair.second;\\n\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        stack<pair<TreeNode*,int>>s;\\n        s.push({root,root->val});\\n        int goodnodes=0;\\n        while(!s.empty())\\n        {\\n            auto[node,maxval]=s.top();\\n            s.pop();\\n            if(node->val>=maxval)\\n            {\\n                goodnodes++;\\n            }\\n            if(node->left)\\n            {\\n                s.push({node->left,max(node->val,maxval)});\\n            }\\n            if(node->right)\\n            {\\n                s.push({node->right,max(node->val,maxval)});\\n            }\\n\\n\\n        }\\n        return goodnodes;\\n        \\n    }\\n};\\n```\\n![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/a863bc72-d660-4004-a3cb-6ab9acf19955_1694629640.884827.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n /**\\n auto replace\\n pair<TreeNode*, int> nodePair = s.top();\\nTreeNode* node = nodePair.first;\\nint maxVal = nodePair.second;\\n\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        stack<pair<TreeNode*,int>>s;\\n        s.push({root,root->val});\\n        int goodnodes=0;\\n        while(!s.empty())\\n        {\\n            auto[node,maxval]=s.top();\\n            s.pop();\\n            if(node->val>=maxval)\\n            {\\n                goodnodes++;\\n            }\\n            if(node->left)\\n            {\\n                s.push({node->left,max(node->val,maxval)});\\n            }\\n            if(node->right)\\n            {\\n                s.push({node->right,max(node->val,maxval)});\\n            }\\n\\n\\n        }\\n        return goodnodes;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511962,
                "title": "c-faster-than-96-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\t\\n1. Perform pre-order traversal and keep a count and maxi variable.\\n2. If root->val is greater than or equal to the maxi, update maxi and increment count.\\n3. Check for root\\'s left and right subtree.\\n4. Return count :)\\n\\n---------------------------------------------------------------------------------------------------------------------\\n\\n\\t\\n\\tvoid solve(TreeNode* root, int maxi, int &count){\\n\\n\\t\\tif(!root) return;\\n\\t\\tif(root->val >= maxi){     //pre-order traversal\\n\\t\\t\\tcount++;               //if root->val is greater than or equal to maxi\\n\\t\\t\\tmaxi=root->val;        //update root->val and increment count\\n\\t\\t}\\n\\n\\t\\tsolve(root->left,maxi,count);\\n\\t\\tsolve(root->right,maxi,count);\\n\\t}\\n\\n\\tint goodNodes(TreeNode* root) {\\n\\t\\tif(!root) return 0;\\n\\t\\tint count=0;\\n\\t\\tsolve(root,INT_MIN,count);\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\t\\n1. Perform pre-order traversal and keep a count and maxi variable.\\n2. If root->val is greater than or equal to the maxi, update maxi and increment count.\\n3. Check for root\\'s left and right subtree.\\n4. Return count :)\\n\\n---------------------------------------------------------------------------------------------------------------------\\n\\n\\t\\n\\tvoid solve(TreeNode* root, int maxi, int &count){\\n\\n\\t\\tif(!root) return;\\n\\t\\tif(root->val >= maxi){     //pre-order traversal\\n\\t\\t\\tcount++;               //if root->val is greater than or equal to maxi\\n\\t\\t\\tmaxi=root->val;        //update root->val and increment count\\n\\t\\t}\\n\\n\\t\\tsolve(root->left,maxi,count);\\n\\t\\tsolve(root->right,maxi,count);\\n\\t}\\n\\n\\tint goodNodes(TreeNode* root) {\\n\\t\\tif(!root) return 0;\\n\\t\\tint count=0;\\n\\t\\tsolve(root,INT_MIN,count);\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1408814,
                "title": "python3-bfs-and-dfs-solution",
                "content": "```\\n# dfs\\ndef goodNodes(self, root: TreeNode) -> int:\\n\\tdef helper(node,curr_max):\\n\\t\\tif node is None:\\n\\t\\t\\treturn 0\\n\\t\\telif node.val>=curr_max:  #add 1 if current node value is greater or equal to the max generated from this path also update the max till now\\n\\t\\t\\tcurr_max=node.val\\n\\t\\t\\treturn 1+helper(node.left,curr_max)+helper(node.right,curr_max)\\n\\t\\telse:\\n\\t\\t\\treturn helper(node.left,curr_max)+helper(node.right,curr_max)\\n\\treturn helper(root,float(\\'-inf\\'))\\n\\n#bfs\\ndef goodNodes(self, root: TreeNode) -> int:\\n\\tans = 0\\n\\tq =[]\\n\\tq.append((root,float(\\'-inf\\')))\\t\\n\\twhile q:\\n\\t\\tnode,curr_max = q.pop(0)\\n\\t\\tif node.val >= curr_max:  \\n\\t\\t\\tans += 1\\n\\t\\tif node.left:\\n\\t\\t\\tq.append((node.left,max(curr_max,node.val)))\\n\\t\\tif node.right:\\n\\t\\t\\tq.append((node.right,max(curr_max,node.val)))\\n\\treturn ans",
                "solutionTags": [],
                "code": "```\\n# dfs\\ndef goodNodes(self, root: TreeNode) -> int:\\n\\tdef helper(node,curr_max):\\n\\t\\tif node is None:\\n\\t\\t\\treturn 0\\n\\t\\telif node.val>=curr_max:  #add 1 if current node value is greater or equal to the max generated from this path also update the max till now\\n\\t\\t\\tcurr_max=node.val\\n\\t\\t\\treturn 1+helper(node.left,curr_max)+helper(node.right,curr_max)\\n\\t\\telse:\\n\\t\\t\\treturn helper(node.left,curr_max)+helper(node.right,curr_max)\\n\\treturn helper(root,float(\\'-inf\\'))\\n\\n#bfs\\ndef goodNodes(self, root: TreeNode) -> int:\\n\\tans = 0\\n\\tq =[]\\n\\tq.append((root,float(\\'-inf\\')))\\t\\n\\twhile q:\\n\\t\\tnode,curr_max = q.pop(0)\\n\\t\\tif node.val >= curr_max:  \\n\\t\\t\\tans += 1\\n\\t\\tif node.left:\\n\\t\\t\\tq.append((node.left,max(curr_max,node.val)))\\n\\t\\tif node.right:\\n\\t\\t\\tq.append((node.right,max(curr_max,node.val)))\\n\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 1408533,
                "title": "c-c-simple-clean-and-short-recursive-solution",
                "content": "**C:**\\n\\n```\\nint rec(struct TreeNode* root, int max) {\\n    if (!root)\\n        return 0;\\n    max = root->val > max ? root->val : max;\\n    if (root->val >= max)\\n        return 1+rec(root->right, max) + rec(root->left, max);\\n    else\\n        return rec(root->right, max) + rec(root->left, max);\\n}\\n\\nint goodNodes(struct TreeNode* root){\\n    if (!root) return 0;\\n    return rec(root, root->val);\\n}\\n```\\n**C++:**\\n\\n```\\nclass Solution {\\npublic:\\n    int rec(struct TreeNode* root, int max_val) {\\n        if (!root)\\n            return 0;\\n        max_val = max(max_val, root->val);\\n        if (root->val >= max_val)\\n            return 1 + rec(root->right, max_val) + rec(root->left, max_val);\\n        else\\n            return rec(root->right, max_val) + rec(root->left, max_val);\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        if (!root) return 0;\\n        return rec(root, root->val);\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint rec(struct TreeNode* root, int max) {\\n    if (!root)\\n        return 0;\\n    max = root->val > max ? root->val : max;\\n    if (root->val >= max)\\n        return 1+rec(root->right, max) + rec(root->left, max);\\n    else\\n        return rec(root->right, max) + rec(root->left, max);\\n}\\n\\nint goodNodes(struct TreeNode* root){\\n    if (!root) return 0;\\n    return rec(root, root->val);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int rec(struct TreeNode* root, int max_val) {\\n        if (!root)\\n            return 0;\\n        max_val = max(max_val, root->val);\\n        if (root->val >= max_val)\\n            return 1 + rec(root->right, max_val) + rec(root->left, max_val);\\n        else\\n            return rec(root->right, max_val) + rec(root->left, max_val);\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        if (!root) return 0;\\n        return rec(root, root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339469,
                "title": "simple-soln-explained-in-1-line",
                "content": "Simple logic: If during recursion, my node.val is >= last biggest val occurred then add 1 to answer and make node.val as the new lastBiggestVal\\n```\\nclass Solution {\\n    \\n    int answer = 0;\\n    \\n    public int goodNodes(TreeNode root) {\\n        \\n        countGoodNodes(root, Integer.MIN_VALUE);\\n        \\n        return answer;\\n    }\\n    \\n    public void countGoodNodes(TreeNode root, int lastBiggest){\\n        \\n        if(root == null) return;\\n        \\n        if(root.val >= lastBiggest){\\n            \\n            answer++;\\n            lastBiggest = root.val;\\n            \\n        }\\n        \\n        countGoodNodes(root.left, lastBiggest);\\n        countGoodNodes(root.right, lastBiggest);\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int answer = 0;\\n    \\n    public int goodNodes(TreeNode root) {\\n        \\n        countGoodNodes(root, Integer.MIN_VALUE);\\n        \\n        return answer;\\n    }\\n    \\n    public void countGoodNodes(TreeNode root, int lastBiggest){\\n        \\n        if(root == null) return;\\n        \\n        if(root.val >= lastBiggest){\\n            \\n            answer++;\\n            lastBiggest = root.val;\\n            \\n        }\\n        \\n        countGoodNodes(root.left, lastBiggest);\\n        countGoodNodes(root.right, lastBiggest);\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663511,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        if (root == null) return 0;\\n        return dfs(root, root.val);\\n    }\\n    \\n    private int dfs(TreeNode node, int val) {\\n        if (node == null) return 0;\\n        if (node.val >= val) val = node.val;\\n        int l = dfs(node.left, val), r = dfs(node.right, val);\\n        return l + r + (node.val == val ? 1 : 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        if (root == null) return 0;\\n        return dfs(root, root.val);\\n    }\\n    \\n    private int dfs(TreeNode node, int val) {\\n        if (node == null) return 0;\\n        if (node.val >= val) val = node.val;\\n        int l = dfs(node.left, val), r = dfs(node.right, val);\\n        return l + r + (node.val == val ? 1 : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097030,
                "title": "java-c-100-solution-using-depth-first-search-count-good-nodes-in-binary-tree",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(TreeNode* root,int value)\\n    {\\n        if(root)\\n        {\\n            if(root->val >= value)\\n            {\\n                ans++;\\n                value = root->val;\\n            }\\n            solve(root->left,value);\\n            solve(root->right,value);\\n        }\\n    }\\n    int goodNodes(TreeNode* root) {\\n        solve(root,INT_MIN);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    int ans=0;\\n    public void solve(TreeNode root, int value)\\n    {\\n        if(root == null) return;\\n        if(root.val >= value)\\n        {\\n            ans++;\\n            value = root.val;\\n        }\\n        solve(root.left,value);\\n        solve(root.right,value);\\n    }\\n    public int goodNodes(TreeNode root) {\\n        solve(root,Integer.MIN_VALUE);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(TreeNode* root,int value)\\n    {\\n        if(root)\\n        {\\n            if(root->val >= value)\\n            {\\n                ans++;\\n                value = root->val;\\n            }\\n            solve(root->left,value);\\n            solve(root->right,value);\\n        }\\n    }\\n    int goodNodes(TreeNode* root) {\\n        solve(root,INT_MIN);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    int ans=0;\\n    public void solve(TreeNode root, int value)\\n    {\\n        if(root == null) return;\\n        if(root.val >= value)\\n        {\\n            ans++;\\n            value = root.val;\\n        }\\n        solve(root.left,value);\\n        solve(root.right,value);\\n    }\\n    public int goodNodes(TreeNode root) {\\n        solve(root,Integer.MIN_VALUE);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511728,
                "title": "java-simple-and-easy-solution-recursion-98-faster-code",
                "content": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return needHelp(root, root.val);\\n    }\\n    \\n    public int needHelp(TreeNode node, int currentMax){\\n        if (node == null){\\n            return 0;\\n        }\\n        int count = 0;\\n        if (node.val >= currentMax){\\n            count = 1;\\n            currentMax = node.val;\\n        }\\n        \\n        return count + needHelp(node.left, currentMax) + needHelp(node.right, currentMax);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return needHelp(root, root.val);\\n    }\\n    \\n    public int needHelp(TreeNode node, int currentMax){\\n        if (node == null){\\n            return 0;\\n        }\\n        int count = 0;\\n        if (node.val >= currentMax){\\n            count = 1;\\n            currentMax = node.val;\\n        }\\n        \\n        return count + needHelp(node.left, currentMax) + needHelp(node.right, currentMax);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408504,
                "title": "java-preorder-better-than-98",
                "content": "```\\nclass Solution \\n{\\n    int count = 0;\\n    public int goodNodes(TreeNode root) \\n    {\\n        util(root , Integer.MIN_VALUE);\\n        return count;\\n    }\\n    void util(TreeNode root , int max)\\n    {\\n        if(root==null)\\n            return;\\n        \\n        if(root.val>=max)\\n            count++;\\n        \\n        util(root.left , Math.max(max , root.val));\\n        util(root.right , Math.max(max , root.val));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    int count = 0;\\n    public int goodNodes(TreeNode root) \\n    {\\n        util(root , Integer.MIN_VALUE);\\n        return count;\\n    }\\n    void util(TreeNode root , int max)\\n    {\\n        if(root==null)\\n            return;\\n        \\n        if(root.val>=max)\\n            count++;\\n        \\n        util(root.left , Math.max(max , root.val));\\n        util(root.right , Math.max(max , root.val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925582,
                "title": "java-simple-dfs-solution-without-global-variable",
                "content": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return dfs(root, root.val);\\n    }\\n    \\n    private int dfs(TreeNode root, int max) {\\n        if(root == null) return 0;\\n        \\n        int total = 0;\\n        \\n        if(root.val >= max) {\\n            total += 1;\\n            max = root.val;\\n        }\\n        \\n        int left = dfs(root.left, max);\\n        int right = dfs(root.right, max);\\n        \\n        return total + left + right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return dfs(root, root.val);\\n    }\\n    \\n    private int dfs(TreeNode root, int max) {\\n        if(root == null) return 0;\\n        \\n        int total = 0;\\n        \\n        if(root.val >= max) {\\n            total += 1;\\n            max = root.val;\\n        }\\n        \\n        int left = dfs(root.left, max);\\n        int right = dfs(root.right, max);\\n        \\n        return total + left + right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635214,
                "title": "java-dfs-keep-track-of-max",
                "content": "```\\nclass Solution {\\n    int count = 0; \\n    public int goodNodes(TreeNode root) {\\n        dfs(root, root.val);\\n        return count; \\n    }\\n    \\n    private void dfs(TreeNode root, int max){\\n        if(root==null) return; \\n        if(root.val>=max) count++; \\n        dfs(root.left, Math.max(max, root.val));\\n        dfs(root.right, Math.max(max, root.val));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count = 0; \\n    public int goodNodes(TreeNode root) {\\n        dfs(root, root.val);\\n        return count; \\n    }\\n    \\n    private void dfs(TreeNode root, int max){\\n        if(root==null) return; \\n        if(root.val>=max) count++; \\n        dfs(root.left, Math.max(max, root.val));\\n        dfs(root.right, Math.max(max, root.val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939268,
                "title": "java-dfs-beats-100-in-time-80-in-space-easy-to-understand",
                "content": "# Intuition\\nAt the first glance, the question seems to calculate the number of nodes which are maximum value node in the path from root to the node itself.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the helper function, pass the root and a maximum value encountered till now in the path from root to node.\\nNow check if the value of root is greater than or equal to max then increment count.\\nFinally, update the max and perform recusion for left and right subtree. \\nA global counter is declared so that counting is easier for recursive calls.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)(Recusive calls)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int count=0;\\n    public int goodNodes(TreeNode root) {\\n        helper(root,Integer.MIN_VALUE);\\n        return count;\\n    }\\n    private void helper(TreeNode root, int max)\\n    {\\n        if(root==null)\\n            return;\\n        if(root.val>=max)\\n        {\\n            count++;\\n        }\\n        max=Math.max(max,root.val);\\n        helper(root.left,max);\\n        helper(root.right,max);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Counting"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int count=0;\\n    public int goodNodes(TreeNode root) {\\n        helper(root,Integer.MIN_VALUE);\\n        return count;\\n    }\\n    private void helper(TreeNode root, int max)\\n    {\\n        if(root==null)\\n            return;\\n        if(root.val>=max)\\n        {\\n            count++;\\n        }\\n        max=Math.max(max,root.val);\\n        helper(root.left,max);\\n        helper(root.right,max);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639284,
                "title": "98-20-easy-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def helper(root, curMax):\\n            if not root:\\n                return 0\\n            if root.val >= curMax:\\n                curMax = root.val\\n                return helper(root.left, curMax) + helper(root.right, curMax) + 1\\n            else:\\n                return helper(root.left, curMax) + helper(root.right, curMax)\\n        return helper(root, float(\"-inf\"))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def helper(root, curMax):\\n            if not root:\\n                return 0\\n            if root.val >= curMax:\\n                curMax = root.val\\n                return helper(root.left, curMax) + helper(root.right, curMax) + 1\\n            else:\\n                return helper(root.left, curMax) + helper(root.right, curMax)\\n        return helper(root, float(\"-inf\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515021,
                "title": "4-liner-code-c-simple",
                "content": "```\\n\\tint goodNodes(TreeNode* root, int pre = -1e5) {\\n        if(!root) return 0;\\n        int value = root->val;\\n        \\n        if(value >= pre) return (1 + goodNodes(root->left, value) + goodNodes(root->right, value));\\n        \\n        return (goodNodes(root->left, pre) + goodNodes(root->right, pre));\\n    }",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\tint goodNodes(TreeNode* root, int pre = -1e5) {\\n        if(!root) return 0;\\n        int value = root->val;\\n        \\n        if(value >= pre) return (1 + goodNodes(root->left, value) + goodNodes(root->right, value));\\n        \\n        return (goodNodes(root->left, pre) + goodNodes(root->right, pre));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2512064,
                "title": "simple-bruteforce-javascript-solution-preordertraversal",
                "content": "```\\n\\nvar cnt=0;\\nvar goodNodes = function(root) {\\n    cnt=0;\\n    fun(root,root.val);\\n    return cnt;\\n};\\nfunction fun(root,val){\\n    if(root===null){\\n        return;\\n    }\\n    if(root.val >= val){\\n        val = root.val;\\n        cnt++;\\n    }\\n    fun(root.left,val);\\n    fun(root.right,val);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n\\nvar cnt=0;\\nvar goodNodes = function(root) {\\n    cnt=0;\\n    fun(root,root.val);\\n    return cnt;\\n};\\nfunction fun(root,val){\\n    if(root===null){\\n        return;\\n    }\\n    if(root.val >= val){\\n        val = root.val;\\n        cnt++;\\n    }\\n    fun(root.left,val);\\n    fun(root.right,val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511929,
                "title": "python-87",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        c=0\\n        def dfs(root,m):\\n            if not root:\\n                return\\n            if m<=root.val:\\n                nonlocal c\\n                c+=1\\n                m=root.val\\n            dfs(root.left,m)\\n            dfs(root.right,m)\\n        dfs(root,root.val)\\n        return c\\n```\\npls upvote",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        c=0\\n        def dfs(root,m):\\n            if not root:\\n                return\\n            if m<=root.val:\\n                nonlocal c\\n                c+=1\\n                m=root.val\\n            dfs(root.left,m)\\n            dfs(root.right,m)\\n        dfs(root,root.val)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511831,
                "title": "206-ms-inf-solution",
                "content": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        \\n        self.count = 0\\n        def test(node, lower):\\n            if not node:\\n                return\\n            if node.val >= lower:\\n                self.count += 1\\n                lower = node.val\\n            \\n            test(node.left, lower)\\n            test(node.right, lower)\\n            \\n        test(root, float(\"-inf\"))\\n        return self.count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        \\n        self.count = 0\\n        def test(node, lower):\\n            if not node:\\n                return\\n            if node.val >= lower:\\n                self.count += 1\\n                lower = node.val\\n            \\n            test(node.left, lower)\\n            test(node.right, lower)\\n            \\n        test(root, float(\"-inf\"))\\n        return self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511644,
                "title": "daily-leetcode-solution-time-complexity-o-n-and-space-complexity-height-of-the-tree",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void preOrderTraversal(TreeNode* root,int maxi,int &cnt)\\n    {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\\n        if(root==NULL)\\n            return;\\n        if(root->val>=maxi)\\n        {\\n            cnt++;\\n            maxi=max(maxi,root->val);\\n        }\\n        preOrderTraversal(root->left,maxi,cnt);\\n        preOrderTraversal(root->right,maxi,cnt);\\n    }\\n    int goodNodes(TreeNode* root) {\\n    if(root==NULL)\\n        return 0;\\n    int goodCnt=0;\\n    preOrderTraversal(root,root->val,goodCnt);\\n        return goodCnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void preOrderTraversal(TreeNode* root,int maxi,int &cnt)\\n    {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\\n        if(root==NULL)\\n            return;\\n        if(root->val>=maxi)\\n        {\\n            cnt++;\\n            maxi=max(maxi,root->val);\\n        }\\n        preOrderTraversal(root->left,maxi,cnt);\\n        preOrderTraversal(root->right,maxi,cnt);\\n    }\\n    int goodNodes(TreeNode* root) {\\n    if(root==NULL)\\n        return 0;\\n    int goodCnt=0;\\n    preOrderTraversal(root,root->val,goodCnt);\\n        return goodCnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2511579,
                "title": "very-easy-recursive-implementation-beats-70-runtime",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        max=root.val\\n        #arr=[]\\n        count=0\\n        def dfs(node,max):\\n            nonlocal count\\n            if not node:\\n                return\\n            if node:\\n                if node.val>=max:\\n                    max=node.val\\n                    count+=1\\n                    #arr.append(max)\\n            dfs(node.left,max)\\n            dfs(node.right,max)\\n        dfs(root,root.val)\\n        return count# len(arr)\\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        max=root.val\\n        #arr=[]\\n        count=0\\n        def dfs(node,max):\\n            nonlocal count\\n            if not node:\\n                return\\n            if node:\\n                if node.val>=max:\\n                    max=node.val\\n                    count+=1\\n                    #arr.append(max)\\n            dfs(node.left,max)\\n            dfs(node.right,max)\\n        dfs(root,root.val)\\n        return count# len(arr)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440554,
                "title": "c-dfs-pre-order-traversal-explained",
                "content": "![image](https://assets.leetcode.com/users/images/f4aba9f8-3c4f-46cf-a892-1739323fe1ee_1660758543.8559844.png)\\n\\n**Logic->Use DFS (Depth First Search) to traverse the tree, and constantly keep track of the current path maximum.**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint count=0;\\n\\t\\tvoid dfs(TreeNode* curr,int maxi){\\n\\t\\t\\tif(!curr) return;\\n\\t\\t\\tif(curr->val>=maxi) count++;\\n\\t\\t\\tdfs(curr->left,max(maxi,curr->val));\\n\\t\\t\\tdfs(curr->right,max(maxi,curr->val));\\n\\t\\t}\\n\\n\\t\\tint goodNodes(TreeNode* root) {\\n\\t\\t\\tdfs(root,root->val);\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint count=0;\\n\\t\\tvoid dfs(TreeNode* curr,int maxi){\\n\\t\\t\\tif(!curr) return;\\n\\t\\t\\tif(curr->val>=maxi) count++;\\n\\t\\t\\tdfs(curr->left,max(maxi,curr->val));\\n\\t\\t\\tdfs(curr->right,max(maxi,curr->val));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1879517,
                "title": "c-bfs-iterative",
                "content": "Not recommended since DFS looks so easy but if you are intrested in the BFS approach, here it is.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans = 1;\\n        queue<pair<TreeNode*,int>> Q;\\n        Q.push({root, root->val});\\n        while(!Q.empty())\\n        {\\n            int sz = Q.size();\\n            for(int i=0; i<sz; i++)\\n            {\\n                pair<TreeNode*, int> front = Q.front();\\n                Q.pop();\\n                \\n                if(front.first->left)\\n                {\\n                    pair<TreeNode*, int> newNode = {front.first->left, max(front.first->left->val, front.second)};\\n                    \\n                    if(newNode.second == newNode.first->val)\\n                        ans++;\\n                    Q.push(newNode);\\n                }\\n                \\n                if(front.first->right)\\n                {\\n                    pair<TreeNode*, int> newNode = {front.first->right, max(front.first->right->val, front.second)};\\n                    \\n                    if(newNode.second == newNode.first->val)\\n                        ans++;\\n                    Q.push(newNode);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans = 1;\\n        queue<pair<TreeNode*,int>> Q;\\n        Q.push({root, root->val});\\n        while(!Q.empty())\\n        {\\n            int sz = Q.size();\\n            for(int i=0; i<sz; i++)\\n            {\\n                pair<TreeNode*, int> front = Q.front();\\n                Q.pop();\\n                \\n                if(front.first->left)\\n                {\\n                    pair<TreeNode*, int> newNode = {front.first->left, max(front.first->left->val, front.second)};\\n                    \\n                    if(newNode.second == newNode.first->val)\\n                        ans++;\\n                    Q.push(newNode);\\n                }\\n                \\n                if(front.first->right)\\n                {\\n                    pair<TreeNode*, int> newNode = {front.first->right, max(front.first->right->val, front.second)};\\n                    \\n                    if(newNode.second == newNode.first->val)\\n                        ans++;\\n                    Q.push(newNode);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410962,
                "title": "java-beat-100-runtime-recursion-beginner-friendly",
                "content": "This is intended to be a beginner-friendly solution. You can skip to the code below if you find the text overwhelming. Let\\'s try to break this down into parts.\\n****\\n**INTUITION FOCUSED ON RECURSION**\\n\\nFirst things first, we need to compare the value at the current node (*currentVal*) to the MAXIMUM value in the path from the root to the current node (*maxPathValue*). Intuitively, it would help if we could somehow keep track of the maximum value in the path so far. \\n****\\n**THE WORK-AROUND SOLUTION**\\n\\nHowever, the given method signature ```public int goodNodes (TreeNode root) {} ``` does not provide any reference variables to keep track of the maximum value. To work around this, we can simply create a new method ```goodNodesUtil``` which takes in the following parameters:\\n1. A \\'root\\' variable of type \\'TreeNode\\'\\n2. A \\'maxPathValue\\' variable of type \\'int\\'\\n\\nThe full signature of the new method: ```public int goodNodesUtil (TreeNode root, int maxPathValue) {}```\\n****\\n**RECURSIVE LOGIC**\\n\\nNow that we have our signature, let\\'s get down to the brass tacks. We have to make a recursive call to *__every node__* of the Tree. Why every node? Because it is possible to have a situation like this: \\n* ```3 (rootNode) --> 1 (not a good node) --> 4 (good node)```\\nHere the arrows represent parent-to-child relations\\n\\nWe can traverse the tree from left sub-tree to right sub-tree. For every recursive call, we will return the number of good nodes found in the subtree with ```rootNode``` as its root. We will add this number to the count being maintained by the parent node of ```rootNode```. Effectively, the code snippet will look something like\\n* ```count = count + {Recursive call to subtree}```\\n\\nSince it is a binary tree, we can have at most two sub-trees (left and right). So there will be a recursive call to each of these subtrees\\n* ```count = count + {Recursive call to left sub-tree}```\\n* ```count = count + {Recursive call to right sub-tree}```\\n****\\n**THE CHOICE**\\n\\nWe will also need to initialise the above-mentioned ```count```.\\nFor every node that we visit, we have a choice. We can either choose to count it as a good node or a bad node, based on some conditions discussed in the next section. But we\\'ll talk about the choice for now. If we choose to count it as a\\n* *__good node__*; then we can initialise ```count``` to ```1```\\n* *__bad node__*; then we can initialise ```count``` to ```0```\\n\\nThus the initialisation itself provides a solution to our choice.\\n****\\n**THE CONDITIONS**\\n\\nWe decide if our current node is good or bad based on the given conditions.\\nIf our current node value is greater than or equal to ```maxPathValue```, then our current node is a *__good node__* and we need to count it. In addition, we need to update the ```maxPathValue``` to our current node value.\\n```if (currentNodeValue >= maxPathValue) maxPathValue = currentNodeValue ```\\nIf this is not the case, then our current node is *__bad__* and we don\\'t need to update ```maxPathValue```.\\n****\\n**THE CODE**\\nFinally, we need to return count.\\n\\n\\n```class Solution {\\n    public int goodNodes (TreeNode root) {\\n\\t\\t// a call to our self-made method\\n        return goodNodesUtil (root, root.val);        \\n    }\\n    \\n    public int goodNodesUtil (TreeNode root, int maxPathValue) {\\n        \\n\\t\\t// initialise the number of good nodes in the subtree with THIS node as root\\n\\t\\t// if THIS node\\'s value is greater than maxPathValue, count THIS as a good node\\n\\t\\tint count = 0;\\n        if (root.val >= maxPathValue) {\\n            count++;\\n        }\\n\\t\\t\\n\\t\\t// Before recursive calls to the sub-trees, save up by checking for NULL\\n\\t\\t// Instead of updating maxPathValue, you can simply pass the maximum value\\n\\t\\t// Notice the second argument passed, it is the new maximum\\n        if (root.left != null) {\\n            count = count + goodNodesUtil(root.left, Math.max(root.val, maxPathValue));\\n        }\\n        if (root.right != null) {\\n            count = count + goodNodesUtil(root.right, Math.max(root.val, maxPathValue));\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```public int goodNodes (TreeNode root) {} ```\n```goodNodesUtil```\n```public int goodNodesUtil (TreeNode root, int maxPathValue) {}```\n```3 (rootNode) --> 1 (not a good node) --> 4 (good node)```\n```rootNode```\n```rootNode```\n```count = count + {Recursive call to subtree}```\n```count = count + {Recursive call to left sub-tree}```\n```count = count + {Recursive call to right sub-tree}```\n```count```\n```count```\n```1```\n```count```\n```0```\n```maxPathValue```\n```maxPathValue```\n```if (currentNodeValue >= maxPathValue) maxPathValue = currentNodeValue ```\n```maxPathValue```",
                "codeTag": "Unknown"
            },
            {
                "id": 1191416,
                "title": "python-java-simple-dfs-solution-with-explanation-beats-97-submissions",
                "content": "We will use **dfs** to solve this problem. Here we will also store the max value that we encountered during traversal of nodes. On each node we will **check the node.val >= max**. If it is **true then** we will **increment the counter** and **change the max = node.val**,  else we will check next node node, keeping the max value same as previous. If you have any doubt than comment please and if like my answer then upvote.\\n\\n![image](https://assets.leetcode.com/users/images/b644fa9e-9086-41cb-9312-120a827de460_1620149151.402691.png)\\n\\n\\n**Pyhton Solution:**\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        \\n        count = 1\\n        \\n        def dfs(root,maxval):\\n            nonlocal count\\n            \\n            if root.left:\\n                if root.left.val >= maxval:\\n                    count+=1\\n                    dfs(root.left,root.left.val)\\n            \\n                else: \\n                    dfs(root.left,maxval)\\n                    \\n            if root.right:\\n                if root.right.val >= maxval:\\n                    count+=1\\n                    dfs(root.right,root.right.val)\\n            \\n                else: \\n                    dfs(root.right,maxval)\\n                    \\n            \\n        dfs(root, root.val)\\n        \\n        return count\\n```\\n\\n**Java Solution:**\\n\\n```\\nclass Solution {\\n    \\n    int count=1;\\n    \\n    public void dfs(TreeNode root, int max){\\n        \\n        if (root.left!=null){\\n            if (root.left.val >= max){\\n                count+=1;\\n                dfs(root.left, root.left.val);\\n            }else{\\n                dfs(root.left, max);\\n            }\\n        }\\n        if (root.right!=null){\\n            if (root.right.val >= max){\\n                count+=1;\\n                dfs(root.right, root.right.val);\\n            }else{\\n                dfs(root.right, max);\\n            }\\n        }\\n        \\n    }\\n    \\n    public int goodNodes(TreeNode root) {\\n        dfs(root, root.val);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        \\n        count = 1\\n        \\n        def dfs(root,maxval):\\n            nonlocal count\\n            \\n            if root.left:\\n                if root.left.val >= maxval:\\n                    count+=1\\n                    dfs(root.left,root.left.val)\\n            \\n                else: \\n                    dfs(root.left,maxval)\\n                    \\n            if root.right:\\n                if root.right.val >= maxval:\\n                    count+=1\\n                    dfs(root.right,root.right.val)\\n            \\n                else: \\n                    dfs(root.right,maxval)\\n                    \\n            \\n        dfs(root, root.val)\\n        \\n        return count\\n```\n```\\nclass Solution {\\n    \\n    int count=1;\\n    \\n    public void dfs(TreeNode root, int max){\\n        \\n        if (root.left!=null){\\n            if (root.left.val >= max){\\n                count+=1;\\n                dfs(root.left, root.left.val);\\n            }else{\\n                dfs(root.left, max);\\n            }\\n        }\\n        if (root.right!=null){\\n            if (root.right.val >= max){\\n                count+=1;\\n                dfs(root.right, root.right.val);\\n            }else{\\n                dfs(root.right, max);\\n            }\\n        }\\n        \\n    }\\n    \\n    public int goodNodes(TreeNode root) {\\n        dfs(root, root.val);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139641,
                "title": "preorder-beats-96-of-submissions",
                "content": "Preorder traversal solution\\nBeats 96% of submissions\\n![image](https://assets.leetcode.com/users/images/858ebcaf-ccec-461a-8fdc-8cb55885f694_1617420918.0829937.png)\\n\\n ```\\nvar goodNodes = function(root) {\\n\\t//counter to count number of good nodes\\n    let counter = 0;\\n    \\n    const preOrderTraversal = (node, maxValue) => {\\n        if(!node) return;\\n\\t\\t\\n\\t\\t   //in preorder, we look at current node first and then left node then right node\\n        //Add to counter and update max value for this path if the current node is equal or bigger than the largest value we have seen\\n        if(node.val >= maxValue) {\\n            counter++;\\n            maxValue = node.val;\\n        }\\n        preOrderTraversal(node.left, maxValue);\\n        preOrderTraversal(node.right, maxValue);\\n    }\\n    \\n\\t//start function call with initial root and negative number(or -100000)\\n    preOrderTraversal(root, -Number.MAX_VALUE);\\n    return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar goodNodes = function(root) {\\n\\t//counter to count number of good nodes\\n    let counter = 0;\\n    \\n    const preOrderTraversal = (node, maxValue) => {\\n        if(!node) return;\\n\\t\\t\\n\\t\\t   //in preorder, we look at current node first and then left node then right node\\n        //Add to counter and update max value for this path if the current node is equal or bigger than the largest value we have seen\\n        if(node.val >= maxValue) {\\n            counter++;\\n            maxValue = node.val;\\n        }\\n        preOrderTraversal(node.left, maxValue);\\n        preOrderTraversal(node.right, maxValue);\\n    }\\n    \\n\\t//start function call with initial root and negative number(or -100000)\\n    preOrderTraversal(root, -Number.MAX_VALUE);\\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122283,
                "title": "java-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int goods = 0;\\n    public int goodNodes(TreeNode root) {\\n        dfs(root,Integer.MIN_VALUE);\\n        \\n        return goods;\\n    }\\n    \\n    private void dfs(TreeNode root,int max){\\n        if(root == null)\\n            return;\\n        if(root.val >= max){\\n            goods+=1;\\n            max = root.val;\\n        }\\n        dfs(root.left,max);\\n        dfs(root.right,max);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int goods = 0;\\n    public int goodNodes(TreeNode root) {\\n        dfs(root,Integer.MIN_VALUE);\\n        \\n        return goods;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 982782,
                "title": "easy-python-recursive-beats-90-with-comments",
                "content": "Easy to solve top down, we just need to carry the largest number we find along each path from root to each leaf, each time a given node that we\\'re at is >= the max we\\'ve encountered so far, we add 1 to our count and update our max seen so far.\\n\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        # Our counter for the good nodes.\\n        count = 0\\n        \\n        def helper(node, m):\\n            nonlocal count\\n\\t\\t\\t# If we run out of nodes return.\\n            if not node:\\n                return\\n\\t\\t\\t# If the current node val is >= the largest observed in the path thus far.\\n            if node.val >= m:\\n\\t\\t\\t    # Add 1 to the count and update the max observed value.\\n                count += 1\\n                m = max(m, node.val)\\n\\t\\t\\t# Traverse l and r subtrees.\\n            helper(node.left, m)\\n            helper(node.right, m)\\n                \\n        helper(root, root.val)\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        # Our counter for the good nodes.\\n        count = 0\\n        \\n        def helper(node, m):\\n            nonlocal count\\n\\t\\t\\t# If we run out of nodes return.\\n            if not node:\\n                return\\n\\t\\t\\t# If the current node val is >= the largest observed in the path thus far.\\n            if node.val >= m:\\n\\t\\t\\t    # Add 1 to the count and update the max observed value.\\n                count += 1\\n                m = max(m, node.val)\\n\\t\\t\\t# Traverse l and r subtrees.\\n            helper(node.left, m)\\n            helper(node.right, m)\\n                \\n        helper(root, root.val)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033566,
                "title": "easy-c-solution-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\nint count = 0;\\n\\n\\nif(!root->right && !root->left ){\\nreturn 1;\\n}\\nint  max_so_far = 0;\\niterate(root,max_so_far, count);\\n\\n\\nreturn count;\\n\\n\\n\\n\\n}\\n\\n\\nvoid iterate(TreeNode* node, int max_so_far, int& count){\\n\\n\\nif(node){\\n\\n\\nif(node->val >= max_so_far ){\\ncount++;\\nmax_so_far = node->val;\\n}\\n\\n\\niterate(node->left,max_so_far, count );\\niterate(node->right, max_so_far, count);\\n}\\n\\n\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\nint count = 0;\\n\\n\\nif(!root->right && !root->left ){\\nreturn 1;\\n}\\nint  max_so_far = 0;\\niterate(root,max_so_far, count);\\n\\n\\nreturn count;\\n\\n\\n\\n\\n}\\n\\n\\nvoid iterate(TreeNode* node, int max_so_far, int& count){\\n\\n\\nif(node){\\n\\n\\nif(node->val >= max_so_far ){\\ncount++;\\nmax_so_far = node->val;\\n}\\n\\n\\niterate(node->left,max_so_far, count );\\niterate(node->right, max_so_far, count);\\n}\\n\\n\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019697,
                "title": "beats-100-both-time-space",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint x=0;\\n    void helper(TreeNode* root,int y){\\n        if(root==NULL){return;}\\n        y=max(y,root->val);\\n        helper(root->left,y);\\n        helper(root->right,y);\\n        if(root->val>=y){x++;}\\n    }\\n\\n    int goodNodes(TreeNode* root) {\\n        helper(root,root->val);\\n        root->left=NULL;\\n        root->right=NULL;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint x=0;\\n    void helper(TreeNode* root,int y){\\n        if(root==NULL){return;}\\n        y=max(y,root->val);\\n        helper(root->left,y);\\n        helper(root->right,y);\\n        if(root->val>=y){x++;}\\n    }\\n\\n    int goodNodes(TreeNode* root) {\\n        helper(root,root->val);\\n        root->left=NULL;\\n        root->right=NULL;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941690,
                "title": "c-recursive-solution-using-preorder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to keep track of maximum value encountered in each root to node path and increment answer if node->val is greater than or equal to currMax encountered till that path.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a recursive function to traverse all root to node paths. In each iteration we check if the node value is new maximum / equal to previous maximum.\\nIf yes then we increment count and update our currMax\\nMake recursive calls for left and right subtrees\\n\\n# Complexity\\n- Time complexity: O(Number of nodes)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(height of tree) due to recursion\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void traverse(TreeNode* root, int currMax, int &ans){\\n        if(!root) return;\\n\\n        if(root->val >= currMax){\\n            ans++;\\n            currMax = root->val;\\n        }\\n\\n        traverse(root->left, currMax, ans);\\n        traverse(root->right, currMax, ans);\\n\\n\\n    }\\n    int goodNodes(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, root->val, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void traverse(TreeNode* root, int currMax, int &ans){\\n        if(!root) return;\\n\\n        if(root->val >= currMax){\\n            ans++;\\n            currMax = root->val;\\n        }\\n\\n        traverse(root->left, currMax, ans);\\n        traverse(root->right, currMax, ans);\\n\\n\\n    }\\n    int goodNodes(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, root->val, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790380,
                "title": "java-clean-code-recursion-o-n",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int count=0;\\n    public int goodNodes(TreeNode root) {\\n        return 1+maxNode(root.left,root.val)+maxNode(root.right,root.val);\\n    }\\n    public int maxNode(TreeNode root,int maxVal){\\n        if(root==null)  return 0;\\n\\n        int res=0;\\n        if(root.val>=maxVal){\\n            res=1;\\n            maxVal=Math.max(maxVal,root.val);\\n        }\\n\\n        count=res+maxNode(root.left,maxVal)+maxNode(root.right,maxVal);\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    int count=0;\\n    public int goodNodes(TreeNode root) {\\n        return 1+maxNode(root.left,root.val)+maxNode(root.right,root.val);\\n    }\\n    public int maxNode(TreeNode root,int maxVal){\\n        if(root==null)  return 0;\\n\\n        int res=0;\\n        if(root.val>=maxVal){\\n            res=1;\\n            maxVal=Math.max(maxVal,root.val);\\n        }\\n\\n        count=res+maxNode(root.left,maxVal)+maxNode(root.right,maxVal);\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478551,
                "title": "python-simple-clean-solution-using-dfs",
                "content": "# Code\\n```Python []\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        res = [0]\\n        def helper(root, maxi):\\n            if root:\\n                maxi = max(maxi, root.val)\\n                if maxi <= root.val:\\n                    res[0] += 1\\n                if root.left:\\n                    helper(root.left, maxi)\\n                if root.right:\\n                    helper(root.right, maxi)\\n        helper(root, -maxsize)\\n        return res[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```Python []\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        res = [0]\\n        def helper(root, maxi):\\n            if root:\\n                maxi = max(maxi, root.val)\\n                if maxi <= root.val:\\n                    res[0] += 1\\n                if root.left:\\n                    helper(root.left, maxi)\\n                if root.right:\\n                    helper(root.right, maxi)\\n        helper(root, -maxsize)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194535,
                "title": "python-simple-one-line-dfs-solution",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    def goodNodes(self, root: TreeNode, so_far_max=-10001) -> int:\\n        return (\\n                int(root.val >= so_far_max) +\\n                self.goodNodes(root.left, max(root.val, so_far_max)) +\\n                self.goodNodes(root.right, max(root.val, so_far_max))\\n        ) if root else 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    def goodNodes(self, root: TreeNode, so_far_max=-10001) -> int:\\n        return (\\n                int(root.val >= so_far_max) +\\n                self.goodNodes(root.left, max(root.val, so_far_max)) +\\n                self.goodNodes(root.right, max(root.val, so_far_max))\\n        ) if root else 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133438,
                "title": "super-easy-short-c-solution-using-recursion-beats-94",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int ans=0;\\nvoid exe(TreeNode* root, int curr){\\n     if(root==NULL)\\n        return;\\n\\nif(root->val>=curr){\\ncurr=root->val;\\nans++;\\n    }\\nexe(root->left,curr);\\nexe(root->right,curr);\\n\\n    }\\n\\nint goodNodes(TreeNode* root) {\\n   if(root==NULL)\\n   return 0;\\n    exe(root,root->val);\\n    return ans;    \\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int ans=0;\\nvoid exe(TreeNode* root, int curr){\\n     if(root==NULL)\\n        return;\\n\\nif(root->val>=curr){\\ncurr=root->val;\\nans++;\\n    }\\nexe(root->left,curr);\\nexe(root->right,curr);\\n\\n    }\\n\\nint goodNodes(TreeNode* root) {\\n   if(root==NULL)\\n   return 0;\\n    exe(root,root->val);\\n    return ans;    \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514942,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    int c;\\n    public int goodNodes(TreeNode root) {\\n        c=0;\\n        task(root,root.val);\\n        return c;\\n    }\\n    public void task(TreeNode root, int max)\\n    {\\n        if(root==null)\\n            return;\\n        if(root.val>=max)\\n            c++;\\n        max=Math.max(max,root.val);\\n        task(root.left,max);\\n        task(root.right,max);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int c;\\n    public int goodNodes(TreeNode root) {\\n        c=0;\\n        task(root,root.val);\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2514865,
                "title": "easy-to-understand-python-recursive-solution-98-3-faster",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def dfs(root, prevMax, count):\\n            if root.val >= prevMax:  \\n                prevMax = root.val   #updating previous max value\\n                count+=1    #increasing count by 1\\n            \\n            if root.left:     \\n                count = dfs(root.left, prevMax, count)   #we need to update count hence my recursive fucntion will return count\\n            if root.right:\\n                count = dfs(root.right, prevMax, count)\\n            \\n            return count\\n        return dfs(root, root.val, 0)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def dfs(root, prevMax, count):\\n            if root.val >= prevMax:  \\n                prevMax = root.val   #updating previous max value\\n                count+=1    #increasing count by 1\\n            \\n            if root.left:     \\n                count = dfs(root.left, prevMax, count)   #we need to update count hence my recursive fucntion will return count\\n            if root.right:\\n                count = dfs(root.right, prevMax, count)\\n            \\n            return count\\n        return dfs(root, root.val, 0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2513709,
                "title": "javascript-recursive-dfs-easy-to-understand",
                "content": "```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar goodNodes = function(root) {\\n    let count = 0;\\n  \\n    function dfs(root, max) {\\n        if (root == null)\\n            return;\\n        \\n        if (root.val >= max) {\\n            max = root.val;\\n            count++;\\n        }\\n        \\n        dfs(root.left, max);\\n        dfs(root.right, max);\\n    }\\n\\t\\n\\tdfs(root, root.val);\\n    return count;\\n};\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar goodNodes = function(root) {\\n    let count = 0;\\n  \\n    function dfs(root, max) {\\n        if (root == null)\\n            return;\\n        \\n        if (root.val >= max) {\\n            max = root.val;\\n            count++;\\n        }\\n        \\n        dfs(root.left, max);\\n        dfs(root.right, max);\\n    }\\n\\t\\n\\tdfs(root, root.val);\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2513012,
                "title": "python-by-using-global-variable-simple-and-easy-way",
                "content": "### nonlocal is used to get the global variable as local variable\\n\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        maxx = root.val\\n        count = 0\\n        def dfs(node,maxx):\\n            nonlocal count\\n            if node is None:\\n                return\\n            if node.val >= maxx:\\n                count +=1\\n                maxx = node.val\\n            dfs(node.left,maxx)\\n            dfs(node.right,maxx)\\n            return\\n        dfs(root,maxx)\\n        return count\\n        \\n```\\n\\t```\\n![image](https://assets.leetcode.com/users/images/ab7f61ce-49b7-42bf-b56d-35025ff8341a_1662020156.9022303.jpeg)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        maxx = root.val\\n        count = 0\\n        def dfs(node,maxx):\\n            nonlocal count\\n            if node is None:\\n                return\\n            if node.val >= maxx:\\n                count +=1\\n                maxx = node.val\\n            dfs(node.left,maxx)\\n            dfs(node.right,maxx)\\n            return\\n        dfs(root,maxx)\\n        return count\\n        \\n```\n```\\n![image](https://assets.leetcode.com/users/images/ab7f61ce-49b7-42bf-b56d-35025ff8341a_1662020156.9022303.jpeg)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512823,
                "title": "easy-c-solution-98-faster-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,int x){\\n        if(!root)return 0;\\n        int l=0;\\n        if(root->val>=x){\\n            x=root->val;\\n            l=1;\\n        }\\n        return l+dfs(root->left,x)+dfs(root->right,x);\\n    }\\n    int goodNodes(TreeNode* root) {\\n        return dfs(root,root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,int x){\\n        if(!root)return 0;\\n        int l=0;\\n        if(root->val>=x){\\n            x=root->val;\\n            l=1;\\n        }\\n        return l+dfs(root->left,x)+dfs(root->right,x);\\n    }\\n    int goodNodes(TreeNode* root) {\\n        return dfs(root,root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512526,
                "title": "python-better-than-97-easy-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/97184399-15fc-48b8-acec-ccbf3e6a2ea1_1662013668.6318004.png)\\n\\n<hr />\\n\\nThe idea is to start a DFS from the root.\\n\\nWe will record the max value seen so far from the root, if the current node is bigger or equal to that number, we found 1 more valid path.\\n\\nWe update the max value seen whenever the current node is bigger than that value and continue our DFS.\\n\\nIn the end, we sum the results from left and right subtrees, so every node represents the paths found up to that point.\\n\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        \\n        def seek(node, max_value_seen):\\n            if not node: return 0\\n            \\n            node_res = 0\\n            if node.val >= max_value_seen:\\n                node_res += 1\\n                max_value_seen = node.val\\n            \\n            node_res += seek(node.left, max_value_seen)\\n            node_res += seek(node.right, max_value_seen)\\n            return node_res\\n            \\n        \\n        return seek(root, float(\\'-inf\\'))\\n```\\n\\nNote: The same approach could we taken with BFS.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        \\n        def seek(node, max_value_seen):\\n            if not node: return 0\\n            \\n            node_res = 0\\n            if node.val >= max_value_seen:\\n                node_res += 1\\n                max_value_seen = node.val\\n            \\n            node_res += seek(node.left, max_value_seen)\\n            node_res += seek(node.right, max_value_seen)\\n            return node_res\\n            \\n        \\n        return seek(root, float(\\'-inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512337,
                "title": "java-dfs-simple-4-liner-clean-code",
                "content": "### JAVA CLEAN CODE SOLUTION \\uD83D\\uDE4C\\uD83C\\uDFFC\\n* Logic of this question is that, we do a normal dfs ```pre order traversal```!\\n* And then check for good node at every node!!\\n* As the binary tree is not a BST, we have to keep track of maximum value node(previous) and send that to subtrees.\\n* Finally we return our total good nodes.\\n```\\nclass Solution {\\n    \\n    public int goodNodes(TreeNode root) {\\n        return goodNodesHelper(root, Integer.MIN_VALUE);\\n    }\\n\\n\\t//helper function\\n    private int goodNodesHelper(TreeNode root, int previous) {\\n        if (root == null) return 0;\\n        int nodes = 0;\\n        if (root.val >= previousMinimum) nodes += 1;\\n        return goodNodesHelper(root.left, Math.max(root.val, previous)) + \\n\\t\\t\\t   goodNodesHelper(root.right, Math.max(root.val, previous)) + nodes;\\n    }\\n}\\n\\n```\\n\\n__Feel free to connect, comment and criticize__ \\uD83E\\uDEE1\\nauthor : [@bharathkalyans](https://leetcode.com/bharathkalyans/)\\nlinkedin : [@bharathkalyans](https://www.linkedin.com/in/bharathkalyans/)\\ntwitter : [@bharathkalyans](https://twitter.com/bharathkalyans)",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```pre order traversal```\n```\\nclass Solution {\\n    \\n    public int goodNodes(TreeNode root) {\\n        return goodNodesHelper(root, Integer.MIN_VALUE);\\n    }\\n\\n\\t//helper function\\n    private int goodNodesHelper(TreeNode root, int previous) {\\n        if (root == null) return 0;\\n        int nodes = 0;\\n        if (root.val >= previousMinimum) nodes += 1;\\n        return goodNodesHelper(root.left, Math.max(root.val, previous)) + \\n\\t\\t\\t   goodNodesHelper(root.right, Math.max(root.val, previous)) + nodes;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512095,
                "title": "c-easily-understandable-pre-order-simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    void count(TreeNode* root,int mx,int& good)\\n    {\\n        if(!root) return;\\n        \\n        if(root->val>=mx)\\n        {\\n            good++;\\n            mx=root->val;\\n        }\\n        \\n        count(root->left,mx,good);\\n        count(root->right,mx,good);\\n        return;\\n    }\\n    \\n    int goodNodes(TreeNode* root) \\n    {\\n        int good = 0;\\n        count(root,INT_MIN,good);\\n        return good;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void count(TreeNode* root,int mx,int& good)\\n    {\\n        if(!root) return;\\n        \\n        if(root->val>=mx)\\n        {\\n            good++;\\n            mx=root->val;\\n        }\\n        \\n        count(root->left,mx,good);\\n        count(root->right,mx,good);\\n        return;\\n    }\\n    \\n    int goodNodes(TreeNode* root) \\n    {\\n        int good = 0;\\n        count(root,INT_MIN,good);\\n        return good;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512060,
                "title": "simple-java-solution-recursion",
                "content": "PLEASE UPVOTE IF ITS HELPFUL-\\n\\n```\\nclass Solution {\\n   int count;\\n    public int goodNodes(TreeNode root) {\\n        if(root==null)\\n        return 0;\\n        \\n        count=0;\\n        helper(root,Integer.MIN_VALUE);\\n        return count;\\n    }\\n    \\n    void helper(TreeNode root,int max) {\\n         if(root==null)\\n         return;\\n        \\n       if(root.val >= max){\\n            count++;\\n            max = root.val;\\n        }\\n        helper(root.left,max);\\n        helper(root.right,max);\\n      \\n    }\\n}\\n```\\n**63 / 63 test cases passed.\\nStatus: Accepted\\nRuntime: 2 ms\\nMemory Usage: 59.5 MB**",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n   int count;\\n    public int goodNodes(TreeNode root) {\\n        if(root==null)\\n        return 0;\\n        \\n        count=0;\\n        helper(root,Integer.MIN_VALUE);\\n        return count;\\n    }\\n    \\n    void helper(TreeNode root,int max) {\\n         if(root==null)\\n         return;\\n        \\n       if(root.val >= max){\\n            count++;\\n            max = root.val;\\n        }\\n        helper(root.left,max);\\n        helper(root.right,max);\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511921,
                "title": "c-1-liner-recursion",
                "content": "Below is a recursive function that terminates when the input node is null. A null tree means that there are no good nodes.\\n\\nAn optional parameter is used to track the maximum parent value. It defaults to the smallest possible integer and is updated at each recursive step.\\n\\nWhen the current node has a value that is at least as large as it\\'s largest parent value, then it is a good node and we add it to the result. Add the the results of recursing to both the left and right children to determine the final result.\\n\\n```cs\\npublic int GoodNodes(TreeNode root, int max = int.MinValue) =>\\n    root == null\\n        ? 0\\n        : (root.val >= max ? 1 : 0)\\n            + GoodNodes(root.left, Math.Max(max, root.val))\\n            + GoodNodes(root.right, Math.Max(max, root.val));\\n```\\n\\nCheck out my other C# 1-liners!\\n* https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cs\\npublic int GoodNodes(TreeNode root, int max = int.MinValue) =>\\n    root == null\\n        ? 0\\n        : (root.val >= max ? 1 : 0)\\n            + GoodNodes(root.left, Math.Max(max, root.val))\\n            + GoodNodes(root.right, Math.Max(max, root.val));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511872,
                "title": "easy-c-solution-recursion-o-n-time",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root,int maz=INT_MIN) {\\n        if(root==NULL)\\n        return 0;\\n        int count =0;\\n        if(maz<=root->val)\\n        {\\n            maz = root->val;\\n            count+=1;\\n        }   \\n        return count+=goodNodes(root->right,maz)+goodNodes(root->left,maz);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root,int maz=INT_MIN) {\\n        if(root==NULL)\\n        return 0;\\n        int count =0;\\n        if(maz<=root->val)\\n        {\\n            maz = root->val;\\n            count+=1;\\n        }   \\n        return count+=goodNodes(root->right,maz)+goodNodes(root->left,maz);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511785,
                "title": "c-dfs-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        return fun(root,root->val);\\n    }\\n    int fun(TreeNode* root,int value)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int t=0;\\n        if(root->val >= value)// if root->val is >= value, this node will be counted. \\n        {\\n            t++;\\n            value = root->val;// updating the max value from root to upto the node\\n        }\\n        \\n        return t + fun(root->left,value) + fun(root->right,value);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        return fun(root,root->val);\\n    }\\n    int fun(TreeNode* root,int value)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int t=0;\\n        if(root->val >= value)// if root->val is >= value, this node will be counted. \\n        {\\n            t++;\\n            value = root->val;// updating the max value from root to upto the node\\n        }\\n        \\n        return t + fun(root->left,value) + fun(root->right,value);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848123,
                "title": "c-easy-understandable-code",
                "content": "``` class Solution {\\npublic:\\n    int cnt=0;\\n    void dfs_tree(TreeNode* root,int maxe)\\n    { if(root==NULL)\\n        return;\\n      if(root->val >= maxe)\\n      {\\n          cnt++;\\n          maxe=root->val;\\n      }\\n     dfs_tree(root->left,maxe);\\n     dfs_tree(root->right,maxe);\\n          \\n        \\n    }\\n    \\n    \\n    int goodNodes(TreeNode* root) {\\n      dfs_tree(root,root->val);\\n        return cnt;\\n    }\\n}; \\n```",
                "solutionTags": [],
                "code": "``` class Solution {\\npublic:\\n    int cnt=0;\\n    void dfs_tree(TreeNode* root,int maxe)\\n    { if(root==NULL)\\n        return;\\n      if(root->val >= maxe)\\n      {\\n          cnt++;\\n          maxe=root->val;\\n      }\\n     dfs_tree(root->left,maxe);\\n     dfs_tree(root->right,maxe);\\n          \\n        \\n    }\\n    \\n    \\n    int goodNodes(TreeNode* root) {\\n      dfs_tree(root,root->val);\\n        return cnt;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808470,
                "title": "c-easy-recursive-solution-brief-explanation",
                "content": "We will check whether  a value is greater than or equal to maximum of all previous traversed values.\\nso we will keep a maxvalue variable to store maximum till now .\\n*if  value of node is greater than current max we will update maxvalue and from that node we will move to its left and right node.\\nelse we will move to its left and right node without updating the maxvalue.*\\n##### C++ :\\n```\\nclass Solution {\\n    int c=0;\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        countgood(root,INT_MIN);\\n        return c;\\n    }\\n    void countgood(TreeNode* root,int maxvalue)\\n    {\\n        if(root==NULL)\\n            return ;\\n        if(root->val>=maxvalue)\\n        {c++;\\n         maxvalue=root->val;}\\n        countgood(root->left,maxvalue);\\n        countgood(root->right,maxvalue);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int c=0;\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        countgood(root,INT_MIN);\\n        return c;\\n    }\\n    void countgood(TreeNode* root,int maxvalue)\\n    {\\n        if(root==NULL)\\n            return ;\\n        if(root->val>=maxvalue)\\n        {c++;\\n         maxvalue=root->val;}\\n        countgood(root->left,maxvalue);\\n        countgood(root->right,maxvalue);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632314,
                "title": "javascript-recursive-and-iterative-solution",
                "content": "```\\n/**\\n * Time O(N)\\n * Space O(height)\\n */\\n \\n var goodNodes = function(root, max = -Infinity) {   \\n    if(root == null) return 0;\\n    let res = 0;\\n\\n    if(root.val >= max){\\n        res++;\\n        max = root.val;\\n    }\\n\\n    res += goodNodes(root.left, max);\\n    res += goodNodes(root.right, max);\\n\\n    return res;\\n}\\n\\nvar goodNodes = function(root) {\\n    \\n    let stck = [], res = 0;\\n    stck.push([root, root.val])\\n\\n    while(stck.length > 0){\\n        let curr = stck.pop();\\n        let [node, max] = [curr[0], curr[1]];\\n\\n        if(node.val >= max){\\n            res++;\\n            max = node.val;\\n        }\\n        node.left && stck.push([node.left, max]);\\n        node.right && stck.push([node.right, max]);\\n    }\\n    return res;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Time O(N)\\n * Space O(height)\\n */\\n \\n var goodNodes = function(root, max = -Infinity) {   \\n    if(root == null) return 0;\\n    let res = 0;\\n\\n    if(root.val >= max){\\n        res++;\\n        max = root.val;\\n    }\\n\\n    res += goodNodes(root.left, max);\\n    res += goodNodes(root.right, max);\\n\\n    return res;\\n}\\n\\nvar goodNodes = function(root) {\\n    \\n    let stck = [], res = 0;\\n    stck.push([root, root.val])\\n\\n    while(stck.length > 0){\\n        let curr = stck.pop();\\n        let [node, max] = [curr[0], curr[1]];\\n\\n        if(node.val >= max){\\n            res++;\\n            max = node.val;\\n        }\\n        node.left && stck.push([node.left, max]);\\n        node.right && stck.push([node.right, max]);\\n    }\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1409209,
                "title": "kotlin-short-clean-recursive-dfs-solution",
                "content": "```\\nimport kotlin.math.max\\n\\nclass Solution {\\n    fun goodNodes(root: TreeNode?, max: Int = Int.MIN_VALUE): Int {\\n        root ?: return 0\\n        var res = if (root.`val` >= max) 1 else 0\\n        res += goodNodes(root.left, max(root.`val`, max))\\n        res += goodNodes(root.right, max(root.`val`, max))\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search"
                ],
                "code": "```\\nimport kotlin.math.max\\n\\nclass Solution {\\n    fun goodNodes(root: TreeNode?, max: Int = Int.MIN_VALUE): Int {\\n        root ?: return 0\\n        var res = if (root.`val` >= max) 1 else 0\\n        res += goodNodes(root.left, max(root.`val`, max))\\n        res += goodNodes(root.right, max(root.`val`, max))\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409186,
                "title": "easy-c-recursive-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void helper(TreeNode* root, int maxi){\\n        if(root==NULL)return;\\n        if(root->val >= maxi) res+=1;\\n        helper(root->left,max(maxi,root->val));\\n        helper(root->right,max(maxi,root->val));\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        helper(root,root->val);\\n        return res;\\n    }\\n};\\n```\\n**Questions/ Discussions are welcome.**",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void helper(TreeNode* root, int maxi){\\n        if(root==NULL)return;\\n        if(root->val >= maxi) res+=1;\\n        helper(root->left,max(maxi,root->val));\\n        helper(root->right,max(maxi,root->val));\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        helper(root,root->val);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409062,
                "title": "python-simple-solution-dfs-preorder-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def dfs(node,maxi,count):            \\n            if(node==None):\\n                return count            \\n            if(node.val>=maxi):\\n                maxi=node.val\\n                count+=1\\n            count=dfs(node.left,maxi,count)\\n            count=dfs(node.right,maxi,count)\\n            return count\\n        return dfs(root,-math.inf,0)\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def dfs(node,maxi,count):            \\n            if(node==None):\\n                return count            \\n            if(node.val>=maxi):\\n                maxi=node.val\\n                count+=1\\n            count=dfs(node.left,maxi,count)\\n            count=dfs(node.right,maxi,count)\\n            return count\\n        return dfs(root,-math.inf,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408898,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int s=0;\\n    int goodNodes(TreeNode* root, int m=INT_MIN) {\\n        if (root == NULL) {\\n            return s;\\n        }\\n        if (root->val >= m) {\\n            s++;\\n            m = root->val;\\n        }\\n        if (root->left) {\\n            goodNodes(root->left, m);\\n        }\\n        if (root->right) {\\n            goodNodes(root->right, m);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int s=0;\\n    int goodNodes(TreeNode* root, int m=INT_MIN) {\\n        if (root == NULL) {\\n            return s;\\n        }\\n        if (root->val >= m) {\\n            s++;\\n            m = root->val;\\n        }\\n        if (root->left) {\\n            goodNodes(root->left, m);\\n        }\\n        if (root->right) {\\n            goodNodes(root->right, m);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408602,
                "title": "python-a-simple-clean-recursive-solution-explained",
                "content": "***LOGIC***\\n- We want to check the current element, `node.val` with the greatest element in the path uptill now, we call it `_max`.  \\n- If `_max <= node.val`, then we can add `+1` to our score. Else, we won\\'t add anything.\\n- Either case, we take care to send the updated `_max` to the next recursion calls.\\n\\n***CODE***\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        \\n        def recurse(node, _max):\\n            if not node: return 0\\n            \\n            curr = 1 if _max <= node.val else 0\\n            left = recurse(node.left, max(_max, node.val))\\n            right = recurse(node.right, max(_max, node.val))\\n            \\n            return curr+left+right\\n\\n        return recurse(root, root.val)\\n```\\n\\n***COMPLEXITY ANALYSIS***\\n- Time: We go over all the nodes once: `O(N)`\\n- Space: We have to consider the maximum height of the tree, which can **also** be `O(N)` in the case of a degenrate binary tree.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        \\n        def recurse(node, _max):\\n            if not node: return 0\\n            \\n            curr = 1 if _max <= node.val else 0\\n            left = recurse(node.left, max(_max, node.val))\\n            right = recurse(node.right, max(_max, node.val))\\n            \\n            return curr+left+right\\n\\n        return recurse(root, root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113008,
                "title": "python3-iterative-dfs",
                "content": "\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        ans = 0 \\n        stack = [(root, -inf)]\\n        while stack: \\n            node, val = stack.pop()\\n            if node: \\n                if node.val >= val: ans += 1\\n                val = max(val, node.val)\\n                stack.append((node.left, val))\\n                stack.append((node.right, val))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        ans = 0 \\n        stack = [(root, -inf)]\\n        while stack: \\n            node, val = stack.pop()\\n            if node: \\n                if node.val >= val: ans += 1\\n                val = max(val, node.val)\\n                stack.append((node.left, val))\\n                stack.append((node.right, val))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028363,
                "title": "python-100-very-easy-recursion-w-comments",
                "content": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode, mx=float(\\'-inf\\')) -> int:\\n        # base case\\n        if not root: return 0\\n\\n        # compare current value with current max in path\\n        if root.val >= mx:\\n            # add 1 (good node) + sum of good nodes in left and right\\n            # also change new max to this node\\n            return 1 + self.goodNodes(root.left, root.val) + self.goodNodes(\\n                root.right, root.val)\\n        else:\\n            # this is bad node, but keep looking for good nodes\\n            return self.goodNodes(root.left, mx) + self.goodNodes(\\n                root.right, mx)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode, mx=float(\\'-inf\\')) -> int:\\n        # base case\\n        if not root: return 0\\n\\n        # compare current value with current max in path\\n        if root.val >= mx:\\n            # add 1 (good node) + sum of good nodes in left and right\\n            # also change new max to this node\\n            return 1 + self.goodNodes(root.left, root.val) + self.goodNodes(\\n                root.right, root.val)\\n        else:\\n            # this is bad node, but keep looking for good nodes\\n            return self.goodNodes(root.left, mx) + self.goodNodes(\\n                root.right, mx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923613,
                "title": "c-c-simple-clean-and-short-recursive-solution",
                "content": "**C:**\\n```\\nint rec(struct TreeNode* root, int max) {\\n    if (!root)\\n        return 0;\\n    max = root->val > max ? root->val : max;\\n    if (root->val >= max)\\n        return 1+rec(root->right, max) + rec(root->left, max);\\n    else\\n        return rec(root->right, max) + rec(root->left, max);\\n}\\n\\nint goodNodes(struct TreeNode* root){\\n    if (!root) return 0;\\n    return rec(root, root->val);\\n}\\n```\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int rec(struct TreeNode* root, int max_val) {\\n        if (!root)\\n            return 0;\\n        max_val = max(max_val, root->val);\\n        if (root->val >= max_val)\\n            return 1 + rec(root->right, max_val) + rec(root->left, max_val);\\n        else\\n            return rec(root->right, max_val) + rec(root->left, max_val);\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        if (!root) return 0;\\n        return rec(root, root->val);\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rec(struct TreeNode* root, int max) {\\n    if (!root)\\n        return 0;\\n    max = root->val > max ? root->val : max;\\n    if (root->val >= max)\\n        return 1+rec(root->right, max) + rec(root->left, max);\\n    else\\n        return rec(root->right, max) + rec(root->left, max);\\n}\\n\\nint goodNodes(struct TreeNode* root){\\n    if (!root) return 0;\\n    return rec(root, root->val);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int rec(struct TreeNode* root, int max_val) {\\n        if (!root)\\n            return 0;\\n        max_val = max(max_val, root->val);\\n        if (root->val >= max_val)\\n            return 1 + rec(root->right, max_val) + rec(root->left, max_val);\\n        else\\n            return rec(root->right, max_val) + rec(root->left, max_val);\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        if (!root) return 0;\\n        return rec(root, root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741118,
                "title": "easy-c-dfs-solution-o-n-time",
                "content": "The global variable count can be avoided by passing it as a paramter in the dfs function.\\n\\nPlease upvote if you find this helpful, it would be encouraging!. \\nThanks :)\\n\\n```\\n\\tint count = 0;\\n    void dfs(TreeNode* root, int maxSoFar) {\\n        if(root) {\\n            if(root->val >= maxSoFar) {\\n                count++;              \\n                maxSoFar = root->val;\\n            }\\n            dfs(root->left, maxSoFar);\\n            dfs(root->right, maxSoFar);\\n        }\\n    }\\n    int goodNodes(TreeNode* root) {\\n        dfs(root, INT_MIN);\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "The global variable count can be avoided by passing it as a paramter in the dfs function.\\n\\nPlease upvote if you find this helpful, it would be encouraging!. \\nThanks :)\\n\\n```\\n\\tint count = 0;\\n    void dfs(TreeNode* root, int maxSoFar) {\\n        if(root) {\\n            if(root->val >= maxSoFar) {\\n                count++;              \\n                maxSoFar = root->val;\\n            }\\n            dfs(root->left, maxSoFar);\\n            dfs(root->right, maxSoFar);\\n        }\\n    }\\n    int goodNodes(TreeNode* root) {\\n        dfs(root, INT_MIN);\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 671529,
                "title": "python3-simple-tree-traversal",
                "content": "```\\nclass Solution:\\n    \\n    def get_result(self,root,maxi):\\n        if root==None:\\n            return\\n        if root.val>=maxi:\\n            self.result+=1\\n            maxi = root.val\\n        self.get_result(root.left,maxi)\\n        self.get_result(root.right,maxi)\\n            \\n    \\n    def goodNodes(self, root: TreeNode) -> int:\\n        self.result = 0\\n        self.get_result(root,root.val)\\n        return self.result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def get_result(self,root,maxi):\\n        if root==None:\\n            return\\n        if root.val>=maxi:\\n            self.result+=1\\n            maxi = root.val\\n        self.get_result(root.left,maxi)\\n        self.get_result(root.right,maxi)\\n            \\n    \\n    def goodNodes(self, root: TreeNode) -> int:\\n        self.result = 0\\n        self.get_result(root,root.val)\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670971,
                "title": "javascript-beats-98-dfs-solution",
                "content": "```\\nvar goodNodes = function(root) {\\n    let res = 0;\\n    const dfs = (node, preMax) => {\\n        if(!node) return;\\n        if(node.val >= preMax) res++;\\n        dfs(node.left, Math.max(node.val, preMax));\\n        dfs(node.right, Math.max(node.val, preMax));\\n    }\\n    dfs(root, -Infinity);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar goodNodes = function(root) {\\n    let res = 0;\\n    const dfs = (node, preMax) => {\\n        if(!node) return;\\n        if(node.val >= preMax) res++;\\n        dfs(node.left, Math.max(node.val, preMax));\\n        dfs(node.right, Math.max(node.val, preMax));\\n    }\\n    dfs(root, -Infinity);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 646488,
                "title": "go-golang-dfs-solution",
                "content": ">Runtime: 108 ms, faster than 94.67% of Go online submissions for Count Good Nodes in Binary Tree.\\nMemory Usage: 14.5 MB, less than 100.00% of Go online submissions for Count Good Nodes in Binary Tree.\\n\\n```go\\nfunc goodNodes(root *TreeNode) int {\\n    return dfs(root, root.Val)\\n}\\n\\nfunc dfs(node *TreeNode, v int) int {\\n    if node == nil { return 0 }\\n    curMax := max(node.Val, v)\\n    if node.Val >= v { return 1 + dfs(node.Left, curMax) + dfs(node.Right, curMax) }\\n    return dfs(node.Left, curMax) + dfs(node.Right, curMax)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc goodNodes(root *TreeNode) int {\\n    return dfs(root, root.Val)\\n}\\n\\nfunc dfs(node *TreeNode, v int) int {\\n    if node == nil { return 0 }\\n    curMax := max(node.Val, v)\\n    if node.Val >= v { return 1 + dfs(node.Left, curMax) + dfs(node.Right, curMax) }\\n    return dfs(node.Left, curMax) + dfs(node.Right, curMax)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 635374,
                "title": "intuitive-and-easy-c-sol-with-comments-100-time-and-space-efficient",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    //simply check for each node that if its value is >= the max value encountered till now(stored by max_till_now)\\n    //we need to keep on updating max_till_now with each time we call the function solve\\n    \\n    void solve(TreeNode *root, int &count, int max_till_now){\\n        if(root==NULL)\\n            return;\\n        if(root->val>=max_till_now){\\n            count++;\\n        }\\n        solve(root->left,count,max(max_till_now,root->val));\\n        solve(root->right,count,max(max_till_now,root->val));   \\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        //count will store the final answer which we will return \\n        int count = 0;\\n        solve(root,count,root->val);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    //simply check for each node that if its value is >= the max value encountered till now(stored by max_till_now)\\n    //we need to keep on updating max_till_now with each time we call the function solve\\n    \\n    void solve(TreeNode *root, int &count, int max_till_now){\\n        if(root==NULL)\\n            return;\\n        if(root->val>=max_till_now){\\n            count++;\\n        }\\n        solve(root->left,count,max(max_till_now,root->val));\\n        solve(root->right,count,max(max_till_now,root->val));   \\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        //count will store the final answer which we will return \\n        int count = 0;\\n        solve(root,count,root->val);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096226,
                "title": "dfs-solution-beats-99-of-c-users",
                "content": "![image.png](https://assets.leetcode.com/users/images/a332ad10-28af-49a1-976b-633c11324d1d_1695815248.3699067.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* All we want to do is to keep tracking of the maximum element in the branch till the current node, and if the current node value was greater than or equal to that max then we should increment our counter by 1. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## count (root, mx, &cnt)\\n### return type and parameters \\n1. it is a recursive function. \\n2. it returns nothing (**void**)\\n3. root is a pointer for the current node. \\n4. mx is the maximum value for the current branch, and it is passed by value, because we change it almost after each call. \\n5. cnt is counter for all good node, and it is passed by reference. \\n### base cases \\n* we have mainly two base cases.\\n    1. if we have empty tree, so we just need to return from the function, and we will return 0 from the main function. \\n    2. if we have reached a leaf.\\n        * at this point we just need to check if the leaf value was less than send mx, if yes then we will just return, otherwise we will increment counter by 1 then return. \\n### recursive cases. \\n* we just need to iterate over left subtree for each node, then traverse over the right one. \\n```\\n    count(root->left, max(mx, root->val), cnt);  // left subtree\\n    count(root->right, max(mx, root->val), cnt); // right subtree\\n```  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    * O(n) as we iterate over each node only once.  \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    * I do not use any extra space.  \\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    #define DPSolver                      \\\\\\n    ios_base::sync_with_stdio(false); \\\\\\n    cin.tie(NULL);                    \\\\\\n    cout.tie(NULL)\\n\\nvoid count(TreeNode *root, int mx, int &cnt)\\n{\\n    if (!root) // empty tree \\n        return;\\n    if (root->val >= mx)\\n        cnt++;\\n    if (!root->left && !root->right) // leaf node. \\n        return; \\n    count(root->left, max(mx, root->val), cnt);  // left subtree\\n    count(root->right, max(mx, root->val), cnt); // right subtree\\n}\\n\\nint goodNodes(TreeNode *root)\\n{\\n    DPSolver; \\n    int cnt = 0;\\n    count(root, root->val, cnt);\\n    return cnt;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n    count(root->left, max(mx, root->val), cnt);  // left subtree\\n    count(root->right, max(mx, root->val), cnt); // right subtree\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    #define DPSolver                      \\\\\\n    ios_base::sync_with_stdio(false); \\\\\\n    cin.tie(NULL);                    \\\\\\n    cout.tie(NULL)\\n\\nvoid count(TreeNode *root, int mx, int &cnt)\\n{\\n    if (!root) // empty tree \\n        return;\\n    if (root->val >= mx)\\n        cnt++;\\n    if (!root->left && !root->right) // leaf node. \\n        return; \\n    count(root->left, max(mx, root->val), cnt);  // left subtree\\n    count(root->right, max(mx, root->val), cnt); // right subtree\\n}\\n\\nint goodNodes(TreeNode *root)\\n{\\n    DPSolver; \\n    int cnt = 0;\\n    count(root, root->val, cnt);\\n    return cnt;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4067028,
                "title": "go-solution-easy-explanation-dfs-o-n-time-o-h-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to count the number of \"good nodes\" in a binary tree. A good node is defined as a node whose value is greater than or equal to the maximum value encountered on the path from the root to that node. We can use a depth-first search (DFS) approach to traverse the tree and keep track of the maximum value while counting good nodes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a helper function dfs that takes a node and the maximum value encountered so far as parameters.\\n\\n2. Inside the dfs function:\\n\\n  - If the current node is nil, return without processing (base case).\\n  - If the current node\\'s value is greater than or equal to the maximum value encountered so far (max), update max and increment the count to indicate a good node.\\n  - Recursively call dfs on the left and right subtrees with the updated max value.\\n3. Start the DFS traversal from the root node with its value as the initial maximum value.\\n\\n4. After the traversal is complete, return the total count of good nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N), where N is the number of nodes in the binary tree. We visit each node once during the DFS traversal.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(H), where H is the height of the binary tree. This is the space required for the recursive call stack, and in the worst case (for a skewed tree), it can be O(N).\\n\\n# Code\\n```\\nfunc goodNodes(root *TreeNode) int {\\n    var count int // Initialize a variable to count good nodes.\\n\\n    // Define a helper function for the recursive traversal.\\n    var dfs func(node *TreeNode, max int)\\n\\n    // The dfs function performs a depth-first search traversal of the binary tree.\\n    dfs = func(node *TreeNode, max int) {\\n        if node == nil {\\n            return // Base case: If the node is nil, return without processing.\\n        }\\n\\n        if node.Val >= max {\\n            max = node.Val   // Update the maximum value encountered so far.\\n            count++          // Increment the count to indicate a good node.\\n        }\\n\\n        // Recursively traverse the left and right subtrees with the updated max value.\\n        dfs(node.Left, max)\\n        dfs(node.Right, max)\\n    }\\n\\n    dfs(root, root.Val) // Start the traversal with the root node and its value.\\n\\n    return count // Return the total count of good nodes in the binary tree.\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc goodNodes(root *TreeNode) int {\\n    var count int // Initialize a variable to count good nodes.\\n\\n    // Define a helper function for the recursive traversal.\\n    var dfs func(node *TreeNode, max int)\\n\\n    // The dfs function performs a depth-first search traversal of the binary tree.\\n    dfs = func(node *TreeNode, max int) {\\n        if node == nil {\\n            return // Base case: If the node is nil, return without processing.\\n        }\\n\\n        if node.Val >= max {\\n            max = node.Val   // Update the maximum value encountered so far.\\n            count++          // Increment the count to indicate a good node.\\n        }\\n\\n        // Recursively traverse the left and right subtrees with the updated max value.\\n        dfs(node.Left, max)\\n        dfs(node.Right, max)\\n    }\\n\\n    dfs(root, root.Val) // Start the traversal with the root node and its value.\\n\\n    return count // Return the total count of good nodes in the binary tree.\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996583,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitialise a prev variable which is the previous maximum value and if the current node\\'s value is greater than the previous maximum value it means that we have a GOOD path hence we increment a count variable and recursively call for the left and right subtree\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Solution based on the intuition stated above\\n# Complexity\\n- Time complexity:\\n<!--O(n) Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(n)\\n\\n- Space complexity:\\n<!-- O(h)Add your space complexity here, e.g. $$O(n)$$ -->\\nO(h)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, int &count, int prev) {\\n        if (root == NULL) {\\n            return count;\\n        }\\n        \\n        if (root->val >= prev) {\\n            count++;\\n        }\\n        \\n        // Update prev based on the current node\\'s value\\n        prev = max(prev, root->val);\\n        \\n        solve(root->left, count, prev);\\n        solve(root->right, count, prev);\\n        \\n        return count;\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        int count = 0, prev = root->val; // Initialize prev with the root\\'s value.\\n        return solve(root, count, prev);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, int &count, int prev) {\\n        if (root == NULL) {\\n            return count;\\n        }\\n        \\n        if (root->val >= prev) {\\n            count++;\\n        }\\n        \\n        // Update prev based on the current node\\'s value\\n        prev = max(prev, root->val);\\n        \\n        solve(root->left, count, prev);\\n        solve(root->right, count, prev);\\n        \\n        return count;\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        int count = 0, prev = root->val; // Initialize prev with the root\\'s value.\\n        return solve(root, count, prev);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982299,
                "title": "easy-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to keep track of the max value while going through a path and count the number of nodes greater than the current max value. if the node is greater than the max value of the path then it will be greater than all of the other values of the path.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse preorder traversal. if the nodes value is greater than maxi then its a good node. update the maxi to node value.  \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(h) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(TreeNode* root, int maxi){\\n        if(!root) return;\\n\\n        if(root->val >= maxi) {\\n            ans++;\\n            maxi = root->val;\\n        }\\n        \\n        solve(root->left,maxi);\\n        solve(root->right,maxi);\\n    }\\n\\n\\n    int goodNodes(TreeNode* root) {\\n        solve(root,INT_MIN);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(TreeNode* root, int maxi){\\n        if(!root) return;\\n\\n        if(root->val >= maxi) {\\n            ans++;\\n            maxi = root->val;\\n        }\\n        \\n        solve(root->left,maxi);\\n        solve(root->right,maxi);\\n    }\\n\\n\\n    int goodNodes(TreeNode* root) {\\n        solve(root,INT_MIN);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829736,
                "title": "java-preorder-traversal-beats-100-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    \\n    public void countGoodNodes(TreeNode root, int maximum) {\\n            if(root!=null) {\\n                if (maximum <= root.val) {\\n                    maximum = root.val;\\n                    count++;\\n                }\\n            countGoodNodes(root.left,maximum);\\n            countGoodNodes(root.right, maximum);\\n        } \\n    }\\n\\n    public int goodNodes(TreeNode root) {\\n        int maximum = root.val;\\n        countGoodNodes(root,  maximum);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    \\n    public void countGoodNodes(TreeNode root, int maximum) {\\n            if(root!=null) {\\n                if (maximum <= root.val) {\\n                    maximum = root.val;\\n                    count++;\\n                }\\n            countGoodNodes(root.left,maximum);\\n            countGoodNodes(root.right, maximum);\\n        } \\n    }\\n\\n    public int goodNodes(TreeNode root) {\\n        int maximum = root.val;\\n        countGoodNodes(root,  maximum);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795904,
                "title": "easy-and-neat-solution-using-recursion-with-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count=0;\\n    void ans(TreeNode* temp,int mx){\\n        if(temp==NULL)\\n        return;\\n\\n        if(temp->val>=mx)\\n        count++;\\n\\n        ans(temp->left,max(temp->val,mx));\\n        ans(temp->right,max(temp->val,mx));\\n    }\\n    int goodNodes(TreeNode* root) {\\n  \\n        ans(root,root->val);\\n        return count;\\n    }\\n};\\n/*UPVOTE IF THE SOLUTION IS HELPFUL FOR YOU/*\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count=0;\\n    void ans(TreeNode* temp,int mx){\\n        if(temp==NULL)\\n        return;\\n\\n        if(temp->val>=mx)\\n        count++;\\n\\n        ans(temp->left,max(temp->val,mx));\\n        ans(temp->right,max(temp->val,mx));\\n    }\\n    int goodNodes(TreeNode* root) {\\n  \\n        ans(root,root->val);\\n        return count;\\n    }\\n};\\n/*UPVOTE IF THE SOLUTION IS HELPFUL FOR YOU/*\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749115,
                "title": "easy-java-solution-recursion",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public void func(int max, TreeNode root){\\n        if(root==null) return;\\n        if(root.val>=max){\\n            max = root.val;\\n            count++;\\n        }\\n        func(max,root.left);\\n        func(max,root.right);\\n    }\\n    public int goodNodes(TreeNode root) {\\n        if(root==null) return 0;\\n        int max = Integer.MIN_VALUE;\\n        func(max,root);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public void func(int max, TreeNode root){\\n        if(root==null) return;\\n        if(root.val>=max){\\n            max = root.val;\\n            count++;\\n        }\\n        func(max,root.left);\\n        func(max,root.right);\\n    }\\n    public int goodNodes(TreeNode root) {\\n        if(root==null) return 0;\\n        int max = Integer.MIN_VALUE;\\n        func(max,root);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686067,
                "title": "easy-dfs-beats-100-no-mess",
                "content": "every time we visit a node we check if it is the biggest node in the path or not\\n\\nif it is we update the max as the currentNode.val\\n\\nnow we check if the currentNode value is greater or equal to the max\\nif it is , we increment the ans;\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return util1(root);\\n    }\\n    int ans = 0;\\n\\n    public int util1(TreeNode root) {\\n        dfs(root, Integer.MIN_VALUE);\\n        return ans;\\n    }\\n\\n    public void dfs(TreeNode root, int maxNode) {\\n        if (root == null) {\\n            return;\\n        }\\n        maxNode = Math.max(maxNode, root.val);\\n        if (root.val >= maxNode) {\\n            ans++;\\n        }\\n        dfs(root.left, maxNode);\\n        dfs(root.right, maxNode);\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        return util1(root);\\n    }\\n    int ans = 0;\\n\\n    public int util1(TreeNode root) {\\n        dfs(root, Integer.MIN_VALUE);\\n        return ans;\\n    }\\n\\n    public void dfs(TreeNode root, int maxNode) {\\n        if (root == null) {\\n            return;\\n        }\\n        maxNode = Math.max(maxNode, root.val);\\n        if (root.val >= maxNode) {\\n            ans++;\\n        }\\n        dfs(root.left, maxNode);\\n        dfs(root.right, maxNode);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578523,
                "title": "easy-dfs-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, height of the tree\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        //Approach: Using DFS \\n        return dfs(root, -99999); //Each node\\'s value is between [-10^4, 10^4].\\n    }\\n    public int dfs(TreeNode root, int maxVal){\\n        //base case\\n        if(root==null) return 0;\\n        //find the result\\n        int res = root.val>=maxVal ? 1 : 0;\\n\\n        //call recursion for left and right subtree\\n        res += dfs(root.left, Math.max(root.val, maxVal));\\n        res += dfs(root.right, Math.max(root.val, maxVal));\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        //Approach: Using DFS \\n        return dfs(root, -99999); //Each node\\'s value is between [-10^4, 10^4].\\n    }\\n    public int dfs(TreeNode root, int maxVal){\\n        //base case\\n        if(root==null) return 0;\\n        //find the result\\n        int res = root.val>=maxVal ? 1 : 0;\\n\\n        //call recursion for left and right subtree\\n        res += dfs(root.left, Math.max(root.val, maxVal));\\n        res += dfs(root.right, Math.max(root.val, maxVal));\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546127,
                "title": "python3-mega-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        ans = 0\\n\\n        def traversal(node, maxi):\\n            if node is None: return\\n\\n            if node.val >= maxi:\\n                nonlocal ans\\n                maxi = node.val\\n                ans += 1\\n            traversal(node.left, maxi)\\n            traversal(node.right, maxi)\\n\\n        traversal(root, root.val)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        ans = 0\\n\\n        def traversal(node, maxi):\\n            if node is None: return\\n\\n            if node.val >= maxi:\\n                nonlocal ans\\n                maxi = node.val\\n                ans += 1\\n            traversal(node.left, maxi)\\n            traversal(node.right, maxi)\\n\\n        traversal(root, root.val)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308907,
                "title": "c-dfs-one-liner",
                "content": "Perform a DFS, passing the current maximum value of the current path of nodes. At each node,\\n\\nBase case : if node is NULL, return 0\\n1.if node\\'s value is the greatest in the path from root to X, return \\n`dfs(node->left)+dfs(node->right)+1`\\n2.else return `dfs(node->left)+dfs(node->right)`\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root,int maxVal=INT_MIN) {\\n        if(!root) return 0;\\n        int val=root->val,res=0;\\n        if(val>=maxVal) return goodNodes(root->left,val)+goodNodes(root->right,val)+1;\\n        return goodNodes(root->left,maxVal)+goodNodes(root->right,maxVal);\\n    }\\n};\\n\\n```\\n\\n## One Liner\\n```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root,int maxVal=INT_MIN) {\\n        return root?(goodNodes(root->left,max(root->val,maxVal))+goodNodes(root->right,max(root->val,maxVal))+(root->val>=maxVal)):0;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ (Recursion Stack Space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root,int maxVal=INT_MIN) {\\n        if(!root) return 0;\\n        int val=root->val,res=0;\\n        if(val>=maxVal) return goodNodes(root->left,val)+goodNodes(root->right,val)+1;\\n        return goodNodes(root->left,maxVal)+goodNodes(root->right,maxVal);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root,int maxVal=INT_MIN) {\\n        return root?(goodNodes(root->left,max(root->val,maxVal))+goodNodes(root->right,max(root->val,maxVal))+(root->val>=maxVal)):0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224861,
                "title": "c-easy-recursion-beats-96-time-92-space",
                "content": "```\\nclass Solution {\\npublic:\\n  void dfs(TreeNode* root, int& count, int maxUpToNow) {\\n    if(root == nullptr) return;\\n    if(root->val >= maxUpToNow) {\\n      count++;\\n      maxUpToNow = root->val;\\n    }\\n    dfs(root->left, count, maxUpToNow);\\n    dfs(root->right, count, maxUpToNow);\\n  }\\n\\n  int goodNodes(TreeNode* root) {\\n    int maxUpToNow = root->val;\\n    int count = 0;\\n    dfs(root, count, maxUpToNow);\\n    return count;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void dfs(TreeNode* root, int& count, int maxUpToNow) {\\n    if(root == nullptr) return;\\n    if(root->val >= maxUpToNow) {\\n      count++;\\n      maxUpToNow = root->val;\\n    }\\n    dfs(root->left, count, maxUpToNow);\\n    dfs(root->right, count, maxUpToNow);\\n  }\\n\\n  int goodNodes(TreeNode* root) {\\n    int maxUpToNow = root->val;\\n    int count = 0;\\n    dfs(root, count, maxUpToNow);\\n    return count;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102302,
                "title": "faster-than-100-python-solution",
                "content": "If you like my solution please upvote:)\\n![image](https://assets.leetcode.com/users/images/2977ddb6-9704-4000-9deb-3e70c4d76ce2_1674748763.2620363.jpeg)\\n\\n```\\nclass Solution(object):\\n    def goodNodes(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(curr, greatest):\\n            res, l, r = 0, 0, 0\\n            if curr.val>=greatest:\\n                res += 1\\n                greatest = curr.val\\n            if curr.right: r = dfs(curr.right, greatest)\\n            if curr.left: l = dfs(curr.left, greatest)\\n            return res + l + r\\n        return dfs(root, root.val)\\n    #O(n) n=number of nodes\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def goodNodes(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(curr, greatest):\\n            res, l, r = 0, 0, 0\\n            if curr.val>=greatest:\\n                res += 1\\n                greatest = curr.val\\n            if curr.right: r = dfs(curr.right, greatest)\\n            if curr.left: l = dfs(curr.left, greatest)\\n            return res + l + r\\n        return dfs(root, root.val)\\n    #O(n) n=number of nodes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068174,
                "title": "simple-dfs-o-n-time-easy-understanding",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    int countNodes(TreeNode*root,int prev){\\n        if(!root)return 0;\\n        if(prev<=root->val){\\n            cnt++;\\n        }\\n        countNodes(root->left,max(prev,root->val));\\n        countNodes(root->right,max(prev,root->val));\\n        return cnt;\\n\\n    }\\n    int goodNodes(TreeNode* root) {\\n        return countNodes(root,INT_MIN);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    int countNodes(TreeNode*root,int prev){\\n        if(!root)return 0;\\n        if(prev<=root->val){\\n            cnt++;\\n        }\\n        countNodes(root->left,max(prev,root->val));\\n        countNodes(root->right,max(prev,root->val));\\n        return cnt;\\n\\n    }\\n    int goodNodes(TreeNode* root) {\\n        return countNodes(root,INT_MIN);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014994,
                "title": "my-simple-c-recursive-solution-faster-than-89-may-god-bless-you-and-your-family",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The approach is pretty straightforward--> Traverse through the tree whilst maintaining a parent node and a max variable.\\n2. Check whether the value of root is greater than parent as well as the max variable(as the question asks us to find out all the nodes within each path, which are greater than or equal to the greatest node anywhere before, in that path).\\n3. So if a node is greater than its parent and also max, it would imply that in the path UPTO THAT NODE, this node is greater than all the other preceding ones and hence is a GOOD NODE.\\n4. Increment the ans variable which has been created globally\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    void update(TreeNode* root, TreeNode* parent, int max){\\n        if(!root)\\n        return;\\n\\n        if(root->val>=parent->val && root->val>=max){\\n            ans++;\\n            max=root->val;\\n        }\\n\\n        update(root->left, root, max);\\n        update(root->right, root, max);\\n\\n        return;\\n    }\\n\\n    int goodNodes(TreeNode* root) {\\n        if(!root->left && !root->right)\\n        return 1;\\n\\n        update(root, root, root->val);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    void update(TreeNode* root, TreeNode* parent, int max){\\n        if(!root)\\n        return;\\n\\n        if(root->val>=parent->val && root->val>=max){\\n            ans++;\\n            max=root->val;\\n        }\\n\\n        update(root->left, root, max);\\n        update(root->right, root, max);\\n\\n        return;\\n    }\\n\\n    int goodNodes(TreeNode* root) {\\n        if(!root->left && !root->right)\\n        return 1;\\n\\n        update(root, root, root->val);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990121,
                "title": "java-solution-time-complexity-o-n-space-complexity-o-h-h-is-tree-height",
                "content": "# Intuition\\n    Please refer the comment in the code section\\n\\n# Approach\\n    Please refer the comment in the code section\\n\\n# Complexity\\n- Time complexity:\\n    - O(n)\\n\\n- Space complexity:\\n    - O(h), h is tree height\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    /** \\n        This problem has been asked in below companies:\\n        Microsoft\\n        Amazon\\n        Google\\n        Salesforce\\n        Bloomberg\\n        Facebook\\n        DRW\\n    */\\n\\n    /** \\n        The idea is to do DFS, in each call check the max of current node val and max value till now is less than or equal to current node val\\n        if yes, increse the good nodes number and send the max of current node and max value till now in left and right side.\\n\\n        Time complexity: O(n)\\n        Space complexity: O(h), h is tree height, considering the recursion stack.\\n    */\\n\\n\\n    private int goodNodes;\\n\\n    public int goodNodes(TreeNode root) {\\n        goodNodes = 0;\\n\\n        goodNodes(root, root.val);\\n\\n        return goodNodes;\\n    }\\n\\n    public void goodNodes(TreeNode root, int max) {\\n        if(root == null) return;\\n\\n        // find the max of current node value and max till now\\n        max = Math.max(max, root.val);\\n        // check the max is less than or equal to current node value\\n        // if yes, increse the good nodes number\\n        if(max <= root.val) goodNodes++;\\n\\n        // send the max to the left and right\\n        goodNodes(root.left, max);\\n        goodNodes(root.right, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    /** \\n        This problem has been asked in below companies:\\n        Microsoft\\n        Amazon\\n        Google\\n        Salesforce\\n        Bloomberg\\n        Facebook\\n        DRW\\n    */\\n\\n    /** \\n        The idea is to do DFS, in each call check the max of current node val and max value till now is less than or equal to current node val\\n        if yes, increse the good nodes number and send the max of current node and max value till now in left and right side.\\n\\n        Time complexity: O(n)\\n        Space complexity: O(h), h is tree height, considering the recursion stack.\\n    */\\n\\n\\n    private int goodNodes;\\n\\n    public int goodNodes(TreeNode root) {\\n        goodNodes = 0;\\n\\n        goodNodes(root, root.val);\\n\\n        return goodNodes;\\n    }\\n\\n    public void goodNodes(TreeNode root, int max) {\\n        if(root == null) return;\\n\\n        // find the max of current node value and max till now\\n        max = Math.max(max, root.val);\\n        // check the max is less than or equal to current node value\\n        // if yes, increse the good nodes number\\n        if(max <= root.val) goodNodes++;\\n\\n        // send the max to the left and right\\n        goodNodes(root.left, max);\\n        goodNodes(root.right, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982195,
                "title": "c-most-frequent-in-microsoft",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n\\n        int result = 0;\\n        dfs(root, root->val, result);\\n        return result;\\n        \\n    }\\n\\n    void dfs(TreeNode* root, int Maxvalue, int &result)\\n    {\\n        if(root==NULL) return;\\n\\n        if(root->val>=Maxvalue) result++;\\n\\n        dfs(root->left, max(Maxvalue, root->val), result);\\n        dfs(root->right, max(Maxvalue, root->val), result);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n\\n        int result = 0;\\n        dfs(root, root->val, result);\\n        return result;\\n        \\n    }\\n\\n    void dfs(TreeNode* root, int Maxvalue, int &result)\\n    {\\n        if(root==NULL) return;\\n\\n        if(root->val>=Maxvalue) result++;\\n\\n        dfs(root->left, max(Maxvalue, root->val), result);\\n        dfs(root->right, max(Maxvalue, root->val), result);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981788,
                "title": "python3-iterative-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse stack to track the nodes and current maximum value to make decision if it is a \"good\" node\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAssociate the current maximum value with each node on the stack. If previous node has value greater then maximim seen so far, update it and store for each child node. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) each node is only visited once, and at each node, O(1) work is done.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n\\n        if not root:\\n            return 0 \\n        \\n        count = 0\\n\\n        stack = [(root, float(\"-inf\"))]\\n        while stack:\\n            node, max_val = stack.pop()\\n            if node.val >= max_val:\\n                max_val = node.val\\n                count +=1\\n\\n            if node.right:             \\n                stack.append((node.right, max_val))\\n\\n            if node.left:\\n                stack.append((node.left, max_val))           \\n\\n        return count\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n\\n        if not root:\\n            return 0 \\n        \\n        count = 0\\n\\n        stack = [(root, float(\"-inf\"))]\\n        while stack:\\n            node, max_val = stack.pop()\\n            if node.val >= max_val:\\n                max_val = node.val\\n                count +=1\\n\\n            if node.right:             \\n                stack.append((node.right, max_val))\\n\\n            if node.left:\\n                stack.append((node.left, max_val))           \\n\\n        return count\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931897,
                "title": "beats-95-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def count_good_nodes(root,max_):\\n            if not root:\\n                return 0\\n            count = 1 if root.val>=max_ else 0\\n            max_ = max(max_,root.val)\\n            return count + count_good_nodes(root.left,max_) + count_good_nodes(root.right,max_)\\n        return count_good_nodes(root,-float(\\'inf\\'))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        def count_good_nodes(root,max_):\\n            if not root:\\n                return 0\\n            count = 1 if root.val>=max_ else 0\\n            max_ = max(max_,root.val)\\n            return count + count_good_nodes(root.left,max_) + count_good_nodes(root.right,max_)\\n        return count_good_nodes(root,-float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848526,
                "title": "c-solution-using-dfs-tc-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int dfs(TreeNode* root,int x){\\n        if(!root) return 0;\\n        int ans=0;\\n        if(root->val>=x){\\n            ans++;\\n            x=root->val;\\n        }\\n        return (ans+dfs(root->left,x)+dfs(root->right,x));\\n    }\\n    int goodNodes(TreeNode* root) {\\n        return dfs(root,INT_MIN);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int dfs(TreeNode* root,int x){\\n        if(!root) return 0;\\n        int ans=0;\\n        if(root->val>=x){\\n            ans++;\\n            x=root->val;\\n        }\\n        return (ans+dfs(root->left,x)+dfs(root->right,x));\\n    }\\n    int goodNodes(TreeNode* root) {\\n        return dfs(root,INT_MIN);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702776,
                "title": "java-recursion-easy-100-faster",
                "content": "```\\nclass Solution {\\n    \\n    int count = 0;\\n    \\n    public void helper(TreeNode root , int max){\\n        \\n        if(root == null)\\n            return ;\\n        \\n        if(root.val >= max){\\n            count++;\\n            max = root.val;\\n        }\\n        helper(root.left , max);\\n        helper(root.right , max);\\n    }\\n    public int goodNodes(TreeNode root) {\\n        \\n        helper(root , Integer.MIN_VALUE);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int count = 0;\\n    \\n    public void helper(TreeNode root , int max){\\n        \\n        if(root == null)\\n            return ;\\n        \\n        if(root.val >= max){\\n            count++;\\n            max = root.val;\\n        }\\n        helper(root.left , max);\\n        helper(root.right , max);\\n    }\\n    public int goodNodes(TreeNode root) {\\n        \\n        helper(root , Integer.MIN_VALUE);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663311,
                "title": "c-easy-fast-and-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void solve(TreeNode* root, int k)\\n    {\\n        if(!root) return;\\n        \\n        if(root->val>=k)\\n        ans++;\\n        k=max(k,root->val);\\n        \\n        solve(root->left,k);\\n        solve(root->right, k);\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        solve(root, INT_MIN);\\n        return ans;\\n    }\\n};\\n```\\n**UPVOTE !**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void solve(TreeNode* root, int k)\\n    {\\n        if(!root) return;\\n        \\n        if(root->val>=k)\\n        ans++;\\n        k=max(k,root->val);\\n        \\n        solve(root->left,k);\\n        solve(root->right, k);\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        solve(root, INT_MIN);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588438,
                "title": "python-stack-based-on-pre-order-traversal",
                "content": "The question is about each time you meet the **greatest** value on the path from root to current node:\\n- Count it\\n- Raise the `good` to the **greatest** you\\'ve just met\\n\\nI stored the `good` value in tuple with `node` so that each time I popped out, I can easily check whether the value of `right`(`left`) is greater than `good`, increase `count` and recompute the `good`.\\n\\n```python\\ndef goodNodes(self, root: TreeNode) -> int:\\n\\tstack = [(root, root.val)]\\n\\t\\n\\t# Initial count with root\\n\\tcount = 1\\n\\n\\twhile stack:\\n\\t\\tnode, good = stack.pop()\\n\\t\\tif node.right:\\n\\t\\t\\tif node.right.val >= good:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\tstack.append((node.right, max(good, node.right.val)))\\n\\t\\tif node.left:\\n\\t\\t\\tif node.left.val >= good:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\tstack.append((node.left, max(good, node.left.val)))\\n\\n\\treturn count\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```python\\ndef goodNodes(self, root: TreeNode) -> int:\\n\\tstack = [(root, root.val)]\\n\\t\\n\\t# Initial count with root\\n\\tcount = 1\\n\\n\\twhile stack:\\n\\t\\tnode, good = stack.pop()\\n\\t\\tif node.right:\\n\\t\\t\\tif node.right.val >= good:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\tstack.append((node.right, max(good, node.right.val)))\\n\\t\\tif node.left:\\n\\t\\t\\tif node.left.val >= good:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\tstack.append((node.left, max(good, node.left.val)))\\n\\n\\treturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2542158,
                "title": "golang-faster-dfs-beats-95",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc goodNodes(root *TreeNode) int {\\n    return goodNodesTraversal(root, math.MinInt)\\n}\\n\\nfunc goodNodesTraversal(root *TreeNode, maxVal int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    goodNode := 0\\n    if root.Val >= maxVal {\\n        maxVal = root.Val\\n        goodNode += 1\\n    }\\n    \\n    if root.Left != nil {\\n        goodNode += goodNodesTraversal(root.Left, maxVal)\\n    }\\n    \\n    if root.Right != nil {\\n        goodNode += goodNodesTraversal(root.Right, maxVal)\\n    }\\n    \\n    return goodNode\\n}\\n",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc goodNodes(root *TreeNode) int {\\n    return goodNodesTraversal(root, math.MinInt)\\n}\\n\\nfunc goodNodesTraversal(root *TreeNode, maxVal int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    goodNode := 0\\n    if root.Val >= maxVal {\\n        maxVal = root.Val\\n        goodNode += 1\\n    }\\n    \\n    if root.Left != nil {\\n        goodNode += goodNodesTraversal(root.Left, maxVal)\\n    }\\n    \\n    if root.Right != nil {\\n        goodNode += goodNodesTraversal(root.Right, maxVal)\\n    }\\n    \\n    return goodNode\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2516192,
                "title": "javascript-96-07-efficient",
                "content": "```\\nlet search = function(node , max){\\n    if(!node){\\n        return 0;\\n    }\\n    \\n    let count = 0;\\n    if(node.val >=max){\\n        count+=1;\\n        max = node.val;\\n    }\\n    count += search(node.left, max);\\n    count += search(node.right, max);\\n    return count;\\n}\\n\\nvar goodNodes = function(root) {\\n    if(!root){\\n        return 0;\\n    }\\n    if(!root.left && !root.right){\\n        return 1;\\n    }\\n    let goodnodes = 1;\\n    goodnodes +=  search(root.left, root.val);\\n    goodnodes +=  search(root.right, root.val);\\n    return goodnodes;\\n}; ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet search = function(node , max){\\n    if(!node){\\n        return 0;\\n    }\\n    \\n    let count = 0;\\n    if(node.val >=max){\\n        count+=1;\\n        max = node.val;\\n    }\\n    count += search(node.left, max);\\n    count += search(node.right, max);\\n    return count;\\n}\\n\\nvar goodNodes = function(root) {\\n    if(!root){\\n        return 0;\\n    }\\n    if(!root.left && !root.right){\\n        return 1;\\n    }\\n    let goodnodes = 1;\\n    goodnodes +=  search(root.left, root.val);\\n    goodnodes +=  search(root.right, root.val);\\n    return goodnodes;\\n}; ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515733,
                "title": "c-recursive-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(TreeNode* root, int high)\\n    {\\n\\t// if root is NULL return 0\\n        if(root==NULL)\\n            return 0;\\n        else{\\n            int c=0;\\n\\t\\t\\t// If  current root value is greater than previous node value then c=1 else c=0\\n            if(root->val>=high)\\n                c++;\\n\\t \\t //Now we will call for left side good nodes and right side good nodes,\\n\\t\\t //with current node value 1 if it is good node else value 0\\n            return c+fun(root->left,max(root->val,high))+\\n\\t\\t\\tfun(root->right,max(root->val,high));       \\n        }\\n    }\\n    int goodNodes(TreeNode* root) {\\n\\t// INT_MIN is minimum value used to keep the track of value of node that, whether it is greater than previous node or not\\n      return fun(root,INT_MIN);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(TreeNode* root, int high)\\n    {\\n\\t// if root is NULL return 0\\n        if(root==NULL)\\n            return 0;\\n        else{\\n            int c=0;\\n\\t\\t\\t// If  current root value is greater than previous node value then c=1 else c=0\\n            if(root->val>=high)\\n                c++;\\n\\t \\t //Now we will call for left side good nodes and right side good nodes,\\n\\t\\t //with current node value 1 if it is good node else value 0\\n            return c+fun(root->left,max(root->val,high))+\\n\\t\\t\\tfun(root->right,max(root->val,high));       \\n        }\\n    }\\n    int goodNodes(TreeNode* root) {\\n\\t// INT_MIN is minimum value used to keep the track of value of node that, whether it is greater than previous node or not\\n      return fun(root,INT_MIN);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515461,
                "title": "java-recursion-dfs",
                "content": "## Java | EasytoUnderstand | Depth-First_Search\\n```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        if(root == null){ return 0; }\\n        int count = 0;\\n        \\n        count += dfs(root,Integer.MIN_VALUE);\\n        return count;\\n    }\\n    \\n    public int dfs(TreeNode root, int currentMax){\\n        \\n        int amount = 0; \\n        if(root == null){ return 0; }\\n        if(root.val >= currentMax){\\n            amount++; \\n            currentMax = root.val;\\n        }\\n        \\n        amount += dfs(root.left, currentMax);\\n        amount += dfs(root.right, currentMax);\\n\\n        return amount; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        if(root == null){ return 0; }\\n        int count = 0;\\n        \\n        count += dfs(root,Integer.MIN_VALUE);\\n        return count;\\n    }\\n    \\n    public int dfs(TreeNode root, int currentMax){\\n        \\n        int amount = 0; \\n        if(root == null){ return 0; }\\n        if(root.val >= currentMax){\\n            amount++; \\n            currentMax = root.val;\\n        }\\n        \\n        amount += dfs(root.left, currentMax);\\n        amount += dfs(root.right, currentMax);\\n\\n        return amount; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515409,
                "title": "java-easy-sol-beats-100",
                "content": "Just keep a check on Max throughout a particular path , if node.val>= max , then it is counted as a good node.\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public int goodNodes(TreeNode root) {\\n        if(root==null) return 0;\\n        else if(root.left==null && root.right==null) return 1;\\n        \\n        int max = root.val;\\n        int[] count = {0};\\n        \\n        getAns(root, max, count);\\n        return count[0];\\n        \\n    }\\n    \\n    public static void getAns(TreeNode root, int max, int[] count){\\n        if(root==null) return;\\n        \\n        if(root.val>=max) count[0]+=1;\\n        \\n        max = Math.max(root.val , max);\\n        getAns(root.left, max, count);\\n        getAns(root.right,max, count);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public int goodNodes(TreeNode root) {\\n        if(root==null) return 0;\\n        else if(root.left==null && root.right==null) return 1;\\n        \\n        int max = root.val;\\n        int[] count = {0};\\n        \\n        getAns(root, max, count);\\n        return count[0];\\n        \\n    }\\n    \\n    public static void getAns(TreeNode root, int max, int[] count){\\n        if(root==null) return;\\n        \\n        if(root.val>=max) count[0]+=1;\\n        \\n        max = Math.max(root.val , max);\\n        getAns(root.left, max, count);\\n        getAns(root.right,max, count);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514947,
                "title": "easy-binary-tree-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        if(root == null)    return 0;\\n        int count = 1;\\n        count += dfs(root.left, root.val);\\n        count += dfs(root.right, root.val);\\n        \\n        return count;\\n    }\\n    \\n    public int dfs(TreeNode root, int max){\\n        int count = 0;\\n        if(root == null)    return 0;\\n        if(root.val >= max){\\n            count ++;\\n            max = root.val;\\n        }\\n        \\n        count += dfs(root.left, max);\\n        count += dfs(root.right, max);\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n        if(root == null)    return 0;\\n        int count = 1;\\n        count += dfs(root.left, root.val);\\n        count += dfs(root.right, root.val);\\n        \\n        return count;\\n    }\\n    \\n    public int dfs(TreeNode root, int max){\\n        int count = 0;\\n        if(root == null)    return 0;\\n        if(root.val >= max){\\n            count ++;\\n            max = root.val;\\n        }\\n        \\n        count += dfs(root.left, max);\\n        count += dfs(root.right, max);\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514940,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    int count;\\n    public int goodNodes(TreeNode root) {\\n        count=0;\\n        Calc(root,root.val);\\n        return count;\\n    }\\n    public void Calc(TreeNode root,int max){\\n        if(root!=null){\\n            if(root.val>=max){\\n                max=root.val;\\n                count++;\\n            }\\n            Calc(root.left,max);\\n            Calc(root.right,max);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count;\\n    public int goodNodes(TreeNode root) {\\n        count=0;\\n        Calc(root,root.val);\\n        return count;\\n    }\\n    public void Calc(TreeNode root,int max){\\n        if(root!=null){\\n            if(root.val>=max){\\n                max=root.val;\\n                count++;\\n            }\\n            Calc(root.left,max);\\n            Calc(root.right,max);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514817,
                "title": "c-simple-recursive-solution",
                "content": "```\\npublic class Solution {\\n    int count = 0;\\n    public int GoodNodes(TreeNode root) {\\n        GoodNodes(root, int.MinValue);\\n        return count;        \\n    }\\n    \\n    public void GoodNodes(TreeNode root, int max)\\n    {\\n        if(root == null)\\n        {\\n            return;\\n        }\\n        else\\n        {\\n            if(root.val >= max)\\n            {\\n                count++;\\n                max = Math.Max(root.val, max);\\n            }\\n            \\n            GoodNodes(root.left, max);\\n            GoodNodes(root.right, max);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    int count = 0;\\n    public int GoodNodes(TreeNode root) {\\n        GoodNodes(root, int.MinValue);\\n        return count;        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2513599,
                "title": "python-one-liner-explained",
                "content": "Pass current maximum parent value via argument and count the sum of good nodes recursively. We use ternary conditional expression (X if COND else Y) to make a one-liner. Also use the fact that boolean value is implicitly cast to 1 if True and 0 if False.\\n```\\ndef goodNodes(self, root: TreeNode, curMax: int = -10000) -> int:\\n    return self.goodNodes(root.left, max(root.val, curMax)) + self.goodNodes(root.right, max(root.val, curMax)) + (root.val >= curMax) if root else 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef goodNodes(self, root: TreeNode, curMax: int = -10000) -> int:\\n    return self.goodNodes(root.left, max(root.val, curMax)) + self.goodNodes(root.right, max(root.val, curMax)) + (root.val >= curMax) if root else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2513429,
                "title": "bfs-simple-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        int ans = 0;\\n        stack<pair<TreeNode *, int>> stk;\\n        stk.emplace(root, INT_MIN);\\n        while (stk.size()) {\\n            auto curr = stk.top(); stk.pop();\\n            if (curr.first->val >= curr.second) ++ ans;\\n            if (curr.first->left) stk.emplace(curr.first->left, max(curr.first->val, curr.second));\\n            if (curr.first->right) stk.emplace(curr.first->right, max(curr.first->val, curr.second));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        int ans = 0;\\n        stack<pair<TreeNode *, int>> stk;\\n        stk.emplace(root, INT_MIN);\\n        while (stk.size()) {\\n            auto curr = stk.top(); stk.pop();\\n            if (curr.first->val >= curr.second) ++ ans;\\n            if (curr.first->left) stk.emplace(curr.first->left, max(curr.first->val, curr.second));\\n            if (curr.first->right) stk.emplace(curr.first->right, max(curr.first->val, curr.second));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512923,
                "title": "python-very-efficient-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        stk=[[root,root.val]]\\n        res=1\\n        while stk:\\n            temp=stk.pop()\\n            if temp[0].left:\\n                if temp[0].left.val>=temp[1]:\\n                    res+=1\\n                    stk.append([temp[0].left,temp[0].left.val])\\n                else:\\n                    stk.append([temp[0].left,temp[1]])\\n            if temp[0].right:\\n                if temp[0].right.val>=temp[1]:\\n                    res+=1\\n                    stk.append([temp[0].right,temp[0].right.val])\\n                else:\\n                    stk.append([temp[0].right,temp[1]])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        stk=[[root,root.val]]\\n        res=1\\n        while stk:\\n            temp=stk.pop()\\n            if temp[0].left:\\n                if temp[0].left.val>=temp[1]:\\n                    res+=1\\n                    stk.append([temp[0].left,temp[0].left.val])\\n                else:\\n                    stk.append([temp[0].left,temp[1]])\\n            if temp[0].right:\\n                if temp[0].right.val>=temp[1]:\\n                    res+=1\\n                    stk.append([temp[0].right,temp[0].right.val])\\n                else:\\n                    stk.append([temp[0].right,temp[1]])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2512899,
                "title": "python-elegant-short-dfs",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef goodNodes(self, root: TreeNode) -> int:\\n\\t\\t\\treturn self._good_nodes(root, -maxsize)\\n\\n\\t\\t@classmethod\\n\\t\\tdef _good_nodes(cls, node: Optional[TreeNode], curr_max: int) -> int:\\n\\t\\t\\tif node is None:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tcurr_max = max(curr_max, node.val)\\n\\t\\t\\treturn (node.val >= curr_max) + \\\\\\n\\t\\t\\t\\t   cls._good_nodes(node.left, curr_max) + \\\\\\n\\t\\t\\t\\t   cls._good_nodes(node.right, curr_max)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef goodNodes(self, root: TreeNode) -> int:\\n\\t\\t\\treturn self._good_nodes(root, -maxsize)\\n\\n\\t\\t@classmethod\\n\\t\\tdef _good_nodes(cls, node: Optional[TreeNode], curr_max: int) -> int:\\n\\t\\t\\tif node is None:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tcurr_max = max(curr_max, node.val)\\n\\t\\t\\treturn (node.val >= curr_max) + \\\\\\n\\t\\t\\t\\t   cls._good_nodes(node.left, curr_max) + \\\\\\n\\t\\t\\t\\t   cls._good_nodes(node.right, curr_max)",
                "codeTag": "Java"
            },
            {
                "id": 2512770,
                "title": "rust-iterative-with-comments",
                "content": "First, the algorithm. \"The path from root to X\" hints towards iterating over the tree. We should determine nodes for which there are \"no nodes with a value greater than X\" along the path, so we\\'ll keep track of the maximum value of the nodes so far along each path, and count the nodes which have a value equal to or greater than the current max value.\\n\\nSome notes about the implementation:\\n* I prefer an iterative tree-walking algorithm over recursive when possible, for efficiency, even if it becomes more verbose than the recursive equivalent.\\n* In LeetCode problems in general when given a tree, you are rarely asked to return it. So instead of messing around with cloning the `Rc`s, I prefer just moving the given `Rc`s around as needed. When you clone `Rc`s, the reference count has to be incremented, and then when you drop the clone, it has to be decremented again. This is totally unnecessary, and something we can avoid by move semantics in this context.\\n* For this problem, we keep track of the max path value in the stack elements along with the node itself.\\n* Given the constraints, I chose `i32::MIN` as the sentinel for \"no previous value\". With a node minimum value of -2^31, we would have been forced to use the more correct, but also more verbose, type `Option<i32>` for the max path value, and indicate \"no previous value\" with `None`.\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn good_nodes(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut stack = vec![(root, i32::MIN)];\\n        let mut rez = 0;\\n\\n        while let Some(tuple) = stack.pop() {\\n            if let (Some(node_rc), mut max_val) = tuple {\\n                let mut node_ref = node_rc.borrow_mut();\\n                if node_ref.val >= max_val {\\n                    rez += 1;\\n                    max_val = node_ref.val;\\n                }\\n                stack.push((node_ref.left.take(), max_val));\\n                stack.push((node_ref.right.take(), max_val));\\n            }\\n        }\\n        \\n        rez\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn good_nodes(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut stack = vec![(root, i32::MIN)];\\n        let mut rez = 0;\\n\\n        while let Some(tuple) = stack.pop() {\\n            if let (Some(node_rc), mut max_val) = tuple {\\n                let mut node_ref = node_rc.borrow_mut();\\n                if node_ref.val >= max_val {\\n                    rez += 1;\\n                    max_val = node_ref.val;\\n                }\\n                stack.push((node_ref.left.take(), max_val));\\n                stack.push((node_ref.right.take(), max_val));\\n            }\\n        }\\n        \\n        rez\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512528,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int maxi, int &count){\\n        if(!root) return;\\n        if(root->val >= maxi){\\n            count++;\\n            maxi=root->val;\\n        }\\n        solve(root->left,maxi,count);\\n        solve(root->right,maxi,count);\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        int count=0;\\n        solve(root,INT_MIN,count);\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int maxi, int &count){\\n        if(!root) return;\\n        if(root->val >= maxi){\\n            count++;\\n            maxi=root->val;\\n        }\\n        solve(root->left,maxi,count);\\n        solve(root->right,maxi,count);\\n    }\\n    \\n    int goodNodes(TreeNode* root) {\\n        if(!root) return 0;\\n        int count=0;\\n        solve(root,INT_MIN,count);\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512347,
                "title": "pre-order-traversal-easy-solution",
                "content": "```\\nclass Solution {\\n    int count;\\n    public int goodNodes(TreeNode root) {\\n        count=0;\\n        iter(root,-10001);\\n        return count;\\n    }\\n    \\n    public void iter(TreeNode root,int max)\\n    {\\n        if(root==null)\\n            return;\\n        \\n        if(max==-10001 || root.val>=max)\\n            count++;\\n        \\n        iter(root.left,Math.max(root.val,max));\\n        iter(root.right,Math.max(root.val,max));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count;\\n    public int goodNodes(TreeNode root) {\\n        count=0;\\n        iter(root,-10001);\\n        return count;\\n    }\\n    \\n    public void iter(TreeNode root,int max)\\n    {\\n        if(root==null)\\n            return;\\n        \\n        if(max==-10001 || root.val>=max)\\n            count++;\\n        \\n        iter(root.left,Math.max(root.val,max));\\n        iter(root.right,Math.max(root.val,max));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512327,
                "title": "js-javascript-easy-simple-solution-with-dfs",
                "content": "# Any feedback would be appreciated \\uD83D\\uDE0A\\n\\n```\\nconst goodNodes = function(root) {\\n  if (!root) return 0;\\n  let answer = 0;\\n  \\n  function DFS(node, max) {\\n    if (!node) return;\\n    if (node.val >= max) {\\n      answer++;\\n      max = node.val\\n    };\\n    DFS(node.left, max);\\n    DFS(node.right, max);\\n  }\\n  \\n  DFS(root, -Infinity);\\n  return answer;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nconst goodNodes = function(root) {\\n  if (!root) return 0;\\n  let answer = 0;\\n  \\n  function DFS(node, max) {\\n    if (!node) return;\\n    if (node.val >= max) {\\n      answer++;\\n      max = node.val\\n    };\\n    DFS(node.left, max);\\n    DFS(node.right, max);\\n  }\\n  \\n  DFS(root, -Infinity);\\n  return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512316,
                "title": "java-easy-solution-100-faster-100-less-memory-usage",
                "content": "**Upvote if you liked the solution.**\\n\\nTC:O(N), N = number of nodes.\\nSC:O(H), H  = Maximum height of the binary tree.\\n\\n```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n         \\n        return helper(root, root.val);\\n    }\\n    \\n    public int helper(TreeNode root, int largest)\\n    {\\n        if(root == null)\\n        {\\n            return 0;\\n        }\\n        \\n        if(root.val > largest)\\n        {\\n            largest = root.val;\\n        }\\n        \\n        int leftAns = helper(root.left, largest);\\n        int rightAns = helper(root.right, largest);\\n        \\n        int ans=leftAns+rightAns;\\n        \\n        if(root.val >= largest)\\n        {\\n            ans++;\\n        }\\n          \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int goodNodes(TreeNode root) {\\n         \\n        return helper(root, root.val);\\n    }\\n    \\n    public int helper(TreeNode root, int largest)\\n    {\\n        if(root == null)\\n        {\\n            return 0;\\n        }\\n        \\n        if(root.val > largest)\\n        {\\n            largest = root.val;\\n        }\\n        \\n        int leftAns = helper(root.left, largest);\\n        int rightAns = helper(root.right, largest);\\n        \\n        int ans=leftAns+rightAns;\\n        \\n        if(root.val >= largest)\\n        {\\n            ans++;\\n        }\\n          \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512238,
                "title": "c-easy-dfs-space-100-fast",
                "content": "##### Declared a value maxx globally which is initialised to -10000 (-1*1e4) as the minimum value of the node is this only which keeps track of the maximum value of node that is traversed till the current node.\\n##### Now write the code of dfs (preorder) and checked if maxx value is less than or equal to value of current node then we will update the maxx value and store current maxx value in temp variable and increase the count by 1.\\n##### Then traverse to left child and right child and will return the count in the similar way. \\n##### At last we will update the maxx value back to previous value as we are going back from that track.\\n##### And return the count.\\n```\\nclass Solution {\\n    int maxx = -1*1e4;\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int count = 0;\\n        int temp = maxx;\\n        if(maxx <= root->val){\\n            maxx = root->val;\\n            count++;\\n        }\\n        \\n        count += goodNodes(root->left);\\n        count += goodNodes(root->right);\\n        \\n        maxx = temp;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int maxx = -1*1e4;\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int count = 0;\\n        int temp = maxx;\\n        if(maxx <= root->val){\\n            maxx = root->val;\\n            count++;\\n        }\\n        \\n        count += goodNodes(root->left);\\n        count += goodNodes(root->right);\\n        \\n        maxx = temp;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511946,
                "title": "simple-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nint helper(struct TreeNode* root, int max1, int max2){\\n    int count = 0;\\n    if(root == NULL)return 0;\\n    if(root->val >= max1){\\n        max1 = root->val;\\n        count++;\\n    }\\n    if(root->val >= max2){\\n        max2 = root->val;\\n        count++;\\n    }\\n    return helper(root->right, max1, max2)+helper(root->left, max1, max2)+count/2;\\n}\\n\\n\\nint goodNodes(struct TreeNode* root){\\n    if(root == NULL)return 0;\\n    return helper(root, root->val, root->val);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nint helper(struct TreeNode* root, int max1, int max2){\\n    int count = 0;\\n    if(root == NULL)return 0;\\n    if(root->val >= max1){\\n        max1 = root->val;\\n        count++;\\n    }\\n    if(root->val >= max2){\\n        max2 = root->val;\\n        count++;\\n    }\\n    return helper(root->right, max1, max2)+helper(root->left, max1, max2)+count/2;\\n}\\n\\n\\nint goodNodes(struct TreeNode* root){\\n    if(root == NULL)return 0;\\n    return helper(root, root->val, root->val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511803,
                "title": "easy-recursion-solution",
                "content": "***For each intermediate node***, I just checked whether the value is greater or equal to the max value of the path, if yes then the count will be incremented. Then for each child, continue the recursion & obviously I passed the max value of the path in each recursion call.\\n\\n***For root***, by definition it is a *good node*. So I just passed it in the recursion call with the lowest possible value so that the root is counted as a good node. \\n\\n***For leaf node***,  just return 1 or 0 considering this is a *good node* or not. \\n\\n\\n    int goodNodes(TreeNode* root) {\\n        return recur(root,-10001);\\n    }\\n    \\n    int recur(TreeNode* x, int max)\\n    {\\n        int ret;\\n        int ok = 0;\\n        if( x->val >= max )\\n        {\\n            max = x->val;\\n            ok = 1;\\n        }\\n            \\n        if ( x->left == nullptr && x->right == nullptr )\\n        {\\n            return ok;\\n        }\\n        else if ( x->left == nullptr )\\n        {\\n            return ok + recur(x->right, max);\\n        }\\n        else if ( x->right == nullptr )\\n        {\\n            return ok + recur(x->left, max);\\n        }\\n        \\n        return ok + recur(x->left, max) + recur ( x->right, max);\\n            \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "***For each intermediate node***, I just checked whether the value is greater or equal to the max value of the path, if yes then the count will be incremented. Then for each child, continue the recursion & obviously I passed the max value of the path in each recursion call.\\n\\n***For root***, by definition it is a *good node*. So I just passed it in the recursion call with the lowest possible value so that the root is counted as a good node. \\n\\n***For leaf node***,  just return 1 or 0 considering this is a *good node* or not. \\n\\n\\n    int goodNodes(TreeNode* root) {\\n        return recur(root,-10001);\\n    }\\n    \\n    int recur(TreeNode* x, int max)\\n    {\\n        int ret;\\n        int ok = 0;\\n        if( x->val >= max )\\n        {\\n            max = x->val;\\n            ok = 1;\\n        }\\n            \\n        if ( x->left == nullptr && x->right == nullptr )\\n        {\\n            return ok;\\n        }\\n        else if ( x->left == nullptr )\\n        {\\n            return ok + recur(x->right, max);\\n        }\\n        else if ( x->right == nullptr )\\n        {\\n            return ok + recur(x->left, max);\\n        }\\n        \\n        return ok + recur(x->left, max) + recur ( x->right, max);\\n            \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2511801,
                "title": "c-dfs-short-and-easy-solution-faster-than-87-51",
                "content": "### Please Upvote If Helpful\\n```\\nclass Solution {\\nprivate:\\n    void dfs(TreeNode* root, int num, int &count)\\n    {\\n    if(root==NULL)\\n        return;\\n    else if(root->val >= num)\\n        count++;\\n    num=max(num,root->val);\\n    dfs(root->left,num,count);\\n    dfs(root->right,num,count);\\n    }\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        int count=0;\\n        dfs(root, root->val, count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(TreeNode* root, int num, int &count)\\n    {\\n    if(root==NULL)\\n        return;\\n    else if(root->val >= num)\\n        count++;\\n    num=max(num,root->val);\\n    dfs(root->left,num,count);\\n    dfs(root->right,num,count);\\n    }\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        int count=0;\\n        dfs(root, root->val, count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465958,
                "title": "python-recursive-and-iterative-dfs-solutions",
                "content": "Recursive Solution:\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        self.res = 0\\n        def dfs(root, max_val):\\n            if root is None:\\n                return 0\\n            \\n            if root.val >= max_val:\\n                self.res += 1\\n                max_val = root.val\\n            \\n            dfs(root.left, max_val)\\n            dfs(root.right, max_val)\\n        \\n        dfs(root, float(\"-inf\"))\\n        return self.res\\n```\\n\\nIterative Solution:\\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        if root is None:\\n            return 0\\n        \\n        stack = []\\n        stack.append((root, float(\"-inf\")))\\n        res = 0\\n        \\n        while stack:\\n            node, max_val = stack.pop()\\n            if node.val >= max_val:\\n                res += 1\\n                max_val = node.val\\n                \\n            if node.left:\\n                stack.append((node.left, max_val))\\n            \\n            if node.right:\\n                stack.append((node.right, max_val))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        self.res = 0\\n        def dfs(root, max_val):\\n            if root is None:\\n                return 0\\n            \\n            if root.val >= max_val:\\n                self.res += 1\\n                max_val = root.val\\n            \\n            dfs(root.left, max_val)\\n            dfs(root.right, max_val)\\n        \\n        dfs(root, float(\"-inf\"))\\n        return self.res\\n```\n```\\nclass Solution:\\n    def goodNodes(self, root: TreeNode) -> int:\\n        if root is None:\\n            return 0\\n        \\n        stack = []\\n        stack.append((root, float(\"-inf\")))\\n        res = 0\\n        \\n        while stack:\\n            node, max_val = stack.pop()\\n            if node.val >= max_val:\\n                res += 1\\n                max_val = node.val\\n                \\n            if node.left:\\n                stack.append((node.left, max_val))\\n            \\n            if node.right:\\n                stack.append((node.right, max_val))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379984,
                "title": "c-preorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    int nodes = 0 ;\\n    void solve(TreeNode * root , int prev){\\n        if(!root) return ;\\n        if(root->val >= prev) ++nodes ;\\n        solve(root->left,max(prev,root->val)) ;\\n        solve(root->right,max(prev,root->val)) ;\\n        \\n    }\\n    int goodNodes(TreeNode* root) {\\n        solve(root,root->val) ;\\n        return nodes ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nodes = 0 ;\\n    void solve(TreeNode * root , int prev){\\n        if(!root) return ;\\n        if(root->val >= prev) ++nodes ;\\n        solve(root->left,max(prev,root->val)) ;\\n        solve(root->right,max(prev,root->val)) ;\\n        \\n    }\\n    int goodNodes(TreeNode* root) {\\n        solve(root,root->val) ;\\n        return nodes ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346162,
                "title": "java-solution-easy-understanding-dfs",
                "content": "```\\nclass Solution {\\n    int count=0;\\n    public int goodNodes(TreeNode root) {\\n           help(root,root.val);\\n           return count;\\n           \\n    }\\n    public void help(TreeNode root,int max)\\n    {\\n          if(root==null)\\n              return;\\n          if(root.val>=max)\\n          {\\n              count++;\\n              max=root.val;\\n          }\\n          help(root.left,max);\\n          help(root.right,max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int count=0;\\n    public int goodNodes(TreeNode root) {\\n           help(root,root.val);\\n           return count;\\n           \\n    }\\n    public void help(TreeNode root,int max)\\n    {\\n          if(root==null)\\n              return;\\n          if(root.val>=max)\\n          {\\n              count++;\\n              max=root.val;\\n          }\\n          help(root.left,max);\\n          help(root.right,max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271424,
                "title": "c-dfs-simple-traversal",
                "content": "class Solution {\\npublic:\\n\\n    int ans=0;\\n    void traverse(TreeNode *root,int max)\\n    {\\n        if(root!=NULL)\\n        {\\n            if(root->val>=max)\\n            {\\n                ans++;\\n                max=root->val;\\n            }\\n            traverse(root->left,max);\\n            traverse(root->right,max);\\n        }\\n        return;\\n    }\\n    int goodNodes(TreeNode* root) {\\n        if(root==NULL)\\n            return ans;\\n        traverse(root,root->val);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Interactive"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int ans=0;\\n    void traverse(TreeNode *root,int max)\\n    {\\n        if(root!=NULL)\\n        {\\n            if(root->val>=max)\\n            {\\n                ans++;\\n                max=root->val;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2237988,
                "title": "java-simple-recursive-using-static-variable-2-approaches-intuitive",
                "content": "```\\n// Recursive\\npublic int count(TreeNode root, int val){\\n        if(root == null)\\n            return 0;\\n        int maxVal = Math.max(root.val, val); \\n        if(root.val >= val){\\n            return 1 + count(root.left, maxVal) + count(root.right, maxVal);\\n        }\\n        else{\\n            return count(root.left, maxVal) + count(root.right, maxVal);\\n        }\\n    }\\n    public int goodNodes(TreeNode root) {\\n        return count(root, root.val);\\n    }\\n\\t//=============== Using Static Variable ==============\\n\\tint count = 0;\\n    public void count(TreeNode root, int val){\\n        if(root == null)\\n            return;\\n        if( root.val >= val){\\n            count++;\\n            val = root.val;\\n        }\\n        count(root.left,val);\\n        count(root.right,val);\\n    }\\n    public int goodNodes(TreeNode root) {\\n        count(root, root.val);\\n        return count;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Recursive\\npublic int count(TreeNode root, int val){\\n        if(root == null)\\n            return 0;\\n        int maxVal = Math.max(root.val, val); \\n        if(root.val >= val){\\n            return 1 + count(root.left, maxVal) + count(root.right, maxVal);\\n        }\\n        else{\\n            return count(root.left, maxVal) + count(root.right, maxVal);\\n        }\\n    }\\n    public int goodNodes(TreeNode root) {\\n        return count(root, root.val);\\n    }\\n\\t//=============== Using Static Variable ==============\\n\\tint count = 0;\\n    public void count(TreeNode root, int val){\\n        if(root == null)\\n            return;\\n        if( root.val >= val){\\n            count++;\\n            val = root.val;\\n        }\\n        count(root.left,val);\\n        count(root.right,val);\\n    }\\n    public int goodNodes(TreeNode root) {\\n        count(root, root.val);\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2025820,
                "title": "binary-tree-99-97-faster-java-solution",
                "content": "```\\n/*in between root node to leave node finding max element \\nif current node val greater than  max element then its must be greater than the all element from root node  to current node */\\nclass Solution {\\n    int count=0;\\n    void rec(int max,TreeNode root){\\n        if(root.val>=max) count++; //comparing with present node with max\\n        if(root.left!=null){\\n            max=Math.max(root.val,max); // finding max element from root to current node\\n            rec(max,root.left);\\n        }\\n        if(root.right!=null){\\n            max=Math.max(root.val,max); // finding max element from root to current node\\n            rec(max,root.right);\\n        }\\n    }\\n    public int goodNodes(TreeNode root) {\\n        rec(root.val,root);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/*in between root node to leave node finding max element \\nif current node val greater than  max element then its must be greater than the all element from root node  to current node */\\nclass Solution {\\n    int count=0;\\n    void rec(int max,TreeNode root){\\n        if(root.val>=max) count++; //comparing with present node with max\\n        if(root.left!=null){\\n            max=Math.max(root.val,max); // finding max element from root to current node\\n            rec(max,root.left);\\n        }\\n        if(root.right!=null){\\n            max=Math.max(root.val,max); // finding max element from root to current node\\n            rec(max,root.right);\\n        }\\n    }\\n    public int goodNodes(TreeNode root) {\\n        rec(root.val,root);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004827,
                "title": "short-and-simple-c",
                "content": "```\\nvoid traverse(TreeNode* root,int k,int& count)//k is not reference to make it hold the -\\n    {                                             // max value of ancestors just before current node\\n        if(root==NULL)\\n            return ;\\n        if(k<root->val)\\n            k=root->val;               //value of k holds the max value among ancestors\\n        traverse(root->left,k,count);\\n            if(root->val>=k)\\n                count++;               //value of count keep track of good nodes\\n        traverse(root->right,k,count);\\n    }\\n    int goodNodes(TreeNode* root) {\\n        int count=0;\\n        traverse(root,INT_MIN,count);\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvoid traverse(TreeNode* root,int k,int& count)//k is not reference to make it hold the -\\n    {                                             // max value of ancestors just before current node\\n        if(root==NULL)\\n            return ;\\n        if(k<root->val)\\n            k=root->val;               //value of k holds the max value among ancestors\\n        traverse(root->left,k,count);\\n            if(root->val>=k)\\n                count++;               //value of count keep track of good nodes\\n        traverse(root->right,k,count);\\n    }\\n    int goodNodes(TreeNode* root) {\\n        int count=0;\\n        traverse(root,INT_MIN,count);\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1972750,
                "title": "preorder-dfs-traversal-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int ans = 0;\\n    void solve(TreeNode* root,int maxi){\\n        if(!root) return;\\n        if(maxi <= root->val) ans++;\\n        maxi = max(maxi,root->val);\\n        solve(root->left,maxi);\\n        solve(root->right,maxi);\\n    }\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        solve(root,-1e9);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int ans = 0;\\n    void solve(TreeNode* root,int maxi){\\n        if(!root) return;\\n        if(maxi <= root->val) ans++;\\n        maxi = max(maxi,root->val);\\n        solve(root->left,maxi);\\n        solve(root->right,maxi);\\n    }\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        solve(root,-1e9);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943708,
                "title": "c-tree-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void helper(TreeNode * root , int val){\\n        if(root==NULL) return;\\n        if(root->val >= val){\\n            count++;\\n            val = max(root->val,val);\\n        }\\n        helper(root->left,val);\\n        helper(root->right,val);\\n        \\n    }\\n    int goodNodes(TreeNode* root) {\\n        \\n        helper(root,INT_MIN);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void helper(TreeNode * root , int val){\\n        if(root==NULL) return;\\n        if(root->val >= val){\\n            count++;\\n            val = max(root->val,val);\\n        }\\n        helper(root->left,val);\\n        helper(root->right,val);\\n        \\n    }\\n    int goodNodes(TreeNode* root) {\\n        \\n        helper(root,INT_MIN);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1581622,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 2024499,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 1936546,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 1627855,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 1775705,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 2004887,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 1727005,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 1575402,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 2076161,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 2062636,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 1581622,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 2024499,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 1936546,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 1627855,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 1775705,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 2004887,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 1727005,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 1575402,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 2076161,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            },
            {
                "id": 2062636,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "Just try to remember max in the path you dont have to worry about other numbers."
                    },
                    {
                        "username": "jaggz01",
                        "content": "Should be marked as Easy."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "It's a bit strange to me how this question, which is just traversing a tree, is marked medium. A question like [subtree of another tree](https://leetcode.com/problems/subtree-of-another-tree/) is marked easy and that seems objectively more complex, you couldn't do that question without the capability to do this one."
                    },
                    {
                        "username": "poundppx",
                        "content": "i can do it in my head but its not efficience tho "
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly sub tree of another tree is bit complexed than this \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "sim1029",
                        "content": "# Hints + Github Gist Solution\\nAs we traverse the paths, the current node can be one of three things:\\n\\n1. Less than a node in the current path\\n2. Equal to a node in the current path\\n3. Greater than a node in the current path\\n\\nIn the first case, we ignore this node from our result.\\n\\nIn cases two and three we need to update the \"greatest\" node in the current path so far and pass this along to the rest of our recursive calls. You can think of it like: \"nodes further down the tree have a harder time being included in the result since there are more nodes in front of them to drive up the minimum value to be included\"\\n\\nThen just setup the correct base case and recursive calls and you are done. \\n\\nMy recursive solution used:\\n- Two parameters: current_node and current_min_of_path\\n- Two new recursive calls spawned at each valid node\\n- Base case when a node is null. Consider carefully what value we want to return in this case...\\n\\n## Still stuck?\\n[Solution](https://gist.github.com/sim1029/696ad81cd02f7627d96a9b9fe991e73f)"
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Why is this question marked as medium? Shouldn\\u2019t it be easy? It\\'s just a simple dfs/bfs with little extra logic. Or am I missing something?"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "yes i don\\'t know why it\\'s marked as  medium the only thing here is just do simple dfs by having the parent as maximum of the path so far but still it could be difficult for beginners maybe but yeah it should be marked as easy "
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Agree"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Try to think in such a way: is it simple just for you or for all people?"
                    },
                    {
                        "username": "GOBurrito",
                        "content": "[@Manohar_001](/Manohar_001) There are easy questions I\\'ve found which were more complex than this. This is just traversing a tree which would I\\'m pretty sure is easy for other questions."
                    },
                    {
                        "username": "joemillervi",
                        "content": "agree"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Don\\'t see the world only from your perspective."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I\\'m having trouble understanding the question.\\nI thought it said, the root node\\'s value is the max and any children nodes with a value greater than the root node should be counted as bad."
                    },
                    {
                        "username": "rashi_05",
                        "content": "Can anyone tell me, why first code is not working while the other one is. \n```\nclass Solution {\npublic:\n    int count=0;\n    void countNodes(TreeNode* root, TreeNode* X, int &count){\n        if(root==NULL){\n            return ;\n        }\n        if(root->val>=X->val){\n            count++;\n            X->val = root->val;\n        }\n        countNodes(root->left, X, count);\n        countNodes(root->right, X, count);\n    }\n    int goodNodes(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        countNodes(root, root->val, count);\n        return count;\n    }\n};\n```\n\n//2nd\n```\nclass Solution {\npublic:\n    int count = 0;\n    void dfs(TreeNode* node,int curMax){\n        if (!node) return;\n        \n        if (node->val >= curMax){\n            count++;\n            curMax = node->val;\n        }\n        dfs(node->left, curMax);\n        dfs(node->right, curMax);\n    }\n    int goodNodes(TreeNode* root) {\n        dfs(root, root->val);\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "tushargupta_1206",
                        "content": "It must be because you don\\'t need to explicitly pass the count variable in countNodes function as it will change its value inside the function only but when you return it inside goodNodes function you are getting gloabal value of count which is still 0."
                    },
                    {
                        "username": "saiprasanthP",
                        "content": "Here in this input at index 1 we have null as input.\\n\\nHow we could have 10 as Left Child and 8 as Right Child for null \\n\\nCan any one tell me the tree structure for this input"
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Could you please share the test case?\n"
                    },
                    {
                        "username": "kimjosephdo",
                        "content": "why is [-1,5,-2,4,4,2,-2,null,null,-4,null,-2,3,null,-2,0,null,-1,null,-3,null,-4,-3,3,null,null,null,null,null,null,null,3,-3]\\na valid test case?? it doesn\\'t seem to make a binary tree?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "Bruh, they say each node\\'s value is between -10^4 and 10^4 but -10^4 = (-10)^4 = 1000 = 10^4"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sentence Similarity III",
        "question_content": "<p>A sentence is a list of words that are separated by a single space with no leading or trailing spaces. For example, <code>&quot;Hello World&quot;</code>, <code>&quot;HELLO&quot;</code>, <code>&quot;hello world hello world&quot;</code> are all sentences. Words consist of <strong>only</strong> uppercase and lowercase English letters.</p>\n\n<p>Two sentences <code>sentence1</code> and <code>sentence2</code> are <strong>similar</strong> if it is possible to insert an arbitrary sentence <strong>(possibly empty)</strong> inside one of these sentences such that the two sentences become equal. For example, <code>sentence1 = &quot;Hello my name is Jane&quot;</code> and <code>sentence2 = &quot;Hello Jane&quot;</code> can be made equal by inserting <code>&quot;my name is&quot;</code> between <code>&quot;Hello&quot;</code> and <code>&quot;Jane&quot;</code> in <code>sentence2</code>.</p>\n\n<p>Given two sentences <code>sentence1</code> and <code>sentence2</code>, return <code>true</code> <em>if </em><code>sentence1</code> <em>and </em><code>sentence2</code> <em>are similar.</em> Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence1 = &quot;My name is Haley&quot;, sentence2 = &quot;My Haley&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> sentence2 can be turned to sentence1 by inserting &quot;name is&quot; between &quot;My&quot; and &quot;Haley&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence1 = &quot;of&quot;, sentence2 = &quot;A lot of words&quot;\n<strong>Output:</strong> false\n<strong>Explanation: </strong>No single sentence can be inserted inside one of the sentences to make it equal to the other.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence1 = &quot;Eating right now&quot;, sentence2 = &quot;Eating&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> sentence2 can be turned to sentence1 by inserting &quot;right now&quot; at the end of the sentence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li>\n\t<li><code>sentence1</code> and <code>sentence2</code> consist of lowercase and uppercase English letters and spaces.</li>\n\t<li>The words in <code>sentence1</code> and <code>sentence2</code> are separated by a single space.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1140503,
                "title": "java-python-3-two-codes-w-brief-explanation-and-analysis",
                "content": "**Method 1: Scan the shorter sentence compare with the longer.**\\n\\n1. Split the two sentences into words;\\n2. Scan the shorter one from left and compare word by word with the longer; Whenever the words from the `2` sentences are not equal, compare the tails of the `2` sentences word by word till the end or they do not match;\\n3. Confirm if the pointer reaches the end of shorter sentence. If yes, return `true`; otherwise, return `false`.\\n\\n```java\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n        String[] words1 = s1.split(\" \"), words2 = s2.split(\" \");\\n        int i = 0, n1 = words1.length, n2 = words2.length;\\n        if (n1 > n2) {\\n            return areSentencesSimilar(s2, s1);\\n        }\\n        while (i < n1 && words1[i].equals(words2[i])) {\\n            ++i;\\n        }\\n        while (i < n1 && words1[i].equals(words2[n2 - n1 + i])) {\\n            ++i;\\n        }\\n        return i == n1;\\n    }\\n```\\n```python\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        words1, words2 = sentence1.split(), sentence2.split()\\n        n1, n2 = map(len, (words1, words2))\\n        if n1 > n2:\\n            return self.areSentencesSimilar(sentence2, sentence1)\\n        i = 0\\n        while i < n1 and words1[i] == words2[i]:\\n            i += 1\\n        while i < n1 and words1[i] == words2[n2 - n1 + i]:\\n            i += 1\\n        return i == n1\\n```\\n\\n----\\n\\n\\n**Method 2: deque:**\\n1. Split the two sentences and put into `Deque`s;\\n2. Keep omparing the first words of the `2` `Deque`s, if same, poll them out; Whenever they are not equal, then compare the tails of the `2` sentences word by word till the end or they do not match;\\n3. Check if either of the `2` `Deque`s is empty, If yes, return `true`; otherwise, return `false`.\\n\\n```java\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n        Deque<String> dq1 = new ArrayDeque<>(Arrays.asList(s1.split(\" \")));\\n        Deque<String> dq2 = new ArrayDeque<>(Arrays.asList(s2.split(\" \")));\\n        while (!dq1.isEmpty() && !dq2.isEmpty() && dq1.peek().equals(dq2.peek())) {\\n            dq1.poll();\\n            dq2.poll();\\n        }\\n        while (!dq1.isEmpty() && !dq2.isEmpty() && dq1.peekLast().equals(dq2.peekLast())) {\\n            dq1.pollLast();\\n            dq2.pollLast();\\n        }\\n        return dq1.isEmpty() || dq2.isEmpty();\\n    }\\n```\\n```python\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        dq1, dq2 = map(deque, (sentence1.split(), sentence2.split()))\\n        while dq1 and dq2 and dq1[0] == dq2[0]:\\n            dq1.popleft()\\n            dq2.popleft()\\n        while dq1 and dq2 and dq1[-1] == dq2[-1]:       \\n            dq1.pop()\\n            dq2.pop()\\n        return not dq1 or not dq2\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n1 + n2)`, where `n1 = sentence1.length()`, `n2 = sentence2.length()`.",
                "solutionTags": [],
                "code": "```java\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n        String[] words1 = s1.split(\" \"), words2 = s2.split(\" \");\\n        int i = 0, n1 = words1.length, n2 = words2.length;\\n        if (n1 > n2) {\\n            return areSentencesSimilar(s2, s1);\\n        }\\n        while (i < n1 && words1[i].equals(words2[i])) {\\n            ++i;\\n        }\\n        while (i < n1 && words1[i].equals(words2[n2 - n1 + i])) {\\n            ++i;\\n        }\\n        return i == n1;\\n    }\\n```\n```python\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        words1, words2 = sentence1.split(), sentence2.split()\\n        n1, n2 = map(len, (words1, words2))\\n        if n1 > n2:\\n            return self.areSentencesSimilar(sentence2, sentence1)\\n        i = 0\\n        while i < n1 and words1[i] == words2[i]:\\n            i += 1\\n        while i < n1 and words1[i] == words2[n2 - n1 + i]:\\n            i += 1\\n        return i == n1\\n```\n```java\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n        Deque<String> dq1 = new ArrayDeque<>(Arrays.asList(s1.split(\" \")));\\n        Deque<String> dq2 = new ArrayDeque<>(Arrays.asList(s2.split(\" \")));\\n        while (!dq1.isEmpty() && !dq2.isEmpty() && dq1.peek().equals(dq2.peek())) {\\n            dq1.poll();\\n            dq2.poll();\\n        }\\n        while (!dq1.isEmpty() && !dq2.isEmpty() && dq1.peekLast().equals(dq2.peekLast())) {\\n            dq1.pollLast();\\n            dq2.pollLast();\\n        }\\n        return dq1.isEmpty() || dq2.isEmpty();\\n    }\\n```\n```python\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        dq1, dq2 = map(deque, (sentence1.split(), sentence2.split()))\\n        while dq1 and dq2 and dq1[0] == dq2[0]:\\n            dq1.popleft()\\n            dq2.popleft()\\n        while dq1 and dq2 and dq1[-1] == dq2[-1]:       \\n            dq1.pop()\\n            dq2.pop()\\n        return not dq1 or not dq2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1140539,
                "title": "deque-solution-c-neat-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        string temp = \"\";\\n        deque<string>a,b;\\n        for(char c:s1){\\n            if(c == \\' \\') a.push_back(temp),temp = \"\";\\n            else temp += c;\\n        }\\n        a.push_back(temp),temp = \"\";\\n        for(char c:s2){\\n            if(c == \\' \\') b.push_back(temp),temp = \"\";\\n            else temp += c;\\n        }\\n        b.push_back(temp),temp = \"\";\\n\\t\\t// removing common from front\\n        while(a.size() != 0 && b.size() != 0 && (a.front() == b.front())) a.pop_front(),b.pop_front();\\n        //removing common from back\\n\\t\\twhile(a.size() != 0 && b.size() != 0 && (a.back() == b.back())) a.pop_back(),b.pop_back();\\n\\t\\tif(a.size() == 0 || b.size() == 0) return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        string temp = \"\";\\n        deque<string>a,b;\\n        for(char c:s1){\\n            if(c == \\' \\') a.push_back(temp),temp = \"\";\\n            else temp += c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1140513,
                "title": "python-solution-just-compare-the-firsts-and-lasts",
                "content": "If the first words match, pop them out\\nIf the last words match,pop them out\\nIf neither matches, return False\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = sentence1.split()\\n        s2 = sentence2.split()\\n        if(len(s1)>len(s2)):            #let s1 be the smaller and s2 be the greater\\n            s1,s2 = s2,s1\\n        while(s1): \\n            if(s2[0]==s1[0]):\\n                s2.pop(0)\\n                s1.pop(0)\\n            elif(s2[-1]==s1[-1]):\\n                s2.pop()\\n                s1.pop()\\n            else:\\n                return(False)            \\n        return(True)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = sentence1.split()\\n        s2 = sentence2.split()\\n        if(len(s1)>len(s2)):            #let s1 be the smaller and s2 be the greater\\n            s1,s2 = s2,s1\\n        while(s1): \\n            if(s2[0]==s1[0]):\\n                s2.pop(0)\\n                s1.pop(0)\\n            elif(s2[-1]==s1[-1]):\\n                s2.pop()\\n                s1.pop()\\n            else:\\n                return(False)            \\n        return(True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140793,
                "title": "java-simple-and-easy-to-understand-solution-5-ms-faster-than-100-00-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        \\n        String[] words1 = sentence1.split(\"\\\\\\\\s\");\\n        String[] words2 = sentence2.split(\"\\\\\\\\s\");\\n        \\n        return words1.length <= words2.length ? areSentencesSimilar(words1, words2) : areSentencesSimilar(words2, words1);\\n    }\\n    \\n    private boolean areSentencesSimilar(String[] words1, String[] words2){\\n        int matchCount = 0;\\n        \\n        int len1 = words1.length; // words of short sentence \\n        int len2 = words2.length; // words of long sentence \\n        \\n        int i = 0;\\n        //find numbers of word matching from starting\\n        while(i < len1 && words1[i].equals(words2[i])){\\n            i++;\\n            matchCount++;\\n        }\\n        \\n        //find numbers of word matching from end\\n        while(i < len1 && words1[i].equals(words2[len2 - (len1 - i)])){\\n            i++;\\n            matchCount++;\\n        }\\n        \\n        return matchCount == len1;\\n    }\\n }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        \\n        String[] words1 = sentence1.split(\"\\\\\\\\s\");\\n        String[] words2 = sentence2.split(\"\\\\\\\\s\");\\n        \\n        return words1.length <= words2.length ? areSentencesSimilar(words1, words2) : areSentencesSimilar(words2, words1);\\n    }\\n    \\n    private boolean areSentencesSimilar(String[] words1, String[] words2){\\n        int matchCount = 0;\\n        \\n        int len1 = words1.length; // words of short sentence \\n        int len2 = words2.length; // words of long sentence \\n        \\n        int i = 0;\\n        //find numbers of word matching from starting\\n        while(i < len1 && words1[i].equals(words2[i])){\\n            i++;\\n            matchCount++;\\n        }\\n        \\n        //find numbers of word matching from end\\n        while(i < len1 && words1[i].equals(words2[len2 - (len1 - i)])){\\n            i++;\\n            matchCount++;\\n        }\\n        \\n        return matchCount == len1;\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140673,
                "title": "simple-cpp-solution",
                "content": "**Logic--\\nIf first words matches increase the start pointers else If last words matches decrease the end pointers else return false**\\n\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        // two vectors to store words of both sentence\\n        vector<string>s1;\\n        vector<string>s2;\\n        string word;\\n        stringstream iss(sentence1);//storing each word of sentence 1\\n            while(iss>>word)\\n               s1.push_back(word);\\n        string word1;\\n        stringstream iss1(sentence2);//storing each word of sentence 2\\n            while(iss1>>word1)\\n                 s2.push_back(word1);\\n        int start1=0,start2=0,end1=s1.size()-1,end2=s2.size()-1;\\n        while(start1<=end1&&start2<=end2)\\n        {\\n            if(s1[start1]==s2[start2]) // if start of both vectors are equal\\n            {\\n                start1++; start2++;\\n            }\\n            else if(s1[end1]==s2[end2]) //if end of both vectors are equal\\n            {\\n                end1--; end2--;\\n            }\\n            else  return false;\\n        }\\n        return true;\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        // two vectors to store words of both sentence\\n        vector<string>s1;\\n        vector<string>s2;\\n        string word;\\n        stringstream iss(sentence1);//storing each word of sentence 1\\n            while(iss>>word)\\n               s1.push_back(word);\\n        string word1;\\n        stringstream iss1(sentence2);//storing each word of sentence 2\\n            while(iss1>>word1)\\n                 s2.push_back(word1);\\n        int start1=0,start2=0,end1=s1.size()-1,end2=s2.size()-1;\\n        while(start1<=end1&&start2<=end2)\\n        {\\n            if(s1[start1]==s2[start2]) // if start of both vectors are equal\\n            {\\n                start1++; start2++;\\n            }\\n            else if(s1[end1]==s2[end2]) //if end of both vectors are equal\\n            {\\n                end1--; end2--;\\n            }\\n            else  return false;\\n        }\\n        return true;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140760,
                "title": "c-one-pass-and-python-split",
                "content": "> Update: check out the newly added one-pass C++ solution below.\\n\\n**Python Split**\\nIt felt easier to use the `split` appoach during the context, so I choose Python as it provides it out of the box.\\n\\nUsing `split` is important so make sure we match entire words. Also, we need to make sure that `s2` is the smallest of two strings to make computations simler.\\n\\n```python\\nclass Solution:\\n    def areSentencesSimilar(self, s1: str, s2: str) -> bool:\\n        w1, w2 = s1.split(\" \"), s2.split(\" \")\\n        if len(w1) < len(w2):\\n            w1, w2 = w2, w1\\n        i, j, dif = 0, len(w2) - 1, len(w1) - len(w2)\\n        while i < len(w2) and w2[i] == w1[i]:\\n            i += 1\\n        while j >= 0 and w2[j] == w1[j + dif]:\\n            j -= 1\\n        return i > j\\n```\\n**C++ One-pass**\\nThe `split` function creates bunch of smaller strings, so it\\'s good to consider a more efficient approach. This problem has a lot of edge cases, and one way to simplify it is to track the position of the most recent *space* when searching from start (`ss`) and end (`ls`). Both pointers should point to the same space in the end.\\n\\nNote that, if we reached the end (or start) of the smaller string, we check if the next character of the larger string is a space.\\n\\n```cpp\\nbool areSentencesSimilar(string s, string l) {\\n    if (l.size() == s.size())\\n        return s == l;\\n    if (l.size() < s.size())\\n        swap(s, l);\\n    int ss = -1, ls = s.size(), d = l.size() - s.size();\\n    for (int i = 0; i < s.size() && s[i] == l[i]; ++i)\\n        ss = s[i] == \\' \\' || l[i + 1] == \\' \\' ? i : ss;\\n    for (int i = s.size() - 1; i >= max(0, ss) && s[i] == l[d + i]; --i)\\n        ls = s[i] == \\' \\' || l[d + i - 1] == \\' \\' ? i : ls;\\n    return ss == s.size() - 1 || ls == 0 || ss == ls;\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def areSentencesSimilar(self, s1: str, s2: str) -> bool:\\n        w1, w2 = s1.split(\" \"), s2.split(\" \")\\n        if len(w1) < len(w2):\\n            w1, w2 = w2, w1\\n        i, j, dif = 0, len(w2) - 1, len(w1) - len(w2)\\n        while i < len(w2) and w2[i] == w1[i]:\\n            i += 1\\n        while j >= 0 and w2[j] == w1[j + dif]:\\n            j -= 1\\n        return i > j\\n```\n```cpp\\nbool areSentencesSimilar(string s, string l) {\\n    if (l.size() == s.size())\\n        return s == l;\\n    if (l.size() < s.size())\\n        swap(s, l);\\n    int ss = -1, ls = s.size(), d = l.size() - s.size();\\n    for (int i = 0; i < s.size() && s[i] == l[i]; ++i)\\n        ss = s[i] == \\' \\' || l[i + 1] == \\' \\' ? i : ss;\\n    for (int i = s.size() - 1; i >= max(0, ss) && s[i] == l[d + i]; --i)\\n        ls = s[i] == \\' \\' || l[d + i - 1] == \\' \\' ? i : ls;\\n    return ss == s.size() - 1 || ls == 0 || ss == ls;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279103,
                "title": "easy-c-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        //store all the words in a vector of string \\n        vector<string> arr1;\\n        vector<string> arr2;\\n        \\n        //i want to keep a track of which sentence is longer and which sentence  is smaller\\n        //Because it would help me when i use two pointer approach\\n        \\n        string longest=sentence1;\\n        string shortest=sentence2;\\n        \\n        if(sentence1.length()<sentence2.length())\\n        {\\n            longest=sentence2;\\n            shortest=sentence1;\\n        }\\n        string currWord=\"\";\\n        for(int i=0;i<longest.length();i++)\\n        {\\n            if(longest[i]==\\' \\')\\n            {\\n                arr1.push_back(currWord);\\n                currWord=\"\";\\n                continue;\\n            }\\n            currWord.push_back(longest[i]);\\n        }\\n        //add the last word too\\n        arr1.push_back(currWord);\\n        \\n        //store the strings in sentence 2\\n        currWord=\"\";\\n        for(int i=0;i<shortest.length();i++)\\n        {\\n            if(shortest[i]==\\' \\')\\n            {\\n                arr2.push_back(currWord);\\n                currWord=\"\";\\n                continue;\\n            }\\n            currWord.push_back(shortest[i]);\\n        }\\n        arr2.push_back(currWord);\\n        \\n        //use two pointer approach \\n        // i always to the arr1 (longest) \\n        //j points to the arr2  (shortest)\\n        int start1=0;\\n        int start2=0;\\n        int end1=arr1.size()-1;\\n        int end2=arr2.size()-1;\\n         while(start1<=end1 && start2<=end2){\\n            if(arr1[start1]==arr2[start2]) //if crrent both starting words are same\\n                start1++,start2++;\\n            else if(arr1[end1]==arr2[end2]) //if the  current both ending words are same\\n                end1--,end2--;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Do upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        //store all the words in a vector of string \\n        vector<string> arr1;\\n        vector<string> arr2;\\n        \\n        //i want to keep a track of which sentence is longer and which sentence  is smaller\\n        //Because it would help me when i use two pointer approach\\n        \\n        string longest=sentence1;\\n        string shortest=sentence2;\\n        \\n        if(sentence1.length()<sentence2.length())\\n        {\\n            longest=sentence2;\\n            shortest=sentence1;\\n        }\\n        string currWord=\"\";\\n        for(int i=0;i<longest.length();i++)\\n        {\\n            if(longest[i]==\\' \\')\\n            {\\n                arr1.push_back(currWord);\\n                currWord=\"\";\\n                continue;\\n            }\\n            currWord.push_back(longest[i]);\\n        }\\n        //add the last word too\\n        arr1.push_back(currWord);\\n        \\n        //store the strings in sentence 2\\n        currWord=\"\";\\n        for(int i=0;i<shortest.length();i++)\\n        {\\n            if(shortest[i]==\\' \\')\\n            {\\n                arr2.push_back(currWord);\\n                currWord=\"\";\\n                continue;\\n            }\\n            currWord.push_back(shortest[i]);\\n        }\\n        arr2.push_back(currWord);\\n        \\n        //use two pointer approach \\n        // i always to the arr1 (longest) \\n        //j points to the arr2  (shortest)\\n        int start1=0;\\n        int start2=0;\\n        int end1=arr1.size()-1;\\n        int end2=arr2.size()-1;\\n         while(start1<=end1 && start2<=end2){\\n            if(arr1[start1]==arr2[start2]) //if crrent both starting words are same\\n                start1++,start2++;\\n            else if(arr1[end1]==arr2[end2]) //if the  current both ending words are same\\n                end1--,end2--;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145427,
                "title": "easy-c-explanation-deque",
                "content": "**Expalnation:** You have to add sustring between any of the one sentence such that both the sentence become equal.\\nEg : s1 = \"Hello CPP World\", s2 = \"Hello Wolrd\" then in this case we have to add *\"CPP\"* in the second sentence to make both of them equal.\\n\\n**Approach** is pretty simple we have to campare both the string from starting and from the ending. If both strings are equal from starting and ending then simply we will return true.\\nEx : s1 = \"My name is Haley\"\\n      s2 = \"My Haley\"\\n\\t  \\nForm above example you can see that both the strings are equal till *\"My\"* and from ending they are equal till *\"Halley\"*. So we can easily insert *\"name is\"* in s2 to make both of them equal.\\n\\nHence we will use **Deque** *(double ended queue in which deletion and insertion is possible from both end)*.\\n\\nIn this we will insert all the words from sentence1 and 2 in two different Deque. Then we will simply run the loop till Deque is not empty and both Deque has front word same. Again we will run loop now this time from backside. If at last anyone of the Deque become empty we will return true else false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n      deque<string> a,b;\\n      sentence1+=\\' \\', sentence2+=\\' \\';  \\n      string temp=\"\";  \\n\\t  \\n      for(int i=0; i<sentence1.length(); i++)\\n      {\\n        if(sentence1[i]==\\' \\') \\n        {\\n          a.push_back(temp);\\n          temp=\"\";  \\n        }\\n        else temp+=sentence1[i];  \\n      }\\n\\t  \\n      temp=\"\";  \\n      for(int i=0; i<sentence2.length(); i++)\\n      {\\n        if(sentence2[i]==\\' \\') \\n        {\\n          b.push_back(temp);\\n          temp=\"\";  \\n        }\\n        else temp+=sentence2[i];  \\n      }\\n\\t  \\n      while(a.size()&&b.size() && a.front()==b.front())  \\n            a.pop_front(), b.pop_front();\\n\\t\\t\\t\\n      while(a.size()&&b.size() && a.back()==b.back())  \\n            a.pop_back(), b.pop_back(); \\n\\t\\t\\t\\n      if(a.size()==0 || b.size()==0) return true;\\n      return false;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n      deque<string> a,b;\\n      sentence1+=\\' \\', sentence2+=\\' \\';  \\n      string temp=\"\";  \\n\\t  \\n      for(int i=0; i<sentence1.length(); i++)\\n      {\\n        if(sentence1[i]==\\' \\') \\n        {\\n          a.push_back(temp);\\n          temp=\"\";  \\n        }\\n        else temp+=sentence1[i];  \\n      }\\n\\t  \\n      temp=\"\";  \\n      for(int i=0; i<sentence2.length(); i++)\\n      {\\n        if(sentence2[i]==\\' \\') \\n        {\\n          b.push_back(temp);\\n          temp=\"\";  \\n        }\\n        else temp+=sentence2[i];  \\n      }\\n\\t  \\n      while(a.size()&&b.size() && a.front()==b.front())  \\n            a.pop_front(), b.pop_front();\\n\\t\\t\\t\\n      while(a.size()&&b.size() && a.back()==b.back())  \\n            a.pop_back(), b.pop_back(); \\n\\t\\t\\t\\n      if(a.size()==0 || b.size()==0) return true;\\n      return false;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160415,
                "title": "java-clean-concise-code-o-n-time-100-easy-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        \\n        if (sentence1.length () < sentence2.length ()) {\\n            return areSentencesSimilar (sentence2, sentence1);\\n        }\\n        \\n        String[] words1 = sentence1.split (\" \");\\n        String[] words2 = sentence2.split (\" \");\\n        \\n        int i = 0, j = words1.length - 1, k = words2.length - 1;\\n        \\n        while (i < words2.length && words1[i].equals (words2[i])) {\\n            i++;\\n        }\\n        \\n        while (k >= 0 && words1[j].equals (words2[k])) {\\n            j--;\\n            k--;\\n        }\\n        \\n        return i > k;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**HAPPY CODING :)\\nLOVE CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        \\n        if (sentence1.length () < sentence2.length ()) {\\n            return areSentencesSimilar (sentence2, sentence1);\\n        }\\n        \\n        String[] words1 = sentence1.split (\" \");\\n        String[] words2 = sentence2.split (\" \");\\n        \\n        int i = 0, j = words1.length - 1, k = words2.length - 1;\\n        \\n        while (i < words2.length && words1[i].equals (words2[i])) {\\n            i++;\\n        }\\n        \\n        while (k >= 0 && words1[j].equals (words2[k])) {\\n            j--;\\n            k--;\\n        }\\n        \\n        return i > k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140561,
                "title": "python-solution-with-4-pointers",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = sentence1.split()\\n        s2 = sentence2.split()\\n        l1,r1,l2,r2 = 0,len(s1)-1,0,len(s2)-1\\n        while l1<len(s1) and l2<len(s2) and s1[l1]==s2[l2]:\\n            l1, l2=l1+1, l2+1\\n        while r1>=0 and r2>=0 and s1[r1]==s2[r2]:\\n            r1,r2=r1-1,r2-1\\n        if l1==len(s1) or l2==len(s2) or r1==-1 or r2==-1 or l1>r1 or l2>r2:\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = sentence1.split()\\n        s2 = sentence2.split()\\n        l1,r1,l2,r2 = 0,len(s1)-1,0,len(s2)-1\\n        while l1<len(s1) and l2<len(s2) and s1[l1]==s2[l2]:\\n            l1, l2=l1+1, l2+1\\n        while r1>=0 and r2>=0 and s1[r1]==s2[r2]:\\n            r1,r2=r1-1,r2-1\\n        if l1==len(s1) or l2==len(s2) or r1==-1 or r2==-1 or l1>r1 or l2>r2:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140775,
                "title": "easy-to-understand-with-logic-o-n-java-c",
                "content": "**Logic And Explanation**\\nHere what we did is..\\n* We just make the first string larger, so that we can run the loop on the basis of smaller string\\n* Make 2 arrays consiting strings which are saperated by space (arrays of words)\\n* Now use 2 pointers (one from start and one from last)\\n* Now the limited conditions are \\n1. if first word are equal increment first pointers\\n2. if second word are equal increment second pointers\\n* In any other case, code should return false\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n\\t\\t// Just to make s1 always bigger in size\\n        if (s1.length() < s2.length()) {\\n            String temp = s1;\\n            s1 = s2;\\n            s2 = temp;\\n        }\\n\\t\\t// making array of every word\\n        String[] arr1 = s1.split(\" \");\\n        String[] arr2 = s2.split(\" \");\\n        int i1 = 0, i2 = 0, j1 = arr1.length - 1, j2 = arr2.length - 1;\\n\\t\\t\\n\\t\\t// iterating from start as well as from last\\n        while (i2 <= j2) {\\n            if (arr1[i1].equals(arr2[i1])) {\\n                i1++; \\n                i2++;\\n            } else if (arr1[j1].equals(arr2[j2])) {\\n                j1--;\\n                j2--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if (s1.size() < s2.size()) {\\n            string temp = s1;\\n            s1 = s2;\\n            s2 = temp;\\n        }\\n        vector<string> ar1;\\n        stringstream ss1(s1);\\n        string word;\\n        while (ss1 >> word) {\\n            ar1.push_back(word);\\n        }\\n        vector<string> ar2;\\n        stringstream ss2(s2);\\n        while (ss2 >> word) {\\n            ar2.push_back(word);\\n        }\\n        int i1 = 0, i2 = 0, j1 = ar1.size() - 1, j2 = ar2.size() - 1;\\n        while (i2 <= j2) {\\n            if (ar1[i1] == ar2[i2]) {\\n                i1++;\\n                i2++;\\n            } else if (ar1[j1] == ar2[j2]) {\\n                j1--;\\n                j2--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n\\t\\t// Just to make s1 always bigger in size\\n        if (s1.length() < s2.length()) {\\n            String temp = s1;\\n            s1 = s2;\\n            s2 = temp;\\n        }\\n\\t\\t// making array of every word\\n        String[] arr1 = s1.split(\" \");\\n        String[] arr2 = s2.split(\" \");\\n        int i1 = 0, i2 = 0, j1 = arr1.length - 1, j2 = arr2.length - 1;\\n\\t\\t\\n\\t\\t// iterating from start as well as from last\\n        while (i2 <= j2) {\\n            if (arr1[i1].equals(arr2[i1])) {\\n                i1++; \\n                i2++;\\n            } else if (arr1[j1].equals(arr2[j2])) {\\n                j1--;\\n                j2--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if (s1.size() < s2.size()) {\\n            string temp = s1;\\n            s1 = s2;\\n            s2 = temp;\\n        }\\n        vector<string> ar1;\\n        stringstream ss1(s1);\\n        string word;\\n        while (ss1 >> word) {\\n            ar1.push_back(word);\\n        }\\n        vector<string> ar2;\\n        stringstream ss2(s2);\\n        while (ss2 >> word) {\\n            ar2.push_back(word);\\n        }\\n        int i1 = 0, i2 = 0, j1 = ar1.size() - 1, j2 = ar2.size() - 1;\\n        while (i2 <= j2) {\\n            if (ar1[i1] == ar2[i2]) {\\n                i1++;\\n                i2++;\\n            } else if (ar1[j1] == ar2[j2]) {\\n                j1--;\\n                j2--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140510,
                "title": "python-3-simple-solution-with-picture-explanation",
                "content": "assmue ```s1``` is the shorter string\\n```len1, len2``` are the maximum length of substrings starting from each end of ```s2``` and equal to part of ```s1```.\\n```s1``` and ```s2``` is similar only when ```len1 + len2 >= len(s1)```\\n\\nTherefore we just use a pointer start from ```index = 0```, move pointer rightward until ```s1[index] != s2[index]```, this is the substring on left end of s2 which equals to left part of s1.\\nThen start from ```index = n - 1```, decrease the index until ```s1[index] != s2[index]```, this is the substing on the right end of s2. \\n\\n![image](https://assets.leetcode.com/users/images/e89089e6-22f1-4cf7-8966-dd62c40d1fe2_1617467501.322186.png)\\n\\n\\n\\n```\\ndef areSentencesSimilar(s1, s2):\\n    s1, s2 = s1.split(), s2.split()\\n    if len(s1) > len(s2):\\n        s1, s2 = s2, s1\\n    n, i, j = len(s1), 0, 1\\n    while i < n and s1[i] == s2[i]:\\n        i += 1\\n    while j < n + 1 and s1[-j] == s2[-j]:\\n        j += 1\\n    return i + j > n\\n```\\n",
                "solutionTags": [],
                "code": "```s1```\n```len1, len2```\n```s2```\n```s1```\n```s1```\n```s2```\n```len1 + len2 >= len(s1)```\n```index = 0```\n```s1[index] != s2[index]```\n```index = n - 1```\n```s1[index] != s2[index]```\n```\\ndef areSentencesSimilar(s1, s2):\\n    s1, s2 = s1.split(), s2.split()\\n    if len(s1) > len(s2):\\n        s1, s2 = s2, s1\\n    n, i, j = len(s1), 0, 1\\n    while i < n and s1[i] == s2[i]:\\n        i += 1\\n    while j < n + 1 and s1[-j] == s2[-j]:\\n        j += 1\\n    return i + j > n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1149136,
                "title": "c-self-explainatory",
                "content": "Put words of every sentence  in two diff vector of strings , and now count the equal stream of words if count becomes equal to the zero while checking the correct order of both the strings than return true otherwise false.\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        if(sentence1 == sentence2) return true;\\n        \\n        vector<string> a,b;\\n        int m = sentence1.size(),n = sentence2.size();\\n        \\n        for(int i=0;i<m;i++){\\n             string t;\\n             while(i<m && sentence1[i] != \\' \\'){\\n                    t += sentence1[i++];\\n             }\\n            if(t.size()){\\n                 a.push_back(t);\\n            }\\n        }\\n        \\n         for(int i=0;i<n;i++){\\n             string t;\\n             while(i<n && sentence2[i] != \\' \\'){\\n                    t += sentence2[i++];\\n             }\\n            if(t.size()){\\n                 b.push_back(t);\\n            }\\n        }\\n        int min_ = min(a.size(),b.size());\\n        int cnt = min_;\\n        \\n        int i = 0, j = 0;\\n        \\n        while(i<a.size() && j<b.size()){\\n              if(a[i] == b[j]){\\n                  cnt--;\\n                  i++; j++;\\n                 if(cnt == 0) return true;\\n              }\\n               else{\\n                      break;\\n               }\\n        }\\n        \\n        i = a.size()-1, j = b.size()-1;\\n        \\n        while(i>=0 && j>=0){\\n             if(a[i] == b[j]){\\n                 cnt--;\\n                 i--; j--;\\n                if(cnt == 0) return true;\\n             }\\n             else{\\n                   break;\\n             }\\n        }\\n        return cnt==0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        if(sentence1 == sentence2) return true;\\n        \\n        vector<string> a,b;\\n        int m = sentence1.size(),n = sentence2.size();\\n        \\n        for(int i=0;i<m;i++){\\n             string t;\\n             while(i<m && sentence1[i] != \\' \\'){\\n                    t += sentence1[i++];\\n             }\\n            if(t.size()){\\n                 a.push_back(t);\\n            }\\n        }\\n        \\n         for(int i=0;i<n;i++){\\n             string t;\\n             while(i<n && sentence2[i] != \\' \\'){\\n                    t += sentence2[i++];\\n             }\\n            if(t.size()){\\n                 b.push_back(t);\\n            }\\n        }\\n        int min_ = min(a.size(),b.size());\\n        int cnt = min_;\\n        \\n        int i = 0, j = 0;\\n        \\n        while(i<a.size() && j<b.size()){\\n              if(a[i] == b[j]){\\n                  cnt--;\\n                  i++; j++;\\n                 if(cnt == 0) return true;\\n              }\\n               else{\\n                      break;\\n               }\\n        }\\n        \\n        i = a.size()-1, j = b.size()-1;\\n        \\n        while(i>=0 && j>=0){\\n             if(a[i] == b[j]){\\n                 cnt--;\\n                 i--; j--;\\n                if(cnt == 0) return true;\\n             }\\n             else{\\n                   break;\\n             }\\n        }\\n        return cnt==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140606,
                "title": "java-clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] w1 = sentence1.split(\" \");\\n        String[] w2 = sentence2.split(\" \");\\n        if (w1.length > w2.length)\\n            return helper(w1, w2);\\n        else\\n            return helper(w2, w1);\\n    }\\n\\n    private boolean helper(String[] w1, String[] w2) {\\n        int s1 = 0, e1 = w1.length - 1;\\n        int s2 = 0, e2 = w2.length - 1;\\n        while (s2 <= e2 && w1[s1].equals(w2[s2])) {\\n            s1++;\\n            s2++;\\n        }\\n\\n        while (e2 >= s2 && w1[e1].equals(w2[e2])) {\\n            e1--;\\n            e2--;\\n        }\\n\\n        return s2 > e2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] w1 = sentence1.split(\" \");\\n        String[] w2 = sentence2.split(\" \");\\n        if (w1.length > w2.length)\\n            return helper(w1, w2);\\n        else\\n            return helper(w2, w1);\\n    }\\n\\n    private boolean helper(String[] w1, String[] w2) {\\n        int s1 = 0, e1 = w1.length - 1;\\n        int s2 = 0, e2 = w2.length - 1;\\n        while (s2 <= e2 && w1[s1].equals(w2[s2])) {\\n            s1++;\\n            s2++;\\n        }\\n\\n        while (e2 >= s2 && w1[e1].equals(w2[e2])) {\\n            e1--;\\n            e2--;\\n        }\\n\\n        return s2 > e2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140500,
                "title": "clean-python-3-greedy-o-s1-s2",
                "content": "Splite two sentences and greedy compare them from head and tail.\\nTime: `O(S1 + S2)`\\nSpace: `O(S1 + S2)`\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if len(sentence1) < len(sentence2): return self.areSentencesSimilar(sentence2, sentence1)\\n        if sentence1 == sentence2: return True\\n        s1, s2 = map(str.split, (sentence1, sentence2))\\n        i = 0\\n        while i < len(s2) and s1[i] == s2[i]:\\n            i += 1\\n        j = -1\\n        while j >= -len(s2) and s1[j] == s2[j]:\\n            j -= 1\\n        return (i - 1) - (j + 1) + 1 == len(s2)\\n ```\\n \\n Deque version\\n ```\\n import collections\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1, s2 = map(collections.deque, map(str.split, (sentence1, sentence2)))\\n        while s1 and s2 and s1[0] == s2[0]:\\n            s1.popleft()\\n            s2.popleft()\\n        while s1 and s2 and s1[-1] == s2[-1]:\\n            s1.pop()\\n            s2.pop()\\n        return not s1 or not s2\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if len(sentence1) < len(sentence2): return self.areSentencesSimilar(sentence2, sentence1)\\n        if sentence1 == sentence2: return True\\n        s1, s2 = map(str.split, (sentence1, sentence2))\\n        i = 0\\n        while i < len(s2) and s1[i] == s2[i]:\\n            i += 1\\n        j = -1\\n        while j >= -len(s2) and s1[j] == s2[j]:\\n            j -= 1\\n        return (i - 1) - (j + 1) + 1 == len(s2)\\n ```\n```\\n import collections\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1, s2 = map(collections.deque, map(str.split, (sentence1, sentence2)))\\n        while s1 and s2 and s1[0] == s2[0]:\\n            s1.popleft()\\n            s2.popleft()\\n        while s1 and s2 and s1[-1] == s2[-1]:\\n            s1.pop()\\n            s2.pop()\\n        return not s1 or not s2\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2786190,
                "title": "c-0ms-solution-using-deque",
                "content": "# Intuition\\nThe Idea is we start to iterate from front first till we dont encounter different words in both sentences (or dont reach to end of either sentence )\\n. Now similarly Iterate from back with above conditions.\\n\\n. If we have iterated through all words of either sentence the sentences will be similar\\n\\n# Approach\\nWe will implement the above intiution with Dequeue approach with following steps :\\n1. Store words from both sentences in two separate deques \\n2. Now iterate from start in both deques and if words re same in both deques pop them else stop.\\n3. Similarly from backside\\n4. If either of deque is empty return true .\\n\\n// Hope you understand this code well . Upvotes are appreciated . \\n\\n\\n# Complexity\\n- Time complexity: O(m+n)\\n\\n- Space complexity: O(m+n)\\n- Where m and n  are number of words in sentence 1 and sentence 2 respectively\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n         \\n        deque<string> s1 , s2;\\n\\n        for(int i = 0 ; i< sentence1.length() ; i++)\\n        {\\n           int j = i;\\n           string temp;\\n           while(j<sentence1.length() && sentence1[j]!= \\' \\')\\n           temp.push_back(sentence1[j++]);\\n           \\n           i = j;\\n           s1.push_back(temp);\\n        }\\n\\n        for(int i = 0 ; i< sentence2.length() ; i++)\\n        {\\n           int j = i;\\n           string temp;\\n           while(j<sentence2.length() && sentence2[j]!= \\' \\')\\n           temp.push_back(sentence2[j++]);\\n           \\n           i = j;\\n           s2.push_back(temp);\\n        }\\n\\n        int i = 0 ;\\n\\n        while(!s1.empty() && !s2.empty())\\n        {\\n            if(s1.front() != s2.front())\\n            break;\\n            \\n            s1.pop_front();\\n            s2.pop_front();\\n        }\\n\\n        while(!s1.empty() && !s2.empty())\\n        {\\n            if(s1.back() != s2.back())\\n            break;\\n            \\n            s1.pop_back();\\n            s2.pop_back();     \\n        }\\n        \\n        return (s1.empty() || s2.empty());\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n         \\n        deque<string> s1 , s2;\\n\\n        for(int i = 0 ; i< sentence1.length() ; i++)\\n        {\\n           int j = i;\\n           string temp;\\n           while(j<sentence1.length() && sentence1[j]!= \\' \\')\\n           temp.push_back(sentence1[j++]);\\n           \\n           i = j;\\n           s1.push_back(temp);\\n        }\\n\\n        for(int i = 0 ; i< sentence2.length() ; i++)\\n        {\\n           int j = i;\\n           string temp;\\n           while(j<sentence2.length() && sentence2[j]!= \\' \\')\\n           temp.push_back(sentence2[j++]);\\n           \\n           i = j;\\n           s2.push_back(temp);\\n        }\\n\\n        int i = 0 ;\\n\\n        while(!s1.empty() && !s2.empty())\\n        {\\n            if(s1.front() != s2.front())\\n            break;\\n            \\n            s1.pop_front();\\n            s2.pop_front();\\n        }\\n\\n        while(!s1.empty() && !s2.empty())\\n        {\\n            if(s1.back() != s2.back())\\n            break;\\n            \\n            s1.pop_back();\\n            s2.pop_back();     \\n        }\\n        \\n        return (s1.empty() || s2.empty());\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433186,
                "title": "easy-java-solution-faster-than-99-50",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] s1 = sentence1.split(\" \");\\n        String[] s2 = sentence2.split(\" \");\\n        int i = 0, j = 0;\\n        while (i < s1.length && j < s2.length){\\n            if (!s1[i].equals(s2[j])) break;\\n            i++;\\n            j++;\\n        }\\n            if (i == s1.length || j == s2.length) return true;\\n        int len1 = s1.length - 1, len2 = s2.length - 1;\\n        while(len1 >= i && len2 >= j){\\n            if(!s1[len1].equals(s2[len2])) return false;\\n            len1--;\\n            len2--;\\n        }\\n        return len1 < i || len2 < j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] s1 = sentence1.split(\" \");\\n        String[] s2 = sentence2.split(\" \");\\n        int i = 0, j = 0;\\n        while (i < s1.length && j < s2.length){\\n            if (!s1[i].equals(s2[j])) break;\\n            i++;\\n            j++;\\n        }\\n            if (i == s1.length || j == s2.length) return true;\\n        int len1 = s1.length - 1, len2 = s2.length - 1;\\n        while(len1 >= i && len2 >= j){\\n            if(!s1[len1].equals(s2[len2])) return false;\\n            len1--;\\n            len2--;\\n        }\\n        return len1 < i || len2 < j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509349,
                "title": "java-deque-solution",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        Deque<String> words1 = new ArrayDeque(Arrays.asList(sentence1.split(\" \")));\\n        Deque<String> words2 = new ArrayDeque(Arrays.asList(sentence2.split(\" \")));\\n        while(!words1.isEmpty() && !words2.isEmpty() && words1.peek().equals(words2.peek())) {\\n            words1.pollFirst();\\n            words2.pollFirst();\\n        }\\n        while(!words1.isEmpty() && !words2.isEmpty() && words1.peekLast().equals(words2.peekLast())) {\\n            words1.pollLast();\\n            words2.pollLast();\\n        }\\n        return words1.isEmpty() || words2.isEmpty();     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        Deque<String> words1 = new ArrayDeque(Arrays.asList(sentence1.split(\" \")));\\n        Deque<String> words2 = new ArrayDeque(Arrays.asList(sentence2.split(\" \")));\\n        while(!words1.isEmpty() && !words2.isEmpty() && words1.peek().equals(words2.peek())) {\\n            words1.pollFirst();\\n            words2.pollFirst();\\n        }\\n        while(!words1.isEmpty() && !words2.isEmpty() && words1.peekLast().equals(words2.peekLast())) {\\n            words1.pollLast();\\n            words2.pollLast();\\n        }\\n        return words1.isEmpty() || words2.isEmpty();     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140613,
                "title": "clear-python-3-implementation",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        words1, words2 = sentence1.split(), sentence2.split()\\n        n1, n2 = len(words1), len(words2)\\n        if n1 == n2:  return sentence1 == sentence2    # the two strings must be identical if their lengths are the same\\n        if words1[0] != words2[0] and words1[-1] != words2[-1]:  return False\\n        i = j = 0\\n        flag = False\\n        while i < n1 and j < n2:\\n            if words1[i] != words2[j]:\\n                if flag:  return False    # a mismatch had already been found before\\n                flag = True\\n                if n1 < n2:  \\n                    while j < n2 and words2[j] != words1[i]:  j += 1\\n                    if j == n2:  return False \\n                else:\\n                    while i < n1 and words1[i] != words2[j]:  i += 1\\n                    if i == n1:  return False\\n            i += 1\\n            j += 1\\n        return True if (not flag or i == n1 and j == n2) else False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        words1, words2 = sentence1.split(), sentence2.split()\\n        n1, n2 = len(words1), len(words2)\\n        if n1 == n2:  return sentence1 == sentence2    # the two strings must be identical if their lengths are the same\\n        if words1[0] != words2[0] and words1[-1] != words2[-1]:  return False\\n        i = j = 0\\n        flag = False\\n        while i < n1 and j < n2:\\n            if words1[i] != words2[j]:\\n                if flag:  return False    # a mismatch had already been found before\\n                flag = True\\n                if n1 < n2:  \\n                    while j < n2 and words2[j] != words1[i]:  j += 1\\n                    if j == n2:  return False \\n                else:\\n                    while i < n1 and words1[i] != words2[j]:  i += 1\\n                    if i == n1:  return False\\n            i += 1\\n            j += 1\\n        return True if (not flag or i == n1 and j == n2) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140610,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.equals(sentence2)) return true;\\n        \\n        String[] arr1=sentence1.split(\" \");\\n        String[] arr2=sentence2.split(\" \");\\n         \\n        if(arr1.length==arr2.length){\\n            return false;\\n        }else if(arr1.length>arr2.length){\\n            return helper(arr1,arr2);\\n        }else{\\n            return helper(arr2,arr1);\\n        }\\n    }\\n    \\n    private boolean helper(String[] arr1,String[] arr2){\\n        int i=0 , j=0;\\n         int mismatch=0;\\n        while(i<arr1.length && j<arr2.length){\\n            if(arr1[i].equals(arr2[j])){\\n            while(i<arr1.length && j<arr2.length && arr1[i].equals(arr2[j])){\\n                 i++;\\n                 j++;\\n            }\\n            }else if(!arr1[i].equals(arr2[j])){\\n                while(i<arr1.length){\\n                    if(arr1[i].equals(arr2[j])){\\n                        mismatch++;\\n                        break;\\n                    }\\n                    i++;\\n                }\\n            }\\n        }\\n        \\n        if(j==arr2.length && mismatch==0) return true;  //first half completly match\\n        else if(i==arr1.length && j==arr2.length && mismatch==1) return true;\\n        return false;\\n    }\\n    \\n   \\n}\\n```\\nComplexity: `Time:O(n) and Space:O(n)`\\n\\nPlease UPVOTE if found it helpful :)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.equals(sentence2)) return true;\\n        \\n        String[] arr1=sentence1.split(\" \");\\n        String[] arr2=sentence2.split(\" \");\\n         \\n        if(arr1.length==arr2.length){\\n            return false;\\n        }else if(arr1.length>arr2.length){\\n            return helper(arr1,arr2);\\n        }else{\\n            return helper(arr2,arr1);\\n        }\\n    }\\n    \\n    private boolean helper(String[] arr1,String[] arr2){\\n        int i=0 , j=0;\\n         int mismatch=0;\\n        while(i<arr1.length && j<arr2.length){\\n            if(arr1[i].equals(arr2[j])){\\n            while(i<arr1.length && j<arr2.length && arr1[i].equals(arr2[j])){\\n                 i++;\\n                 j++;\\n            }\\n            }else if(!arr1[i].equals(arr2[j])){\\n                while(i<arr1.length){\\n                    if(arr1[i].equals(arr2[j])){\\n                        mismatch++;\\n                        break;\\n                    }\\n                    i++;\\n                }\\n            }\\n        }\\n        \\n        if(j==arr2.length && mismatch==0) return true;  //first half completly match\\n        else if(i==arr1.length && j==arr2.length && mismatch==1) return true;\\n        return false;\\n    }\\n    \\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140524,
                "title": "java-simple",
                "content": "```\\npublic boolean areSentencesSimilar(String sentence1, String sentence2) {\\n\\tif(sentence2.length() > sentence1.length()) return areSentencesSimilar(sentence2, sentence1);\\n\\tString[] split1 = sentence1.split(\" \"), split2 = sentence2.split(\" \");\\n\\tint i=0, j=split1.length-1, k = split2.length-1;\\n\\tfor(;i<split2.length && split1[i].equals(split2[i]);i++);   // Match the first part\\n\\tfor(;i<=k && split1[j].equals(split2[k]);k--,j--);          // Match the last part\\n\\treturn i>k;                                                 // return true if sentence2 is matched completely\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean areSentencesSimilar(String sentence1, String sentence2) {\\n\\tif(sentence2.length() > sentence1.length()) return areSentencesSimilar(sentence2, sentence1);\\n\\tString[] split1 = sentence1.split(\" \"), split2 = sentence2.split(\" \");\\n\\tint i=0, j=split1.length-1, k = split2.length-1;\\n\\tfor(;i<split2.length && split1[i].equals(split2[i]);i++);   // Match the first part\\n\\tfor(;i<=k && split1[j].equals(split2[k]);k--,j--);          // Match the last part\\n\\treturn i>k;                                                 // return true if sentence2 is matched completely\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2795892,
                "title": "c-stringstream-simple-easy-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        stringstream ss1(s1);\\n        stringstream ss2(s2);\\n        vector<string>v1; vector<string>v2;\\n        string word;\\n        while(ss1>>word)\\n        {\\n            v1.push_back(word);\\n        }\\n        while(ss2>>word)\\n        {\\n            v2.push_back(word);\\n        }\\n        \\n        int n1=v1.size(); int n2=v2.size();\\n        int i=0; int j=0; \\n        while(i<n1 and j<n2)\\n        {\\n            if(v1[i]==v2[j])\\n            {\\n                i++; j++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        int index=i,index2=j;\\n        i=n1-1; j=n2-1;\\n        while(i>=index and j>=index2)\\n        {\\n            if(v1[i]==v2[j])\\n            {\\n                i--; j--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        stringstream ss1(s1);\\n        stringstream ss2(s2);\\n        vector<string>v1; vector<string>v2;\\n        string word;\\n        while(ss1>>word)\\n        {\\n            v1.push_back(word);\\n        }\\n        while(ss2>>word)\\n        {\\n            v2.push_back(word);\\n        }\\n        \\n        int n1=v1.size(); int n2=v2.size();\\n        int i=0; int j=0; \\n        while(i<n1 and j<n2)\\n        {\\n            if(v1[i]==v2[j])\\n            {\\n                i++; j++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        int index=i,index2=j;\\n        i=n1-1; j=n2-1;\\n        while(i>=index and j>=index2)\\n        {\\n            if(v1[i]==v2[j])\\n            {\\n                i--; j--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854744,
                "title": "java-explained-code-easy-to-understand",
                "content": "Kindly share suggestions to improve my solution\\n\\n```\\n    public static boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        \\n        \\n        if(sentence1.equals(sentence2)) return true;\\n        \\n        // we first begin by splitting the sentences in to arrays\\n        \\n        String[] sS1 = sentence1.split(\" \");\\n        \\n        String[] sS2 = sentence2.split(\" \");\\n        \\n        \\n        /* once we have split the arrays, we can run a loop\\n        to check if the words of the sentence match from either ends\\n        \\n        if they do, the middle part can be added to the other sentence\\n        and they can be called similar\\n        \\n        each sentence will have minimum one word \\n        so the index can start with 0\\n        \\n        what are the various cases here?\\n        the similar words lie at the edges\\n        \\n        the similar words lie in the middle\\n        */ \\n        \\n        int i = -1; // tracking similar words from the beginning\\n        int j = -1; // tracking similar words from the end\\n        \\n        int s = 0; // iterating from the start\\n        \\n        int e = 0; // iterating from the end\\n        \\n        // we need to start moving from the 0th index and check till the words\\n        // are common\\n        \\n        while(s <= Math.min(sS1.length-1, sS2.length -1) && sS1[s].equals(sS2[s])){\\n            s++;\\n            i++;\\n        }\\n        \\n        // similarly we start from the end\\n        while(e <=  Math.min(sS1.length-1, sS2.length -1) && sS1[sS1.length-1 - e].equals(sS2[sS2.length-1-e])){\\n            e ++;\\n            \\n        }\\n        \\n\\n        \\n        if(e > 0){\\n            j = e;\\n        }\\n        \\n        // System.out.println(i);\\n        // System.out.println(j);\\n        \\n        // so now we have the start and end sections where the words are similar\\n        \\n\\n        // any one string has only one word\\n        if((sS1.length == 1 || sS2.length == 1) && (i > -1 || j > -1 ) ){\\n            \\n            return true;\\n        }\\n        \\n        \\n        // if both the sentences have more than 1 word, we need to stick with checking both ends\\n        // also we need to check if there are no extra words between both the ends\\n        // on at least one of the sentence\\n        \\n        // there are matches from both sides\\n        else if(i != -1 && j != -1){\\n            \\n            // check if there are no extra words for at least one of the sentence\\n            // in between both the ends\\n            \\n            \\n            \\n            // start position = i\\n            // end position = j\\n            \\n            // one string has match and extra words in between\\n            if(i + 1 == sS1.length -j || i + 1 == sS2.length -j){\\n                return true;\\n            }\\n            \\n            \\n        }\\n        \\n        // match on any side extends entire length of string \\n        else if (s == sS1.length || s == sS2.length ||  e == sS1.length || e == sS2.length ){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n\\t```\\n\\t",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n    public static boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        \\n        \\n        if(sentence1.equals(sentence2)) return true;\\n        \\n        // we first begin by splitting the sentences in to arrays\\n        \\n        String[] sS1 = sentence1.split(\" \");\\n        \\n        String[] sS2 = sentence2.split(\" \");\\n        \\n        \\n        /* once we have split the arrays, we can run a loop\\n        to check if the words of the sentence match from either ends\\n        \\n        if they do, the middle part can be added to the other sentence\\n        and they can be called similar\\n        \\n        each sentence will have minimum one word \\n        so the index can start with 0\\n        \\n        what are the various cases here?\\n        the similar words lie at the edges\\n        \\n        the similar words lie in the middle\\n        */ \\n        \\n        int i = -1; // tracking similar words from the beginning\\n        int j = -1; // tracking similar words from the end\\n        \\n        int s = 0; // iterating from the start\\n        \\n        int e = 0; // iterating from the end\\n        \\n        // we need to start moving from the 0th index and check till the words\\n        // are common\\n        \\n        while(s <= Math.min(sS1.length-1, sS2.length -1) && sS1[s].equals(sS2[s])){\\n            s++;\\n            i++;\\n        }\\n        \\n        // similarly we start from the end\\n        while(e <=  Math.min(sS1.length-1, sS2.length -1) && sS1[sS1.length-1 - e].equals(sS2[sS2.length-1-e])){\\n            e ++;\\n            \\n        }\\n        \\n\\n        \\n        if(e > 0){\\n            j = e;\\n        }\\n        \\n        // System.out.println(i);\\n        // System.out.println(j);\\n        \\n        // so now we have the start and end sections where the words are similar\\n        \\n\\n        // any one string has only one word\\n        if((sS1.length == 1 || sS2.length == 1) && (i > -1 || j > -1 ) ){\\n            \\n            return true;\\n        }\\n        \\n        \\n        // if both the sentences have more than 1 word, we need to stick with checking both ends\\n        // also we need to check if there are no extra words between both the ends\\n        // on at least one of the sentence\\n        \\n        // there are matches from both sides\\n        else if(i != -1 && j != -1){\\n            \\n            // check if there are no extra words for at least one of the sentence\\n            // in between both the ends\\n            \\n            \\n            \\n            // start position = i\\n            // end position = j\\n            \\n            // one string has match and extra words in between\\n            if(i + 1 == sS1.length -j || i + 1 == sS2.length -j){\\n                return true;\\n            }\\n            \\n            \\n        }\\n        \\n        // match on any side extends entire length of string \\n        else if (s == sS1.length || s == sS2.length ||  e == sS1.length || e == sS2.length ){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461165,
                "title": "python3-easy-peezy-code-using-stack-crisp-and-clear",
                "content": "Dont use 2 pointers, use stack as everything works on words case sensitive\\n\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if len(sentence2)>len(sentence1):\\n            return self.areSentencesSimilar(sentence2,sentence1)\\n        sentence1=sentence1.split(\" \")\\n        sentence2=sentence2.split(\" \")\\n        s1=sentence1[:]\\n        s2=sentence2[:]\\n        while s1[0]==s2[0]:\\n                s1.pop(0)\\n                s2.pop(0)\\n                if not s2:\\n                    return True\\n        if not s2:\\n            return True\\n        while s1[-1]==s2[-1]:\\n                s1.pop()\\n                s2.pop()\\n                if not s2:\\n                    return True\\n        if not s2:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if len(sentence2)>len(sentence1):\\n            return self.areSentencesSimilar(sentence2,sentence1)\\n        sentence1=sentence1.split(\" \")\\n        sentence2=sentence2.split(\" \")\\n        s1=sentence1[:]\\n        s2=sentence2[:]\\n        while s1[0]==s2[0]:\\n                s1.pop(0)\\n                s2.pop(0)\\n                if not s2:\\n                    return True\\n        if not s2:\\n            return True\\n        while s1[-1]==s2[-1]:\\n                s1.pop()\\n                s2.pop()\\n                if not s2:\\n                    return True\\n        if not s2:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320004,
                "title": "easy-c-solution-faster-than-100-matching-prefixes-suffixes",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n          deque<string> d,q;\\n          string cur;\\n          for(char x : s1) {\\n               if(x==\\' \\') {\\n                   d.push_back(cur);\\n                   cur.clear();\\n               }else {\\n                   cur.push_back(x);\\n               }\\n          }\\n          d.push_back(cur);\\n          cur.clear();\\n          for(char x : s2) {\\n               if(x==\\' \\') {\\n                   q.push_back(cur);\\n                   cur.clear(); \\n               }else {\\n                   cur.push_back(x);\\n               }\\n          }\\n          q.push_back(cur);\\n          cur.clear();\\n          while(!d.empty() && !q.empty() && d.front()==q.front()) d.pop_front(),q.pop_front();\\n          while(!d.empty() && !q.empty() && d.back()==q.back()) d.pop_back(),q.pop_back();\\n          return (d.empty() || q.empty());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n          deque<string> d,q;\\n          string cur;\\n          for(char x : s1) {\\n               if(x==\\' \\') {\\n                   d.push_back(cur);\\n                   cur.clear();\\n               }else {\\n                   cur.push_back(x);\\n               }\\n          }\\n          d.push_back(cur);\\n          cur.clear();\\n          for(char x : s2) {\\n               if(x==\\' \\') {\\n                   q.push_back(cur);\\n                   cur.clear(); \\n               }else {\\n                   cur.push_back(x);\\n               }\\n          }\\n          q.push_back(cur);\\n          cur.clear();\\n          while(!d.empty() && !q.empty() && d.front()==q.front()) d.pop_front(),q.pop_front();\\n          while(!d.empty() && !q.empty() && d.back()==q.back()) d.pop_back(),q.pop_back();\\n          return (d.empty() || q.empty());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208631,
                "title": "easy-c-commented-code-faster-than-100-percent",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool areSentencesSimilar(string s1, string s2) {\\n\\t\\t\\tvector<string>first;\\n\\t\\t\\tvector<string>second;\\n\\t\\t\\tint n=s1.size();\\n\\t\\t\\tint m=s2.size();\\n\\t\\t\\tstring temp=\"\";\\n\\t\\t\\tfor(int i=0;i<n;i++)// for seperating the words of the given sentence\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s1[i]==32)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirst.push_back(temp);\\n\\t\\t\\t\\t\\ttemp=\"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp+=s1[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfirst.push_back(temp);\\n\\t\\t\\ttemp=\"\";\\n\\t\\t\\tfor(int i=0;i<m;i++)//for seperating the words of the given sentence\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s2[i]==32)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsecond.push_back(temp);\\n\\t\\t\\t\\t\\ttemp=\"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp+=s2[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsecond.push_back(temp);\\n\\t\\t\\tvector<string>lcp;\\n\\t\\t\\tvector<string>lcs;\\n\\t\\t\\tn=first.size();\\n\\t\\t\\tm=second.size();\\n\\t\\t\\tint i=0;\\n\\t\\t\\twhile(i<n&&i<m)// finding longest common prefix\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(first[i]==second[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlcp.push_back(first[i]);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ti=n-1;\\n\\t\\t\\tint j=m-1;\\n\\t\\t\\twhile(i>=0&&j>=0)// finding longest common suffix\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(first[i]==second[j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlcs.push_back(first[i]);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif((lcs.size()+lcp.size()>=second.size())||(lcs.size()+lcp.size()>=first.size()))// if sum of size of lcp and lcs >= anyone of the strings then there must be a possibility\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool areSentencesSimilar(string s1, string s2) {\\n\\t\\t\\tvector<string>first;\\n\\t\\t\\tvector<string>second;\\n\\t\\t\\tint n=s1.size();\\n\\t\\t\\tint m=s2.size();\\n\\t\\t\\tstring temp=\"\";\\n\\t\\t\\tfor(int i=0;i<n;i++)// for seperating the words of the given sentence\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s1[i]==32)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirst.push_back(temp);\\n\\t\\t\\t\\t\\ttemp=\"\";\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1154239,
                "title": "python-split-and-slicing",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = sentence1.split()\\n        s2 = sentence2.split()\\n        # let s1 be the shorter sequence\\n        if len(s1) > len(s2):\\n            s1,s2 = s2,s1\\n        # find the first index where they differ\\n        i = 0\\n        while i < len(s1):\\n            if s1[i] != s2[i]:\\n                break\\n            i += 1\\n        # check if the trailing part of s1 matches the end of s2\\n        return s1[i:] == s2[len(s2) - (len(s1) - i):]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = sentence1.split()\\n        s2 = sentence2.split()\\n        # let s1 be the shorter sequence\\n        if len(s1) > len(s2):\\n            s1,s2 = s2,s1\\n        # find the first index where they differ\\n        i = 0\\n        while i < len(s1):\\n            if s1[i] != s2[i]:\\n                break\\n            i += 1\\n        # check if the trailing part of s1 matches the end of s2\\n        return s1[i:] == s2[len(s2) - (len(s1) - i):]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152825,
                "title": "java-string",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if (sentence1.equals(sentence2)) return true;\\n        String longer = \"\"; String shorter = \"\";\\n        longer = sentence1.length() > sentence2.length() ? sentence1 : sentence2;\\n        shorter = sentence1.length() > sentence2.length() ? sentence2 : sentence1;\\n        \\n        String[] arrl = longer.split(\" \");\\n        String[] arrs = shorter.split(\" \");\\n        \\n        int i = 0, j = 0;\\n        int lenl = arrl.length, lens = arrs.length;\\n        while (i < lenl && i < lens && arrl[i].equals(arrs[i])) {\\n            i++;\\n        }\\n        \\n        while (lenl - 1 - j >= 0 && lens - 1 - j >= 0\\n               && arrl[lenl - 1 - j].equals(arrs[lens - 1 - j])) {\\n            j++;\\n        }\\n        \\n        //System.out.println(i + \" \" + j);\\n        if (i == 0 && j == 0) return false;\\n        if (i + j < arrs.length) return false;\\n        return true;\\n       \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if (sentence1.equals(sentence2)) return true;\\n        String longer = \"\"; String shorter = \"\";\\n        longer = sentence1.length() > sentence2.length() ? sentence1 : sentence2;\\n        shorter = sentence1.length() > sentence2.length() ? sentence2 : sentence1;\\n        \\n        String[] arrl = longer.split(\" \");\\n        String[] arrs = shorter.split(\" \");\\n        \\n        int i = 0, j = 0;\\n        int lenl = arrl.length, lens = arrs.length;\\n        while (i < lenl && i < lens && arrl[i].equals(arrs[i])) {\\n            i++;\\n        }\\n        \\n        while (lenl - 1 - j >= 0 && lens - 1 - j >= 0\\n               && arrl[lenl - 1 - j].equals(arrs[lens - 1 - j])) {\\n            j++;\\n        }\\n        \\n        //System.out.println(i + \" \" + j);\\n        if (i == 0 && j == 0) return false;\\n        if (i + j < arrs.length) return false;\\n        return true;\\n       \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141127,
                "title": "fully-explained-elegant-smart-clean-solution",
                "content": "\\nLet\\'s break it down:\\n1. If sentences are the same\\u200A-\\u200Athey are similar\\n2. If sentences don\\'t have a common prefix or don\\'t have a common suffix\\u200A-\\u200Athey are not similar\\n3. If either common prefix or common suffix equals one of the lengths of the sentences\\u200A-\\u200Athen they are similar!\\n4. If they have common prefix and common suffix, and one of the sentances can be build by the common_prefix+common_suffix\\u200A-\\u200Athen they are similiar!\\n\\n***Please upvote if you find the explanation helful! :)***\\n\\nCode:\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if sentence1 == sentence2:\\n            return True\\n        def longst_common_prefix(s1, s2):\\n            prefix = []\\n            for x1, x2 in zip(s1, s2):\\n                if x1 == x2:\\n                    prefix.append(x1)\\n                else:\\n                    break\\n            return prefix\\n        def longst_common_suffix(s1, s2):\\n            s1 = s1[::-1]\\n            s2 = s2[::-1]\\n            return longst_common_prefix(s1, s2)[::-1]\\n        words1 = sentence1.split(\\' \\')\\n        words2 = sentence2.split(\\' \\')\\n        common_prefix = longst_common_prefix(words1, words2)\\n        common_suffix = longst_common_suffix(words1, words2)\\n        def can_match(common_prefix, common_suffix, words1, words2):\\n            if not common_prefix and not common_suffix:\\n                return False\\n            sentances_lengts    = { len(words1), len(words2) }\\n            if len(common_prefix) in sentances_lengts:\\n                return True\\n            if len(common_suffix) in sentances_lengts:\\n                return True\\n            total_common_legnth = len(common_prefix) + len(common_suffix)\\n            return total_common_legnth in sentances_lengts\\n        return can_match(common_prefix, common_suffix, words1, words2)\\n```\\n\\nOther Solutions for LeetCode Biweekly Contest:\\n[1812. Determine Color of a Chessboard Square](https://leetcode.com/problems/determine-color-of-a-chessboard-square/discuss/1142388/Fully-Explained-Extremly-Fast-Beat-100-Elegant-Smart-Clean-Solution)\\n[1814. Count Nice Pairs in an Array](https://leetcode.com/problems/count-nice-pairs-in-an-array/discuss/1141121/fully-explained-extremly-fast-beat-100-elegant-smart-clean-solution)\\n[1815. Maximum Number of Groups Getting Fresh Donut](https://leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts/discuss/1141102/fully-explained-extremly-fast-beat-100-elegant-smart-clean-solution)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if sentence1 == sentence2:\\n            return True\\n        def longst_common_prefix(s1, s2):\\n            prefix = []\\n            for x1, x2 in zip(s1, s2):\\n                if x1 == x2:\\n                    prefix.append(x1)\\n                else:\\n                    break\\n            return prefix\\n        def longst_common_suffix(s1, s2):\\n            s1 = s1[::-1]\\n            s2 = s2[::-1]\\n            return longst_common_prefix(s1, s2)[::-1]\\n        words1 = sentence1.split(\\' \\')\\n        words2 = sentence2.split(\\' \\')\\n        common_prefix = longst_common_prefix(words1, words2)\\n        common_suffix = longst_common_suffix(words1, words2)\\n        def can_match(common_prefix, common_suffix, words1, words2):\\n            if not common_prefix and not common_suffix:\\n                return False\\n            sentances_lengts    = { len(words1), len(words2) }\\n            if len(common_prefix) in sentances_lengts:\\n                return True\\n            if len(common_suffix) in sentances_lengts:\\n                return True\\n            total_common_legnth = len(common_prefix) + len(common_suffix)\\n            return total_common_legnth in sentances_lengts\\n        return can_match(common_prefix, common_suffix, words1, words2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140573,
                "title": "c-solution-code-deque-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if(s1.size() < s2.size()) {\\n            string temp = s1;\\n            s1 = s2;\\n            s2 = temp;\\n        }\\n        if(s1.compare(s2) == 0) return 1;\\n        \\n        deque<string> words1, words2;\\n        \\n        int i = 0;\\n        \\n        while(i < s1.size()) {\\n            int j = i;\\n            while(j < s1.size() && s1[j] != \\' \\' ) {\\n                j++;\\n            }\\n            string temp = s1.substr(i, j-i);\\n            words1.push_back(temp);\\n            i = j+1;\\n        }\\n        \\n        i = 0;\\n        \\n        while(i < s2.size()) {\\n            int j = i;\\n            while(j < s2.size() && s2[j] != \\' \\' ) {\\n                j++;\\n            }\\n            string temp = s2.substr(i, j-i);\\n            words2.push_back(temp);\\n            i = j+1;\\n        }\\n        \\n        bool used = false;\\n        \\n        while(words1.size() && words2.size()) {\\n            if(words1.front().compare(words2.front()) == 0) {\\n                words1.pop_front();\\n                words2.pop_front();\\n                continue;\\n            }\\n            \\n            if(used) return false;\\n            \\n            while(words1.size() && words2.size() && words1.front().compare(words2.front()) && !used) {\\n                words2.push_front(words1.front());\\n                words1.pop_front();\\n                words2.pop_front();\\n            }\\n            \\n            used = 1;\\n            \\n        }\\n        \\n        if(words2.size() == 0 && !used) return true;\\n        \\n        if(words1.size() == 0 && words2.size() == 0) return true;\\n        \\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if(s1.size() < s2.size()) {\\n            string temp = s1;\\n            s1 = s2;\\n            s2 = temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3263050,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.length()==sentence2.length()){\\n            if(sentence1.equals(sentence2)) return true;\\n            else return false;\\n        }\\n        \\n        String[] arr1 = sentence1.split(\" \");\\n        String[] arr2 = sentence2.split(\" \");\\n        \\n        int l1 = arr1.length;  // l1 = length of the 1st array arr1.\\n        int l2 = arr2.length;  // l2 = length of the 2st array arr2.\\n        \\n        int f1 =0, f2 =0;        // f1 and f2 are the front of the array arr1 and arr2;\\n        int b1 =l1-1, b2 = l2-1; // b1 and b2 are the back of the array arr1 and arr2;\\n        \\n        // If the front element of both array are equal we delete them and increment the front.\\n        while(l1!=0 && l2!=0 && arr1[f1].equals(arr2[f2])){\\n            l1--;\\n            l2--;\\n            f1++;\\n            f2++;\\n        }\\n        \\n        // If the back element of both array are equal we delete them and decrement the back.\\n        while(l1!=0 && l2!=0 && arr1[b1].equals(arr2[b2])){\\n            l1--;\\n            l2--;\\n            b1--;\\n            b2--;\\n        }\\n        \\n        return l1==0 || l2==0;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.length()==sentence2.length()){\\n            if(sentence1.equals(sentence2)) return true;\\n            else return false;\\n        }\\n        \\n        String[] arr1 = sentence1.split(\" \");\\n        String[] arr2 = sentence2.split(\" \");\\n        \\n        int l1 = arr1.length;  // l1 = length of the 1st array arr1.\\n        int l2 = arr2.length;  // l2 = length of the 2st array arr2.\\n        \\n        int f1 =0, f2 =0;        // f1 and f2 are the front of the array arr1 and arr2;\\n        int b1 =l1-1, b2 = l2-1; // b1 and b2 are the back of the array arr1 and arr2;\\n        \\n        // If the front element of both array are equal we delete them and increment the front.\\n        while(l1!=0 && l2!=0 && arr1[f1].equals(arr2[f2])){\\n            l1--;\\n            l2--;\\n            f1++;\\n            f2++;\\n        }\\n        \\n        // If the back element of both array are equal we delete them and decrement the back.\\n        while(l1!=0 && l2!=0 && arr1[b1].equals(arr2[b2])){\\n            l1--;\\n            l2--;\\n            b1--;\\n            b2--;\\n        }\\n        \\n        return l1==0 || l2==0;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975932,
                "title": "easy-cpp-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        deque<string> a,b;\\n        string temp;\\n        for(char c:s1){\\n            if(c==\\' \\'){\\n                a.push_back(temp);\\n                temp=\"\";\\n                continue;\\n        }\\n        temp.push_back(c);\\n        }\\n        a.push_back(temp);\\n        temp=\"\";\\n        for(char c:s2){\\n            if(c==\\' \\'){\\n                b.push_back(temp);\\n                temp=\"\";\\n                continue;\\n        }\\n        temp.push_back(c);\\n        }\\n        b.push_back(temp);\\n    while(a.size()!=0&&b.size()!=0&&a[0]==b[0]){\\n        a.pop_front();\\n        b.pop_front();\\n    }\\n    while(a.size()!=0&&b.size()!=0&&a[a.size()-1]==b[b.size()-1]){\\n        a.pop_back();\\n        b.pop_back();\\n    }\\n    if(a.size()==0||b.size()==0)return true;\\n    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        deque<string> a,b;\\n        string temp;\\n        for(char c:s1){\\n            if(c==\\' \\'){\\n                a.push_back(temp);\\n                temp=\"\";\\n                continue;\\n        }\\n        temp.push_back(c);\\n        }\\n        a.push_back(temp);\\n        temp=\"\";\\n        for(char c:s2){\\n            if(c==\\' \\'){\\n                b.push_back(temp);\\n                temp=\"\";\\n                continue;\\n        }\\n        temp.push_back(c);\\n        }\\n        b.push_back(temp);\\n    while(a.size()!=0&&b.size()!=0&&a[0]==b[0]){\\n        a.pop_front();\\n        b.pop_front();\\n    }\\n    while(a.size()!=0&&b.size()!=0&&a[a.size()-1]==b[b.size()-1]){\\n        a.pop_back();\\n        b.pop_back();\\n    }\\n    if(a.size()==0||b.size()==0)return true;\\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806079,
                "title": "c",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Sentence Similarity III.\\nMemory Usage: 5.7 MB, less than 100.00% of C online submissions for Sentence Similarity III.\\n```\\nbool cmpStr(char* s1, char* s2){\\n    int i;\\n    int n1 = strlen(s1);\\n    int n2 = strlen(s2);\\n    for(i = 0; i < n1; i++){\\n        if(s1[i] != s2[i])\\n            break;\\n    }\\n    if(i == n1 && s2[i] == \\' \\')\\n        return true;\\n    i--;\\n    while(i >= 0  && s2[i] != \\' \\'){\\n        i--;\\n    }    \\n    i = fmax(0, i);\\n    printf(\"i = %d \", i);\\n    int d = 1;\\n    for(int j = n1-1; j >= i; j--){\\n        if(s1[j] != s2[n2-d])\\n            return false;\\n        if(j == i){\\n            if(i == 0){\\n                if(s2[n2 - d - 1] != \\' \\')\\n                    return false;\\n            }\\n            else\\n                if(s2[n2 - d ] != \\' \\')\\n                    return false;\\n        }\\n        d++;\\n    }\\n    return true;\\n}\\nbool areSentencesSimilar(char * sentence1, char * sentence2){\\n    int n1 = strlen(sentence1);\\n    int n2 = strlen(sentence2);\\n    if(n1 == n2){\\n        for(int i = 0; i < n1; i++){\\n            if(sentence1[i] != sentence2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    if(n1 < n2)\\n        return cmpStr(sentence1, sentence2);\\n    else\\n        return cmpStr(sentence2, sentence1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool cmpStr(char* s1, char* s2){\\n    int i;\\n    int n1 = strlen(s1);\\n    int n2 = strlen(s2);\\n    for(i = 0; i < n1; i++){\\n        if(s1[i] != s2[i])\\n            break;\\n    }\\n    if(i == n1 && s2[i] == \\' \\')\\n        return true;\\n    i--;\\n    while(i >= 0  && s2[i] != \\' \\'){\\n        i--;\\n    }    \\n    i = fmax(0, i);\\n    printf(\"i = %d \", i);\\n    int d = 1;\\n    for(int j = n1-1; j >= i; j--){\\n        if(s1[j] != s2[n2-d])\\n            return false;\\n        if(j == i){\\n            if(i == 0){\\n                if(s2[n2 - d - 1] != \\' \\')\\n                    return false;\\n            }\\n            else\\n                if(s2[n2 - d ] != \\' \\')\\n                    return false;\\n        }\\n        d++;\\n    }\\n    return true;\\n}\\nbool areSentencesSimilar(char * sentence1, char * sentence2){\\n    int n1 = strlen(sentence1);\\n    int n2 = strlen(sentence2);\\n    if(n1 == n2){\\n        for(int i = 0; i < n1; i++){\\n            if(sentence1[i] != sentence2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    if(n1 < n2)\\n        return cmpStr(sentence1, sentence2);\\n    else\\n        return cmpStr(sentence2, sentence1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658714,
                "title": "java-easy-solution-3-ms-faster-than-44-74-but-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.length()==sentence2.length()){\\n            if(sentence1.equals(sentence2)) return true;\\n            else return false;\\n        }\\n        \\n        String[] arr1 = sentence1.split(\" \");\\n        String[] arr2 = sentence2.split(\" \");\\n        \\n        int l1 = arr1.length;  // l1 = length of the 1st array arr1.\\n        int l2 = arr2.length;  // l2 = length of the 2st array arr2.\\n        \\n        int f1 =0, f2 =0;        // f1 and f2 are the front of the array arr1 and arr2;\\n        int b1 =l1-1, b2 = l2-1; // b1 and b2 are the back of the array arr1 and arr2;\\n        \\n        // If the front element of both array are equal we delete them and increment the front.\\n        while(l1!=0 && l2!=0 && arr1[f1].equals(arr2[f2])){\\n            l1--;\\n            l2--;\\n            f1++;\\n            f2++;\\n        }\\n        \\n        // If the back element of both array are equal we delete them and decrement the back.\\n        while(l1!=0 && l2!=0 && arr1[b1].equals(arr2[b2])){\\n            l1--;\\n            l2--;\\n            b1--;\\n            b2--;\\n        }\\n        \\n        return l1==0 || l2==0;  \\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/0b6fa1ef-fcd4-45cb-8265-073c5055d0a2_1664866502.2099135.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.length()==sentence2.length()){\\n            if(sentence1.equals(sentence2)) return true;\\n            else return false;\\n        }\\n        \\n        String[] arr1 = sentence1.split(\" \");\\n        String[] arr2 = sentence2.split(\" \");\\n        \\n        int l1 = arr1.length;  // l1 = length of the 1st array arr1.\\n        int l2 = arr2.length;  // l2 = length of the 2st array arr2.\\n        \\n        int f1 =0, f2 =0;        // f1 and f2 are the front of the array arr1 and arr2;\\n        int b1 =l1-1, b2 = l2-1; // b1 and b2 are the back of the array arr1 and arr2;\\n        \\n        // If the front element of both array are equal we delete them and increment the front.\\n        while(l1!=0 && l2!=0 && arr1[f1].equals(arr2[f2])){\\n            l1--;\\n            l2--;\\n            f1++;\\n            f2++;\\n        }\\n        \\n        // If the back element of both array are equal we delete them and decrement the back.\\n        while(l1!=0 && l2!=0 && arr1[b1].equals(arr2[b2])){\\n            l1--;\\n            l2--;\\n            b1--;\\n            b2--;\\n        }\\n        \\n        return l1==0 || l2==0;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608426,
                "title": "c-easy-to-understand-short-code",
                "content": "**Approach:**  Start erasing word matches from front and back and then check if any of the string is empty\\n\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        stringstream take1(sentence1),take2(sentence2);\\n        string word;\\n        deque<string> q1,q2;\\n        while(take1>>word)q1.push_back(word);\\n        while(take2>>word)q2.push_back(word);\\n        \\n        while(q1.size() and q2.size() and q1.back() == q2.back())\\n                    q1.pop_back(),q2.pop_back();\\n        while(q1.size() and q2.size() and q1.front() == q2.front())\\n                    q1.pop_front(),q2.pop_front();\\n        \\n        return q1.empty() or q2.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        stringstream take1(sentence1),take2(sentence2);\\n        string word;\\n        deque<string> q1,q2;\\n        while(take1>>word)q1.push_back(word);\\n        while(take2>>word)q2.push_back(word);\\n        \\n        while(q1.size() and q2.size() and q1.back() == q2.back())\\n                    q1.pop_back(),q2.pop_back();\\n        while(q1.size() and q2.size() and q1.front() == q2.front())\\n                    q1.pop_front(),q2.pop_front();\\n        \\n        return q1.empty() or q2.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577936,
                "title": "typescript-solution-with-stacks",
                "content": "\\n\\n```\\nfunction areSentencesSimilar(sentence1: string, sentence2: string): boolean {\\n    const shorter = (sentence1.length > sentence2.length ? sentence2 : sentence1).split(\" \")\\n    const longer = (sentence1.length > sentence2.length ? sentence1 : sentence2).split(\" \")\\n    \\n    while (shorter.length) {\\n        if (shorter[0] === longer[0]) {\\n            shorter.shift()\\n            longer.shift()\\n        } else if (shorter[shorter.length - 1] === longer[longer.length - 1]) {\\n            shorter.pop()\\n            longer.pop()\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction areSentencesSimilar(sentence1: string, sentence2: string): boolean {\\n    const shorter = (sentence1.length > sentence2.length ? sentence2 : sentence1).split(\" \")\\n    const longer = (sentence1.length > sentence2.length ? sentence1 : sentence2).split(\" \")\\n    \\n    while (shorter.length) {\\n        if (shorter[0] === longer[0]) {\\n            shorter.shift()\\n            longer.shift()\\n        } else if (shorter[shorter.length - 1] === longer[longer.length - 1]) {\\n            shorter.pop()\\n            longer.pop()\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2473028,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if len(sentence1)<len(sentence2):\\n            sentence1,sentence2=sentence2,sentence1\\n        a=sentence1.split()\\n        b=sentence2.split()\\n        l=0\\n        h=-1\\n        while l<len(b) and a[l]==b[l]:\\n            l+=1\\n        while -len(b)<=h and a[h]==b[h]:\\n            h-=1\\n        return l-h-1>=len(b)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if len(sentence1)<len(sentence2):\\n            sentence1,sentence2=sentence2,sentence1\\n        a=sentence1.split()\\n        b=sentence2.split()\\n        l=0\\n        h=-1\\n        while l<len(b) and a[l]==b[l]:\\n            l+=1\\n        while -len(b)<=h and a[h]==b[h]:\\n            h-=1\\n        return l-h-1>=len(b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067203,
                "title": "c-deque-solution-string-simple-easy-clean-code",
                "content": "**C++ Approach :**\\n```\\n\\tbool areSentencesSimilar(string sentence1, string sentence2) \\n    {\\n        deque<string> dq1;\\n        string s=\"\";\\n        for(char c:sentence1)\\n        {\\n            if(c==\\' \\')\\n            { \\n                dq1.push_back(s);\\n                s=\"\";\\n            }\\n            else\\n                s+=c;\\n        }\\n        dq1.push_back(s);\\n        \\n        s=\"\";\\n        deque<string> dq2;\\n        for(char c:sentence2)\\n        {\\n            if(c==\\' \\')\\n            { \\n                dq2.push_back(s);\\n                s=\"\";\\n            }\\n            else\\n                s+=c;\\n        }\\n        dq2.push_back(s);\\n        \\n        if(dq1.size()>dq2.size())\\n        {\\n            while(!dq2.empty())\\n            {\\n                if(dq2.front()==dq1.front())\\n                {\\n                    dq1.pop_front();\\n                    dq2.pop_front();\\n                }\\n                else if(dq2.back()==dq1.back())\\n                {\\n                    dq1.pop_back();\\n                    dq2.pop_back();\\n                }\\n                else\\n                    return false;    \\n            }\\n        }\\n        else\\n        {\\n            while(!dq1.empty())\\n            {\\n                if(dq1.front()==dq2.front())\\n                {\\n                    dq2.pop_front();\\n                    dq1.pop_front();\\n                }\\n                else if(dq1.back()==dq2.back())\\n                {\\n                    dq2.pop_back();\\n                    dq1.pop_back();\\n                }\\n                else\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Queue"
                ],
                "code": "```\\n\\tbool areSentencesSimilar(string sentence1, string sentence2) \\n    {\\n        deque<string> dq1;\\n        string s=\"\";\\n        for(char c:sentence1)\\n        {\\n            if(c==\\' \\')\\n            { \\n                dq1.push_back(s);\\n                s=\"\";\\n            }\\n            else\\n                s+=c;\\n        }\\n        dq1.push_back(s);\\n        \\n        s=\"\";\\n        deque<string> dq2;\\n        for(char c:sentence2)\\n        {\\n            if(c==\\' \\')\\n            { \\n                dq2.push_back(s);\\n                s=\"\";\\n            }\\n            else\\n                s+=c;\\n        }\\n        dq2.push_back(s);\\n        \\n        if(dq1.size()>dq2.size())\\n        {\\n            while(!dq2.empty())\\n            {\\n                if(dq2.front()==dq1.front())\\n                {\\n                    dq1.pop_front();\\n                    dq2.pop_front();\\n                }\\n                else if(dq2.back()==dq1.back())\\n                {\\n                    dq1.pop_back();\\n                    dq2.pop_back();\\n                }\\n                else\\n                    return false;    \\n            }\\n        }\\n        else\\n        {\\n            while(!dq1.empty())\\n            {\\n                if(dq1.front()==dq2.front())\\n                {\\n                    dq2.pop_front();\\n                    dq1.pop_front();\\n                }\\n                else if(dq1.back()==dq2.back())\\n                {\\n                    dq2.pop_back();\\n                    dq1.pop_back();\\n                }\\n                else\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1924212,
                "title": "python3-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        arr1=sentence1.split(\\' \\')\\n        arr2=sentence2.split(\\' \\')\\n        while arr1 and arr2 and arr1[-1]==arr2[-1]:\\n            arr1.pop()\\n            arr2.pop()\\n        arr1.reverse()\\n        arr2.reverse()\\n        while arr1 and arr2 and arr1[-1]==arr2[-1]:\\n            arr1.pop()\\n            arr2.pop()\\n        return not arr1 or not arr2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        arr1=sentence1.split(\\' \\')\\n        arr2=sentence2.split(\\' \\')\\n        while arr1 and arr2 and arr1[-1]==arr2[-1]:\\n            arr1.pop()\\n            arr2.pop()\\n        arr1.reverse()\\n        arr2.reverse()\\n        while arr1 and arr2 and arr1[-1]==arr2[-1]:\\n            arr1.pop()\\n            arr2.pop()\\n        return not arr1 or not arr2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646346,
                "title": "go",
                "content": "```\\nfunc areSentencesSimilar(sentence1 string, sentence2 string) bool {\\n    if len(sentence1) < len(sentence2) {\\n        return areSentencesSimilar(sentence2, sentence1)\\n    }\\n    a := strings.Split(sentence1, \" \")\\n    b := strings.Split(sentence2, \" \")\\n    \\n    ib, jb := 0, len(b) - 1\\n    ia, ja := 0, len(a) - 1\\n    for ib <= jb {\\n        if b[ib] == a[ia] {\\n            ib++\\n            ia++\\n        } else if b[jb] == a[ja] {\\n            jb--\\n            ja--\\n        } else {\\n            break\\n        }\\n    }\\n    return ib > jb\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc areSentencesSimilar(sentence1 string, sentence2 string) bool {\\n    if len(sentence1) < len(sentence2) {\\n        return areSentencesSimilar(sentence2, sentence1)\\n    }\\n    a := strings.Split(sentence1, \" \")\\n    b := strings.Split(sentence2, \" \")\\n    \\n    ib, jb := 0, len(b) - 1\\n    ia, ja := 0, len(a) - 1\\n    for ib <= jb {\\n        if b[ib] == a[ia] {\\n            ib++\\n            ia++\\n        } else if b[jb] == a[ja] {\\n            jb--\\n            ja--\\n        } else {\\n            break\\n        }\\n    }\\n    return ib > jb\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600095,
                "title": "simple-two-stack-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        stack1 = deque(sentence1.split(\" \"))\\n        stack2 = deque(sentence2.split(\" \"))  \\n        while (stack1 and stack2):\\n            if stack1[0] == stack2[0] or stack1[-1] == stack2[-1]:\\n                if stack1[0] == stack2[0]:\\n                    stack1.popleft()\\n                    stack2.popleft()\\n                else:\\n                    stack1.pop()\\n                    stack2.pop()\\n            else:\\n                return False\\n            \\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        stack1 = deque(sentence1.split(\" \"))\\n        stack2 = deque(sentence2.split(\" \"))  \\n        while (stack1 and stack2):\\n            if stack1[0] == stack2[0] or stack1[-1] == stack2[-1]:\\n                if stack1[0] == stack2[0]:\\n                    stack1.popleft()\\n                    stack2.popleft()\\n                else:\\n                    stack1.pop()\\n                    stack2.pop()\\n            else:\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553043,
                "title": "python3-o-n-solution-faster-than-100",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, s1: str, s2: str) -> bool:\\n        if len(s2) > len(s1): s1, s2 = s2, s1\\n        if s1 == s2: return True\\n        \\n        arr1, arr2 = collections.deque(s1.split()), collections.deque(s2.split())\\n        while arr1 and arr2:\\n            if arr1[0] == arr2[0]:\\n                arr1.popleft()\\n                arr2.popleft()\\n            elif arr1[-1] == arr2[-1]:\\n                arr1.pop()\\n                arr2.pop()\\n            else:\\n                break\\n        else:\\n            return True if not len(arr2) else False\\n        return False\\n```\\nRuntime: 16 ms\\nMemory Usage: 14.3 MB",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, s1: str, s2: str) -> bool:\\n        if len(s2) > len(s1): s1, s2 = s2, s1\\n        if s1 == s2: return True\\n        \\n        arr1, arr2 = collections.deque(s1.split()), collections.deque(s2.split())\\n        while arr1 and arr2:\\n            if arr1[0] == arr2[0]:\\n                arr1.popleft()\\n                arr2.popleft()\\n            elif arr1[-1] == arr2[-1]:\\n                arr1.pop()\\n                arr2.pop()\\n            else:\\n                break\\n        else:\\n            return True if not len(arr2) else False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486115,
                "title": "java-solution-inspired-by-youtuber-fisher-coder",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] words1 =  sentence1.split(\" \");\\n        String[] words2 =  sentence2.split(\" \");\\n        int l1 = words1.length;\\n        int l2 = words2.length;\\n        int count = l1 < l2 ? l1 : l2;\\n        \\n        for (int i = 0,j = 0; i < l1 && j < l2; i++,j++ ) {\\n            if (words1[i].equals(words2[j])) {\\n                count--;\\n                if (count == 0) return true;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        for (int i = l1 -1, j = l2 -1; i>=0 && j>=0; i--, j--) {\\n            if (words1[i].equals(words2[j])) {\\n                count--;\\n                if (count == 0) return true;\\n            } else {\\n                break;\\n            }\\n        }\\n        return count == 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] words1 =  sentence1.split(\" \");\\n        String[] words2 =  sentence2.split(\" \");\\n        int l1 = words1.length;\\n        int l2 = words2.length;\\n        int count = l1 < l2 ? l1 : l2;\\n        \\n        for (int i = 0,j = 0; i < l1 && j < l2; i++,j++ ) {\\n            if (words1[i].equals(words2[j])) {\\n                count--;\\n                if (count == 0) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1350633,
                "title": "find-prefix-and-suffix-of-lists",
                "content": "Runtime: 32 ms, faster than 60.23%\\nMemory Usage: 14.3 MB, less than 50.38%\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        lst1, lst2 = sentence1.split(\" \"), sentence2.split(\" \")\\n        for i, (a, b) in enumerate(zip(lst1, lst2)):\\n            if a != b:\\n                prefix = i\\n                break\\n        else:\\n            return True\\n        for i, (a, b) in enumerate(zip(lst1[::-1], lst2[::-1])):\\n            if a != b:\\n                suffix = i\\n                break\\n        else:\\n            return True\\n        return prefix + suffix in (len(lst1), len(lst2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        lst1, lst2 = sentence1.split(\" \"), sentence2.split(\" \")\\n        for i, (a, b) in enumerate(zip(lst1, lst2)):\\n            if a != b:\\n                prefix = i\\n                break\\n        else:\\n            return True\\n        for i, (a, b) in enumerate(zip(lst1[::-1], lst2[::-1])):\\n            if a != b:\\n                suffix = i\\n                break\\n        else:\\n            return True\\n        return prefix + suffix in (len(lst1), len(lst2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308369,
                "title": "c-solution-0ms-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2)\\n    {\\n        if(s1==s2)return true;\\n        int i1=0,i2=0;\\n        int left=0,right=0;\\n        int count=0;\\n        int i=0;\\n        while(i<s2.length())\\n        {\\n            if(s2[i]==\\' \\'){i++;count++;continue;}\\n            i++;\\n        }\\n        count++;\\n        while(i1<s1.length()&&i2<s2.length())\\n        {\\n            string word1=\"\";\\n            while(i1<s1.length())\\n            {\\n                if(s1[i1]==\\' \\')break;\\n                word1+=s1[i1];\\n                i1++;\\n            }\\n            i1++;\\n            string word2=\"\";\\n            while(i2<s2.length())\\n            {\\n                if(s2[i2]==\\' \\')break;\\n                word2+=s2[i2];\\n                i2++;\\n            }\\n            i2++;\\n            if(word1!=word2)break;\\n            left++;\\n        }\\n        i1=s1.length()-1;\\n        i2=s2.length()-1;\\n        while(i1>=0&&i2>=0)\\n        {\\n            string word1=\"\";\\n            while(i1>=0)\\n            {\\n                if(s1[i1]==\\' \\')break;\\n                word1+=s1[i1];\\n                i1--;\\n            }\\n            i1--;\\n            string word2=\"\";\\n            while(i2>=0)\\n            {\\n                if(s2[i2]==\\' \\')break;\\n                word2+=s2[i2];\\n                i2--;\\n            }\\n            i2--;\\n            if(word1!=word2)break;\\n            right++;\\n        }\\n        if(left+right==count||count==1&&(left==1||right==1))return true;\\n        \\n        \\n        \\n        \\n        \\n        swap(s1,s2);\\n        i1=0,i2=0;\\n         left=0,right=0;\\n         count=0;\\n         i=0;\\n        while(i<s2.length())\\n        {\\n            if(s2[i]==\\' \\'){i++;count++;continue;}\\n            i++;\\n        }\\n        count++;\\n        while(i1<s1.length()&&i2<s2.length())\\n        {\\n            string word1=\"\";\\n            while(i1<s1.length())\\n            {\\n                if(s1[i1]==\\' \\')break;\\n                word1+=s1[i1];\\n                i1++;\\n            }\\n            i1++;\\n            string word2=\"\";\\n            while(i2<s2.length())\\n            {\\n                if(s2[i2]==\\' \\')break;\\n                word2+=s2[i2];\\n                i2++;\\n            }\\n            i2++;\\n            if(word1!=word2)break;\\n            left++;\\n        }\\n        i1=s1.length()-1;\\n        i2=s2.length()-1;\\n        while(i1>=0&&i2>=0)\\n        {\\n            string word1=\"\";\\n            while(i1>=0)\\n            {\\n                if(s1[i1]==\\' \\')break;\\n                word1+=s1[i1];\\n                i1--;\\n            }\\n            i1--;\\n            string word2=\"\";\\n            while(i2>=0)\\n            {\\n                if(s2[i2]==\\' \\')break;\\n                word2+=s2[i2];\\n                i2--;\\n            }\\n            i2--;\\n            if(word1!=word2)break;\\n            right++;\\n        }\\n        if(left+right==count||count==1&&(left==1||right==1))return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2)\\n    {\\n        if(s1==s2)return true;\\n        int i1=0,i2=0;\\n        int left=0,right=0;\\n        int count=0;\\n        int i=0;\\n        while(i<s2.length())\\n        {\\n            if(s2[i]==\\' \\'){i++;count++;continue;}\\n            i++;\\n        }\\n        count++;\\n        while(i1<s1.length()&&i2<s2.length())\\n        {\\n            string word1=\"\";\\n            while(i1<s1.length())\\n            {\\n                if(s1[i1]==\\' \\')break;\\n                word1+=s1[i1];\\n                i1++;\\n            }\\n            i1++;\\n            string word2=\"\";\\n            while(i2<s2.length())\\n            {\\n                if(s2[i2]==\\' \\')break;\\n                word2+=s2[i2];\\n                i2++;\\n            }\\n            i2++;\\n            if(word1!=word2)break;\\n            left++;\\n        }\\n        i1=s1.length()-1;\\n        i2=s2.length()-1;\\n        while(i1>=0&&i2>=0)\\n        {\\n            string word1=\"\";\\n            while(i1>=0)\\n            {\\n                if(s1[i1]==\\' \\')break;\\n                word1+=s1[i1];\\n                i1--;\\n            }\\n            i1--;\\n            string word2=\"\";\\n            while(i2>=0)\\n            {\\n                if(s2[i2]==\\' \\')break;\\n                word2+=s2[i2];\\n                i2--;\\n            }\\n            i2--;\\n            if(word1!=word2)break;\\n            right++;\\n        }\\n        if(left+right==count||count==1&&(left==1||right==1))return true;\\n        \\n        \\n        \\n        \\n        \\n        swap(s1,s2);\\n        i1=0,i2=0;\\n         left=0,right=0;\\n         count=0;\\n         i=0;\\n        while(i<s2.length())\\n        {\\n            if(s2[i]==\\' \\'){i++;count++;continue;}\\n            i++;\\n        }\\n        count++;\\n        while(i1<s1.length()&&i2<s2.length())\\n        {\\n            string word1=\"\";\\n            while(i1<s1.length())\\n            {\\n                if(s1[i1]==\\' \\')break;\\n                word1+=s1[i1];\\n                i1++;\\n            }\\n            i1++;\\n            string word2=\"\";\\n            while(i2<s2.length())\\n            {\\n                if(s2[i2]==\\' \\')break;\\n                word2+=s2[i2];\\n                i2++;\\n            }\\n            i2++;\\n            if(word1!=word2)break;\\n            left++;\\n        }\\n        i1=s1.length()-1;\\n        i2=s2.length()-1;\\n        while(i1>=0&&i2>=0)\\n        {\\n            string word1=\"\";\\n            while(i1>=0)\\n            {\\n                if(s1[i1]==\\' \\')break;\\n                word1+=s1[i1];\\n                i1--;\\n            }\\n            i1--;\\n            string word2=\"\";\\n            while(i2>=0)\\n            {\\n                if(s2[i2]==\\' \\')break;\\n                word2+=s2[i2];\\n                i2--;\\n            }\\n            i2--;\\n            if(word1!=word2)break;\\n            right++;\\n        }\\n        if(left+right==count||count==1&&(left==1||right==1))return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303187,
                "title": "c-elegant-easy-to-understand-4ms",
                "content": "- first split both the sentences into words.\\n- make sure that the first vector has more words than second one (swap if not). \\n- find the index `i` till which both the sentences have common words\\n- iterate from the back and find the index `j` till which both the sentences have common words from back\\n- if `j < i` i.e if the sentence 2 can be formed by picking from words from the start of s1 and end of s2 then `return true`\\n\\n`NOTE: I did a small optimisation after finding i, it is not necessary`\\n\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        // general: some part of s2 is at front of s1 and some part is at back of s1\\n        \\n        // splitting the strings into vector of words\\n        vector <string> words1, words2;\\n        stringstream iss1(sentence1);\\n        stringstream iss2(sentence2);\\n        string temp;\\n        while (iss1 >> temp) words1.push_back(temp);\\n        while (iss2 >> temp) words2.push_back(temp);\\n        if (words1.size() < words2.size()) swap(words1, words2);\\n        int n1 = words1.size();\\n        int n2 = words2.size();\\n        \\n        \\n        int i = 0;\\n        while (i < n1 && i < n2 && words1[i] == words2[i]) ++i;\\n        if (i == n2) return true;\\n        \\n        // till the index i, s1 and s2 share a common suffix\\n        \\n        int j1 = n1 - 1;\\n        int j2 = n2 - 1;\\n        while (j1 >= 0 && j2 >= 0 && words1[j1] == words2[j2]) {\\n            --j1;\\n            --j2;\\n        }\\n        \\n        return j2 < i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        // general: some part of s2 is at front of s1 and some part is at back of s1\\n        \\n        // splitting the strings into vector of words\\n        vector <string> words1, words2;\\n        stringstream iss1(sentence1);\\n        stringstream iss2(sentence2);\\n        string temp;\\n        while (iss1 >> temp) words1.push_back(temp);\\n        while (iss2 >> temp) words2.push_back(temp);\\n        if (words1.size() < words2.size()) swap(words1, words2);\\n        int n1 = words1.size();\\n        int n2 = words2.size();\\n        \\n        \\n        int i = 0;\\n        while (i < n1 && i < n2 && words1[i] == words2[i]) ++i;\\n        if (i == n2) return true;\\n        \\n        // till the index i, s1 and s2 share a common suffix\\n        \\n        int j1 = n1 - 1;\\n        int j2 = n2 - 1;\\n        while (j1 >= 0 && j2 >= 0 && words1[j1] == words2[j2]) {\\n            --j1;\\n            --j2;\\n        }\\n        \\n        return j2 < i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292690,
                "title": "c-100-time-88-space",
                "content": "```\\n/*\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Sentence Similarity III.\\nMemory Usage: 6.3 MB, less than 88.76% of C++ online submissions for Sentence Similarity III.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    inline int get_left_index_match(string s1, string s2) {\\n        // check the common suffix (words) and return the index of the last space of this common suffix\\n        int i=0;\\n        int last_space = -1;\\n        while (i<s1.size()) {\\n            if (s1[i] != s2[i])\\n                return last_space;  // discard the partial matching word\\n            if (s1[i] == \\' \\')\\n                last_space = i;\\n            ++i;\\n        }\\n        \\n        // s1 completely matches with the s1\\n        if (s2[i] == \\' \\')   // if the last word of s1 was also a word in s2 or was it partial word \\n            return i;\\n        \\n        return last_space;\\n    }\\n    \\n    inline bool if_right_match(string s1, string s2, int left_i) {\\n        int i, j;\\n        for (i=s1.size()-1, j=s2.size()-1; i>left_i; --i, --j) {\\n            if(s1[i] != s2[j]){\\n                //cout << \" \" << i;\\n                return false;\\n            }\\n        }\\n        \\n        return s2[j] == \\' \\';\\n    }\\n    \\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        if (sentence1.size() > sentence2.size())\\n            return areSentencesSimilar(sentence2, sentence1);\\n        if (sentence1.size() == sentence2.size())\\n            return sentence1 == sentence2;\\n        \\n        // 1 is smaller than 2\\n        int left_i = get_left_index_match(sentence1, sentence2);\\n        //cout << left_i;\\n        if (left_i == sentence1.size())\\n            return true;\\n        \\n        return if_right_match(sentence1, sentence2, left_i);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Sentence Similarity III.\\nMemory Usage: 6.3 MB, less than 88.76% of C++ online submissions for Sentence Similarity III.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    inline int get_left_index_match(string s1, string s2) {\\n        // check the common suffix (words) and return the index of the last space of this common suffix\\n        int i=0;\\n        int last_space = -1;\\n        while (i<s1.size()) {\\n            if (s1[i] != s2[i])\\n                return last_space;  // discard the partial matching word\\n            if (s1[i] == \\' \\')\\n                last_space = i;\\n            ++i;\\n        }\\n        \\n        // s1 completely matches with the s1\\n        if (s2[i] == \\' \\')   // if the last word of s1 was also a word in s2 or was it partial word \\n            return i;\\n        \\n        return last_space;\\n    }\\n    \\n    inline bool if_right_match(string s1, string s2, int left_i) {\\n        int i, j;\\n        for (i=s1.size()-1, j=s2.size()-1; i>left_i; --i, --j) {\\n            if(s1[i] != s2[j]){\\n                //cout << \" \" << i;\\n                return false;\\n            }\\n        }\\n        \\n        return s2[j] == \\' \\';\\n    }\\n    \\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        if (sentence1.size() > sentence2.size())\\n            return areSentencesSimilar(sentence2, sentence1);\\n        if (sentence1.size() == sentence2.size())\\n            return sentence1 == sentence2;\\n        \\n        // 1 is smaller than 2\\n        int left_i = get_left_index_match(sentence1, sentence2);\\n        //cout << left_i;\\n        if (left_i == sentence1.size())\\n            return true;\\n        \\n        return if_right_match(sentence1, sentence2, left_i);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1266519,
                "title": "5-line-java-code-2-pointer",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] arr1 = sentence1.split(\" \"), arr2 = sentence2.split(\" \");\\n        int s1 =0, e1 = arr1.length-1, s2 = 0, e2 = arr2.length-1;\\n        for(;s1<=e1 && s2<=e2 && arr1[s1].equals(arr2[s2]);s1++,s2++);\\n        for(;e1>=0 && e2>=0 && arr1[e1].equals( arr2[e2]); e1--,e2--);\\n        return s1>e1 || s2>e2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] arr1 = sentence1.split(\" \"), arr2 = sentence2.split(\" \");\\n        int s1 =0, e1 = arr1.length-1, s2 = 0, e2 = arr2.length-1;\\n        for(;s1<=e1 && s2<=e2 && arr1[s1].equals(arr2[s2]);s1++,s2++);\\n        for(;e1>=0 && e2>=0 && arr1[e1].equals( arr2[e2]); e1--,e2--);\\n        return s1>e1 || s2>e2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256329,
                "title": "python-o-n-deque-clean-code-remove-any-prefix-remove-any-suffix-you-get-a-subarray",
                "content": "what is a subarray? -> remove any prefix & remove any suffix you get a subarray!!\\n\\nAfter removing the prefix and suffix, atleast one sentence i.e. `THE CONTAINER`  will become size 0 ;)\\n\\n\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = deque(sentence1.split(\\' \\'))\\n        s2 = deque(sentence2.split(\\' \\'))\\n        \\n        while s1 and s2 and s1[0] == s2[0]:\\n            s1.popleft()\\n            s2.popleft()\\n        \\n        while s1 and s2 and s1[-1] == s2[-1]:\\n            s1.pop()\\n            s2.pop()\\n        \\n        return len(s1)==0 or len(s2) == 0\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = deque(sentence1.split(\\' \\'))\\n        s2 = deque(sentence2.split(\\' \\'))\\n        \\n        while s1 and s2 and s1[0] == s2[0]:\\n            s1.popleft()\\n            s2.popleft()\\n        \\n        while s1 and s2 and s1[-1] == s2[-1]:\\n            s1.pop()\\n            s2.pop()\\n        \\n        return len(s1)==0 or len(s2) == 0\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234813,
                "title": "c-1813-sentence-similarity-iii",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        if (size(sentence1) < size(sentence2)) swap(sentence1, sentence2); \\n        \\n        vector<string> words1, words2; \\n        \\n        string word; \\n        istringstream iss1(sentence1); \\n        while (iss1 >> word) words1.push_back(word); \\n        \\n        istringstream iss2(sentence2); \\n        while (iss2 >> word) words2.push_back(word); \\n        \\n        int i = 0; \\n        for (; i < size(words2) && words1[i] == words2[i]; ++i); \\n        int j = size(words2)-1;\\n        for (; 0 <= j && words1[size(words1)-size(words2)+j] == words2[j]; --j); \\n        return j < i; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        if (size(sentence1) < size(sentence2)) swap(sentence1, sentence2); \\n        \\n        vector<string> words1, words2; \\n        \\n        string word; \\n        istringstream iss1(sentence1); \\n        while (iss1 >> word) words1.push_back(word); \\n        \\n        istringstream iss2(sentence2); \\n        while (iss2 >> word) words2.push_back(word); \\n        \\n        int i = 0; \\n        for (; i < size(words2) && words1[i] == words2[i]; ++i); \\n        int j = size(words2)-1;\\n        for (; 0 <= j && words1[size(words1)-size(words2)+j] == words2[j]; --j); \\n        return j < i; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233459,
                "title": "java-clean-o-1-space-solution-no-substring-no-split",
                "content": "I really believe we should do more than just solve it naively. Here I want to mention two approaches that I particularly not enjoy:\\n1. Split by space at the beginning\\n2. Use two-pointers but doing substring multiple times\\n\\nWe are able to finish this question without these practice by simply using two-pointer. If you have a more elegant solution, please comment at below so that I may improve my code: \\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        int n1 = sentence1.length();\\n        int n2 = sentence2.length();\\n        \\n        int l1 = 0, r1 = n1 - 1;\\n        int l2 = 0, r2 = n2 - 1;\\n        \\n        // match from left\\n        while (l1 < n1 && l2 < n2) {\\n            char c1 = sentence1.charAt(l1);\\n            char c2 = sentence2.charAt(l2);\\n\\n            if (c1 != c2) break;\\n\\n            l1++;\\n            l2++;\\n        }\\n        \\n        // matching process is ended bacuase we run out of words \\n        if (l1 == n1 && l2 == n2) return true;\\n        else if (l1 == n1) {\\n             if (sentence2.charAt(l2) == \\' \\') return true;\\n        } else if (l2 == n2) {\\n             if (sentence1.charAt(l1) == \\' \\') return true;\\n        }\\n        \\n        // backtrace to the start of non-matching word from the left\\n        while (l1 > 0 && sentence1.charAt(l1-1) != \\' \\') l1--;\\n        while (l2 > 0 && sentence2.charAt(l2-1) != \\' \\') l2--;\\n\\n      \\n     \\n        \\n        // match from right\\n        while (r1 >= l1 && r2 >= l2) {\\n            char c1 = sentence1.charAt(r1);\\n            char c2 = sentence2.charAt(r2);\\n            \\n            if (c1 != c2) break;\\n\\n            r1--;\\n            r2--;\\n        }\\n        \\n        // matching process is ended bacuase we run out of words \\n        if (r1 < l1 && r2 < l2) return true;\\n        else if (r1 < l1) {\\n             if (sentence2.charAt(r2) == \\' \\') return true;\\n        } else if (r2 < l2) {\\n             if (sentence1.charAt(r1) == \\' \\') return true;\\n        }\\n        \\n        // backtrace to the start of non-matching word from the right\\n        while (r1 < n1-1 && sentence1.charAt(r1+1) != \\' \\') r1++;\\n        while (r2 < n2-1 && sentence2.charAt(r2+1) != \\' \\') r2++;\\n\\n        \\n        return l1 > r1 || l2 > r2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        int n1 = sentence1.length();\\n        int n2 = sentence2.length();\\n        \\n        int l1 = 0, r1 = n1 - 1;\\n        int l2 = 0, r2 = n2 - 1;\\n        \\n        // match from left\\n        while (l1 < n1 && l2 < n2) {\\n            char c1 = sentence1.charAt(l1);\\n            char c2 = sentence2.charAt(l2);\\n\\n            if (c1 != c2) break;\\n\\n            l1++;\\n            l2++;\\n        }\\n        \\n        // matching process is ended bacuase we run out of words \\n        if (l1 == n1 && l2 == n2) return true;\\n        else if (l1 == n1) {\\n             if (sentence2.charAt(l2) == \\' \\') return true;\\n        } else if (l2 == n2) {\\n             if (sentence1.charAt(l1) == \\' \\') return true;\\n        }\\n        \\n        // backtrace to the start of non-matching word from the left\\n        while (l1 > 0 && sentence1.charAt(l1-1) != \\' \\') l1--;\\n        while (l2 > 0 && sentence2.charAt(l2-1) != \\' \\') l2--;\\n\\n      \\n     \\n        \\n        // match from right\\n        while (r1 >= l1 && r2 >= l2) {\\n            char c1 = sentence1.charAt(r1);\\n            char c2 = sentence2.charAt(r2);\\n            \\n            if (c1 != c2) break;\\n\\n            r1--;\\n            r2--;\\n        }\\n        \\n        // matching process is ended bacuase we run out of words \\n        if (r1 < l1 && r2 < l2) return true;\\n        else if (r1 < l1) {\\n             if (sentence2.charAt(r2) == \\' \\') return true;\\n        } else if (r2 < l2) {\\n             if (sentence1.charAt(r1) == \\' \\') return true;\\n        }\\n        \\n        // backtrace to the start of non-matching word from the right\\n        while (r1 < n1-1 && sentence1.charAt(r1+1) != \\' \\') r1++;\\n        while (r2 < n2-1 && sentence2.charAt(r2+1) != \\' \\') r2++;\\n\\n        \\n        return l1 > r1 || l2 > r2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231385,
                "title": "simple-c-solution-using-deque-100-faster",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        deque<string>v1,v2;\\n        string temp=\"\";\\n        for(auto u: s1)\\n        {\\n            if(u==\\' \\') {v1.push_back(temp); temp=\"\"; }\\n            else temp+=u;\\n        }\\n        v1.push_back(temp);\\n        temp=\"\";\\n        for(auto u: s2)\\n        {\\n            if(u==\\' \\') {v2.push_back(temp); temp=\"\"; }\\n            else temp+=u;\\n        }\\n        v2.push_back(temp);\\n        while(!v1.empty()&&!v2.empty()) //removing common word from startin\\n        {\\n            if(v1.front()==v2.front()) v1.pop_front(),v2.pop_front();\\n            else break;\\n        }\\n        while(!v1.empty()&&!v2.empty()) //removing common word from ending\\n        {\\n            if(v1.back()==v2.back()) v1.pop_back(),v2.pop_back();\\n            else break;\\n        }\\n\\t\\t\\t//after removing starting and ending common word if we find one of the deque is empty than result is true otherwise result is false\\n        if(v1.empty()||v2.empty()) return true;  \\n        else return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        deque<string>v1,v2;\\n        string temp=\"\";\\n        for(auto u: s1)\\n        {\\n            if(u==\\' \\') {v1.push_back(temp); temp=\"\"; }\\n            else temp+=u;\\n        }\\n        v1.push_back(temp);\\n        temp=\"\";\\n        for(auto u: s2)\\n        {\\n            if(u==\\' \\') {v2.push_back(temp); temp=\"\"; }\\n            else temp+=u;\\n        }\\n        v2.push_back(temp);\\n        while(!v1.empty()&&!v2.empty()) //removing common word from startin\\n        {\\n            if(v1.front()==v2.front()) v1.pop_front(),v2.pop_front();\\n            else break;\\n        }\\n        while(!v1.empty()&&!v2.empty()) //removing common word from ending\\n        {\\n            if(v1.back()==v2.back()) v1.pop_back(),v2.pop_back();\\n            else break;\\n        }\\n\\t\\t\\t//after removing starting and ending common word if we find one of the deque is empty than result is true otherwise result is false\\n        if(v1.empty()||v2.empty()) return true;  \\n        else return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156892,
                "title": "python-deque",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = sentence1.split()\\n        s2 = sentence2.split()\\n        \\n        s1 = collections.deque(s1)\\n        s2 = collections.deque(s2)\\n        \\n        while len(s1)>0 and len(s2)>0:\\n            if s1[0] == s2[0]:\\n                s1.popleft()\\n                s2.popleft()\\n            else:\\n                break\\n                \\n        while len(s1)>0 and len(s2)>0:\\n            if s1[-1] == s2[-1]:\\n                s1.pop()\\n                s2.pop()\\n            else:\\n                break\\n        \\n        return len(s1) == 0 or len(s2) == 0\\n                \\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = sentence1.split()\\n        s2 = sentence2.split()\\n        \\n        s1 = collections.deque(s1)\\n        s2 = collections.deque(s2)\\n        \\n        while len(s1)>0 and len(s2)>0:\\n            if s1[0] == s2[0]:\\n                s1.popleft()\\n                s2.popleft()\\n            else:\\n                break\\n                \\n        while len(s1)>0 and len(s2)>0:\\n            if s1[-1] == s2[-1]:\\n                s1.pop()\\n                s2.pop()\\n            else:\\n                break\\n        \\n        return len(s1) == 0 or len(s2) == 0\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147141,
                "title": "go-simple-solution",
                "content": "```go\\nimport \"reflect\"\\n\\nfunc areSentencesSimilar(sentence1 string, sentence2 string) bool {\\n    s, l := strings.Fields(sentence1), strings.Fields(sentence2)\\n    if len(s) > len(l) {\\n        s, l = l, s\\n    }\\n    for i := range s {\\n        if s[i] == l[i] {\\n            continue\\n        }\\n        return reflect.DeepEqual(s[i:], l[i+len(l)-len(s):])\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nimport \"reflect\"\\n\\nfunc areSentencesSimilar(sentence1 string, sentence2 string) bool {\\n    s, l := strings.Fields(sentence1), strings.Fields(sentence2)\\n    if len(s) > len(l) {\\n        s, l = l, s\\n    }\\n    for i := range s {\\n        if s[i] == l[i] {\\n            continue\\n        }\\n        return reflect.DeepEqual(s[i:], l[i+len(l)-len(s):])\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1142012,
                "title": "c-solution-using-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) \\n    {\\n        vector<string>v1,v2;\\n        istringstream ss(s1);\\n        string str1;\\n        while(ss>>str1)\\n        {\\n            v1.push_back(str1);\\n        }\\n        istringstream sss(s2);\\n        string str2;\\n        while(sss>>str2)\\n        {\\n            v2.push_back(str2);\\n        }\\n        int l1,l2,r1,r2;\\n        l1=l2=0;\\n        r1=v1.size()-1;\\n        r2=v2.size()-1;\\n        while(l1<=r1&&l2<=r2)\\n        {\\n            if(v1[l1]==v2[l2])\\n            {\\n                l1++;\\n                l2++;\\n            }\\n            else if(v1[r1]==v2[r2])\\n            {\\n                r1--;\\n                r2--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) \\n    {\\n        vector<string>v1,v2;\\n        istringstream ss(s1);\\n        string str1;\\n        while(ss>>str1)\\n        {\\n            v1.push_back(str1);\\n        }\\n        istringstream sss(s2);\\n        string str2;\\n        while(sss>>str2)\\n        {\\n            v2.push_back(str2);\\n        }\\n        int l1,l2,r1,r2;\\n        l1=l2=0;\\n        r1=v1.size()-1;\\n        r2=v2.size()-1;\\n        while(l1<=r1&&l2<=r2)\\n        {\\n            if(v1[l1]==v2[l2])\\n            {\\n                l1++;\\n                l2++;\\n            }\\n            else if(v1[r1]==v2[r2])\\n            {\\n                r1--;\\n                r2--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140901,
                "title": "python3-simple-two-pointers-solution",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        str1 = sentence1.split(\" \")\\n        str2 = sentence2.split(\" \")\\n        def check(s1, s2):\\n            j = 0\\n            n = len(s1)\\n            m = len(s2)\\n            cnt = 0\\n            for i in range(n):\\n                if j == m:\\n                    return cnt == 0\\n                elif s1[i] == s2[j]:\\n                    if cnt == 1:\\n                        cnt += 1\\n                    j += 1\\n                elif cnt == 0:\\n                    cnt += 1\\n                elif cnt == 2:\\n                    return False\\n            return j == m\\n        return check(str1, str2) or check(str2, str1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        str1 = sentence1.split(\" \")\\n        str2 = sentence2.split(\" \")\\n        def check(s1, s2):\\n            j = 0\\n            n = len(s1)\\n            m = len(s2)\\n            cnt = 0\\n            for i in range(n):\\n                if j == m:\\n                    return cnt == 0\\n                elif s1[i] == s2[j]:\\n                    if cnt == 1:\\n                        cnt += 1\\n                    j += 1\\n                elif cnt == 0:\\n                    cnt += 1\\n                elif cnt == 2:\\n                    return False\\n            return j == m\\n        return check(str1, str2) or check(str2, str1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140796,
                "title": "java-solution-array-approach-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        \\n        \\n         \\n        int l1 = sentence1.length();\\n        int l2 = sentence2.length();\\n            \\n            \\n        int l = 0;\\n        \\n        \\n        String[] bigger;\\n        String[] small;\\n        \\n        if(l1>l2){\\n            \\n             bigger = sentence1.split(\" \");\\n             small = sentence2.split(\" \");\\n            \\n            \\n        }else{\\n            \\n            bigger = sentence2.split(\" \");\\n            small = sentence1.split(\" \");\\n            \\n        }\\n        \\n        \\n        \\n        HashSet<String> h = new HashSet<String>();\\n        \\n        for(String s:bigger){\\n            h.add(s);\\n        }\\n        \\n        for(String s:small){\\n            if(!h.contains(s)){\\n                return false;\\n            }\\n        }\\n        \\n        int r = bigger.length;\\n        \\n        boolean arr[] = new boolean[r];\\n        \\n        \\n        \\n       int i = 0;\\n        int j=0;\\n        \\n        \\n        while(i<bigger.length){\\n            \\n            if(j==small.length){\\n                arr[i++] = false;\\n                continue;\\n            }\\n            if(small[j].equals(bigger[i])){\\n                arr[i] = true;\\n                i++;\\n                j++;\\n            }else{\\n                \\n                arr[i] = false;\\n                i++;\\n            }\\n            \\n            \\n            \\n        }\\n          \\n       \\n        int flag = 0;\\n        \\n        for(int u = 0;u<arr.length;u++){\\n            \\n            System.out.print(arr[u]+\" \");\\n            \\n        }\\n        System.out.println();\\n        \\n        int allFalse =0;\\n        \\n        for(int g = 0;g<arr.length;g++){\\n            \\n            if(arr[g]==false)\\n                allFalse++;\\n            \\n        }\\n        \\n        if(allFalse==arr.length)\\n            return false;\\n        \\n        \\n        for(int l4=0;l4<arr.length-1;l4++){\\n            \\n            if(arr[l4]==false && arr[l4+1]==true){\\n                \\n                flag++;\\n                \\n            }\\n            \\n            if(flag==1 && arr[l4+1]!=true)\\n                return false;\\n            \\n        }\\n        \\n        return flag<=1;\\n        \\n        \\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        \\n        \\n         \\n        int l1 = sentence1.length();\\n        int l2 = sentence2.length();\\n            \\n            \\n        int l = 0;\\n        \\n        \\n        String[] bigger;\\n        String[] small;\\n        \\n        if(l1>l2){\\n            \\n             bigger = sentence1.split(\" \");\\n             small = sentence2.split(\" \");\\n            \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1140705,
                "title": "o-n-c-solution",
                "content": "``` \\nclass Solution {\\npublic:\\n    bool ans; \\n    void solve(string a, string b){\\n        \\n        int i,j,k; \\n        vector<string>s; \\n        \\n        i=0; \\n        \\n        while(i<a.size())\\n        {\\n            \\n            if(a[i]==\\' \\')\\n            {\\n                i++;  \\n                continue;  \\n            }\\n            \\n            string x; \\n            \\n            while(i<a.size() &&  a[i]!=\\' \\'){\\n                x+=a[i]; \\n                i++;  \\n            }\\n            \\n            s.push_back(x); \\n        }\\n        \\n        i=0; \\n        j=0; \\n        int insert=0; \\n        \\n        while(i<b.size())\\n        {\\n            \\n            if(b[i] == \\' \\')\\n            {\\n                i++; \\n                continue;  \\n            }\\n            \\n            string x; \\n            \\n            while(i<b.size() &&  b[i]!=\\' \\')\\n            {\\n                x+=b[i];  \\n                i++;  \\n            }\\n            \\n\\n            \\n            bool found  = false;   \\n            k=j; \\n \\n            cout<<j<<\" \";\\n            while(j<s.size())\\n            {\\n                \\n                if(s[j]==x)\\n                {\\n                    found =true;  \\n                    j++; \\n                    break; \\n                }\\n                j++; \\n                \\n            }\\n            \\n            if(found == false)\\n            {   \\n               \\n               ans=false; \\n               return;\\n            }\\n          \\n            if(j-k> 1)\\n            {\\n                insert++; \\n            }\\n        }\\n        \\n        if(j!=s.size())\\n        {\\n            insert++;  \\n        }\\n        \\n        \\n        if(insert>1)\\n        {\\n            ans=false;  \\n        }else\\n        {\\n            ans=true;  \\n        }\\n    }\\n    bool areSentencesSimilar(string a, string b) {\\n        \\n        ans=false; \\n        \\n        if(a.size() > b.size())\\n        {\\n            solve(a,b); \\n        }\\n        else{\\n            solve(b,a); \\n        }\\n        \\n        return ans;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool ans; \\n    void solve(string a, string b){\\n        \\n        int i,j,k; \\n        vector<string>s; \\n        \\n        i=0; \\n        \\n        while(i<a.size())\\n        {\\n            \\n            if(a[i]==\\' \\')\\n            {\\n                i++;  \\n                continue;  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1140688,
                "title": "javascript-left-right-remove-80ms",
                "content": "```\\nconst areSentencesSimilar = (s1, s2) => {\\n    let a1 = s1.split(\" \");\\n    let a2 = s2.split(\" \");\\n    return a1.length <= a2.length ? ok(a1, a2) : ok(a2, a1);\\n};\\n\\nconst ok = (short, long) => {\\n    let re = []; // record short array length\\n    while (1) {\\n        if (short[0] == long[0]) {\\n            short.shift();\\n            long.shift();\\n        }\\n        if (short[short.length - 1] == long[long.length - 1]) {\\n            short.pop();\\n            long.pop();\\n        }\\n        if (re[0] == short.length) break; // short array length stop changing, loop end\\n        re.unshift(short.length);\\n    }\\n    return short.length == 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst areSentencesSimilar = (s1, s2) => {\\n    let a1 = s1.split(\" \");\\n    let a2 = s2.split(\" \");\\n    return a1.length <= a2.length ? ok(a1, a2) : ok(a2, a1);\\n};\\n\\nconst ok = (short, long) => {\\n    let re = []; // record short array length\\n    while (1) {\\n        if (short[0] == long[0]) {\\n            short.shift();\\n            long.shift();\\n        }\\n        if (short[short.length - 1] == long[long.length - 1]) {\\n            short.pop();\\n            long.pop();\\n        }\\n        if (re[0] == short.length) break; // short array length stop changing, loop end\\n        re.unshift(short.length);\\n    }\\n    return short.length == 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140635,
                "title": "python-easy-to-understand-solution-with-comments-for-explanation",
                "content": "The solution is straightforward if we leverage state of traversal while checking both the strings. Refer comments in code below for details -\\n\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        \\n        if sentence1 == sentence2:\\n            return True\\n\\n        # spplit the sentences into words\\n        words1 = sentence1.split(\" \")\\n        words2 = sentence2.split(\" \")\\n        \\n        # kep the smaller one in words2\\n        if len(words1) < len(words2):\\n            words1, words2 = words2, words1\\n        \\n        \\'\\'\\'\\n        Keep following states during traversal\\n            0. not inserted\\n            1. inserting\\n            2. inserted\\n        \\'\\'\\'\\n        inserted = 0\\n        i = 0\\n        j = 0\\n\\n        while(i < len(words1)):\\n            if j >= len(words2):\\n                if inserted == 2:\\n                    return False\\n                else:\\n                    return True\\n            if words1[i] != words2[j]:\\n                if inserted == 0:\\n                    inserted = 1 # start insertion\\n                    i += 1 # only move i not j\\n                elif inserted == 1:\\n                    i += 1 # keep inserting more words\\n                else: # that means it\\'s 2 .. hence a sentence is already inserted\\n                    return False # as not more sentences can be inserted\\n            else: # continue moving\\n                if inserted == 1:\\n                    inserted = 2 # set that previously a sentence has already been inserted\\n                i += 1\\n                j += 1\\n            \\n        # if we reach here then it means we can do it\\n        return j == len(words2)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        \\n        if sentence1 == sentence2:\\n            return True\\n\\n        # spplit the sentences into words\\n        words1 = sentence1.split(\" \")\\n        words2 = sentence2.split(\" \")\\n        \\n        # kep the smaller one in words2\\n        if len(words1) < len(words2):\\n            words1, words2 = words2, words1\\n        \\n        \\'\\'\\'\\n        Keep following states during traversal\\n            0. not inserted\\n            1. inserting\\n            2. inserted\\n        \\'\\'\\'\\n        inserted = 0\\n        i = 0\\n        j = 0\\n\\n        while(i < len(words1)):\\n            if j >= len(words2):\\n                if inserted == 2:\\n                    return False\\n                else:\\n                    return True\\n            if words1[i] != words2[j]:\\n                if inserted == 0:\\n                    inserted = 1 # start insertion\\n                    i += 1 # only move i not j\\n                elif inserted == 1:\\n                    i += 1 # keep inserting more words\\n                else: # that means it\\'s 2 .. hence a sentence is already inserted\\n                    return False # as not more sentences can be inserted\\n            else: # continue moving\\n                if inserted == 1:\\n                    inserted = 2 # set that previously a sentence has already been inserted\\n                i += 1\\n                j += 1\\n            \\n        # if we reach here then it means we can do it\\n        return j == len(words2)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140624,
                "title": "java-100-easy-to-understand",
                "content": "3 cases\\n- All matching words are at start of s1\\n- All matching words are at end of s1\\n- Matching words are present both at start and at the end\\n\\nApproach:\\n- Left pointer counts the word matches from the start of s1\\n- Right pointer counts the word matches from the end of s1\\n- Sentences are similar if all words from s2 are used by pointers --> (sum of left count and right count)\\n\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n        \\n        // ensure sentence1 is longer\\n        if(s1.length() < s2.length()) return areSentencesSimilar(s2, s1);\\n        \\n        String[] w1 = s1.split(\" \");\\n        String[] w2 = s2.split(\" \");\\n        \\n        // count matching words in beginning\\n        int l=0;\\n        while(l< w2.length){\\n            if(w2[l].equals(w1[l])) l++;\\n            else break;\\n        }\\n        if(l== w2.length) return true;\\n        \\n        // count matching words at the end\\n        int r=0;\\n        while(r<w2.length){\\n            if(w2[w2.length-1-r].equals(w1[w1.length-1-r])) r++;\\n            else break;\\n        }\\n        return l+r==w2.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n        \\n        // ensure sentence1 is longer\\n        if(s1.length() < s2.length()) return areSentencesSimilar(s2, s1);\\n        \\n        String[] w1 = s1.split(\" \");\\n        String[] w2 = s2.split(\" \");\\n        \\n        // count matching words in beginning\\n        int l=0;\\n        while(l< w2.length){\\n            if(w2[l].equals(w1[l])) l++;\\n            else break;\\n        }\\n        if(l== w2.length) return true;\\n        \\n        // count matching words at the end\\n        int r=0;\\n        while(r<w2.length){\\n            if(w2[w2.length-1-r].equals(w1[w1.length-1-r])) r++;\\n            else break;\\n        }\\n        return l+r==w2.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140552,
                "title": "scanning-words-from-first-last-c",
                "content": "\\n***\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool areSentencesSimilar(string s1, string s2) {      \\n\\t\\t\\tif(s2.size() > s1.size())              // s1 is always the bigger string\\n\\t\\t\\t\\tswap(s1,s2);\\n\\n\\t\\t\\tvector<string> w1,w2;                  \\n\\t\\t\\tint n = s1.size(), m = s2.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++) {                 // storing all words from s1 in w1 \\n\\t\\t\\t\\tstring word=\"\";\\n\\t\\t\\t\\twhile(!isspace(s1[i]) && i<n) \\n\\t\\t\\t\\t\\tword += s1[i++];\\n\\t\\t\\t\\tif(word!=\"\") \\n\\t\\t\\t\\t\\tw1.push_back(word);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0;i<m;i++) {                 // storing all words from s2 in w2\\n\\t\\t\\t\\tstring word=\"\";\\n\\t\\t\\t\\twhile(!isspace(s2[i]) && i<m)\\n\\t\\t\\t\\t\\tword += s2[i++];\\n\\t\\t\\t\\tif(word!=\"\")\\n\\t\\t\\t\\t\\tw2.push_back(word);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint i = 0, j = w1.size()-1;\\n\\t\\t\\tint x = 0, y = w2.size()-1;\\n\\t\\t\\twhile(x<=y) {                          // keep checking whether words exist from front as well as back; \\n\\t\\t\\t\\tif(w1[i] == w2[x]) {\\n\\t\\t\\t\\t\\ti++; x++; continue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(w1[j] == w2[y]) {\\n\\t\\t\\t\\t\\tj--; y--; continue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn false;                      // if we don\\'t find word either in front or back ... return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n***\\n\\nwondering whether it is possible to check without checking for individual words??",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool areSentencesSimilar(string s1, string s2) {      \\n\\t\\t\\tif(s2.size() > s1.size())              // s1 is always the bigger string\\n\\t\\t\\t\\tswap(s1,s2);\\n\\n\\t\\t\\tvector<string> w1,w2;                  \\n\\t\\t\\tint n = s1.size(), m = s2.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++) {                 // storing all words from s1 in w1 \\n\\t\\t\\t\\tstring word=\"\";\\n\\t\\t\\t\\twhile(!isspace(s1[i]) && i<n) \\n\\t\\t\\t\\t\\tword += s1[i++];\\n\\t\\t\\t\\tif(word!=\"\") \\n\\t\\t\\t\\t\\tw1.push_back(word);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1140522,
                "title": "python-simple-and-easy-solution-using-split",
                "content": "```\\nclass Solution(object):\\n    def areSentencesSimilar(self, sa, sb):\\n        tempa=sa\\n        tempb=sb\\n        if len(sa)>len(sb):\\n            sa=tempb\\n            sb=tempa\\n            \\n        lst1=sa.split()\\n        lst2=sb.split()\\n        \\n        l=0\\n        \\n        while l<len(lst1) and lst1[l]==lst2[l]:\\n            l=l+1\\n            \\n        if l==len(lst1):\\n            return True\\n        \\n        ra=len(lst1)-1\\n        rb=len(lst2)-1\\n        \\n        while ra>=0 and lst1[ra]==lst2[rb]:\\n            ra=ra-1\\n            rb=rb-1\\n            \\n        if l>ra:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def areSentencesSimilar(self, sa, sb):\\n        tempa=sa\\n        tempb=sb\\n        if len(sa)>len(sb):\\n            sa=tempb\\n            sb=tempa\\n            \\n        lst1=sa.split()\\n        lst2=sb.split()\\n        \\n        l=0\\n        \\n        while l<len(lst1) and lst1[l]==lst2[l]:\\n            l=l+1\\n            \\n        if l==len(lst1):\\n            return True\\n        \\n        ra=len(lst1)-1\\n        rb=len(lst2)-1\\n        \\n        while ra>=0 and lst1[ra]==lst2[rb]:\\n            ra=ra-1\\n            rb=rb-1\\n            \\n        if l>ra:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140512,
                "title": "c-two-pointers-stringstream-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if (s1.size() < s2.size()) {\\n            string temp = s1;\\n            s1 = s2;\\n            s2 = temp;\\n        }\\n        \\n        vector<string> ar1;\\n        stringstream ss1(s1);\\n        string word;\\n        \\n        while (ss1 >> word) {\\n            ar1.push_back(word);\\n        }\\n        \\n        vector<string> ar2;\\n        stringstream ss2(s2);\\n        \\n        while (ss2 >> word){\\n            ar2.push_back(word);\\n        }\\n        \\n        int i1 = 0, i2 = 0, j1 = ar1.size() - 1, j2 = ar2.size() - 1;\\n        \\n        while (i2 <= j2){\\n            if(ar1[i1] == ar2[i2]){\\n                i1++;\\n                i2++;\\n            } \\n            else if(ar1[j1] == ar2[j2]){\\n                j1--;\\n                j2--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if (s1.size() < s2.size()) {\\n            string temp = s1;\\n            s1 = s2;\\n            s2 = temp;\\n        }\\n        \\n        vector<string> ar1;\\n        stringstream ss1(s1);\\n        string word;\\n        \\n        while (ss1 >> word) {\\n            ar1.push_back(word);\\n        }\\n        \\n        vector<string> ar2;\\n        stringstream ss2(s2);\\n        \\n        while (ss2 >> word){\\n            ar2.push_back(word);\\n        }\\n        \\n        int i1 = 0, i2 = 0, j1 = ar1.size() - 1, j2 = ar2.size() - 1;\\n        \\n        while (i2 <= j2){\\n            if(ar1[i1] == ar2[i2]){\\n                i1++;\\n                i2++;\\n            } \\n            else if(ar1[j1] == ar2[j2]){\\n                j1--;\\n                j2--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140495,
                "title": "a-few-solutions",
                "content": "Recursively reduce input strings `a`, `b` via matches to their respective first/last words.  Let the indices `i`,`j` denote the first/last word in `A` and let indices `u`,`v` denote the first/last word in `B`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun areSentencesSimilar(a: String, b: String): Boolean {\\n        var A = a.split(\" \")\\n        var B = b.split(\" \")\\n        fun go(i: Int = 0, j: Int = A.size - 1, u: Int = 0, v: Int = B.size - 1): Boolean {\\n            if (j < i || v < u || (i == j && u == v && A[i] == B[i]))\\n                return true\\n            if (A[i] == B[u]) return go(i + 1, j, u + 1, v)\\n            if (A[j] == B[v]) return go(i, j - 1, u, v - 1)\\n            return false\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet areSentencesSimilar = (a, b) => {\\n    let A = a.split(\\' \\'),\\n        B = b.split(\\' \\');\\n    let go = (i = 0, j = A.length - 1, u = 0, v = B.length - 1) => {\\n        if (j < i || v < u || (i == j && u == v && A[i] == B[u]))\\n            return true;\\n        if (A[i] == B[u]) return go(i + 1, j, u + 1, v);\\n        if (A[j] == B[v]) return go(i, j - 1, u, v - 1);\\n        return false;\\n    };\\n    return go();\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, a: str, b: str) -> bool:\\n        A, B = a.split(\\' \\'), b.split(\\' \\')\\n        M, N = len(A), len(B)\\n        def go(i = 0, j = M - 1, u = 0, v = N - 1):\\n            if j < i or v < u or (i == j and u == v and A[i] == B[u]):\\n                return True\\n            if A[i] == B[u]: return go(i + 1, j, u + 1, v)\\n            if A[j] == B[v]: return go(i, j - 1, u, v - 1)\\n            return False\\n        return go()\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using fun = function<bool(int, int, int, int)>;\\n    bool areSentencesSimilar(string a, string b) {\\n        auto words = [](string& s, VS res = {}) -> VS {\\n            stringstream ss{ s };\\n            for (string word; ss >> word; res.emplace_back(word));\\n            return res;\\n        };\\n        auto A = words(a),\\n             B = words(b);\\n        fun go = [&](auto i, auto j, auto u, auto v) {\\n            if (j < i || v < u || (i == j && u == v && A[i] == B[u]))\\n                return true;\\n            if (A[i] == B[u]) return go(i + 1, j, u + 1, v);\\n            if (A[j] == B[v]) return go(i, j - 1, u, v - 1);\\n            return false;\\n        };\\n        int M = A.size(),\\n            N = B.size();\\n        return go(0, M - 1, 0, N - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun areSentencesSimilar(a: String, b: String): Boolean {\\n        var A = a.split(\" \")\\n        var B = b.split(\" \")\\n        fun go(i: Int = 0, j: Int = A.size - 1, u: Int = 0, v: Int = B.size - 1): Boolean {\\n            if (j < i || v < u || (i == j && u == v && A[i] == B[i]))\\n                return true\\n            if (A[i] == B[u]) return go(i + 1, j, u + 1, v)\\n            if (A[j] == B[v]) return go(i, j - 1, u, v - 1)\\n            return false\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nlet areSentencesSimilar = (a, b) => {\\n    let A = a.split(\\' \\'),\\n        B = b.split(\\' \\');\\n    let go = (i = 0, j = A.length - 1, u = 0, v = B.length - 1) => {\\n        if (j < i || v < u || (i == j && u == v && A[i] == B[u]))\\n            return true;\\n        if (A[i] == B[u]) return go(i + 1, j, u + 1, v);\\n        if (A[j] == B[v]) return go(i, j - 1, u, v - 1);\\n        return false;\\n    };\\n    return go();\\n};\\n```\n```\\nclass Solution:\\n    def areSentencesSimilar(self, a: str, b: str) -> bool:\\n        A, B = a.split(\\' \\'), b.split(\\' \\')\\n        M, N = len(A), len(B)\\n        def go(i = 0, j = M - 1, u = 0, v = N - 1):\\n            if j < i or v < u or (i == j and u == v and A[i] == B[u]):\\n                return True\\n            if A[i] == B[u]: return go(i + 1, j, u + 1, v)\\n            if A[j] == B[v]: return go(i, j - 1, u, v - 1)\\n            return False\\n        return go()\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using fun = function<bool(int, int, int, int)>;\\n    bool areSentencesSimilar(string a, string b) {\\n        auto words = [](string& s, VS res = {}) -> VS {\\n            stringstream ss{ s };\\n            for (string word; ss >> word; res.emplace_back(word));\\n            return res;\\n        };\\n        auto A = words(a),\\n             B = words(b);\\n        fun go = [&](auto i, auto j, auto u, auto v) {\\n            if (j < i || v < u || (i == j && u == v && A[i] == B[u]))\\n                return true;\\n            if (A[i] == B[u]) return go(i + 1, j, u + 1, v);\\n            if (A[j] == B[v]) return go(i, j - 1, u, v - 1);\\n            return false;\\n        };\\n        int M = A.size(),\\n            N = B.size();\\n        return go(0, M - 1, 0, N - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140491,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if len(sentence2) > len(sentence1):\\n            sentence1, sentence2 = sentence2, sentence1\\n        words2 = sentence2.split(\" \")\\n        words1 = sentence1.split(\" \")\\n        \\n        for index in range(len(words2)+1):\\n            front = index\\n            back = len(words2) - index\\n            if words2[:front] == words1[:front] and words2[len(words2)-back:] == words1[len(words1)-back:]:\\n                return True\\n        return False\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if len(sentence2) > len(sentence1):\\n            sentence1, sentence2 = sentence2, sentence1\\n        words2 = sentence2.split(\" \")\\n        words1 = sentence1.split(\" \")\\n        \\n        for index in range(len(words2)+1):\\n            front = index\\n            back = len(words2) - index\\n            if words2[:front] == words1[:front] and words2[len(words2)-back:] == words1[len(words1)-back:]:\\n                return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140486,
                "title": "c-o-n-o-n",
                "content": "![](https://i.imgur.com/ftZhWAu.png)\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        if(sentence1 == sentence2) return true;\\n        istringstream s1(sentence1),s2(sentence2);\\n        vector<string> svtr1,svtr2;\\n        string tmp;\\n        while(s1 >> tmp) svtr1.push_back(tmp);\\n        while(s2 >> tmp) svtr2.push_back(tmp);\\n        int len1 = svtr1.size();\\n        int len2 = svtr2.size();\\n        if(len1 < len2){\\n            swap(len1,len2);\\n            swap(svtr1,svtr2);\\n        }\\n        int l1=0,l2=0,r1 = len1-1,r2=len2-1; \\n        // Check from beginning\\n        while(l1 <= r1 && l2 <= r2 && svtr1[l1] == svtr2[l2]){\\n            if(r2 == l2)\\n                return true;\\n            ++l1;\\n            ++l2;\\n        }\\n        // Check from ending\\n        while(l1 <= r1 && l2 <= r2 && svtr1[r1] == svtr2[r2]){\\n            if(r2 == l2)\\n                return true;\\n            --r1;\\n            --r2;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        if(sentence1 == sentence2) return true;\\n        istringstream s1(sentence1),s2(sentence2);\\n        vector<string> svtr1,svtr2;\\n        string tmp;\\n        while(s1 >> tmp) svtr1.push_back(tmp);\\n        while(s2 >> tmp) svtr2.push_back(tmp);\\n        int len1 = svtr1.size();\\n        int len2 = svtr2.size();\\n        if(len1 < len2){\\n            swap(len1,len2);\\n            swap(svtr1,svtr2);\\n        }\\n        int l1=0,l2=0,r1 = len1-1,r2=len2-1; \\n        // Check from beginning\\n        while(l1 <= r1 && l2 <= r2 && svtr1[l1] == svtr2[l2]){\\n            if(r2 == l2)\\n                return true;\\n            ++l1;\\n            ++l2;\\n        }\\n        // Check from ending\\n        while(l1 <= r1 && l2 <= r2 && svtr1[r1] == svtr2[r2]){\\n            if(r2 == l2)\\n                return true;\\n            --r1;\\n            --r2;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092913,
                "title": "simple-java-solution",
                "content": "# Intuition\\nIf continuous string is left than both strings can be made same.\\n\\n# Approach\\n1. Split both sentences into arrays of words using the space character as the delimiter.\\n2. Initialize two pointers, i and j, to 0.\\n3. Compare words from the beginning of both arrays until a mismatch is found or one of the arrays is exhausted.\\n4. Compare words from the end of both arrays until a mismatch is found or one of the arrays is exhausted.\\n5. If all words in both sentences are matched, the sentences are considered similar.\\n\\n# Complexity\\n- Time complexity:\\nO(max(N, M)), where N is the number of words in the first sentence (sentence1) and M is the number of words in the second sentence (sentence2)\\n\\n- Space complexity:\\nO(N + M)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) \\n    {\\n        List<String> list1 = new ArrayList(Arrays.asList(sentence1.split(\" \")));\\n        List<String> list2 = new ArrayList(Arrays.asList(sentence2.split(\" \")));\\n\\n        int i=0, j=0;\\n\\n        while(i < list1.size() && j < list2.size() && (list1.get(i)).equals(list2.get(j)))\\n        {\\n            list1.remove(i);\\n            list2.remove(j);\\n        }\\n        \\n        while(list1.size() > 0 && list2.size() > 0 && list1.get(list1.size()-1).equals(list2.get(list2.size()-1)))\\n        {\\n            list1.remove(list1.size()-1);\\n            list2.remove(list2.size()-1);\\n            \\n        }\\n\\n        if(list1.size() == 0 || list2.size() == 0)\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) \\n    {\\n        List<String> list1 = new ArrayList(Arrays.asList(sentence1.split(\" \")));\\n        List<String> list2 = new ArrayList(Arrays.asList(sentence2.split(\" \")));\\n\\n        int i=0, j=0;\\n\\n        while(i < list1.size() && j < list2.size() && (list1.get(i)).equals(list2.get(j)))\\n        {\\n            list1.remove(i);\\n            list2.remove(j);\\n        }\\n        \\n        while(list1.size() > 0 && list2.size() > 0 && list1.get(list1.size()-1).equals(list2.get(list2.size()-1)))\\n        {\\n            list1.remove(list1.size()-1);\\n            list2.remove(list2.size()-1);\\n            \\n        }\\n\\n        if(list1.size() == 0 || list2.size() == 0)\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073439,
                "title": "peeling-the-onion-method",
                "content": "Keeps removing similar first word or similar last word, and if one of the sentences became empty .. then they are similar\\n\\n```\\nfunction areSentencesSimilar(sentence1: string, sentence2: string): boolean {\\n    const one = sentence1.split(\\' \\')\\n    const two = sentence2.split(\\' \\')\\n\\n    while (true) {\\n        if (one.length === 0 || two.length ===0) {\\n            break\\n        }\\n\\n        if (one[0] === two[0]) {\\n            one.shift()\\n            two.shift()\\n            continue\\n        }\\n        if (one[one.length - 1] === two[two.length - 1]) {\\n            one.pop()\\n            two.pop()\\n            continue\\n        }\\n        \\n        break\\n    }\\n\\n    return one.length === 0 || two.length === 0 \\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction areSentencesSimilar(sentence1: string, sentence2: string): boolean {\\n    const one = sentence1.split(\\' \\')\\n    const two = sentence2.split(\\' \\')\\n\\n    while (true) {\\n        if (one.length === 0 || two.length ===0) {\\n            break\\n        }\\n\\n        if (one[0] === two[0]) {\\n            one.shift()\\n            two.shift()\\n            continue\\n        }\\n        if (one[one.length - 1] === two[two.length - 1]) {\\n            one.pop()\\n            two.pop()\\n            continue\\n        }\\n        \\n        break\\n    }\\n\\n    return one.length === 0 || two.length === 0 \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072811,
                "title": "c-0ms-solution-faster-than-100-users-using-string-stream",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        stringstream s(s1),ss(s2);\\n\\n        vector<string>v1,v2;\\n\\n        string word;\\n\\n        while(s>>word) v1.push_back(word);\\n        while(ss>>word) v2.push_back(word);\\n\\n        int i=0,j=0;\\n\\n        while(i<v1.size() and j<v2.size()){\\n            if(v1[i]==v2[j]) i++,j++;\\n            else break;\\n        }\\n\\n        int x=v1.size()-1,y=v2.size()-1;\\n\\n        bool ans=true;\\n\\n        while(i<=x and j<=y){\\n            if(v1[x]==v2[y]) x--,y--;\\n            else{\\n                ans=false;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        stringstream s(s1),ss(s2);\\n\\n        vector<string>v1,v2;\\n\\n        string word;\\n\\n        while(s>>word) v1.push_back(word);\\n        while(ss>>word) v2.push_back(word);\\n\\n        int i=0,j=0;\\n\\n        while(i<v1.size() and j<v2.size()){\\n            if(v1[i]==v2[j]) i++,j++;\\n            else break;\\n        }\\n\\n        int x=v1.size()-1,y=v2.size()-1;\\n\\n        bool ans=true;\\n\\n        while(i<=x and j<=y){\\n            if(v1[x]==v2[y]) x--,y--;\\n            else{\\n                ans=false;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061590,
                "title": "c-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n    //\\uD83D\\uDC49 1. split strings and store in vector.\\n\\n       istringstream iss(sentence1);\\n       vector<string>s1;\\n\\n       string word1,word2;\\n       while(iss>>word1){\\n           s1.push_back(word1);\\n       } \\n\\n      istringstream iss1(sentence2);\\n       \\n       vector<string>s2;\\n\\n       while(iss1>>word2){\\n           s2.push_back(word2);\\n       }\\n\\n    //\\uD83D\\uDC492. check if possible to insert string into another or not.\\n\\n       if(s1.size()==0 || s2.size()==0)return true;\\n        \\n      while(s1.size()>0 && s2.size()>0 &&s1[0]==s2[0]){\\n          s1.erase(s1.begin());\\n          s2.erase(s2.begin());\\n\\n      }\\n      while(s1.size()>0 && s2.size()>0 &&s2[s2.size()-1]==s1[s1.size()-1]){\\n          s1.pop_back();\\n          s2.pop_back();\\n      }\\n    //\\uD83D\\uDC49 If any of the string get empty it is possible to insert one into another.\\n\\n      if(s1.size()==0 || s2.size()==0)return true;\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n    //\\uD83D\\uDC49 1. split strings and store in vector.\\n\\n       istringstream iss(sentence1);\\n       vector<string>s1;\\n\\n       string word1,word2;\\n       while(iss>>word1){\\n           s1.push_back(word1);\\n       } \\n\\n      istringstream iss1(sentence2);\\n       \\n       vector<string>s2;\\n\\n       while(iss1>>word2){\\n           s2.push_back(word2);\\n       }\\n\\n    //\\uD83D\\uDC492. check if possible to insert string into another or not.\\n\\n       if(s1.size()==0 || s2.size()==0)return true;\\n        \\n      while(s1.size()>0 && s2.size()>0 &&s1[0]==s2[0]){\\n          s1.erase(s1.begin());\\n          s2.erase(s2.begin());\\n\\n      }\\n      while(s1.size()>0 && s2.size()>0 &&s2[s2.size()-1]==s1[s1.size()-1]){\\n          s1.pop_back();\\n          s2.pop_back();\\n      }\\n    //\\uD83D\\uDC49 If any of the string get empty it is possible to insert one into another.\\n\\n      if(s1.size()==0 || s2.size()==0)return true;\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021021,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        if(sentence1 == sentence2) \\n            return true;\\n        \\n        vector<string> a;\\n        vector<string> b;\\n        int m = sentence1.size();\\n        int n = sentence2.size();\\n        \\n        for(int i=0; i<m; i++){\\n            string t;\\n            while(i < m && sentence1[i] != \\' \\'){\\n                t += sentence1[i++];\\n            }\\n\\n            if(t.size())\\n                a.push_back(t);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            string t;\\n            while(i<n && sentence2[i] != \\' \\'){\\n                t += sentence2[i++];\\n            }\\n\\n            if(t.size())\\n                b.push_back(t);            \\n        }\\n\\n        int min_ = min(a.size(), b.size());\\n        int cnt = min_;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while(i < a.size() && j < b.size()){\\n            if(a[i] == b[j]){\\n                cnt--;\\n                i++; \\n                j++;\\n\\n                if(cnt == 0) \\n                    return true;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        i = a.size()-1;\\n        j = b.size()-1;\\n        \\n        while(i >= 0 && j >=0 ){\\n            if(a[i] == b[j]){\\n                cnt--;\\n                i--; \\n                j--;\\n\\n                if(cnt == 0) \\n                    return true;\\n            }\\n            else\\n                break;             \\n        }\\n        return cnt == 0;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/05b04280-21c8-46c8-83ec-c3e2b0e085fb_1694077342.2801075.png)",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        if(sentence1 == sentence2) \\n            return true;\\n        \\n        vector<string> a;\\n        vector<string> b;\\n        int m = sentence1.size();\\n        int n = sentence2.size();\\n        \\n        for(int i=0; i<m; i++){\\n            string t;\\n            while(i < m && sentence1[i] != \\' \\'){\\n                t += sentence1[i++];\\n            }\\n\\n            if(t.size())\\n                a.push_back(t);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            string t;\\n            while(i<n && sentence2[i] != \\' \\'){\\n                t += sentence2[i++];\\n            }\\n\\n            if(t.size())\\n                b.push_back(t);            \\n        }\\n\\n        int min_ = min(a.size(), b.size());\\n        int cnt = min_;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while(i < a.size() && j < b.size()){\\n            if(a[i] == b[j]){\\n                cnt--;\\n                i++; \\n                j++;\\n\\n                if(cnt == 0) \\n                    return true;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        i = a.size()-1;\\n        j = b.size()-1;\\n        \\n        while(i >= 0 && j >=0 ){\\n            if(a[i] == b[j]){\\n                cnt--;\\n                i--; \\n                j--;\\n\\n                if(cnt == 0) \\n                    return true;\\n            }\\n            else\\n                break;             \\n        }\\n        return cnt == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015699,
                "title": "java-1ms-beats-99-2pointers-clean-code",
                "content": "# Approach\\n1. Split the two sentences into String[] words: sentence1, sentence2\\n2. Decide which of the two is longer (eg: has more words): the logic is to find the short sentence inside the long one\\n3. Use a leftPointer traverse short/long and break when the two words do not match.\\n    - If left pointer == short.length, then you have traversed the whole shortSencence and it is contained 100% (eg: \"aa aaa\" / \"aa aaa etc\")    \\n4. Else, do the same but from the rightSide, with a rightPointer.\\n    - Start from the end of shortSentence/longSentence and traverse while the words match, stopping at the leftPointer -1.\\n    - if leftPointer -1 == rightPointer, then you have met the two in the middle, so the sentence can be made\\n    - EG: \"ab cc dd ac\", \"ab  tt cc dd ac\".\\n    - leftPointer will be 1.\\n    - rightPointer will be 0. 1 - 1 = 0, so the two pointers overlap.\\n\\n# Complexity\\n- Time complexity:$$O(n + m + m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n + m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        return areSimilar(sentence1.split(\" \"), sentence2.split(\" \"));\\n    }\\n\\n    private boolean areSimilar(String[] chunks1, String[] chunks2) {\\n        String[] shortSentence = chunks1.length <= chunks2.length ? chunks1 : chunks2;\\n        String[] longSentence = chunks1.length <= chunks2.length ? chunks2 : chunks1;\\n        int leftMismatchIndex = findMismatchIndex(0, shortSentence.length, 0, 1, shortSentence, longSentence);\\n        if (leftMismatchIndex == shortSentence.length) {\\n            return true;\\n        }\\n        int rightMismatch = findMismatchIndex(shortSentence.length -1, leftMismatchIndex - 1, longSentence.length -1, -1, shortSentence, longSentence);\\n        return leftMismatchIndex == 1 + rightMismatch;\\n    }\\n\\n    private int findMismatchIndex(int shortFrom, int shortTo, int longFrom, int direction, String[] shortSentence, String[] longSentence) {\\n        while (shortFrom != shortTo && shortSentence[shortFrom].equals(longSentence[longFrom])) {\\n            shortFrom += direction;\\n            longFrom += direction;\\n        }\\n        return shortFrom;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        return areSimilar(sentence1.split(\" \"), sentence2.split(\" \"));\\n    }\\n\\n    private boolean areSimilar(String[] chunks1, String[] chunks2) {\\n        String[] shortSentence = chunks1.length <= chunks2.length ? chunks1 : chunks2;\\n        String[] longSentence = chunks1.length <= chunks2.length ? chunks2 : chunks1;\\n        int leftMismatchIndex = findMismatchIndex(0, shortSentence.length, 0, 1, shortSentence, longSentence);\\n        if (leftMismatchIndex == shortSentence.length) {\\n            return true;\\n        }\\n        int rightMismatch = findMismatchIndex(shortSentence.length -1, leftMismatchIndex - 1, longSentence.length -1, -1, shortSentence, longSentence);\\n        return leftMismatchIndex == 1 + rightMismatch;\\n    }\\n\\n    private int findMismatchIndex(int shortFrom, int shortTo, int longFrom, int direction, String[] shortSentence, String[] longSentence) {\\n        while (shortFrom != shortTo && shortSentence[shortFrom].equals(longSentence[longFrom])) {\\n            shortFrom += direction;\\n            longFrom += direction;\\n        }\\n        return shortFrom;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976219,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        int n1=s1.length(),n2=s2.length();\\n\\n        //put words of s1 and s2 into seperate vectors\\n        vector<string> v1=stringToArr(s1);\\n        vector<string> v2=stringToArr(s2);\\n        int N1=v1.size(),N2=v2.size();\\n        //make sure s1 is smallest size\\n        if(N1>N2) return areSentencesSimilar(s2,s1);\\n        \\n        //match smaller string with prefix and suffix of the larger one\\n        int i=0;\\n        while(i< N1  && v1[i]==v2[i]) i++;\\n        while(i< N1 && v1[i]==v2[N2 - (N1 -i)]) i++;\\n        return i==N1;\\n    }\\n    vector<string> stringToArr(string s){\\n        vector<string> res;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n                temp+=s[i];\\n            }\\n            else{\\n                res.push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        if(temp.size()>0)   res.push_back(temp);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        int n1=s1.length(),n2=s2.length();\\n\\n        //put words of s1 and s2 into seperate vectors\\n        vector<string> v1=stringToArr(s1);\\n        vector<string> v2=stringToArr(s2);\\n        int N1=v1.size(),N2=v2.size();\\n        //make sure s1 is smallest size\\n        if(N1>N2) return areSentencesSimilar(s2,s1);\\n        \\n        //match smaller string with prefix and suffix of the larger one\\n        int i=0;\\n        while(i< N1  && v1[i]==v2[i]) i++;\\n        while(i< N1 && v1[i]==v2[N2 - (N1 -i)]) i++;\\n        return i==N1;\\n    }\\n    vector<string> stringToArr(string s){\\n        vector<string> res;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n                temp+=s[i];\\n            }\\n            else{\\n                res.push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        if(temp.size()>0)   res.push_back(temp);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953630,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        int n1=s1.length(),n2=s2.length();\\n\\n        //put words of s1 and s2 into seperate vectors\\n        vector<string> v1,v2;\\n        for(int i=0;i<n1;){\\n            while(i<n1 && s1[i]==\\' \\')   i++;\\n            int j=i;\\n            while(j<n1 && s1[j]!=\\' \\')   j++;\\n            if(i>=n1)   break;\\n            v1.push_back(s1.substr(i,j-i));\\n            i=j;\\n        }\\n        for(int i=0;i<n2;){\\n            while(i<n2 && s2[i]==\\' \\')   i++;\\n            int j=i;\\n            while(j<n2 && s2[j]!=\\' \\')   j++;\\n            if(i>=n2)   break;\\n            v2.push_back(s2.substr(i,j-i));\\n            i=j;\\n        }\\n        \\n        int N1=v1.size(),N2=v2.size();\\n        //make sure s1 is smallest size\\n        if(N1>N2) return areSentencesSimilar(s2,s1);\\n        \\n        //match smaller string with prefix and suffix of the larger one\\n        int i=0;\\n        while(i< N1  && v1[i]==v2[i]) i++;\\n        while(i< N1 && v1[i]==v2[N2 - (N1 -i)]) i++;\\n        return i==N1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        int n1=s1.length(),n2=s2.length();\\n\\n        //put words of s1 and s2 into seperate vectors\\n        vector<string> v1,v2;\\n        for(int i=0;i<n1;){\\n            while(i<n1 && s1[i]==\\' \\')   i++;\\n            int j=i;\\n            while(j<n1 && s1[j]!=\\' \\')   j++;\\n            if(i>=n1)   break;\\n            v1.push_back(s1.substr(i,j-i));\\n            i=j;\\n        }\\n        for(int i=0;i<n2;){\\n            while(i<n2 && s2[i]==\\' \\')   i++;\\n            int j=i;\\n            while(j<n2 && s2[j]!=\\' \\')   j++;\\n            if(i>=n2)   break;\\n            v2.push_back(s2.substr(i,j-i));\\n            i=j;\\n        }\\n        \\n        int N1=v1.size(),N2=v2.size();\\n        //make sure s1 is smallest size\\n        if(N1>N2) return areSentencesSimilar(s2,s1);\\n        \\n        //match smaller string with prefix and suffix of the larger one\\n        int i=0;\\n        while(i< N1  && v1[i]==v2[i]) i++;\\n        while(i< N1 && v1[i]==v2[N2 - (N1 -i)]) i++;\\n        return i==N1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933274,
                "title": "swift-2-ms-solution-beats-100-in-time",
                "content": "# Complexity\\n- Time complexity:\\nO(shorter string\\'s length)\\n\\n- Space complexity:\\nO(1). swift\\'s mechanism copy on write should help here, as the strings do not get changed.\\n\\n# Code\\n```\\nclass Solution {\\n    func areSentencesSimilar(_ sentence1: String, _ sentence2: String) -> Bool {\\n        let count1 = sentence1.count\\n        let count2 = sentence2.count\\n        if count1 > count2 {\\n            return areSentencesSimilar(sentence2, sentence1)\\n        }\\n        if count1 == count2 {\\n            return sentence1 == sentence2\\n        }\\n\\n        var idx = sentence1.startIndex\\n        var lastSpaceIdx: String.Index? = nil\\n        while idx < sentence1.endIndex && sentence1[idx] == sentence2[idx] {\\n            if sentence1[idx] == Character(\" \") {\\n                lastSpaceIdx = idx\\n            }\\n            sentence1.formIndex(after: &idx)\\n        }\\n\\n        if sentence2[idx] == Character(\" \") && idx == sentence1.endIndex { return true } else {\\n            idx = lastSpaceIdx ?? sentence1.startIndex\\n        }\\n\\n        var jdx = sentence1.endIndex\\n        sentence1.formIndex(before: &jdx)\\n        var longJdx = sentence2.endIndex\\n        sentence2.formIndex(before: &longJdx)\\n        while jdx != idx && sentence1[jdx] == sentence2[longJdx] {\\n            sentence1.formIndex(before: &jdx)\\n            sentence2.formIndex(before: &longJdx)\\n        }\\n\\n        if jdx == idx, sentence1[jdx] == sentence2[longJdx] {\\n            if lastSpaceIdx != nil { return true }\\n            sentence2.formIndex(before: &longJdx)\\n            return sentence2[longJdx] == Character(\" \")\\n        }\\n\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func areSentencesSimilar(_ sentence1: String, _ sentence2: String) -> Bool {\\n        let count1 = sentence1.count\\n        let count2 = sentence2.count\\n        if count1 > count2 {\\n            return areSentencesSimilar(sentence2, sentence1)\\n        }\\n        if count1 == count2 {\\n            return sentence1 == sentence2\\n        }\\n\\n        var idx = sentence1.startIndex\\n        var lastSpaceIdx: String.Index? = nil\\n        while idx < sentence1.endIndex && sentence1[idx] == sentence2[idx] {\\n            if sentence1[idx] == Character(\" \") {\\n                lastSpaceIdx = idx\\n            }\\n            sentence1.formIndex(after: &idx)\\n        }\\n\\n        if sentence2[idx] == Character(\" \") && idx == sentence1.endIndex { return true } else {\\n            idx = lastSpaceIdx ?? sentence1.startIndex\\n        }\\n\\n        var jdx = sentence1.endIndex\\n        sentence1.formIndex(before: &jdx)\\n        var longJdx = sentence2.endIndex\\n        sentence2.formIndex(before: &longJdx)\\n        while jdx != idx && sentence1[jdx] == sentence2[longJdx] {\\n            sentence1.formIndex(before: &jdx)\\n            sentence2.formIndex(before: &longJdx)\\n        }\\n\\n        if jdx == idx, sentence1[jdx] == sentence2[longJdx] {\\n            if lastSpaceIdx != nil { return true }\\n            sentence2.formIndex(before: &longJdx)\\n            return sentence2[longJdx] == Character(\" \")\\n        }\\n\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844294,
                "title": "python-beats-100-tc-o-s1-s2-sc-o-s1-s2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnly single sentence can be inserted so only three positions possible\\n\\n#### Insert Left\\nEx: s1 = \"now\", s2 = \"Eating right now\"\\n\\n__\"Eating right\"__ + \"now == \"Eating right now\"\\n\\n\\n#### Insert Right\\nEx: s1 = \"Eating\", s2 = \"Eating right now\"\\n\\n\"Eating\" + __\"right now\"__ == \"Eating right now\"\\n\\n#### Insert Middle\\nEx: s1 = \"Eating now\", s2 = \"Eating right now\"\\n\\n\"Eating\" + __\"right\"__ + \"now\" == \"Eating right now\"\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet smaller of sentence be sentence1\\nTake a pointer i = 0\\n\\nMove the pointer till s1[i] == s2[i] (covering the left part)\\n\\nThen skip the pointer by n2 - n1 in s2 distance to skip different words (check insert left example) then again\\n\\nMove the pointer till s1[i] == s2[n2 - n1 + i] (covering the right part)\\n\\nIf i == len(s1) means we covered all the words and we can insert a sentence to make s1 == s2\\n\\n# Complexity\\n- Time complexity: O(S1 + S2) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(S1 + S2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        l1 = sentence1.split()\\n        l2 = sentence2.split()\\n        n1 = len(l1)\\n        n2 = len(l2)\\n        if n1 > n2:\\n            n1, n2 = n2, n1\\n            l1, l2 = l2[:], l1[:]\\n\\n        i = 0\\n        while i < n1 and l1[i] == l2[i]:\\n            i += 1\\n        while i < n1 and l1[i] == l2[n2 - n1 + i]:\\n            i += 1\\n\\n        return i == n1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        l1 = sentence1.split()\\n        l2 = sentence2.split()\\n        n1 = len(l1)\\n        n2 = len(l2)\\n        if n1 > n2:\\n            n1, n2 = n2, n1\\n            l1, l2 = l2[:], l1[:]\\n\\n        i = 0\\n        while i < n1 and l1[i] == l2[i]:\\n            i += 1\\n        while i < n1 and l1[i] == l2[n2 - n1 + i]:\\n            i += 1\\n\\n        return i == n1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829891,
                "title": "python3-sol",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, s1: str, s2: str) -> bool:\\n        def check(a,b):\\n            a=a.split()\\n            b=b.split()\\n            while len(a)>0 and len(b)>0 and a[0]==b[0]:\\n                a.pop(0)\\n                b.pop(0)\\n            while len(a)>0 and len(b)>0 and a[-1]==b[-1]:\\n                a.pop(-1)\\n                b.pop(-1)\\n            if len(a)==0:\\n                return True\\n        return check(s1,s2) or check(s2,s1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, s1: str, s2: str) -> bool:\\n        def check(a,b):\\n            a=a.split()\\n            b=b.split()\\n            while len(a)>0 and len(b)>0 and a[0]==b[0]:\\n                a.pop(0)\\n                b.pop(0)\\n            while len(a)>0 and len(b)>0 and a[-1]==b[-1]:\\n                a.pop(-1)\\n                b.pop(-1)\\n            if len(a)==0:\\n                return True\\n        return check(s1,s2) or check(s2,s1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820889,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] words1 = sentence1.split(\" \");\\n        String[] words2 = sentence2.split(\" \");\\n        int i,j,k;\\n        if(words1.length <= words2.length){\\n            for(i = 0;i < words1.length;i++){\\n                if(!words1[words1.length-1-i].equals(words2[words2.length-1-i])){\\n                    break;\\n                }\\n            }\\n            if(i == words1.length){\\n                return true;\\n            }\\n            for(i = 0;i < words1.length;i++){\\n                for(j = 0;j <= i;j++){\\n                    if(!words1[j].equals(words2[j])){\\n                        break;\\n                    }\\n                }\\n                if(j != i+1){\\n                    continue;\\n                }\\n                for(k = 0;k < words1.length-j;k++){\\n                    if(!words1[words1.length-1-k].equals(words2[words2.length-1-k])){\\n                        break;\\n                    }\\n                }\\n                if(k == words1.length-j){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            for(i = 0;i < words2.length;i++){\\n                if(!words2[words2.length-1-i].equals(words1[words1.length-1-i])){\\n                    break;\\n                }\\n            }\\n            if(i == words2.length){\\n                return true;\\n            }\\n            for(i = 0;i < words2.length;i++){\\n                for(j = 0;j <= i;j++){\\n                    if(!words2[j].equals(words1[j])){\\n                        break;\\n                    }\\n                }\\n                if(j != i+1){\\n                    continue;\\n                }\\n                for(k = 0;k < words2.length-j;k++){\\n                    if(!words2[words2.length-1-k].equals(words1[words1.length-1-k])){\\n                        break;\\n                    }\\n                }\\n                if(k == words2.length-j){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] words1 = sentence1.split(\" \");\\n        String[] words2 = sentence2.split(\" \");\\n        int i,j,k;\\n        if(words1.length <= words2.length){\\n            for(i = 0;i < words1.length;i++){\\n                if(!words1[words1.length-1-i].equals(words2[words2.length-1-i])){\\n                    break;\\n                }\\n            }\\n            if(i == words1.length){\\n                return true;\\n            }\\n            for(i = 0;i < words1.length;i++){\\n                for(j = 0;j <= i;j++){\\n                    if(!words1[j].equals(words2[j])){\\n                        break;\\n                    }\\n                }\\n                if(j != i+1){\\n                    continue;\\n                }\\n                for(k = 0;k < words1.length-j;k++){\\n                    if(!words1[words1.length-1-k].equals(words2[words2.length-1-k])){\\n                        break;\\n                    }\\n                }\\n                if(k == words1.length-j){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            for(i = 0;i < words2.length;i++){\\n                if(!words2[words2.length-1-i].equals(words1[words1.length-1-i])){\\n                    break;\\n                }\\n            }\\n            if(i == words2.length){\\n                return true;\\n            }\\n            for(i = 0;i < words2.length;i++){\\n                for(j = 0;j <= i;j++){\\n                    if(!words2[j].equals(words1[j])){\\n                        break;\\n                    }\\n                }\\n                if(j != i+1){\\n                    continue;\\n                }\\n                for(k = 0;k < words2.length-j;k++){\\n                    if(!words2[words2.length-1-k].equals(words1[words1.length-1-k])){\\n                        break;\\n                    }\\n                }\\n                if(k == words2.length-j){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778171,
                "title": "using-dynamic-programming-standard-algo-for-most-of-the-dynamic-programming-questions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: n * m\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn this code we have splited the given string to array. \\nso it will take less time than n * m\\nWhere \\nn -> len(str1)\\nm -> len(str2)\\n\\n- Space complexity: n * m\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe have used memoization which is 2d. so it consumes n * m.\\nWhere \\nn -> len(str1)\\nm -> len(str2)\\n\\n# Code\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        str1 = sentence1.split()\\n        str2 = sentence2.split()\\n        dp = {}\\n        def solve(i, j, c, flag):\\n            if j == len(str2):\\n                return c <= 1\\n            if i >= len(str1):\\n                return False\\n            if (i, j, c) in dp:\\n                return dp[(i, j, c)]\\n            ans = False\\n            if str2[j] == str1[i]:\\n                #ans |= solve(i+1, j, c, flag)\\n                ans |= solve(i+1, j+1, c, False)\\n            if flag:\\n                ans |= solve(i+1, j, c, flag)\\n            ans |= solve(i+1, j, c+1, True)\\n            dp[(i, j, c)] = ans\\n            return ans\\n        st = (str1[0] == str2[0]) or (str1[-1] == str2[-1])\\n        opt =  solve(0, 0, 0, False) and st\\n        dp = {}\\n        str1, str2 = str2, str1\\n        return (solve(0, 0, 0, False) or opt) and st\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        str1 = sentence1.split()\\n        str2 = sentence2.split()\\n        dp = {}\\n        def solve(i, j, c, flag):\\n            if j == len(str2):\\n                return c <= 1\\n            if i >= len(str1):\\n                return False\\n            if (i, j, c) in dp:\\n                return dp[(i, j, c)]\\n            ans = False\\n            if str2[j] == str1[i]:\\n                #ans |= solve(i+1, j, c, flag)\\n                ans |= solve(i+1, j+1, c, False)\\n            if flag:\\n                ans |= solve(i+1, j, c, flag)\\n            ans |= solve(i+1, j, c+1, True)\\n            dp[(i, j, c)] = ans\\n            return ans\\n        st = (str1[0] == str2[0]) or (str1[-1] == str2[-1])\\n        opt =  solve(0, 0, 0, False) and st\\n        dp = {}\\n        str1, str2 = str2, str1\\n        return (solve(0, 0, 0, False) or opt) and st\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706708,
                "title": "simple-kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun areSentencesSimilar(sentence1: String, sentence2: String): Boolean {\\n        val splitOne = sentence1.split(\" \").toMutableList()\\n        val splitTwo = sentence2.split(\" \").toMutableList()\\n\\n        // find where they are not equal\\n        while (true) {\\n            if (splitOne.isEmpty() || splitTwo.isEmpty()) break\\n            if (splitOne.first() != splitTwo.first()) break\\n\\n            splitOne.removeAt(0)\\n            splitTwo.removeAt(0)\\n        }\\n\\n        if (splitOne.size == splitTwo.size) return splitOne == splitTwo\\n\\n        val shorterList = if (splitOne.size < splitTwo.size) splitOne else splitTwo\\n        val longerList = if (shorterList == splitOne) splitTwo else splitOne\\n\\n        while (longerList.isNotEmpty() && longerList.size >= shorterList.size && longerList != shorterList) {\\n            longerList.removeAt(0)\\n        }\\n\\n        return shorterList == longerList\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun areSentencesSimilar(sentence1: String, sentence2: String): Boolean {\\n        val splitOne = sentence1.split(\" \").toMutableList()\\n        val splitTwo = sentence2.split(\" \").toMutableList()\\n\\n        // find where they are not equal\\n        while (true) {\\n            if (splitOne.isEmpty() || splitTwo.isEmpty()) break\\n            if (splitOne.first() != splitTwo.first()) break\\n\\n            splitOne.removeAt(0)\\n            splitTwo.removeAt(0)\\n        }\\n\\n        if (splitOne.size == splitTwo.size) return splitOne == splitTwo\\n\\n        val shorterList = if (splitOne.size < splitTwo.size) splitOne else splitTwo\\n        val longerList = if (shorterList == splitOne) splitTwo else splitOne\\n\\n        while (longerList.isNotEmpty() && longerList.size >= shorterList.size && longerList != shorterList) {\\n            longerList.removeAt(0)\\n        }\\n\\n        return shorterList == longerList\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689345,
                "title": "swift-simple-solution-beats-100-online-submissions",
                "content": "# Intuition\\n![Screenshot 2023-06-27 at 7.49.20 PM.png](https://assets.leetcode.com/users/images/1569083c-f972-4e73-a7bb-18af9e90b46a_1687875577.1586463.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public  func areSentencesSimilar(_ s1: String, _ s2: String) -> Bool {\\n    // Just to make s1 always bigger in size\\n    var s1 = s1\\n    var s2 = s2\\n    if s1.count < s2.count {\\n        let temp = s1\\n        s1 = s2\\n        s2 = temp\\n    }\\n    \\n    // making array of every word\\n    let arr1 = s1.components(separatedBy: \" \")\\n    let arr2 = s2.components(separatedBy: \" \")\\n    var i1 = 0\\n    var i2 = 0\\n    var j1 = arr1.count - 1\\n    var j2 = arr2.count - 1\\n    \\n    // iterating from start as well as from last\\n    while i2 <= j2 {\\n        if arr1[i1] == arr2[i1] {\\n            i1 += 1\\n            i2 += 1\\n        } else if arr1[j1] == arr2[j2] {\\n            j1 -= 1\\n            j2 -= 1\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    public  func areSentencesSimilar(_ s1: String, _ s2: String) -> Bool {\\n    // Just to make s1 always bigger in size\\n    var s1 = s1\\n    var s2 = s2\\n    if s1.count < s2.count {\\n        let temp = s1\\n        s1 = s2\\n        s2 = temp\\n    }\\n    \\n    // making array of every word\\n    let arr1 = s1.components(separatedBy: \" \")\\n    let arr2 = s2.components(separatedBy: \" \")\\n    var i1 = 0\\n    var i2 = 0\\n    var j1 = arr1.count - 1\\n    var j2 = arr2.count - 1\\n    \\n    // iterating from start as well as from last\\n    while i2 <= j2 {\\n        if arr1[i1] == arr2[i1] {\\n            i1 += 1\\n            i2 += 1\\n        } else if arr1[j1] == arr2[j2] {\\n            j1 -= 1\\n            j2 -= 1\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689322,
                "title": "accepted-solution-for-java-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean areSentencesSimilar(String s1, String s2) {\\n\\t\\t// Just to make s1 always bigger in size\\n        if (s1.length() < s2.length()) {\\n            String temp = s1;\\n            s1 = s2;\\n            s2 = temp;\\n        }\\n\\t\\t// making array of every word\\n        String[] arr1 = s1.split(\" \");\\n        String[] arr2 = s2.split(\" \");\\n        int i1 = 0, i2 = 0, j1 = arr1.length - 1, j2 = arr2.length - 1;\\n\\t\\t\\n\\t\\t// iterating from start as well as from last\\n        while (i2 <= j2) {\\n            if (arr1[i1].equals(arr2[i1])) {\\n                i1++; \\n                i2++;\\n            } else if (arr1[j1].equals(arr2[j2])) {\\n                j1--;\\n                j2--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean areSentencesSimilar(String s1, String s2) {\\n\\t\\t// Just to make s1 always bigger in size\\n        if (s1.length() < s2.length()) {\\n            String temp = s1;\\n            s1 = s2;\\n            s2 = temp;\\n        }\\n\\t\\t// making array of every word\\n        String[] arr1 = s1.split(\" \");\\n        String[] arr2 = s2.split(\" \");\\n        int i1 = 0, i2 = 0, j1 = arr1.length - 1, j2 = arr2.length - 1;\\n\\t\\t\\n\\t\\t// iterating from start as well as from last\\n        while (i2 <= j2) {\\n            if (arr1[i1].equals(arr2[i1])) {\\n                i1++; \\n                i2++;\\n            } else if (arr1[j1].equals(arr2[j2])) {\\n                j1--;\\n                j2--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657958,
                "title": "java-1ms-95-very-easy-to-understand",
                "content": "# Approach\\n1. **This problem has three cases, because we were allowed to insert only 1 sentence to make two sentences similar, that means two sentences will have some same words from start or back, or both, cannot in the middle:**\\n```\\nsentence1   Eating banana and apple is good for health.\\nsentence2:\\n    case 1: Eating banana                             .\\n    case 2:                            good for health.\\n    case 3: Eating                          for health.\\n```\\n- Case 1: Match in the start.\\n- Case 2: Match in the end.\\n- Case 3: Math both the start and the end.\\n2. **So, we just need to check how many words are the same from start and from backward in both sentences**\\n3. **The total words matched has to equal length() of one sentence to return true, else return false**\\n\\n# Complexity\\n- Time complexity: O(n);\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] s1 = sentence1.split(\" \");\\n        String[] s2 = sentence2.split(\" \");\\n        int go = 0;\\n        int back = 0;\\n        int index = 0;\\n\\n        while (index < s1.length && index < s2.length && s1[index].equals(s2[index])) {\\n            go++;\\n            index++;\\n        }\\n        index = 0;\\n        while (s1.length-1-index >= 0 && s2.length-1-index >= 0 && s1[s1.length-1-index].equals(s2[s2.length-1-index])) {\\n            back++;\\n            index++;\\n        }\\n        return (go+back) >= s1.length || (go+back) >= s2.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nsentence1   Eating banana and apple is good for health.\\nsentence2:\\n    case 1: Eating banana                             .\\n    case 2:                            good for health.\\n    case 3: Eating                          for health.\\n```\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] s1 = sentence1.split(\" \");\\n        String[] s2 = sentence2.split(\" \");\\n        int go = 0;\\n        int back = 0;\\n        int index = 0;\\n\\n        while (index < s1.length && index < s2.length && s1[index].equals(s2[index])) {\\n            go++;\\n            index++;\\n        }\\n        index = 0;\\n        while (s1.length-1-index >= 0 && s2.length-1-index >= 0 && s1[s1.length-1-index].equals(s2[s2.length-1-index])) {\\n            back++;\\n            index++;\\n        }\\n        return (go+back) >= s1.length || (go+back) >= s2.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615929,
                "title": "two-pointer-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> gen_words(string &s)\\n    {\\n        int n=s.size();\\n        vector<string> res;\\n        int i=0;\\n        while (i<n)\\n        {\\n            string temp=\"\";\\n            while(i<n && s[i]!=\\' \\')\\n                  temp+=s[i++];\\n            i++;\\n            res.push_back(temp);\\n        }\\n        return res;\\n\\n    }\\n    bool possible(vector<string> &st1,vector<string> &st2)\\n    {\\n        int n=st1.size();\\n        int m=st2.size();\\n        int i1=0,j1=n-1;\\n        int i2=0,j2=m-1;\\n        while (i1<=j1 && i2<=j2)\\n        {\\n            if (st1[i1]==st2[i2])\\n               i1++,i2++;\\n            else if (st1[j1]==st2[j2])\\n                j1--,j2--;\\n            else\\n              return false;\\n        }\\n        return (i1>j1)? true:false;\\n\\n    }\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        vector<string> st1=gen_words(sentence1);\\n        vector<string> st2=gen_words(sentence2);\\n        if (st1.size()==st2.size())\\n        {\\n            for (int i=0;i<st1.size();i++)\\n            {\\n                if (st1[i]!=st2[i])\\n                  return false;\\n            }\\n            return true;\\n        }\\n        else if (st1.size()<st2.size())\\n            return possible(st1,st2);\\n        else\\n           return possible(st2,st1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> gen_words(string &s)\\n    {\\n        int n=s.size();\\n        vector<string> res;\\n        int i=0;\\n        while (i<n)\\n        {\\n            string temp=\"\";\\n            while(i<n && s[i]!=\\' \\')\\n                  temp+=s[i++];\\n            i++;\\n            res.push_back(temp);\\n        }\\n        return res;\\n\\n    }\\n    bool possible(vector<string> &st1,vector<string> &st2)\\n    {\\n        int n=st1.size();\\n        int m=st2.size();\\n        int i1=0,j1=n-1;\\n        int i2=0,j2=m-1;\\n        while (i1<=j1 && i2<=j2)\\n        {\\n            if (st1[i1]==st2[i2])\\n               i1++,i2++;\\n            else if (st1[j1]==st2[j2])\\n                j1--,j2--;\\n            else\\n              return false;\\n        }\\n        return (i1>j1)? true:false;\\n\\n    }\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        vector<string> st1=gen_words(sentence1);\\n        vector<string> st2=gen_words(sentence2);\\n        if (st1.size()==st2.size())\\n        {\\n            for (int i=0;i<st1.size();i++)\\n            {\\n                if (st1[i]!=st2[i])\\n                  return false;\\n            }\\n            return true;\\n        }\\n        else if (st1.size()<st2.size())\\n            return possible(st1,st2);\\n        else\\n           return possible(st2,st1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546148,
                "title": "easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n public static boolean areSentencesSimilar(String sentence1, String sentence2) {\\n\\n        if (sentence1.length() < sentence2.length()) {\\n            String temp = sentence1;\\n            sentence1 = sentence2;\\n            sentence2 = temp;\\n        }\\n\\n        String[] arr1 = sentence1.split(\" \");\\n        String[] arr2 = sentence2.split(\" \");\\n\\n        int i1 = 0, i2 = 0;\\n        int j1 = arr1.length - 1, j2 = arr2.length - 1;\\n        while (i2 <= j2) {\\n            if (arr1[i1].equals(arr2[i2])) {\\n                i1++;\\n                i2++;\\n            } else if (arr1[j1].equals(arr2[j2])) {\\n                j1--;\\n                j2--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n public static boolean areSentencesSimilar(String sentence1, String sentence2) {\\n\\n        if (sentence1.length() < sentence2.length()) {\\n            String temp = sentence1;\\n            sentence1 = sentence2;\\n            sentence2 = temp;\\n        }\\n\\n        String[] arr1 = sentence1.split(\" \");\\n        String[] arr2 = sentence2.split(\" \");\\n\\n        int i1 = 0, i2 = 0;\\n        int j1 = arr1.length - 1, j2 = arr2.length - 1;\\n        while (i2 <= j2) {\\n            if (arr1[i1].equals(arr2[i2])) {\\n                i1++;\\n                i2++;\\n            } else if (arr1[j1].equals(arr2[j2])) {\\n                j1--;\\n                j2--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503948,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if (sentence1.length()<sentence2.length()) return areSentencesSimilar(sentence2,sentence1);\\n        if (sentence1.equals(sentence2) ||\\n            (sentence1.startsWith(sentence2) && (sentence1.charAt(sentence2.length()) == \\' \\')) || \\n            (sentence1.endsWith(sentence2)) && (sentence1.charAt(sentence1.length()-sentence2.length()-1) ==  \\' \\')) return true;\\n\\n        while (sentence2.length()>0){\\n            int wordLen = sentence2.indexOf(\\' \\');\\n            String word = (wordLen!=-1)? sentence2.substring(0,wordLen) : sentence2;\\n\\n            if (!sentence1.startsWith(word) || sentence1.charAt(word.length())!=\\' \\') return false;\\n            sentence2 = sentence2.substring(wordLen + 1);\\n            if (sentence1.endsWith(sentence2) && sentence1.charAt(sentence1.length()-sentence2.length()-1)==\\' \\') return true;\\n            sentence1 = sentence1.substring(wordLen + 1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if (sentence1.length()<sentence2.length()) return areSentencesSimilar(sentence2,sentence1);\\n        if (sentence1.equals(sentence2) ||\\n            (sentence1.startsWith(sentence2) && (sentence1.charAt(sentence2.length()) == \\' \\')) || \\n            (sentence1.endsWith(sentence2)) && (sentence1.charAt(sentence1.length()-sentence2.length()-1) ==  \\' \\')) return true;\\n\\n        while (sentence2.length()>0){\\n            int wordLen = sentence2.indexOf(\\' \\');\\n            String word = (wordLen!=-1)? sentence2.substring(0,wordLen) : sentence2;\\n\\n            if (!sentence1.startsWith(word) || sentence1.charAt(word.length())!=\\' \\') return false;\\n            sentence2 = sentence2.substring(wordLen + 1);\\n            if (sentence1.endsWith(sentence2) && sentence1.charAt(sentence1.length()-sentence2.length()-1)==\\' \\') return true;\\n            sentence1 = sentence1.substring(wordLen + 1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497713,
                "title": "very-easy-c-beginners-beats-100",
                "content": "# Intuition\\nVery easy to understand\\n\\n# Approach\\nJust DRY Run it and you will get it.\\nIt is very important to DRY without that you cannot learn.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the areSentencesSimilar function is O(max(n1, n2)), where n1 and n2 are the lengths of the input sentences. \\n\\n- Space complexity:\\nThe space complexity of the areSentencesSimilar function is also O(m), since it generates two vectors of words, each with at most m elements.\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<string> generateVector(string sentence){\\n    int n = sentence.length();\\n    vector<string> ans;\\n    int j = 0;\\n    for(int i = 0; i < n; i++){\\n        if(sentence[i] == \\' \\' || i == n-1){\\n            string temp = sentence.substr(j, i - j + (i == n - 1 ? 1 : 0));\\n            ans.push_back(temp);\\n            j = i + 1;\\n        }\\n    }\\n    return ans;\\n}\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        vector<string> sent1 = generateVector(sentence1);\\n        vector<string> sent2 = generateVector(sentence2);\\n\\n        int n1 = sent1.size(); int n2 = sent2.size();\\n        int i=0; int j=0; \\n        while(i<n1 and j<n2)\\n        {\\n            if(sent1[i] == sent2[j])\\n            {\\n                i++; \\n                j++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n\\n        int index1 = i, index2 = j;\\n        i = n1-1; j = n2-1;\\n        while(i >= index1 and j >= index2)\\n        {\\n            if(sent1[i]==sent2[j])\\n            {\\n                i--; \\n                j--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<string> generateVector(string sentence){\\n    int n = sentence.length();\\n    vector<string> ans;\\n    int j = 0;\\n    for(int i = 0; i < n; i++){\\n        if(sentence[i] == \\' \\' || i == n-1){\\n            string temp = sentence.substr(j, i - j + (i == n - 1 ? 1 : 0));\\n            ans.push_back(temp);\\n            j = i + 1;\\n        }\\n    }\\n    return ans;\\n}\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        vector<string> sent1 = generateVector(sentence1);\\n        vector<string> sent2 = generateVector(sentence2);\\n\\n        int n1 = sent1.size(); int n2 = sent2.size();\\n        int i=0; int j=0; \\n        while(i<n1 and j<n2)\\n        {\\n            if(sent1[i] == sent2[j])\\n            {\\n                i++; \\n                j++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n\\n        int index1 = i, index2 = j;\\n        i = n1-1; j = n2-1;\\n        while(i >= index1 and j >= index2)\\n        {\\n            if(sent1[i]==sent2[j])\\n            {\\n                i--; \\n                j--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332503,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.length()==sentence2.length()){\\n            if(sentence1.equals(sentence2)) return true;\\n            else return false;\\n        }\\n        \\n        String[] arr1 = sentence1.split(\" \");\\n        String[] arr2 = sentence2.split(\" \");\\n        \\n        int l1 = arr1.length;  \\n        int l2 = arr2.length;  \\n        \\n        int f1 =0, f2 =0;        \\n        int b1 =l1-1, b2 = l2-1; \\n        \\n        while(l1!=0 && l2!=0 && arr1[f1].equals(arr2[f2])){\\n            l1--;\\n            l2--;\\n            f1++;\\n            f2++;\\n        }\\n        \\n        \\n        while(l1!=0 && l2!=0 && arr1[b1].equals(arr2[b2])){\\n            l1--;\\n            l2--;\\n            b1--;\\n            b2--;\\n        }\\n        \\n        return l1==0 || l2==0;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.length()==sentence2.length()){\\n            if(sentence1.equals(sentence2)) return true;\\n            else return false;\\n        }\\n        \\n        String[] arr1 = sentence1.split(\" \");\\n        String[] arr2 = sentence2.split(\" \");\\n        \\n        int l1 = arr1.length;  \\n        int l2 = arr2.length;  \\n        \\n        int f1 =0, f2 =0;        \\n        int b1 =l1-1, b2 = l2-1; \\n        \\n        while(l1!=0 && l2!=0 && arr1[f1].equals(arr2[f2])){\\n            l1--;\\n            l2--;\\n            f1++;\\n            f2++;\\n        }\\n        \\n        \\n        while(l1!=0 && l2!=0 && arr1[b1].equals(arr2[b2])){\\n            l1--;\\n            l2--;\\n            b1--;\\n            b2--;\\n        }\\n        \\n        return l1==0 || l2==0;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329467,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n      if(s1.length()<s2.length()){\\n          return areSentencesSimilar(  s2,   s1) ;\\n      }\\n        \\n        String []a=s1.split(\" \");\\n        String [] b=s2.split(\" \");\\n        int i=0,j=a.length-1,k=b.length-1;\\n        while(i<b.length && a[i].equals(b[i])){\\n          i++;\\n        }\\n        while(k>=0 && a[j].equals(b[k])){\\n           k--; \\n           j--;\\n        }\\n        return i>k; \\n    }\\n}\\n \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n      if(s1.length()<s2.length()){\\n          return areSentencesSimilar(  s2,   s1) ;\\n      }\\n        \\n        String []a=s1.split(\" \");\\n        String [] b=s2.split(\" \");\\n        int i=0,j=a.length-1,k=b.length-1;\\n        while(i<b.length && a[i].equals(b[i])){\\n          i++;\\n        }\\n        while(k>=0 && a[j].equals(b[k])){\\n           k--; \\n           j--;\\n        }\\n        return i>k; \\n    }\\n}\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318792,
                "title": "python-3-lines",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- functional\\n- `assert issubclass(bool, int)`\\n\\n# Complexity\\n- Time complexity: $$O(min(n1, n2))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n1+n2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        prefix = lambda xs, ys: sum(takewhile(bool, map(eq, xs, ys)))\\n        W1, W2 = map(str.split, (sentence1, sentence2))\\n        return prefix(W1, W2) + prefix(reversed(W1), reversed(W2)) >= min(len(W1), len(W2))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        prefix = lambda xs, ys: sum(takewhile(bool, map(eq, xs, ys)))\\n        W1, W2 = map(str.split, (sentence1, sentence2))\\n        return prefix(W1, W2) + prefix(reversed(W1), reversed(W2)) >= min(len(W1), len(W2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292979,
                "title": "java-easy-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.length() == sentence2.length()){\\n            if(sentence1.equals(sentence2)){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        String[] arr1 = sentence1.split(\" \");\\n        String[] arr2 = sentence2.split(\" \");\\n        int len1 = arr1.length;\\n        int len2 = arr2.length;\\n        int start1 = 0;\\n        int start2 = 0;\\n        int end1 = len1-1;\\n        int end2 = len2-1;\\n        while(len1 != 0 && len2 != 0 && arr1[start1].equals(arr2[start2])){\\n            len1--;\\n            len2--;\\n            start1++;\\n            start2++;\\n        }\\n        while(len1 != 0 && len2 != 0 && arr1[end1].equals(arr2[end2])){\\n            len1--;\\n            len2--;\\n            end1--;\\n            end2--;\\n        }\\n        return len1 == 0 || len2 == 0;\\n       \\n       \\n        \\n\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.length() == sentence2.length()){\\n            if(sentence1.equals(sentence2)){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        String[] arr1 = sentence1.split(\" \");\\n        String[] arr2 = sentence2.split(\" \");\\n        int len1 = arr1.length;\\n        int len2 = arr2.length;\\n        int start1 = 0;\\n        int start2 = 0;\\n        int end1 = len1-1;\\n        int end2 = len2-1;\\n        while(len1 != 0 && len2 != 0 && arr1[start1].equals(arr2[start2])){\\n            len1--;\\n            len2--;\\n            start1++;\\n            start2++;\\n        }\\n        while(len1 != 0 && len2 != 0 && arr1[end1].equals(arr2[end2])){\\n            len1--;\\n            len2--;\\n            end1--;\\n            end2--;\\n        }\\n        return len1 == 0 || len2 == 0;\\n       \\n       \\n        \\n\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280163,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        int n1=s1.size();\\n        int n2=s2.size();\\n        if (n1==n2)\\n        {\\n            if (s1==s2) return true;\\n            return false;\\n        }\\n        deque<string>a,b;\\n        s1.push_back(\\' \\');\\n        s2.push_back(\\' \\');\\n        string word=\"\";\\n        for (int i=0;i<=n1;i++)\\n        {\\n            if (s1[i]==\\' \\')\\n            {\\n                a.push_back(word);\\n                word=\"\";\\n            }\\n            else{\\n                word+=s1[i];\\n            }\\n        }\\n        for (int i=0;i<=n2;i++)\\n        {\\n            if (s2[i]==\\' \\')\\n            {\\n                b.push_back(word);\\n                word=\"\";\\n            }\\n            else{\\n                word+=s2[i];\\n            }\\n        }\\n        while(a.size() && b.size() && a.front()==b.front())\\n        {\\n            a.pop_front();\\n            b.pop_front();\\n        }\\n        while(a.size() && b.size() && a.back()==b.back())\\n        {\\n            a.pop_back();\\n            b.pop_back();\\n        }\\n        if (a.size()==0 || b.size()==0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        int n1=s1.size();\\n        int n2=s2.size();\\n        if (n1==n2)\\n        {\\n            if (s1==s2) return true;\\n            return false;\\n        }\\n        deque<string>a,b;\\n        s1.push_back(\\' \\');\\n        s2.push_back(\\' \\');\\n        string word=\"\";\\n        for (int i=0;i<=n1;i++)\\n        {\\n            if (s1[i]==\\' \\')\\n            {\\n                a.push_back(word);\\n                word=\"\";\\n            }\\n            else{\\n                word+=s1[i];\\n            }\\n        }\\n        for (int i=0;i<=n2;i++)\\n        {\\n            if (s2[i]==\\' \\')\\n            {\\n                b.push_back(word);\\n                word=\"\";\\n            }\\n            else{\\n                word+=s2[i];\\n            }\\n        }\\n        while(a.size() && b.size() && a.front()==b.front())\\n        {\\n            a.pop_front();\\n            b.pop_front();\\n        }\\n        while(a.size() && b.size() && a.back()==b.back())\\n        {\\n            a.pop_back();\\n            b.pop_back();\\n        }\\n        if (a.size()==0 || b.size()==0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276223,
                "title": "c-2-pointers-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(string &s1, string &s2)\\n    {\\n        int n1 = s1.size(), n2 = s2.size(), l=0, last = -1;\\n        while(l<n2 && s1[l] == s2[l])\\n        {\\n            if(s1[l] == \\' \\')last = l;\\n            l++;\\n        }\\n        if(l == n2 && s1[l] == \\' \\')return true;\\n        int rem = n2-1-last, r1 = n1-1, r2 = n2-1;\\n        // cout << rem << \\' \\';\\n        while(rem>0)\\n        {\\n            if(s1[r1] == s2[r2]){r1--;r2--;}\\n            else break;\\n            rem--;\\n        }\\n        // cout << last <<  \" \"  << r1 << \" \"  << r2 << \" \"  << rem << \\'\\\\n\\';\\n        return (rem == 0 && (r2 == -1 || s2[r2] == \\' \\') && s1[r1] == \\' \\');\\n    }\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if(s1.size() == s2.size())return s1 == s2;\\n        if(s1.size() > s2.size())return solve(s1, s2);\\n        return solve(s2, s1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string &s1, string &s2)\\n    {\\n        int n1 = s1.size(), n2 = s2.size(), l=0, last = -1;\\n        while(l<n2 && s1[l] == s2[l])\\n        {\\n            if(s1[l] == \\' \\')last = l;\\n            l++;\\n        }\\n        if(l == n2 && s1[l] == \\' \\')return true;\\n        int rem = n2-1-last, r1 = n1-1, r2 = n2-1;\\n        // cout << rem << \\' \\';\\n        while(rem>0)\\n        {\\n            if(s1[r1] == s2[r2]){r1--;r2--;}\\n            else break;\\n            rem--;\\n        }\\n        // cout << last <<  \" \"  << r1 << \" \"  << r2 << \" \"  << rem << \\'\\\\n\\';\\n        return (rem == 0 && (r2 == -1 || s2[r2] == \\' \\') && s1[r1] == \\' \\');\\n    }\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if(s1.size() == s2.size())return s1 == s2;\\n        if(s1.size() > s2.size())return solve(s1, s2);\\n        return solve(s2, s1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3234717,
                "title": "python3-forward-backward-checking",
                "content": "# Code\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if sentence1==sentence2: return True\\n\\n        longer = sentence1 if len(sentence1) >= len(sentence2) else sentence2\\n        shorter = sentence1 if len(sentence1) < len(sentence2) else sentence2\\n        \\n        s1Arr = longer.split(\" \")\\n        N = len(s1Arr)\\n        s2Arr = shorter.split(\" \")\\n\\n        check1 = [False] * len(s1Arr)\\n        check2 = [False] * len(s2Arr)\\n\\n        i = 0     \\n        j = 0\\n\\n        # Forward check\\n        while i<len(s1Arr) and j<len(s2Arr):\\n            if s1Arr[i] == s2Arr[j]:\\n                check1[i]=True\\n                check2[j]=True\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        \\n        for e in check2:\\n            if e==False: return False\\n\\n        cnt = 0\\n        prev = True\\n        for i in range(len(check1)):\\n            if check1[i] == False:\\n                if prev == True:\\n                    cnt += 1\\n            prev = check1[i]\\n\\n        if cnt == 1: return True\\n\\n        check1 = [False] * len(s1Arr)\\n        check2 = [False] * len(s2Arr)\\n\\n        i = len(s1Arr)-1\\n        j = len(s2Arr)-1\\n\\n        # Backward check\\n        while i>=0 and j>=0:\\n            print(i, j)\\n            if s1Arr[i] == s2Arr[j]:\\n                check1[i]=True\\n                check2[j]=True\\n                i-=1\\n                j-=1\\n            else:\\n                i-=1\\n\\n        cnt = 0\\n        prev = True\\n        for i in range(len(check1)):\\n            if check1[i] == False:\\n                if prev == True:\\n                    cnt += 1\\n            prev = check1[i]\\n\\n        if cnt == 1: return True\\n\\n        return False\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        if sentence1==sentence2: return True\\n\\n        longer = sentence1 if len(sentence1) >= len(sentence2) else sentence2\\n        shorter = sentence1 if len(sentence1) < len(sentence2) else sentence2\\n        \\n        s1Arr = longer.split(\" \")\\n        N = len(s1Arr)\\n        s2Arr = shorter.split(\" \")\\n\\n        check1 = [False] * len(s1Arr)\\n        check2 = [False] * len(s2Arr)\\n\\n        i = 0     \\n        j = 0\\n\\n        # Forward check\\n        while i<len(s1Arr) and j<len(s2Arr):\\n            if s1Arr[i] == s2Arr[j]:\\n                check1[i]=True\\n                check2[j]=True\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        \\n        for e in check2:\\n            if e==False: return False\\n\\n        cnt = 0\\n        prev = True\\n        for i in range(len(check1)):\\n            if check1[i] == False:\\n                if prev == True:\\n                    cnt += 1\\n            prev = check1[i]\\n\\n        if cnt == 1: return True\\n\\n        check1 = [False] * len(s1Arr)\\n        check2 = [False] * len(s2Arr)\\n\\n        i = len(s1Arr)-1\\n        j = len(s2Arr)-1\\n\\n        # Backward check\\n        while i>=0 and j>=0:\\n            print(i, j)\\n            if s1Arr[i] == s2Arr[j]:\\n                check1[i]=True\\n                check2[j]=True\\n                i-=1\\n                j-=1\\n            else:\\n                i-=1\\n\\n        cnt = 0\\n        prev = True\\n        for i in range(len(check1)):\\n            if check1[i] == False:\\n                if prev == True:\\n                    cnt += 1\\n            prev = check1[i]\\n\\n        if cnt == 1: return True\\n\\n        return False\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219464,
                "title": "0ms-91-memory-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        int n = sentence1.size() - 1, m = sentence2.size() - 1;\\n        if(n < m){\\n            return areSentencesSimilar(sentence2, sentence1);\\n        }\\n        else if(n == m){\\n            return sentence1 == sentence2;\\n        }\\n\\n        if(sentence1[m + 1] == \\' \\' && sentence1.substr(0, m + 1) == sentence2 || sentence1[n - m - 1] == \\' \\' &&  sentence1.substr(n - m, m + 1) == sentence2){\\n            return 1;\\n        }\\n        while(m >= 0 && sentence1[n] == sentence2[m]){\\n            n--, m--;\\n        }\\n        return sentence1.substr(0, m + 2) == sentence2.substr(0, m + 2) && sentence1[m + 1] == \\' \\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        int n = sentence1.size() - 1, m = sentence2.size() - 1;\\n        if(n < m){\\n            return areSentencesSimilar(sentence2, sentence1);\\n        }\\n        else if(n == m){\\n            return sentence1 == sentence2;\\n        }\\n\\n        if(sentence1[m + 1] == \\' \\' && sentence1.substr(0, m + 1) == sentence2 || sentence1[n - m - 1] == \\' \\' &&  sentence1.substr(n - m, m + 1) == sentence2){\\n            return 1;\\n        }\\n        while(m >= 0 && sentence1[n] == sentence2[m]){\\n            n--, m--;\\n        }\\n        return sentence1.substr(0, m + 2) == sentence2.substr(0, m + 2) && sentence1[m + 1] == \\' \\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188639,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        \\n        stringstream ob(s1);\\n        \\n        vector<string> v1;\\n        \\n        string word;\\n        \\n        while(ob >> word)\\n        {\\n            v1.push_back(word);\\n        }\\n        \\n        stringstream ob1(s2);\\n        \\n        vector<string> v2;\\n        \\n        string word1;\\n        \\n        while(ob1 >> word1)\\n        {\\n            v2.push_back(word1);\\n        }\\n        \\n        int start1 =0, start2=0,end1=v1.size()-1,end2=v2.size()-1;\\n        \\n        while(start1 <=end1 && start2 <= end2)\\n        {\\n            if(v1[start1] == v2[start2])\\n            {\\n                start1++;\\n                start2++;\\n            }\\n            else if(v1[end1] == v2[end2])\\n            {\\n                end1--;\\n                end2--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        \\n        stringstream ob(s1);\\n        \\n        vector<string> v1;\\n        \\n        string word;\\n        \\n        while(ob >> word)\\n        {\\n            v1.push_back(word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3149770,
                "title": "easy-simple-python-code-with-exp",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust track the count of words matched from starting and ending of the bigger sentence.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def areSentencesSimilar(self, s1, s2):\\n        # let word1 is smaller sentence and word2 is larger\\n        word1, word2 = s1.split(\" \"), s2.split(\" \")\\n        s, l = len(word1), len(word2)\\n        if s>l:\\n            word1, word2 = word2, word1\\n            s,l = l,s\\n        \\n\\n        i=0\\n        # number of words match from starting\\n        while i < s and word1[i]==word2[i]:\\n            i += 1\\n        # number of words match from ending\\n        while i < s and word1[i]==word2[l-s+i]:\\n            i += 1\\n        # if the words matched is equal to smaller sentence return True\\n        return i==s\\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def areSentencesSimilar(self, s1, s2):\\n        # let word1 is smaller sentence and word2 is larger\\n        word1, word2 = s1.split(\" \"), s2.split(\" \")\\n        s, l = len(word1), len(word2)\\n        if s>l:\\n            word1, word2 = word2, word1\\n            s,l = l,s\\n        \\n\\n        i=0\\n        # number of words match from starting\\n        while i < s and word1[i]==word2[i]:\\n            i += 1\\n        # number of words match from ending\\n        while i < s and word1[i]==word2[l-s+i]:\\n            i += 1\\n        # if the words matched is equal to smaller sentence return True\\n        return i==s\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062813,
                "title": "tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to remove extra words from start and end so gives a vauge idea of using deque\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        // first make a double ended queue\\n        deque<string> s1,s2;\\n\\n        // enter the words from both sentences\\n        string temp=\"\";\\n        for(int i=0; i<sentence1.size(); i++){\\n            if(sentence1[i] == \\' \\'){\\n                s1.push_back(temp);\\n                temp=\"\";\\n            }\\n            else{\\n                temp+=sentence1[i];\\n            }\\n        }\\n        // the last word will be left\\n        s1.push_back(temp);\\n        temp=\"\";\\n        for(int i=0; i<sentence2.size(); i++){\\n            if(sentence2[i] == \\' \\'){\\n                s2.push_back(temp);\\n                temp=\"\";\\n            }\\n            else{\\n                temp+=sentence2[i];\\n            }\\n        }\\n        s2.push_back(temp);\\n\\n\\n        while(s1.size() !=0 && s2.size() !=0 && (s1.front() == s2.front())){\\n            s1.pop_front();\\n            s2.pop_front();\\n        }\\n\\n         while(s1.size() !=0 && s2.size() !=0 && (s1.back() == s2.back())){\\n            s1.pop_back();\\n            s2.pop_back();\\n        }\\n\\n\\n        if(s1.size() == 0 || s2.size() == 0){\\n            return true;\\n        }\\n\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        // first make a double ended queue\\n        deque<string> s1,s2;\\n\\n        // enter the words from both sentences\\n        string temp=\"\";\\n        for(int i=0; i<sentence1.size(); i++){\\n            if(sentence1[i] == \\' \\'){\\n                s1.push_back(temp);\\n                temp=\"\";\\n            }\\n            else{\\n                temp+=sentence1[i];\\n            }\\n        }\\n        // the last word will be left\\n        s1.push_back(temp);\\n        temp=\"\";\\n        for(int i=0; i<sentence2.size(); i++){\\n            if(sentence2[i] == \\' \\'){\\n                s2.push_back(temp);\\n                temp=\"\";\\n            }\\n            else{\\n                temp+=sentence2[i];\\n            }\\n        }\\n        s2.push_back(temp);\\n\\n\\n        while(s1.size() !=0 && s2.size() !=0 && (s1.front() == s2.front())){\\n            s1.pop_front();\\n            s2.pop_front();\\n        }\\n\\n         while(s1.size() !=0 && s2.size() !=0 && (s1.back() == s2.back())){\\n            s1.pop_back();\\n            s2.pop_back();\\n        }\\n\\n\\n        if(s1.size() == 0 || s2.size() == 0){\\n            return true;\\n        }\\n\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058272,
                "title": "c-compare-string-via-one-character-by-one-character",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        auto len1 = sentence1.length();\\n        auto len2 = sentence2.length();\\n     \\n        if (len1 == len2) {\\n            return sentence1 == sentence2;\\n        }\\n        \\n        bool ans;\\n        if (len1 > len2) {\\n            ans = isSimilar(sentence1, sentence2);\\n        } else {\\n            ans = isSimilar(sentence2, sentence1);\\n        } \\n        \\n        return ans;\\n    }\\n    \\n\\n    \\n    bool isSimilar(const string &str1, const string &str2) {\\n        auto len1 = str1.length();\\n        auto len2 = str2.length();\\n        int left;\\n\\n       \\n        for (left = 0; left < len2; left++) {\\n            if (str1[left] != str2[left]) {\\n                break;\\n            }\\n        }\\n        /* The str2 is a prefix of the str1 */\\n        if (left == len2 && str1[left] == \\' \\') {\\n            return true;\\n        }\\n        \\n         \\n        int right = len2 - 1;\\n        int i = len1 - 1;\\n        do {\\n            if (str1[i] != str2[right]) {\\n                break;\\n            }\\n            --i;\\n            --right;\\n        } while (right >= left);\\n        \\n        /* Check if the str2 is a suffix of the str1 */      \\n        if (right == -1) {\\n            return str1[i] == \\' \\' ? true : false;\\n        }\\n        \\n        /* Check if the str2 is able to be replenished as the str1 */\\n        return (right + 1 == left) && (str1[i] == str2[right]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        auto len1 = sentence1.length();\\n        auto len2 = sentence2.length();\\n     \\n        if (len1 == len2) {\\n            return sentence1 == sentence2;\\n        }\\n        \\n        bool ans;\\n        if (len1 > len2) {\\n            ans = isSimilar(sentence1, sentence2);\\n        } else {\\n            ans = isSimilar(sentence2, sentence1);\\n        } \\n        \\n        return ans;\\n    }\\n    \\n\\n    \\n    bool isSimilar(const string &str1, const string &str2) {\\n        auto len1 = str1.length();\\n        auto len2 = str2.length();\\n        int left;\\n\\n       \\n        for (left = 0; left < len2; left++) {\\n            if (str1[left] != str2[left]) {\\n                break;\\n            }\\n        }\\n        /* The str2 is a prefix of the str1 */\\n        if (left == len2 && str1[left] == \\' \\') {\\n            return true;\\n        }\\n        \\n         \\n        int right = len2 - 1;\\n        int i = len1 - 1;\\n        do {\\n            if (str1[i] != str2[right]) {\\n                break;\\n            }\\n            --i;\\n            --right;\\n        } while (right >= left);\\n        \\n        /* Check if the str2 is a suffix of the str1 */      \\n        if (right == -1) {\\n            return str1[i] == \\' \\' ? true : false;\\n        }\\n        \\n        /* Check if the str2 is able to be replenished as the str1 */\\n        return (right + 1 == left) && (str1[i] == str2[right]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982818,
                "title": "c-easy-and-100-fast-and-simple",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        //store all the words in a vector of string \\n        vector<string> arr1;\\n        vector<string> arr2;\\n        \\n        //i want to keep a track of which sentence is longer and which sentence  is smaller\\n        //Because it would help me when i use two pointer approach\\n        \\n        string longest=sentence1;\\n        string shortest=sentence2;\\n        \\n        if(sentence1.length()<sentence2.length())\\n        {\\n            longest=sentence2;\\n            shortest=sentence1;\\n        }\\n        string currWord=\"\";\\n        for(int i=0;i<longest.length();i++)\\n        {\\n            if(longest[i]==\\' \\')\\n            {\\n                arr1.push_back(currWord);\\n                currWord=\"\";\\n                continue;\\n            }\\n            currWord.push_back(longest[i]);\\n        }\\n        //add the last word too\\n        arr1.push_back(currWord);\\n        \\n        //store the strings in sentence 2\\n        currWord=\"\";\\n        for(int i=0;i<shortest.length();i++)\\n        {\\n            if(shortest[i]==\\' \\')\\n            {\\n                arr2.push_back(currWord);\\n                currWord=\"\";\\n                continue;\\n            }\\n            currWord.push_back(shortest[i]);\\n        }\\n        arr2.push_back(currWord);\\n        \\n        //use two pointer approach \\n        // i always to the arr1 (longest) \\n        //j points to the arr2  (shortest)\\n        int start1=0;\\n        int start2=0;\\n        int end1=arr1.size()-1;\\n        int end2=arr2.size()-1;\\n         while(start1<=end1 && start2<=end2){\\n            if(arr1[start1]==arr2[start2]) //if crrent both starting words are same\\n                start1++,start2++;\\n            else if(arr1[end1]==arr2[end2]) //if the  current both ending words are same\\n                end1--,end2--;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        //store all the words in a vector of string \\n        vector<string> arr1;\\n        vector<string> arr2;\\n        \\n        //i want to keep a track of which sentence is longer and which sentence  is smaller\\n        //Because it would help me when i use two pointer approach\\n        \\n        string longest=sentence1;\\n        string shortest=sentence2;\\n        \\n        if(sentence1.length()<sentence2.length())\\n        {\\n            longest=sentence2;\\n            shortest=sentence1;\\n        }\\n        string currWord=\"\";\\n        for(int i=0;i<longest.length();i++)\\n        {\\n            if(longest[i]==\\' \\')\\n            {\\n                arr1.push_back(currWord);\\n                currWord=\"\";\\n                continue;\\n            }\\n            currWord.push_back(longest[i]);\\n        }\\n        //add the last word too\\n        arr1.push_back(currWord);\\n        \\n        //store the strings in sentence 2\\n        currWord=\"\";\\n        for(int i=0;i<shortest.length();i++)\\n        {\\n            if(shortest[i]==\\' \\')\\n            {\\n                arr2.push_back(currWord);\\n                currWord=\"\";\\n                continue;\\n            }\\n            currWord.push_back(shortest[i]);\\n        }\\n        arr2.push_back(currWord);\\n        \\n        //use two pointer approach \\n        // i always to the arr1 (longest) \\n        //j points to the arr2  (shortest)\\n        int start1=0;\\n        int start2=0;\\n        int end1=arr1.size()-1;\\n        int end2=arr2.size()-1;\\n         while(start1<=end1 && start2<=end2){\\n            if(arr1[start1]==arr2[start2]) //if crrent both starting words are same\\n                start1++,start2++;\\n            else if(arr1[end1]==arr2[end2]) //if the  current both ending words are same\\n                end1--,end2--;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959317,
                "title": "java-1ms-best-solution-easy-approach-with-explanation-in-comments",
                "content": "# Approach: Check the end and start and iterate accordingly\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n        //Split the array.\\n        String[] str1 = s1.split(\" \");\\n        String[] str2 = s2.split(\" \");\\n        //check which string have the more words and less words so we can put words in lesser sentence array to make it equal\\n        return str1.length<=str2.length ? check(str1,str2) : check(str2,str1);\\n        //by this fn we ensure s1 have more words than s2 \\n    }\\n\\n    public boolean check(String[] str1, String[] str2){\\n        int diff = 0;\\n        int i=0;\\n\\n        //taking length of both strings\\n        int len1 = str1.length;\\n        int len2 = str2.length;\\n\\n        //checking the first word of the array\\n        while(i<len1 && str1[i].equals(str2[i])){\\n            i++;\\n            diff++;\\n        }\\n        //checking the last word of the array\\n        while(i<len1 && str1[i].equals(str2[len2-len1+i])){\\n            i++;\\n            diff++;\\n        }\\n        //if the length of the lesser words array is equal to the difference then return\\n        return len1==diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String s1, String s2) {\\n        //Split the array.\\n        String[] str1 = s1.split(\" \");\\n        String[] str2 = s2.split(\" \");\\n        //check which string have the more words and less words so we can put words in lesser sentence array to make it equal\\n        return str1.length<=str2.length ? check(str1,str2) : check(str2,str1);\\n        //by this fn we ensure s1 have more words than s2 \\n    }\\n\\n    public boolean check(String[] str1, String[] str2){\\n        int diff = 0;\\n        int i=0;\\n\\n        //taking length of both strings\\n        int len1 = str1.length;\\n        int len2 = str2.length;\\n\\n        //checking the first word of the array\\n        while(i<len1 && str1[i].equals(str2[i])){\\n            i++;\\n            diff++;\\n        }\\n        //checking the last word of the array\\n        while(i<len1 && str1[i].equals(str2[len2-len1+i])){\\n            i++;\\n            diff++;\\n        }\\n        //if the length of the lesser words array is equal to the difference then return\\n        return len1==diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958614,
                "title": "python-greedy-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = sentence1.split()\\n        s2 = sentence2.split()\\n        n1, n2 = len(s1), len(s2)\\n        if n1 == n2: return s1 == s2\\n        if n1 > n2:\\n            s1, s2 = s2, s1\\n            n1, n2 = n2, n1\\n        i, j = 0, 1\\n        while i < n1 and s1[i] == s2[i]: i += 1\\n        while j <= n1 and s1[n1-j] == s2[n2-j]: j += 1\\n        return i + j - 1 >= n1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1 = sentence1.split()\\n        s2 = sentence2.split()\\n        n1, n2 = len(s1), len(s2)\\n        if n1 == n2: return s1 == s2\\n        if n1 > n2:\\n            s1, s2 = s2, s1\\n            n1, n2 = n2, n1\\n        i, j = 0, 1\\n        while i < n1 and s1[i] == s2[i]: i += 1\\n        while j <= n1 and s1[n1-j] == s2[n2-j]: j += 1\\n        return i + j - 1 >= n1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896675,
                "title": "java-easy-o-n-o-n",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] s1=sentence1.split(\" \");\\n        String[] s2=sentence2.split(\" \");\\n        \\n        int i=0,j=0;\\n\\n        while(i<s1.length && j<s2.length){\\n            if(!s1[i].equals(s2[j])){\\n                i--;\\n                j--;\\n                break;\\n            }\\n            i++;\\n            j++;\\n        }\\n        if (i == s1.length || j == s2.length) return true;\\n\\n\\n        int m=s1.length-1,n=s2.length-1;\\n\\n        while(m>i && n>j){\\n            if(!s1[m].equals(s2[n])){\\n                m++;\\n                n++;\\n                break;\\n            }\\n            m--;\\n            n--;\\n        }\\n        // System.out.println(j+\" \"+n);\\n        return m==i || n==j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] s1=sentence1.split(\" \");\\n        String[] s2=sentence2.split(\" \");\\n        \\n        int i=0,j=0;\\n\\n        while(i<s1.length && j<s2.length){\\n            if(!s1[i].equals(s2[j])){\\n                i--;\\n                j--;\\n                break;\\n            }\\n            i++;\\n            j++;\\n        }\\n        if (i == s1.length || j == s2.length) return true;\\n\\n\\n        int m=s1.length-1,n=s2.length-1;\\n\\n        while(m>i && n>j){\\n            if(!s1[m].equals(s2[n])){\\n                m++;\\n                n++;\\n                break;\\n            }\\n            m--;\\n            n--;\\n        }\\n        // System.out.println(j+\" \"+n);\\n        return m==i || n==j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884757,
                "title": "scala-o-n-clean-recursion",
                "content": "```Scala\\nobject Solution {\\n    def areSentencesSimilar(sentence1: String, sentence2: String): Boolean = {\\n        def helper(s1: Vector[String], s2: Vector[String]): Boolean = (s1, s2) match {\\n            case (Nil, _) => true\\n            case (_, Nil) => true\\n            case (h1 +: r1, h2 +: r2) if (h1 == h2) => helper(r1, r2)\\n            case (r1 :+ t1, r2 :+ t2) if (t1 == t2) => helper(r1, r2)\\n            case _ => false\\n        }\\n        \\n        helper(sentence1.split(\" \").toVector, sentence2.split(\" \").toVector)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```Scala\\nobject Solution {\\n    def areSentencesSimilar(sentence1: String, sentence2: String): Boolean = {\\n        def helper(s1: Vector[String], s2: Vector[String]): Boolean = (s1, s2) match {\\n            case (Nil, _) => true\\n            case (_, Nil) => true\\n            case (h1 +: r1, h2 +: r2) if (h1 == h2) => helper(r1, r2)\\n            case (r1 :+ t1, r2 :+ t2) if (t1 == t2) => helper(r1, r2)\\n            case _ => false\\n        }\\n        \\n        helper(sentence1.split(\" \").toVector, sentence2.split(\" \").toVector)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2815734,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        stringstream take1(sentence1),take2(sentence2);\\n        string word;\\n        deque<string> q1,q2;\\n        while(take1>>word)q1.push_back(word);\\n        while(take2>>word)q2.push_back(word);\\n        \\n        while(q1.size() and q2.size() and q1.back() == q2.back())\\n                    q1.pop_back(),q2.pop_back();\\n        while(q1.size() and q2.size() and q1.front() == q2.front())\\n                    q1.pop_front(),q2.pop_front();\\n        \\n        return q1.empty() or q2.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        stringstream take1(sentence1),take2(sentence2);\\n        string word;\\n        deque<string> q1,q2;\\n        while(take1>>word)q1.push_back(word);\\n        while(take2>>word)q2.push_back(word);\\n        \\n        while(q1.size() and q2.size() and q1.back() == q2.back())\\n                    q1.pop_back(),q2.pop_back();\\n        while(q1.size() and q2.size() and q1.front() == q2.front())\\n                    q1.pop_front(),q2.pop_front();\\n        \\n        return q1.empty() or q2.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761818,
                "title": "python-o-n-solution-93-time-80-memory",
                "content": "# Intuition\\n\\n\\n# Approach\\nSplit the string by space \\nAlways compare from the shortest splited result\\nFind the first different index \\nSubstract the shortest array from index\\nSubstract the longest array from the approate index\\ncompare two substracted array (as string)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ n = len(shortest arr after split)\\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s2 = sentence2.split(\\' \\')\\n        s1 = sentence1.split(\\' \\')\\n        \\n        def compare(s1,s2):\\n            idx = 0\\n            for i in range(len(s2)):\\n                if s2[i] == s1[i]:\\n                    idx+=1\\n                else:\\n                    break\\n         \\n            left = s2[idx:]\\n            itemTake = len(s2)-idx\\n            right = s1[len(s1)-itemTake:]\\n            return \\' \\'.join(left) == \\' \\'.join(right)\\n\\n            ## alternative way to save memory\\n            ## for i in range(idx, len(s2)):\\n            ##      if s2[i] != s1[len(s1)-len(s2)+i]:\\n            ##          return False\\n            ##      return True\\n            \\n\\n        if len(s1) > len(s2):\\n            return compare(s1,s2)\\n        else:\\n            return compare(s2,s1)\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s2 = sentence2.split(\\' \\')\\n        s1 = sentence1.split(\\' \\')\\n        \\n        def compare(s1,s2):\\n            idx = 0\\n            for i in range(len(s2)):\\n                if s2[i] == s1[i]:\\n                    idx+=1\\n                else:\\n                    break\\n         \\n            left = s2[idx:]\\n            itemTake = len(s2)-idx\\n            right = s1[len(s1)-itemTake:]\\n            return \\' \\'.join(left) == \\' \\'.join(right)\\n\\n            ## alternative way to save memory\\n            ## for i in range(idx, len(s2)):\\n            ##      if s2[i] != s1[len(s1)-len(s2)+i]:\\n            ##          return False\\n            ##      return True\\n            \\n\\n        if len(s1) > len(s2):\\n            return compare(s1,s2)\\n        else:\\n            return compare(s2,s1)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754100,
                "title": "java-straightforward-2ms-solution",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String [] words1 = sentence1.split(\" \");\\n        String [] words2 = sentence2.split(\" \");\\n        return words1.length<=words2.length ? checkSimilar(words1,words2) :  checkSimilar(words2,words1);\\n    }\\n    public boolean checkSimilar(String[] words1, String[] words2){\\n        \\n        int count=0;\\n        int n1 = words1.length;\\n        int n2 = words2.length;\\n        int i=0;\\n        while(i<n1 && words1[i].equals(words2[i])){\\n            i++;\\n            count++;\\n        }\\n        while(i<n1 && words1[i].equals(words2[n2-n1+i])){\\n            i++;\\n            count++;\\n        }\\n        return n1==count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String [] words1 = sentence1.split(\" \");\\n        String [] words2 = sentence2.split(\" \");\\n        return words1.length<=words2.length ? checkSimilar(words1,words2) :  checkSimilar(words2,words1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2717274,
                "title": "java-beats-100-with-explanation-in-comments",
                "content": "# Intuition & Approach\\nCheck code comments\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ where n is the number of words of sentence having LESS words\\n\\n- Space complexity:\\n$$O(n)$$ where n is the number of words of sentence having MORE words\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] sent1 = sentence1.split(\" \");\\n        String[] sent2 = sentence2.split(\" \");\\n        // split sentence into words\\n\\n// a sentence with less words will have some words put into it to try to make it equal to the sentence with more words\\n        \\n        return sent1.length >= sent2.length ? areSentencesSimilar(sent1, sent2) : areSentencesSimilar(sent2, sent1);\\n        //by this we are ensuring sent1 has more words than sent2 when it is passed in the next function\\n    }\\n\\n    boolean areSentencesSimilar(String[] words1, String[] words2) {\\n        // length of words1 is bigger than or equal to words2, so we will have to put some imaginary words in words2 to try to make it equal to words1\\n        int len1 = words1.length;\\n        int len2 = words2.length;\\n        // len1 >= len2\\n        int diff = len1 - len2;\\n        // difference tells us how many words we will have to put in\\n        int i=0; // for now i is pointer for both arrays\\n        // we are checking until when words are equal\\n        while(i<len2 && words1[i].equals(words2[i])){\\n            i++;\\n        }\\n        if(i==len2) return true; \\n        // if i reached end of smaller array, then answer is true, since starting of larger array and whole of smaller array is equal, so we can just place all the words at the end of smaller sentence and make it equal.\\n        \\n        int j = i + diff; \\n        // say we have a diff of 4 words in both arrays, so larger array has 4 more words than smaller array, then we assume that in order to make smaller array equal to larger array we added 4 words at the index where there was a diff\\n        // but we can\\'t actually add words here, so we skip 4 (or diff amount of indices) in larger array assuming the words will be added at this index in small array, and then keep checking ahead if the rest of the parts of the sentence are equal \\n        while( i<len2 && j<len1 && words1[j].equals(words2[i])){\\n            i++;\\n            j++;\\n        }\\n        // if after adding words, the rest of the words are equal then j, the pointer for largest array will reach the end of the array\\n        // return j==len1;\\n        return i==len2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] sent1 = sentence1.split(\" \");\\n        String[] sent2 = sentence2.split(\" \");\\n        // split sentence into words\\n\\n// a sentence with less words will have some words put into it to try to make it equal to the sentence with more words\\n        \\n        return sent1.length >= sent2.length ? areSentencesSimilar(sent1, sent2) : areSentencesSimilar(sent2, sent1);\\n        //by this we are ensuring sent1 has more words than sent2 when it is passed in the next function\\n    }\\n\\n    boolean areSentencesSimilar(String[] words1, String[] words2) {\\n        // length of words1 is bigger than or equal to words2, so we will have to put some imaginary words in words2 to try to make it equal to words1\\n        int len1 = words1.length;\\n        int len2 = words2.length;\\n        // len1 >= len2\\n        int diff = len1 - len2;\\n        // difference tells us how many words we will have to put in\\n        int i=0; // for now i is pointer for both arrays\\n        // we are checking until when words are equal\\n        while(i<len2 && words1[i].equals(words2[i])){\\n            i++;\\n        }\\n        if(i==len2) return true; \\n        // if i reached end of smaller array, then answer is true, since starting of larger array and whole of smaller array is equal, so we can just place all the words at the end of smaller sentence and make it equal.\\n        \\n        int j = i + diff; \\n        // say we have a diff of 4 words in both arrays, so larger array has 4 more words than smaller array, then we assume that in order to make smaller array equal to larger array we added 4 words at the index where there was a diff\\n        // but we can\\'t actually add words here, so we skip 4 (or diff amount of indices) in larger array assuming the words will be added at this index in small array, and then keep checking ahead if the rest of the parts of the sentence are equal \\n        while( i<len2 && j<len1 && words1[j].equals(words2[i])){\\n            i++;\\n            j++;\\n        }\\n        // if after adding words, the rest of the words are equal then j, the pointer for largest array will reach the end of the array\\n        // return j==len1;\\n        return i==len2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712337,
                "title": "deque-solution-c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    void put_words_in_deque(string sen, deque<string> &dq){\\n        \\n        int sen_len=sen.length(), start=0;\\n        while(start< sen_len){\\n            string temp=\"\";\\n            while(sen[start]!=\\' \\' && sen[start]!=\\'\\\\0\\'){\\n                temp+=sen[start];\\n                start++;\\n            }\\n            start++;\\n            dq.push_back(temp);\\n            \\n        }\\n    }\\n    bool areSentencesSimilar(string sen1, string sen2) {\\n        \\n        deque<string> dq1, dq2;\\n        put_words_in_deque(sen1, dq1);\\n        put_words_in_deque(sen2, dq2);\\n        \\n        \\n        while(!dq1.empty() && !dq2.empty() && dq1.front()==dq2.front()){\\n            dq1.pop_front(), dq2.pop_front();\\n        }\\n        \\n        while(!dq1.empty() && !dq2.empty() && dq1.back()==dq2.back()){\\n            dq1.pop_back(), dq2.pop_back();\\n        }\\n        \\n        if(dq1.empty() || dq2.empty())\\n            return true;\\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    void put_words_in_deque(string sen, deque<string> &dq){\\n        \\n        int sen_len=sen.length(), start=0;\\n        while(start< sen_len){\\n            string temp=\"\";\\n            while(sen[start]!=\\' \\' && sen[start]!=\\'\\\\0\\'){\\n                temp+=sen[start];\\n                start++;\\n            }\\n            start++;\\n            dq.push_back(temp);\\n            \\n        }\\n    }\\n    bool areSentencesSimilar(string sen1, string sen2) {\\n        \\n        deque<string> dq1, dq2;\\n        put_words_in_deque(sen1, dq1);\\n        put_words_in_deque(sen2, dq2);\\n        \\n        \\n        while(!dq1.empty() && !dq2.empty() && dq1.front()==dq2.front()){\\n            dq1.pop_front(), dq2.pop_front();\\n        }\\n        \\n        while(!dq1.empty() && !dq2.empty() && dq1.back()==dq2.back()){\\n            dq1.pop_back(), dq2.pop_back();\\n        }\\n        \\n        if(dq1.empty() || dq2.empty())\\n            return true;\\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682333,
                "title": "java-clean-code",
                "content": "class Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        \\n        \\n        if(sentence1.length()>=sentence2.length()){\\n            \\n            return check(sentence2,sentence1);\\n        }else{\\n            \\n            return check(sentence1,sentence2);\\n        }    \\n        \\n    }\\n    \\n    public boolean check(String shot, String lon){\\n        \\n        String[]s=shot.split(\" \");\\n        String[]l=lon.split(\" \");\\n     \\n      int start1=0, start2=0, end1=s.length-1, end2=l.length-1;\\n        \\n        while(start1<=end1){\\n            \\n     if(s[start1].equals(l[start2]) && (s[end1]).equals(l[end2])){\\n                \\n                start1++;\\n                start2++;\\n                end1--;\\n                end2--;\\n            }else if(s[end1].equals(l[end2])){\\n                \\n                end1--;\\n                end2--;\\n            }else if(s[start1].equals(l[start2])){\\n                \\n                start1++;\\n                start2++;\\n            }else{\\n                \\n                return false;\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        \\n        \\n        if(sentence1.length()>=sentence2.length()){\\n            \\n            return check(sentence2,sentence1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2660896,
                "title": "java-2ms-explained",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.length()==sentence2.length()){   // Basic comparison !\\n            return sentence1.equals(sentence2)?true:false;\\n        }\\n        String big,low;\\n        if(sentence1.length()>sentence2.length()){\\n            big=sentence1;\\n            low=sentence2;\\n        }else{\\n            big=sentence2;\\n            low=sentence1;\\n        }             // seperating the two strings on the basis of their length.\\n        return evaluate(big,low);    // function made by me.\\n    }\\n    boolean evaluate(String a , String b){\\n        String[] big=a.split(\" \");   //coverting strings into string arrays for easy iteration.\\n        String[] low = b.split(\" \");\\n        int l= low .length;\\n        int i=0;\\n        while(i<l){      //iterarting over shorter length so that out of bound is error is avoided.\\n           if(!big[i].equals(low[i])){\\n                break;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        if(i==l){  // condition when the shorter string is prefix of bigger string.\\n            return true;\\n        }\\n        int leni=big.length-1;  // checking for the suffix part(if equal) after getting prefix checked\\n        int j = l-1;      //                   0   1    2   3 \\n        while(j>=i){  // till i because ex--; \"My name is Haley\" and \"My name\" first common prefix would be checked which exists till i=0 only and in suffix part we check from last index of shorter one to i.\\n            if(!big[leni].equals(low[j])){\\n                return false;  // this means that neither prefix nor suffix part of big string is similar to shorter string.\\n            }\\n            else{\\n                j--;\\n                leni--;\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.length()==sentence2.length()){   // Basic comparison !\\n            return sentence1.equals(sentence2)?true:false;\\n        }\\n        String big,low;\\n        if(sentence1.length()>sentence2.length()){\\n            big=sentence1;\\n            low=sentence2;\\n        }else{\\n            big=sentence2;\\n            low=sentence1;\\n        }             // seperating the two strings on the basis of their length.\\n        return evaluate(big,low);    // function made by me.\\n    }\\n    boolean evaluate(String a , String b){\\n        String[] big=a.split(\" \");   //coverting strings into string arrays for easy iteration.\\n        String[] low = b.split(\" \");\\n        int l= low .length;\\n        int i=0;\\n        while(i<l){      //iterarting over shorter length so that out of bound is error is avoided.\\n           if(!big[i].equals(low[i])){\\n                break;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        if(i==l){  // condition when the shorter string is prefix of bigger string.\\n            return true;\\n        }\\n        int leni=big.length-1;  // checking for the suffix part(if equal) after getting prefix checked\\n        int j = l-1;      //                   0   1    2   3 \\n        while(j>=i){  // till i because ex--; \"My name is Haley\" and \"My name\" first common prefix would be checked which exists till i=0 only and in suffix part we check from last index of shorter one to i.\\n            if(!big[leni].equals(low[j])){\\n                return false;  // this means that neither prefix nor suffix part of big string is similar to shorter string.\\n            }\\n            else{\\n                j--;\\n                leni--;\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631960,
                "title": "very-easy-solution-in-python-less-then-10-lines",
                "content": "Python is particularly powerful for this kind of problem! \\n\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        sentence1, sentence2 = sentence1.split(), sentence2.split()\\n        if len(sentence2) > len(sentence1):\\n            sentence1, sentence2 = sentence2, sentence1\\n        for p in range(len(sentence2)):\\n            if sentence1[p] != sentence2[p]:\\n                return sentence1[-(len(sentence2) - p):] == sentence2[p:]\\n        return True",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Python is particularly powerful for this kind of problem! \\n\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        sentence1, sentence2 = sentence1.split(), sentence2.split()\\n        if len(sentence2) > len(sentence1):\\n            sentence1, sentence2 = sentence2, sentence1\\n        for p in range(len(sentence2)):\\n            if sentence1[p] != sentence2[p]:\\n                return sentence1[-(len(sentence2) - p):] == sentence2[p:]\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2591029,
                "title": "c-string-commented",
                "content": "```\\n/* thier are four use case that both sentence have similarity \\n1)(a)-------\\n  (b)    ---\\n    prefix of sentence need to be inserted\\n2)(a)-------\\n  (b)---\\n    suffix of sentence need to be inserted\\n3)(a)-------\\n  (b)--  ---\\n   middle part of the sentence need to be inserted\\n4)(a)-------\\n  (b)-------\\n   both the string are same   \\n \\n\\n        think as you are empting both string as \\n        the suffix and prefix word matches \\n        so if one of string gets empty then the sentence can be similar\\n        if not then it need more than one insertion\\n*/\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        vector<string> S1;\\n        vector<string> S2;\\n        string temp=\"\";\\n        for(int i=0;i<sentence1.size();i++){\\n            if(sentence1[i]==\\' \\'){\\n                S1.push_back(temp);\\n                temp=\"\";\\n            }else{\\n                temp+=sentence1[i];\\n            }\\n        }\\n        S1.push_back(temp);\\n        temp=\"\";\\n        for(int i=0;i<sentence2.size();i++){\\n            if(sentence2[i]==\\' \\'){\\n                S2.push_back(temp);\\n                // cout<<temp<<\" \";\\n                temp=\"\";\\n            }else{\\n                temp+=sentence2[i];\\n            }\\n        }\\n        S2.push_back(temp);\\n        // cout<<temp<<\"\\\\n\";\\n        int n=S1.size()-1,m=S2.size()-1;\\n        int i=0,j=0;\\n        bool flag=true;\\n        \\n\\n        while(i<=n && j<=m){\\n            if(S1[i]==S2[j]){\\n                i++;\\n                j++;\\n            }\\n            else if(S1[n]==S2[m]){\\n                n--;\\n                m--;\\n            }\\n            else {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n/* thier are four use case that both sentence have similarity \\n1)(a)-------\\n  (b)    ---\\n    prefix of sentence need to be inserted\\n2)(a)-------\\n  (b)---\\n    suffix of sentence need to be inserted\\n3)(a)-------\\n  (b)--  ---\\n   middle part of the sentence need to be inserted\\n4)(a)-------\\n  (b)-------\\n   both the string are same   \\n \\n\\n        think as you are empting both string as \\n        the suffix and prefix word matches \\n        so if one of string gets empty then the sentence can be similar\\n        if not then it need more than one insertion\\n*/\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        vector<string> S1;\\n        vector<string> S2;\\n        string temp=\"\";\\n        for(int i=0;i<sentence1.size();i++){\\n            if(sentence1[i]==\\' \\'){\\n                S1.push_back(temp);\\n                temp=\"\";\\n            }else{\\n                temp+=sentence1[i];\\n            }\\n        }\\n        S1.push_back(temp);\\n        temp=\"\";\\n        for(int i=0;i<sentence2.size();i++){\\n            if(sentence2[i]==\\' \\'){\\n                S2.push_back(temp);\\n                // cout<<temp<<\" \";\\n                temp=\"\";\\n            }else{\\n                temp+=sentence2[i];\\n            }\\n        }\\n        S2.push_back(temp);\\n        // cout<<temp<<\"\\\\n\";\\n        int n=S1.size()-1,m=S2.size()-1;\\n        int i=0,j=0;\\n        bool flag=true;\\n        \\n\\n        while(i<=n && j<=m){\\n            if(S1[i]==S2[j]){\\n                i++;\\n                j++;\\n            }\\n            else if(S1[n]==S2[m]){\\n                n--;\\n                m--;\\n            }\\n            else {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2548197,
                "title": "correct-my-code",
                "content": "class Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        string temp=\"\";\\n        int senlen1=sentence1.length();\\n        int senlen2=sentence2.length();\\n        stringstream ss1;\\n        stringstream ss2;\\n        if(sentence1==sentence2) return true;\\n        if(senlen1>senlen2){ temp=sentence1; ss1<<sentence2; ss2<<sentence1;}\\n        else {temp=sentence2; ss1<<sentence1;ss2<<sentence2;}\\n        string word1,word2;\\n        while(ss1>> word1){\\n            while(ss2>> word2){\\n                if(word1==word2) {temp.erase(temp.find(word1)!=string::npos,word1.length());\\n                break;}\\n            }\\n        }\\n        if(sentence1.find(temp)!=string::npos || sentence2.find(temp)!=string::npos)return true;\\n        else return false;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        string temp=\"\";\\n        int senlen1=sentence1.length();\\n        int senlen2=sentence2.length();\\n        stringstream ss1;\\n        stringstream ss2;\\n        if(sentence1==sentence2) return true;\\n        if(senlen1>senlen2){ temp=sentence1; ss1<<sentence2; ss2<<sentence1;}",
                "codeTag": "Java"
            },
            {
                "id": 2535015,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        vector<string>v1,v2;\\n        string str=\"\";\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if(s1[i]!=\\' \\')\\n                str+=s1[i];\\n            else\\n            {\\n                v1.push_back(str);\\n                str=\"\";\\n            }\\n        }\\n        v1.push_back(str);\\n        str=\"\";\\n        for(int i=0;i<s2.size();i++)\\n        {\\n            if(s2[i]!=\\' \\')\\n                str+=s2[i];\\n            else\\n            {\\n                v2.push_back(str);\\n                str=\"\";\\n            }\\n        }\\n        v2.push_back(str);\\n        bool flag=true;\\n        int l1=0,l2=0,r1=v1.size()-1,r2=v2.size()-1;\\n        while(l1<=r1&&l2<=r2)\\n        {\\n            if(v1[l1]==v2[l2])\\n            {\\n                l1++;l2++;\\n            }\\n            else if(v1[r1]==v2[r2])\\n            {\\n                r1--;\\n                r2--;\\n            }\\n            else\\n            {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        vector<string>v1,v2;\\n        string str=\"\";\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            if(s1[i]!=\\' \\')\\n                str+=s1[i];\\n            else\\n            {\\n                v1.push_back(str);\\n                str=\"\";\\n            }\\n        }\\n        v1.push_back(str);\\n        str=\"\";\\n        for(int i=0;i<s2.size();i++)\\n        {\\n            if(s2[i]!=\\' \\')\\n                str+=s2[i];\\n            else\\n            {\\n                v2.push_back(str);\\n                str=\"\";\\n            }\\n        }\\n        v2.push_back(str);\\n        bool flag=true;\\n        int l1=0,l2=0,r1=v1.size()-1,r2=v2.size()-1;\\n        while(l1<=r1&&l2<=r2)\\n        {\\n            if(v1[l1]==v2[l2])\\n            {\\n                l1++;l2++;\\n            }\\n            else if(v1[r1]==v2[r2])\\n            {\\n                r1--;\\n                r2--;\\n            }\\n            else\\n            {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534458,
                "title": "c-beats-100-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) \\n    {\\n        if(s1.size()==s2.size())\\n            return s1==s2;\\n        vector<string> a1;\\n        vector<string> a2;\\n        stringstream is1(s1);\\n        string str;\\n        while(is1>>str)\\n        {\\n            a1.push_back(str);\\n        }\\n        istringstream is2(s2);\\n        while(is2>>str)\\n        {\\n            a2.push_back(str);\\n        }\\n        int start1=0,start2=0,end1=a1.size()-1,end2=a2.size()-1;\\n        while(start1<=end1&&start2<=end2)\\n        {\\n            if(a1[start1]==a2[start2])\\n            {\\n                start1++;\\n                start2++;\\n            }\\n            else if(a1[end1]==a2[end2])\\n            {\\n                end1--;\\n                end2--;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n//if you like the solution plz upvote",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) \\n    {\\n        if(s1.size()==s2.size())\\n            return s1==s2;\\n        vector<string> a1;\\n        vector<string> a2;\\n        stringstream is1(s1);\\n        string str;\\n        while(is1>>str)\\n        {\\n            a1.push_back(str);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2503082,
                "title": "python-clean-solution-matching-substring-for-space-index",
                "content": "```\\ndef areSentencesSimilar(self, s1: str, s2: str) -> bool:\\n\\tif len(s1)<len(s2):\\n\\t\\ts1, s2 = s2, s1\\n\\tif s1.startswith(s2+\\' \\') or s1.endswith(\\' \\'+s2) or s1==s2:\\n\\t\\treturn True\\n\\tspace_idx = [i for i in range(len(s2)) if s2[i]==\\' \\']\\n\\tfor i in space_idx:\\n\\t\\t# space should be included in matching substring\\n\\t\\tif s1.startswith(s2[:i+1]) and s1.endswith(s2[i:]):\\n\\t\\t\\treturn True\\n\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\ndef areSentencesSimilar(self, s1: str, s2: str) -> bool:\\n\\tif len(s1)<len(s2):\\n\\t\\ts1, s2 = s2, s1\\n\\tif s1.startswith(s2+\\' \\') or s1.endswith(\\' \\'+s2) or s1==s2:\\n\\t\\treturn True\\n\\tspace_idx = [i for i in range(len(s2)) if s2[i]==\\' \\']\\n\\tfor i in space_idx:\\n\\t\\t# space should be included in matching substring\\n\\t\\tif s1.startswith(s2[:i+1]) and s1.endswith(s2[i:]):\\n\\t\\t\\treturn True\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2484706,
                "title": "simple-recursion-approach-top-down",
                "content": "Convert s2  to  s1\\n\\n**Intuition**\\nInserting in s2 is equivalent to skipping corresponding in s1\\n\\n\\ninserted = true  -> if we already have inserted some string in s2 and we could add more \\n\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if(s1.size() < s2.size()) swap(s1, s2);\\n        vector<string> ss1 = split(s1), ss2 = split(s2);\\n        return solve(ss1, ss2, 0, 0);\\n    }\\n    \\nprivate:\\n    bool solve(vector<string> &s1, vector<string> &s2, int i, int j, bool inserted = false){\\n        int n = s1.size();\\n        if(i == n){\\n            return j == s2.size();\\n        }\\n        if(s1[i].compare(s2[j]) == 0){ // ith == jth\\n            if(inserted){ // if remaining string matches then you got a match return TRUE\\n                bool substringMatched = compare(s1, s2, i, j);\\n                if(substringMatched) return true;\\n            }\\n            bool val1 = solve(s1, s2, i+1, j, true); // we may or may not have already inserted in between skip ith and solve ahead\\n            if(!inserted){ // till now we haven\\'t already inserted don\\'t insert here too  [Match ith to jth] and solve ahead\\n                val1 |= solve(s1, s2, i+1, j+1, false);\\n            }\\n            return val1;\\n        }\\n\\t\\t// we don\\'t have choice insert ith and solve ahead\\n        return solve(s1, s2, i+1, j, true);\\n    }\\n    \\n    bool compare(const vector<string> &v1, const vector<string> &v2, int i, int j){\\n        int n1 = v1.size(), n2 = v2.size();\\n        while(i < n1 && j < n2){\\n            if(v1[i++] == v2[j++]) continue;\\n            return false;\\n        }\\n        return i == n1 && j == n2;\\n    }\\n    \\n    vector<string> split(string &sr){\\n        stringstream ss(sr);\\n        vector<string> tokens;\\n        string token;\\n        while(getline(ss, token, \\' \\')){\\n            tokens.push_back(token);\\n        }\\n        return tokens;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if(s1.size() < s2.size()) swap(s1, s2);\\n        vector<string> ss1 = split(s1), ss2 = split(s2);\\n        return solve(ss1, ss2, 0, 0);\\n    }\\n    \\nprivate:\\n    bool solve(vector<string> &s1, vector<string> &s2, int i, int j, bool inserted = false){\\n        int n = s1.size();\\n        if(i == n){\\n            return j == s2.size();\\n        }\\n        if(s1[i].compare(s2[j]) == 0){ // ith == jth\\n            if(inserted){ // if remaining string matches then you got a match return TRUE\\n                bool substringMatched = compare(s1, s2, i, j);\\n                if(substringMatched) return true;\\n            }\\n            bool val1 = solve(s1, s2, i+1, j, true); // we may or may not have already inserted in between skip ith and solve ahead\\n            if(!inserted){ // till now we haven\\'t already inserted don\\'t insert here too  [Match ith to jth] and solve ahead\\n                val1 |= solve(s1, s2, i+1, j+1, false);\\n            }\\n            return val1;\\n        }\\n\\t\\t// we don\\'t have choice insert ith and solve ahead\\n        return solve(s1, s2, i+1, j, true);\\n    }\\n    \\n    bool compare(const vector<string> &v1, const vector<string> &v2, int i, int j){\\n        int n1 = v1.size(), n2 = v2.size();\\n        while(i < n1 && j < n2){\\n            if(v1[i++] == v2[j++]) continue;\\n            return false;\\n        }\\n        return i == n1 && j == n2;\\n    }\\n    \\n    vector<string> split(string &sr){\\n        stringstream ss(sr);\\n        vector<string> tokens;\\n        string token;\\n        while(getline(ss, token, \\' \\')){\\n            tokens.push_back(token);\\n        }\\n        return tokens;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401039,
                "title": "c-solution-using-two-pointers-beats-100",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<string>parse(string &sentence){\\n        vector<string>ans;\\n        int start=0,prev=0;\\n        while(start<sentence.size()){\\n            if(sentence[++start]==\\' \\'){\\n                ans.push_back(sentence.substr(prev,start-prev));\\n                prev=++start;\\n            } else if(start==sentence.size()){\\n                ans.push_back(sentence.substr(prev));\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if(s2.size()>s1.size()){\\n            swap(s1,s2);\\n        }\\n        if(s1.size()==s2.size()){\\n            return s1==s2;\\n        } else {\\n            vector<string>first=parse(s1);\\n            vector<string>second=parse(s2);\\n            int start=0,end=second.size()-1,startCnt=0,endCnt=0;\\n            for(int i=0;i<first.size();i++){\\n                if(first[i]==second[start]){\\n                    if(++start==second.size()){\\n                        return true;\\n                    }\\n                    startCnt++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            for(int i=first.size()-1;i>=0;i--){\\n                if(first[i]==second[end]){\\n                    if(--end<0){\\n                        return true;\\n                    }\\n                    endCnt++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            return startCnt+endCnt==second.size();\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<string>parse(string &sentence){\\n        vector<string>ans;\\n        int start=0,prev=0;\\n        while(start<sentence.size()){\\n            if(sentence[++start]==\\' \\'){\\n                ans.push_back(sentence.substr(prev,start-prev));\\n                prev=++start;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2370797,
                "title": "java-simple-solution-explained",
                "content": "\\n\\n\\n\\n\\n\\n        \\n        String s1[] = a.split(\" \");\\n        String s2[] = b.split(\" \");\\n        Deque<String> x = new ArrayDeque<>();\\n        \\n        Deque<String> y = new ArrayDeque<>();\\n        int flag= s1.length > s2.length ? 1:0;\\n        for(String i: s1)\\n        {\\n            x.offer(i);\\n        }\\n        \\n        for(String j: s2)\\n        {\\n            y.offer(j);\\n        }\\n        if (flag==1)\\n        {\\n            while(!y.isEmpty())\\n        {\\n            if(x.peekFirst().equals(y.peekFirst())) \\n            {\\n                x.pollFirst();\\n                y.pollFirst();\\n            }\\n            else if(x.peekLast().equals(y.peekLast()))\\n            {\\n                x.pollLast();\\n                y.pollLast();\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        }\\n        \\n        if(flag==0)\\n        {\\n            while(!x.isEmpty())\\n         {\\n            if(x.peekFirst().equals(y.peekFirst())) \\n            {\\n                x.pollFirst();\\n                y.pollFirst();\\n            }\\n            else if(x.peekLast().equals(y.peekLast()))\\n            {\\n                x.pollLast();\\n                y.pollLast();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n        \\n        \\n        \\n        \\n       \\n        return true;\\n",
                "solutionTags": [],
                "code": "\\n\\n\\n\\n\\n\\n        \\n        String s1[] = a.split(\" \");\\n        String s2[] = b.split(\" \");\\n        Deque<String> x = new ArrayDeque<>();\\n        \\n        Deque<String> y = new ArrayDeque<>();\\n        int flag= s1.length > s2.length ? 1:0;\\n        for(String i: s1)\\n        {\\n            x.offer(i);\\n        }\\n        \\n        for(String j: s2)\\n        {\\n            y.offer(j);\\n        }\\n        if (flag==1)\\n        {\\n            while(!y.isEmpty())\\n        {\\n            if(x.peekFirst().equals(y.peekFirst())) \\n            {\\n                x.pollFirst();\\n                y.pollFirst();\\n            }\\n            else if(x.peekLast().equals(y.peekLast()))\\n            {\\n                x.pollLast();\\n                y.pollLast();\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        }\\n        \\n        if(flag==0)\\n        {\\n            while(!x.isEmpty())\\n         {\\n            if(x.peekFirst().equals(y.peekFirst())) \\n            {\\n                x.pollFirst();\\n                y.pollFirst();\\n            }\\n            else if(x.peekLast().equals(y.peekLast()))\\n            {\\n                x.pollLast();\\n                y.pollLast();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n        \\n        \\n        \\n        \\n       \\n        return true;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2292030,
                "title": "c-easy-soln-using-stringstream-and-deque",
                "content": "```\\n bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        if(sentence1.size() < sentence2.size()) \\n            return areSentencesSimilar(sentence2, sentence1);\\n        \\n        stringstream ss1(sentence1);\\n        string str1;\\n        deque<string> d1;\\n        \\n        while(ss1 >> str1){\\n            d1.push_back(str1);\\n        }\\n        \\n        stringstream ss2(sentence2);\\n        string str2;\\n        deque<string> d2;\\n        \\n        while(ss2 >> str2){\\n            d2.push_back(str2);\\n        }\\n        \\n        \\n        while(not d2.empty()){\\n            \\n            if(d1.front() == d2.front()){\\n                d1.pop_front();\\n                d2.pop_front();\\n            }\\n            else if(d1.back() == d2.back()){\\n                d1.pop_back();\\n                d2.pop_back();\\n            }\\n            else\\n                return false;\\n            \\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        if(sentence1.size() < sentence2.size()) \\n            return areSentencesSimilar(sentence2, sentence1);\\n        \\n        stringstream ss1(sentence1);\\n        string str1;\\n        deque<string> d1;\\n        \\n        while(ss1 >> str1){\\n            d1.push_back(str1);\\n        }\\n        \\n        stringstream ss2(sentence2);\\n        string str2;\\n        deque<string> d2;\\n        \\n        while(ss2 >> str2){\\n            d2.push_back(str2);\\n        }\\n        \\n        \\n        while(not d2.empty()){\\n            \\n            if(d1.front() == d2.front()){\\n                d1.pop_front();\\n                d2.pop_front();\\n            }\\n            else if(d1.back() == d2.back()){\\n                d1.pop_back();\\n                d2.pop_back();\\n            }\\n            else\\n                return false;\\n            \\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2210682,
                "title": "c-easy-stringstream",
                "content": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<string> a,vector<string> b)\\n    {\\n        // Here a vector is larger than b vector\\n        int i=0;\\n        int m=b.size();\\n       \\n        int j=0;//Initially iterate from start of a\\n         int n=a.size();\\n        \\n        bool flag=false;\\n        while(j<n && i<m)\\n        {\\n            //Start iterating\\n            \\n            if(a[j]==b[i])\\n            {\\n                \\n                i++;\\n                j++;\\n                \\n            }\\n            else\\n            {\\n               \\n                \\n                if(flag)//If flag already present return false;\\n                {\\n                    return false;\\n                }\\n                j=n-(m-i);// If not present and flag is false iterate from end-length of b remaining \\n                flag=true;//Set flag true\\n            }\\n        }\\n        return i==m;\\n    }\\n    bool areSentencesSimilar(string s1, string s2) {\\n        stringstream s(s1);\\n        vector<string>a1;// a1 contains words of s1\\n        string word;\\n        while(s>>word)\\n        {\\n            a1.push_back(word);\\n        }\\n        s.clear();\\n        stringstream x(s2);\\n        string word1;\\n        vector<string>a2;//a2 contains words of s2\\n        while(x>>word1)\\n        {\\n            a2.push_back(word1);\\n        }\\n        if(a2.size()>a1.size())\\n        {\\n            return compare(a2,a1);\\n        }\\n       \\n        return compare(a1,a2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<string> a,vector<string> b)\\n    {\\n        // Here a vector is larger than b vector\\n        int i=0;\\n        int m=b.size();\\n       \\n        int j=0;//Initially iterate from start of a\\n         int n=a.size();\\n        \\n        bool flag=false;\\n        while(j<n && i<m)\\n        {\\n            //Start iterating\\n            \\n            if(a[j]==b[i])\\n            {\\n                \\n                i++;\\n                j++;\\n                \\n            }\\n            else\\n            {\\n               \\n                \\n                if(flag)//If flag already present return false;\\n                {\\n                    return false;\\n                }\\n                j=n-(m-i);// If not present and flag is false iterate from end-length of b remaining \\n                flag=true;//Set flag true\\n            }\\n        }\\n        return i==m;\\n    }\\n    bool areSentencesSimilar(string s1, string s2) {\\n        stringstream s(s1);\\n        vector<string>a1;// a1 contains words of s1\\n        string word;\\n        while(s>>word)\\n        {\\n            a1.push_back(word);\\n        }\\n        s.clear();\\n        stringstream x(s2);\\n        string word1;\\n        vector<string>a2;//a2 contains words of s2\\n        while(x>>word1)\\n        {\\n            a2.push_back(word1);\\n        }\\n        if(a2.size()>a1.size())\\n        {\\n            return compare(a2,a1);\\n        }\\n       \\n        return compare(a1,a2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174571,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n       String[] a= sentence1.split(\" \");\\n       String[] b= sentence2.split(\" \");\\n       int i=0,j=0,n=a.length,m=b.length;\\n        while(i<n && j<m){\\n            if(!a[i].equals(b[j])) break;\\n            i++;\\n            j++;\\n        }\\n        \\n        if(i==n|| j==m) return true;\\n        \\n        int p=n-1,q=m-1;\\n        \\n        while(p>=i&&q>=j){\\n            if(!a[p].equals(b[q])) return false;\\n            p--;\\n            q--;\\n        }\\n        return p<i||q<j;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n       String[] a= sentence1.split(\" \");\\n       String[] b= sentence2.split(\" \");\\n       int i=0,j=0,n=a.length,m=b.length;\\n        while(i<n && j<m){\\n            if(!a[i].equals(b[j])) break;\\n            i++;\\n            j++;\\n        }\\n        \\n        if(i==n|| j==m) return true;\\n        \\n        int p=n-1,q=m-1;\\n        \\n        while(p>=i&&q>=j){\\n            if(!a[p].equals(b[q])) return false;\\n            p--;\\n            q--;\\n        }\\n        return p<i||q<j;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159392,
                "title": "0ms-go",
                "content": "```\\nfunc ok(s, t []string) bool {\\n    n, m := len(s), len(t)\\n    i := 0\\n    for i < n && i < m {\\n        if s[i] == t[i] {\\n            i++\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    j, k := n - 1, m - 1\\n    for j >= 0 && k >= 0 {\\n        if s[j] == t[k] {\\n            j--\\n            k--\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    return i > k\\n}\\n\\nfunc areSentencesSimilar(s1 string, s2 string) bool {\\n    ss1, ss2 := strings.Split(s1, \" \"), strings.Split(s2, \" \")\\n    return len(ss1) >= len(ss2) && ok(ss1, ss2) || len(ss1) < len(ss2) && ok(ss2, ss1)\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc ok(s, t []string) bool {\\n    n, m := len(s), len(t)\\n    i := 0\\n    for i < n && i < m {\\n        if s[i] == t[i] {\\n            i++\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    j, k := n - 1, m - 1\\n    for j >= 0 && k >= 0 {\\n        if s[j] == t[k] {\\n            j--\\n            k--\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    return i > k\\n}\\n\\nfunc areSentencesSimilar(s1 string, s2 string) bool {\\n    ss1, ss2 := strings.Split(s1, \" \"), strings.Split(s2, \" \")\\n    return len(ss1) >= len(ss2) && ok(ss1, ss2) || len(ss1) < len(ss2) && ok(ss2, ss1)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2142354,
                "title": "5-lines-only-cpp-no-deque-pure-intuition",
                "content": "```\\n  bool areSentencesSimilar(string s1, string s2) {\\n        \\n        string sw1[100], sw2[100], w; int i{0}, p1{0}, p2{0};\\n        istringstream ss1(s1), ss2(s2);\\n        while(ss1>> w) sw1[i++]= w, p1=i;\\n        i=0;\\n        while(ss2 >> w) sw2[i++]=w, p2=i;\\n        i=0;\\n        if(p1 > p2)  return areSentencesSimilar(s2,s1);\\n        while(i<p1 && sw1[i]==sw2[i]) i++;\\n        while( i< p1 && sw1[i]== sw2[p2-p1+i])i++;\\n        return i==p1; \\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  bool areSentencesSimilar(string s1, string s2) {\\n        \\n        string sw1[100], sw2[100], w; int i{0}, p1{0}, p2{0};\\n        istringstream ss1(s1), ss2(s2);\\n        while(ss1>> w) sw1[i++]= w, p1=i;\\n        i=0;\\n        while(ss2 >> w) sw2[i++]=w, p2=i;\\n        i=0;\\n        if(p1 > p2)  return areSentencesSimilar(s2,s1);\\n        while(i<p1 && sw1[i]==sw2[i]) i++;\\n        while( i< p1 && sw1[i]== sw2[p2-p1+i])i++;\\n        return i==p1; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2115730,
                "title": "javascript-prefix-and-suffix-clean-simple",
                "content": "Intuition\\n\\n- Let\\'s reduce to the case where `sentence1` is longer than `sentence2`\\n- We want to split `sentence2` into two halves, `prefix` and `suffix`, that match `sentence1`\\n- For example, if `sentence1 = \"a b c d\"` and `sentence2 = \"a c d\"`, the prefix is `\"a\"` and the suffix is `\"c d\"`.\\n\\n```\\nconst areSentencesSimilar = (sentence1, sentence2) => {\\n  const array1 = sentence1.split(\" \");\\n  const array2 = sentence2.split(\" \");\\n\\n  if (array1.length < array2.length) {\\n    return areSentencesSimilar(sentence2, sentence1);\\n  }\\n\\n  // find the shared prefix between array1 and array2\\n  let prefixLength = 0;\\n  for (; prefixLength < array2.length; prefixLength++) {\\n    if (array2[prefixLength] !== array1[prefixLength]) {\\n      break;\\n    }\\n  }\\n\\n  // the rest of array2 must be a suffix of array1\\n  const suffixLength = array2.length - prefixLength;\\n  for (let i = 0; i < suffixLength; i++) {\\n    if (array2[array2.length - 1 - i] !== array1[array1.length - 1 - i]) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst areSentencesSimilar = (sentence1, sentence2) => {\\n  const array1 = sentence1.split(\" \");\\n  const array2 = sentence2.split(\" \");\\n\\n  if (array1.length < array2.length) {\\n    return areSentencesSimilar(sentence2, sentence1);\\n  }\\n\\n  // find the shared prefix between array1 and array2\\n  let prefixLength = 0;\\n  for (; prefixLength < array2.length; prefixLength++) {\\n    if (array2[prefixLength] !== array1[prefixLength]) {\\n      break;\\n    }\\n  }\\n\\n  // the rest of array2 must be a suffix of array1\\n  const suffixLength = array2.length - prefixLength;\\n  for (let i = 0; i < suffixLength; i++) {\\n    if (array2[array2.length - 1 - i] !== array1[array1.length - 1 - i]) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2104445,
                "title": "python-following-the-hints",
                "content": "\\t\\t# presented without much ado:\\n\\t\\ts1 = list(sentence1.split(\\' \\'))\\n        s2 = list(sentence2.split(\\' \\'))\\n        \\n        N1, N2 = len(s1), len(s2)\\n        \\n        # first, we move left->right in index and see if we have\\n\\t\\t# matching word in the two sentences (common prefix):\\n\\t\\tprefix = -1\\n        for ii in range(min(N1, N2)):\\n            if s1[ii] == s2[ii]:\\n                prefix = ii\\n                \\n            else:\\n                break\\n                \\n\\t\\t# same thing but for suffix words at the end of the sentences:\\n        suffix = -1\\n        for ii in range(min(N1, N2)):\\n            if s1[-(ii+1)] == s2[-(ii+1)]:\\n                suffix = ii\\n            else:\\n                break\\n                \\n\\t\\t# case when words would have to be added at both\\n\\t\\t# the beginning and end of one of the words to match\\n\\t\\t# the other:\\n        if prefix == -1 and suffix == -1:\\n            return(False)\\n        \\n\\t\\t# case when words need to be added to the end of one\\n\\t\\t# of the sentences:\\n        if prefix+1 == N1 or prefix+1 == N2:\\n            return(True)\\n        \\n\\t\\t# case when words need to be added to the beginning\\n\\t\\t# of one of the sentences:\\n        if suffix+1 == N1 or suffix+1 == N2:\\n            return(True)\\n        \\n\\t\\t# case when words need to be inserted into the middle\\n\\t\\t# of one of the sentences:\\n        if prefix+suffix+2 == N1 or prefix+suffix+2 == N2:\\n            return(True)\\n        \\n\\t\\t# else:\\n        return(False)",
                "solutionTags": [],
                "code": "\\t\\t# presented without much ado:\\n\\t\\ts1 = list(sentence1.split(\\' \\'))\\n        s2 = list(sentence2.split(\\' \\'))\\n        \\n        N1, N2 = len(s1), len(s2)\\n        \\n        # first, we move left->right in index and see if we have\\n\\t\\t# matching word in the two sentences (common prefix):\\n\\t\\tprefix = -1\\n        for ii in range(min(N1, N2)):\\n            if s1[ii] == s2[ii]:\\n                prefix = ii\\n                \\n            else:\\n                break\\n                \\n\\t\\t# same thing but for suffix words at the end of the sentences:\\n        suffix = -1\\n        for ii in range(min(N1, N2)):\\n            if s1[-(ii+1)] == s2[-(ii+1)]:\\n                suffix = ii\\n            else:\\n                break\\n                \\n\\t\\t# case when words would have to be added at both\\n\\t\\t# the beginning and end of one of the words to match\\n\\t\\t# the other:\\n        if prefix == -1 and suffix == -1:\\n            return(False)\\n        \\n\\t\\t# case when words need to be added to the end of one\\n\\t\\t# of the sentences:\\n        if prefix+1 == N1 or prefix+1 == N2:\\n            return(True)\\n        \\n\\t\\t# case when words need to be added to the beginning\\n\\t\\t# of one of the sentences:\\n        if suffix+1 == N1 or suffix+1 == N2:\\n            return(True)\\n        \\n\\t\\t# case when words need to be inserted into the middle\\n\\t\\t# of one of the sentences:\\n        if prefix+suffix+2 == N1 or prefix+suffix+2 == N2:\\n            return(True)\\n        \\n\\t\\t# else:\\n        return(False)",
                "codeTag": "Unknown"
            },
            {
                "id": 2098797,
                "title": "c-solution-without-queue",
                "content": "One should quickly figure out that when you search for matching prefix && postfix of two strings, any one pair of the { prefix, postfix } should be overlapping.\\n\\nThe code: \\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> s1, s2;\\n    void opt(string in_str, vector<string> &v) {\\n        stringstream ss;\\n        ss << in_str;\\n        string w;\\n        while (ss >> w) {\\n            v.push_back(w);\\n        }\\n        return;\\n    }\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        opt(sentence1, s1); opt(sentence2, s2);\\n        int len1 = s1.size();\\n        int len2 = s2.size();\\n        int i1 = 0;\\n        int i2 = 0;\\n        bool fi = false;\\n        bool fj = false;\\n        while (i1 < len1 && i2 < len2) {\\n            if (s1[i1] == s2[i2]) {\\n                i1++; i2++;\\n                fi = true;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        int j1 = len1 - 1;\\n        int j2 = len2 - 1;\\n        while (j1 >= 0 && j2 >= 0) {\\n            if (s1[j1] == s2[j2]) {\\n                j1--; j2--;\\n                fj = true;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        if (i1 > j1 || i2 > j2) {\\n            if (fi || fj) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> s1, s2;\\n    void opt(string in_str, vector<string> &v) {\\n        stringstream ss;\\n        ss << in_str;\\n        string w;\\n        while (ss >> w) {\\n            v.push_back(w);\\n        }\\n        return;\\n    }\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        opt(sentence1, s1); opt(sentence2, s2);\\n        int len1 = s1.size();\\n        int len2 = s2.size();\\n        int i1 = 0;\\n        int i2 = 0;\\n        bool fi = false;\\n        bool fj = false;\\n        while (i1 < len1 && i2 < len2) {\\n            if (s1[i1] == s2[i2]) {\\n                i1++; i2++;\\n                fi = true;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        int j1 = len1 - 1;\\n        int j2 = len2 - 1;\\n        while (j1 >= 0 && j2 >= 0) {\\n            if (s1[j1] == s2[j2]) {\\n                j1--; j2--;\\n                fj = true;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        if (i1 > j1 || i2 > j2) {\\n            if (fi || fj) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022412,
                "title": "split-strings-and-check-if-break-points-are-one",
                "content": "**stringstream** might not be very efficiency and **tok1 and tok2** unnecessarily duplicte the 2 sentences,\\nbut at least the logic is clear.\\n\\n```cpp\\n// make sure s2 is longer than s1\\nif (s1.size() > s2.size())\\n\\tswap(s1, s2);\\n\\n// split s1 and s2 into tok1 and tok2 using stringstream.\\nvector<string> tok1, tok2;\\nstring tok = \"\";\\nstringstream ss1(s1), ss2(s2);\\n\\nwhile (ss1 >> tok)\\n\\ttok1.push_back(tok);\\n\\nwhile (ss2 >> tok)\\n\\ttok2.push_back(tok);\\n\\nint l = 0;\\nint r1 = tok1.size() - 1;\\nint r2 = tok2.size() - 1;\\n\\n// find the breaking point from the left\\nwhile (l < tok1.size() && tok1[l] == tok2[l])\\n\\t++ l;\\n\\n// find the breaking point from the right\\nwhile (r1 >= 0 && tok1[r1] == tok2[r2])\\n{\\n\\t-- r1;\\n\\t-- r2;\\n}\\n\\n// check coincide\\nreturn l > r1;\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n// make sure s2 is longer than s1\\nif (s1.size() > s2.size())\\n\\tswap(s1, s2);\\n\\n// split s1 and s2 into tok1 and tok2 using stringstream.\\nvector<string> tok1, tok2;\\nstring tok = \"\";\\nstringstream ss1(s1), ss2(s2);\\n\\nwhile (ss1 >> tok)\\n\\ttok1.push_back(tok);\\n\\nwhile (ss2 >> tok)\\n\\ttok2.push_back(tok);\\n\\nint l = 0;\\nint r1 = tok1.size() - 1;\\nint r2 = tok2.size() - 1;\\n\\n// find the breaking point from the left\\nwhile (l < tok1.size() && tok1[l] == tok2[l])\\n\\t++ l;\\n\\n// find the breaking point from the right\\nwhile (r1 >= 0 && tok1[r1] == tok2[r2])\\n{\\n\\t-- r1;\\n\\t-- r2;\\n}\\n\\n// check coincide\\nreturn l > r1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2020631,
                "title": "simple-and-neat-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void getWords(string & s , vector<string> & v)\\n    {   stringstream ss(s);\\n        string word;\\n        while(ss>>word)\\n        {\\n            v.push_back(word);\\n        }\\n    }\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        string shorter,longer;\\n        sentence1.size()>sentence2.size()?shorter= sentence2 : shorter = sentence1;\\n        sentence1.size()>sentence2.size()?longer= sentence1 : longer = sentence2;\\n        vector<string> shortWords , longWords;\\n        getWords(shorter, shortWords);\\n        getWords(longer, longWords);\\n        int start1=0,start2=0,end1=shortWords.size()-1,end2=longWords.size()-1;\\n        while(start1<=end1&&start2<=end2)\\n        {\\n            if(shortWords[start1]==longWords[start2]) // if start of both vectors are equal\\n            {\\n                start1++; start2++;\\n            }\\n            else if(shortWords[end1]==longWords[end2]) //if end of both vectors are equal\\n            {\\n                end1--; end2--;\\n            }\\n            else  return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void getWords(string & s , vector<string> & v)\\n    {   stringstream ss(s);\\n        string word;\\n        while(ss>>word)\\n        {\\n            v.push_back(word);\\n        }\\n    }\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        string shorter,longer;\\n        sentence1.size()>sentence2.size()?shorter= sentence2 : shorter = sentence1;\\n        sentence1.size()>sentence2.size()?longer= sentence1 : longer = sentence2;\\n        vector<string> shortWords , longWords;\\n        getWords(shorter, shortWords);\\n        getWords(longer, longWords);\\n        int start1=0,start2=0,end1=shortWords.size()-1,end2=longWords.size()-1;\\n        while(start1<=end1&&start2<=end2)\\n        {\\n            if(shortWords[start1]==longWords[start2]) // if start of both vectors are equal\\n            {\\n                start1++; start2++;\\n            }\\n            else if(shortWords[end1]==longWords[end2]) //if end of both vectors are equal\\n            {\\n                end1--; end2--;\\n            }\\n            else  return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004215,
                "title": "1ms-100-java-simple-solution",
                "content": "java code is \\n\\n```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String arr1[]=sentence1.split(\" \");\\n        String arr2[]=sentence2.split(\" \");\\n        int i=0,j=0,n=arr1.length,m=arr2.length;\\n        while(i<n&&j<m){\\n            if(!arr1[i].equals(arr2[j]))break;\\n            i++;\\n            j++;\\n        }\\n        if(i==n||j==m)return true;\\n        int p=n-1,q=m-1;\\n        while(p>=i&&q>=j){\\n            if(!arr1[p].equals(arr2[q]))return false;\\n            p--;\\n            q--;\\n        }\\n        return p<i||q<j;\\n    }\\n}\\n```\\n\\nPlease upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String arr1[]=sentence1.split(\" \");\\n        String arr2[]=sentence2.split(\" \");\\n        int i=0,j=0,n=arr1.length,m=arr2.length;\\n        while(i<n&&j<m){\\n            if(!arr1[i].equals(arr2[j]))break;\\n            i++;\\n            j++;\\n        }\\n        if(i==n||j==m)return true;\\n        int p=n-1,q=m-1;\\n        while(p>=i&&q>=j){\\n            if(!arr1[p].equals(arr2[q]))return false;\\n            p--;\\n            q--;\\n        }\\n        return p<i||q<j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995931,
                "title": "rust-solution-using-deque",
                "content": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn are_sentences_similar(sentence1: String, sentence2: String) -> bool {\\n    let mut s1 = sentence1.split(\" \").into_iter().map(|v| v.to_string()).collect::<VecDeque<String>>();\\n    let mut s2 = sentence2.split(\" \").into_iter().map(|v| v.to_string()).collect::<VecDeque<String>>();\\n\\n    if s1.len() < s2.len() {\\n      std::mem::swap(&mut s1, &mut s2);\\n    }\\n\\n    while !s2.is_empty() {\\n      if s1[0] == s2[0] {\\n        s1.pop_front();\\n        s2.pop_front();\\n      } else {\\n        break\\n      }\\n    }\\n    \\n    while !s2.is_empty() {\\n      if s1[s1.len()-1] == s2[s2.len()-1] {\\n        s1.pop_back();\\n        s2.pop_back();\\n      } else {\\n        break\\n      }\\n    }\\n    \\n    s2.is_empty()\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Queue"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn are_sentences_similar(sentence1: String, sentence2: String) -> bool {\\n    let mut s1 = sentence1.split(\" \").into_iter().map(|v| v.to_string()).collect::<VecDeque<String>>();\\n    let mut s2 = sentence2.split(\" \").into_iter().map(|v| v.to_string()).collect::<VecDeque<String>>();\\n\\n    if s1.len() < s2.len() {\\n      std::mem::swap(&mut s1, &mut s2);\\n    }\\n\\n    while !s2.is_empty() {\\n      if s1[0] == s2[0] {\\n        s1.pop_front();\\n        s2.pop_front();\\n      } else {\\n        break\\n      }\\n    }\\n    \\n    while !s2.is_empty() {\\n      if s1[s1.len()-1] == s2[s2.len()-1] {\\n        s1.pop_back();\\n        s2.pop_back();\\n      } else {\\n        break\\n      }\\n    }\\n    \\n    s2.is_empty()\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1970709,
                "title": "java-linear",
                "content": "```\\n\\tpublic boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        var s1 = sentence1.length() <= sentence2.length() ? sentence1 : sentence2;\\n        var s2 = sentence1.length() <= sentence2.length() ? sentence2 : sentence1;\\n        \\n        var w1 = s1.split(\" \");\\n        var w2 = s2.split(\" \");\\n        \\n        if (w2.length < w1.length) return false;\\n        \\n        int i = 0;\\n        while (i < w1.length && i < w2.length && w1[i].equals(w2[i])) { // match from the begining\\n            i++;\\n        }\\n        \\n        while (i < w1.length && i < w2.length && w1[i].equals(w2[w2.length - (w1.length - i)])) { // match from the end\\n            i++;\\n        }\\n        \\n        return i == w1.length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        var s1 = sentence1.length() <= sentence2.length() ? sentence1 : sentence2;\\n        var s2 = sentence1.length() <= sentence2.length() ? sentence2 : sentence1;\\n        \\n        var w1 = s1.split(\" \");\\n        var w2 = s2.split(\" \");\\n        \\n        if (w2.length < w1.length) return false;\\n        \\n        int i = 0;\\n        while (i < w1.length && i < w2.length && w1[i].equals(w2[i])) { // match from the begining\\n            i++;\\n        }\\n        \\n        while (i < w1.length && i < w2.length && w1[i].equals(w2[w2.length - (w1.length - i)])) { // match from the end\\n            i++;\\n        }\\n        \\n        return i == w1.length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937597,
                "title": "java-insert-to-shorter-string",
                "content": "We only have to consider inserting to the shorter string, so the first thing we do is to make sure the longer string comes in the first parameter of the function.\\n\\nThen, we will trim the shorter string by matching as much as we can from the prefix and suffix words of A and B.\\nFor A and B to be similiar, B has to be trimmed to nothing. \\n\\n```Java\\nclass Solution {\\n    public boolean areSentencesSimilar(String A, String B) {\\n        if (A.length() < B.length())\\n            return areSentencesSimilar(B, A);\\n\\n        return check(A, B);\\n    }\\n\\n    private boolean check(String A, String B){\\n        String[] x = A.split(\" \");\\n        String[] y = B.split(\" \");\\n        int i = 0, j = y.length - 1, k = x.length - 1;\\n        while(i < y.length && x[i].equals(y[i])){\\n            i++;\\n        }\\n        while(j >= 0 && x[k].equals(y[j])){\\n            j--;\\n            k--;\\n        }\\n        return i > j; // USED ALL THE B.\\n    }\\n    // a b cc dd\\n    // a b cc dd ff\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean areSentencesSimilar(String A, String B) {\\n        if (A.length() < B.length())\\n            return areSentencesSimilar(B, A);\\n\\n        return check(A, B);\\n    }\\n\\n    private boolean check(String A, String B){\\n        String[] x = A.split(\" \");\\n        String[] y = B.split(\" \");\\n        int i = 0, j = y.length - 1, k = x.length - 1;\\n        while(i < y.length && x[i].equals(y[i])){\\n            i++;\\n        }\\n        while(j >= 0 && x[k].equals(y[j])){\\n            j--;\\n            k--;\\n        }\\n        return i > j; // USED ALL THE B.\\n    }\\n    // a b cc dd\\n    // a b cc dd ff\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926480,
                "title": "c-stringstream-deque",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    deque<string> d1,d2;\\n    \\n    bool areSentencesSimilar(string s1, string s2 )  {\\n        stringstream ss(s1) , string word = \"\" ;\\n        \\n        while(ss >> word) d1.push_back(word) ;\\n        ss = stringstream(s2) , word = \"\";\\n        while(ss >> word) d2.push_back(word);\\n        \\n        while(d1.size() and d2.size() and d1.front() == d2.front()) d1.pop_front() , d2.pop_front() ;\\n        while(d1.size() and d2.size() and d1.back() == d2.back()) d1.pop_back() , d2.pop_back() ;\\n        \\n        return (d1.size() == 0 || d2.size() == 0) ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    deque<string> d1,d2;\\n    \\n    bool areSentencesSimilar(string s1, string s2 )  {\\n        stringstream ss(s1) , string word = \"\" ;\\n        \\n        while(ss >> word) d1.push_back(word) ;\\n        ss = stringstream(s2) , word = \"\";\\n        while(ss >> word) d2.push_back(word);\\n        \\n        while(d1.size() and d2.size() and d1.front() == d2.front()) d1.pop_front() , d2.pop_front() ;\\n        while(d1.size() and d2.size() and d1.back() == d2.back()) d1.pop_back() , d2.pop_back() ;\\n        \\n        return (d1.size() == 0 || d2.size() == 0) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910201,
                "title": "golang-solution-two-pointers",
                "content": "Time: **O(m)** `m <= n`\\nSpace: **O(n+m)**\\n\\n```Go\\nfunc areSentencesSimilar(sentence1 string, sentence2 string) bool {\\n    \\n    ss1, ss2 := strings.Fields(sentence1), strings.Fields(sentence2)\\n    if len(ss2) > len(ss1) {\\n        ss1, ss2 = ss2, ss1\\n    }\\n    \\n    i := 0\\n    for ; i < len(ss2) && ss1[i] == ss2[i]; i++ {}\\n    \\n    j := 1\\n    for ; len(ss2) - j >= i && ss2[len(ss2)-j] == ss1[len(ss1)-j]; j++ {}\\n    j--\\n    return i + j == len(ss2)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```Go\\nfunc areSentencesSimilar(sentence1 string, sentence2 string) bool {\\n    \\n    ss1, ss2 := strings.Fields(sentence1), strings.Fields(sentence2)\\n    if len(ss2) > len(ss1) {\\n        ss1, ss2 = ss2, ss1\\n    }\\n    \\n    i := 0\\n    for ; i < len(ss2) && ss1[i] == ss2[i]; i++ {}\\n    \\n    j := 1\\n    for ; len(ss2) - j >= i && ss2[len(ss2)-j] == ss1[len(ss1)-j]; j++ {}\\n    j--\\n    return i + j == len(ss2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1900142,
                "title": "python-2-ptrs",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, a: str, b: str) -> bool:\\n        if len(b) == 0 or a == b:\\n            return True\\n        a = a.split()\\n        b = b.split()\\n        \\n        if len(a) < len(b):\\n            a, b = b, a\\n        \\n        i = 0\\n        while i < len(b) and a[i] == b[i]:\\n            i += 1\\n \\n        return i == len(b) or a[-(len(b) - i):] == b[i:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, a: str, b: str) -> bool:\\n        if len(b) == 0 or a == b:\\n            return True\\n        a = a.split()\\n        b = b.split()\\n        \\n        if len(a) < len(b):\\n            a, b = b, a\\n        \\n        i = 0\\n        while i < len(b) and a[i] == b[i]:\\n            i += 1\\n \\n        return i == len(b) or a[-(len(b) - i):] == b[i:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899813,
                "title": "c-stringstream-and-two-pointer-easy-to-understand",
                "content": "We first tokenise both strings to obtain the words in each string.Then we place pointers at the beginning and end of each vector . If the pointer at the beginning of the vector crosses the pointer at the end of the vector we can conclude that the string is fully traversed.\\n\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string str1, string str2) {\\n        \\n\\t\\t//tokenising first string\\n        vector<string> tokens1;\\n        stringstream check1(str1);\\n        string intermediate;\\n        \\n        while(getline(check1,intermediate,\\' \\')){\\n            tokens1.push_back(intermediate);\\n        }\\n        \\n\\t\\t//tokenising second string\\n        vector<string> tokens2;\\n        stringstream check2(str2);\\n        \\n        while(getline(check2,intermediate,\\' \\')){\\n            tokens2.push_back(intermediate);\\n        }\\n        \\n\\t\\t//placing pointers at the beginning and end of first string tokens\\n        int i1=0;\\n        int j1=tokens1.size()-1;\\n        \\n\\t\\t//placing pointers at the beginning and end of second string tokens\\n        int i2=0;\\n        int j2=tokens2.size()-1;\\n        \\n        while(i1<tokens1.size()&&i2<tokens2.size()&&tokens1[i1]==tokens2[i2]){\\n            i1++;\\n            i2++;\\n        }\\n        \\n         while(j1>=0&&j2>=0&&tokens1[j1]==tokens2[j2]){\\n            j1--;\\n            j2--;\\n        }\\n        //if the pointers cross each other then the string is fully travesed i.e we can convert one string to another\\n        if(i1>j1||i2>j2)\\n            return true;\\n        else\\n            return false; \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool areSentencesSimilar(string str1, string str2) {\\n        \\n\\t\\t//tokenising first string\\n        vector<string> tokens1;\\n        stringstream check1(str1);\\n        string intermediate;\\n        \\n        while(getline(check1,intermediate,\\' \\')){\\n            tokens1.push_back(intermediate);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1864504,
                "title": "python3-split-and-compare",
                "content": "1. Split each sentence\\n2. Compare words from the begining of the sentences\\n3. Compare words from the end of the sentences\\n4. If the equal part from the begining PLUS the equal part from the end give us the whole shorter sentence, \\nwe can make longer sentence from the shorter by inserting some words.\\n\\n```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        a=sentence1.split()\\n        b=sentence2.split()\\n        if len(a)>len(b):\\n            a,b=b,a\\n        if len(a)==len(b):\\n            return a==b\\n\\n        i=0\\n        while i<len(a) and a[i]==b[i]:\\n                i+=1\\n            \\n        j=1\\n        while j<=len(a) and a[-j]==b[-j]:\\n                j+=1 \\n        return len(a)==i+j-1 or i>len(a) or j>len(a)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        a=sentence1.split()\\n        b=sentence2.split()\\n        if len(a)>len(b):\\n            a,b=b,a\\n        if len(a)==len(b):\\n            return a==b\\n\\n        i=0\\n        while i<len(a) and a[i]==b[i]:\\n                i+=1\\n            \\n        j=1\\n        while j<=len(a) and a[-j]==b[-j]:\\n                j+=1 \\n        return len(a)==i+j-1 or i>len(a) or j>len(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854782,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn are_sentences_similar(sentence1: String, sentence2: String) -> bool {\\n        if &sentence1 == &sentence2 {\\n            return true;\\n        }\\n        let (mut s1, mut s2) : (Vec<&str>, Vec<&str>) = if sentence1.len() > sentence2.len() {\\n            (sentence1.split(\" \").collect(), sentence2.split(\" \").collect())\\n        } else {\\n            (sentence2.split(\" \").collect(), sentence1.split(\" \").collect())\\n        };\\n        let mut start = 0;\\n        let mut end = 0;\\n        for str in &s2 {\\n            if *str == s1[start] {\\n                start += 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        loop {\\n            if end < s2.len() && s1[s1.len() - 1 - end] == s2[s2.len() - 1 - end] {\\n                end += 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        end + start >= s2.len()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn are_sentences_similar(sentence1: String, sentence2: String) -> bool {\\n        if &sentence1 == &sentence2 {\\n            return true;\\n        }\\n        let (mut s1, mut s2) : (Vec<&str>, Vec<&str>) = if sentence1.len() > sentence2.len() {\\n            (sentence1.split(\" \").collect(), sentence2.split(\" \").collect())\\n        } else {\\n            (sentence2.split(\" \").collect(), sentence1.split(\" \").collect())\\n        };\\n        let mut start = 0;\\n        let mut end = 0;\\n        for str in &s2 {\\n            if *str == s1[start] {\\n                start += 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        loop {\\n            if end < s2.len() && s1[s1.len() - 1 - end] == s2[s2.len() - 1 - end] {\\n                end += 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        end + start >= s2.len()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1839034,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        int l1 = sentence1.length();\\n        int l2 = sentence2.length();\\n        if(l1<l2){\\n            return areSentencesSimilar(sentence2,sentence1);\\n        }\\n        String[] s1 = sentence1.split(\" \") ;\\n        String[] s2 = sentence2.split(\" \");\\n        int i=0;\\n        int j=0;\\n        int n=s2.length;\\n        int m=s1.length;\\n        while(i<n && s1[i].equals(s2[i])){\\n         i++;   \\n        }\\n        if(i==n){\\n            return true;\\n        }\\n       while(j<n && s1[m-j-1].equals(s2[n-j-1])){\\n           j++;\\n       }\\n        if(j==n)\\n            return true;\\n        \\n        return (i+j)==n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        int l1 = sentence1.length();\\n        int l2 = sentence2.length();\\n        if(l1<l2){\\n            return areSentencesSimilar(sentence2,sentence1);\\n        }\\n        String[] s1 = sentence1.split(\" \") ;\\n        String[] s2 = sentence2.split(\" \");\\n        int i=0;\\n        int j=0;\\n        int n=s2.length;\\n        int m=s1.length;\\n        while(i<n && s1[i].equals(s2[i])){\\n         i++;   \\n        }\\n        if(i==n){\\n            return true;\\n        }\\n       while(j<n && s1[m-j-1].equals(s2[n-j-1])){\\n           j++;\\n       }\\n        if(j==n)\\n            return true;\\n        \\n        return (i+j)==n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791607,
                "title": "python3-recursive-solution-with-explicit-cases-probably-overkill",
                "content": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1, s2 = sentence1.split(\" \"), sentence2.split(\" \")\\n        n, m = len(s1), len(s2)\\n        if n < m:\\n            s1, s2 = s2, s1\\n            n, m = m, n\\n            \\n        @cache\\n        def rec(i, j, prev_eq, gaps):\\n            if gaps > 1:\\n                return False\\n            elif i == n:\\n                return j == m\\n            elif j == m:\\n                return i == n or gaps == 0\\n            elif prev_eq:\\n                if s1[i] == s2[j]:\\n                    return rec(i+1, j+1, True, gaps) or rec(i+1, j, False, gaps+1)\\n                else:\\n                    return rec(i+1, j, False, gaps+1)\\n            else:\\n                if s1[i] == s2[j]:\\n                    return rec(i+1, j+1, True, gaps) or rec(i+1, j, False, gaps)\\n                else:\\n                    return rec(i+1, j, False, gaps)\\n            \\n        return rec(0, 0, True, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\\n        s1, s2 = sentence1.split(\" \"), sentence2.split(\" \")\\n        n, m = len(s1), len(s2)\\n        if n < m:\\n            s1, s2 = s2, s1\\n            n, m = m, n\\n            \\n        @cache\\n        def rec(i, j, prev_eq, gaps):\\n            if gaps > 1:\\n                return False\\n            elif i == n:\\n                return j == m\\n            elif j == m:\\n                return i == n or gaps == 0\\n            elif prev_eq:\\n                if s1[i] == s2[j]:\\n                    return rec(i+1, j+1, True, gaps) or rec(i+1, j, False, gaps+1)\\n                else:\\n                    return rec(i+1, j, False, gaps+1)\\n            else:\\n                if s1[i] == s2[j]:\\n                    return rec(i+1, j+1, True, gaps) or rec(i+1, j, False, gaps)\\n                else:\\n                    return rec(i+1, j, False, gaps)\\n            \\n        return rec(0, 0, True, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790304,
                "title": "c-o-n-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {        \\n        if(s1.size()==s2.size()) return s1==s2;\\n        vector<string>v1,v2;\\n        stringstream str1(s1),str2(s2);\\n        string w;\\n        while(str1>>w)v1.push_back(w);\\n        while(str2>>w)v2.push_back(w);\\n        if(v1.size()<v2.size()) swap(v1,v2);\\n        int i=0,j=v2.size()-1,diff=v1.size()-v2.size();\\n        while(i<v2.size() && v2[i]==v1[i]) ++i;\\n        while(j>=0 && v2[j]==v1[j+diff]) --j;\\n        return i>j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string s1, string s2) {        \\n        if(s1.size()==s2.size()) return s1==s2;\\n        vector<string>v1,v2;\\n        stringstream str1(s1),str2(s2);\\n        string w;\\n        while(str1>>w)v1.push_back(w);\\n        while(str2>>w)v2.push_back(w);\\n        if(v1.size()<v2.size()) swap(v1,v2);\\n        int i=0,j=v2.size()-1,diff=v1.size()-v2.size();\\n        while(i<v2.size() && v2[i]==v1[i]) ++i;\\n        while(j>=0 && v2[j]==v1[j+diff]) --j;\\n        return i>j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772257,
                "title": "java-long-code-but-faster",
                "content": "```class Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n     return match(sentence1 , sentence2);\\n        \\n    }\\n    static boolean match (String sentence1 , String sentence2) {\\n//        sentence1 = sentence1.toLowerCase();\\n//        sentence2 = sentence2.toLowerCase();\\n        String[] s1 = sentence1.split(\" \");\\n        String[] s2 = sentence2.split(\" \");\\n        int i = 0;\\n        int j = 0;\\n        while (i < s1.length && j < s2.length &&  s1[i].equals(s2[j])) {\\n            i++;\\n            j++;\\n        }\\n        if (i == s1.length || j == s2.length) {\\n            return true;\\n        }\\n        else if (s1.length > s2.length) {\\n            while(i < s1.length  && !s1[i].equals(s2[j])) {\\n                i++;\\n            }\\n            if (i == s1.length) {\\n                return false;\\n            }\\n            if (j == s2.length - 1) {\\n                return s1[s1.length - 1].equals(s2[j]);\\n            }else {\\n                while (i < s1.length - 1 && s1[i].equals(s1[i + 1])) i++;\\n                while (i < s1.length && j < s2.length) {\\n                    if (!s1[i].equals(s2[j])) {\\n                        return false;\\n                    }\\n                    i++;\\n                    j++;\\n                }\\n                return (i == s1.length && j == s2.length);\\n            }\\n        }\\n        else  {\\n            while(j < s2.length  && !s2[j].equals(s1[i])) {\\n                j++;\\n            }\\n            if (j == s2.length) {\\n                return false;\\n            }\\n            if (i == s1.length - 1) {\\n                return s2[s2.length - 1].equals(s1[i]);\\n            }else {\\n                while (j < s2.length - 1 && s2[j].equals(s2[j + 1])) j++;\\n                while (i < s1.length && j < s2.length) {\\n                    if (!s1[i].equals(s2[j])) {\\n                        return false;\\n                    }\\n                    i++;\\n                    j++;\\n                }\\n                return (i == s1.length && j == s2.length);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n     return match(sentence1 , sentence2);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1743569,
                "title": "c-deque-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        deque<string> d1,d2;\\n        stringstream ss1(sentence1), ss2(sentence2);\\n        string curr;\\n        \\n        while(getline(ss1, curr, \\' \\'))\\n            d1.push_back(curr);\\n        \\n        while(getline(ss2, curr, \\' \\'))\\n            d2.push_back(curr);\\n        \\n        while(!d1.empty() && !d2.empty() && d1.front() == d2.front())\\n            d1.pop_front(), d2.pop_front();\\n        \\n        while(!d1.empty() && !d2.empty() && d1.back() == d2.back())\\n            d1.pop_back(), d2.pop_back();\\n        \\n        return d1.empty() || d2.empty();\\n    }\\n};\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        \\n        deque<string> d1,d2;\\n        stringstream ss1(sentence1), ss2(sentence2);\\n        string curr;\\n        \\n        while(getline(ss1, curr, \\' \\'))\\n            d1.push_back(curr);\\n        \\n        while(getline(ss2, curr, \\' \\'))\\n            d2.push_back(curr);\\n        \\n        while(!d1.empty() && !d2.empty() && d1.front() == d2.front())\\n            d1.pop_front(), d2.pop_front();\\n        \\n        while(!d1.empty() && !d2.empty() && d1.back() == d2.back())\\n            d1.pop_back(), d2.pop_back();\\n        \\n        return d1.empty() || d2.empty();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1734529,
                "title": "c-3-4-lines-linq-o-n-time-space",
                "content": "```\\npublic class Solution \\n{\\n    public bool AreSentencesSimilar(string sentence1, string sentence2) \\n    {\\n        string[] s1 = sentence1.Split(\\' \\'), s2 = sentence2.Split(\\' \\');\\n        return CommonPrefix(s1, s2) + CommonPrefix(s1.Reverse(), s2.Reverse()) >= Math.Min(s1.Length, s2.Length);\\n        \\n        static int CommonPrefix(IEnumerable<string> s1, IEnumerable<string> s2) \\n            => s1.Zip(s2).TakeWhile(p => p.First == p.Second).Count();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool AreSentencesSimilar(string sentence1, string sentence2) \\n    {\\n        string[] s1 = sentence1.Split(\\' \\'), s2 = sentence2.Split(\\' \\');\\n        return CommonPrefix(s1, s2) + CommonPrefix(s1.Reverse(), s2.Reverse()) >= Math.Min(s1.Length, s2.Length);\\n        \\n        static int CommonPrefix(IEnumerable<string> s1, IEnumerable<string> s2) \\n            => s1.Zip(s2).TakeWhile(p => p.First == p.Second).Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729003,
                "title": "c-0ms-deque",
                "content": "```\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if(s1.length() == s2.length())\\n            return s1==s2;\\n        if(s1.length() == 0 || s2.length() == 0) return true;\\n        deque<string> a, b;\\n        int i = 0;\\n        string temp = \"\";\\n        while(i < s1.length()){\\n            if(s1[i] == \\' \\'){i++;a.push_back(temp);temp = \"\";}\\n            else\\n                temp += s1[i++];\\n        }\\n        a.push_back(temp);\\n        i = 0;\\n        temp = \"\";\\n        while(i < s2.length()){\\n            if(s2[i] == \\' \\'){i++;b.push_back(temp);temp = \"\";} \\n            else\\n                temp += s2[i++];\\n        }\\n        b.push_back(temp);\\n        while(a.size() > 0 && b.size() > 0 && a.front() == b.front()){a.pop_front(); b.pop_front();}\\n        while(a.size() > 0 && b.size() > 0 && a.back() == b.back()){a.pop_back(); b.pop_back();}\\n        return (a.size() == 0 || b.size() == 0);\\n    }",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\n    bool areSentencesSimilar(string s1, string s2) {\\n        if(s1.length() == s2.length())\\n            return s1==s2;\\n        if(s1.length() == 0 || s2.length() == 0) return true;\\n        deque<string> a, b;\\n        int i = 0;\\n        string temp = \"\";\\n        while(i < s1.length()){\\n            if(s1[i] == \\' \\'){i++;a.push_back(temp);temp = \"\";}\\n            else\\n                temp += s1[i++];\\n        }\\n        a.push_back(temp);\\n        i = 0;\\n        temp = \"\";\\n        while(i < s2.length()){\\n            if(s2[i] == \\' \\'){i++;b.push_back(temp);temp = \"\";} \\n            else\\n                temp += s2[i++];\\n        }\\n        b.push_back(temp);\\n        while(a.size() > 0 && b.size() > 0 && a.front() == b.front()){a.pop_front(); b.pop_front();}\\n        while(a.size() > 0 && b.size() > 0 && a.back() == b.back()){a.pop_back(); b.pop_back();}\\n        return (a.size() == 0 || b.size() == 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1685921,
                "title": "c-0ms-100-simple-easy-small-space-o1-one-pass-two-pointers",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Sentence Similarity III.\\nMemory Usage: 6.2 MB, less than 93.53% of C++ online submissions for Sentence Similarity III.\\n```\\nclass Solution {\\npublic:\\n  bool areSentencesSimilar(string s1, string s2) {\\n    if(s1.size() < s2.size()) swap(s1,s2);                         //done s2 - the smallest\\n    int i = 0, j = s2.size()-1, id = s1.size()-1, last_space = 0;\\n    \\n    while(i != s2.size() && s1[i] == s2[i]) \\n      if(s1[i++] == \\' \\') last_space = i;\\n   \\n    if(i == s2.size() && (i == s1.size() || s1[i] == \\' \\') ) return true;\\n    i = last_space - 1; \\n       \\n    while(j > i && s1[id] == s2[j]) id--, j--;\\n  \\n    return j == i && s1[id] == \\' \\';\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool areSentencesSimilar(string s1, string s2) {\\n    if(s1.size() < s2.size()) swap(s1,s2);                         //done s2 - the smallest\\n    int i = 0, j = s2.size()-1, id = s1.size()-1, last_space = 0;\\n    \\n    while(i != s2.size() && s1[i] == s2[i]) \\n      if(s1[i++] == \\' \\') last_space = i;\\n   \\n    if(i == s2.size() && (i == s1.size() || s1[i] == \\' \\') ) return true;\\n    i = last_space - 1; \\n       \\n    while(j > i && s1[id] == s2[j]) id--, j--;\\n  \\n    return j == i && s1[id] == \\' \\';\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676707,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String s, String t) {\\n        int ms = s.length(), nt=t.length();\\n        if(s==null||ms==0||t==null||nt==0){\\n            return true;\\n        }\\n        \\n        if(ms<nt) return areSentencesSimilar(t,s);\\n        \\n        String[] S = s.split(\" \");\\n        String[] T = t.split(\" \");\\n        \\n        int m = S.length, n = T.length;\\n        \\n        int i=0;\\n        while(i<n&&(S[i]).equals(T[i])) i++;\\n        if(i==n) return true;\\n        \\n        int j=0;\\n        while(j<n&&(S[m-1-j]).equals(T[n-1-j])) j++;\\n        if(j==n) return true;\\n        \\n        return (i+j)==n;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areSentencesSimilar(String s, String t) {\\n        int ms = s.length(), nt=t.length();\\n        if(s==null||ms==0||t==null||nt==0){\\n            return true;\\n        }\\n        \\n        if(ms<nt) return areSentencesSimilar(t,s);\\n        \\n        String[] S = s.split(\" \");\\n        String[] T = t.split(\" \");\\n        \\n        int m = S.length, n = T.length;\\n        \\n        int i=0;\\n        while(i<n&&(S[i]).equals(T[i])) i++;\\n        if(i==n) return true;\\n        \\n        int j=0;\\n        while(j<n&&(S[m-1-j]).equals(T[n-1-j])) j++;\\n        if(j==n) return true;\\n        \\n        return (i+j)==n;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1911369,
                "content": [
                    {
                        "username": "Msey",
                        "content": "This problem\\'s edgecases are like a minesweeper game "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "problem description is unclear"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "wow this looked easy when reading the question , edgecases is where it got kind of tricky."
                    },
                    {
                        "username": "serega",
                        "content": "Same here. Seems easy, but had to iterate a few times before fixed all edgecases"
                    },
                    {
                        "username": "user1183Z",
                        "content": "Yeeeah, this task is exactly about edgecases"
                    },
                    {
                        "username": "JParks1982",
                        "content": "The acceptance rate concerned me at first, but I didn\\'t find the \"edge cases\" to be problematic with a two-pointers approach (well, technically 3 pointers). Tokenize both strings into word tokens, set a single left pointer to the start of both strings and two right pointers, one each for the right side of each string. Iterate first from left while tokens of both strings match, break when condition fails. Do the same from the right side of both strings. Afterward, if the left pointer equals at least one of the right pointers, the sentences are similar."
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "Feels easy only until you discover edge cases"
                    },
                    {
                        "username": "seif_elsokary10",
                        "content": "its two condition\\nfirst condition ::-->\\n1- check if s1[0] == s2[0]:\\n         pop (s1[0] and s2[0])\\nsecond condition ::->\\n2- check if s1[-1] == s2[-1]:\\n         pop (s1[-1] and s2[-1])\\n\\n"
                    }
                ]
            },
            {
                "id": 1754666,
                "content": [
                    {
                        "username": "Msey",
                        "content": "This problem\\'s edgecases are like a minesweeper game "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "problem description is unclear"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "wow this looked easy when reading the question , edgecases is where it got kind of tricky."
                    },
                    {
                        "username": "serega",
                        "content": "Same here. Seems easy, but had to iterate a few times before fixed all edgecases"
                    },
                    {
                        "username": "user1183Z",
                        "content": "Yeeeah, this task is exactly about edgecases"
                    },
                    {
                        "username": "JParks1982",
                        "content": "The acceptance rate concerned me at first, but I didn\\'t find the \"edge cases\" to be problematic with a two-pointers approach (well, technically 3 pointers). Tokenize both strings into word tokens, set a single left pointer to the start of both strings and two right pointers, one each for the right side of each string. Iterate first from left while tokens of both strings match, break when condition fails. Do the same from the right side of both strings. Afterward, if the left pointer equals at least one of the right pointers, the sentences are similar."
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "Feels easy only until you discover edge cases"
                    },
                    {
                        "username": "seif_elsokary10",
                        "content": "its two condition\\nfirst condition ::-->\\n1- check if s1[0] == s2[0]:\\n         pop (s1[0] and s2[0])\\nsecond condition ::->\\n2- check if s1[-1] == s2[-1]:\\n         pop (s1[-1] and s2[-1])\\n\\n"
                    }
                ]
            },
            {
                "id": 1687288,
                "content": [
                    {
                        "username": "Msey",
                        "content": "This problem\\'s edgecases are like a minesweeper game "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "problem description is unclear"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "wow this looked easy when reading the question , edgecases is where it got kind of tricky."
                    },
                    {
                        "username": "serega",
                        "content": "Same here. Seems easy, but had to iterate a few times before fixed all edgecases"
                    },
                    {
                        "username": "user1183Z",
                        "content": "Yeeeah, this task is exactly about edgecases"
                    },
                    {
                        "username": "JParks1982",
                        "content": "The acceptance rate concerned me at first, but I didn\\'t find the \"edge cases\" to be problematic with a two-pointers approach (well, technically 3 pointers). Tokenize both strings into word tokens, set a single left pointer to the start of both strings and two right pointers, one each for the right side of each string. Iterate first from left while tokens of both strings match, break when condition fails. Do the same from the right side of both strings. Afterward, if the left pointer equals at least one of the right pointers, the sentences are similar."
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "Feels easy only until you discover edge cases"
                    },
                    {
                        "username": "seif_elsokary10",
                        "content": "its two condition\\nfirst condition ::-->\\n1- check if s1[0] == s2[0]:\\n         pop (s1[0] and s2[0])\\nsecond condition ::->\\n2- check if s1[-1] == s2[-1]:\\n         pop (s1[-1] and s2[-1])\\n\\n"
                    }
                ]
            },
            {
                "id": 2047156,
                "content": [
                    {
                        "username": "Msey",
                        "content": "This problem\\'s edgecases are like a minesweeper game "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "problem description is unclear"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "wow this looked easy when reading the question , edgecases is where it got kind of tricky."
                    },
                    {
                        "username": "serega",
                        "content": "Same here. Seems easy, but had to iterate a few times before fixed all edgecases"
                    },
                    {
                        "username": "user1183Z",
                        "content": "Yeeeah, this task is exactly about edgecases"
                    },
                    {
                        "username": "JParks1982",
                        "content": "The acceptance rate concerned me at first, but I didn\\'t find the \"edge cases\" to be problematic with a two-pointers approach (well, technically 3 pointers). Tokenize both strings into word tokens, set a single left pointer to the start of both strings and two right pointers, one each for the right side of each string. Iterate first from left while tokens of both strings match, break when condition fails. Do the same from the right side of both strings. Afterward, if the left pointer equals at least one of the right pointers, the sentences are similar."
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "Feels easy only until you discover edge cases"
                    },
                    {
                        "username": "seif_elsokary10",
                        "content": "its two condition\\nfirst condition ::-->\\n1- check if s1[0] == s2[0]:\\n         pop (s1[0] and s2[0])\\nsecond condition ::->\\n2- check if s1[-1] == s2[-1]:\\n         pop (s1[-1] and s2[-1])\\n\\n"
                    }
                ]
            },
            {
                "id": 1955763,
                "content": [
                    {
                        "username": "Msey",
                        "content": "This problem\\'s edgecases are like a minesweeper game "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "problem description is unclear"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "wow this looked easy when reading the question , edgecases is where it got kind of tricky."
                    },
                    {
                        "username": "serega",
                        "content": "Same here. Seems easy, but had to iterate a few times before fixed all edgecases"
                    },
                    {
                        "username": "user1183Z",
                        "content": "Yeeeah, this task is exactly about edgecases"
                    },
                    {
                        "username": "JParks1982",
                        "content": "The acceptance rate concerned me at first, but I didn\\'t find the \"edge cases\" to be problematic with a two-pointers approach (well, technically 3 pointers). Tokenize both strings into word tokens, set a single left pointer to the start of both strings and two right pointers, one each for the right side of each string. Iterate first from left while tokens of both strings match, break when condition fails. Do the same from the right side of both strings. Afterward, if the left pointer equals at least one of the right pointers, the sentences are similar."
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "Feels easy only until you discover edge cases"
                    },
                    {
                        "username": "seif_elsokary10",
                        "content": "its two condition\\nfirst condition ::-->\\n1- check if s1[0] == s2[0]:\\n         pop (s1[0] and s2[0])\\nsecond condition ::->\\n2- check if s1[-1] == s2[-1]:\\n         pop (s1[-1] and s2[-1])\\n\\n"
                    }
                ]
            },
            {
                "id": 1830754,
                "content": [
                    {
                        "username": "Msey",
                        "content": "This problem\\'s edgecases are like a minesweeper game "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "problem description is unclear"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "wow this looked easy when reading the question , edgecases is where it got kind of tricky."
                    },
                    {
                        "username": "serega",
                        "content": "Same here. Seems easy, but had to iterate a few times before fixed all edgecases"
                    },
                    {
                        "username": "user1183Z",
                        "content": "Yeeeah, this task is exactly about edgecases"
                    },
                    {
                        "username": "JParks1982",
                        "content": "The acceptance rate concerned me at first, but I didn\\'t find the \"edge cases\" to be problematic with a two-pointers approach (well, technically 3 pointers). Tokenize both strings into word tokens, set a single left pointer to the start of both strings and two right pointers, one each for the right side of each string. Iterate first from left while tokens of both strings match, break when condition fails. Do the same from the right side of both strings. Afterward, if the left pointer equals at least one of the right pointers, the sentences are similar."
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "Feels easy only until you discover edge cases"
                    },
                    {
                        "username": "seif_elsokary10",
                        "content": "its two condition\\nfirst condition ::-->\\n1- check if s1[0] == s2[0]:\\n         pop (s1[0] and s2[0])\\nsecond condition ::->\\n2- check if s1[-1] == s2[-1]:\\n         pop (s1[-1] and s2[-1])\\n\\n"
                    }
                ]
            }
        ]
    }
]