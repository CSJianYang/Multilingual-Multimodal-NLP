[
    {
        "title": "Create Binary Tree From Descriptions",
        "question_content": "You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,\n\n\tIf isLefti == 1, then childi is the left child of parenti.\n\tIf isLefti == 0, then childi is the right child of parenti.\n\nConstruct the binary tree described by descriptions and return its root.\nThe test cases will be generated such that the binary tree is valid.\n&nbsp;\nExample 1:\n\nInput: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]\nOutput: [50,20,80,15,17,19]\nExplanation: The root node is the node with value 50 since it has no parent.\nThe resulting binary tree is shown in the diagram.\n\nExample 2:\n\nInput: descriptions = [[1,2,1],[2,3,0],[3,4,1]]\nOutput: [1,2,null,null,3,4]\nExplanation: The root node is the node with value 1 since it has no parent.\nThe resulting binary tree is shown in the diagram.\n\n&nbsp;\nConstraints:\n\n\t1 <= descriptions.length <= 104\n\tdescriptions[i].length == 3\n\t1 <= parenti, childi <= 105\n\t0 <= isLefti <= 1\n\tThe binary tree described by descriptions is valid.",
        "solutions": [
            {
                "id": 1823687,
                "title": "c-map",
                "content": "We are using a hashmap (**getNode**) to store node for corresponding value. Also, we are using a hashmap (**isChild**) to check if node is a child or not.\\nThen, we traverse through the *descriptions* array and make the connections accordingly.\\n* If we haven\\'t created node for corresponding value previously we create it otherwise we get the node from hashmap (*getNode*).\\n* We connect the child node to parent node as a left or right child according to the value of isLeft.\\n* And mark child node as *true* in hashmap (*isChild*).\\n\\nAt last we travel through all the nodes in *descriptions* to check which node has no parent (i.e root node) and return the root node.\\n*descriptions[i] = [parent, child, isLeft]*\\nI am checking for only parent because checking child node makes no sense and saves some time.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions){\\n        unordered_map<int, TreeNode*> getNode;                          //to check if node alredy exist\\n        unordered_map<int, bool> isChild;                               //to check if node has parent or not\\n        for(auto &v: descriptions){\\n            if(getNode.count(v[0])==0){\\n                TreeNode* par = new TreeNode(v[0]);\\n                getNode[v[0]] = par;\\n            }\\n            if(getNode.count(v[1])==0){\\n                TreeNode* child = new TreeNode(v[1]);\\n                getNode[v[1]] = child;\\n            }\\n            if(v[2]==1) getNode[v[0]]->left = getNode[v[1]];               //left-child\\n            else getNode[v[0]]->right = getNode[v[1]];                     //right-child\\n            isChild[v[1]] = true;\\n        }\\n        TreeNode* ans = NULL;\\n        for(auto &v: descriptions){\\n            if(isChild[v[0]] != true){                  //if node has no parent then this is root node\\n                ans = getNode[v[0]]; \\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n*If you like the solution, please Upvote \\uD83D\\uDC4D!!*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions){\\n        unordered_map<int, TreeNode*> getNode;                          //to check if node alredy exist\\n        unordered_map<int, bool> isChild;                               //to check if node has parent or not\\n        for(auto &v: descriptions){\\n            if(getNode.count(v[0])==0){\\n                TreeNode* par = new TreeNode(v[0]);\\n                getNode[v[0]] = par;\\n            }\\n            if(getNode.count(v[1])==0){\\n                TreeNode* child = new TreeNode(v[1]);\\n                getNode[v[1]] = child;\\n            }\\n            if(v[2]==1) getNode[v[0]]->left = getNode[v[1]];               //left-child\\n            else getNode[v[0]]->right = getNode[v[1]];                     //right-child\\n            isChild[v[1]] = true;\\n        }\\n        TreeNode* ans = NULL;\\n        for(auto &v: descriptions){\\n            if(isChild[v[0]] != true){                  //if node has no parent then this is root node\\n                ans = getNode[v[0]]; \\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823716,
                "title": "simple-java-solution-hashmap",
                "content": "```\\npublic TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        Set<Integer> children = new HashSet<>();\\n        for (int[] arr : descriptions) {\\n            int parent = arr[0], child = arr[1], isLeft = arr[2];\\n            children.add(child);\\n            TreeNode node = map.getOrDefault(parent, new TreeNode(parent));\\n            if (isLeft == 1) {\\n                node.left = map.getOrDefault(child, new TreeNode(child));\\n                map.put(child, node.left);\\n            } else {\\n                node.right = map.getOrDefault(child, new TreeNode(child));\\n                map.put(child, node.right);\\n            }\\n            map.put(parent, node);\\n        }\\n        \\n        int root = -1;\\n        for (int [] arr: descriptions) {\\n            if (!children.contains(arr[0])) {\\n                root = arr[0];\\n                break;\\n            }\\n        }\\n        \\n        return map.getOrDefault(root, null);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\npublic TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        Set<Integer> children = new HashSet<>();\\n        for (int[] arr : descriptions) {\\n            int parent = arr[0], child = arr[1], isLeft = arr[2];\\n            children.add(child);\\n            TreeNode node = map.getOrDefault(parent, new TreeNode(parent));\\n            if (isLeft == 1) {\\n                node.left = map.getOrDefault(child, new TreeNode(child));\\n                map.put(child, node.left);\\n            } else {\\n                node.right = map.getOrDefault(child, new TreeNode(child));\\n                map.put(child, node.right);\\n            }\\n            map.put(parent, node);\\n        }\\n        \\n        int root = -1;\\n        for (int [] arr: descriptions) {\\n            if (!children.contains(arr[0])) {\\n                root = arr[0];\\n                break;\\n            }\\n        }\\n        \\n        return map.getOrDefault(root, null);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823804,
                "title": "python-solution",
                "content": "# **Explanation**\\nIterate `descriptions`,\\nfor each `[p, c, l]` of `[parent, child, isLeft]`\\n\\nCreate `Treenode` with value `p` and `c`,\\nand store them in a hash map with the value as key,\\nso that we can access the `TreeNode` easily.\\n\\nBased on the value `isLeft`,\\nwe assign `Treenode(parent).left = Treenode(child)`\\nor `Treenode(parent).right = Treenode(child)`.\\n\\nFinall we find the `root` of the tree, and return its `TreeNode`.\\n<br>\\n\\n**Python**\\n```py\\n    def createBinaryTree(self, descriptions):\\n        children = set()\\n        m = {}\\n        for p,c,l in descriptions:\\n            np = m.setdefault(p, TreeNode(p))\\n            nc = m.setdefault(c, TreeNode(c))\\n            if l:\\n                np.left = nc\\n            else:\\n                np.right = nc\\n            children.add(c)\\n        root = (set(m) - set(children)).pop()\\n        return m[root]\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def createBinaryTree(self, descriptions):\\n        children = set()\\n        m = {}\\n        for p,c,l in descriptions:\\n            np = m.setdefault(p, TreeNode(p))\\n            nc = m.setdefault(c, TreeNode(c))\\n            if l:\\n                np.left = nc\\n            else:\\n                np.right = nc\\n            children.add(c)\\n        root = (set(m) - set(children)).pop()\\n        return m[root]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823606,
                "title": "c-hash-map-o-n-time",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Hash Table\\n\\nMaintain a hash map from node value to node pointer. Use this map to prevent creating the same node multiple times.\\n\\nTo get the root node, we can maintain another map `parentMap` mapping from child node pointer to parent node pointer. We pick a random node pointer and keep traversing back towards the root using `parentMap` until the node doesn\\'t have any parents.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/create-binary-tree-from-descriptions/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& A) {\\n        unordered_map<TreeNode*, TreeNode*> parentMap; // map from child node pointer to parent node pointer\\n        unordered_map<int, TreeNode*> m; // map from node value to node pointer\\n        for (auto &v : A) {\\n            int p = v[0], c = v[1], isLeft = v[2];\\n            auto parent = m.count(p) ? m[p] : (m[p] = new TreeNode(p));\\n            auto child = m.count(c) ? m[c] : (m[c] = new TreeNode(c));\\n            if (isLeft) parent->left = child;\\n            else parent->right = child;\\n            parentMap[child] = parent;\\n        }\\n        auto root = m.begin()->second; // Pick a random node pointer and keep traversing up until the node doesn\\'t have any parents\\n        while (parentMap.count(root)) root = parentMap[root];\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/create-binary-tree-from-descriptions/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& A) {\\n        unordered_map<TreeNode*, TreeNode*> parentMap; // map from child node pointer to parent node pointer\\n        unordered_map<int, TreeNode*> m; // map from node value to node pointer\\n        for (auto &v : A) {\\n            int p = v[0], c = v[1], isLeft = v[2];\\n            auto parent = m.count(p) ? m[p] : (m[p] = new TreeNode(p));\\n            auto child = m.count(c) ? m[c] : (m[c] = new TreeNode(c));\\n            if (isLeft) parent->left = child;\\n            else parent->right = child;\\n            parentMap[child] = parent;\\n        }\\n        auto root = m.begin()->second; // Pick a random node pointer and keep traversing up until the node doesn\\'t have any parents\\n        while (parentMap.count(root)) root = parentMap[root];\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823729,
                "title": "java-python-3-2-codes-hashmap-and-bfs-w-brief-explanation-and-analysis",
                "content": "**Q & A:**\\nQ1: How to get root?\\nA1: The node that does NOT have any parent is the root.\\nUse `2` sets to store parents and kids respectively; from the `keySet()` of `valToNode`, `parents`, remove all `kids`, there must be one remaining, the root.\\n\\n**End of Q & A**\\n\\n**HashMap**\\n\\n```java\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Set<Integer> kids = new HashSet<>();\\n        Map<Integer, TreeNode> valToNode = new HashMap<>();\\n        for (int[] d : descriptions) {\\n            int parent = d[0], kid = d[1], left = d[2];\\n            valToNode.putIfAbsent(parent, new TreeNode(parent));\\n            valToNode.putIfAbsent(kid, new TreeNode(kid));\\n            kids.add(kid);\\n            if (left == 1) {\\n                valToNode.get(parent).left = valToNode.get(kid);\\n            }else {\\n                valToNode.get(parent).right = valToNode.get(kid);\\n            }\\n        }\\n        valToNode.keySet().removeAll(kids);\\n        return valToNode.values().iterator().next();\\n    }\\n```\\n```python\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        val_to_node, kids = {}, set()\\n        for parent, kid, left in descriptions:\\n            kids.add(kid)\\n            parent_node = val_to_node.setdefault(parent, TreeNode(parent))\\n            kid_node = val_to_node.setdefault(kid, TreeNode(kid))\\n            if left == 1:\\n                parent_node.left = kid_node\\n            else:\\n                parent_node.right = kid_node\\n        return val_to_node[(val_to_node.keys() - kids).pop()]\\n```\\n\\n----\\n\\n**BFS**\\n\\n1. Build graph from parent to kids, and add parent and kids to `HashSet`s respectively;\\n2. Remove all `kids` from `parents`, and the remaining is `root`;\\n3. Starting from `root`, use BFS to construct binary tree according to the graph `parentsToKids` built in `1.`.\\n\\n```java\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Set<Integer> kids = new HashSet<>(), parents = new HashSet<>();\\n        Map<Integer, List<int[]>> parentToKids = new HashMap<>();\\n        for (int[] d : descriptions) {\\n            int parent = d[0], kid = d[1];\\n            parents.add(parent);\\n            kids.add(kid);\\n            parentToKids.computeIfAbsent(parent, l -> new ArrayList<>()).add(new int[]{kid, d[2]});\\n        }\\n        parents.removeAll(kids);\\n        TreeNode root = new TreeNode(parents.iterator().next());\\n        Deque<TreeNode> dq = new ArrayDeque<>();\\n        dq.offer(root);\\n        while (!dq.isEmpty()) {\\n            TreeNode parent = dq.poll();\\n            for (int[] kidInfo : parentToKids.getOrDefault(parent.val, Arrays.asList())) {\\n                int kid = kidInfo[0], left = kidInfo[1];\\n                dq.offer(new TreeNode(kid));\\n                if (left == 1) {\\n                    parent.left = dq.peekLast();\\n                }else {\\n                    parent.right = dq.peekLast();\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n```\\n\\n```python\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        g, kids, parents = defaultdict(list), set(), set()\\n        for parent, kid, left in descriptions:\\n            kids.add(kid)\\n            parents.add(parent)\\n            g[parent].append([kid, left])\\n        parents.difference_update(kids)\\n        root = TreeNode(parents.pop())\\n        dq = deque([root])\\n        while dq:\\n            parent = dq.popleft()\\n            for kid, left in g.pop(parent.val, []): \\n                dq.append(TreeNode(kid))\\n                if left == 1:\\n                    parent.left = dq[-1]\\n                else:\\n                    parent.right = dq[-1]\\n        return root\\n```\\n\\n**Analysis:**\\n\\nEach node/value is visited at most twice, therefore,\\n\\nTime & space: `O(V + E)`, where `V = # of nodes, E = # of edges`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Set<Integer> kids = new HashSet<>();\\n        Map<Integer, TreeNode> valToNode = new HashMap<>();\\n        for (int[] d : descriptions) {\\n            int parent = d[0], kid = d[1], left = d[2];\\n            valToNode.putIfAbsent(parent, new TreeNode(parent));\\n            valToNode.putIfAbsent(kid, new TreeNode(kid));\\n            kids.add(kid);\\n            if (left == 1) {\\n                valToNode.get(parent).left = valToNode.get(kid);\\n            }else {\\n                valToNode.get(parent).right = valToNode.get(kid);\\n            }\\n        }\\n        valToNode.keySet().removeAll(kids);\\n        return valToNode.values().iterator().next();\\n    }\\n```\n```python\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        val_to_node, kids = {}, set()\\n        for parent, kid, left in descriptions:\\n            kids.add(kid)\\n            parent_node = val_to_node.setdefault(parent, TreeNode(parent))\\n            kid_node = val_to_node.setdefault(kid, TreeNode(kid))\\n            if left == 1:\\n                parent_node.left = kid_node\\n            else:\\n                parent_node.right = kid_node\\n        return val_to_node[(val_to_node.keys() - kids).pop()]\\n```\n```java\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Set<Integer> kids = new HashSet<>(), parents = new HashSet<>();\\n        Map<Integer, List<int[]>> parentToKids = new HashMap<>();\\n        for (int[] d : descriptions) {\\n            int parent = d[0], kid = d[1];\\n            parents.add(parent);\\n            kids.add(kid);\\n            parentToKids.computeIfAbsent(parent, l -> new ArrayList<>()).add(new int[]{kid, d[2]});\\n        }\\n        parents.removeAll(kids);\\n        TreeNode root = new TreeNode(parents.iterator().next());\\n        Deque<TreeNode> dq = new ArrayDeque<>();\\n        dq.offer(root);\\n        while (!dq.isEmpty()) {\\n            TreeNode parent = dq.poll();\\n            for (int[] kidInfo : parentToKids.getOrDefault(parent.val, Arrays.asList())) {\\n                int kid = kidInfo[0], left = kidInfo[1];\\n                dq.offer(new TreeNode(kid));\\n                if (left == 1) {\\n                    parent.left = dq.peekLast();\\n                }else {\\n                    parent.right = dq.peekLast();\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n```\n```python\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        g, kids, parents = defaultdict(list), set(), set()\\n        for parent, kid, left in descriptions:\\n            kids.add(kid)\\n            parents.add(parent)\\n            g[parent].append([kid, left])\\n        parents.difference_update(kids)\\n        root = TreeNode(parents.pop())\\n        dq = deque([root])\\n        while dq:\\n            parent = dq.popleft()\\n            for kid, left in g.pop(parent.val, []): \\n                dq.append(TreeNode(kid))\\n                if left == 1:\\n                    parent.left = dq[-1]\\n                else:\\n                    parent.right = dq[-1]\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823728,
                "title": "do-as-question-says-easy-and-well-explained-clean-code",
                "content": "This is very straightforward problem. Just keep doing as problem says.\\nLike for any ***description*** in **descriptions** :\\n1. Get the parent node \\n\\t* So first check whether you\\'ve been created parent node earlier or not. If it\\'s not created than create it else get the earlier node.\\n\\t* If child node is in the left of parent than add it left else add it to the right.\\n2. Keep memorize these 2 nodes for future process.\\n\\t3. Once we done with all **description** in **descriptions** than we have challenge part to find the root node. So for this keep tracking the inDegree for every node. And which node have inDegree 0 that will be our root node.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        // To store whether we have already created a subtree with give node as key\\n        unordered_map<int,TreeNode*> created;\\n        \\n        // It will help to find the root node\\n        vector<int> inDegree(100001,0);\\n        for(auto &d:descriptions) {\\n            // If already created than get the older once else create new\\n            TreeNode *parent = created.find(d[0])==created.end() ? new TreeNode(d[0]): created[d[0]];\\n            TreeNode *child = created.find(d[1])==created.end() ? new TreeNode(d[1]): created[d[1]];\\n            \\n            // Do as problem description said\\n            if(d[2]) {\\n                parent->left = child;\\n            } else {\\n                parent->right = child;\\n            }\\n            \\n            // Store back to use for future\\n            created[d[0]] = parent;\\n            created[d[1]] = child;\\n            inDegree[d[1]]++;\\n        }\\n        \\n        // Find the root node\\n        for(auto &[key, node]:created) {\\n            if(inDegree[key] == 0) {\\n                return node;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};\\n```\\n# Time Complexity : \\n**Since we are going to each description in descriptions only once. So it would take O(N) time. And also finding the root node take O(N) time.**\\n\\n# Space Complexity :\\n**Since we are storing the nodes and storing the inDegree which will take O(N) space.**\\n\\n**Please upvote if it helps you.**\\n\\n*Happy Coding!*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        // To store whether we have already created a subtree with give node as key\\n        unordered_map<int,TreeNode*> created;\\n        \\n        // It will help to find the root node\\n        vector<int> inDegree(100001,0);\\n        for(auto &d:descriptions) {\\n            // If already created than get the older once else create new\\n            TreeNode *parent = created.find(d[0])==created.end() ? new TreeNode(d[0]): created[d[0]];\\n            TreeNode *child = created.find(d[1])==created.end() ? new TreeNode(d[1]): created[d[1]];\\n            \\n            // Do as problem description said\\n            if(d[2]) {\\n                parent->left = child;\\n            } else {\\n                parent->right = child;\\n            }\\n            \\n            // Store back to use for future\\n            created[d[0]] = parent;\\n            created[d[1]] = child;\\n            inDegree[d[1]]++;\\n        }\\n        \\n        // Find the root node\\n        for(auto &[key, node]:created) {\\n            if(inDegree[key] == 0) {\\n                return node;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183055,
                "title": "python3-solution-with-explanation",
                "content": "Code is self explanatory...\\nI used hashmap to store node\\'s value as key and node as value... so by using key I can access particular node at any time....\\nI took nodes set which I pushed all node values in it...\\nI took children set which I pushed all children values in it..\\n\\nIf a node in the nodes set is not present in children set... that means that node is not a children.. i.e, that node doesnt have any parent... so return that particular node as root....\\n\\n```\\n\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        hashmap = {}\\n        nodes = set()\\n        children = set()\\n        for parent,child,isLeft in descriptions:\\n            nodes.add(parent)\\n            nodes.add(child)\\n            children.add(child)\\n            if parent not in hashmap:\\n                hashmap[parent] = TreeNode(parent)\\n            if child not in hashmap:\\n                hashmap[child] = TreeNode(child)\\n            if isLeft:\\n                hashmap[parent].left = hashmap[child]\\n            if not isLeft:\\n                hashmap[parent].right = hashmap[child]\\n        \\n        for node in nodes:\\n            if node not in children:\\n                return hashmap[node]\\n\\n\\n\\n```\\n\\n**PLEASE UPVOTE IF U LIKE IT :).. FEEL FREE TO ASK QUERIES**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        hashmap = {}\\n        nodes = set()\\n        children = set()\\n        for parent,child,isLeft in descriptions:\\n            nodes.add(parent)\\n            nodes.add(child)\\n            children.add(child)\\n            if parent not in hashmap:\\n                hashmap[parent] = TreeNode(parent)\\n            if child not in hashmap:\\n                hashmap[child] = TreeNode(child)\\n            if isLeft:\\n                hashmap[parent].left = hashmap[child]\\n            if not isLeft:\\n                hashmap[parent].right = hashmap[child]\\n        \\n        for node in nodes:\\n            if node not in children:\\n                return hashmap[node]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823644,
                "title": "python3-simulation",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/bb5647e856ff11b072f9c51a140e0f243c100171) for solutions of weekly 283.\\n\\n```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        mp = {}\\n        seen = set()\\n        for p, c, left in descriptions: \\n            if p not in mp: mp[p] = TreeNode(p)\\n            if c not in mp: mp[c] = TreeNode(c)\\n            if left: mp[p].left = mp[c]\\n            else: mp[p].right = mp[c]\\n            seen.add(c)\\n        for p, _, _ in descriptions: \\n            if p not in seen: return mp[p]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        mp = {}\\n        seen = set()\\n        for p, c, left in descriptions: \\n            if p not in mp: mp[p] = TreeNode(p)\\n            if c not in mp: mp[c] = TreeNode(c)\\n            if left: mp[p].left = mp[c]\\n            else: mp[p].right = mp[c]\\n            seen.add(c)\\n        for p, _, _ in descriptions: \\n            if p not in seen: return mp[p]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823953,
                "title": "c-map-set-detailed-explanation",
                "content": "**Structures used:**\\n*map bank* : stores {int a, TreeNode* temp} pair, where *int a* is the node value, and *temp* is the address of the node with value same *int a*\\n*set k* : cotains all the value of the nodes, and is used to find the root node\\n\\n**Explanation**\\n* **Section 1** \\n\\tThe map *bank* and set *k* are populated here. If the node with value *des[i][0]* or *des[i][1]* (for all *i* from *0* to *des.size()-1*) have not been encountered before, then a TreeNode is made for them followed by making connections between them. \\n\\tThe set k is also inserted with various node value\\n* **Section 2**\\n\\tOne key observation for finding the root is that, since root has no parents it will not occur as *des[i][1]* (for all *i* from *0* to *des.size()-1*). So I interate through the *des* vector again and pop all the *des[i][1]* so only one integer remains in set k at the begining position. and then return the TreeNode * associated to that root value using map bank\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) \\n    {\\n        unordered_set<int> k; \\n        unordered_map<int, TreeNode*> bank;\\n        \\n\\t\\t//Section 1\\n\\t\\tfor(int i =0; i<des.size(); i++)\\n        {\\n            k.insert(des[i][0]);\\n            k.insert(des[i][1]);\\n            \\n            if(bank.find(des[i][0]) == bank.end())\\n            {\\n                TreeNode *temp = new TreeNode(des[i][0]);\\n                bank.insert({des[i][0], temp});\\n            }\\n            if(bank.find(des[i][1]) == bank.end())\\n            {\\n                TreeNode *temp = new TreeNode(des[i][1]);\\n                bank.insert({des[i][1], temp});  \\n            }\\n            \\n            if(des[i][2] == 0)\\n                bank[des[i][0]]->right = bank[des[i][1]];\\n            else\\n                bank[des[i][0]]->left = bank[des[i][1]];\\n        }\\n        \\n\\t\\t//Section 2\\n        for(int i =0; i<des.size(); i++)\\n            k.erase(k.find(des[i][1]));\\n        \\n        return bank[*k.begin()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) \\n    {\\n        unordered_set<int> k; \\n        unordered_map<int, TreeNode*> bank;\\n        \\n\\t\\t//Section 1\\n\\t\\tfor(int i =0; i<des.size(); i++)\\n        {\\n            k.insert(des[i][0]);\\n            k.insert(des[i][1]);\\n            \\n            if(bank.find(des[i][0]) == bank.end())\\n            {\\n                TreeNode *temp = new TreeNode(des[i][0]);\\n                bank.insert({des[i][0], temp});\\n            }\\n            if(bank.find(des[i][1]) == bank.end())\\n            {\\n                TreeNode *temp = new TreeNode(des[i][1]);\\n                bank.insert({des[i][1], temp});  \\n            }\\n            \\n            if(des[i][2] == 0)\\n                bank[des[i][0]]->right = bank[des[i][1]];\\n            else\\n                bank[des[i][0]]->left = bank[des[i][1]];\\n        }\\n        \\n\\t\\t//Section 2\\n        for(int i =0; i<des.size(); i++)\\n            k.erase(k.find(des[i][1]));\\n        \\n        return bank[*k.begin()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823720,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& nums) {\\n        unordered_map<int,TreeNode*> hash;\\n        unordered_set<int> rootcomp;\\n        for(int i=0;i<nums.size();i++){\\n            if(!hash.count(nums[i][0])) hash[nums[i][0]]=new TreeNode(nums[i][0]);\\n            if(!hash.count(nums[i][1])) hash[nums[i][1]]=new TreeNode(nums[i][1]);\\n            rootcomp.insert(nums[i][1]);\\n            TreeNode* parent=hash[nums[i][0]]; TreeNode* child=hash[nums[i][1]];\\n            nums[i][2]==1?parent->left=child:parent->right=child;\\n        }\\n        for(int i=0;i<nums.size();i++) if(!rootcomp.count(nums[i][0])) return hash[nums[i][0]];\\n        return nullptr;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& nums) {\\n        unordered_map<int,TreeNode*> hash;\\n        unordered_set<int> rootcomp;\\n        for(int i=0;i<nums.size();i++){\\n            if(!hash.count(nums[i][0])) hash[nums[i][0]]=new TreeNode(nums[i][0]);\\n            if(!hash.count(nums[i][1])) hash[nums[i][1]]=new TreeNode(nums[i][1]);\\n            rootcomp.insert(nums[i][1]);\\n            TreeNode* parent=hash[nums[i][0]]; TreeNode* child=hash[nums[i][1]];\\n            nums[i][2]==1?parent->left=child:parent->right=child;\\n        }\\n        for(int i=0;i<nums.size();i++) if(!rootcomp.count(nums[i][0])) return hash[nums[i][0]];\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823623,
                "title": "c-easy-hashmap-commented-code",
                "content": "\\n1) Use unordered_map and unordered_set .\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& desc)\\n    {\\n        // set contains all the nodes\\n        set<TreeNode*>contains;\\n        \\n        // map which contains child -> parent\\n        unordered_map<TreeNode*,TreeNode*>childToParentMap;\\n        \\n        //map which contains val->Node\\n        unordered_map<int,TreeNode*>valWithNode;\\n\\n        for(auto &xt : desc)\\n        {\\n            int parentVal = xt[0];\\n            int childVal = xt[1];\\n            int isLeft = xt[2];\\n            \\n            TreeNode* parent;\\n            \\n            // if the parent val is already present get that particular node no need to create new \\n            if(valWithNode.find(parentVal)==valWithNode.end())\\n            {\\n                parent = new TreeNode(parentVal);\\n                valWithNode[parentVal]=parent;\\n            }\\n            else\\n                parent = valWithNode[parentVal];\\n            \\n            TreeNode* child;\\n            \\n            \\n            if(valWithNode.find(childVal)==valWithNode.end())\\n            {\\n                child = new TreeNode(childVal);\\n                valWithNode[childVal]=child;\\n            }\\n            else\\n                child = valWithNode[childVal];\\n\\n            contains.insert(parent);\\n            contains.insert(child);\\n\\n            \\n            childToParentMap[child] = parent;\\n\\n            if(isLeft)\\n            {\\n                parent->left = child;\\n            }\\n            else\\n            {\\n                parent->right = child;\\n            }\\n            \\n        }\\n        \\n        // interate all the nodes in contains set \\n        for(TreeNode* node : contains)\\n        {\\n            // if a node is not  present from child->parent map then the node is root \\n\\t\\t\\t// return it\\n            if(childToParentMap.find(node)==childToParentMap.end())\\n            {\\n                return node;\\n            }\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& desc)\\n    {\\n        // set contains all the nodes\\n        set<TreeNode*>contains;\\n        \\n        // map which contains child -> parent\\n        unordered_map<TreeNode*,TreeNode*>childToParentMap;\\n        \\n        //map which contains val->Node\\n        unordered_map<int,TreeNode*>valWithNode;\\n\\n        for(auto &xt : desc)\\n        {\\n            int parentVal = xt[0];\\n            int childVal = xt[1];\\n            int isLeft = xt[2];\\n            \\n            TreeNode* parent;\\n            \\n            // if the parent val is already present get that particular node no need to create new \\n            if(valWithNode.find(parentVal)==valWithNode.end())\\n            {\\n                parent = new TreeNode(parentVal);\\n                valWithNode[parentVal]=parent;\\n            }\\n            else\\n                parent = valWithNode[parentVal];\\n            \\n            TreeNode* child;\\n            \\n            \\n            if(valWithNode.find(childVal)==valWithNode.end())\\n            {\\n                child = new TreeNode(childVal);\\n                valWithNode[childVal]=child;\\n            }\\n            else\\n                child = valWithNode[childVal];\\n\\n            contains.insert(parent);\\n            contains.insert(child);\\n\\n            \\n            childToParentMap[child] = parent;\\n\\n            if(isLeft)\\n            {\\n                parent->left = child;\\n            }\\n            else\\n            {\\n                parent->right = child;\\n            }\\n            \\n        }\\n        \\n        // interate all the nodes in contains set \\n        for(TreeNode* node : contains)\\n        {\\n            // if a node is not  present from child->parent map then the node is root \\n\\t\\t\\t// return it\\n            if(childToParentMap.find(node)==childToParentMap.end())\\n            {\\n                return node;\\n            }\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833962,
                "title": "java-map-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer,TreeNode> map=new HashMap<>();\\n        HashSet<Integer> children=new HashSet<>();\\n        for(int[] info:descriptions)\\n        {\\n            int parent=info[0],child=info[1];\\n            boolean isLeft=info[2]==1?true:false;\\n            TreeNode parentNode=null;\\n            TreeNode childNode=null;\\n            if(map.containsKey(parent))\\n                parentNode=map.get(parent);\\n            else\\n                parentNode=new TreeNode(parent);\\n            if(map.containsKey(child))\\n                childNode=map.get(child);\\n            else\\n                childNode=new TreeNode(child);\\n            if(isLeft)\\n                parentNode.left=childNode;\\n            else\\n                parentNode.right=childNode;\\n            map.put(parent,parentNode);\\n            map.put(child,childNode);\\n            children.add(child);\\n            \\n        }\\n        TreeNode root=null;\\n        for(int info[]:descriptions)\\n        {\\n            if(!children.contains(info[0]))\\n            {\\n                root=map.get(info[0]);\\n                break;\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer,TreeNode> map=new HashMap<>();\\n        HashSet<Integer> children=new HashSet<>();\\n        for(int[] info:descriptions)\\n        {\\n            int parent=info[0],child=info[1];\\n            boolean isLeft=info[2]==1?true:false;\\n            TreeNode parentNode=null;\\n            TreeNode childNode=null;\\n            if(map.containsKey(parent))\\n                parentNode=map.get(parent);\\n            else\\n                parentNode=new TreeNode(parent);\\n            if(map.containsKey(child))\\n                childNode=map.get(child);\\n            else\\n                childNode=new TreeNode(child);\\n            if(isLeft)\\n                parentNode.left=childNode;\\n            else\\n                parentNode.right=childNode;\\n            map.put(parent,parentNode);\\n            map.put(child,childNode);\\n            children.add(child);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1966088,
                "title": "python-faster-then-100-solution",
                "content": "```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        \\n        tree = dict()\\n        children = set()\\n        for parent, child, isLeft in descriptions:\\n            if parent not in tree : tree[parent] = TreeNode(parent)\\n            if child not in tree : tree[child] = TreeNode(child)\\n            \\n            if isLeft : tree[parent].left = tree[child]\\n            else : tree[parent].right = tree[child]\\n        \\n            children.add(child)\\n        \\n        for parent in tree:\\n            if parent not in children:\\n                return tree[parent]\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        \\n        tree = dict()\\n        children = set()\\n        for parent, child, isLeft in descriptions:\\n            if parent not in tree : tree[parent] = TreeNode(parent)\\n            if child not in tree : tree[child] = TreeNode(child)\\n            \\n            if isLeft : tree[parent].left = tree[child]\\n            else : tree[parent].right = tree[child]\\n        \\n            children.add(child)\\n        \\n        for parent in tree:\\n            if parent not in children:\\n                return tree[parent]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891563,
                "title": "easy-c-code-using-map-runtime-281-ms",
                "content": "# Approach\\n**Step 1:-** Take a map data Structure that will store the address of each of the nodes formed with their values.\\n\\n**Step 2:-** Iterate over the given 2D matrix(edgeRelationArray) and see if the parentNode is present in the map or not. \\n\\n- If the parentNode is present in the map then there is no need of making a new node, Just store the address of the parentNode in a variable. \\n- If the parentNode is not present in the map then form a parentNode of the given value and store its address in the map. (Because this parentNode can be the childNode of some other Node). \\n\\n**Step 3:-** Repeat Step 2 for child Node also i.e.,\\n\\n- If the childNode is present in the map then there is no need of making a new node, Just store the address of the childNode in a variable.\\n- If the childNode is not present in the map then form a childNode of the given value and store its address in the map(Because this childNode can be the parentNode of some other Node). \\n\\n**Step 4:-** Form the relation between the parentNode and the childNode for each iteration depending on the value of the third value of the array of each iteration. i.e.,\\n\\n- If the third value of the array in the given iteration is 1 then it means that the childNode is the left child of the parentNode formed for the given iteration.\\n- If the third value of the array in the given iteration is 0 then it means that the childNode is the left child of the parentNode formed for the given iteration.\\n\\nNow here comes a little thinking. We have all the addresses of every node in the map. But How to determine the parentNode. \\n\\nWe can use the concept of the Tree itself. If carefully observed we know that the root node is the only node that has no Parent.\\n\\n**Step 5:-** So we can store all the values of the childNode that is present in the given 2D matrix (edgeRelationArray) in a data structure (let\\'s assume a map data structure).\\n\\n**Step 6:-** Again iterate the 2D matrix (edgeRelationArray) to check which parentNode value is not present in the map dataStructure formed in step 5).\\n\\n# Complexity\\n- Time complexity:O(N) where N is the number of rows present in the 2D matrix\\n\\n- Space complexity: O(M) where M is the number of nodes present in the Tree (We are storing the nodes values along with its address in the map). \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n    map<int, TreeNode*> mp;\\n    for (auto it : descriptions) {\\n      TreeNode* parentNode, * childNode;\\n\\n      // Finding the parent Node\\n      if (mp.find(it[0]) != mp.end()) {\\n        parentNode = mp[it[0]];\\n      }\\n      else {\\n        parentNode = new TreeNode(it[0]);\\n        mp[it[0]] = parentNode;\\n      }\\n\\n      // Finding the child Node\\n      if (mp.find(it[1]) != mp.end()) {\\n        childNode = mp[it[1]];\\n      }\\n      else {\\n        childNode = new TreeNode(it[1]);\\n        mp[it[1]] = childNode;\\n      }\\n\\n      // Making the Edge Between parent and child Node\\n      if (it[2] == 1) {\\n        parentNode->left = childNode;\\n      }\\n      else {\\n        parentNode->right = childNode;\\n      }\\n    }\\n\\n    // Store the childNode \\n    map<int, int> storeChild;\\n    for (auto it : descriptions) {\\n      storeChild[it[1]] = 1;\\n    }\\n    // Find the root of the Tree\\n    TreeNode* root;\\n    for (auto it : descriptions) {\\n      if (storeChild.find(it[0]) == storeChild.end()) {\\n        root = mp[it[0]];\\n      }\\n    }\\n    return root;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n    map<int, TreeNode*> mp;\\n    for (auto it : descriptions) {\\n      TreeNode* parentNode, * childNode;\\n\\n      // Finding the parent Node\\n      if (mp.find(it[0]) != mp.end()) {\\n        parentNode = mp[it[0]];\\n      }\\n      else {\\n        parentNode = new TreeNode(it[0]);\\n        mp[it[0]] = parentNode;\\n      }\\n\\n      // Finding the child Node\\n      if (mp.find(it[1]) != mp.end()) {\\n        childNode = mp[it[1]];\\n      }\\n      else {\\n        childNode = new TreeNode(it[1]);\\n        mp[it[1]] = childNode;\\n      }\\n\\n      // Making the Edge Between parent and child Node\\n      if (it[2] == 1) {\\n        parentNode->left = childNode;\\n      }\\n      else {\\n        parentNode->right = childNode;\\n      }\\n    }\\n\\n    // Store the childNode \\n    map<int, int> storeChild;\\n    for (auto it : descriptions) {\\n      storeChild[it[1]] = 1;\\n    }\\n    // Find the root of the Tree\\n    TreeNode* root;\\n    for (auto it : descriptions) {\\n      if (storeChild.find(it[0]) == storeChild.end()) {\\n        root = mp[it[0]];\\n      }\\n    }\\n    return root;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823941,
                "title": "java-map",
                "content": "```\\n\\nclass Solution {\\n     \\n    public TreeNode createBinaryTree(int[][] desc) {\\n        Map<Integer,TreeNode> map = new HashMap<>();\\n        Map<Integer,Boolean> children = new HashMap<>();\\n        TreeNode pp =  null;\\n        for(int i=0;i<desc.length;i++){\\n            int p = desc[i][0];\\n            int c =  desc[i][1];\\n            int isleft =  desc[i][2];\\n            children.put( c,true );\\n            TreeNode parent =  map.getOrDefault( p , new TreeNode(p) );\\n            TreeNode child =  map.getOrDefault( c , new TreeNode(c) );                         \\n            \\n            if(isleft==1){\\n                parent.left =  child;\\n            }\\n            else{\\n                parent.right =  child;\\n            }                  \\n            map.put(p , parent  );\\n            map.put(c , child  );\\n        }\\n        \\n        // just figure out  , the node which is not in children of any node, so it should not present in map\\n\\t\\t\\n        \\n        int idx=0;\\n        for(int i=0;i<desc.length;i++){\\n            int p = desc[i][0];\\n            if(!children.containsKey( p ) ){\\n                idx =  p;\\n                break;\\n            }\\n            \\n        }\\n        \\n        return map.get(idx);\\n        \\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n     \\n    public TreeNode createBinaryTree(int[][] desc) {\\n        Map<Integer,TreeNode> map = new HashMap<>();\\n        Map<Integer,Boolean> children = new HashMap<>();\\n        TreeNode pp =  null;\\n        for(int i=0;i<desc.length;i++){\\n            int p = desc[i][0];\\n            int c =  desc[i][1];\\n            int isleft =  desc[i][2];\\n            children.put( c,true );\\n            TreeNode parent =  map.getOrDefault( p , new TreeNode(p) );\\n            TreeNode child =  map.getOrDefault( c , new TreeNode(c) );                         \\n            \\n            if(isleft==1){\\n                parent.left =  child;\\n            }\\n            else{\\n                parent.right =  child;\\n            }                  \\n            map.put(p , parent  );\\n            map.put(c , child  );\\n        }\\n        \\n        // just figure out  , the node which is not in children of any node, so it should not present in map\\n\\t\\t\\n        \\n        int idx=0;\\n        for(int i=0;i<desc.length;i++){\\n            int p = desc[i][0];\\n            if(!children.containsKey( p ) ){\\n                idx =  p;\\n                break;\\n            }\\n            \\n        }\\n        \\n        return map.get(idx);\\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823678,
                "title": "python-solution-using-hashmap-with-steps",
                "content": "Here we use a HashMap to keep track of node values and their references along with the fact if that node has a parent or not. We develop the Binary Tree as we go along. Finally we check which node has no parent as that node is the root node.\\n1. Maintain a hash map with the keys being node values and value being a list of its `REFERENCE` and a `HAS_PARENT` property which tells weather or not it has a parent or not (Represented by True if it has False if not)\\n2. Traverse through the descriptions list.\\n3. For every new node value found, add a new TreeNode into the list with its `HAS_PARENT` property being False.\\n4. Now make the child node parents left/right child and update the `HAS_PARENT` property of child value in map to True.\\n5. Now once the Binary Tree is made we traverse through the hash map to check which node still has no parent. This node is out root node.\\n6. Return the root node.\\n```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        root = None\\n        table = {}\\n        for arr in descriptions:\\n            parent = arr[0]\\n            child = arr[1]\\n            isleft = arr[2]\\n            if table.get(parent, None) is None: # If key parent does not exist in table\\n                table[parent] = [TreeNode(parent), False]\\n            if table.get(child, None) is None: If key child does not exist in table\\n                table[child] = [TreeNode(child), False]\\n            table[child][1] = True # Since child is going to have a parent in the current iteration, set its has parent property to True\\n            if isleft == 1:\\n                table[parent][0].left = table[child][0]\\n            else:\\n                table[parent][0].right = table[child][0]\\n\\t\\t# Now traverse the hashtable and check which node still has no parent\\n        for k, v in table.items():\\n            if not v[1]: # Has parent is False, so root is found.\\n                root = k\\n\\t\\t\\t\\tbreak\\n        return table[root][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        root = None\\n        table = {}\\n        for arr in descriptions:\\n            parent = arr[0]\\n            child = arr[1]\\n            isleft = arr[2]\\n            if table.get(parent, None) is None: # If key parent does not exist in table\\n                table[parent] = [TreeNode(parent), False]\\n            if table.get(child, None) is None: If key child does not exist in table\\n                table[child] = [TreeNode(child), False]\\n            table[child][1] = True # Since child is going to have a parent in the current iteration, set its has parent property to True\\n            if isleft == 1:\\n                table[parent][0].left = table[child][0]\\n            else:\\n                table[parent][0].right = table[child][0]\\n\\t\\t# Now traverse the hashtable and check which node still has no parent\\n        for k, v in table.items():\\n            if not v[1]: # Has parent is False, so root is found.\\n                root = k\\n\\t\\t\\t\\tbreak\\n        return table[root][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282585,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind root whose indeg=0\\nfrom root build tree recursively \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)(Creating maps)+O(n) (finding root) +O(n) (building tree)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)+O(n) (2 Maps)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* helper(unordered_map<int,pair<int,int>>& mp, int value){\\n        if(mp.count(value)==0){\\n            TreeNode* root=new TreeNode(value);\\n            return root;\\n        }\\n        TreeNode* root=new TreeNode(value);\\n        if(mp[value].first!=-1) root->left=helper(mp,mp[value].first);\\n        if(mp[value].second!=-1) root->right=helper(mp,mp[value].second);\\n\\n        return root;\\n    }\\n\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,int> parent;\\n        unordered_map<int,pair<int,int>> mp;\\n\\n        for(int i=0;i<descriptions.size();i++){\\n            parent[descriptions[i][1]]=descriptions[i][0];\\n\\n            if(mp.count(descriptions[i][0])==0) mp[descriptions[i][0]]={-1,-1};\\n\\n            if(descriptions[i][2]==1){\\n                mp[descriptions[i][0]].first=descriptions[i][1];\\n            }\\n            else{\\n                mp[descriptions[i][0]].second=descriptions[i][1];\\n            }\\n        }\\n        int root=0;\\n        for(auto i : parent){\\n            if(parent.count(i.second)==0){\\n                root=i.second;\\n                break;\\n            }\\n        }\\n\\n        return helper(mp,root);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* helper(unordered_map<int,pair<int,int>>& mp, int value){\\n        if(mp.count(value)==0){\\n            TreeNode* root=new TreeNode(value);\\n            return root;\\n        }\\n        TreeNode* root=new TreeNode(value);\\n        if(mp[value].first!=-1) root->left=helper(mp,mp[value].first);\\n        if(mp[value].second!=-1) root->right=helper(mp,mp[value].second);\\n\\n        return root;\\n    }\\n\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,int> parent;\\n        unordered_map<int,pair<int,int>> mp;\\n\\n        for(int i=0;i<descriptions.size();i++){\\n            parent[descriptions[i][1]]=descriptions[i][0];\\n\\n            if(mp.count(descriptions[i][0])==0) mp[descriptions[i][0]]={-1,-1};\\n\\n            if(descriptions[i][2]==1){\\n                mp[descriptions[i][0]].first=descriptions[i][1];\\n            }\\n            else{\\n                mp[descriptions[i][0]].second=descriptions[i][1];\\n            }\\n        }\\n        int root=0;\\n        for(auto i : parent){\\n            if(parent.count(i.second)==0){\\n                root=i.second;\\n                break;\\n            }\\n        }\\n\\n        return helper(mp,root);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827610,
                "title": "easy-to-understand-unordered-map-c",
                "content": "```\\nBasic idea is we are checking if the parent is present in the map if it is present then we\\'ll simply use it if it is not present then we will make the parent node and the same we will do for the child.\\nAnd we will be adding the newly created nodes in are map.\\nI\\'m also using two maps the one map is holding the nodes to every parent  and the other map is holding the nodes of the childs, now I\\'m traversing the parent node and if the parent node is not present in the child map then I\\'ll simply return it as the root.\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        int n=descriptions.size();\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_set<TreeNode*>p , c;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            TreeNode *parent;\\n            \\n            if(mp.find(descriptions[i][0])!=mp.end())\\n            {\\n                parent = mp[descriptions[i][0]];\\n                \\n            }\\n            else{\\n                parent = new TreeNode(descriptions[i][0]);\\n            }\\n            TreeNode *child;\\n            if(mp.find(descriptions[i][1])!=mp.end())\\n            {\\n                child = mp[descriptions[i][1]];\\n            }\\n            else{\\n                child = new TreeNode(descriptions[i][1]);\\n            }\\n            if(descriptions[i][2]==1)parent->left = child;\\n            else parent->right  = child;\\n            mp.insert({parent->val,parent});\\n            mp.insert({child->val,child});\\n            p.insert(parent);\\n            c.insert(child);\\n            \\n        }\\n        for(auto x:p)\\n        {\\n            if(c.find(x)==c.end())return x;\\n        }\\n       \\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nBasic idea is we are checking if the parent is present in the map if it is present then we\\'ll simply use it if it is not present then we will make the parent node and the same we will do for the child.\\nAnd we will be adding the newly created nodes in are map.\\nI\\'m also using two maps the one map is holding the nodes to every parent  and the other map is holding the nodes of the childs, now I\\'m traversing the parent node and if the parent node is not present in the child map then I\\'ll simply return it as the root.\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        int n=descriptions.size();\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_set<TreeNode*>p , c;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            TreeNode *parent;\\n            \\n            if(mp.find(descriptions[i][0])!=mp.end())\\n            {\\n                parent = mp[descriptions[i][0]];\\n                \\n            }\\n            else{\\n                parent = new TreeNode(descriptions[i][0]);\\n            }\\n            TreeNode *child;\\n            if(mp.find(descriptions[i][1])!=mp.end())\\n            {\\n                child = mp[descriptions[i][1]];\\n            }\\n            else{\\n                child = new TreeNode(descriptions[i][1]);\\n            }\\n            if(descriptions[i][2]==1)parent->left = child;\\n            else parent->right  = child;\\n            mp.insert({parent->val,parent});\\n            mp.insert({child->val,child});\\n            p.insert(parent);\\n            c.insert(child);\\n            \\n        }\\n        for(auto x:p)\\n        {\\n            if(c.find(x)==c.end())return x;\\n        }\\n       \\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825222,
                "title": "c-hashmap",
                "content": "**Solution:** \\n\\nHere, we are using **mp**(hashmap to build tree) to create a new nodes for the corresponding values, and initially wer are marking all nodes are parent(i.e. While assigning nodes to their parent we will marked them as a child). **mp1**(hashmap) will keep track on root node.\\n\\n* **In 1st step, we are creating a node for each corresponding value(parent and child)** and at the same time we are marking them as a parent.\\n* **In 2nd step, we are connecting all child nodes to their parent node based on the left value**(if left==1 then child node goes to left, if left==0 then child goes to right of parent), **and at the same time we are marking child node as a false(i.e. mp1[v]=false it will indicates that , current node is child, where v is the left/right child of parent node).**\\n* In 3rd step, we will itarate to the **mp1 hahsmap**, it will gives us root node ( **the node whose value is true, is the root of tree**).\\n            \\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        unordered_map<int,TreeNode*>mp;                   // hashmap to build tree\\n        unordered_map<int,int>mp1;                       // hashmap  to keep track on root of tree\\n        // Step: 1\\n\\t\\tfor(auto it:descriptions)\\n        {\\n            int u=it[0];\\n            int v=it[1];\\n            mp1[u]=true;                                // Initially marked every node as a parent\\n            mp1[v]=true;\\n            mp[u]=new TreeNode(u);                     // Creating nodes for corresponding value\\n            mp[v]=new TreeNode(v);\\n        }\\n\\t\\t\\n\\t\\t// Step: 2\\n        for(auto it:descriptions)\\n        {\\n            int u=it[0];\\n            int v=it[1];\\n            int isLeft=it[2];                   //  check parent have left child or not\\n            if(isLeft==1)                     \\n            {\\n\\t\\t\\t     // if left==1 , then assign child to the left of parent, just by giving reference of child  and marked this child node \"false\", \\n\\t\\t\\t\\t // it will indicate that this node is not root, because root node don\\'t have parent\\n                mp[u]->left=mp[v];           \\n                mp1[v]=false;\\n            }\\n            else\\n            {\\n\\t\\t\\t   //  else assign child to the right of parent , and marked this child node \"false\", \\n\\t\\t\\t   // it will indicate that this node is not root, because root node don\\'t have parent\\n                mp[u]->right=mp[v];\\n                mp1[v]=false;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Step: 3\\n\\t\\t// Iterate over the mp1(hashmap) to find the root of tree\\n        TreeNode* root=NULL;\\n        for(auto it:mp1)\\n        {\\n\\t\\t    // if node is true(root of a tree) then return it, \\n            if(it.second==true)\\n            {\\n                root=mp[it.first];\\n                break;\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```\\n\\n*If you like it, then please upvote it!!*",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        unordered_map<int,TreeNode*>mp;                   // hashmap to build tree\\n        unordered_map<int,int>mp1;                       // hashmap  to keep track on root of tree\\n        // Step: 1\\n\\t\\tfor(auto it:descriptions)\\n        {\\n            int u=it[0];\\n            int v=it[1];\\n            mp1[u]=true;                                // Initially marked every node as a parent\\n            mp1[v]=true;\\n            mp[u]=new TreeNode(u);                     // Creating nodes for corresponding value\\n            mp[v]=new TreeNode(v);\\n        }\\n\\t\\t\\n\\t\\t// Step: 2\\n        for(auto it:descriptions)\\n        {\\n            int u=it[0];\\n            int v=it[1];\\n            int isLeft=it[2];                   //  check parent have left child or not\\n            if(isLeft==1)                     \\n            {\\n\\t\\t\\t     // if left==1 , then assign child to the left of parent, just by giving reference of child  and marked this child node \"false\", \\n\\t\\t\\t\\t // it will indicate that this node is not root, because root node don\\'t have parent\\n                mp[u]->left=mp[v];           \\n                mp1[v]=false;\\n            }\\n            else\\n            {\\n\\t\\t\\t   //  else assign child to the right of parent , and marked this child node \"false\", \\n\\t\\t\\t   // it will indicate that this node is not root, because root node don\\'t have parent\\n                mp[u]->right=mp[v];\\n                mp1[v]=false;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Step: 3\\n\\t\\t// Iterate over the mp1(hashmap) to find the root of tree\\n        TreeNode* root=NULL;\\n        for(auto it:mp1)\\n        {\\n\\t\\t    // if node is true(root of a tree) then return it, \\n            if(it.second==true)\\n            {\\n                root=mp[it.first];\\n                break;\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1823731,
                "title": "map",
                "content": "Somehow I got TLE during the contest. Probably a glitch - the implementation is O(n). AC second time.\\n\\n**C++**\\n```cpp\\nTreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n    unordered_map<int, TreeNode*> m;\\n    unordered_set<int> children;\\n    for (auto &d: descriptions) {\\n        children.insert(d[1]);\\n        auto it_p = m.find(d[0]), it_c = m.find(d[1]);\\n        if (it_p == end(m))\\n            it_p = m.insert({d[0], new TreeNode(d[0]) }).first;\\n        if (it_c == end(m))\\n            it_c = m.insert({d[1], new TreeNode(d[1]) }).first;\\n        if (d[2])\\n            it_p->second->left = it_c->second;\\n        else\\n            it_p->second->right = it_c->second;\\n    }\\n    for (auto &p : m)\\n        if (children.find(p.first) == end(children))\\n            return p.second;\\n    return nullptr;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nTreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n    unordered_map<int, TreeNode*> m;\\n    unordered_set<int> children;\\n    for (auto &d: descriptions) {\\n        children.insert(d[1]);\\n        auto it_p = m.find(d[0]), it_c = m.find(d[1]);\\n        if (it_p == end(m))\\n            it_p = m.insert({d[0], new TreeNode(d[0]) }).first;\\n        if (it_c == end(m))\\n            it_c = m.insert({d[1], new TreeNode(d[1]) }).first;\\n        if (d[2])\\n            it_p->second->left = it_c->second;\\n        else\\n            it_p->second->right = it_c->second;\\n    }\\n    for (auto &p : m)\\n        if (children.find(p.first) == end(children))\\n            return p.second;\\n    return nullptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823726,
                "title": "python-dictonary-recursion",
                "content": "create a tree dict to store all the child node\\ncreate a dict to find the parent node\\n\\nuse recursion to form the tree. \\n\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        tree = {}\\n        dp = {}\\n        for p,c,_ in descriptions:\\n            tree[p] = [None, None]\\n            \\n            dp[p] = True\\n            \\n            dp[c] = True\\n        for p,c,l in descriptions:\\n            dp[c] = False\\n            if l:\\n                tree[p][0] = c\\n            else:\\n                tree[p][1] = c\\n        pa = None\\n        for k,v in dp.items():\\n            if v:\\n                pa = k\\n     \\n        def create(parent):\\n            if not parent:\\n                return\\n            if parent not in tree:\\n                return TreeNode(parent)\\n            temp = TreeNode(parent)\\n            if tree[parent][0]:\\n                temp.left = create(tree[parent][0])\\n            if tree[parent][1]:\\n                temp.right = create(tree[parent][1])\\n            return temp\\n        \\n        return create(pa)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        tree = {}\\n        dp = {}\\n        for p,c,_ in descriptions:\\n            tree[p] = [None, None]\\n            \\n            dp[p] = True\\n            \\n            dp[c] = True\\n        for p,c,l in descriptions:\\n            dp[c] = False\\n            if l:\\n                tree[p][0] = c\\n            else:\\n                tree[p][1] = c\\n        pa = None\\n        for k,v in dp.items():\\n            if v:\\n                pa = k\\n     \\n        def create(parent):\\n            if not parent:\\n                return\\n            if parent not in tree:\\n                return TreeNode(parent)\\n            temp = TreeNode(parent)\\n            if tree[parent][0]:\\n                temp.left = create(tree[parent][0])\\n            if tree[parent][1]:\\n                temp.right = create(tree[parent][1])\\n            return temp\\n        \\n        return create(pa)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039756,
                "title": "an-elegant-approach-deeply-explained",
                "content": "# Intuition\\nBuild the tree in pieces with each description given. Construct the tree two nodes at a time and connect them accordingly based on the descriptions provided while also storing every child element that we come across. Run a loop on the description and check for each parent element, if it has been a child element at some point, it cannot be the root. Return the parent element that has never been a child.\\n\\n# Approach\\nCreate a map that takes ```int``` as key and ```TreeNode*``` as value. For every description, call the helper function. Check if the parent and the child already exist in the map. Now we have four conditions to check:\\n1. If the parent exists and the child does too, connect the child root to the parent root based on the direction specified.\\n2. If the parent exists but the child does not, create a new node for the child and connect it to the parent root based on direction specified.\\n3. If the parent does not exists but the child does, create a new node for parent and connect the child node to it based on the direction specified.\\n4. If the parent and child both do not exist, create a node for both and join them based on the direction specified.\\n\\nAfter every iteration, store the child element in a set to keep track of all the children. Whichever parent in the ```description``` array does not exist in the child set is the root of the tree.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, TreeNode*> mp;\\n    unordered_set<int> s;\\n\\n    void helper(vector<int> v) {\\n        if (mp.find(v[0]) != mp.end()) {\\n            if (mp.find(v[1]) != mp.end()) {\\n                if (v[2] == 1)\\n                    mp[v[0]]->left = mp[v[1]];\\n                else \\n                    mp[v[0]]->right = mp[v[1]];\\n            }\\n            else {\\n                if (v[2] == 1) {\\n                    mp[v[0]]->left = new TreeNode(v[1]);\\n                    mp[v[1]] = mp[v[0]]->left;\\n                }\\n                else {\\n                    mp[v[0]]->right = new TreeNode(v[1]);\\n                    mp[v[1]] = mp[v[0]]->right;\\n                }\\n            }\\n        }\\n        else {\\n            TreeNode* temp = new TreeNode(v[0]);\\n            if (mp.find(v[1]) != mp.end()) {\\n                if (v[2] == 1)\\n                    temp->left = mp[v[1]];\\n                else \\n                    temp->right = mp[v[1]];\\n            }\\n            else {\\n                if (v[2] == 1) {\\n                    temp->left = new TreeNode(v[1]);\\n                    mp[v[1]] = temp->left;\\n                }\\n                else {\\n                    temp->right = new TreeNode(v[1]);\\n                    mp[v[1]] = temp->right;\\n                }\\n            }\\n            mp[v[0]] = temp;\\n        }\\n\\n        s.insert(v[1]);\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        for (auto& pr : d) {\\n            helper(pr);\\n        }\\n\\n        int ans;\\n        for (auto& pr : d) {\\n            if (s.find(pr[0]) == s.end()) {\\n                ans = pr[0];\\n                break;\\n            }\\n        }\\n\\n        return mp[ans];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```int```\n```TreeNode*```\n```description```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, TreeNode*> mp;\\n    unordered_set<int> s;\\n\\n    void helper(vector<int> v) {\\n        if (mp.find(v[0]) != mp.end()) {\\n            if (mp.find(v[1]) != mp.end()) {\\n                if (v[2] == 1)\\n                    mp[v[0]]->left = mp[v[1]];\\n                else \\n                    mp[v[0]]->right = mp[v[1]];\\n            }\\n            else {\\n                if (v[2] == 1) {\\n                    mp[v[0]]->left = new TreeNode(v[1]);\\n                    mp[v[1]] = mp[v[0]]->left;\\n                }\\n                else {\\n                    mp[v[0]]->right = new TreeNode(v[1]);\\n                    mp[v[1]] = mp[v[0]]->right;\\n                }\\n            }\\n        }\\n        else {\\n            TreeNode* temp = new TreeNode(v[0]);\\n            if (mp.find(v[1]) != mp.end()) {\\n                if (v[2] == 1)\\n                    temp->left = mp[v[1]];\\n                else \\n                    temp->right = mp[v[1]];\\n            }\\n            else {\\n                if (v[2] == 1) {\\n                    temp->left = new TreeNode(v[1]);\\n                    mp[v[1]] = temp->left;\\n                }\\n                else {\\n                    temp->right = new TreeNode(v[1]);\\n                    mp[v[1]] = temp->right;\\n                }\\n            }\\n            mp[v[0]] = temp;\\n        }\\n\\n        s.insert(v[1]);\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        for (auto& pr : d) {\\n            helper(pr);\\n        }\\n\\n        int ans;\\n        for (auto& pr : d) {\\n            if (s.find(pr[0]) == s.end()) {\\n                ans = pr[0];\\n                break;\\n            }\\n        }\\n\\n        return mp[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897006,
                "title": "c-map-o-n-time",
                "content": "```\\nclass Solution {\\npublic:  \\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode*> map;\\n        unordered_map<int,int> children;\\n        for(int i = 0 ; i < descriptions.size() ;i++){\\n            int parent = descriptions[i][0];\\n            int child = descriptions[i][1];\\n            TreeNode* p=NULL;\\n            TreeNode*c = NULL;\\n            if(map[parent]==0){\\n                p = new TreeNode(parent);\\n                map[parent] = p;\\n            }\\n            else{\\n                p = map[parent];\\n            }\\n            \\n            \\n            if(map[child]==0){\\n                c = new TreeNode(child);\\n                map[child] = c;\\n                children[child]=1;\\n            }\\n            else{\\n                c=map[child];\\n                children[child]=1;\\n            }\\n            \\n            if(descriptions[i][2]==0){\\n                p->right = c;\\n            }\\n            else{\\n                p->left = c;\\n            }\\n        }\\n        for(int i =0 ; i < descriptions.size() ;i++){\\n            if(children[descriptions[i][0]]==0){\\n                return map[descriptions[i][0]];\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode*> map;\\n        unordered_map<int,int> children;\\n        for(int i = 0 ; i < descriptions.size() ;i++){\\n            int parent = descriptions[i][0];\\n            int child = descriptions[i][1];\\n            TreeNode* p=NULL;\\n            TreeNode*c = NULL;\\n            if(map[parent]==0){\\n                p = new TreeNode(parent);\\n                map[parent] = p;\\n            }\\n            else{\\n                p = map[parent];\\n            }\\n            \\n            \\n            if(map[child]==0){\\n                c = new TreeNode(child);\\n                map[child] = c;\\n                children[child]=1;\\n            }\\n            else{\\n                c=map[child];\\n                children[child]=1;\\n            }\\n            \\n            if(descriptions[i][2]==0){\\n                p->right = c;\\n            }\\n            else{\\n                p->left = c;\\n            }\\n        }\\n        for(int i =0 ; i < descriptions.size() ;i++){\\n            if(children[descriptions[i][0]]==0){\\n                return map[descriptions[i][0]];\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835831,
                "title": "javascript-simple-hash-map-o-n-time-and-space",
                "content": "**The idea behind the solution is to use a hash map to store our Nodes, then according to the \\'descriptions\\' input array, connect the child to the parent. We are using a second hash map (rootHash) to find the root node.**\\n\\n**In order to find the root node, we are marking every parent node as \\'true\\' initially, if a node appears as a child, we mark it as false. Then we traverse through our map (rootHash) and check which node is marked true. There will only be 1 node marked \\'true\\' and that will be our \\'Root Node\\'**\\n\\n**Time Complexity : O(N)\\nSpace Complexity : O(N)**\\n\\nEnjoy!!\\n\\n*Without Comments*\\n```\\nvar createBinaryTree = function (descriptions) {\\n  let hash = {};\\n  let rootHash = {};\\n  for (let i = 0; i < descriptions.length; i++) {\\n    if (!(descriptions[i][0] in hash)) hash[descriptions[i][0]] = new TreeNode(descriptions[i][0]);\\n    if (!(descriptions[i][1] in hash)) hash[descriptions[i][1]] = new TreeNode(descriptions[i][1]);\\n    if (descriptions[i][2] == 1) hash[descriptions[i][0]].left = hash[descriptions[i][1]];\\n    else hash[descriptions[i][0]].right = hash[descriptions[i][1]];\\n    if (!(descriptions[i][0] in rootHash)) rootHash[descriptions[i][0]] = true;\\n    if (!(descriptions[i][1] in rootHash)) rootHash[descriptions[i][1]] = false;\\n    rootHash[descriptions[i][1]] = false;\\n  }\\n  for (let key in rootHash) {\\n    if (rootHash[key] == true) return hash[key];\\n  }\\n};\\n```\\n\\n\\n*With Comments*\\n```\\nvar createBinaryTree = function (descriptions) {\\n  let hash = {}; // to store all nodes\\n  let rootHash = {}; // to find the root node\\n  for (let i = 0; i < descriptions.length; i++) {\\n    // initialize parent node\\n    if (!(descriptions[i][0] in hash)) {\\n      hash[descriptions[i][0]] = new TreeNode(descriptions[i][0]);\\n    }\\n    // initialize child node\\n    if (!(descriptions[i][1] in hash)) {\\n      hash[descriptions[i][1]] = new TreeNode(descriptions[i][1]);\\n    }\\n    // connect child to parent\\n    if (descriptions[i][2] == 1) { // left child\\n      hash[descriptions[i][0]].left = hash[descriptions[i][1]];\\n    } else { // right child\\n      hash[descriptions[i][0]].right = hash[descriptions[i][1]];\\n    }\\n    // keep track of parent and child node\\n    // mark true if parent, mark false if children\\n    if (!(descriptions[i][0] in rootHash)) rootHash[descriptions[i][0]] = true;\\n    if (!(descriptions[i][1] in rootHash)) rootHash[descriptions[i][1]] = false;\\n    rootHash[descriptions[i][1]] = false;\\n  }\\n  // only node which hasn\\'t been marked false is the root node\\n  for (let key in rootHash) {\\n    if (rootHash[key] == true) return hash[key];\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nvar createBinaryTree = function (descriptions) {\\n  let hash = {};\\n  let rootHash = {};\\n  for (let i = 0; i < descriptions.length; i++) {\\n    if (!(descriptions[i][0] in hash)) hash[descriptions[i][0]] = new TreeNode(descriptions[i][0]);\\n    if (!(descriptions[i][1] in hash)) hash[descriptions[i][1]] = new TreeNode(descriptions[i][1]);\\n    if (descriptions[i][2] == 1) hash[descriptions[i][0]].left = hash[descriptions[i][1]];\\n    else hash[descriptions[i][0]].right = hash[descriptions[i][1]];\\n    if (!(descriptions[i][0] in rootHash)) rootHash[descriptions[i][0]] = true;\\n    if (!(descriptions[i][1] in rootHash)) rootHash[descriptions[i][1]] = false;\\n    rootHash[descriptions[i][1]] = false;\\n  }\\n  for (let key in rootHash) {\\n    if (rootHash[key] == true) return hash[key];\\n  }\\n};\\n```\n```\\nvar createBinaryTree = function (descriptions) {\\n  let hash = {}; // to store all nodes\\n  let rootHash = {}; // to find the root node\\n  for (let i = 0; i < descriptions.length; i++) {\\n    // initialize parent node\\n    if (!(descriptions[i][0] in hash)) {\\n      hash[descriptions[i][0]] = new TreeNode(descriptions[i][0]);\\n    }\\n    // initialize child node\\n    if (!(descriptions[i][1] in hash)) {\\n      hash[descriptions[i][1]] = new TreeNode(descriptions[i][1]);\\n    }\\n    // connect child to parent\\n    if (descriptions[i][2] == 1) { // left child\\n      hash[descriptions[i][0]].left = hash[descriptions[i][1]];\\n    } else { // right child\\n      hash[descriptions[i][0]].right = hash[descriptions[i][1]];\\n    }\\n    // keep track of parent and child node\\n    // mark true if parent, mark false if children\\n    if (!(descriptions[i][0] in rootHash)) rootHash[descriptions[i][0]] = true;\\n    if (!(descriptions[i][1] in rootHash)) rootHash[descriptions[i][1]] = false;\\n    rootHash[descriptions[i][1]] = false;\\n  }\\n  // only node which hasn\\'t been marked false is the root node\\n  for (let key in rootHash) {\\n    if (rootHash[key] == true) return hash[key];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824124,
                "title": "javascript-map-set",
                "content": "**Solution: Map & Set**\\n\\nUse a map \\'nodes\\' to store the references to the tree nodes.\\nUse a set \\'children\\' to store the values of all children nodes. \\n  This is used to find the root, the root node is the only node that does not exist in the set.\\n\\nTime Complexity: O(n) 510ms\\nSpace Complexity: O(n) 88.8MB\\n```\\nvar createBinaryTree = function(descriptions) {\\n  let nodes = new Map(), children = new Set();\\n  for (let [parent, child, isLeft] of descriptions) {\\n    let parentNode = nodes.get(parent) || new TreeNode(parent);\\n    if (!nodes.has(parent)) nodes.set(parent, parentNode);\\n    \\n    let childNode = nodes.get(child) || new TreeNode(child);\\n    if (!nodes.has(child)) nodes.set(child, childNode);\\n    \\n    if (isLeft) parentNode.left = childNode;\\n    else parentNode.right = childNode;\\n    \\n    children.add(child);\\n  }\\n\\n  for (let [parent, child, isLeft] of descriptions) {\\n    // a node with no parent is the root\\n    if (!children.has(parent)) return nodes.get(parent);\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createBinaryTree = function(descriptions) {\\n  let nodes = new Map(), children = new Set();\\n  for (let [parent, child, isLeft] of descriptions) {\\n    let parentNode = nodes.get(parent) || new TreeNode(parent);\\n    if (!nodes.has(parent)) nodes.set(parent, parentNode);\\n    \\n    let childNode = nodes.get(child) || new TreeNode(child);\\n    if (!nodes.has(child)) nodes.set(child, childNode);\\n    \\n    if (isLeft) parentNode.left = childNode;\\n    else parentNode.right = childNode;\\n    \\n    children.add(child);\\n  }\\n\\n  for (let [parent, child, isLeft] of descriptions) {\\n    // a node with no parent is the root\\n    if (!children.has(parent)) return nodes.get(parent);\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823883,
                "title": "java-easy-solution-o-n-hashmap",
                "content": "1. Create parent and child nodes and link them using given description. Also put the parent and child nodes in the map so that it can be used later on whenever same parent or child value is coming in another description.\\n\\n2. To find the root of the tree we need to keep track of all the child node values. For that we can use a set to keep all child node values. Any node value which is not there in this set must be root as only root will not be a child of any node.\\n\\n```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        Set<Integer> childs = new HashSet<>();\\n        int n = descriptions.length;\\n        for (int i = 0; i < n; ++i) {\\n            int parent = descriptions[i][0];\\n            int child = descriptions[i][1];\\n            \\n            TreeNode parentNode = map.get(parent);\\n            if (parentNode == null) {\\n                parentNode = new TreeNode(parent);\\n                map.put(parent, parentNode);\\n            }\\n            \\n            TreeNode childNode = map.get(child);\\n            if (childNode == null) {\\n                childNode = new TreeNode(child);\\n                map.put(child, childNode);\\n            }\\n            \\n            if (descriptions[i][2] == 1) {\\n                parentNode.left = childNode;\\n            } else {\\n                parentNode.right = childNode;\\n            }\\n            \\n            childs.add(child);\\n        }\\n        \\n        TreeNode root = null;\\n        for (int i = 0; i < n; ++i) {\\n            int parent = descriptions[i][0];\\n            if (!childs.contains(parent)) {\\n                root = map.get(parent);\\n                break;\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        Set<Integer> childs = new HashSet<>();\\n        int n = descriptions.length;\\n        for (int i = 0; i < n; ++i) {\\n            int parent = descriptions[i][0];\\n            int child = descriptions[i][1];\\n            \\n            TreeNode parentNode = map.get(parent);\\n            if (parentNode == null) {\\n                parentNode = new TreeNode(parent);\\n                map.put(parent, parentNode);\\n            }\\n            \\n            TreeNode childNode = map.get(child);\\n            if (childNode == null) {\\n                childNode = new TreeNode(child);\\n                map.put(child, childNode);\\n            }\\n            \\n            if (descriptions[i][2] == 1) {\\n                parentNode.left = childNode;\\n            } else {\\n                parentNode.right = childNode;\\n            }\\n            \\n            childs.add(child);\\n        }\\n        \\n        TreeNode root = null;\\n        for (int i = 0; i < n; ++i) {\\n            int parent = descriptions[i][0];\\n            if (!childs.contains(parent)) {\\n                root = map.get(parent);\\n                break;\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823797,
                "title": "idea-explained-store-nodes-mapping-well-commented-c-code",
                "content": "**Intuition :**\\n\\n* Idea here is to store node pointer by its value in a map -> `nodeMap`.\\n\\n* And connect each node with its children node.\\n* If node is already present in map, then use that node pointer,\\n* Else we create a new node using `getNode()` function.\\n* In this way we can easily track all nodes and its children.\\n* Now, when iterating over the `descriptions` list, we store child nodes\\' value in a set.\\n* We will later use this set to get **root** node. \\n* Since a root node is the one which has no parent, or \\n\\t* in other words, root is not a child of any other node.\\n   \\n# Code : \\n```\\nclass Solution {\\nprivate: \\n\\t\\t// Map to store node value and its pointer\\n\\t    unordered_map<int, TreeNode*> nodeMap;\\nprivate: \\n\\t// Helper function to getNode by value\\n\\tTreeNode* getNode(int val) {\\n        TreeNode* node = NULL;\\n\\t\\t// If node is not present in map, \\n\\t\\t// Then create a new node, and store it in map\\n        if(nodeMap.find(val) == nodeMap.end()) {\\n            node = new TreeNode(val);\\n            nodeMap[val] = node;\\n        }\\n\\t\\t// If node is already present in map then return it\\n        else {\\n            node = nodeMap[val];\\n        }\\n        return node;\\n    }\\npublic:\\n       \\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        \\n        unordered_set<int> isChild; // used to track if a node is child of some other node\\n        for(auto& description : descriptions) {\\n            int val = description[0], child = description[1];\\n            bool left = (description[2]);\\n            \\n\\t\\t\\t// Get node and then connect to left or right child accordingly\\n            TreeNode* node = getNode(val);\\n            if(left) {\\n                node->left = getNode(child);\\n            }\\n            else {\\n                node->right = getNode(child);   \\n            }\\n            isChild.insert(child);\\n        }\\n        \\n\\t\\t// Iterate over map, and get root node\\n        for(auto& [node, ptr] : nodeMap) {\\n            if(isChild.find(node) == st.end()) return ptr;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N + N)`, N is size of `descriptions` list\\n\\t* to iterate over `descriptions` list, \\n\\t* and to get root node by iterating over `nodeMap`\\n\\n* Space : `O(M)` , M is number of nodes in tree\\n\\t* to store nodes in map\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n\\t\\t// Map to store node value and its pointer\\n\\t    unordered_map<int, TreeNode*> nodeMap;\\nprivate: \\n\\t// Helper function to getNode by value\\n\\tTreeNode* getNode(int val) {\\n        TreeNode* node = NULL;\\n\\t\\t// If node is not present in map, \\n\\t\\t// Then create a new node, and store it in map\\n        if(nodeMap.find(val) == nodeMap.end()) {\\n            node = new TreeNode(val);\\n            nodeMap[val] = node;\\n        }\\n\\t\\t// If node is already present in map then return it\\n        else {\\n            node = nodeMap[val];\\n        }\\n        return node;\\n    }\\npublic:\\n       \\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        \\n        unordered_set<int> isChild; // used to track if a node is child of some other node\\n        for(auto& description : descriptions) {\\n            int val = description[0], child = description[1];\\n            bool left = (description[2]);\\n            \\n\\t\\t\\t// Get node and then connect to left or right child accordingly\\n            TreeNode* node = getNode(val);\\n            if(left) {\\n                node->left = getNode(child);\\n            }\\n            else {\\n                node->right = getNode(child);   \\n            }\\n            isChild.insert(child);\\n        }\\n        \\n\\t\\t// Iterate over map, and get root node\\n        for(auto& [node, ptr] : nodeMap) {\\n            if(isChild.find(node) == st.end()) return ptr;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823753,
                "title": "python-solution-using-dictionary",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        d = {}\\n        parent = {}\\n        for i in range(len(descriptions)):\\n            if descriptions[i][0] not in d:\\n                d[descriptions[i][0]] = TreeNode(descriptions[i][0])\\n            if descriptions[i][1] not in d:\\n                d[descriptions[i][1]] = TreeNode(descriptions[i][1])\\n            if descriptions[i][2] == 1:\\n                d[descriptions[i][0]].left = d[descriptions[i][1]]\\n            else:\\n                d[descriptions[i][0]].right = d[descriptions[i][1]]\\n            parent[descriptions[i][1]] = descriptions[i][0]\\n        x = list(set(d.keys()).difference(set(parent.keys())))\\n        return d[x[0]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        d = {}\\n        parent = {}\\n        for i in range(len(descriptions)):\\n            if descriptions[i][0] not in d:\\n                d[descriptions[i][0]] = TreeNode(descriptions[i][0])\\n            if descriptions[i][1] not in d:\\n                d[descriptions[i][1]] = TreeNode(descriptions[i][1])\\n            if descriptions[i][2] == 1:\\n                d[descriptions[i][0]].left = d[descriptions[i][1]]\\n            else:\\n                d[descriptions[i][0]].right = d[descriptions[i][1]]\\n            parent[descriptions[i][1]] = descriptions[i][0]\\n        x = list(set(d.keys()).difference(set(parent.keys())))\\n        return d[x[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823723,
                "title": "c-using-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& desc) {\\n        unordered_map<int,int> indegree;\\n        unordered_map<int,TreeNode*> mp;\\n        for(int i=0;i<desc.size();++i)\\n        {\\n            indegree[desc[i][1]]++;\\n            \\n            if(mp.count(desc[i][0])==0)\\n                mp[desc[i][0]] = new TreeNode(desc[i][0]);\\n            if(mp.count(desc[i][1])==0) \\n                mp[desc[i][1]] = new TreeNode(desc[i][1]);\\n            \\n            TreeNode* N= mp[desc[i][0]];\\n            TreeNode* child = mp[desc[i][1]];\\n            \\n            if(desc[i][2]==1)\\n                N->left=child;\\n            else\\n                N->right=child;\\n        }\\n        for(int i=0;i<desc.size();++i)\\n        {\\n            if(indegree.count(desc[i][0])==0)\\n                return mp[desc[i][0]];\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& desc) {\\n        unordered_map<int,int> indegree;\\n        unordered_map<int,TreeNode*> mp;\\n        for(int i=0;i<desc.size();++i)\\n        {\\n            indegree[desc[i][1]]++;\\n            \\n            if(mp.count(desc[i][0])==0)\\n                mp[desc[i][0]] = new TreeNode(desc[i][0]);\\n            if(mp.count(desc[i][1])==0) \\n                mp[desc[i][1]] = new TreeNode(desc[i][1]);\\n            \\n            TreeNode* N= mp[desc[i][0]];\\n            TreeNode* child = mp[desc[i][1]];\\n            \\n            if(desc[i][2]==1)\\n                N->left=child;\\n            else\\n                N->right=child;\\n        }\\n        for(int i=0;i<desc.size();++i)\\n        {\\n            if(indegree.count(desc[i][0])==0)\\n                return mp[desc[i][0]];\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823601,
                "title": "java-hashmap",
                "content": "**Code:**\\n\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer, TreeNode> x = new HashMap<>();\\n        HashSet<TreeNode> par = new HashSet<>();\\n        for(int [] arr : descriptions){\\n            if(!x.containsKey(arr[0])){\\n                x.put(arr[0], new TreeNode(arr[0]));\\n                par.add(x.get(arr[0]));\\n            }\\n            TreeNode curr = x.get(arr[0]);\\n\\t\\t\\t\\n            if(!x.containsKey(arr[1]))\\n                x.put(arr[1], new TreeNode(arr[1]));\\n            else par.remove(x.get(arr[1]));\\n\\t\\t\\t\\n            TreeNode add = x.get(arr[1]);\\n            if(arr[2]==1) curr.left = add;\\n            else curr.right = add;\\n        }\\n        return par.iterator().next();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Code:**\\n\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer, TreeNode> x = new HashMap<>();\\n        HashSet<TreeNode> par = new HashSet<>();\\n        for(int [] arr : descriptions){\\n            if(!x.containsKey(arr[0])){\\n                x.put(arr[0], new TreeNode(arr[0]));\\n                par.add(x.get(arr[0]));\\n            }\\n            TreeNode curr = x.get(arr[0]);\\n\\t\\t\\t\\n            if(!x.containsKey(arr[1]))\\n                x.put(arr[1], new TreeNode(arr[1]));\\n            else par.remove(x.get(arr[1]));\\n\\t\\t\\t\\n            TreeNode add = x.get(arr[1]);\\n            if(arr[2]==1) curr.left = add;\\n            else curr.right = add;\\n        }\\n        return par.iterator().next();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1823593,
                "title": "python3-with-clear-explanation-code",
                "content": "1. Iterate through given descriptions list\\n2. Use a dictionary to create a mapping from parent & child val to a Node object\\n3. Grab the parent node from the dictionary & assign its left/right child to the current child Node\\n4. In the same loop, keep track of all child nodes in a set. This is used to determine the root Node to return at the end\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        mapping = defaultdict(TreeNode)\\n        child_set = set()\\n        \\n        for (parent, child, is_left) in descriptions:\\n            child_set.add(child)\\n\\n            mapping[child].val = child\\n            mapping[parent].val = parent\\n                \\n            if is_left == 1:\\n                mapping[parent].left = mapping[child]\\n            else:\\n                mapping[parent].right = mapping[child]\\n\\n        for node in mapping.keys():\\n            if node not in child_set:\\n                return mapping[node]\\n        return None\\n",
                "solutionTags": [],
                "code": "1. Iterate through given descriptions list\\n2. Use a dictionary to create a mapping from parent & child val to a Node object\\n3. Grab the parent node from the dictionary & assign its left/right child to the current child Node\\n4. In the same loop, keep track of all child nodes in a set. This is used to determine the root Node to return at the end\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        mapping = defaultdict(TreeNode)\\n        child_set = set()\\n        \\n        for (parent, child, is_left) in descriptions:\\n            child_set.add(child)\\n\\n            mapping[child].val = child\\n            mapping[parent].val = parent\\n                \\n            if is_left == 1:\\n                mapping[parent].left = mapping[child]\\n            else:\\n                mapping[parent].right = mapping[child]\\n\\n        for node in mapping.keys():\\n            if node not in child_set:\\n                return mapping[node]\\n        return None\\n",
                "codeTag": "Java"
            },
            {
                "id": 3998532,
                "title": "c-a-unique-yet-fast-solution-using-recursion",
                "content": "Try challenging yourself in understanding this piece of code :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* create (unordered_map<int, pair<int, int>> &map, int val) {\\n        if (val == 0) return nullptr;\\n        TreeNode* node = new TreeNode (val);\\n        node->left = create(map, map[val].first);\\n        node->right = create(map, map[val].second);\\n        return node;\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map <int, pair<int, int >> map;\\n        unordered_map <int, int> temp;\\n        for (vector<int> vec: descriptions) {\\n            temp[vec[1]] = 1;\\n            if (map.find(vec[0]) == map.end()) map[vec[0]] = {0,0};\\n            if (vec[2] == 0) map[vec[0]].second = vec[1];\\n            else if (vec[2] == 1) map[vec[0]].first = vec[1];\\n        }\\n        int rootval = 0;\\n        for (auto pair: map) {\\n            if (temp[pair.first] == 0) rootval = pair.first; \\n        }\\n        map[-1] = {rootval, 0};\\n\\n        TreeNode* root = create(map, -1);\\n        TreeNode* n = root;\\n        root = root->left;\\n        delete n;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* create (unordered_map<int, pair<int, int>> &map, int val) {\\n        if (val == 0) return nullptr;\\n        TreeNode* node = new TreeNode (val);\\n        node->left = create(map, map[val].first);\\n        node->right = create(map, map[val].second);\\n        return node;\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map <int, pair<int, int >> map;\\n        unordered_map <int, int> temp;\\n        for (vector<int> vec: descriptions) {\\n            temp[vec[1]] = 1;\\n            if (map.find(vec[0]) == map.end()) map[vec[0]] = {0,0};\\n            if (vec[2] == 0) map[vec[0]].second = vec[1];\\n            else if (vec[2] == 1) map[vec[0]].first = vec[1];\\n        }\\n        int rootval = 0;\\n        for (auto pair: map) {\\n            if (temp[pair.first] == 0) rootval = pair.first; \\n        }\\n        map[-1] = {rootval, 0};\\n\\n        TreeNode* root = create(map, -1);\\n        TreeNode* n = root;\\n        root = root->left;\\n        delete n;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748626,
                "title": "c-map-very-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& arr) \\n{\\n\\t//getting the root node of the tree\\n    unordered_set<int>st;\\n    for(int i=0;i<arr.size();i++)\\n    {\\n    \\tst.insert(arr[i][0]);\\n    \\tst.insert(arr[i][1]);\\n\\t}\\n\\tfor(int i=0;i<arr.size();i++)\\n\\t{\\n\\t\\tif(st.find(arr[i][1])!=st.end())\\n\\t\\t{\\n\\t\\t\\tst.erase(arr[i][1]);\\n\\t\\t}\\n\\t}\\n\\tint root=*(st.begin());\\n     \\n    //getting the map filled with the diff roots \\n    unordered_map<int,TreeNode*>mp; \\n\\tfor(int i=0;i<arr.size();i++)\\n\\t{\\n\\t   if(mp.find(arr[i][0])==mp.end())  //agar nahi mila to\\n\\t   {\\n\\t     \\tmp[arr[i][0]]=new TreeNode(arr[i][0]);\\n       }  \\t\\n       if(mp.find(arr[i][1])==mp.end())  //agar nahi mila to\\n       {\\n       \\t   mp[arr[i][1]]=new TreeNode(arr[i][1]);\\n\\t   }\\n    }\\n    vector<int>temp;\\n\\tfor(int i=0;i<arr.size();i++)\\n\\t{\\n\\t\\ttemp=arr[i];\\n\\t\\t\\n\\t\\tint parent = temp[0];\\n\\t\\tint child = temp[1];\\n\\t\\tbool isleft=temp[2];\\n\\t\\t\\n\\t\\tif(isleft==true)\\n\\t\\t{\\n\\t\\t   mp[parent]->left = mp[child];\\t\\n\\t\\t}\\n\\t\\telse if(isleft==false)\\n\\t\\t{\\n\\t\\t\\tmp[parent]->right = mp[child];\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn mp[root];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& arr) \\n{\\n\\t//getting the root node of the tree\\n    unordered_set<int>st;\\n    for(int i=0;i<arr.size();i++)\\n    {\\n    \\tst.insert(arr[i][0]);\\n    \\tst.insert(arr[i][1]);\\n\\t}\\n\\tfor(int i=0;i<arr.size();i++)\\n\\t{\\n\\t\\tif(st.find(arr[i][1])!=st.end())\\n\\t\\t{\\n\\t\\t\\tst.erase(arr[i][1]);\\n\\t\\t}\\n\\t}\\n\\tint root=*(st.begin());\\n     \\n    //getting the map filled with the diff roots \\n    unordered_map<int,TreeNode*>mp; \\n\\tfor(int i=0;i<arr.size();i++)\\n\\t{\\n\\t   if(mp.find(arr[i][0])==mp.end())  //agar nahi mila to\\n\\t   {\\n\\t     \\tmp[arr[i][0]]=new TreeNode(arr[i][0]);\\n       }  \\t\\n       if(mp.find(arr[i][1])==mp.end())  //agar nahi mila to\\n       {\\n       \\t   mp[arr[i][1]]=new TreeNode(arr[i][1]);\\n\\t   }\\n    }\\n    vector<int>temp;\\n\\tfor(int i=0;i<arr.size();i++)\\n\\t{\\n\\t\\ttemp=arr[i];\\n\\t\\t\\n\\t\\tint parent = temp[0];\\n\\t\\tint child = temp[1];\\n\\t\\tbool isleft=temp[2];\\n\\t\\t\\n\\t\\tif(isleft==true)\\n\\t\\t{\\n\\t\\t   mp[parent]->left = mp[child];\\t\\n\\t\\t}\\n\\t\\telse if(isleft==false)\\n\\t\\t{\\n\\t\\t\\tmp[parent]->right = mp[child];\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn mp[root];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568586,
                "title": "easy-solution-using-graph-and-map",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     \\n    TreeNode* construct( vector<int>graph[],int par){\\n        TreeNode* root=new TreeNode(par);\\n        if(graph[par][0]!=-1){\\n            root->left=construct(graph,graph[par][0]);\\n        }\\n         if(graph[par][1]!=-1){\\n            root->right=construct(graph,graph[par][1]);\\n        }\\n        return root;\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& desc) {\\n        unordered_map<int,int> m;\\n        for(auto i:desc){\\n            m[i[1]] = 1;\\n            if(m.find(i[0])==m.end()) m[i[0]] = 0;\\n        }\\n        int par = -1;\\n        for(auto i:m){\\n            if(i.second==0){\\n                par = i.first;\\n                break;\\n            }\\n        }\\n        \\n        vector<int>graph[100004];\\n        for(auto x:m){\\n          graph[x.first].push_back(-1);\\n          graph[x.first].push_back(-1);  \\n        }\\n         for(auto x:desc){\\n            graph[x[0]][1-x[2]]=x[1];\\n           \\n        }\\n        return construct(graph,par);\\n        TreeNode *ans=new TreeNode(0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     \\n    TreeNode* construct( vector<int>graph[],int par){\\n        TreeNode* root=new TreeNode(par);\\n        if(graph[par][0]!=-1){\\n            root->left=construct(graph,graph[par][0]);\\n        }\\n         if(graph[par][1]!=-1){\\n            root->right=construct(graph,graph[par][1]);\\n        }\\n        return root;\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& desc) {\\n        unordered_map<int,int> m;\\n        for(auto i:desc){\\n            m[i[1]] = 1;\\n            if(m.find(i[0])==m.end()) m[i[0]] = 0;\\n        }\\n        int par = -1;\\n        for(auto i:m){\\n            if(i.second==0){\\n                par = i.first;\\n                break;\\n            }\\n        }\\n        \\n        vector<int>graph[100004];\\n        for(auto x:m){\\n          graph[x.first].push_back(-1);\\n          graph[x.first].push_back(-1);  \\n        }\\n         for(auto x:desc){\\n            graph[x[0]][1-x[2]]=x[1];\\n           \\n        }\\n        return construct(graph,par);\\n        TreeNode *ans=new TreeNode(0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538511,
                "title": "python-solution",
                "content": "# class Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        d = {}\\n        s1, s2 = set(), set()\\n        for a, b, c in descriptions:\\n            if a not in d: d[a] = TreeNode(a)\\n            if b not in d: d[b] = TreeNode(b)\\n            if c == 1:\\n                d[a].left = d[b]\\n            else:\\n                d[a].right = d[b]\\n            s1.add(a)\\n            s2.add(b)\\n        \\n        return d[list(s1 - s2)[0]]\\n                \\n        \\n#",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 2510314,
                "title": "c-using-map",
                "content": "This solution uses two maps \\n1. to keep track of parent nodes of each parent.\\n2. to keep track of nodes which are created and stores their address.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        map<int,TreeNode*> nodes;  // keeps track of nodes which are created\\n        map<TreeNode*, TreeNode*> pc; // keeps track of parent of each child\\n       for(auto i: descriptions){\\n           TreeNode* parent;\\n           TreeNode* child;\\n           if(nodes.find(i[0]) == nodes.end()){\\n               parent = new TreeNode(i[0]);\\n               nodes[i[0]] = parent;\\n           }\\n           else parent = nodes[i[0]];\\n           if(nodes.find(i[1]) == nodes.end()){\\n               child = new TreeNode(i[1]);\\n               nodes[i[1]] = child;\\n           }\\n           else child = nodes[i[1]];\\n           if(i[2] == 0)\\n               parent->right=child;\\n           else parent->left=child;\\n           pc[child]=parent;\\n       }\\n        TreeNode* root=NULL;\\n        for(auto i: nodes){\\n            if(pc.find(i.second) == pc.end()){\\n                root=i.second;\\n                break;\\n            }\\n        }\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        map<int,TreeNode*> nodes;  // keeps track of nodes which are created\\n        map<TreeNode*, TreeNode*> pc; // keeps track of parent of each child\\n       for(auto i: descriptions){\\n           TreeNode* parent;\\n           TreeNode* child;\\n           if(nodes.find(i[0]) == nodes.end()){\\n               parent = new TreeNode(i[0]);\\n               nodes[i[0]] = parent;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2292393,
                "title": "c-easy-to-understand-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        int n=d.size();\\n        map<int,TreeNode*> mp;\\n        set<int> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            TreeNode* temp;\\n            if(mp.find(d[i][0])!=mp.end())\\n            {\\n                temp=mp[d[i][0]];\\n            }\\n            else\\n            {\\n                temp=new TreeNode(d[i][0]);\\n                mp[d[i][0]]=temp;\\n            }\\n            bool isleft=d[i][2];\\n            if(isleft)\\n            {\\n                TreeNode* t2;\\n                if(mp.find(d[i][1])!=mp.end())\\n                {\\n                    t2=mp[d[i][1]];\\n                }\\n                else\\n                {\\n                    t2=new TreeNode(d[i][1]);\\n                    mp[d[i][1]]=t2;\\n                }\\n                st.insert(d[i][1]);\\n                temp->left=t2;\\n            }\\n            else\\n            {\\n                TreeNode* t2;\\n                if(mp.find(d[i][1])!=mp.end())\\n                {\\n                    t2=mp[d[i][1]];\\n                }\\n                else\\n                {\\n                    t2=new TreeNode(d[i][1]);\\n                    mp[d[i][1]]=t2;\\n                }\\n                st.insert(d[i][1]);\\n                temp->right=t2;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.find(d[i][0])==st.end())\\n            return mp[d[i][0]];\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        int n=d.size();\\n        map<int,TreeNode*> mp;\\n        set<int> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            TreeNode* temp;\\n            if(mp.find(d[i][0])!=mp.end())\\n            {\\n                temp=mp[d[i][0]];\\n            }\\n            else\\n            {\\n                temp=new TreeNode(d[i][0]);\\n                mp[d[i][0]]=temp;\\n            }\\n            bool isleft=d[i][2];\\n            if(isleft)\\n            {\\n                TreeNode* t2;\\n                if(mp.find(d[i][1])!=mp.end())\\n                {\\n                    t2=mp[d[i][1]];\\n                }\\n                else\\n                {\\n                    t2=new TreeNode(d[i][1]);\\n                    mp[d[i][1]]=t2;\\n                }\\n                st.insert(d[i][1]);\\n                temp->left=t2;\\n            }\\n            else\\n            {\\n                TreeNode* t2;\\n                if(mp.find(d[i][1])!=mp.end())\\n                {\\n                    t2=mp[d[i][1]];\\n                }\\n                else\\n                {\\n                    t2=new TreeNode(d[i][1]);\\n                    mp[d[i][1]]=t2;\\n                }\\n                st.insert(d[i][1]);\\n                temp->right=t2;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.find(d[i][0])==st.end())\\n            return mp[d[i][0]];\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063015,
                "title": "c-map",
                "content": "# C++ MAP\\n\\t\\t\\t/**\\n\\t\\t\\t * Definition for a binary tree node.\\n\\t\\t\\t * struct TreeNode {\\n\\t\\t\\t *     int val;\\n\\t\\t\\t *     TreeNode *left;\\n\\t\\t\\t *     TreeNode *right;\\n\\t\\t\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t\\t\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t\\t\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t\\t\\t * };\\n\\t\\t\\t */\\n\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tTreeNode* createBinaryTree(vector<vector<int>>& d) {\\n\\n\\t\\t\\t\\t\\tmap<int,TreeNode*> m;\\n\\t\\t\\t\\t\\tint n = d.size();\\n\\t\\t\\t\\t\\tTreeNode* head = NULL;\\n\\t\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\t\\tmap<int,bool> b;\\n\\n\\t\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\t\\tint p = d[i][0];\\n\\t\\t\\t\\t\\t\\tint c = d[i][1];\\n\\t\\t\\t\\t\\t\\tint l = d[i][2];\\n\\n\\t\\t\\t\\t\\t\\tif(m.find(p)==m.end()){\\n\\t\\t\\t\\t\\t\\t\\tTreeNode* a = new TreeNode(p);\\n\\t\\t\\t\\t\\t\\t\\tm[p] = a;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(m.find(c)==m.end()){\\n\\t\\t\\t\\t\\t\\t\\tTreeNode* a = new TreeNode(c);\\n\\t\\t\\t\\t\\t\\t\\tm[c] = a;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif(l==1){\\n\\t\\t\\t\\t\\t\\t\\tm[p]->left = m[c];\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\tm[p]->right = m[c];\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tb[c] = true;\\n\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\t\\tint c = d[i][0];\\n\\t\\t\\t\\t\\t\\tif(b[c]!=true){\\n\\t\\t\\t\\t\\t\\t\\thead = m[c];\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn head;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tTreeNode* createBinaryTree(vector<vector<int>>& d) {\\n\\n\\t\\t\\t\\t\\tmap<int,TreeNode*> m;\\n\\t\\t\\t\\t\\tint n = d.size();\\n\\t\\t\\t\\t\\tTreeNode* head = NULL;\\n\\t\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\t\\tmap<int,bool> b;\\n\\n\\t\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\t\\tint p = d[i][0];\\n\\t\\t\\t\\t\\t\\tint c = d[i][1];\\n\\t\\t\\t\\t\\t\\tint l = d[i][2];\\n\\n\\t\\t\\t\\t\\t\\tif(m.find(p)==m.end()){\\n\\t\\t\\t\\t\\t\\t\\tTreeNode* a = new TreeNode(p);\\n\\t\\t\\t\\t\\t\\t\\tm[p] = a;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2058405,
                "title": "c-straightforward-hashmap-solution-with-explanation-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,int> isRoot;//we will take convention => 2: for potential candidate for root node, 1: for any child node. \\n        //LOGIC: Any child node can\\'t be the root node ever.\\n        unordered_map<int,TreeNode*> mp; //storing pointers created for every node\\n        for(auto d: descriptions)\\n        {\\n            if(mp.find(d[0])==mp.end()) {mp[d[0]] = new TreeNode(d[0]);}\\n            \\n            if(mp.find(d[1])==mp.end()) {mp[d[1]] = new TreeNode(d[1]);}\\n            \\n            if(d[2])\\n                mp[d[0]]->left = mp[d[1]];\\n            if(!d[2])\\n                mp[d[0]]->right = mp[d[1]];\\n               \\n            if(isRoot.find(d[0])==isRoot.end()) isRoot[d[0]] = 2; //marked as potential candidate for root node only if previously never marked as child\\n            isRoot[d[1]] = 1; //marked as child\\n        }\\n               \\n        for(auto node: isRoot)\\n            if(node.second==2) //found root node (only node which is not a child node)\\n               return mp[node.first];\\n               \\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,int> isRoot;//we will take convention => 2: for potential candidate for root node, 1: for any child node. \\n        //LOGIC: Any child node can\\'t be the root node ever.\\n        unordered_map<int,TreeNode*> mp; //storing pointers created for every node\\n        for(auto d: descriptions)\\n        {\\n            if(mp.find(d[0])==mp.end()) {mp[d[0]] = new TreeNode(d[0]);}\\n            \\n            if(mp.find(d[1])==mp.end()) {mp[d[1]] = new TreeNode(d[1]);}\\n            \\n            if(d[2])\\n                mp[d[0]]->left = mp[d[1]];\\n            if(!d[2])\\n                mp[d[0]]->right = mp[d[1]];\\n               \\n            if(isRoot.find(d[0])==isRoot.end()) isRoot[d[0]] = 2; //marked as potential candidate for root node only if previously never marked as child\\n            isRoot[d[1]] = 1; //marked as child\\n        }\\n               \\n        for(auto node: isRoot)\\n            if(node.second==2) //found root node (only node which is not a child node)\\n               return mp[node.first];\\n               \\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993065,
                "title": "c-easy-to-understand",
                "content": "**DO UPVOTE IF YOU LIKE IT**\\n```\\nTreeNode* createBinaryTree(vector<vector<int>>& descriptions) \\n    {\\n        unordered_map<int,TreeNode*> nodes;\\n        unordered_map<TreeNode*,int> parent,child;\\n        \\n        for(auto x:descriptions)\\n        {\\n            int par=x[0],chi=x[1],isL=x[2];\\n            \\n            if(nodes.find(par)==nodes.end())\\n            {\\n                nodes[par]=new TreeNode(par);\\n            }\\n            \\n            if(nodes.find(chi)==nodes.end())\\n            {\\n                nodes[chi]=new TreeNode(chi);\\n            }\\n            \\n            if(isL==1)\\n            {\\n                nodes[par]->left=nodes[chi];\\n            }\\n            else\\n            {\\n                nodes[par]->right=nodes[chi];\\n            }\\n            parent[nodes[par]]++;\\n            child[nodes[chi]]++;\\n        }\\n        \\n        for(auto x:nodes)\\n        {\\n            if(parent[x.second]!=0&&child[x.second]==0)\\n            {\\n                return x.second;\\n            }\\n        }\\n        return NULL;\\n    }",
                "solutionTags": [],
                "code": "**DO UPVOTE IF YOU LIKE IT**\\n```\\nTreeNode* createBinaryTree(vector<vector<int>>& descriptions) \\n    {\\n        unordered_map<int,TreeNode*> nodes;\\n        unordered_map<TreeNode*,int> parent,child;\\n        \\n        for(auto x:descriptions)\\n        {\\n            int par=x[0],chi=x[1],isL=x[2];\\n            \\n            if(nodes.find(par)==nodes.end())\\n            {\\n                nodes[par]=new TreeNode(par);\\n            }\\n            \\n            if(nodes.find(chi)==nodes.end())\\n            {\\n                nodes[chi]=new TreeNode(chi);\\n            }\\n            \\n            if(isL==1)\\n            {\\n                nodes[par]->left=nodes[chi];\\n            }\\n            else\\n            {\\n                nodes[par]->right=nodes[chi];\\n            }\\n            parent[nodes[par]]++;\\n            child[nodes[chi]]++;\\n        }\\n        \\n        for(auto x:nodes)\\n        {\\n            if(parent[x.second]!=0&&child[x.second]==0)\\n            {\\n                return x.second;\\n            }\\n        }\\n        return NULL;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1839428,
                "title": "c-detailed-dfs-solution-2196",
                "content": "From the given descriptions we need to convert the given information into an efficient way to solve this question.\\n1. **We need to find the root of the tree**\\nAs we know there will be no parent node to the root of the tree so in the given information the root of the tree will be present in the 0th indices(parent) and will not present in 1st indices(child).\\nSo we will take a set or map to store all the child nodes and then check all the parent nodes. If a parent node is not a child node then it is the root node\\n\\n2. **We need to store all the child nodes as leftChild and rightChild**\\nWe can do this by two maps (as we have all values unique it makes our work easier), storing by checking the left or right indication in the given descriptions\\n\\n3. **Construct the tree**\\nNow we know root node and left and right child childs of the existing nodes of the tree so by using DFS or BFS we can construct the tree.\\n\\nHere is the DFS implementation\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>leftChild,rightChild;\\n    TreeNode* constructTree(int value){\\n        TreeNode* root = new TreeNode(value);\\n        if(leftChild.count(value)){root->left = constructTree(leftChild[value]);}\\n        if(rightChild.count(value)){root->right = constructTree(rightChild[value]);}\\n        return root;\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_set<int>notRoots;\\n        for(vector<int>& v : descriptions){\\n            notRoots.insert(v[1]);\\n            if(v[2] == 1){leftChild[v[0]] = v[1];}\\n            else{rightChild[v[0]] = v[1];}\\n        }\\n        int root;\\n        for(vector<int>& v : descriptions){\\n            if(!notRoots.count(v[0])){root = v[0]; break;}\\n        }\\n        return constructTree(root);\\n    }\\n};\\n```\\n\\nFeel free to comment your queries if any\\n**Upvote** if found useful\\n**Thank You :)**",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>leftChild,rightChild;\\n    TreeNode* constructTree(int value){\\n        TreeNode* root = new TreeNode(value);\\n        if(leftChild.count(value)){root->left = constructTree(leftChild[value]);}\\n        if(rightChild.count(value)){root->right = constructTree(rightChild[value]);}\\n        return root;\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_set<int>notRoots;\\n        for(vector<int>& v : descriptions){\\n            notRoots.insert(v[1]);\\n            if(v[2] == 1){leftChild[v[0]] = v[1];}\\n            else{rightChild[v[0]] = v[1];}\\n        }\\n        int root;\\n        for(vector<int>& v : descriptions){\\n            if(!notRoots.count(v[0])){root = v[0]; break;}\\n        }\\n        return constructTree(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833449,
                "title": "javascript-easy-to-understand-detailed-explanation",
                "content": "To build a binary tree, what we need to do is:\\n- create the nodes we need\\n- link the nodes depends on the `descriptions`\\n- return the root node\\n\\nStep 1 is easy, when we traverse the `descriptions`, we could create the whole nodes.\\n\\nStep 2 is easy too, we just need to traverse the `descriptions` and link the pointer between parent and child.\\n\\nStep 3 is a little tough, seems we can\\'t get it straightforward. What I can think of to deal with this, is to put all `parent` into a set, then remove all the `child`, so the last one left in the set should be the root. If you have a better solution, please comment to help me, thank you.\\n\\nFinally, here\\'s a sample code from me:\\n\\n```js\\nconst createBinaryTree = (descriptions) => {\\n  const headSet = new Set();\\n  const map = {};\\n  for (const [parent, child, isLeft] of descriptions) {\\n    !map[parent] && (map[parent] = new TreeNode(parent));\\n    !map[child] && (map[child] = new TreeNode(child));\\n    map[parent][isLeft ? \"left\" : \"right\"] = map[child];\\n    headSet.add(parent);\\n  }\\n  for (const desc of descriptions) {\\n    headSet.delete(desc[1]);\\n  }\\n  return map[Array.from(headSet)[0]];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst createBinaryTree = (descriptions) => {\\n  const headSet = new Set();\\n  const map = {};\\n  for (const [parent, child, isLeft] of descriptions) {\\n    !map[parent] && (map[parent] = new TreeNode(parent));\\n    !map[child] && (map[child] = new TreeNode(child));\\n    map[parent][isLeft ? \"left\" : \"right\"] = map[child];\\n    headSet.add(parent);\\n  }\\n  for (const desc of descriptions) {\\n    headSet.delete(desc[1]);\\n  }\\n  return map[Array.from(headSet)[0]];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825889,
                "title": "c-map-o-n-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n       unordered_map<int, pair<TreeNode*, bool>> mp;\\n       for(auto &node : descriptions) {\\n           int parent = node[0];\\n           int child = node[1];\\n           int left = node[2];\\n           TreeNode *parentNode, *childNode;\\n           if(mp.find(parent) == mp.end()) {\\n              parentNode = new TreeNode(parent);\\n               mp[parent] = {parentNode,true};\\n           }\\n           if(mp.find(child) == mp.end()) {\\n               childNode = new TreeNode(child);\\n               mp[child] = {childNode,false};\\n           } else {\\n               mp[child].second = false;\\n           }\\n           if(left == 1) {\\n               mp[parent].first->left = mp[child].first;\\n           } else {\\n               mp[parent].first->right = mp[child].first;\\n           }\\n       }\\n       \\n        TreeNode* root = NULL;\\n       \\n        for(auto &node: mp) {\\n            if(node.second.second == true) {\\n                root = node.second.first; \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**If you have any doubt comment, if liked then upvote.**",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n       unordered_map<int, pair<TreeNode*, bool>> mp;\\n       for(auto &node : descriptions) {\\n           int parent = node[0];\\n           int child = node[1];\\n           int left = node[2];\\n           TreeNode *parentNode, *childNode;\\n           if(mp.find(parent) == mp.end()) {\\n              parentNode = new TreeNode(parent);\\n               mp[parent] = {parentNode,true};\\n           }\\n           if(mp.find(child) == mp.end()) {\\n               childNode = new TreeNode(child);\\n               mp[child] = {childNode,false};\\n           } else {\\n               mp[child].second = false;\\n           }\\n           if(left == 1) {\\n               mp[parent].first->left = mp[child].first;\\n           } else {\\n               mp[parent].first->right = mp[child].first;\\n           }\\n       }\\n       \\n        TreeNode* root = NULL;\\n       \\n        for(auto &node: mp) {\\n            if(node.second.second == true) {\\n                root = node.second.first; \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825202,
                "title": "c-map-most-efficient-simple-solution-beats-every-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        map<int,TreeNode *>m;//map root value with root\\n        map<TreeNode *,TreeNode *>mp;//map children with their parents\\n        TreeNode *ans = NULL;\\n        vector<int>v;\\n        for(auto it:descriptions){\\n            int par = it[0];\\n            int child = it[1];\\n            int left = it[2];\\n            TreeNode * node = NULL;\\n            if(m.count(child)>0){\\n                node = m[child];\\n            }\\n            else{\\n                node = new TreeNode(child);\\n            }\\n\\n            if(m.count(par)>0){\\n                if(left){\\n                    m[par]->left = node;\\n                    mp[node] = m[par];\\n                   \\n                }\\n                else{\\n                    m[par]->right = node;\\n                    mp[node] = m[par];\\n                  \\n                }\\n            }\\n            else{\\n                TreeNode * node1 = new TreeNode(par);\\n                if(left){\\n                    node1->left = node;\\n                    mp[node] = node1;\\n              \\n                }\\n                else{\\n                    node1->right = node;\\n                    mp[node] = node1;\\n                   \\n                }\\n                m[par] = node1;\\n                ans = node1;\\n                if(mp[node1]==NULL){\\n                    v.push_back(node1->val);//collecting all nodes whose parents not exist till now(might be possible root of the tree)\\n                }\\n               \\n            }\\n            m[child] = node;\\n            \\n        }\\n        for(auto it:v){\\n            if(mp[m[it]]==NULL)return m[it];//only single root possible whose parent not exist till final\\n        }\\n   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        map<int,TreeNode *>m;//map root value with root\\n        map<TreeNode *,TreeNode *>mp;//map children with their parents\\n        TreeNode *ans = NULL;\\n        vector<int>v;\\n        for(auto it:descriptions){\\n            int par = it[0];\\n            int child = it[1];\\n            int left = it[2];\\n            TreeNode * node = NULL;\\n            if(m.count(child)>0){\\n                node = m[child];\\n            }\\n            else{\\n                node = new TreeNode(child);\\n            }\\n\\n            if(m.count(par)>0){\\n                if(left){\\n                    m[par]->left = node;\\n                    mp[node] = m[par];\\n                   \\n                }\\n                else{\\n                    m[par]->right = node;\\n                    mp[node] = m[par];\\n                  \\n                }\\n            }\\n            else{\\n                TreeNode * node1 = new TreeNode(par);\\n                if(left){\\n                    node1->left = node;\\n                    mp[node] = node1;\\n              \\n                }\\n                else{\\n                    node1->right = node;\\n                    mp[node] = node1;\\n                   \\n                }\\n                m[par] = node1;\\n                ans = node1;\\n                if(mp[node1]==NULL){\\n                    v.push_back(node1->val);//collecting all nodes whose parents not exist till now(might be possible root of the tree)\\n                }\\n               \\n            }\\n            m[child] = node;\\n            \\n        }\\n        for(auto it:v){\\n            if(mp[m[it]]==NULL)return m[it];//only single root possible whose parent not exist till final\\n        }\\n   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824874,
                "title": "simple-c-solution-using-map",
                "content": "\\tclass Solution {\\n\\t\\tunordered_map<int,TreeNode *> mp;\\n\\t\\tunordered_set<int> st;\\n\\tpublic:\\n\\t\\tvoid fill(vector<vector<int>>& tree){\\n\\t\\t\\t  for(auto &it: tree){\\n\\t\\t\\t\\t  if(mp.find(it[0])==mp.end()){\\n\\t\\t\\t\\t\\t   TreeNode *n=new TreeNode(it[0]);\\n\\t\\t\\t\\t\\t  mp[it[0]]=n;\\n\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  if(mp.find(it[1])==mp.end()){\\n\\t\\t\\t\\t\\t   TreeNode *n=new TreeNode(it[1]);\\n\\t\\t\\t\\t\\t  mp[it[1]]=n;\\n\\t\\t\\t\\t  }\\n\\t\\t\\t  }\\n\\t\\t}\\n\\t\\tvoid maketree(vector<vector<int>>& tree){\\n\\t\\t\\t   for(auto &it: tree){\\n\\t\\t\\t\\t   if(it[2]==1){\\n\\t\\t\\t\\t\\t   mp[it[0]]->left=mp[it[1]];\\n\\t\\t\\t\\t   }\\n\\t\\t\\t\\t   else{\\n\\t\\t\\t\\t\\t   mp[it[0]]->right=mp[it[1]];\\n\\t\\t\\t\\t   }\\n\\t\\t\\t\\t   st.insert(it[1]);\\n\\t\\t\\t   }\\n\\t\\t}\\n\\t\\tTreeNode* createBinaryTree(vector<vector<int>>& tree) {\\n\\t\\t\\tmp.clear();\\n\\t\\t\\t\\t fill(tree);\\n\\t\\t\\t\\tmaketree(tree);\\n\\t\\t\\t  for(auto &it: mp){\\n\\t\\t\\t\\t  if(st.find(it.first)==st.end())\\n\\t\\t\\t\\t\\t  return mp[it.first];\\n\\t\\t\\t  }\\n\\t\\t\\treturn nullptr;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tunordered_map<int,TreeNode *> mp;\\n\\t\\tunordered_set<int> st;\\n\\tpublic:\\n\\t\\tvoid fill(vector<vector<int>>& tree){\\n\\t\\t\\t  for(auto &it: tree){\\n\\t\\t\\t\\t  if(mp.find(it[0])==mp.end()){\\n\\t\\t\\t\\t\\t   TreeNode *n=new TreeNode(it[0]);\\n\\t\\t\\t\\t\\t  mp[it[0]]=n;\\n\\t\\t\\t\\t  }",
                "codeTag": "Java"
            },
            {
                "id": 1823875,
                "title": "java-approach-explained-using-map-set-o-n",
                "content": "Maintain a map of value & its treeNode i.e. `Map<Integer, TreeNode>`\\nMaintain `childSet` which will contain all childValues as we need to return root of the tree.\\nSince root has no parent so it won\\'t be added in childSet.\\n\\nIdea is to iterate over all descriptions:\\n1. Check if parent node exists in map. Otherwise create new TreeNode and put in map.\\n2. Similarly for child node.\\n3. Fix the left or right pointer as per isLeft value.\\n4. Add the child value to childSet.\\n\\nTo find root node, iterate over descrptions again & check for parent values in childSet.\\nif `!childSet.contains(descrption[i][0]) `then it is our root node.\\n\\n```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        Set<Integer> childSet = new HashSet<>();\\n        for (int[] desc: descriptions) {\\n            int parent = desc[0];\\n            TreeNode p = map.get(parent);\\n            if (p == null) {\\n                p = new TreeNode(parent);\\n                map.put(parent, p);\\n            }\\n            \\n            int child = desc[1];\\n            TreeNode c = map.get(child);\\n            if (c == null) {\\n                c = new TreeNode(child);\\n                map.put(child, c);\\n            }\\n            \\n            if (desc[2] == 1) {\\n                p.left = c;\\n            } else {\\n                p.right = c;\\n            }\\n            \\n            childSet.add(child);\\n        }\\n        \\n        for (int[] desc: descriptions) {\\n            if (!childSet.contains(desc[0])) {\\n                return map.get(desc[0]);\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        Set<Integer> childSet = new HashSet<>();\\n        for (int[] desc: descriptions) {\\n            int parent = desc[0];\\n            TreeNode p = map.get(parent);\\n            if (p == null) {\\n                p = new TreeNode(parent);\\n                map.put(parent, p);\\n            }\\n            \\n            int child = desc[1];\\n            TreeNode c = map.get(child);\\n            if (c == null) {\\n                c = new TreeNode(child);\\n                map.put(child, c);\\n            }\\n            \\n            if (desc[2] == 1) {\\n                p.left = c;\\n            } else {\\n                p.right = c;\\n            }\\n            \\n            childSet.add(child);\\n        }\\n        \\n        for (int[] desc: descriptions) {\\n            if (!childSet.contains(desc[0])) {\\n                return map.get(desc[0]);\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823788,
                "title": "treat-it-as-a-dag-kahn-s-topo-algorithm-with-images-easy-to-understand",
                "content": "\\nThis is a two-pass approach. \\nI created the following data structures: \\nFor ex: if input is `descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]`\\nI construct adjacency list and indegree just like I would in Kahn\\'s Topological Sort\\n\\n![image](https://assets.leetcode.com/users/images/84b44c20-dd98-458d-874c-9694d913e497_1646538951.364825.png)\\n\\nFrom there, I pick the in-degree 0 / a.k.a root node and do a BFS constructing the tree as I go along. \\n\\n```\\nclass Solution:\\n    \\n    def construct_graph_and_indegree(self, descriptions):\\n        g = {}\\n        in_degree = {}\\n        \\n        for parent, child, is_left in descriptions:\\n            if parent not in g: \\n                g[parent] = [None, None]\\n            if child not in g:\\n                g[child] = [None, None]\\n            \\n            if parent not in in_degree: in_degree[parent] = 0\\n            if child not in in_degree: in_degree[child] = 0\\n            \\n            in_degree[child] += 1\\n            # if is_left is true will be in 1st pos, else it will be inserted in right child\\n            g[parent][is_left] = child\\n        \\n        return [g, in_degree]\\n    \\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        g, in_degree = self.construct_graph_and_indegree(descriptions)\\n        root = None\\n        for vertex, in_deg in in_degree.items():\\n            if in_deg == 0:\\n                root = vertex\\n                break\\n        \\n        root_node = TreeNode(root)\\n        q = deque([root_node])\\n        while q:\\n            curr_node = q.popleft()\\n            if g[curr_node.val][0]:\\n                right_node = TreeNode(g[curr_node.val][0])\\n                curr_node.right = right_node\\n                q.append(right_node)\\n            if g[curr_node.val][1]:\\n                left_node = TreeNode(g[curr_node.val][1])\\n                curr_node.left = left_node\\n                q.append(left_node)\\n        return root_node\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def construct_graph_and_indegree(self, descriptions):\\n        g = {}\\n        in_degree = {}\\n        \\n        for parent, child, is_left in descriptions:\\n            if parent not in g: \\n                g[parent] = [None, None]\\n            if child not in g:\\n                g[child] = [None, None]\\n            \\n            if parent not in in_degree: in_degree[parent] = 0\\n            if child not in in_degree: in_degree[child] = 0\\n            \\n            in_degree[child] += 1\\n            # if is_left is true will be in 1st pos, else it will be inserted in right child\\n            g[parent][is_left] = child\\n        \\n        return [g, in_degree]\\n    \\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        g, in_degree = self.construct_graph_and_indegree(descriptions)\\n        root = None\\n        for vertex, in_deg in in_degree.items():\\n            if in_deg == 0:\\n                root = vertex\\n                break\\n        \\n        root_node = TreeNode(root)\\n        q = deque([root_node])\\n        while q:\\n            curr_node = q.popleft()\\n            if g[curr_node.val][0]:\\n                right_node = TreeNode(g[curr_node.val][0])\\n                curr_node.right = right_node\\n                q.append(right_node)\\n            if g[curr_node.val][1]:\\n                left_node = TreeNode(g[curr_node.val][1])\\n                curr_node.left = left_node\\n                q.append(left_node)\\n        return root_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823721,
                "title": "java-map",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n     Map<Integer,TreeNode>   nodes=new HashMap<>();\\n     Set<Integer> children= new HashSet<>();\\n     \\n        for(int []d:descriptions){\\n            nodes.putIfAbsent(d[0],new TreeNode(d[0]));\\n            \\n            nodes.putIfAbsent(d[1],new TreeNode(d[1]));\\n            if(d[2]==1){\\n                nodes.get(d[0]).left=nodes.get(d[1]);\\n            } else {\\n                nodes.get(d[0]).right=nodes.get(d[1]);\\n            }\\n            children.add(d[1]);\\n        }\\n        for(int key:nodes.keySet()){\\n            if(!children.contains(key)) return nodes.get(key);\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\n#  updated with comments and removed the set\\n```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        //create the map of node values\\n        Map < Integer, TreeNode > nodes = new HashMap < > ();\\n        for (int[] d: descriptions) {\\n            //create the parent node\\n            nodes.putIfAbsent(d[0], new TreeNode(d[0]));\\n            // create the child Node\\n            nodes.putIfAbsent(d[1], new TreeNode(d[1]));\\n\\n            if (d[2] == 1) {\\n                //   left child\\n                nodes.get(d[0]).left = nodes.get(d[1]);\\n            } else {\\n                //   right child\\n                nodes.get(d[0]).right = nodes.get(d[1]);\\n            }\\n\\n        }\\n        // remove children nodes from map \\n        for (int[] d: descriptions) {\\n            nodes.remove(d[1]);\\n        }\\n        // the only remaining node is root which is not a child of any node.\\n        return nodes.entrySet().iterator().next().getValue();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n     Map<Integer,TreeNode>   nodes=new HashMap<>();\\n     Set<Integer> children= new HashSet<>();\\n     \\n        for(int []d:descriptions){\\n            nodes.putIfAbsent(d[0],new TreeNode(d[0]));\\n            \\n            nodes.putIfAbsent(d[1],new TreeNode(d[1]));\\n            if(d[2]==1){\\n                nodes.get(d[0]).left=nodes.get(d[1]);\\n            } else {\\n                nodes.get(d[0]).right=nodes.get(d[1]);\\n            }\\n            children.add(d[1]);\\n        }\\n        for(int key:nodes.keySet()){\\n            if(!children.contains(key)) return nodes.get(key);\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        //create the map of node values\\n        Map < Integer, TreeNode > nodes = new HashMap < > ();\\n        for (int[] d: descriptions) {\\n            //create the parent node\\n            nodes.putIfAbsent(d[0], new TreeNode(d[0]));\\n            // create the child Node\\n            nodes.putIfAbsent(d[1], new TreeNode(d[1]));\\n\\n            if (d[2] == 1) {\\n                //   left child\\n                nodes.get(d[0]).left = nodes.get(d[1]);\\n            } else {\\n                //   right child\\n                nodes.get(d[0]).right = nodes.get(d[1]);\\n            }\\n\\n        }\\n        // remove children nodes from map \\n        for (int[] d: descriptions) {\\n            nodes.remove(d[1]);\\n        }\\n        // the only remaining node is root which is not a child of any node.\\n        return nodes.entrySet().iterator().next().getValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057195,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] arr) {\\n        HashSet<Integer> children = new HashSet<>();\\n        HashMap<Integer,TreeNode> hp = new HashMap<>();\\n\\n        int n = arr.length;\\n\\n        for(int i=0; i<n; i++){\\n            int parent = arr[i][0];\\n            int child = arr[i][1];\\n            int isLeft = arr[i][2];\\n\\n            children.add(child);\\n    \\n            TreeNode a = hp.getOrDefault(parent,new TreeNode(parent));\\n            \\n            if(isLeft==1){\\n                a.left = hp.getOrDefault(child, new TreeNode(child));\\n                hp.put(child,a.left);\\n            }else{\\n                a.right = hp.getOrDefault(child, new TreeNode(child));\\n                hp.put(child,a.right);\\n            }\\n            hp.put(parent,a);\\n        }\\n\\n        int root=-1;\\n\\n        for(int i=0; i<n; i++){\\n            if(!children.contains(arr[i][0])){\\n                root = arr[i][0];\\n                break;\\n            }\\n        }\\n        return hp.getOrDefault(root,null);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] arr) {\\n        HashSet<Integer> children = new HashSet<>();\\n        HashMap<Integer,TreeNode> hp = new HashMap<>();\\n\\n        int n = arr.length;\\n\\n        for(int i=0; i<n; i++){\\n            int parent = arr[i][0];\\n            int child = arr[i][1];\\n            int isLeft = arr[i][2];\\n\\n            children.add(child);\\n    \\n            TreeNode a = hp.getOrDefault(parent,new TreeNode(parent));\\n            \\n            if(isLeft==1){\\n                a.left = hp.getOrDefault(child, new TreeNode(child));\\n                hp.put(child,a.left);\\n            }else{\\n                a.right = hp.getOrDefault(child, new TreeNode(child));\\n                hp.put(child,a.right);\\n            }\\n            hp.put(parent,a);\\n        }\\n\\n        int root=-1;\\n\\n        for(int i=0; i<n; i++){\\n            if(!children.contains(arr[i][0])){\\n                root = arr[i][0];\\n                break;\\n            }\\n        }\\n        return hp.getOrDefault(root,null);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880634,
                "title": "bfs-o-n-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou Need to Know BFS, of a tree- The level Order Traversal\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        unordered_map<int,int>mp;\\n        unordered_map<int,pair<int,int>>mp1;\\n        // The root will never be present in des[i][1] the child, we will use map to find it.\\n        for(auto it : des){\\n            mp[it[1]]++;\\n        }\\n        \\n        int r;\\n        for(auto it : des){\\n            // To find the root\\n           if(mp.find(it[0])==mp.end()) r=it[0];\\n        //    we will map root to its left and right child , The is a pair where left is \\n        //    pair.first and right is pair.second .\\n           if(it[2])    mp1[it[0]].first = it[1];\\n           else    mp1[it[0]].second = it[1];\\n        }\\n        // the root\\n        TreeNode* root = new TreeNode(r);\\n        TreeNode* temp = root;\\n        // queue for BFS\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            r = q.front()->val;\\n            temp = q.front();\\n            q.pop();\\n            TreeNode* root_l=NULL , *root_r = NULL;\\n            if(mp1[r].first) {\\n                root_l = new TreeNode(mp1[r].first);\\n                q.push(root_l);\\n            }\\n            if(mp1[r].second){\\n                root_r = new TreeNode(mp1[r].second);\\n                q.push(root_r);\\n            }  \\n            temp->left = root_l;\\n            temp->right = root_r;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        unordered_map<int,int>mp;\\n        unordered_map<int,pair<int,int>>mp1;\\n        // The root will never be present in des[i][1] the child, we will use map to find it.\\n        for(auto it : des){\\n            mp[it[1]]++;\\n        }\\n        \\n        int r;\\n        for(auto it : des){\\n            // To find the root\\n           if(mp.find(it[0])==mp.end()) r=it[0];\\n        //    we will map root to its left and right child , The is a pair where left is \\n        //    pair.first and right is pair.second .\\n           if(it[2])    mp1[it[0]].first = it[1];\\n           else    mp1[it[0]].second = it[1];\\n        }\\n        // the root\\n        TreeNode* root = new TreeNode(r);\\n        TreeNode* temp = root;\\n        // queue for BFS\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            r = q.front()->val;\\n            temp = q.front();\\n            q.pop();\\n            TreeNode* root_l=NULL , *root_r = NULL;\\n            if(mp1[r].first) {\\n                root_l = new TreeNode(mp1[r].first);\\n                q.push(root_l);\\n            }\\n            if(mp1[r].second){\\n                root_r = new TreeNode(mp1[r].second);\\n                q.push(root_r);\\n            }  \\n            temp->left = root_l;\\n            temp->right = root_r;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773339,
                "title": "unordered-map-easy-c-beats-90",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Parent and Child** are given so it is easy to **create parent, child nodes and link them**. But here we are **not creating nodes again and again**, **to avoid this situation the created nodes will be stored in an unordered map**.\\n\\n**What do you think about the root node..........?**\\n`The root node never becomes a child node in the tree` **Use this statement to locate the root node**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n       unordered_map<int,TreeNode*> iscreated;\\n       unordered_map<int,bool> isparent;\\n       int n = d.size();\\n       for(int i = 0;i<n;i++)\\n       {\\n           TreeNode *parent, *child;\\n           if(iscreated.find(d[i][0])==iscreated.end())\\n           {\\n             parent = new TreeNode(d[i][0]);  \\n             iscreated[d[i][0]] = parent;\\n           }\\n           else parent = iscreated[d[i][0]];\\n           if(iscreated.find(d[i][1])==iscreated.end())\\n           {\\n             child = new TreeNode(d[i][1]);\\n             iscreated[d[i][1]] = child;\\n           }\\n           else child = iscreated[d[i][1]];\\n           if(d[i][2]) parent->left = child;\\n           else parent->right  =  child;\\n           isparent[d[i][1]] = true;\\n       }\\n       for(int i = 0;i<n;i++)\\n       if(isparent.find(d[i][0])==isparent.end()) return iscreated[d[i][0]];\\n       return NULL;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/f17d8e49-70c8-4ac2-a302-1f21b9d43ace_1689507000.9662292.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n       unordered_map<int,TreeNode*> iscreated;\\n       unordered_map<int,bool> isparent;\\n       int n = d.size();\\n       for(int i = 0;i<n;i++)\\n       {\\n           TreeNode *parent, *child;\\n           if(iscreated.find(d[i][0])==iscreated.end())\\n           {\\n             parent = new TreeNode(d[i][0]);  \\n             iscreated[d[i][0]] = parent;\\n           }\\n           else parent = iscreated[d[i][0]];\\n           if(iscreated.find(d[i][1])==iscreated.end())\\n           {\\n             child = new TreeNode(d[i][1]);\\n             iscreated[d[i][1]] = child;\\n           }\\n           else child = iscreated[d[i][1]];\\n           if(d[i][2]) parent->left = child;\\n           else parent->right  =  child;\\n           isparent[d[i][1]] = true;\\n       }\\n       for(int i = 0;i<n;i++)\\n       if(isparent.find(d[i][0])==isparent.end()) return iscreated[d[i][0]];\\n       return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335634,
                "title": "c-simple-but-effective-using-unordered-map-int-treenode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n                  TreeNode* root = NULL;\\n                 unordered_map<int,TreeNode*>m1;\\n                 unordered_map<int,int>m2;\\nTreeNode* out=NULL;\\nTreeNode* temp = NULL;\\n\\n                  for(int i=0;i<descriptions.size();i++){\\n                             int par = descriptions[i][0];\\n                             int chil = descriptions[i][1];\\n                             TreeNode* temp_1 = NULL;\\n                             TreeNode* temp_2 = NULL;\\n                             if(m1[par]==0){\\n                                   temp_1 = new TreeNode(par);\\n                                   m1[par]=temp_1;\\n                                  \\n                             }\\n                             else{\\n                                 temp_1 = m1[par];\\n                                  \\n                             }\\n                             if(m1[chil]==0){\\n                                  temp_2 = new TreeNode(chil);\\n                                   m1[chil]=temp_2;\\n                                   m2[chil]=1;\\n                             }\\n                             else{\\n                                  temp_2 = m1[chil];\\n                                   m2[chil]=1;\\n                             }\\n                             if(descriptions[i][2]==1){\\n                                 temp_1->left = temp_2;\\n                             }\\n                             else{\\n                                 temp_1->right = temp_2;\\n                             }\\n\\n            \\n             }\\n          for(int i=0;i<descriptions.size();i++){\\n              if(m2[descriptions[i][0]]==0){\\n                  return m1[descriptions[i][0]];\\n              }\\n          }\\n          return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n                  TreeNode* root = NULL;\\n                 unordered_map<int,TreeNode*>m1;\\n                 unordered_map<int,int>m2;\\nTreeNode* out=NULL;\\nTreeNode* temp = NULL;\\n\\n                  for(int i=0;i<descriptions.size();i++){\\n                             int par = descriptions[i][0];\\n                             int chil = descriptions[i][1];\\n                             TreeNode* temp_1 = NULL;\\n                             TreeNode* temp_2 = NULL;\\n                             if(m1[par]==0){\\n                                   temp_1 = new TreeNode(par);\\n                                   m1[par]=temp_1;\\n                                  \\n                             }\\n                             else{\\n                                 temp_1 = m1[par];\\n                                  \\n                             }\\n                             if(m1[chil]==0){\\n                                  temp_2 = new TreeNode(chil);\\n                                   m1[chil]=temp_2;\\n                                   m2[chil]=1;\\n                             }\\n                             else{\\n                                  temp_2 = m1[chil];\\n                                   m2[chil]=1;\\n                             }\\n                             if(descriptions[i][2]==1){\\n                                 temp_1->left = temp_2;\\n                             }\\n                             else{\\n                                 temp_1->right = temp_2;\\n                             }\\n\\n            \\n             }\\n          for(int i=0;i<descriptions.size();i++){\\n              if(m2[descriptions[i][0]]==0){\\n                  return m1[descriptions[i][0]];\\n              }\\n          }\\n          return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201298,
                "title": "easiest-solution-step-by-step-explanation",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        TreeNode* createBinaryTree(vector<vector < int>> &d)\\n        {\\n            unordered_set<int> s;\\n            for (int i = 0; i < d.size(); i++)//Finding all eligible candidates for root.\\n                s.insert(d[i][0]);\\n\\n            for (int i = 0; i < d.size(); i++)//Eliminating all Un-eligible candidates.\\n                s.erase(d[i][1]);\\n\\n            TreeNode *root = new TreeNode(*s.begin());\\n            unordered_map<int, pair<int, int>> m;\\n\\n            for (int i = 0; i < d.size(); i++)//Creating map using values to find childrens in constant time(Since all values are unique).\\n            {\\n                if (m.find(d[i][0]) == m.end())\\n                    m[d[i][0]] = { i,-1 };\\n                else\\n                    m[d[i][0]].second = i;\\n            }\\n            queue<TreeNode*> q;//Performing BFS\\n            q.push(root);\\n            while (q.size())\\n            {\\n                int n = q.size();\\n                for (int i = 0; i < n; i++)\\n                {\\n                    TreeNode *x = q.front();\\n                    q.pop();\\n                    int a = -1, b = -1;\\n                    if (m.find(x->val) != m.end())\\n                    {\\n                        a = m[x->val].first;\\n                        b = m[x->val].second;\\n                    }\\n                    if (a != -1)\\n                        if (d[a][2] == 1) x->left = new TreeNode(d[a][1]);\\n                        else x->right = new TreeNode(d[a][1]);\\n                    if (b != -1)\\n                        if (d[b][2] == 1) x->left = new TreeNode(d[b][1]);\\n                        else x->right = new TreeNode(d[b][1]);\\n                    if (x->left) q.push(x->left);\\n                    if (x->right) q.push(x->right);\\n                }\\n            }\\n            return root;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        TreeNode* createBinaryTree(vector<vector < int>> &d)\\n        {\\n            unordered_set<int> s;\\n            for (int i = 0; i < d.size(); i++)//Finding all eligible candidates for root.\\n                s.insert(d[i][0]);\\n\\n            for (int i = 0; i < d.size(); i++)//Eliminating all Un-eligible candidates.\\n                s.erase(d[i][1]);\\n\\n            TreeNode *root = new TreeNode(*s.begin());\\n            unordered_map<int, pair<int, int>> m;\\n\\n            for (int i = 0; i < d.size(); i++)//Creating map using values to find childrens in constant time(Since all values are unique).\\n            {\\n                if (m.find(d[i][0]) == m.end())\\n                    m[d[i][0]] = { i,-1 };\\n                else\\n                    m[d[i][0]].second = i;\\n            }\\n            queue<TreeNode*> q;//Performing BFS\\n            q.push(root);\\n            while (q.size())\\n            {\\n                int n = q.size();\\n                for (int i = 0; i < n; i++)\\n                {\\n                    TreeNode *x = q.front();\\n                    q.pop();\\n                    int a = -1, b = -1;\\n                    if (m.find(x->val) != m.end())\\n                    {\\n                        a = m[x->val].first;\\n                        b = m[x->val].second;\\n                    }\\n                    if (a != -1)\\n                        if (d[a][2] == 1) x->left = new TreeNode(d[a][1]);\\n                        else x->right = new TreeNode(d[a][1]);\\n                    if (b != -1)\\n                        if (d[b][2] == 1) x->left = new TreeNode(d[b][1]);\\n                        else x->right = new TreeNode(d[b][1]);\\n                    if (x->left) q.push(x->left);\\n                    if (x->right) q.push(x->right);\\n                }\\n            }\\n            return root;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173517,
                "title": "python-easy-to-read-tree-reconstruct",
                "content": "```python\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        nodes = {}\\n        childs = set()\\n        parents = set()\\n\\n        for parent, child, left in descriptions:\\n            childs.add(child)\\n            parents.add(parent)\\n            \\n            if parent in nodes:\\n                node = nodes[parent]\\n            else:\\n                node = TreeNode(parent)\\n                nodes[parent] = node\\n\\n            if child in nodes:\\n                cnode = nodes[child]\\n            else:\\n                cnode = TreeNode(child)\\n                nodes[child] = cnode\\n\\n            if left:\\n                node.left = cnode\\n            else:\\n                node.right = cnode\\n\\n        return nodes[list(parents - childs)[0]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        nodes = {}\\n        childs = set()\\n        parents = set()\\n\\n        for parent, child, left in descriptions:\\n            childs.add(child)\\n            parents.add(parent)\\n            \\n            if parent in nodes:\\n                node = nodes[parent]\\n            else:\\n                node = TreeNode(parent)\\n                nodes[parent] = node\\n\\n            if child in nodes:\\n                cnode = nodes[child]\\n            else:\\n                cnode = TreeNode(child)\\n                nodes[child] = cnode\\n\\n            if left:\\n                node.left = cnode\\n            else:\\n                node.right = cnode\\n\\n        return nodes[list(parents - childs)[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093818,
                "title": "beats-92-hashmap-hashset-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_set<int>st;\\n        for(int i=0;i<descriptions.size();i++){\\n            if(mp.find(descriptions[i][0])==mp.end()){\\n                mp[descriptions[i][0]]=new TreeNode(descriptions[i][0]);\\n            }\\n            if(mp.find(descriptions[i][1])==mp.end()){\\n                mp[descriptions[i][1]]=new TreeNode(descriptions[i][1]);\\n            }\\n            st.insert(descriptions[i][1]);\\n            TreeNode* parent=mp[descriptions[i][0]],*child=mp[descriptions[i][1]];\\n            descriptions[i][2]==1?parent->left=child:parent->right=child;\\n        }\\n\\n        for(int i=0;i<descriptions.size();i++){\\n            if(st.find(descriptions[i][0])==st.end())return mp[descriptions[i][0]];\\n        }\\n        return NULL;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_set<int>st;\\n        for(int i=0;i<descriptions.size();i++){\\n            if(mp.find(descriptions[i][0])==mp.end()){\\n                mp[descriptions[i][0]]=new TreeNode(descriptions[i][0]);\\n            }\\n            if(mp.find(descriptions[i][1])==mp.end()){\\n                mp[descriptions[i][1]]=new TreeNode(descriptions[i][1]);\\n            }\\n            st.insert(descriptions[i][1]);\\n            TreeNode* parent=mp[descriptions[i][0]],*child=mp[descriptions[i][1]];\\n            descriptions[i][2]==1?parent->left=child:parent->right=child;\\n        }\\n\\n        for(int i=0;i<descriptions.size();i++){\\n            if(st.find(descriptions[i][0])==st.end())return mp[descriptions[i][0]];\\n        }\\n        return NULL;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431225,
                "title": "c-hashing-map-easy-to-underdstand",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) \\n    {\\n        unordered_map<int,TreeNode*> getnode;\\n        unordered_map<int,bool> ischild;     //to check if node has parent or not \\n        for(auto &v:descriptions)\\n        {\\n            if(getnode.count(v[0])==0)\\n            {\\n                TreeNode* par=new TreeNode(v[0]);\\n                getnode[v[0]]=par;\\n            }\\n            if(getnode.count(v[1])==0)\\n            {\\n                TreeNode* child=new TreeNode(v[1]);\\n                getnode[v[1]]=child;\\n            }\\n            if(v[2]==1)\\n            {\\n                getnode[v[0]]->left=getnode[v[1]];\\n            }\\n            else\\n            {\\n                getnode[v[0]]->right=getnode[v[1]];\\n            }\\n            ischild[v[1]]=true;\\n        }\\n        TreeNode * res=NULL;\\n        for(auto &v:descriptions)\\n        {\\n            if(ischild[v[0]]!=true)\\n            {\\n                res=getnode[v[0]];\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) \\n    {\\n        unordered_map<int,TreeNode*> getnode;\\n        unordered_map<int,bool> ischild;     //to check if node has parent or not \\n        for(auto &v:descriptions)\\n        {\\n            if(getnode.count(v[0])==0)\\n            {\\n                TreeNode* par=new TreeNode(v[0]);\\n                getnode[v[0]]=par;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2405040,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using BFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        \\n        int n = descriptions.size();\\n        \\n        unordered_set<int> child;\\n        \\n        unordered_map<int, vector<pair<int, int>>> mp;\\n        \\n        // insert all the child into child set\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            child.insert(descriptions[i][1]);\\n            \\n            mp[descriptions[i][0]].push_back({descriptions[i][1], descriptions[i][2]});\\n        }\\n        \\n        // first of all find the root of tree\\n        \\n        // root is the node which is parent for some node but does not present as child for any node\\n        \\n        int root_of_tree = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(child.count(descriptions[i][0]) == 0)\\n            {\\n                root_of_tree = descriptions[i][0];\\n                \\n                break;\\n            }\\n        }\\n        \\n        // apply bfs and create tree\\n       \\n        queue<TreeNode*> q;\\n        \\n        // create root and push into queue\\n        \\n        TreeNode* root = new TreeNode(root_of_tree);\\n        \\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            // take out the front node\\n            \\n            TreeNode* curr = q.front();\\n            \\n            q.pop();\\n            \\n            // find the left child and right child for curr node\\n            \\n            int left_child = -1;\\n            \\n            int right_child = -1;\\n            \\n            if(mp[curr -> val].size() > 0 && mp[curr -> val][0].second == 1)\\n            {\\n                left_child = mp[curr -> val][0].first;\\n            }\\n            else if(mp[curr -> val].size() > 0 && mp[curr -> val][0].second == 0)\\n            {\\n                right_child = mp[curr -> val][0].first;\\n            }\\n            \\n            if(mp[curr -> val].size() > 1 && mp[curr -> val][1].second == 1)\\n            {\\n                left_child = mp[curr -> val][1].first;\\n            }\\n            else if(mp[curr -> val].size() > 1 && mp[curr -> val][1].second == 0)\\n            {\\n                right_child = mp[curr -> val][1].first;\\n            }\\n            \\n            // if left child is present then create left child and push into queue\\n          \\n            if(left_child != -1)\\n            {\\n                curr -> left = new TreeNode(left_child);\\n                \\n                q.push(curr -> left);\\n            }\\n            \\n            // if right child is present then craete right child and push into queue\\n            \\n            if(right_child != -1)\\n            {\\n                curr -> right = new TreeNode(right_child);\\n                \\n                q.push(curr -> right);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        \\n        int n = descriptions.size();\\n        \\n        unordered_set<int> child;\\n        \\n        unordered_map<int, vector<pair<int, int>>> mp;\\n        \\n        // insert all the child into child set\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            child.insert(descriptions[i][1]);\\n            \\n            mp[descriptions[i][0]].push_back({descriptions[i][1], descriptions[i][2]});\\n        }\\n        \\n        // first of all find the root of tree\\n        \\n        // root is the node which is parent for some node but does not present as child for any node\\n        \\n        int root_of_tree = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(child.count(descriptions[i][0]) == 0)\\n            {\\n                root_of_tree = descriptions[i][0];\\n                \\n                break;\\n            }\\n        }\\n        \\n        // apply bfs and create tree\\n       \\n        queue<TreeNode*> q;\\n        \\n        // create root and push into queue\\n        \\n        TreeNode* root = new TreeNode(root_of_tree);\\n        \\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            // take out the front node\\n            \\n            TreeNode* curr = q.front();\\n            \\n            q.pop();\\n            \\n            // find the left child and right child for curr node\\n            \\n            int left_child = -1;\\n            \\n            int right_child = -1;\\n            \\n            if(mp[curr -> val].size() > 0 && mp[curr -> val][0].second == 1)\\n            {\\n                left_child = mp[curr -> val][0].first;\\n            }\\n            else if(mp[curr -> val].size() > 0 && mp[curr -> val][0].second == 0)\\n            {\\n                right_child = mp[curr -> val][0].first;\\n            }\\n            \\n            if(mp[curr -> val].size() > 1 && mp[curr -> val][1].second == 1)\\n            {\\n                left_child = mp[curr -> val][1].first;\\n            }\\n            else if(mp[curr -> val].size() > 1 && mp[curr -> val][1].second == 0)\\n            {\\n                right_child = mp[curr -> val][1].first;\\n            }\\n            \\n            // if left child is present then create left child and push into queue\\n          \\n            if(left_child != -1)\\n            {\\n                curr -> left = new TreeNode(left_child);\\n                \\n                q.push(curr -> left);\\n            }\\n            \\n            // if right child is present then craete right child and push into queue\\n            \\n            if(right_child != -1)\\n            {\\n                curr -> right = new TreeNode(right_child);\\n                \\n                q.push(curr -> right);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382738,
                "title": "c-map-easy",
                "content": "Idea :\\nCreating a map of int,vector<pair> this will store for every parent its left and right child if exists, i am doing this so that it becomes easy to access,\\n\\nI am also creating set which stores all childs, and it we look in this set it will not contain the root of the tree, so we iterate over the first map and check if the key exists or not, if not then we are sure that is root of the tree, else we remove that key from set.\\n\\nAll leftovers are leaf nodes in the tree, i insert in the first map as key,{-1,-1} so that during recursion we can know in constant time if this is left or not and return,\\n\\nRest of the code is self-explanatory\\n\\nHere Goes the code\\n```\\nclass Solution {\\n    void createTree(TreeNode*&root,int parent,unordered_map<int,vector<pair<int,int>>>&mp){\\n        for(auto&it:mp[parent]){\\n            if(it.first==-1){\\n                return;\\n            }\\n            else{\\n                    if(it.second==1){\\n                        root->left=new TreeNode(it.first);\\n                        createTree(root->left,it.first,mp);\\n                    }\\n                    else{\\n                        root->right=new TreeNode(it.first);\\n                        createTree(root->right,it.first,mp);\\n                    }\\n            }\\n        }\\n    }\\n    \\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        unordered_map<int,vector<pair<int,int>>>mp;\\n        unordered_set<int>st;\\n        for(auto&it:d){\\n            st.insert(it[1]);\\n            mp[it[0]].push_back({it[1],it[2]});\\n        }\\n        \\n        int parent=-1;\\n        for(auto&it:mp){\\n            if(st.find(it.first)==st.end()){\\n                parent=it.first;\\n            }\\n            else{\\n                st.erase(it.first);\\n            }\\n        }\\n        \\n        for(auto&it:st){\\n            mp[it].push_back({-1,-1});\\n        }\\n        \\n        TreeNode*root=new TreeNode(parent);\\n        createTree(root,parent,mp);\\n        return root;\\n    }\\n};\\n```\\n\\n***Please upvote if you understood the solution, Comment in case of any questions***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void createTree(TreeNode*&root,int parent,unordered_map<int,vector<pair<int,int>>>&mp){\\n        for(auto&it:mp[parent]){\\n            if(it.first==-1){\\n                return;\\n            }\\n            else{\\n                    if(it.second==1){\\n                        root->left=new TreeNode(it.first);\\n                        createTree(root->left,it.first,mp);\\n                    }\\n                    else{\\n                        root->right=new TreeNode(it.first);\\n                        createTree(root->right,it.first,mp);\\n                    }\\n            }\\n        }\\n    }\\n    \\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        unordered_map<int,vector<pair<int,int>>>mp;\\n        unordered_set<int>st;\\n        for(auto&it:d){\\n            st.insert(it[1]);\\n            mp[it[0]].push_back({it[1],it[2]});\\n        }\\n        \\n        int parent=-1;\\n        for(auto&it:mp){\\n            if(st.find(it.first)==st.end()){\\n                parent=it.first;\\n            }\\n            else{\\n                st.erase(it.first);\\n            }\\n        }\\n        \\n        for(auto&it:st){\\n            mp[it].push_back({-1,-1});\\n        }\\n        \\n        TreeNode*root=new TreeNode(parent);\\n        createTree(root,parent,mp);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373917,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& desc) {\\n        unordered_map<int,bool>isChild;\\n        unordered_map<int,TreeNode*>mp;\\n        for(auto x:desc){\\n            if(mp.find(x[0]) == mp.end()){\\n                TreeNode*node = new TreeNode(x[0]);\\n                mp[x[0]] = node;\\n            }\\n            \\n            if(mp.find(x[1]) == mp.end()){\\n                TreeNode *child = new TreeNode(x[1]);\\n                mp[x[1]] = child;\\n            }\\n            \\n            if(x[2] == 1) mp[x[0]]->left = mp[x[1]];\\n            if(x[2] == 0) mp[x[0]]->right = mp[x[1]];\\n            isChild[x[1]] = true;\\n        }\\n        \\n        TreeNode*ans = NULL;\\n        for(auto x:desc){\\n            if(isChild[x[0]] == false){\\n                ans = mp[x[0]];\\n                return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& desc) {\\n        unordered_map<int,bool>isChild;\\n        unordered_map<int,TreeNode*>mp;\\n        for(auto x:desc){\\n            if(mp.find(x[0]) == mp.end()){\\n                TreeNode*node = new TreeNode(x[0]);\\n                mp[x[0]] = node;\\n            }\\n            \\n            if(mp.find(x[1]) == mp.end()){\\n                TreeNode *child = new TreeNode(x[1]);\\n                mp[x[1]] = child;\\n            }\\n            \\n            if(x[2] == 1) mp[x[0]]->left = mp[x[1]];\\n            if(x[2] == 0) mp[x[0]]->right = mp[x[1]];\\n            isChild[x[1]] = true;\\n        }\\n        \\n        TreeNode*ans = NULL;\\n        for(auto x:desc){\\n            if(isChild[x[0]] == false){\\n                ans = mp[x[0]];\\n                return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328369,
                "title": "python-solution-easy-to-understand-o-v-e",
                "content": "Basically while we\\'re building the Trees, we keep track of the parent and child nodes.\\nAfter we\\'ve built all the trees, the root node is the only parent node that isn\\'t also a child.\\nThis is accurately represented by the set difference operation between the parent set and the children set.\\n```python\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        adj = {}\\n        parent_set = set()\\n        children_set = set()\\n        \\n        for parent, child, isLeft in descriptions:\\n            # if the nodes haven\\'t been created already\\n            if parent not in adj:\\n                adj[parent] = TreeNode(parent)\\n            if child not in adj:\\n                adj[child] = TreeNode(child)\\n            # determines the direction of the child in parent node\\n            if isLeft:\\n                adj[parent].left = adj[child]\\n            else:\\n                adj[parent].right = adj[child]\\n            # adds parent and child to thier respective sets\\n            parent_set.add(parent)\\n            children_set.add(child)\\n        return adj[(parent_set-children_set).pop()]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        adj = {}\\n        parent_set = set()\\n        children_set = set()\\n        \\n        for parent, child, isLeft in descriptions:\\n            # if the nodes haven\\'t been created already\\n            if parent not in adj:\\n                adj[parent] = TreeNode(parent)\\n            if child not in adj:\\n                adj[child] = TreeNode(child)\\n            # determines the direction of the child in parent node\\n            if isLeft:\\n                adj[parent].left = adj[child]\\n            else:\\n                adj[parent].right = adj[child]\\n            # adds parent and child to thier respective sets\\n            parent_set.add(parent)\\n            children_set.add(child)\\n        return adj[(parent_set-children_set).pop()]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239861,
                "title": "python-o-n-time-o-n-sapce",
                "content": "The **hasParent** variable was set, I have no idea why set performed much worse than dict.\\n\\n```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        hasParent = dict()\\n        nodeMap = dict()\\n        \\n        for m in descriptions:\\n            if m[1] not in nodeMap: nodeMap[m[1]] = TreeNode(m[1])\\n            if m[0] not in nodeMap: nodeMap[m[0]] = TreeNode(m[0])\\n            hasParent[m[1]] = True\\n            \\n            if m[2] == 1: \\n                nodeMap[m[0]].left = nodeMap[m[1]]\\n            else:\\n                nodeMap[m[0]].right = nodeMap[m[1]]\\n            \\n        for m in descriptions: \\n            if m[0] not in hasParent: \\n                return nodeMap[m[0]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        hasParent = dict()\\n        nodeMap = dict()\\n        \\n        for m in descriptions:\\n            if m[1] not in nodeMap: nodeMap[m[1]] = TreeNode(m[1])\\n            if m[0] not in nodeMap: nodeMap[m[0]] = TreeNode(m[0])\\n            hasParent[m[1]] = True\\n            \\n            if m[2] == 1: \\n                nodeMap[m[0]].left = nodeMap[m[1]]\\n            else:\\n                nodeMap[m[0]].right = nodeMap[m[1]]\\n            \\n        for m in descriptions: \\n            if m[0] not in hasParent: \\n                return nodeMap[m[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218216,
                "title": "c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n       TreeNode* root = nullptr;\\n        map<int,TreeNode*> mp;\\n        for(auto& des : descriptions) {\\n            TreeNode* temp = new TreeNode(des[1]);\\n            mp[des[1]] =  temp ;\\n        }\\n        for(auto &des : descriptions) {\\n            if(mp.find(des[0]) == mp.end()) {\\n                root = new TreeNode(des[0]);\\n                mp[des[0]] = root;\\n            }\\n            TreeNode* parent = mp[des[0]];\\n            TreeNode* cur =  mp[des[1]];\\n            if(des[2] == 1){\\n                parent->left = cur;\\n            }else{\\n                parent->right = cur;\\n            }\\n        }\\n        return root;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n       TreeNode* root = nullptr;\\n        map<int,TreeNode*> mp;\\n        for(auto& des : descriptions) {\\n            TreeNode* temp = new TreeNode(des[1]);\\n            mp[des[1]] =  temp ;\\n        }\\n        for(auto &des : descriptions) {\\n            if(mp.find(des[0]) == mp.end()) {\\n                root = new TreeNode(des[0]);\\n                mp[des[0]] = root;\\n            }\\n            TreeNode* parent = mp[des[0]];\\n            TreeNode* cur =  mp[des[1]];\\n            if(des[2] == 1){\\n                parent->left = cur;\\n            }else{\\n                parent->right = cur;\\n            }\\n        }\\n        return root;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185837,
                "title": "easy-c-solution-self-explanatory-with-detailed-comments",
                "content": "``` \\n1. Create HashMap of key: nodeValue  value: NodePtr\\n2. For every parent, child check if they (value) is present in the HashMap.\\n3. If they are not present then create both parentNode and childNode and insert them into the HashMap with key=nodeValue value=NodePointer\\n4. Link parentNodePtr\\'s left or right to , ChildNodePtr  (leftChild or rightChild is decided on the input vector value)\\n5. Once the entier tree is constructed then find the rootNode to return using the below technique:\\n\\t5.1. RootNode is the only node which doesn\\'t have the parent.\\n\\t5.2. So loop through the input vector once again and keep removing the childNode i.e inputVector[1] from the HashMap.\\n\\t5.3. At the end there will be only one node leftout in the HashMap, so return that element as it\\'s the root.\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) \\n    {\\n        unordered_map<int, TreeNode*> nodePtrMap;\\n        \\n        if (descriptions.size() == 0)\\n        {\\n            return NULL;\\n        }\\n        \\n        //for (int i=0; i<descriptions.size(); i++)\\n        for (auto d:descriptions)\\n        {\\n            if (d.size() != 3)\\n            {\\n                assert(\"INVALID INPUT\");\\n            }\\n            \\n            int p = d[0];\\n            int c = d[1];\\n            bool isLeft = (d[2])?true:false;\\n            TreeNode *parent = NULL;\\n            TreeNode *child = NULL;\\n            \\n            // Check if parent already created by looking up the HT\\n            if (nodePtrMap.find(p) != nodePtrMap.end())\\n            {\\n                parent = (TreeNode*) nodePtrMap.find(p)->second;\\n            }\\n            else\\n            {\\n                // create the new parent and add it to the hashtable\\n                parent = new TreeNode(p);\\n                nodePtrMap.insert(make_pair(p, parent));\\n            }\\n            \\n            // Check if child already created by looking up the HT\\n            if (nodePtrMap.find(c) != nodePtrMap.end())\\n            {\\n                child = (TreeNode*) nodePtrMap.find(c)->second;\\n            }\\n            else\\n            {\\n                // create the new parent and add it to the hashtable\\n                child = new TreeNode(c);\\n                nodePtrMap.insert(make_pair(c, child));\\n            }\\n            \\n            \\n            // link parent -> child \\n            if (isLeft)\\n            {\\n                parent->left = child;\\n            }\\n            else\\n            {\\n                parent->right=child;\\n            }\\n        }\\n        \\n        \\n        // Find the rootNode. \\n        // RootNode = node which doesn\\'t have any parent.\\n        // so remove all children which has a parent node from the nodePtrMap unordered_map \\n        // and the only one leftout in the map will be the rootNode\\n        for (auto d:descriptions)\\n        {\\n            int c = d[1];\\n            nodePtrMap.erase(c);\\n        }\\n        \\n        unordered_map<int, TreeNode*>::iterator it = nodePtrMap.begin();\\n        return it->second;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) \\n    {\\n        unordered_map<int, TreeNode*> nodePtrMap;\\n        \\n        if (descriptions.size() == 0)\\n        {\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2162621,
                "title": "python3-solution-with-using-hashmap-and-hashset",
                "content": "```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        val2node = {}\\n        child_set = set()\\n        parent_set = set()\\n        \\n        for parent_val, child_val, is_left in descriptions:\\n            if child_val not in val2node:\\n                val2node[child_val] = TreeNode(child_val)\\n            \\n            if parent_val not in val2node:\\n                val2node[parent_val] = TreeNode(parent_val)\\n                \\n            if is_left == 1:\\n                val2node[parent_val].left = val2node[child_val]\\n            else:\\n                val2node[parent_val].right = val2node[child_val]\\n            \\n            child_set.add(child_val)\\n            parent_set.discard(child_val)\\n            \\n            if parent_val not in child_set:\\n                parent_set.add(parent_val)\\n            else:\\n                parent_set.discard(parent_val)\\n\\n        return val2node[parent_set.pop()]\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        val2node = {}\\n        child_set = set()\\n        parent_set = set()\\n        \\n        for parent_val, child_val, is_left in descriptions:\\n            if child_val not in val2node:\\n                val2node[child_val] = TreeNode(child_val)\\n            \\n            if parent_val not in val2node:\\n                val2node[parent_val] = TreeNode(parent_val)\\n                \\n            if is_left == 1:\\n                val2node[parent_val].left = val2node[child_val]\\n            else:\\n                val2node[parent_val].right = val2node[child_val]\\n            \\n            child_set.add(child_val)\\n            parent_set.discard(child_val)\\n            \\n            if parent_val not in child_set:\\n                parent_set.add(parent_val)\\n            else:\\n                parent_set.discard(parent_val)\\n\\n        return val2node[parent_set.pop()]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142760,
                "title": "simple-c-solution-using-hashmap-unordered-map",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n\\t// we use the hashmap with keys as values of the nodes as it will help us to get the pointer to the node by giving the current value\\n        unordered_map<int, TreeNode*> hashmap;\\n\\t// We use another map for storing the parents of all nodes, this is useful to get the root after the tree is constructed as the root will have no parent\\n        unordered_map<TreeNode*, TreeNode*> pr;\\n        int n = descriptions.size();\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t// Check if the current node is already present in hashmap\\n\\t\\t// if not then create the node else get the pointer to the node using hashmap\\n            if(hashmap.find(descriptions[i][0]) == hashmap.end())\\n            {\\n                TreeNode* cur = new TreeNode(descriptions[i][0]);\\n\\t\\t\\t\\t// add the parent to the hashmap\\n                hashmap[descriptions[i][0]] = cur;\\n\\t\\t\\t\\t// check if child node is already created\\n\\t\\t\\t\\t// if not then create the child node else get the pointer to the node using the child\\'s value\\n                if(hashmap.find(descriptions[i][1]) == hashmap.end())\\n                {\\n                    TreeNode* child = new TreeNode(descriptions[i][1]);\\n\\t\\t\\t\\t\\t// add the child to the hashmap\\n                    hashmap[descriptions[i][1]] = child;\\n\\t\\t\\t\\t\\t// add the parent of the child\\n                    pr[child] = cur;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// make the child to the left or right of the parent according to given value\\n                    if(descriptions[i][2])\\n                    {\\n                        cur->left = child;\\n                    }\\n                    else\\n                    {\\n                        cur->right = child;\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* child = hashmap[descriptions[i][1]];\\n                    pr[child] = cur;\\n                    if(descriptions[i][2])\\n                    {\\n                        cur->left = child;\\n                    }\\n                    else\\n                    {\\n                        cur->right = child;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                TreeNode* parent = hashmap[descriptions[i][0]];\\n                if(hashmap.find(descriptions[i][1]) == hashmap.end())\\n                {\\n                    TreeNode* child = new TreeNode(descriptions[i][1]);\\n                    hashmap[descriptions[i][1]] = child;\\n                    pr[child] = parent;\\n                    if(descriptions[i][2])\\n                    {\\n                        parent->left = child;\\n                    }\\n                    else\\n                    {\\n                        parent->right = child;\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* child = hashmap[descriptions[i][1]];\\n                    pr[child] = parent;\\n                    if(descriptions[i][2])\\n                    {\\n                        parent->left = child;\\n                    }\\n                    else\\n                    {\\n                        parent->right = child;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(auto i : hashmap)\\n        {\\n            if(!pr[i.second])\\n                return i.second;\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n\\t// we use the hashmap with keys as values of the nodes as it will help us to get the pointer to the node by giving the current value\\n        unordered_map<int, TreeNode*> hashmap;\\n\\t// We use another map for storing the parents of all nodes, this is useful to get the root after the tree is constructed as the root will have no parent\\n        unordered_map<TreeNode*, TreeNode*> pr;\\n        int n = descriptions.size();\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t// Check if the current node is already present in hashmap\\n\\t\\t// if not then create the node else get the pointer to the node using hashmap\\n            if(hashmap.find(descriptions[i][0]) == hashmap.end())\\n            {\\n                TreeNode* cur = new TreeNode(descriptions[i][0]);\\n\\t\\t\\t\\t// add the parent to the hashmap\\n                hashmap[descriptions[i][0]] = cur;\\n\\t\\t\\t\\t// check if child node is already created\\n\\t\\t\\t\\t// if not then create the child node else get the pointer to the node using the child\\'s value\\n                if(hashmap.find(descriptions[i][1]) == hashmap.end())\\n                {\\n                    TreeNode* child = new TreeNode(descriptions[i][1]);\\n\\t\\t\\t\\t\\t// add the child to the hashmap\\n                    hashmap[descriptions[i][1]] = child;\\n\\t\\t\\t\\t\\t// add the parent of the child\\n                    pr[child] = cur;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// make the child to the left or right of the parent according to given value\\n                    if(descriptions[i][2])\\n                    {\\n                        cur->left = child;\\n                    }\\n                    else\\n                    {\\n                        cur->right = child;\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* child = hashmap[descriptions[i][1]];\\n                    pr[child] = cur;\\n                    if(descriptions[i][2])\\n                    {\\n                        cur->left = child;\\n                    }\\n                    else\\n                    {\\n                        cur->right = child;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                TreeNode* parent = hashmap[descriptions[i][0]];\\n                if(hashmap.find(descriptions[i][1]) == hashmap.end())\\n                {\\n                    TreeNode* child = new TreeNode(descriptions[i][1]);\\n                    hashmap[descriptions[i][1]] = child;\\n                    pr[child] = parent;\\n                    if(descriptions[i][2])\\n                    {\\n                        parent->left = child;\\n                    }\\n                    else\\n                    {\\n                        parent->right = child;\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* child = hashmap[descriptions[i][1]];\\n                    pr[child] = parent;\\n                    if(descriptions[i][2])\\n                    {\\n                        parent->left = child;\\n                    }\\n                    else\\n                    {\\n                        parent->right = child;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(auto i : hashmap)\\n        {\\n            if(!pr[i.second])\\n                return i.second;\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133569,
                "title": "c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> ump;\\n        for(int i = 0; i < descriptions.size(); ++i){\\n            if(ump.find(descriptions[i][0]) == ump.end()){\\n                TreeNode* newNode = new TreeNode(descriptions[i][0]);\\n                if(ump.find(descriptions[i][1]) == ump.end()){\\n                    TreeNode* childNode = new TreeNode(descriptions[i][1]);\\n                    if(descriptions[i][2] == 1)\\n                        newNode->left = childNode;\\n                    else\\n                        newNode->right = childNode;\\n                    ump[descriptions[i][1]] = childNode;\\n                }\\n                else{\\n                    if(descriptions[i][2] == 1)\\n                        newNode->left = ump[descriptions[i][1]];\\n                    else\\n                        newNode->right = ump[descriptions[i][1]];\\n                }\\n                ump[descriptions[i][0]] = newNode;\\n            }\\n            else{\\n                if(ump.find(descriptions[i][1]) == ump.end()){\\n                    TreeNode* childNode = new TreeNode(descriptions[i][1]);\\n                    if(descriptions[i][2] == 1)\\n                        ump[descriptions[i][0]]->left = childNode;\\n                    else\\n                        ump[descriptions[i][0]]->right = childNode;\\n                    ump[descriptions[i][1]] = childNode;\\n                }\\n                else{\\n                    if(descriptions[i][2] == 1)\\n                        ump[descriptions[i][0]]->left = ump[descriptions[i][1]];\\n                    else\\n                        ump[descriptions[i][0]]->right = ump[descriptions[i][1]];\\n                }\\n            }\\n        }\\n        unordered_map<int, int> temp;\\n        for(int i = 0; i < descriptions.size(); ++i)\\n            temp[descriptions[i][1]]++;\\n        int rootVal = 0;\\n        for(int i = 0; i < descriptions.size(); ++i){\\n            if(temp.find(descriptions[i][0]) == temp.end()){\\n                rootVal = descriptions[i][0];\\n                break;\\n            }\\n        }\\n        return ump[rootVal];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> ump;\\n        for(int i = 0; i < descriptions.size(); ++i){\\n            if(ump.find(descriptions[i][0]) == ump.end()){\\n                TreeNode* newNode = new TreeNode(descriptions[i][0]);\\n                if(ump.find(descriptions[i][1]) == ump.end()){\\n                    TreeNode* childNode = new TreeNode(descriptions[i][1]);\\n                    if(descriptions[i][2] == 1)\\n                        newNode->left = childNode;\\n                    else\\n                        newNode->right = childNode;\\n                    ump[descriptions[i][1]] = childNode;\\n                }\\n                else{\\n                    if(descriptions[i][2] == 1)\\n                        newNode->left = ump[descriptions[i][1]];\\n                    else\\n                        newNode->right = ump[descriptions[i][1]];\\n                }\\n                ump[descriptions[i][0]] = newNode;\\n            }\\n            else{\\n                if(ump.find(descriptions[i][1]) == ump.end()){\\n                    TreeNode* childNode = new TreeNode(descriptions[i][1]);\\n                    if(descriptions[i][2] == 1)\\n                        ump[descriptions[i][0]]->left = childNode;\\n                    else\\n                        ump[descriptions[i][0]]->right = childNode;\\n                    ump[descriptions[i][1]] = childNode;\\n                }\\n                else{\\n                    if(descriptions[i][2] == 1)\\n                        ump[descriptions[i][0]]->left = ump[descriptions[i][1]];\\n                    else\\n                        ump[descriptions[i][0]]->right = ump[descriptions[i][1]];\\n                }\\n            }\\n        }\\n        unordered_map<int, int> temp;\\n        for(int i = 0; i < descriptions.size(); ++i)\\n            temp[descriptions[i][1]]++;\\n        int rootVal = 0;\\n        for(int i = 0; i < descriptions.size(); ++i){\\n            if(temp.find(descriptions[i][0]) == temp.end()){\\n                rootVal = descriptions[i][0];\\n                break;\\n            }\\n        }\\n        return ump[rootVal];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121655,
                "title": "c-fastest-solution-t-c-o-n-s-c-o-n-easy-understanding",
                "content": "**T.C. : O(n)\\nS.C. : O(n)**\\n\\n```\\n TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        \\n            unordered_map<int,TreeNode*>mp;\\n            unordered_map<int,bool>vis;\\n            \\n            TreeNode *head= nullptr;\\n        \\n            for(int i=0;i<des.size();i++)\\n            {\\n                \\n                vis[des[i][1]] = true;\\n                if(mp.find(des[i][0])!=mp.end())\\n                {\\n                    if(mp.find(des[i][1])!=mp.end())\\n                    {\\n                        if(des[i][2]==1)\\n                        {\\n                            mp[des[i][0]]->left = mp[des[i][1]]; \\n                        }\\n                        else\\n                        {\\n                            mp[des[i][0]]->right = mp[des[i][1]];\\n                        }\\n                    }\\n                    else\\n                    {\\n                        TreeNode *node = new TreeNode(des[i][1]);\\n                        mp[des[i][1]] = node;\\n                        if(des[i][2]==1)\\n                        {\\n                            mp[des[i][0]]->left = mp[des[i][1]]; \\n                        }\\n                        else\\n                        {\\n                            mp[des[i][0]]->right = mp[des[i][1]];\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode *node = new TreeNode(des[i][0]);\\n                    mp[des[i][0]] = node;\\n                    \\n                    \\n                    \\n                   if(mp.find(des[i][1])!=mp.end())\\n                    {\\n                        if(des[i][2]==1)\\n                        {\\n                            mp[des[i][0]]->left = mp[des[i][1]]; \\n                        }\\n                        else\\n                        {\\n                            mp[des[i][0]]->right = mp[des[i][1]];\\n                        }\\n                    }\\n                    else\\n                    {\\n                        TreeNode *node = new TreeNode(des[i][1]);\\n                        mp[des[i][1]] = node;\\n                        if(des[i][2]==1)\\n                        {\\n                            mp[des[i][0]]->left = mp[des[i][1]]; \\n                        }\\n                        else\\n                        {\\n                            mp[des[i][0]]->right = mp[des[i][1]];\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        for(int i=0;i<des.size();i++)\\n        {\\n            if(vis.find(des[i][0])==vis.end())\\n            {\\n                head = mp[des[i][0]];\\n                break;\\n            }\\n        }\\n        \\n        \\n        return head;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        \\n            unordered_map<int,TreeNode*>mp;\\n            unordered_map<int,bool>vis;\\n            \\n            TreeNode *head= nullptr;\\n        \\n            for(int i=0;i<des.size();i++)\\n            {\\n                \\n                vis[des[i][1]] = true;\\n                if(mp.find(des[i][0])!=mp.end())\\n                {\\n                    if(mp.find(des[i][1])!=mp.end())\\n                    {\\n                        if(des[i][2]==1)\\n                        {\\n                            mp[des[i][0]]->left = mp[des[i][1]]; \\n                        }\\n                        else\\n                        {\\n                            mp[des[i][0]]->right = mp[des[i][1]];\\n                        }\\n                    }\\n                    else\\n                    {\\n                        TreeNode *node = new TreeNode(des[i][1]);\\n                        mp[des[i][1]] = node;\\n                        if(des[i][2]==1)\\n                        {\\n                            mp[des[i][0]]->left = mp[des[i][1]]; \\n                        }\\n                        else\\n                        {\\n                            mp[des[i][0]]->right = mp[des[i][1]];\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode *node = new TreeNode(des[i][0]);\\n                    mp[des[i][0]] = node;\\n                    \\n                    \\n                    \\n                   if(mp.find(des[i][1])!=mp.end())\\n                    {\\n                        if(des[i][2]==1)\\n                        {\\n                            mp[des[i][0]]->left = mp[des[i][1]]; \\n                        }\\n                        else\\n                        {\\n                            mp[des[i][0]]->right = mp[des[i][1]];\\n                        }\\n                    }\\n                    else\\n                    {\\n                        TreeNode *node = new TreeNode(des[i][1]);\\n                        mp[des[i][1]] = node;\\n                        if(des[i][2]==1)\\n                        {\\n                            mp[des[i][0]]->left = mp[des[i][1]]; \\n                        }\\n                        else\\n                        {\\n                            mp[des[i][0]]->right = mp[des[i][1]];\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        for(int i=0;i<des.size();i++)\\n        {\\n            if(vis.find(des[i][0])==vis.end())\\n            {\\n                head = mp[des[i][0]];\\n                break;\\n            }\\n        }\\n        \\n        \\n        return head;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2115325,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int,TreeNode*> um;\\n    unordered_map<int,bool> parent;\\n    TreeNode* CreateBT(vector<vector<int>>& desp)\\n    {\\n        for(int i = 0; i < desp.size(); i++)\\n        {\\n            int fst = desp[i][0];\\n            int snd = desp[i][1];\\n            int dir = desp[i][2];\\n            if(!um.count(fst))\\n                um[fst] = new TreeNode(fst);\\n            if(!um.count(snd))\\n                um[snd] = new TreeNode(snd);\\n            parent[snd] = false;\\n            if(!parent.count(fst))\\n                parent[fst] = true;\\n            if(dir == 1)\\n            {\\n                um[fst]->left = um[snd];\\n            }\\n            else\\n            {\\n                um[fst]->right = um[snd];\\n            }\\n        }\\n        for(auto &[fst,snd] : parent)\\n        {\\n            if(snd)\\n            {\\n                return um[fst];\\n            }\\n        }\\n        return NULL;\\n    }\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        return CreateBT(descriptions);    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int,TreeNode*> um;\\n    unordered_map<int,bool> parent;\\n    TreeNode* CreateBT(vector<vector<int>>& desp)\\n    {\\n        for(int i = 0; i < desp.size(); i++)\\n        {\\n            int fst = desp[i][0];\\n            int snd = desp[i][1];\\n            int dir = desp[i][2];\\n            if(!um.count(fst))\\n                um[fst] = new TreeNode(fst);\\n            if(!um.count(snd))\\n                um[snd] = new TreeNode(snd);\\n            parent[snd] = false;\\n            if(!parent.count(fst))\\n                parent[fst] = true;\\n            if(dir == 1)\\n            {\\n                um[fst]->left = um[snd];\\n            }\\n            else\\n            {\\n                um[fst]->right = um[snd];\\n            }\\n        }\\n        for(auto &[fst,snd] : parent)\\n        {\\n            if(snd)\\n            {\\n                return um[fst];\\n            }\\n        }\\n        return NULL;\\n    }\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        return CreateBT(descriptions);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100757,
                "title": "c-hashmap-solution-o-n-time-and-o-n-space",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {    \\n    public TreeNode CreateBinaryTree(int[][] descriptions) {\\n        Dictionary<int, TreeNode> dict = new Dictionary<int, TreeNode>();\\n        Dictionary<int, HashSet<int>> freqDict = new Dictionary<int, HashSet<int>>();\\n        freqDict.Add(0, new HashSet<int>());\\n        freqDict.Add(1, new HashSet<int>());\\n        foreach(int[] description in descriptions){\\n            if(!dict.ContainsKey(description[0]))\\n                dict.Add(description[0], new TreeNode(description[0]));\\n            TreeNode parent = dict[description[0]];\\n            \\n            if(!dict.ContainsKey(description[1]))\\n                dict.Add(description[1], new TreeNode(description[1]));\\n            TreeNode child = dict[description[1]];\\n            \\n            if(description[2] == 1)\\n                parent.left = child;\\n            else\\n                parent.right = child;\\n            \\n            if(!freqDict[1].Contains(parent.val))\\n                freqDict[0].Add(parent.val);\\n            \\n            if(freqDict[0].Contains(child.val)){\\n                freqDict[0].Remove(child.val);\\n            }\\n            freqDict[1].Add(child.val);\\n        }\\n        \\n        foreach(int val in freqDict[0])\\n            return dict[val];\\n        \\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {    \\n    public TreeNode CreateBinaryTree(int[][] descriptions) {\\n        Dictionary<int, TreeNode> dict = new Dictionary<int, TreeNode>();\\n        Dictionary<int, HashSet<int>> freqDict = new Dictionary<int, HashSet<int>>();\\n        freqDict.Add(0, new HashSet<int>());\\n        freqDict.Add(1, new HashSet<int>());\\n        foreach(int[] description in descriptions){\\n            if(!dict.ContainsKey(description[0]))\\n                dict.Add(description[0], new TreeNode(description[0]));\\n            TreeNode parent = dict[description[0]];\\n            \\n            if(!dict.ContainsKey(description[1]))\\n                dict.Add(description[1], new TreeNode(description[1]));\\n            TreeNode child = dict[description[1]];\\n            \\n            if(description[2] == 1)\\n                parent.left = child;\\n            else\\n                parent.right = child;\\n            \\n            if(!freqDict[1].Contains(parent.val))\\n                freqDict[0].Add(parent.val);\\n            \\n            if(freqDict[0].Contains(child.val)){\\n                freqDict[0].Remove(child.val);\\n            }\\n            freqDict[1].Add(child.val);\\n        }\\n        \\n        foreach(int val in freqDict[0])\\n            return dict[val];\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076340,
                "title": "c-o-n-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> mp;\\n        unordered_map<int, int> hash;\\n        \\n        for(int i = 0 ; i < descriptions.size(); i++){\\n            int parent = descriptions[i][0];\\n            int child = descriptions[i][1];\\n            int leftFlag = descriptions[i][2];\\n            \\n            if(mp.find(parent) == mp.end()){\\n                TreeNode* newNode = new TreeNode(parent);\\n                mp[parent] = newNode;\\n            }\\n            \\n            if(mp.find(child) == mp.end()){\\n                TreeNode* newNode = new TreeNode(child);\\n                mp[child] = newNode;\\n            }\\n            \\n            if(leftFlag == 1) mp[parent]->left = mp[child];\\n            else mp[parent]->right = mp[child];\\n            \\n            hash[child] = parent;\\n        }\\n        \\n        TreeNode* ans = NULL;\\n        for(int i = 0 ; i < descriptions.size(); i++){\\n            if(hash.find(descriptions[i][0]) == hash.end())\\n                ans = mp[descriptions[i][0]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> mp;\\n        unordered_map<int, int> hash;\\n        \\n        for(int i = 0 ; i < descriptions.size(); i++){\\n            int parent = descriptions[i][0];\\n            int child = descriptions[i][1];\\n            int leftFlag = descriptions[i][2];\\n            \\n            if(mp.find(parent) == mp.end()){\\n                TreeNode* newNode = new TreeNode(parent);\\n                mp[parent] = newNode;\\n            }\\n            \\n            if(mp.find(child) == mp.end()){\\n                TreeNode* newNode = new TreeNode(child);\\n                mp[child] = newNode;\\n            }\\n            \\n            if(leftFlag == 1) mp[parent]->left = mp[child];\\n            else mp[parent]->right = mp[child];\\n            \\n            hash[child] = parent;\\n        }\\n        \\n        TreeNode* ans = NULL;\\n        for(int i = 0 ; i < descriptions.size(); i++){\\n            if(hash.find(descriptions[i][0]) == hash.end())\\n                ans = mp[descriptions[i][0]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070657,
                "title": "python3-directed-graph-to-binary-tree-o-n",
                "content": "```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        dct={}\\n        children=set()\\n        for p,c,left in descriptions:\\n            children.add(c)\\n            if p not in dct:\\n                dct[p]=[None,None]\\n            dct[p][1-left]=c\\n        for el in dct:\\n            if el not in children:\\n                start=el\\n        \\n        def helper(root):\\n            if not root: return None\\n            l,r=dct[root.val] if root.val in dct else (None,None)\\n            if l: root.left=helper(TreeNode(l))\\n            if r: root.right=helper(TreeNode(r))\\n            return root\\n        \\n        root=TreeNode(start)\\n        helper(root)\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        dct={}\\n        children=set()\\n        for p,c,left in descriptions:\\n            children.add(c)\\n            if p not in dct:\\n                dct[p]=[None,None]\\n            dct[p][1-left]=c\\n        for el in dct:\\n            if el not in children:\\n                start=el\\n        \\n        def helper(root):\\n            if not root: return None\\n            l,r=dct[root.val] if root.val in dct else (None,None)\\n            if l: root.left=helper(TreeNode(l))\\n            if r: root.right=helper(TreeNode(r))\\n            return root\\n        \\n        root=TreeNode(start)\\n        helper(root)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059984,
                "title": "java-hashmap-and-hashset",
                "content": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> map= new HashMap<>();\\n        Set<Integer> children = new HashSet<>();\\n        for (int[] description: descriptions){\\n            int parent= description[0];\\n            int child= description[1];\\n            int isLeft= description[2];\\n            children.add(child);\\n            TreeNode parentNode = map.getOrDefault(parent, new TreeNode(parent));\\n            if (isLeft == 1){\\n                parentNode.left = map.getOrDefault(child, new TreeNode(child));\\n                map.put(child, parentNode.left);\\n            }else{\\n                parentNode.right = map.getOrDefault(child, new TreeNode(child));\\n                map.put(child, parentNode.right);\\n            }\\n            map.put(parent, parentNode);\\n        }\\n        for (Integer key: map.keySet())\\n            if (!children.contains(key))\\n                return map.get(key);\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> map= new HashMap<>();\\n        Set<Integer> children = new HashSet<>();\\n        for (int[] description: descriptions){\\n            int parent= description[0];\\n            int child= description[1];\\n            int isLeft= description[2];\\n            children.add(child);\\n            TreeNode parentNode = map.getOrDefault(parent, new TreeNode(parent));\\n            if (isLeft == 1){\\n                parentNode.left = map.getOrDefault(child, new TreeNode(child));\\n                map.put(child, parentNode.left);\\n            }else{\\n                parentNode.right = map.getOrDefault(child, new TreeNode(child));\\n                map.put(child, parentNode.right);\\n            }\\n            map.put(parent, parentNode);\\n        }\\n        for (Integer key: map.keySet())\\n            if (!children.contains(key))\\n                return map.get(key);\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023560,
                "title": "python",
                "content": "\\n    def createBinaryTree(self, descriptions):\\n        dict1 = defaultdict(int)\\n        \\n        root = list(set([i[0] for i in descriptions]) - set([i[1] for i in descriptions]))[0]\\n        \\n        for parent, child, isLeft in descriptions:\\n            if parent not in dict1:\\n                dict1[parent] = TreeNode(parent)\\n                \\n            if child not in dict1:\\n                dict1[child] = TreeNode(child)\\n                \\n            if isLeft == 1:\\n                dict1[parent].left = dict1[child]\\n            else:\\n                dict1[parent].right = dict1[child]\\n                \\n        return dict1[root]",
                "solutionTags": [],
                "code": "\\n    def createBinaryTree(self, descriptions):\\n        dict1 = defaultdict(int)\\n        \\n        root = list(set([i[0] for i in descriptions]) - set([i[1] for i in descriptions]))[0]\\n        \\n        for parent, child, isLeft in descriptions:\\n            if parent not in dict1:\\n                dict1[parent] = TreeNode(parent)\\n                \\n            if child not in dict1:\\n                dict1[child] = TreeNode(child)\\n                \\n            if isLeft == 1:\\n                dict1[parent].left = dict1[child]\\n            else:\\n                dict1[parent].right = dict1[child]\\n                \\n        return dict1[root]",
                "codeTag": "Python3"
            },
            {
                "id": 2002236,
                "title": "c-hashmap-and-set-approach",
                "content": "The root node will be the element which is not a child of any node thats why we can simply use a set to find the root node then create a hashmap to store the TreeNode pointers and a visited array to actually know that we have created that node previosuly to avoid overwriting Then the problem is just basiz if-else statements the code is given below:\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        set<int> s;\\n        \\n        int n=descriptions.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(descriptions[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            s.erase(descriptions[i][1]);\\n        }\\n        \\n        unordered_map<int,TreeNode*> mpp;\\n        \\n        unordered_map<int,int> vis;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[descriptions[i][0]]==0)\\n            {\\n                TreeNode *p=new TreeNode(descriptions[i][0]);\\n                mpp[descriptions[i][0]]=p;\\n                if((descriptions[i][2])==1)\\n                {\\n                    if(vis[descriptions[i][1]]==0)\\n                    {\\n                        TreeNode *left=new TreeNode(descriptions[i][1]);\\n                        p->left=left;\\n                        mpp[descriptions[i][1]]=left;\\n                    }\\n                    else\\n                    {\\n                        p->left=mpp[descriptions[i][1]]; \\n                    }\\n                }\\n                else\\n                {\\n                    if(vis[descriptions[i][1]]==0)\\n                    {\\n                        TreeNode *right=new TreeNode(descriptions[i][1]);\\n                        p->right=right;\\n                        mpp[descriptions[i][1]]=right;\\n                    }\\n                    else\\n                    {\\n                        p->right=mpp[descriptions[i][1]];\\n                    }\\n                    \\n                }\\n                vis[descriptions[i][0]]=1;\\n                vis[descriptions[i][1]]=1;\\n            }\\n            else\\n            {\\n                TreeNode *p=mpp[descriptions[i][0]];\\n                mpp[descriptions[i][0]]=p;\\n                if((descriptions[i][2])==1)\\n                {\\n                    if(vis[descriptions[i][1]]==0)\\n                    {\\n                        TreeNode *left=new TreeNode(descriptions[i][1]);\\n                        p->left=left;\\n                        mpp[descriptions[i][1]]=left;\\n                    }\\n                    else\\n                    {\\n                        p->left=mpp[descriptions[i][1]]; \\n                    }\\n                }\\n                else\\n                {\\n                    if(vis[descriptions[i][1]]==0)\\n                    {\\n                        TreeNode *right=new TreeNode(descriptions[i][1]);\\n                        p->right=right;\\n                        mpp[descriptions[i][1]]=right;\\n                    }\\n                    else\\n                    {\\n                        p->right=mpp[descriptions[i][1]];\\n                    }\\n                    \\n                }\\n                vis[descriptions[i][0]]=1;\\n                vis[descriptions[i][1]]=1;\\n            }\\n        }\\n        return mpp[*s.begin()];\\n    }\\n};\\n```\\n\\nP.S : **YOU ARE VERY WARMLY WELCOME TO SUGGEST FASTER APPROACH**",
                "solutionTags": [
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        set<int> s;\\n        \\n        int n=descriptions.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(descriptions[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            s.erase(descriptions[i][1]);\\n        }\\n        \\n        unordered_map<int,TreeNode*> mpp;\\n        \\n        unordered_map<int,int> vis;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[descriptions[i][0]]==0)\\n            {\\n                TreeNode *p=new TreeNode(descriptions[i][0]);\\n                mpp[descriptions[i][0]]=p;\\n                if((descriptions[i][2])==1)\\n                {\\n                    if(vis[descriptions[i][1]]==0)\\n                    {\\n                        TreeNode *left=new TreeNode(descriptions[i][1]);\\n                        p->left=left;\\n                        mpp[descriptions[i][1]]=left;\\n                    }\\n                    else\\n                    {\\n                        p->left=mpp[descriptions[i][1]]; \\n                    }\\n                }\\n                else\\n                {\\n                    if(vis[descriptions[i][1]]==0)\\n                    {\\n                        TreeNode *right=new TreeNode(descriptions[i][1]);\\n                        p->right=right;\\n                        mpp[descriptions[i][1]]=right;\\n                    }\\n                    else\\n                    {\\n                        p->right=mpp[descriptions[i][1]];\\n                    }\\n                    \\n                }\\n                vis[descriptions[i][0]]=1;\\n                vis[descriptions[i][1]]=1;\\n            }\\n            else\\n            {\\n                TreeNode *p=mpp[descriptions[i][0]];\\n                mpp[descriptions[i][0]]=p;\\n                if((descriptions[i][2])==1)\\n                {\\n                    if(vis[descriptions[i][1]]==0)\\n                    {\\n                        TreeNode *left=new TreeNode(descriptions[i][1]);\\n                        p->left=left;\\n                        mpp[descriptions[i][1]]=left;\\n                    }\\n                    else\\n                    {\\n                        p->left=mpp[descriptions[i][1]]; \\n                    }\\n                }\\n                else\\n                {\\n                    if(vis[descriptions[i][1]]==0)\\n                    {\\n                        TreeNode *right=new TreeNode(descriptions[i][1]);\\n                        p->right=right;\\n                        mpp[descriptions[i][1]]=right;\\n                    }\\n                    else\\n                    {\\n                        p->right=mpp[descriptions[i][1]];\\n                    }\\n                    \\n                }\\n                vis[descriptions[i][0]]=1;\\n                vis[descriptions[i][1]]=1;\\n            }\\n        }\\n        return mpp[*s.begin()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988598,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Set<Integer> head = new HashSet<>();\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        for (int[] description : descriptions) {\\n            head.add(description[0]);\\n            TreeNode parent = map.getOrDefault(description[0], new TreeNode(description[0]));\\n            TreeNode child = map.getOrDefault(description[1], new TreeNode(description[1]));\\n            if (description[2] == 1) {\\n                parent.left = child;\\n            } else {\\n                parent.right = child;\\n            }\\n\\n            map.put(parent.val, parent);\\n            map.put(child.val, child);\\n        }\\n        \\n        for (int[] description : descriptions)\\n            head.remove(description[1]);\\n        \\n        return map.get(head.iterator().next());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Set<Integer> head = new HashSet<>();\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        for (int[] description : descriptions) {\\n            head.add(description[0]);\\n            TreeNode parent = map.getOrDefault(description[0], new TreeNode(description[0]));\\n            TreeNode child = map.getOrDefault(description[1], new TreeNode(description[1]));\\n            if (description[2] == 1) {\\n                parent.left = child;\\n            } else {\\n                parent.right = child;\\n            }\\n\\n            map.put(parent.val, parent);\\n            map.put(child.val, child);\\n        }\\n        \\n        for (int[] description : descriptions)\\n            head.remove(description[1]);\\n        \\n        return map.get(head.iterator().next());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922572,
                "title": "c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& v) {\\n      ios_base::sync_with_stdio(0);\\n      cin.tie(NULL);\\n      cout.tie(NULL);\\n        unordered_map<int,pair<TreeNode *,int>>m; //map.key -->storinf all unique values\\n                                        //map.value-->pair of(Tree constructed by curr val and its child and second value of pair store level of node considering root level is at 0)\\n        for(int i=0;i<v.size();i++){\\n          if(m.find(v[i][0])==m.end()){\\n            TreeNode *temp=new TreeNode(v[i][0]);\\n            if(m.find(v[i][1])==m.end()){\\n              TreeNode *node=new TreeNode(v[i][1]);\\n            v[i][2]==1?temp->left=node:temp->right=node;\\n            m[v[i][0]]={temp,0};\\n            m[v[i][1]]={node,m[v[i][0]].second+1};\\n            }\\n            else {\\n              m[v[i][1]].second++;\\n              if(m[v[i][1]].first->left)m[m[v[i][1]].first->left->val].second++;\\n              if(m[v[i][1]].first->right)m[m[v[i][1]].first->right->val].second++;\\n              v[i][2]==1?temp->left=m[v[i][1]].first:temp->right=m[v[i][1]].first;\\n              m[v[i][0]]={temp,0};\\n            }\\n          }\\n          else {\\n            if(m.find(v[i][1])==m.end()){\\n              TreeNode *node=new TreeNode(v[i][1]);\\n            v[i][2]==1?m[v[i][0]].first->left=node:m[v[i][0]].first->right=node;\\n              m[v[i][1]]={node,m[v[i][0]].second+1};\\n            }\\n            else {\\n              m[v[i][1]].second++;\\n              if(m[v[i][1]].first->left)m[m[v[i][1]].first->left->val].second++;\\n              if(m[v[i][1]].first->right)m[m[v[i][1]].first->right->val].second++;\\n              v[i][2]==1?m[v[i][0]].first->left=m[v[i][1]].first:m[v[i][0]].first->right=m[v[i][1]].first;\\n            }\\n            \\n          }\\n        } \\n      for(auto val:m){\\n        if(val.second.second==0)return val.second.first;\\n      }\\n      return NULL;\\n    }\\n};\\n```\\n**PLEASE UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& v) {\\n      ios_base::sync_with_stdio(0);\\n      cin.tie(NULL);\\n      cout.tie(NULL);\\n        unordered_map<int,pair<TreeNode *,int>>m; //map.key -->storinf all unique values\\n                                        //map.value-->pair of(Tree constructed by curr val and its child and second value of pair store level of node considering root level is at 0)\\n        for(int i=0;i<v.size();i++){\\n          if(m.find(v[i][0])==m.end()){\\n            TreeNode *temp=new TreeNode(v[i][0]);\\n            if(m.find(v[i][1])==m.end()){\\n              TreeNode *node=new TreeNode(v[i][1]);\\n            v[i][2]==1?temp->left=node:temp->right=node;\\n            m[v[i][0]]={temp,0};\\n            m[v[i][1]]={node,m[v[i][0]].second+1};\\n            }\\n            else {\\n              m[v[i][1]].second++;\\n              if(m[v[i][1]].first->left)m[m[v[i][1]].first->left->val].second++;\\n              if(m[v[i][1]].first->right)m[m[v[i][1]].first->right->val].second++;\\n              v[i][2]==1?temp->left=m[v[i][1]].first:temp->right=m[v[i][1]].first;\\n              m[v[i][0]]={temp,0};\\n            }\\n          }\\n          else {\\n            if(m.find(v[i][1])==m.end()){\\n              TreeNode *node=new TreeNode(v[i][1]);\\n            v[i][2]==1?m[v[i][0]].first->left=node:m[v[i][0]].first->right=node;\\n              m[v[i][1]]={node,m[v[i][0]].second+1};\\n            }\\n            else {\\n              m[v[i][1]].second++;\\n              if(m[v[i][1]].first->left)m[m[v[i][1]].first->left->val].second++;\\n              if(m[v[i][1]].first->right)m[m[v[i][1]].first->right->val].second++;\\n              v[i][2]==1?m[v[i][0]].first->left=m[v[i][1]].first:m[v[i][0]].first->right=m[v[i][1]].first;\\n            }\\n            \\n          }\\n        } \\n      for(auto val:m){\\n        if(val.second.second==0)return val.second.first;\\n      }\\n      return NULL;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1903324,
                "title": "easiest-java-solution-using-2-hashmaps",
                "content": "This problem can be solved very easily using two HashMaps and assigning proper meanings to them. In my solution, I have used the maps as described below:\\n\\n**(i)** **The first map named \\'hm\\' stores all the children nodes with their \\'isLeft\\' property.** This map will help us to find the root node and also in the dfs function to determine whether to attach a node to the left of its parent or to the right.\\n\\n**(ii)** **The second map named \\'hm2\\' stores the parents against a list of their children.** This map will help us to determine which nodes are the leaf nodes and make the task of making recursive calls to the dfs function much simplified as we will call it for all the children of a parent node.\\n\\nThe base case in the dfs function will check whether the current value is that of a leaf node, that is, if that value is not present in hm2 as it is not a parent of any other node in the tree. Rest of the solution is pretty much self-explanatory.\\n\\n```\\npublic TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer, Integer> hm = new HashMap<>(); // for storing children with their left property\\n        HashMap<Integer, List<Integer>> hm2 = new HashMap<>(); // for storing parents with their children\\n        \\n        int rootVal = 0; // for storing the value of the root node \\n        \\n        for(int[] a: descriptions){\\n            hm.put(a[1], a[2]); // putting child node with its left property\\n            \\n            if(hm2.get(a[0]) == null){\\n                hm2.put(a[0], new ArrayList<>()); // creating a new list against a parent and putting its children in the list\\n                hm2.get(a[0]).add(a[1]);\\n            }else{\\n                hm2.get(a[0]).add(a[1]);\\n            }\\n        }\\n        \\n\\t\\t// finding root node\\'s value \\n        for(int[] a: descriptions){\\n            if(!hm.containsKey(a[0])){\\n                rootVal = a[0];\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// calling the dfs function after doing all the prerequisites\\n        return dfs(rootVal, hm, hm2);\\n    }\\n    \\n    public TreeNode dfs(int rootVal, HashMap<Integer,Integer> hm, HashMap<Integer, List<Integer>> hm2){\\n        \\n        if(!hm2.containsKey(rootVal)){\\n            return new TreeNode(rootVal); // if the current node is a leaf node, return it\\n        }\\n        \\n        List<Integer> children = hm2.get(rootVal); // if not a leaf node, get its children from hm2\\n        TreeNode root = new TreeNode(rootVal); // make it a node and make recursive calls to attach its children\\n        \\n        for(int i = 0; i < children.size(); i++){\\n            int child = children.get(i); // get the node\\'s children one by one\\n            if(hm.get(child) == 1){ // check whether its a left child or not\\n                root.left = dfs(child, hm, hm2); // the child will be the root of its own subtree, so pass its value as root to the next call \\n            }else{\\n                root.right = dfs(child, hm, hm2); \\n            }\\n        }\\n        \\n        return root; // return the final tree\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer, Integer> hm = new HashMap<>(); // for storing children with their left property\\n        HashMap<Integer, List<Integer>> hm2 = new HashMap<>(); // for storing parents with their children\\n        \\n        int rootVal = 0; // for storing the value of the root node \\n        \\n        for(int[] a: descriptions){\\n            hm.put(a[1], a[2]); // putting child node with its left property\\n            \\n            if(hm2.get(a[0]) == null){\\n                hm2.put(a[0], new ArrayList<>()); // creating a new list against a parent and putting its children in the list\\n                hm2.get(a[0]).add(a[1]);\\n            }else{\\n                hm2.get(a[0]).add(a[1]);\\n            }\\n        }\\n        \\n\\t\\t// finding root node\\'s value \\n        for(int[] a: descriptions){\\n            if(!hm.containsKey(a[0])){\\n                rootVal = a[0];\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// calling the dfs function after doing all the prerequisites\\n        return dfs(rootVal, hm, hm2);\\n    }\\n    \\n    public TreeNode dfs(int rootVal, HashMap<Integer,Integer> hm, HashMap<Integer, List<Integer>> hm2){\\n        \\n        if(!hm2.containsKey(rootVal)){\\n            return new TreeNode(rootVal); // if the current node is a leaf node, return it\\n        }\\n        \\n        List<Integer> children = hm2.get(rootVal); // if not a leaf node, get its children from hm2\\n        TreeNode root = new TreeNode(rootVal); // make it a node and make recursive calls to attach its children\\n        \\n        for(int i = 0; i < children.size(); i++){\\n            int child = children.get(i); // get the node\\'s children one by one\\n            if(hm.get(child) == 1){ // check whether its a left child or not\\n                root.left = dfs(child, hm, hm2); // the child will be the root of its own subtree, so pass its value as root to the next call \\n            }else{\\n                root.right = dfs(child, hm, hm2); \\n            }\\n        }\\n        \\n        return root; // return the final tree\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1898285,
                "title": "java-hashmap-easy-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer, TreeNode> hm = new HashMap<>();\\n        HashSet<Integer> havp = new HashSet<>();\\n        for (int[] d : descriptions) {\\n            if (!hm.containsKey(d[0])) hm.put(d[0], new TreeNode(d[0]));\\n            if (!hm.containsKey(d[1])) hm.put(d[1], new TreeNode(d[1]));\\n            TreeNode par = hm.get(d[0]), child = hm.get(d[1]);\\n\\t\\t\\t\\n\\t\\t\\t//conect child to its parent\\n            if (d[2] == 1) par.left = child;\\n            else par.right = child;\\n\\t\\t\\t\\n\\t\\t\\t//mark this node as not root, bcz it has parent\\n            havp.add(child.val);\\n\\n        }\\n\\t\\t// find root: root has no parent\\n        for (Integer integer : hm.keySet()) {\\n            if(!havp.contains(integer)) return hm.get(integer);\\n        }\\n\\t\\t\\n\\t\\t//line below this doesn\\'t matter bcz code will never reach here\\n        return  new TreeNode(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer, TreeNode> hm = new HashMap<>();\\n        HashSet<Integer> havp = new HashSet<>();\\n        for (int[] d : descriptions) {\\n            if (!hm.containsKey(d[0])) hm.put(d[0], new TreeNode(d[0]));\\n            if (!hm.containsKey(d[1])) hm.put(d[1], new TreeNode(d[1]));\\n            TreeNode par = hm.get(d[0]), child = hm.get(d[1]);\\n\\t\\t\\t\\n\\t\\t\\t//conect child to its parent\\n            if (d[2] == 1) par.left = child;\\n            else par.right = child;\\n\\t\\t\\t\\n\\t\\t\\t//mark this node as not root, bcz it has parent\\n            havp.add(child.val);\\n\\n        }\\n\\t\\t// find root: root has no parent\\n        for (Integer integer : hm.keySet()) {\\n            if(!havp.contains(integer)) return hm.get(integer);\\n        }\\n\\t\\t\\n\\t\\t//line below this doesn\\'t matter bcz code will never reach here\\n        return  new TreeNode(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878669,
                "title": "easy-solution-o-n-time",
                "content": "class Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        unordered_map<int,bool>mp1;\\n        unordered_map<int,TreeNode*>mp;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            int a=d[i][0];\\n            int b=d[i][1];\\n            int c=d[i][2];\\n            TreeNode*temp;\\n            if(mp.find(a)!=mp.end())\\n            {\\n                temp=mp[a];\\n            }\\n            else\\n            {\\n                temp=new TreeNode (a);\\n                mp[a]=temp;\\n            }\\n            TreeNode*temp1;\\n            if(mp.find(b)!=mp.end())\\n            {\\n                temp1=mp[b];\\n            }\\n            else\\n            {\\n                temp1=new TreeNode(b);\\n                mp[b]=temp1;\\n            }\\n            mp1[b]=true;\\n            if(c==0)\\n            {\\n                temp->right=temp1;\\n            }\\n            else\\n            {\\n                temp->left=temp1;\\n            }\\n        }\\n        for(auto x:mp)\\n        {\\n            if(mp1[x.first]==false)\\n            {\\n                return x.second;\\n            }\\n        }\\n        return NULL;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        unordered_map<int,bool>mp1;\\n        unordered_map<int,TreeNode*>mp;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            int a=d[i][0];\\n            int b=d[i][1];\\n            int c=d[i][2];\\n            TreeNode*temp;\\n            if(mp.find(a)!=mp.end())\\n            {\\n                temp=mp[a];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1878528,
                "title": "c-map-union-find",
                "content": "1. Using union-find to find the root.\\n2. Creating the tree using unordered_map\\n3. Returning the root node from the map\\n\\n```\\nclass Solution {\\npublic:\\n    int getParent(int u, vector<int>& parent){\\n        if(u==parent[u]){\\n            return u;\\n        }\\n        return parent[u] = getParent(parent[u], parent);\\n    }\\n    int getRoot(vector<vector<int>>& des){\\n        vector<int> parent(100001);\\n        for(int i=0; i<100001; i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0; i<des.size(); i++){\\n            int u=des[i][0], v=des[i][1];\\n            \\n            int srcParent=getParent(u, parent);\\n            int destParent=getParent(v, parent);\\n            parent[destParent]=srcParent;\\n        }\\n        \\n        return getParent(des[0][0], parent);\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        \\n        //Applying union find for finding the root of the tree\\n        int root=getRoot(des);\\n        \\n        \\n        //Creating the tree\\n        unordered_map<int, TreeNode*> m;\\n      \\n        for(int i=0; i<des.size(); i++){\\n            int par=des[i][0], child=des[i][1], f=des[i][2];\\n            \\n            TreeNode* t, *u;\\n            if(m.count(par) && m.count(child)){\\n                t = m[par];\\n                u = m[child];\\n            }\\n            else if(m.count(par)){\\n                t=m[par];\\n                u=new TreeNode(child);\\n                \\n            }else if(m.count(child)){\\n                t=new TreeNode(par);\\n                u=m[child];\\n        \\n            }else{\\n                t=new TreeNode(par);\\n                u=new TreeNode(child);\\n            }\\n            \\n            if(f){\\n                t->left=u;\\n            }else{\\n                t->right=u;\\n            }\\n            m[par]=t;\\n            m[child]=u;\\n        }\\n    \\n        return m[root];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getParent(int u, vector<int>& parent){\\n        if(u==parent[u]){\\n            return u;\\n        }\\n        return parent[u] = getParent(parent[u], parent);\\n    }\\n    int getRoot(vector<vector<int>>& des){\\n        vector<int> parent(100001);\\n        for(int i=0; i<100001; i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0; i<des.size(); i++){\\n            int u=des[i][0], v=des[i][1];\\n            \\n            int srcParent=getParent(u, parent);\\n            int destParent=getParent(v, parent);\\n            parent[destParent]=srcParent;\\n        }\\n        \\n        return getParent(des[0][0], parent);\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        \\n        //Applying union find for finding the root of the tree\\n        int root=getRoot(des);\\n        \\n        \\n        //Creating the tree\\n        unordered_map<int, TreeNode*> m;\\n      \\n        for(int i=0; i<des.size(); i++){\\n            int par=des[i][0], child=des[i][1], f=des[i][2];\\n            \\n            TreeNode* t, *u;\\n            if(m.count(par) && m.count(child)){\\n                t = m[par];\\n                u = m[child];\\n            }\\n            else if(m.count(par)){\\n                t=m[par];\\n                u=new TreeNode(child);\\n                \\n            }else if(m.count(child)){\\n                t=new TreeNode(par);\\n                u=m[child];\\n        \\n            }else{\\n                t=new TreeNode(par);\\n                u=new TreeNode(child);\\n            }\\n            \\n            if(f){\\n                t->left=u;\\n            }else{\\n                t->right=u;\\n            }\\n            m[par]=t;\\n            m[child]=u;\\n        }\\n    \\n        return m[root];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852176,
                "title": "c-clean-hashmap",
                "content": "```\\npublic class Solution {\\n    public TreeNode CreateBinaryTree(int[][] descriptions) {\\n        var map = new Dictionary<int, TreeNode>();\\n        var childs = new HashSet<int>();\\n        foreach (var desc in descriptions) {\\n            int p = desc[0], c = desc[1], isLeft = desc[2];\\n            if (!map.ContainsKey(p)) map[p] = new TreeNode() { val = p };\\n            if (!map.ContainsKey(c)) map[c] = new TreeNode() { val = c };\\n            childs.Add(c);\\n\\n            if (isLeft == 1) map[p].left = map[c];\\n            else map[p].right = map[c];\\n        }\\n\\n        var parentSet = map.Keys.ToHashSet();\\n        parentSet.RemoveWhere(r => childs.Contains(r));       \\n        return map[parentSet.ElementAt(0)];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public TreeNode CreateBinaryTree(int[][] descriptions) {\\n        var map = new Dictionary<int, TreeNode>();\\n        var childs = new HashSet<int>();\\n        foreach (var desc in descriptions) {\\n            int p = desc[0], c = desc[1], isLeft = desc[2];\\n            if (!map.ContainsKey(p)) map[p] = new TreeNode() { val = p };\\n            if (!map.ContainsKey(c)) map[c] = new TreeNode() { val = c };\\n            childs.Add(c);\\n\\n            if (isLeft == 1) map[p].left = map[c];\\n            else map[p].right = map[c];\\n        }\\n\\n        var parentSet = map.Keys.ToHashSet();\\n        parentSet.RemoveWhere(r => childs.Contains(r));       \\n        return map[parentSet.ElementAt(0)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851235,
                "title": "c-o-n-unordered-map-explain",
                "content": "\\n# Idea \\nAt least, you need to have a table mapping the different \\ninteger into different `TreeNode* `. When I have this table I can \\ngo through one `descriptions` with one loop and build up all \\nTreeNode. and their relatiosnhip (parent, left and right). \\n\\nWhen you can build up this Tree, you will also need to know\\nwhat root it is. One idea to find root is that `The node without parent is the root`. \\nAnother idea to choice any node and keep going to find parent. \\nSo we can build a hash map to map each node to its parent.\\n\\n\\nNow , we can have the following source code.\\n# Source Code \\n\\n```C++\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> mp;\\n        unordered_map<int, int> parents_mp; \\n\\t\\t//process to build TreeNode map of mapping integer to TreeNode and \\n\\t\\t//parent map of mapping node to its parent\\n        for(auto& desc: descriptions) { \\n            if(mp[desc[0]] == nullptr) {\\n                mp[desc[0]] = new TreeNode(desc[0]);\\n            }\\n            if(mp[desc[1]] == nullptr) {\\n                mp[desc[1]] = new TreeNode(desc[1]);\\n            }\\n            \\n            if(desc[2]==1) {\\n                mp[desc[0]]->left = mp[desc[1]];\\n            } else {\\n                mp[desc[0]]->right = mp[desc[1]];\\n            }\\n            parents_mp[desc[1]] = desc[0];\\n        }\\n        int child = descriptions[0][1];        \\n\\t\\t//The process to find root from any child.\\n        while(parents_mp.find(child) != parents_mp.end()) child = parents_mp[child];\\n        return mp[child];\\n    }\\n};\\n```\\n\\n# Complexity Analysis\\n\\n**Time Complexity O(n)**\\n\\nUse O(n) time to build the two hash map `mp` and `parents_mp`\\nUse O(n) time to find root from one of node because the worst case\\nwill happen in the skew tree.\\n\\n**Space Complexity O(n)** \\nThe two hash map need O(n) space.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> mp;\\n        unordered_map<int, int> parents_mp; \\n\\t\\t//process to build TreeNode map of mapping integer to TreeNode and \\n\\t\\t//parent map of mapping node to its parent\\n        for(auto& desc: descriptions) { \\n            if(mp[desc[0]] == nullptr) {\\n                mp[desc[0]] = new TreeNode(desc[0]);\\n            }\\n            if(mp[desc[1]] == nullptr) {\\n                mp[desc[1]] = new TreeNode(desc[1]);\\n            }\\n            \\n            if(desc[2]==1) {\\n                mp[desc[0]]->left = mp[desc[1]];\\n            } else {\\n                mp[desc[0]]->right = mp[desc[1]];\\n            }\\n            parents_mp[desc[1]] = desc[0];\\n        }\\n        int child = descriptions[0][1];        \\n\\t\\t//The process to find root from any child.\\n        while(parents_mp.find(child) != parents_mp.end()) child = parents_mp[child];\\n        return mp[child];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848732,
                "title": "my-java-solution-using-hashmap",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        if (descriptions == null || descriptions.length == 0) {\\n            return new TreeNode();\\n        }\\n        Set<Integer> trackChild = new HashSet<>();\\n        for (int [] desc : descriptions) {\\n            trackChild.add(desc[1]);\\n        }\\n        Map<Integer, TreeNode> parentChildMapping = new HashMap<>();\\n        // we need to find the root\\n        int rootElement = getRootElement(descriptions, trackChild);\\n        for (int [] des : descriptions) {\\n            int parent = des[0];\\n            int child = des[1];\\n            int leftOrRight = des[2];\\n            TreeNode node = parentChildMapping.getOrDefault(parent, new TreeNode(parent));\\n            if (leftOrRight == 1) {\\n                node.left = parentChildMapping.getOrDefault(child, new TreeNode(child));\\n                parentChildMapping.put(child, node.left);\\n            }\\n            else {\\n                node.right = parentChildMapping.getOrDefault(child, new TreeNode(child));\\n                parentChildMapping.put(child, node.right);\\n            }\\n            parentChildMapping.put(parent, node);\\n        }\\n        return parentChildMapping.getOrDefault(rootElement, null);\\n    }\\n    \\n    public int getRootElement(int [][] descriptions, Set<Integer> trackChild) {\\n        int rootElement = -1;\\n        for (int [] desc : descriptions) {\\n            if (!trackChild.contains(desc[0])) {\\n                rootElement = desc[0];\\n                break;\\n            }\\n        }\\n        return rootElement;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        if (descriptions == null || descriptions.length == 0) {\\n            return new TreeNode();\\n        }\\n        Set<Integer> trackChild = new HashSet<>();\\n        for (int [] desc : descriptions) {\\n            trackChild.add(desc[1]);\\n        }\\n        Map<Integer, TreeNode> parentChildMapping = new HashMap<>();\\n        // we need to find the root\\n        int rootElement = getRootElement(descriptions, trackChild);\\n        for (int [] des : descriptions) {\\n            int parent = des[0];\\n            int child = des[1];\\n            int leftOrRight = des[2];\\n            TreeNode node = parentChildMapping.getOrDefault(parent, new TreeNode(parent));\\n            if (leftOrRight == 1) {\\n                node.left = parentChildMapping.getOrDefault(child, new TreeNode(child));\\n                parentChildMapping.put(child, node.left);\\n            }\\n            else {\\n                node.right = parentChildMapping.getOrDefault(child, new TreeNode(child));\\n                parentChildMapping.put(child, node.right);\\n            }\\n            parentChildMapping.put(parent, node);\\n        }\\n        return parentChildMapping.getOrDefault(rootElement, null);\\n    }\\n    \\n    public int getRootElement(int [][] descriptions, Set<Integer> trackChild) {\\n        int rootElement = -1;\\n        for (int [] desc : descriptions) {\\n            if (!trackChild.contains(desc[0])) {\\n                rootElement = desc[0];\\n                break;\\n            }\\n        }\\n        return rootElement;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847138,
                "title": "c-explained-unordered-map-binary-tree",
                "content": "```\\n1.First Create all nodes that is TreeNode for d[i][0] and d[i][1]  for i<n. n=descriptions.size()\\n2.Build the Tree. That is link their childs.\\n3.Find root and return pointer to that Node.\\n\\nCode:\\n\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        unordered_map<int,TreeNode*> f;\\n        int n=d.size();\\n\\t\\t//Create all Nodes\\n        for(int i=0;i<n;i++){\\n            TreeNode* cur =new TreeNode(d[i][0]);\\n            f[d[i][0]]=cur;\\n            TreeNode* child=new TreeNode(d[i][1]);\\n            f[d[i][1]]=child;\\n        }\\n\\t\\t//Build the Tree\\n        for(int i=0;i<n;i++){\\n            if(d[i][2]==1)f[d[i][0]]->left=f[d[i][1]];\\n            else f[d[i][0]]->right=f[d[i][1]];\\n        }\\n\\t\\t//Find root\\n        TreeNode* root;\\n        unordered_set<int> g;\\n        for(int i=0;i<n;i++){\\n            g.insert(d[i][1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(g.find(d[i][0])==g.end()){\\n                root=f[d[i][0]];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        unordered_map<int,TreeNode*> f;\\n        int n=d.size();\\n\\t\\t//Create all Nodes\\n        for(int i=0;i<n;i++){\\n            TreeNode* cur =new TreeNode(d[i][0]);\\n            f[d[i][0]]=cur;\\n            TreeNode* child=new TreeNode(d[i][1]);\\n            f[d[i][1]]=child;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1844429,
                "title": "scala-solution-always-throw-mle",
                "content": "```scala\\n\\n  def createBinaryTree(descriptions: Array[Array[Int]]): TreeNode = {\\n    import scala.collection.mutable.{HashMap, HashSet}\\n    val graph = new HashMap[Int, TreeNode]\\n    val parc  = new HashMap[Int, Int]\\n\\n    descriptions.foreach(x => {\\n\\n      if (!graph.contains(x(0))) graph += (x(0) -> new TreeNode(x(0)))\\n      if (!graph.contains(x(1))) graph += (x(1) -> new TreeNode(x(1)))\\n      if (x(2) == 1) graph(x(0)).left = graph(x(1)) else graph(x(0)).right = graph(x(1))\\n      if (!parc.contains(x(1))) parc.put(x(1), 0)\\n      if (!parc.contains(x(0))) parc.put(x(0), 0)\\n      parc.put(x(1), parc(x(1)) + 1)\\n    })\\n     \\n    parc.foreach { case (p, count) =>\\n      if (count == 0) return graph(p)\\n    }\\n\\n    null\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\n\\n  def createBinaryTree(descriptions: Array[Array[Int]]): TreeNode = {\\n    import scala.collection.mutable.{HashMap, HashSet}\\n    val graph = new HashMap[Int, TreeNode]\\n    val parc  = new HashMap[Int, Int]\\n\\n    descriptions.foreach(x => {\\n\\n      if (!graph.contains(x(0))) graph += (x(0) -> new TreeNode(x(0)))\\n      if (!graph.contains(x(1))) graph += (x(1) -> new TreeNode(x(1)))\\n      if (x(2) == 1) graph(x(0)).left = graph(x(1)) else graph(x(0)).right = graph(x(1))\\n      if (!parc.contains(x(1))) parc.put(x(1), 0)\\n      if (!parc.contains(x(0))) parc.put(x(0), 0)\\n      parc.put(x(1), parc(x(1)) + 1)\\n    })\\n     \\n    parc.foreach { case (p, count) =>\\n      if (count == 0) return graph(p)\\n    }\\n\\n    null\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1843488,
                "title": "weekly-contest-no-283-binary-tree-from-description-solution-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] d) {\\n         Set<Integer> set = new HashSet<>();\\n        Map<Integer,TreeNode> map = new HashMap<>();\\n        for(int[] nums:d){\\n            int parent = nums[0];\\n            int child = nums[1];\\n            TreeNode parentNode = map.containsKey(parent)?map.get(parent):new TreeNode(parent);\\n            TreeNode childNode = map.containsKey(child)?map.get(child):new TreeNode(child);\\n            if(nums[2]==1)\\n                parentNode.left=childNode;\\n            else parentNode.right=childNode;\\n            map.put(parent,parentNode);\\n            map.put(child,childNode);\\n            set.add(child);\\n        }\\n        for(Integer n:map.keySet()){\\n            if(!set.contains(n))\\n                return map.get(n);\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] d) {\\n         Set<Integer> set = new HashSet<>();\\n        Map<Integer,TreeNode> map = new HashMap<>();\\n        for(int[] nums:d){\\n            int parent = nums[0];\\n            int child = nums[1];\\n            TreeNode parentNode = map.containsKey(parent)?map.get(parent):new TreeNode(parent);\\n            TreeNode childNode = map.containsKey(child)?map.get(child):new TreeNode(child);\\n            if(nums[2]==1)\\n                parentNode.left=childNode;\\n            else parentNode.right=childNode;\\n            map.put(parent,parentNode);\\n            map.put(child,childNode);\\n            set.add(child);\\n        }\\n        for(Integer n:map.keySet()){\\n            if(!set.contains(n))\\n                return map.get(n);\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842371,
                "title": "c-hash-table-solution",
                "content": "Runtime: 1225 ms, faster than 77.71% of C++ online submissions for Create Binary Tree From Descriptions.\\nMemory Usage: 257.8 MB, less than 97.14% of C++ online submissions for Create Binary Tree From Descriptions.\\n\\n`Track all nodes in Hash Table and root = All unique node sum - child node sum`\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& binaryTree) {\\n        \\n        unordered_map<int,TreeNode*>tree;\\n        int root = 0;\\n        TreeNode * parentNode;\\n        TreeNode * childNode;        \\n        int parent;\\n\\t\\tint child;\\n\\t\\tbool isLeftChild;\\n\\t\\t\\n        for(auto &node : binaryTree)\\n        {\\n\\t\\t\\tparent = node[0];\\n\\t\\t\\tchild = node[1];\\n\\t\\t\\tisLeftChild = node[2];\\n\\t\\t\\t\\n            root -= child;\\n\\n            if(tree.count(parent)==0)\\n            {\\n                tree[parent] = new TreeNode(parent);\\n                root += parent;                \\n            }\\n\\n            parentNode = tree[parent];\\n            \\n            if(tree.count(child)==0)\\n            {\\n                tree[child] = new TreeNode(child);\\n                root += child;                \\n            }\\n\\n            childNode  = tree[child];\\n            \\n            if(isLeftChild)\\n                parentNode->left = childNode;\\n            else\\n                parentNode->right = childNode;\\n            \\n        }\\n        \\n        return tree[root];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& binaryTree) {\\n        \\n        unordered_map<int,TreeNode*>tree;\\n        int root = 0;\\n        TreeNode * parentNode;\\n        TreeNode * childNode;        \\n        int parent;\\n\\t\\tint child;\\n\\t\\tbool isLeftChild;\\n\\t\\t\\n        for(auto &node : binaryTree)\\n        {\\n\\t\\t\\tparent = node[0];\\n\\t\\t\\tchild = node[1];\\n\\t\\t\\tisLeftChild = node[2];\\n\\t\\t\\t\\n            root -= child;\\n\\n            if(tree.count(parent)==0)\\n            {\\n                tree[parent] = new TreeNode(parent);\\n                root += parent;                \\n            }\\n\\n            parentNode = tree[parent];\\n            \\n            if(tree.count(child)==0)\\n            {\\n                tree[child] = new TreeNode(child);\\n                root += child;                \\n            }\\n\\n            childNode  = tree[child];\\n            \\n            if(isLeftChild)\\n                parentNode->left = childNode;\\n            else\\n                parentNode->right = childNode;\\n            \\n        }\\n        \\n        return tree[root];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836971,
                "title": "c-o-n-map-set",
                "content": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n\\t\\tmap<int, TreeNode*> map;\\n\\t\\tset<TreeNode*> rootSet;\\n\\t\\tfor (vector<int> desc : descriptions) {\\n\\t\\t\\tTreeNode* parent = map.count(desc[0])? map[desc[0]] : new TreeNode(desc[0]);\\n\\t\\t\\tTreeNode* child = map.count(desc[1])? map[desc[1]] : new TreeNode(desc[1]);\\n\\t\\t\\tmap[desc[0]] = parent;\\n\\t\\t\\tmap[desc[1]] = child;\\n\\t\\t\\tdesc[2] ? parent->left = child : parent->right = child;\\t\\t\\t\\t\\n\\t\\t\\tif (rootSet.count(child))   rootSet.erase(child);\\n\\t\\t\\trootSet.insert(parent);\\n\\t\\t}\\n        for (vector<int> desc : descriptions) {\\n\\t\\t\\tTreeNode* parent = map[desc[0]];\\n\\t\\t\\tTreeNode* child = map[desc[1]];\\t\\t\\t\\t\\n\\t\\t\\tif (rootSet.count(child))   rootSet.erase(child);\\n\\t\\t}\\n        return *rootSet.begin();\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n\\t\\tmap<int, TreeNode*> map;\\n\\t\\tset<TreeNode*> rootSet;\\n\\t\\tfor (vector<int> desc : descriptions) {\\n\\t\\t\\tTreeNode* parent = map.count(desc[0])? map[desc[0]] : new TreeNode(desc[0]);\\n\\t\\t\\tTreeNode* child = map.count(desc[1])? map[desc[1]] : new TreeNode(desc[1]);\\n\\t\\t\\tmap[desc[0]] = parent;\\n\\t\\t\\tmap[desc[1]] = child;\\n\\t\\t\\tdesc[2] ? parent->left = child : parent->right = child;\\t\\t\\t\\t\\n\\t\\t\\tif (rootSet.count(child))   rootSet.erase(child);\\n\\t\\t\\trootSet.insert(parent);\\n\\t\\t}\\n        for (vector<int> desc : descriptions) {\\n\\t\\t\\tTreeNode* parent = map[desc[0]];\\n\\t\\t\\tTreeNode* child = map[desc[1]];\\t\\t\\t\\t\\n\\t\\t\\tif (rootSet.count(child))   rootSet.erase(child);\\n\\t\\t}\\n        return *rootSet.begin();\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834926,
                "title": "python3-solution-o-n-time-runtime-beats-93-86-of-python3-submissions",
                "content": "The basic idea of my solution is to first find the number which is going to be the root of the binary tree. Next, I\\'ll find the largest number in the binary tree because I\\'m using arrays and hashing instead of using dictionaries in this solution. \\n\\n<b>Step 1</b>:\\nTo find the root value (say <code>r</code>) of the binary tree from the descriptions, I\\'m creating two sets. One set consists of parent node numbers (<code>set a</code>) and the other set consists of child node numbers (<code>set b</code>). When I use set difference operation <code>set a - set b</code>, I\\'ll obtain the root of the binary tree. If we consider the binary tree has <code>n</code> nodes, finding the root takes O(n) time.\\n\\n<b>Step 2</b>:\\nTo find the largest number in the binary tree (say <code>m</code>), I calculated the max value among the parent nodes and the max value among the child nodes. The largest value among these two is the largest number in the binary tree. Consider the example <code>[[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]</code> given in the problem statement. 80 is the max value among the parent nodes (20, 50, 80) and 80 is the max value among the child nodes(15, 17, 20, 80, 19). <code>max(80, 80)</code> is 80. Since we traversed through the <code>descriptions</code>, this process takes O(n) time.\\n\\n<b>Step 3</b>:\\nNow, we create the array of size <code>m</code> (say <code>nodes</code>) to hold all the nodes in the binary tree. If a node has a <code>val</code> of 5, then the reference of this node is stored at <code>nodes[5]</code>. The root node will be referenced at index <code>r</code>.\\n\\n<b>Step 4</b>:\\nNow, we traverse through each node\\'s <code>description</code> in the <code>descriptions</code>. For each <code>description</code>, we create the parent node if it\\'s not been created before and also create the child node if it\\'s not been created before. We now add the child node to the left or right of the parent appropriately. The time to iterate through the <code>descriptions</code> is O(n).\\n\\n<br />\\nThe whole binary tree has been constructed from the <code>descriptions</code> where the root of the node is referenced at <code>nodes[r]</code>. Finally, just return <code>nodes[r]</code>.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        # Steps:\\n        # 1. Find the root r: O(n) time.\\n        # 2. Find the largest number: O(n) time.\\n        # 3. Create an array of \\'None\\'s of size r+1: O(n) space.\\n        # 4. For each description in descriptions, create a node if needed and add it to appropriate index in the array: O(n) time.\\n        # 5. Return r th index from the array: O(n) time.\\n        \\n        # Find the root.\\n        r=(set([description[0] for description in descriptions])-set([description[1] for description in descriptions])).pop()\\n        \\n        # Find the largest number.\\n        m=max(max(descriptions, key=lambda x:x[1])[1], max(descriptions, key=lambda x:x[0])[0])\\n        \\n        # Initialize the array of nodes.\\n        nodes=[None]*(m+1)\\n        \\n        # Iterate through descriptions.\\n        for description in descriptions:\\n            parent, child=description[0], description[1]\\n            if nodes[child]==None:  nodes[child]=TreeNode(child)\\n            if nodes[parent]==None: nodes[parent]=TreeNode(parent)\\n            if description[2]==1:   nodes[parent].left=nodes[child]\\n            else:                   nodes[parent].right=nodes[child]\\n        \\n        # Return the root.\\n        return nodes[r]\\n```\\n\\n<b>Time Complexity</b>: O(n)",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        # Steps:\\n        # 1. Find the root r: O(n) time.\\n        # 2. Find the largest number: O(n) time.\\n        # 3. Create an array of \\'None\\'s of size r+1: O(n) space.\\n        # 4. For each description in descriptions, create a node if needed and add it to appropriate index in the array: O(n) time.\\n        # 5. Return r th index from the array: O(n) time.\\n        \\n        # Find the root.\\n        r=(set([description[0] for description in descriptions])-set([description[1] for description in descriptions])).pop()\\n        \\n        # Find the largest number.\\n        m=max(max(descriptions, key=lambda x:x[1])[1], max(descriptions, key=lambda x:x[0])[0])\\n        \\n        # Initialize the array of nodes.\\n        nodes=[None]*(m+1)\\n        \\n        # Iterate through descriptions.\\n        for description in descriptions:\\n            parent, child=description[0], description[1]\\n            if nodes[child]==None:  nodes[child]=TreeNode(child)\\n            if nodes[parent]==None: nodes[parent]=TreeNode(parent)\\n            if description[2]==1:   nodes[parent].left=nodes[child]\\n            else:                   nodes[parent].right=nodes[child]\\n        \\n        # Return the root.\\n        return nodes[r]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834024,
                "title": "easy-c-map-solution-recursion-find-parent-and-call-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tunordered_map<int,int>left,right;\\n\\t\\tTreeNode* help(int node){\\n\\t\\t\\tTreeNode* root = new TreeNode(node);\\n\\t\\t\\tif(left[node]) root->left = help(left[node]);\\n\\t\\t\\tif(right[node]) root->right = help(right[node]);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\tTreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n\\t\\t\\tint root = -1,maxi = INT_MIN;\\n\\t\\t\\tunordered_map<int,int>parent;\\n\\t\\t\\tfor(auto des:descriptions){\\n\\t\\t\\t\\tif(des[2]) left[des[0]] = des[1];\\n\\t\\t\\t\\telse right[des[0]] = des[1];\\n\\t\\t\\t\\tparent[des[0]]++;\\n\\t\\t\\t\\tparent[des[1]]--;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto par:parent){\\n\\t\\t\\t\\tif(maxi<par.second){\\n\\t\\t\\t\\t\\tmaxi = par.second;\\n\\t\\t\\t\\t\\troot = par.first;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn help(root);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tunordered_map<int,int>left,right;\\n\\t\\tTreeNode* help(int node){\\n\\t\\t\\tTreeNode* root = new TreeNode(node);\\n\\t\\t\\tif(left[node]) root->left = help(left[node]);\\n\\t\\t\\tif(right[node]) root->right = help(right[node]);\\n\\t\\t\\treturn root;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1831587,
                "title": "c-easy-understanding-hashmap",
                "content": "Make a hashmap to store the nodes and an boolean array to check the node is parent or not\\n\\nnow traverse in the descriptions vector and generate node and store them in the map to use them for further description\\n\\n| Please upvote if you like the solution |\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode *>mp;\\n        vector<bool>par(1000001,1);\\n        for(auto i:descriptions){\\n            TreeNode *temp;\\n            if(mp.find(i[0])==mp.end()){\\n                temp=new TreeNode(i[0]);\\n            }else{\\n                temp=mp[i[0]];\\n            }\\n            TreeNode *child;\\n            if(mp.find(i[1])==mp.end()){\\n                child=new TreeNode(i[1]);\\n            }else{\\n                child=mp[i[1]];\\n            }\\n            if(i[2]==1){\\n                temp->left=child;\\n            }else{\\n                temp->right=child;\\n            }\\n            mp[i[0]]=temp;\\n            mp[i[1]]=child;\\n            par[i[1]]=0;\\n        }\\n        for(int i=0;i<100001;i++){\\n            if(mp.find(i)!=mp.end() && par[i]==1){\\n                return mp[i];\\n            }\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode *>mp;\\n        vector<bool>par(1000001,1);\\n        for(auto i:descriptions){\\n            TreeNode *temp;\\n            if(mp.find(i[0])==mp.end()){\\n                temp=new TreeNode(i[0]);\\n            }else{\\n                temp=mp[i[0]];\\n            }\\n            TreeNode *child;\\n            if(mp.find(i[1])==mp.end()){\\n                child=new TreeNode(i[1]);\\n            }else{\\n                child=mp[i[1]];\\n            }\\n            if(i[2]==1){\\n                temp->left=child;\\n            }else{\\n                temp->right=child;\\n            }\\n            mp[i[0]]=temp;\\n            mp[i[1]]=child;\\n            par[i[1]]=0;\\n        }\\n        for(int i=0;i<100001;i++){\\n            if(mp.find(i)!=mp.end() && par[i]==1){\\n                return mp[i];\\n            }\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827577,
                "title": "simple-c-solution-using-map-set",
                "content": "Hi, all : You can find me at [here](https://t.me/avatarlazy)\\n\\nSo , the basic approach followed in this question is to use 2 maps. \\nOne of them maps the child to parent relation and the other one maps value with corresponding node. \\nThe code written below is pretty self explanatory, but feel free to ping me incase of doubt [here](https://t.me/avatarlazy) \\n```cpp\\n // Definition for a binary tree node.\\n struct TreeNode {\\n      int val;\\n      TreeNode *left;\\n      TreeNode *right;\\n      TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n };\\n \\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        set<TreeNode*> contains;\\n        map<TreeNode* , TreeNode* > childToParent;\\n        map<int , TreeNode*> valueWithNode;\\n        \\n        for(auto& it: descriptions){\\n            int valueOfParent = it[0];\\n            int valueOfChild = it[1];\\n            int statusOfLeft = it[2];\\n            \\n            TreeNode* parent;\\n            TreeNode* child;\\n            \\n            if(valueWithNode.find(valueOfParent) != valueWithNode.end()) parent = valueWithNode[valueOfParent];\\n            else{\\n                parent = new TreeNode(valueOfParent);\\n                valueWithNode[valueOfParent] = parent;\\n            }\\n            \\n            if(valueWithNode.find(valueOfChild) != valueWithNode.end()) child = valueWithNode[valueOfChild];\\n            else{\\n                child = new TreeNode(valueOfChild);\\n                valueWithNode[valueOfChild] = child;\\n            }\\n            \\n            childToParent[child] = parent;\\n            \\n            (statusOfLeft == 1 )? parent->left = child : parent->right = child;\\n            contains.insert(parent);\\n            contains.insert(child);\\n        }\\n        \\n        for(auto& it: contains){\\n            if(childToParent.find(it) == childToParent.end()) return it;\\n        }\\n        return NULL;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        set<TreeNode*> contains;\\n        map<TreeNode* , TreeNode* > childToParent;\\n        map<int , TreeNode*> valueWithNode;\\n        \\n        for(auto& it: descriptions){\\n            int valueOfParent = it[0];\\n            int valueOfChild = it[1];\\n            int statusOfLeft = it[2];\\n            \\n            TreeNode* parent;\\n            TreeNode* child;\\n            \\n            if(valueWithNode.find(valueOfParent) != valueWithNode.end()) parent = valueWithNode[valueOfParent];\\n            else{\\n                parent = new TreeNode(valueOfParent);\\n                valueWithNode[valueOfParent] = parent;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1827064,
                "title": "getting-tle-for-correct-logic-c-map-ac",
                "content": "Below given is the code with got TLE even after it follows the same logic that most people using hashmaps have written and got AC. \\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& arr) {\\n        map<int,int>parent,children;\\n        map<int,TreeNode*>val_to_node;\\n        int n = arr.size(),root;\\n        for(int i=0;i<n;i++){\\n            TreeNode* node;\\n            if(val_to_node[arr[i][0]])\\n                node = val_to_node[arr[i][0]];\\n            else{\\n                node = new TreeNode(arr[i][0]);\\n                val_to_node[arr[i][0]] = node;\\n            }\\n             TreeNode* child ;\\n             if(val_to_node[arr[i][1]])\\n                   child = val_to_node[arr[i][1]];\\n            else{\\n                child = new TreeNode(arr[i][1]);\\n                val_to_node[arr[i][1]] = child;\\n            }\\n            if(arr[i][2]==0)\\n                node->right = child;\\n            else\\n                node->left = child;\\n            \\n            parent[arr[i][0]]++;\\n            children[arr[i][1]]++;\\n           \\n        }\\n        for(auto u : parent)\\n            if(children[u.first]==0)\\n                root=u.first;\\n        return val_to_node[root];\\n    }\\n};\\n```\\nThen What is the problem?\\nThe problem lies in using map instead of unordered_map in C++.\\nReplace map with unordered_map and see the magic work!\\nAC CODE:\\n```\\nclass Solution {\\npublic:\\n    // TLE DUE TO USE OF ONLY MAP IN PLACE OF UNORDERED MAP\\n    TreeNode* createBinaryTree(vector<vector<int>>& arr) {\\n\\t\\tunordered_map<int,int>parent,children;  //just replace one word in this line\\n        unordered_map<int,TreeNode*>val_to_node; //and this line\\n        int n = arr.size(),root;\\n        for(int i=0;i<n;i++){\\n            TreeNode* node;\\n            if(val_to_node[arr[i][0]])\\n                node = val_to_node[arr[i][0]];\\n            else{\\n                node = new TreeNode(arr[i][0]);\\n                val_to_node[arr[i][0]] = node;\\n            }\\n             TreeNode* child ;\\n             if(val_to_node[arr[i][1]])\\n                   child = val_to_node[arr[i][1]];\\n            else{\\n                child = new TreeNode(arr[i][1]);\\n                val_to_node[arr[i][1]] = child;\\n            }\\n            if(arr[i][2]==0)\\n                node->right = child;\\n            else\\n                node->left = child;\\n            \\n            parent[arr[i][0]]++;\\n            children[arr[i][1]]++;\\n           \\n        }\\n        for(auto u : parent)\\n            if(children[u.first]==0)\\n                root=u.first;\\n        return val_to_node[root];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& arr) {\\n        map<int,int>parent,children;\\n        map<int,TreeNode*>val_to_node;\\n        int n = arr.size(),root;\\n        for(int i=0;i<n;i++){\\n            TreeNode* node;\\n            if(val_to_node[arr[i][0]])\\n                node = val_to_node[arr[i][0]];\\n            else{\\n                node = new TreeNode(arr[i][0]);\\n                val_to_node[arr[i][0]] = node;\\n            }\\n             TreeNode* child ;\\n             if(val_to_node[arr[i][1]])\\n                   child = val_to_node[arr[i][1]];\\n            else{\\n                child = new TreeNode(arr[i][1]);\\n                val_to_node[arr[i][1]] = child;\\n            }\\n            if(arr[i][2]==0)\\n                node->right = child;\\n            else\\n                node->left = child;\\n            \\n            parent[arr[i][0]]++;\\n            children[arr[i][1]]++;\\n           \\n        }\\n        for(auto u : parent)\\n            if(children[u.first]==0)\\n                root=u.first;\\n        return val_to_node[root];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // TLE DUE TO USE OF ONLY MAP IN PLACE OF UNORDERED MAP\\n    TreeNode* createBinaryTree(vector<vector<int>>& arr) {\\n\\t\\tunordered_map<int,int>parent,children;  //just replace one word in this line\\n        unordered_map<int,TreeNode*>val_to_node; //and this line\\n        int n = arr.size(),root;\\n        for(int i=0;i<n;i++){\\n            TreeNode* node;\\n            if(val_to_node[arr[i][0]])\\n                node = val_to_node[arr[i][0]];\\n            else{\\n                node = new TreeNode(arr[i][0]);\\n                val_to_node[arr[i][0]] = node;\\n            }\\n             TreeNode* child ;\\n             if(val_to_node[arr[i][1]])\\n                   child = val_to_node[arr[i][1]];\\n            else{\\n                child = new TreeNode(arr[i][1]);\\n                val_to_node[arr[i][1]] = child;\\n            }\\n            if(arr[i][2]==0)\\n                node->right = child;\\n            else\\n                node->left = child;\\n            \\n            parent[arr[i][0]]++;\\n            children[arr[i][1]]++;\\n           \\n        }\\n        for(auto u : parent)\\n            if(children[u.first]==0)\\n                root=u.first;\\n        return val_to_node[root];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826729,
                "title": "scala-always-throwing-memory-limit-exceeded-in-this-question",
                "content": "```\\nobject Solution {\\n  def createBinaryTree(descriptions: Array[Array[Int]]): TreeNode = {\\n    val nodes = scala.collection.mutable.Map[Int, TreeNode]()\\n    val nodeHasParent = scala.collection.mutable.Set[Int]()\\n    for (Array(p, c, isLeft) <- descriptions) {\\n      val pn = nodes.getOrElse(p, new TreeNode(p))\\n      val cn = nodes.getOrElse(c, new TreeNode(c))\\n      nodeHasParent.addOne(c)\\n      if (isLeft == 1)\\n        pn.left = cn\\n      else\\n        pn.right = cn\\n      nodes.put(p, pn)\\n      nodes.put(c, cn)\\n    }\\n    nodes(nodes.keySet.diff(nodeHasParent).head)\\n  }\\n}\\n```\\n\\nOr\\n\\n```\\nobject Solution {\\n  def createBinaryTree(descriptions: Array[Array[Int]]): TreeNode = {\\n    val nodes = scala.collection.mutable.Map[Int, TreeNode]()\\n    val nodeHasParent = scala.collection.mutable.Set[Int]()\\n    for (Array(p, c, isLeft) <- descriptions) {\\n      if (!nodes.contains(p))\\n        nodes += p -> new TreeNode(p)\\n      if (!nodes.contains(c))\\n        nodes += c -> new TreeNode(c)\\n      nodeHasParent.addOne(c)\\n      if (isLeft == 1)\\n        nodes(p).left = nodes(c)\\n      else\\n        nodes(p).right = nodes(c)\\n    }\\n    nodes(nodes.keySet.diff(nodeHasParent).head)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def createBinaryTree(descriptions: Array[Array[Int]]): TreeNode = {\\n    val nodes = scala.collection.mutable.Map[Int, TreeNode]()\\n    val nodeHasParent = scala.collection.mutable.Set[Int]()\\n    for (Array(p, c, isLeft) <- descriptions) {\\n      val pn = nodes.getOrElse(p, new TreeNode(p))\\n      val cn = nodes.getOrElse(c, new TreeNode(c))\\n      nodeHasParent.addOne(c)\\n      if (isLeft == 1)\\n        pn.left = cn\\n      else\\n        pn.right = cn\\n      nodes.put(p, pn)\\n      nodes.put(c, cn)\\n    }\\n    nodes(nodes.keySet.diff(nodeHasParent).head)\\n  }\\n}\\n```\n```\\nobject Solution {\\n  def createBinaryTree(descriptions: Array[Array[Int]]): TreeNode = {\\n    val nodes = scala.collection.mutable.Map[Int, TreeNode]()\\n    val nodeHasParent = scala.collection.mutable.Set[Int]()\\n    for (Array(p, c, isLeft) <- descriptions) {\\n      if (!nodes.contains(p))\\n        nodes += p -> new TreeNode(p)\\n      if (!nodes.contains(c))\\n        nodes += c -> new TreeNode(c)\\n      nodeHasParent.addOne(c)\\n      if (isLeft == 1)\\n        nodes(p).left = nodes(c)\\n      else\\n        nodes(p).right = nodes(c)\\n    }\\n    nodes(nodes.keySet.diff(nodeHasParent).head)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1825712,
                "title": "easy-js-javascript-solution-with-map-max-408-ms",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number[][]} descriptions\\n * @return {TreeNode}\\n */\\nvar createBinaryTree = function(descriptions) {\\n    let map = new Map();\\n    \\n    descriptions.forEach(([val,child,isLeft])=>{\\n        \\n        let node = map.get(val) || new TreeNode(val);\\n        \\n        let childNode =  map.get(child) || new TreeNode(child);\\n                \\n        if(isLeft) // left\\n         node.left =  childNode;\\n        else \\n         node.right = childNode;\\n        \\n        //parent\\n        map.set(val, node);\\n        //child\\n        map.set(child, childNode);\\n    });\\n    \\n    //console.log(map);\\n    \\n    // find the head\\n    let headVal = findTheHead(descriptions);\\n    \\n    return map.get(headVal);\\n};\\n\\n//only head val cannot be in the child set\\nconst findTheHead = (arr) => {\\n    let childs = new Set();\\n    arr.forEach(([parent,child,left])=>{\\n        childs.add(child);\\n    });\\n    //console.log(\\'childs\\',childs);\\n    for(let i=0; i<arr.length; i++){\\n        if(!childs.has(arr[i][0])) return arr[i][0];\\n    }\\n    return null;\\n}\\n\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number[][]} descriptions\\n * @return {TreeNode}\\n */\\nvar createBinaryTree = function(descriptions) {\\n    let map = new Map();\\n    \\n    descriptions.forEach(([val,child,isLeft])=>{\\n        \\n        let node = map.get(val) || new TreeNode(val);\\n        \\n        let childNode =  map.get(child) || new TreeNode(child);\\n                \\n        if(isLeft) // left\\n         node.left =  childNode;\\n        else \\n         node.right = childNode;\\n        \\n        //parent\\n        map.set(val, node);\\n        //child\\n        map.set(child, childNode);\\n    });\\n    \\n    //console.log(map);\\n    \\n    // find the head\\n    let headVal = findTheHead(descriptions);\\n    \\n    return map.get(headVal);\\n};\\n\\n//only head val cannot be in the child set\\nconst findTheHead = (arr) => {\\n    let childs = new Set();\\n    arr.forEach(([parent,child,left])=>{\\n        childs.add(child);\\n    });\\n    //console.log(\\'childs\\',childs);\\n    for(let i=0; i<arr.length; i++){\\n        if(!childs.has(arr[i][0])) return arr[i][0];\\n    }\\n    return null;\\n}\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1825055,
                "title": "c-map-implementation-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        \\n        // since values are unique there will be unique pointers\\n        // for each unique integer\\n        unordered_map<int,TreeNode*> ump; \\n        \\n        // map storing <x,y> where x is child of y\\n        unordered_map<int,int> pc; \\n        \\n        int parent = d[0][0];\\n        for(int i = 0;i<d.size();i+=1)\\n        {   \\n            \\n            int p = d[i][0]; // parent\\n            int c = d[i][1]; // child\\n            \\n            pc[c] = p; // p is set parent of child c\\n            if(parent==c){\\n                // if our assumed parent so far is a child\\n                // keep on searching parent in pc map\\n                while(pc.find(parent)!=pc.end())\\n                    parent = pc[parent];\\n            }\\n            int isLeft = d[i][2];\\n            \\n            if(ump.find(p)==ump.end())\\n                ump[p]= new TreeNode(p);\\n            \\n            if(ump.find(c)==ump.end())\\n                ump[c] = new TreeNode(c);\\n            \\n            \\n            if(isLeft)\\n                ump[p]->left = ump[c];\\n            \\n            else\\n                ump[p]->right = ump[c];\\n            \\n        }\\n\\n        return ump[parent];\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        \\n        // since values are unique there will be unique pointers\\n        // for each unique integer\\n        unordered_map<int,TreeNode*> ump; \\n        \\n        // map storing <x,y> where x is child of y\\n        unordered_map<int,int> pc; \\n        \\n        int parent = d[0][0];\\n        for(int i = 0;i<d.size();i+=1)\\n        {   \\n            \\n            int p = d[i][0]; // parent\\n            int c = d[i][1]; // child\\n            \\n            pc[c] = p; // p is set parent of child c\\n            if(parent==c){\\n                // if our assumed parent so far is a child\\n                // keep on searching parent in pc map\\n                while(pc.find(parent)!=pc.end())\\n                    parent = pc[parent];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1824839,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* check(TreeNode* root, vector<pair<int, int>>& v){\\n        if(!root) return NULL;\\n        if(v[root->val].first){\\n            root->left = new TreeNode(v[root->val].first);\\n            check(root->left, v);\\n        }\\n        if(v[root->val].second){\\n            root->right = new TreeNode(v[root->val].second);\\n            check(root->right, v);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_set<int> us;\\n        vector<pair<int, int>> v(100001, {0, 0});\\n        for(auto x: descriptions){\\n            us.insert(x[0]);\\n            if(x[2]) v[x[0]].first = x[1];\\n            else v[x[0]].second = x[1];\\n        }\\n        for(auto x: descriptions) if(us.count(x[1])) us.erase(x[1]);\\n        TreeNode *root = new TreeNode(*us.begin());\\n        return check(root, v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* check(TreeNode* root, vector<pair<int, int>>& v){\\n        if(!root) return NULL;\\n        if(v[root->val].first){\\n            root->left = new TreeNode(v[root->val].first);\\n            check(root->left, v);\\n        }\\n        if(v[root->val].second){\\n            root->right = new TreeNode(v[root->val].second);\\n            check(root->right, v);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_set<int> us;\\n        vector<pair<int, int>> v(100001, {0, 0});\\n        for(auto x: descriptions){\\n            us.insert(x[0]);\\n            if(x[2]) v[x[0]].first = x[1];\\n            else v[x[0]].second = x[1];\\n        }\\n        for(auto x: descriptions) if(us.count(x[1])) us.erase(x[1]);\\n        TreeNode *root = new TreeNode(*us.begin());\\n        return check(root, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824679,
                "title": "c-tree-map",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, int> left;\\n    unordered_map<int, int> right;\\n    unordered_map<int, int> parent;\\n    \\n    TreeNode* solve(int par){\\n        if(par == NULL) return NULL;\\n         \\n          TreeNode* root = new TreeNode(par);\\n        \\n          root->left = solve(left[par]);\\n               \\n          root->right = solve(right[par]);\\n          \\n        \\n        return root;\\n         \\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n\\t       // storing the left and right child of each node\\n\\t\\t   // each node can have at most 1 left and right child\\n                for(int i=0; i<descriptions.size(); i++){\\n                     \\n                    if(descriptions[i][2] == 1){\\n                        left[descriptions[i][0]]=descriptions[i][1];\\n                    }\\n                    if(descriptions[i][2] == 0) right[descriptions[i][0]]= descriptions[i][1];\\n                    \\n                    parent[descriptions[i][1]]++;\\n                }\\n             \\n               int par;\\n             // finding the parent node\\n             for(int i=0; i<descriptions.size(); i++){\\n                     if(parent.find(descriptions[i][0]) == parent.end()) {par = descriptions[i][0]; break;}\\n               }\\n             \\n            return solve(par);\\n                  \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<int, int> left;\\n    unordered_map<int, int> right;\\n    unordered_map<int, int> parent;\\n    \\n    TreeNode* solve(int par){\\n        if(par == NULL) return NULL;\\n         \\n          TreeNode* root = new TreeNode(par);\\n        \\n          root->left = solve(left[par]);\\n               \\n          root->right = solve(right[par]);\\n          \\n        \\n        return root;\\n         \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1824597,
                "title": "simple-solution-in-java-using-hashmap",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        \\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(int[] e : descriptions){\\n            TreeNode parentNode = getNodeIfPresentElseCreate(e[0],  map);\\n            \\n            if(e[2] == 1){\\n                TreeNode childNode = getNodeIfPresentElseCreate(e[1],  map);\\n                parentNode.left = childNode;\\n            }else{\\n                TreeNode childNode = getNodeIfPresentElseCreate(e[1],  map);\\n                parentNode.right = childNode;\\n            }\\n            \\n            set.add(e[1]);\\n        }\\n        \\n        for(int[] e : descriptions){\\n            if(!set.contains(e[0])) return map.get(e[0]);\\n        }\\n        \\n        return null;\\n    }\\n    \\n    private TreeNode getNodeIfPresentElseCreate(int node, HashMap<Integer, TreeNode> map){\\n        TreeNode newNode = null;\\n           if(map.containsKey(node)){\\n                newNode = map.get(node);\\n            }else{\\n                newNode = new TreeNode(node);\\n                map.put(node, newNode);\\n            }\\n                \\n        return newNode;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        \\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(int[] e : descriptions){\\n            TreeNode parentNode = getNodeIfPresentElseCreate(e[0],  map);\\n            \\n            if(e[2] == 1){\\n                TreeNode childNode = getNodeIfPresentElseCreate(e[1],  map);\\n                parentNode.left = childNode;\\n            }else{\\n                TreeNode childNode = getNodeIfPresentElseCreate(e[1],  map);\\n                parentNode.right = childNode;\\n            }\\n            \\n            set.add(e[1]);\\n        }\\n        \\n        for(int[] e : descriptions){\\n            if(!set.contains(e[0])) return map.get(e[0]);\\n        }\\n        \\n        return null;\\n    }\\n    \\n    private TreeNode getNodeIfPresentElseCreate(int node, HashMap<Integer, TreeNode> map){\\n        TreeNode newNode = null;\\n           if(map.containsKey(node)){\\n                newNode = map.get(node);\\n            }else{\\n                newNode = new TreeNode(node);\\n                map.put(node, newNode);\\n            }\\n                \\n        return newNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824226,
                "title": "c-hashmap-clean-and-concise",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode *>ma;\\n        unordered_map<int,int>indegree;\\n        \\n        for(auto &i:descriptions)\\n        {\\n            int parent=i[0];\\n            int child=i[1];\\n            indegree[child]++;\\n            if(ma.count(parent)==0)\\n                ma[parent]=new TreeNode(parent);\\n            if(ma.count(child)==0)\\n                ma[child]=new TreeNode(child);\\n            \\n            if(i[2]==1)\\n            {\\n                ma[parent]->left=ma[child];\\n            }\\n            else\\n            {\\n                ma[parent]->right=ma[child];\\n            }\\n        }\\n        \\n        for(auto i:ma)\\n        {\\n            if(indegree[i.first]==0)\\n                return i.second;\\n        }\\n        return NULL;\\n        \\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode *>ma;\\n        unordered_map<int,int>indegree;\\n        \\n        for(auto &i:descriptions)\\n        {\\n            int parent=i[0];\\n            int child=i[1];\\n            indegree[child]++;\\n            if(ma.count(parent)==0)\\n                ma[parent]=new TreeNode(parent);\\n            if(ma.count(child)==0)\\n                ma[child]=new TreeNode(child);\\n            \\n            if(i[2]==1)\\n            {\\n                ma[parent]->left=ma[child];\\n            }\\n            else\\n            {\\n                ma[parent]->right=ma[child];\\n            }\\n        }\\n        \\n        for(auto i:ma)\\n        {\\n            if(indegree[i.first]==0)\\n                return i.second;\\n        }\\n        return NULL;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824156,
                "title": "simple-recursion-solution-build-from-root",
                "content": "```\\n\\nclass Solution {\\npublic:unordered_map<int,pair<int,int>>mp;\\n\\n    TreeNode* solve(int x){\\n        if(x==0) return NULL;\\n        \\n        TreeNode* root = new TreeNode(x);\\n        \\n        root->left  = solve(mp[x].first);        \\n        root->right = solve(mp[x].second);\\n        \\n        return root;\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& a) {\\n        unordered_map<int,int> seen;\\n        for(auto &v:a) seen[v[1]] = 1;\\n        \\n        int rootval = -1;\\n        for(auto &v:a){\\n            if(seen[v[0]]==0) rootval = v[0];\\n            \\n            if(v[2]==1){\\n                mp[v[0]].first = v[1];\\n            }else{\\n                mp[v[0]].second = v[1];\\n            }\\n        }\\n        return solve(rootval);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:unordered_map<int,pair<int,int>>mp;\\n\\n    TreeNode* solve(int x){\\n        if(x==0) return NULL;\\n        \\n        TreeNode* root = new TreeNode(x);\\n        \\n        root->left  = solve(mp[x].first);        \\n        root->right = solve(mp[x].second);\\n        \\n        return root;\\n    }\\n    TreeNode* createBinaryTree(vector<vector<int>>& a) {\\n        unordered_map<int,int> seen;\\n        for(auto &v:a) seen[v[1]] = 1;\\n        \\n        int rootval = -1;\\n        for(auto &v:a){\\n            if(seen[v[0]]==0) rootval = v[0];\\n            \\n            if(v[2]==1){\\n                mp[v[0]].first = v[1];\\n            }else{\\n                mp[v[0]].second = v[1];\\n            }\\n        }\\n        return solve(rootval);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824140,
                "title": "c-using-hashmap",
                "content": "We check for the presence of each node in the hashmap and create new nodes if the they aren\\'t present in the map or else, we just link the tree nodes based on isLeftChild. We also use a map to find the root node which doesn\\'t have a parent.\\n```\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        TreeNode* root=nullptr;\\n        unordered_map<int,TreeNode*> hash;\\n        unordered_set<TreeNode*> child;\\n        for(int i=0; i<descriptions.size(); i++)\\n        {\\n            TreeNode *par=nullptr;\\n            auto it1=hash.find(descriptions[i][0]);\\n            if(it1==hash.end())\\n            {\\n                par=new TreeNode(descriptions[i][0]);\\n                hash[descriptions[i][0]]=par;\\n            }\\n            else\\n                par=it1->second;\\n            TreeNode *chi=nullptr;\\n            auto it2=hash.find(descriptions[i][1]);\\n            if(it2==hash.end())\\n            {\\n                chi=new TreeNode(descriptions[i][1]);\\n                hash[descriptions[i][1]]=chi;\\n            }\\n            else\\n                chi=it2->second;\\n            if(descriptions[i][2]==1)\\n                par->left=chi;\\n            else\\n                par->right=chi;\\n            child.insert(chi);\\n        }\\n        for(auto &x:hash)\\n        {\\n            if(child.find(x.second)==child.end())\\n            {\\n                root=x.second;\\n                break;\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        TreeNode* root=nullptr;\\n        unordered_map<int,TreeNode*> hash;\\n        unordered_set<TreeNode*> child;\\n        for(int i=0; i<descriptions.size(); i++)\\n        {\\n            TreeNode *par=nullptr;\\n            auto it1=hash.find(descriptions[i][0]);\\n            if(it1==hash.end())\\n            {\\n                par=new TreeNode(descriptions[i][0]);\\n                hash[descriptions[i][0]]=par;\\n            }\\n            else\\n                par=it1->second;\\n            TreeNode *chi=nullptr;\\n            auto it2=hash.find(descriptions[i][1]);\\n            if(it2==hash.end())\\n            {\\n                chi=new TreeNode(descriptions[i][1]);\\n                hash[descriptions[i][1]]=chi;\\n            }\\n            else\\n                chi=it2->second;\\n            if(descriptions[i][2]==1)\\n                par->left=chi;\\n            else\\n                par->right=chi;\\n            child.insert(chi);\\n        }\\n        for(auto &x:hash)\\n        {\\n            if(child.find(x.second)==child.end())\\n            {\\n                root=x.second;\\n                break;\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823947,
                "title": "weekly-contest-283-approach-using-map-easy-understandable-code-o-n",
                "content": "Please give a upvote if you like this solutions. Comment if you didn\\'t get it.\\n\\nThe given problem can be solved the traversing the given array of descriptions[] and pre-populate the Tree as per the given descriptions. We also required HashMap of pair<TreeNode*, int> which denotes whether the current Node can be root node or not. Below are the steps:\\n\\nInitialize a unordered_map, say **map** of the type <int, pair<TreeNode*, int>>.\\n1. Traverse the given array of **descriptions** and perform the following steps:\\n\\t1. Initialize a pair of TreeNode for the current parent and child node as:\\n\\t\\t1. P : { new TreeNode(it[0]), 1), C = {new TreeNode(it[1]), 1}, where 1 denotes that the current node can be root node.\\n\\t3. If the current node value **it[0] and it[1]** doesn\\'t exist in the map, then keep the above declaration as to the parent and child node respectively. Otherwise, choose the parent and child node from the map as that map will be updated as per the resultant tree.\\n\\t1. For the current child node, we are sure that he can\\'t become a root node. Therefore, make the second pair of it as **0**.\\n\\t1. Update the **left or right child of the parent** based on **isLeft(given by it[2])**.\\n1. After completing the above steps, the whole map would be updated and now we only need to find the root of the tree. We can find that root by **traversing the map** and checking whether the **second part of the pair of any node is 1** or not. If yes, then that **node is the root node.**\\n\\nBelow is the implementation of the above approach:\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr),\\n * right(nullptr) {} TreeNode(int x, TreeNode *left,\\n * TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    // Track the tree and whether any node\\n    // can be root or not\\n    unordered_map<int, pair<TreeNode*, int> > Map;\\n\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int> >& descriptions)\\n    {\\n        for (auto& it : descriptions) {\\n\\n            // Generate Parent (P) and Child(Q) node\\n            // if it is not present in the map\\n            pair<TreeNode*, int> P = { new TreeNode(it[0]), 1 },\\n                \\t\\t\\t\\t Q = { new TreeNode(it[1]), 1 };\\n\\n            // Find the parent and child node from\\n            // the map\\n            pair<TreeNode*, int> parentNode = (Map.find(it[0]) == Map.end() ? P : Map[it[0]]);\\n            pair<TreeNode*, int> childNode = (Map.find(it[1]) == Map.end() ? Q : Map[it[1]]);\\n\\n            // Mark the root possible of the\\n            // child node as false\\n            childNode.second = 0;\\n\\n            // Update the parent left or right\\n            // as child as per the information\\n            if (it[2]) {\\n                parentNode.first->left = childNode.first;\\n            }\\n            else {\\n                parentNode.first->right = childNode.first;\\n            }\\n\\n            // Update the map with the updated\\n            // tree\\n            Map[it[0]] = parentNode;\\n            Map[it[1]] = childNode;\\n        }\\n\\n        // Traverse the map and find the root\\n        // of the tree\\n        for (auto& it : Map) {\\n\\n            // Possible root condition\\n            if (it.second.second == 1)\\n\\n                // Return the root of the tree\\n                return Map[it.first].first;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n***Time Complexity:** O(N)\\n**Space Complexity:** O(N)*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr),\\n * right(nullptr) {} TreeNode(int x, TreeNode *left,\\n * TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    // Track the tree and whether any node\\n    // can be root or not\\n    unordered_map<int, pair<TreeNode*, int> > Map;\\n\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int> >& descriptions)\\n    {\\n        for (auto& it : descriptions) {\\n\\n            // Generate Parent (P) and Child(Q) node\\n            // if it is not present in the map\\n            pair<TreeNode*, int> P = { new TreeNode(it[0]), 1 },\\n                \\t\\t\\t\\t Q = { new TreeNode(it[1]), 1 };\\n\\n            // Find the parent and child node from\\n            // the map\\n            pair<TreeNode*, int> parentNode = (Map.find(it[0]) == Map.end() ? P : Map[it[0]]);\\n            pair<TreeNode*, int> childNode = (Map.find(it[1]) == Map.end() ? Q : Map[it[1]]);\\n\\n            // Mark the root possible of the\\n            // child node as false\\n            childNode.second = 0;\\n\\n            // Update the parent left or right\\n            // as child as per the information\\n            if (it[2]) {\\n                parentNode.first->left = childNode.first;\\n            }\\n            else {\\n                parentNode.first->right = childNode.first;\\n            }\\n\\n            // Update the map with the updated\\n            // tree\\n            Map[it[0]] = parentNode;\\n            Map[it[1]] = childNode;\\n        }\\n\\n        // Traverse the map and find the root\\n        // of the tree\\n        for (auto& it : Map) {\\n\\n            // Possible root condition\\n            if (it.second.second == 1)\\n\\n                // Return the root of the tree\\n                return Map[it.first].first;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823942,
                "title": "simple-c-easy-to-understand",
                "content": "```\\n TreeNode* createBinaryTree(vector<vector<int>>& desc) {\\n        unordered_map<int,Node*>exist;\\n        unordered_map<int,bool>isNotroot;\\n        for(int i=0;i<desc.size();i++){\\n            int u=desc[i][0];\\n            int v=desc[i][1];\\n            int is=desc[i][2];\\n            \\n            \\n            Node*par=NULL,*child=NULL;\\n            \\n            if(exist.find(u)==exist.end()){\\n                par=new Node(u);\\n                exist[u]=par;\\n            \\n            }else \\n                par=exist[u];\\n           \\n            if(exist.find(v)==exist.end()){\\n                child=new Node(v);\\n                exist[v]=child;\\n            }\\n            else \\n                child=exist[v];\\n            \\n            \\n            if(is)\\n                par->left=child;\\n            else \\n                par->right=child;\\n            \\n            \\n            isNotroot[v]=true;\\n        }\\n        for(auto it:exist){\\n            if(isNotroot[it.first]==false)return it.second;\\n        }\\n        return NULL;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n TreeNode* createBinaryTree(vector<vector<int>>& desc) {\\n        unordered_map<int,Node*>exist;\\n        unordered_map<int,bool>isNotroot;\\n        for(int i=0;i<desc.size();i++){\\n            int u=desc[i][0];\\n            int v=desc[i][1];\\n            int is=desc[i][2];\\n            \\n            \\n            Node*par=NULL,*child=NULL;\\n            \\n            if(exist.find(u)==exist.end()){\\n                par=new Node(u);\\n                exist[u]=par;\\n            \\n            }else \\n                par=exist[u];\\n           \\n            if(exist.find(v)==exist.end()){\\n                child=new Node(v);\\n                exist[v]=child;\\n            }\\n            else \\n                child=exist[v];\\n            \\n            \\n            if(is)\\n                par->left=child;\\n            else \\n                par->right=child;\\n            \\n            \\n            isNotroot[v]=true;\\n        }\\n        for(auto it:exist){\\n            if(isNotroot[it.first]==false)return it.second;\\n        }\\n        return NULL;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823924,
                "title": "c-solution-hashmap-o-n-easy-store-nodes-in-map",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        \\n        unordered_map<int,TreeNode*> mpp;\\n        unordered_set<TreeNode*> allNodes;\\n        unordered_map<TreeNode* , TreeNode*> cToP;\\n       \\n        for(auto &it:descriptions)\\n        {\\n            int par=it[0] , child=it[1];\\n            bool isLeft=it[2];\\n            \\n            TreeNode* node;\\n            TreeNode* bccha;\\n            if(mpp.find(par)==mpp.end())\\n            {\\n               node=new TreeNode(par);\\n                if(mpp.find(child)==mpp.end())\\n                {\\n                    bccha =new TreeNode(child);\\n                    mpp[child]=bccha;\\n                    \\n                }\\n                else\\n                    bccha=mpp[child];\\n                \\n                if(isLeft)\\n                    node->left=bccha;\\n                else\\n                    node->right=bccha;\\n                \\n                mpp[par]=node;\\n                \\n                \\n                \\n                \\n            }\\n            else\\n            {\\n                node=mpp[par];\\n\\n                \\n                if(mpp.find(child)==mpp.end())\\n                {\\n                    bccha=new TreeNode(child);\\n                    mpp[child]=bccha;\\n                    \\n                }\\n                else\\n                {\\n                    bccha=mpp[child];\\n                  \\n                       \\n                }\\n                    \\n                \\n                if(isLeft)\\n                    node->left=bccha;\\n                else\\n                    node->right=bccha;\\n                \\n              \\n            }\\n            \\n            cToP[bccha]=node;\\n            allNodes.insert(node);\\n            allNodes.insert(bccha);\\n            \\n            \\n\\n            \\n        }\\n        \\n        \\n        for(auto &it:allNodes)\\n        {\\n            if(cToP.find(it)==cToP.end())\\n                return it;\\n        }\\n       \\n        \\n        return NULL;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        \\n        unordered_map<int,TreeNode*> mpp;\\n        unordered_set<TreeNode*> allNodes;\\n        unordered_map<TreeNode* , TreeNode*> cToP;\\n       \\n        for(auto &it:descriptions)\\n        {\\n            int par=it[0] , child=it[1];\\n            bool isLeft=it[2];\\n            \\n            TreeNode* node;\\n            TreeNode* bccha;\\n            if(mpp.find(par)==mpp.end())\\n            {\\n               node=new TreeNode(par);\\n                if(mpp.find(child)==mpp.end())\\n                {\\n                    bccha =new TreeNode(child);\\n                    mpp[child]=bccha;\\n                    \\n                }\\n                else\\n                    bccha=mpp[child];\\n                \\n                if(isLeft)\\n                    node->left=bccha;\\n                else\\n                    node->right=bccha;\\n                \\n                mpp[par]=node;\\n                \\n                \\n                \\n                \\n            }\\n            else\\n            {\\n                node=mpp[par];\\n\\n                \\n                if(mpp.find(child)==mpp.end())\\n                {\\n                    bccha=new TreeNode(child);\\n                    mpp[child]=bccha;\\n                    \\n                }\\n                else\\n                {\\n                    bccha=mpp[child];\\n                  \\n                       \\n                }\\n                    \\n                \\n                if(isLeft)\\n                    node->left=bccha;\\n                else\\n                    node->right=bccha;\\n                \\n              \\n            }\\n            \\n            cToP[bccha]=node;\\n            allNodes.insert(node);\\n            allNodes.insert(bccha);\\n            \\n            \\n\\n            \\n        }\\n        \\n        \\n        for(auto &it:allNodes)\\n        {\\n            if(cToP.find(it)==cToP.end())\\n                return it;\\n        }\\n       \\n        \\n        return NULL;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823917,
                "title": "hashmap-binary-tree-java-solution",
                "content": "\\n   Make a pair class --->\\n   \\n        TreeNode node;\\n        TreeNode par;\\n        Pair(TreeNode node,TreeNode par)\\n        {\\n            this.node=node;\\n            this.par=par;\\n        }\\n    }\\n   \\n   main code starts here---->\\n   \\n        HashMap<Integer,Pair> map=new HashMap<>();\\n        for(int[] des: descriptions)\\n        {\\n            TreeNode root=null;\\n            if(map.containsKey(des[0]))\\n            {\\n                root=map.get(des[0]).node;\\n            }else{\\n                root=new TreeNode(des[0]);\\n                map.put(des[0],new Pair(root,null));\\n            }\\n            \\n            if(des[2]==1)\\n            {\\n                if(map.containsKey(des[1]))\\n                {\\n                    root.left=map.get(des[1]).node; \\n                }else{\\n                    root.left=new TreeNode(des[1]);\\n                }\\n                map.put(des[1],new Pair(root.left,root));\\n            }else{\\n                if(map.containsKey(des[1]))\\n                {\\n                    root.right=map.get(des[1]).node;\\n                }else{\\n                    root.right=new TreeNode(des[1]);\\n                }\\n                map.put(des[1],new Pair(root.right,root));\\n            }\\n        }\\n        for(int val: map.keySet())\\n        {\\n            Pair rem=map.get(val);\\n            if(rem.par==null)\\n            {\\n                return rem.node;\\n            }\\n        }\\n        return null;\\n",
                "solutionTags": [],
                "code": "\\n   Make a pair class --->\\n   \\n        TreeNode node;\\n        TreeNode par;\\n        Pair(TreeNode node,TreeNode par)\\n        {\\n            this.node=node;\\n            this.par=par;\\n        }\\n    }\\n   \\n   main code starts here---->\\n   \\n        HashMap<Integer,Pair> map=new HashMap<>();\\n        for(int[] des: descriptions)\\n        {\\n            TreeNode root=null;\\n            if(map.containsKey(des[0]))\\n            {\\n                root=map.get(des[0]).node;\\n            }else{\\n                root=new TreeNode(des[0]);\\n                map.put(des[0],new Pair(root,null));\\n            }\\n            \\n            if(des[2]==1)\\n            {\\n                if(map.containsKey(des[1]))\\n                {\\n                    root.left=map.get(des[1]).node; \\n                }else{\\n                    root.left=new TreeNode(des[1]);\\n                }\\n                map.put(des[1],new Pair(root.left,root));\\n            }else{\\n                if(map.containsKey(des[1]))\\n                {\\n                    root.right=map.get(des[1]).node;\\n                }else{\\n                    root.right=new TreeNode(des[1]);\\n                }\\n                map.put(des[1],new Pair(root.right,root));\\n            }\\n        }\\n        for(int val: map.keySet())\\n        {\\n            Pair rem=map.get(val);\\n            if(rem.par==null)\\n            {\\n                return rem.node;\\n            }\\n        }\\n        return null;\\n",
                "codeTag": "Java"
            },
            {
                "id": 1823899,
                "title": "simple-java-solution-using-hashmap-and-xor",
                "content": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        int XorOfNodes = 0;\\n        for(int[] d : descriptions){\\n            TreeNode parent = null;\\n            TreeNode child = null;\\n            \\n            if(!map.containsKey(d[0])){\\n                parent = new TreeNode(d[0]);\\n                map.put(d[0], parent);\\n            }\\n            else\\n                parent = map.get(d[0]);\\n            \\n            if(!map.containsKey(d[1])){\\n                child = new TreeNode(d[1]);\\n                map.put(d[1], child);\\n            }\\n            else\\n                child = map.get(d[1]);\\n            \\n            if(d[2] == 1)\\n                parent.left = child;\\n            else\\n                parent.right = child;\\n            \\n            XorOfNodes ^= d[1];\\n        }\\n        \\n        for(int key : map.keySet()){\\n            XorOfNodes ^= key;\\n        }\\n        \\n        return map.get(XorOfNodes);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        int XorOfNodes = 0;\\n        for(int[] d : descriptions){\\n            TreeNode parent = null;\\n            TreeNode child = null;\\n            \\n            if(!map.containsKey(d[0])){\\n                parent = new TreeNode(d[0]);\\n                map.put(d[0], parent);\\n            }\\n            else\\n                parent = map.get(d[0]);\\n            \\n            if(!map.containsKey(d[1])){\\n                child = new TreeNode(d[1]);\\n                map.put(d[1], child);\\n            }\\n            else\\n                child = map.get(d[1]);\\n            \\n            if(d[2] == 1)\\n                parent.left = child;\\n            else\\n                parent.right = child;\\n            \\n            XorOfNodes ^= d[1];\\n        }\\n        \\n        for(int key : map.keySet()){\\n            XorOfNodes ^= key;\\n        }\\n        \\n        return map.get(XorOfNodes);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823898,
                "title": "java-simple-solution-recursion",
                "content": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashSet<Integer> parents = new HashSet<>(), children = new HashSet<>();\\n        HashMap<Integer, Integer> left = new HashMap<>(), right = new HashMap<>();\\n        for(int edge[] : descriptions) {\\n            int parent = edge[0];\\n            int child = edge[1];\\n            boolean isLeft = edge[2] == 1 ? true : false;\\n            parents.add(parent);\\n            children.add(child);\\n            if(isLeft)\\n                left.put(parent, child);\\n            else\\n                right.put(parent, child);\\n        }\\n        parents.removeAll(children);\\n        int root = parents.iterator().next();\\n        return f(left, right, root);\\n    }\\n    \\n    private TreeNode f(HashMap<Integer, Integer> left, HashMap<Integer, Integer> right, int x) {\\n        TreeNode root = new TreeNode(x);\\n        if(left.containsKey(x))\\n            root.left = f(left, right, left.get(x));\\n        if(right.containsKey(x))\\n            root.right = f(left, right, right.get(x));\\n        return root;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashSet<Integer> parents = new HashSet<>(), children = new HashSet<>();\\n        HashMap<Integer, Integer> left = new HashMap<>(), right = new HashMap<>();\\n        for(int edge[] : descriptions) {\\n            int parent = edge[0];\\n            int child = edge[1];\\n            boolean isLeft = edge[2] == 1 ? true : false;\\n            parents.add(parent);\\n            children.add(child);\\n            if(isLeft)\\n                left.put(parent, child);\\n            else\\n                right.put(parent, child);\\n        }\\n        parents.removeAll(children);\\n        int root = parents.iterator().next();\\n        return f(left, right, root);\\n    }\\n    \\n    private TreeNode f(HashMap<Integer, Integer> left, HashMap<Integer, Integer> right, int x) {\\n        TreeNode root = new TreeNode(x);\\n        if(left.containsKey(x))\\n            root.left = f(left, right, left.get(x));\\n        if(right.containsKey(x))\\n            root.right = f(left, right, right.get(x));\\n        return root;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823869,
                "title": "c-root-node-is-the-node-that-does-not-appear-as-a-child",
                "content": "Build a map to store the information of the tree.\\n\\nThen we do a dfs from the root node to build the tree.\\n\\nWe can find the root node by the following statement: \"If a node in a tree never becomes a child, then it is the root node of the tree.\"\\n\\n```\\nclass Solution {\\n    vector<array<int, 2>> tree;\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        tree.resize(100001);\\n        unordered_set<int> child;\\n        for (auto& d : descriptions) {\\n            if (d[2]) {\\n                tree[d[0]][0] = d[1]; \\n            } else {\\n                tree[d[0]][1] = d[1]; \\n            }\\n            child.insert(d[1]);\\n        }\\n        \\n        TreeNode* root = NULL;\\n        for (auto& p : descriptions) {\\n            if (child.find(p[0]) == child.end()) {\\n                root = new TreeNode(p[0]);\\n                break;\\n            }\\n        }\\n        \\n        dfs(root);\\n        return root;\\n    }\\n    \\n    void dfs(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n        \\n        if (tree[root->val][0] != NULL) {\\n            root->left = new TreeNode(tree[root->val][0]);\\n            dfs(root->left);\\n        }\\n        if (tree[root->val][1] != NULL) {\\n            root->right = new TreeNode(tree[root->val][1]);\\n            dfs(root->right);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<array<int, 2>> tree;\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        tree.resize(100001);\\n        unordered_set<int> child;\\n        for (auto& d : descriptions) {\\n            if (d[2]) {\\n                tree[d[0]][0] = d[1]; \\n            } else {\\n                tree[d[0]][1] = d[1]; \\n            }\\n            child.insert(d[1]);\\n        }\\n        \\n        TreeNode* root = NULL;\\n        for (auto& p : descriptions) {\\n            if (child.find(p[0]) == child.end()) {\\n                root = new TreeNode(p[0]);\\n                break;\\n            }\\n        }\\n        \\n        dfs(root);\\n        return root;\\n    }\\n    \\n    void dfs(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n        \\n        if (tree[root->val][0] != NULL) {\\n            root->left = new TreeNode(tree[root->val][0]);\\n            dfs(root->left);\\n        }\\n        if (tree[root->val][1] != NULL) {\\n            root->right = new TreeNode(tree[root->val][1]);\\n            dfs(root->right);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823838,
                "title": "c-hashmap-well-commented-code",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        int n = des.size();\\n        \\n        //Map \"mp\" will store the key-value pair of {node\\'s value, node\\'s address} for fututre reference\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int par = des[i][0];\\n            int child = des[i][1];\\n            int isLeft = des[i][2]; \\n            \\n            //If parent is absent in mp, create a fresh new node and store it in mp\\n            if(mp.find(par)==mp.end())\\n            {\\n               TreeNode* newNode = new TreeNode(par);\\n               mp[par] = newNode;\\n            }\\n            \\n            //If child is absent in mp, create a new child node and store it in mp\\n            if(mp.find(child)==mp.end())\\n            {\\n               TreeNode* newNode = new TreeNode(child);\\n               mp[child] = newNode;\\n            }\\n            \\n            //If isLeft variable is 1, attach the child node as the left child of parent\\n            //Use the addresses stored in mp\\n            if(isLeft==1)\\n            {\\n                mp[par]->left = mp[child];\\n            }\\n            else\\n            {\\n                mp[par]->right = mp[child];\\n            }\\n        }\\n        \\n        //Finding which node is root node\\n        \\n        //Creating 2 sets, \\n        //set s1 will store all the parent nodes given in the input\\n        //set s2 will store all the child nodes given in the input\\n        \\n        unordered_set<int> s1,s2;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n           s1.insert(des[i][0]);\\n           s2.insert(des[i][1]);\\n        }\\n        \\n        //For all nodes present in set s1, check if that node is present in set s2,\\n        //if it is found in s2, then it cannot be a root node(since it has a parent \\n        //and root nodes don\\'t have a parent), else if it is not present , \\n        //that node is our root node\\n        \\n        int root;\\n        for(auto x : s1)\\n        {\\n           if(s2.find(x)==s2.end()){\\n             root = x;\\n             break;\\n           }\\n        }\\n        \\n        //returning address of root node stored in mp\\n        return mp[root];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        int n = des.size();\\n        \\n        //Map \"mp\" will store the key-value pair of {node\\'s value, node\\'s address} for fututre reference\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int par = des[i][0];\\n            int child = des[i][1];\\n            int isLeft = des[i][2]; \\n            \\n            //If parent is absent in mp, create a fresh new node and store it in mp\\n            if(mp.find(par)==mp.end())\\n            {\\n               TreeNode* newNode = new TreeNode(par);\\n               mp[par] = newNode;\\n            }\\n            \\n            //If child is absent in mp, create a new child node and store it in mp\\n            if(mp.find(child)==mp.end())\\n            {\\n               TreeNode* newNode = new TreeNode(child);\\n               mp[child] = newNode;\\n            }\\n            \\n            //If isLeft variable is 1, attach the child node as the left child of parent\\n            //Use the addresses stored in mp\\n            if(isLeft==1)\\n            {\\n                mp[par]->left = mp[child];\\n            }\\n            else\\n            {\\n                mp[par]->right = mp[child];\\n            }\\n        }\\n        \\n        //Finding which node is root node\\n        \\n        //Creating 2 sets, \\n        //set s1 will store all the parent nodes given in the input\\n        //set s2 will store all the child nodes given in the input\\n        \\n        unordered_set<int> s1,s2;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n           s1.insert(des[i][0]);\\n           s2.insert(des[i][1]);\\n        }\\n        \\n        //For all nodes present in set s1, check if that node is present in set s2,\\n        //if it is found in s2, then it cannot be a root node(since it has a parent \\n        //and root nodes don\\'t have a parent), else if it is not present , \\n        //that node is our root node\\n        \\n        int root;\\n        for(auto x : s1)\\n        {\\n           if(s2.find(x)==s2.end()){\\n             root = x;\\n             break;\\n           }\\n        }\\n        \\n        //returning address of root node stored in mp\\n        return mp[root];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823837,
                "title": "c-simple-and-clean-code-store-details-of-node-in-map",
                "content": "The idea is simple.\\n* First store the details of every parent node in a map.\\n* Each key in map maps to a vector of pairs, which stores the value of each child and it is left or not.\\n* Keep a set to store every child.\\n* Traverse in the ``descriptions`` vector and find which node is not a child, i.e. which is not present in the set. That node will be our root node.\\n* Finally create the root node and using recursion build the tree.\\n\\n```\\nclass Solution {\\npublic:\\n    void makeTree(TreeNode *root, unordered_map<int,vector<pair<int,int>>>& m)\\n    {\\n        if(m.find(root -> val) == m.end()) return;\\n        \\n       \\n            for(int i = 0; i < m[root -> val].size() ; i++)\\n            {\\n                int child = m[root -> val][i].first;\\n                int isLeft = m[root -> val][i].second;\\n\\n                if(isLeft)\\n                {\\n                    root -> left = new TreeNode(child);\\n                    makeTree(root -> left, m);\\n                }\\n                \\n                else\\n                {\\n                    root -> right = new TreeNode(child);\\n                    makeTree(root -> right, m);\\n                }\\n            }\\n        \\n    }\\n    \\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) \\n    {\\n        unordered_map<int,vector<pair<int,int>>> m;\\n        unordered_set<int> s;\\n        \\n        for(int i = 0; i < descriptions.size() ;i++)\\n        {\\n            int parent = descriptions[i][0];\\n            int child = descriptions[i][1];\\n            int isLeft = descriptions[i][2];\\n            \\n            s.insert(child);\\n            m[parent].push_back({make_pair(child,isLeft)});\\n        }\\n        \\n        int rootVal;\\n        for(int i = 0; i < descriptions.size() ;i++)\\n        {\\n            if(s.find(descriptions[i][0]) == s.end())\\n                rootVal = descriptions[i][0];\\n        }\\n        \\n        TreeNode *root = new TreeNode(rootVal);\\n        makeTree(root,m);\\n        return root;\\n    }\\n};\\n```\\n\\nPlease consider upvoting, if you find it useful :)",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void makeTree(TreeNode *root, unordered_map<int,vector<pair<int,int>>>& m)\\n    {\\n        if(m.find(root -> val) == m.end()) return;\\n        \\n       \\n            for(int i = 0; i < m[root -> val].size() ; i++)\\n            {\\n                int child = m[root -> val][i].first;\\n                int isLeft = m[root -> val][i].second;\\n\\n                if(isLeft)\\n                {\\n                    root -> left = new TreeNode(child);\\n                    makeTree(root -> left, m);\\n                }\\n                \\n                else\\n                {\\n                    root -> right = new TreeNode(child);\\n                    makeTree(root -> right, m);\\n                }\\n            }\\n        \\n    }\\n    \\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) \\n    {\\n        unordered_map<int,vector<pair<int,int>>> m;\\n        unordered_set<int> s;\\n        \\n        for(int i = 0; i < descriptions.size() ;i++)\\n        {\\n            int parent = descriptions[i][0];\\n            int child = descriptions[i][1];\\n            int isLeft = descriptions[i][2];\\n            \\n            s.insert(child);\\n            m[parent].push_back({make_pair(child,isLeft)});\\n        }\\n        \\n        int rootVal;\\n        for(int i = 0; i < descriptions.size() ;i++)\\n        {\\n            if(s.find(descriptions[i][0]) == s.end())\\n                rootVal = descriptions[i][0];\\n        }\\n        \\n        TreeNode *root = new TreeNode(rootVal);\\n        makeTree(root,m);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823817,
                "title": "100-faster-time-o-n-easy-c-solution-optimized",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode*> umap;\\n        unordered_map<int,int> parent;\\n        for(int i=0;i<descriptions.size();i++)\\n        {\\n            if(umap[descriptions[i][0]]!=NULL)\\n            {\\n                if(umap[descriptions[i][1]]!=NULL)\\n                {\\n                    if(descriptions[i][2]==1)\\n                    {\\n                        umap[descriptions[i][0]]->left=umap[descriptions[i][1]];\\n                    }\\n                    else\\n                    {\\n                        umap[descriptions[i][0]]->right=umap[descriptions[i][1]];\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* temp=new TreeNode(descriptions[i][1]);\\n                    umap[descriptions[i][1]]=temp;\\n                    if(descriptions[i][2]==1)\\n                    {\\n                        umap[descriptions[i][0]]->left=umap[descriptions[i][1]];\\n                    }\\n                    else\\n                    {\\n                        umap[descriptions[i][0]]->right=umap[descriptions[i][1]];\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                TreeNode* temp1=new TreeNode(descriptions[i][0]);\\n                    umap[descriptions[i][0]]=temp1;\\n                if(umap[descriptions[i][1]]!=NULL)\\n                {\\n                    if(descriptions[i][2]==1)\\n                    {\\n                        umap[descriptions[i][0]]->left=umap[descriptions[i][1]];\\n                    }\\n                    else\\n                    {\\n                        umap[descriptions[i][0]]->right=umap[descriptions[i][1]];\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* temp=new TreeNode(descriptions[i][1]);\\n                    umap[descriptions[i][1]]=temp;\\n                    if(descriptions[i][2]==1)\\n                    {\\n                        umap[descriptions[i][0]]->left=umap[descriptions[i][1]];\\n                    }\\n                    else\\n                    {\\n                        umap[descriptions[i][0]]->right=umap[descriptions[i][1]];\\n                    }\\n                }\\n            }\\n            parent[descriptions[i][1]]=1;\\n        }\\n        for(int i=0;i<i<descriptions.size();i++)\\n        {\\n            if(parent[descriptions[i][0]]==0)\\n                return umap[descriptions[i][0]];\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n**Like it? Please Upvote :-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode*> umap;\\n        unordered_map<int,int> parent;\\n        for(int i=0;i<descriptions.size();i++)\\n        {\\n            if(umap[descriptions[i][0]]!=NULL)\\n            {\\n                if(umap[descriptions[i][1]]!=NULL)\\n                {\\n                    if(descriptions[i][2]==1)\\n                    {\\n                        umap[descriptions[i][0]]->left=umap[descriptions[i][1]];\\n                    }\\n                    else\\n                    {\\n                        umap[descriptions[i][0]]->right=umap[descriptions[i][1]];\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* temp=new TreeNode(descriptions[i][1]);\\n                    umap[descriptions[i][1]]=temp;\\n                    if(descriptions[i][2]==1)\\n                    {\\n                        umap[descriptions[i][0]]->left=umap[descriptions[i][1]];\\n                    }\\n                    else\\n                    {\\n                        umap[descriptions[i][0]]->right=umap[descriptions[i][1]];\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                TreeNode* temp1=new TreeNode(descriptions[i][0]);\\n                    umap[descriptions[i][0]]=temp1;\\n                if(umap[descriptions[i][1]]!=NULL)\\n                {\\n                    if(descriptions[i][2]==1)\\n                    {\\n                        umap[descriptions[i][0]]->left=umap[descriptions[i][1]];\\n                    }\\n                    else\\n                    {\\n                        umap[descriptions[i][0]]->right=umap[descriptions[i][1]];\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* temp=new TreeNode(descriptions[i][1]);\\n                    umap[descriptions[i][1]]=temp;\\n                    if(descriptions[i][2]==1)\\n                    {\\n                        umap[descriptions[i][0]]->left=umap[descriptions[i][1]];\\n                    }\\n                    else\\n                    {\\n                        umap[descriptions[i][0]]->right=umap[descriptions[i][1]];\\n                    }\\n                }\\n            }\\n            parent[descriptions[i][1]]=1;\\n        }\\n        for(int i=0;i<i<descriptions.size();i++)\\n        {\\n            if(parent[descriptions[i][0]]==0)\\n                return umap[descriptions[i][0]];\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823783,
                "title": "java-hashmap-o-n",
                "content": "Concept : Use Hasmap to remember nodes. And at last to find root just see which node has no parent\\nTC: O(Descriptions length)\\nSC: O(Number of nodes)\\n```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer,TreeNode> map=new HashMap<>();\\n        Set<Integer> set=new HashSet<>();\\n        for(int[] d:descriptions){\\n            TreeNode p=map.getOrDefault(d[0],new TreeNode(d[0]));\\n            TreeNode c=map.getOrDefault(d[1],new TreeNode(d[1]));\\n            if(d[2]==1){\\n                p.left=c;\\n            }\\n            else\\n                p.right=c;\\n            \\n            map.put(d[0],p);\\n            map.put(d[1],c);\\n            set.add(c.val);\\n        }\\n        \\n        for(int key:map.keySet()){\\n            if(!set.contains(key))\\n                return map.get(key);\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer,TreeNode> map=new HashMap<>();\\n        Set<Integer> set=new HashSet<>();\\n        for(int[] d:descriptions){\\n            TreeNode p=map.getOrDefault(d[0],new TreeNode(d[0]));\\n            TreeNode c=map.getOrDefault(d[1],new TreeNode(d[1]));\\n            if(d[2]==1){\\n                p.left=c;\\n            }\\n            else\\n                p.right=c;\\n            \\n            map.put(d[0],p);\\n            map.put(d[1],c);\\n            set.add(c.val);\\n        }\\n        \\n        for(int key:map.keySet()){\\n            if(!set.contains(key))\\n                return map.get(key);\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823764,
                "title": "c-o-n-time-hashmap-easy-to-understand-with-comments-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        \\n        unordered_map<int, TreeNode*> hash;\\n        \\n        unordered_map<TreeNode*, bool> canBeRoot;\\n        \\n        for(auto d: descriptions) {\\n            \\n            if(!hash[d[0]]) { // the parent node does not exist, so create one\\n                TreeNode* node = new TreeNode(d[0]);\\n                hash[d[0]] = node;\\n                if(canBeRoot.count(node) == 0) { // if this node does not exist in canBeParent then add it\\n                    canBeRoot[node] = true;\\n                }\\n            }\\n            TreeNode* parent = hash[d[0]];\\n            \\n                \\n            if(!hash[d[1]]) { // if the child does not exist then create one\\n                TreeNode* child = new TreeNode(d[1]);\\n                hash[d[1]] = child;\\n            }\\n\\n            TreeNode* child = hash[d[1]];\\n            canBeRoot[child] = false; // child can not be the root\\n\\n\\n            // add child to the parent\\n            if(d[2] == 1) { \\n                parent->left = child;\\n            }\\n            else {\\n                parent->right = child;\\n            }\\n            \\n        }\\n        \\n        for(auto it: canBeRoot) {\\n            if(it.second) {\\n                return it.first;\\n            }\\n        }\\n        \\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        \\n        unordered_map<int, TreeNode*> hash;\\n        \\n        unordered_map<TreeNode*, bool> canBeRoot;\\n        \\n        for(auto d: descriptions) {\\n            \\n            if(!hash[d[0]]) { // the parent node does not exist, so create one\\n                TreeNode* node = new TreeNode(d[0]);\\n                hash[d[0]] = node;\\n                if(canBeRoot.count(node) == 0) { // if this node does not exist in canBeParent then add it\\n                    canBeRoot[node] = true;\\n                }\\n            }\\n            TreeNode* parent = hash[d[0]];\\n            \\n                \\n            if(!hash[d[1]]) { // if the child does not exist then create one\\n                TreeNode* child = new TreeNode(d[1]);\\n                hash[d[1]] = child;\\n            }\\n\\n            TreeNode* child = hash[d[1]];\\n            canBeRoot[child] = false; // child can not be the root\\n\\n\\n            // add child to the parent\\n            if(d[2] == 1) { \\n                parent->left = child;\\n            }\\n            else {\\n                parent->right = child;\\n            }\\n            \\n        }\\n        \\n        for(auto it: canBeRoot) {\\n            if(it.second) {\\n                return it.first;\\n            }\\n        }\\n        \\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823749,
                "title": "python-o-n-faster-and-optimized-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, d: List[List[int]]) -> Optional[TreeNode]:\\n        m = {}\\n        p = set()\\n        for i in range(len(d)):\\n            if d[i][0] in m:\\n                a = m[d[i][0]]\\n            else:\\n                a = TreeNode(d[i][0])\\n            \\n            if d[i][1] in m:\\n                b = m[d[i][1]]\\n            else:\\n                b = TreeNode(d[i][1])\\n            if d[i][2]==1:\\n                a.left = b \\n            else:\\n                a.right = b \\n            m[d[i][0]] = a \\n            m[d[i][1]] = b\\n            p.add(d[i][1])\\n        x = list(m.keys()-p) \\n        return m[x[0]]\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, d: List[List[int]]) -> Optional[TreeNode]:\\n        m = {}\\n        p = set()\\n        for i in range(len(d)):\\n            if d[i][0] in m:\\n                a = m[d[i][0]]\\n            else:\\n                a = TreeNode(d[i][0])\\n            \\n            if d[i][1] in m:\\n                b = m[d[i][1]]\\n            else:\\n                b = TreeNode(d[i][1])\\n            if d[i][2]==1:\\n                a.left = b \\n            else:\\n                a.right = b \\n            m[d[i][0]] = a \\n            m[d[i][1]] = b\\n            p.add(d[i][1])\\n        x = list(m.keys()-p) \\n        return m[x[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823748,
                "title": "c-unordered-map-int-pair-int-bool-basic-tree-fundamental",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& desc) {\\n        unordered_map<int,pair<TreeNode*,bool>> mp; // { node->val , { acutal node , haveParent } }\\n        \\n        for(auto it : desc){\\n            int root = it[0], child = it[1];\\n            bool isleft = it[2];\\n            \\n            // setting up for child node\\n            TreeNode* kid;\\n            if(mp.find(child) != mp.end()){\\n                kid = mp[child].first;\\n                mp[child].second = true;\\n            }else{\\n                kid = new TreeNode(child);\\n                mp[child] = {kid,true};\\n            }\\n            \\n            // setting up for parent node\\n            TreeNode* head;\\n            if(mp.find(root) != mp.end()){\\n                head = mp[root].first;\\n            }else{\\n                head = new TreeNode(root);\\n                mp[root] = {head,false};                \\n            }\\n            \\n            // attaching at appropriate position\\n            if(isleft){\\n                head->left = kid;\\n            }else{\\n                head->right = kid;\\n            }            \\n        }\\n        \\n        // Node who doesn\\'t have any parent is the root node\\n        for(auto it : mp){\\n            if(!it.second.second) return it.second.first;\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& desc) {\\n        unordered_map<int,pair<TreeNode*,bool>> mp; // { node->val , { acutal node , haveParent } }\\n        \\n        for(auto it : desc){\\n            int root = it[0], child = it[1];\\n            bool isleft = it[2];\\n            \\n            // setting up for child node\\n            TreeNode* kid;\\n            if(mp.find(child) != mp.end()){\\n                kid = mp[child].first;\\n                mp[child].second = true;\\n            }else{\\n                kid = new TreeNode(child);\\n                mp[child] = {kid,true};\\n            }\\n            \\n            // setting up for parent node\\n            TreeNode* head;\\n            if(mp.find(root) != mp.end()){\\n                head = mp[root].first;\\n            }else{\\n                head = new TreeNode(root);\\n                mp[root] = {head,false};                \\n            }\\n            \\n            // attaching at appropriate position\\n            if(isleft){\\n                head->left = kid;\\n            }else{\\n                head->right = kid;\\n            }            \\n        }\\n        \\n        // Node who doesn\\'t have any parent is the root node\\n        for(auto it : mp){\\n            if(!it.second.second) return it.second.first;\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823743,
                "title": "java-hashmap-set",
                "content": "Set is used to find the head\\n```\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        Set<Integer> parentSet = new HashSet<>(), childSet = new HashSet<>();\\n        for (int[] arr : descriptions) {\\n        \\tTreeNode parent = map.computeIfAbsent(arr[0], x -> new TreeNode(arr[0]));\\n        \\tTreeNode child = map.computeIfAbsent(arr[1], x -> new TreeNode(arr[1]));\\n        \\tif (arr[2] == 1)\\n        \\t\\tparent.left = child;\\n        \\telse\\n        \\t\\tparent.right = child;\\n        \\tif (!childSet.contains(arr[0]))\\n        \\t\\tparentSet.add(arr[0]);\\n        \\tparentSet.remove(arr[1]);\\n        \\tchildSet.add(arr[1]);\\n        }\\n        return map.get(parentSet.iterator().next());\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "Set is used to find the head\\n```\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        Set<Integer> parentSet = new HashSet<>(), childSet = new HashSet<>();\\n        for (int[] arr : descriptions) {\\n        \\tTreeNode parent = map.computeIfAbsent(arr[0], x -> new TreeNode(arr[0]));\\n        \\tTreeNode child = map.computeIfAbsent(arr[1], x -> new TreeNode(arr[1]));\\n        \\tif (arr[2] == 1)\\n        \\t\\tparent.left = child;\\n        \\telse\\n        \\t\\tparent.right = child;\\n        \\tif (!childSet.contains(arr[0]))\\n        \\t\\tparentSet.add(arr[0]);\\n        \\tparentSet.remove(arr[1]);\\n        \\tchildSet.add(arr[1]);\\n        }\\n        return map.get(parentSet.iterator().next());\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1823696,
                "title": "c-2196-create-binary-tree-from-descriptions",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> mp; \\n        unordered_set<int> seen; \\n        for (auto& desc : descriptions) {\\n            int p = desc[0], c = desc[1], left = desc[2]; \\n            if (!mp.count(p)) mp[p] = new TreeNode(p); \\n            if (!mp.count(c)) mp[c] = new TreeNode(c); \\n            if (left) mp[p]->left = mp[c]; \\n            else mp[p]->right = mp[c]; \\n            seen.insert(c); \\n        }\\n        for (auto& desc : descriptions) \\n            if (!seen.count(desc[0])) return mp[desc[0]]; \\n        return nullptr; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> mp; \\n        unordered_set<int> seen; \\n        for (auto& desc : descriptions) {\\n            int p = desc[0], c = desc[1], left = desc[2]; \\n            if (!mp.count(p)) mp[p] = new TreeNode(p); \\n            if (!mp.count(c)) mp[c] = new TreeNode(c); \\n            if (left) mp[p]->left = mp[c]; \\n            else mp[p]->right = mp[c]; \\n            seen.insert(c); \\n        }\\n        for (auto& desc : descriptions) \\n            if (!seen.count(desc[0])) return mp[desc[0]]; \\n        return nullptr; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823664,
                "title": "tree-construct-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& A) {\\n        // collect all nodes for later use\\n        unordered_set<int> nodes;\\n        for(auto& i : A){\\n            nodes.insert(i[0]);\\n            nodes.insert(i[1]);\\n        }\\n        \\n        vector<vector<pair<int, int>>> tree(1e5 + 1); // node -> [{child, isLeft}]\\n        vector<int> indeg(1e5 + 1); // indegree to find root node\\n        for(auto& i : A){\\n            tree[i[0]].push_back({i[1], i[2]});\\n            indeg[i[1]]++;\\n        }\\n        \\n        // find root node\\n        TreeNode* Root;\\n        for(auto& i : nodes){\\n            if(indeg[i] == 0){\\n                Root = new TreeNode(i);\\n                break;\\n            }\\n        }\\n        \\n        queue<TreeNode*> q;\\n        q.push(Root);\\n        \\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            \\n            for(auto& [child, isLeft] : tree[node->val]){\\n                if(isLeft){\\n                    node->left = new TreeNode(child);\\n                    q.push(node->left);\\n                }\\n                else{\\n                    node->right = new TreeNode(child);\\n                    q.push(node->right);\\n                }\\n            }\\n        }\\n        \\n        return Root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& A) {\\n        // collect all nodes for later use\\n        unordered_set<int> nodes;\\n        for(auto& i : A){\\n            nodes.insert(i[0]);\\n            nodes.insert(i[1]);\\n        }\\n        \\n        vector<vector<pair<int, int>>> tree(1e5 + 1); // node -> [{child, isLeft}]\\n        vector<int> indeg(1e5 + 1); // indegree to find root node\\n        for(auto& i : A){\\n            tree[i[0]].push_back({i[1], i[2]});\\n            indeg[i[1]]++;\\n        }\\n        \\n        // find root node\\n        TreeNode* Root;\\n        for(auto& i : nodes){\\n            if(indeg[i] == 0){\\n                Root = new TreeNode(i);\\n                break;\\n            }\\n        }\\n        \\n        queue<TreeNode*> q;\\n        q.push(Root);\\n        \\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            \\n            for(auto& [child, isLeft] : tree[node->val]){\\n                if(isLeft){\\n                    node->left = new TreeNode(child);\\n                    q.push(node->left);\\n                }\\n                else{\\n                    node->right = new TreeNode(child);\\n                    q.push(node->right);\\n                }\\n            }\\n        }\\n        \\n        return Root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823656,
                "title": "java-hash-map-and-set-o-n",
                "content": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n\\t  // map that will contains all node value as key\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n\\t\\t// set that will contains all the childrens\\n        Set<Integer> childSet = new HashSet<>();\\n        for(int[] r : descriptions){\\n            if(!map.containsKey(r[0])){\\n                TreeNode node = new TreeNode(r[0]);\\n                map.put(r[0] , node);\\n            }\\n            TreeNode node= map.get(r[0]) ; \\n            if(!map.containsKey(r[1])){\\n                TreeNode child = new TreeNode(r[1]); \\n                map.put(r[1] , child);\\n            }\\n\\t\\t\\t// add r[1] node to children set\\n            childSet.add(r[1]); \\n            if(r[2] == 1){\\n              node.left = map.get(r[1]);  \\n            }else{\\n                node.right = map.get(r[1]);\\n            }\\n            map.put(r[0],  node);\\n        }\\n        \\n        for(Integer key : map.keySet()){\\n\\t\\t// means the key has children\\n            if(!childSet.contains(key)) {\\n\\t\\t\\t// means the key does not have parent so its the root\\n               return map.get(key); \\n            }\\n        }\\n        return null;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n\\t  // map that will contains all node value as key\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n\\t\\t// set that will contains all the childrens\\n        Set<Integer> childSet = new HashSet<>();\\n        for(int[] r : descriptions){\\n            if(!map.containsKey(r[0])){\\n                TreeNode node = new TreeNode(r[0]);\\n                map.put(r[0] , node);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1823614,
                "title": "python-o-n-with-sets",
                "content": "Root node will be in parent nodes set but not in children nodes set\\n```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        # num: node\\n        m = {}\\n        pset = set([]) # parent nodes set\\n        cset = set([]) # children nodes set\\n        for desc in descriptions:\\n            p, c, left = desc\\n            pn, cn = None, None\\n            # create parent node\\n            if p not in m:\\n                pn = TreeNode(p)\\n                m[p] = pn\\n            else:\\n                pn = m[p]\\n            pset.add(pn)\\n            \\n\\t        #create child node\\n            if c not in m:\\n                cn = TreeNode(c)\\n                m[c] = cn\\n            else:\\n                cn = m[c]\\n            cset.add(cn)    \\n            \\n            # connect parent & child\\n            if left == 1:\\n                pn.left = cn\\n            else:\\n                pn.right = cn\\n\\n        # root node is in parent node set but not in children nodes set\\n        for pnode in pset:\\n            if pnode not in cset: return pnode\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        # num: node\\n        m = {}\\n        pset = set([]) # parent nodes set\\n        cset = set([]) # children nodes set\\n        for desc in descriptions:\\n            p, c, left = desc\\n            pn, cn = None, None\\n            # create parent node\\n            if p not in m:\\n                pn = TreeNode(p)\\n                m[p] = pn\\n            else:\\n                pn = m[p]\\n            pset.add(pn)\\n            \\n\\t        #create child node\\n            if c not in m:\\n                cn = TreeNode(c)\\n                m[c] = cn\\n            else:\\n                cn = m[c]\\n            cset.add(cn)    \\n            \\n            # connect parent & child\\n            if left == 1:\\n                pn.left = cn\\n            else:\\n                pn.right = cn\\n\\n        # root node is in parent node set but not in children nodes set\\n        for pnode in pset:\\n            if pnode not in cset: return pnode\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094058,
                "title": "easiest-code-and-explanation",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode*> getNode;\\n        unordered_map<int,bool> vis, isNotRoot;\\n        int rootVal = 0;\\n        for(auto it : descriptions)\\n        {\\n            int parent = it[0];\\n            int child = it[1];\\n            int isLeftChild = it[2];\\n            //make a new Node if we are visiting this number for the first time\\n            if(!vis[parent]) {\\n             getNode[parent] = new TreeNode(parent);\\n            }\\n            //make a new Node if we are visiting this number for the first time\\n             if(!vis[child]) {\\n             getNode[child] = new TreeNode(child);\\n             }\\n            //now, make \\'child\\' node left or right child of \\'parent\\' node depending upon the value of \\'isLeftChild\\'\\n             if(isLeftChild)\\n              getNode[parent]->left = getNode[child];\\n             else\\n             getNode[parent]->right = getNode[child];\\n\\n         vis[parent] = true; //mark both parent and child nodes as visited so\\n         vis[child] = true; //that we do not redeclare them in next iterations\\n         isNotRoot[child] = true; //if a node is child of some other node, it cannot be a root\\n        }\\n\\n        //traverse once again to find the root node\\n        for(auto it : descriptions)\\n        {\\n            if(isNotRoot[it[0]] == false) { //this means current node is the root\\n                rootVal = it[0];\\n                break;  //no need to traverse further as we already found the root\\n            }\\n        }\\n    return getNode[rootVal]; //return the root node\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,TreeNode*> getNode;\\n        unordered_map<int,bool> vis, isNotRoot;\\n        int rootVal = 0;\\n        for(auto it : descriptions)\\n        {\\n            int parent = it[0];\\n            int child = it[1];\\n            int isLeftChild = it[2];\\n            //make a new Node if we are visiting this number for the first time\\n            if(!vis[parent]) {\\n             getNode[parent] = new TreeNode(parent);\\n            }\\n            //make a new Node if we are visiting this number for the first time\\n             if(!vis[child]) {\\n             getNode[child] = new TreeNode(child);\\n             }\\n            //now, make \\'child\\' node left or right child of \\'parent\\' node depending upon the value of \\'isLeftChild\\'\\n             if(isLeftChild)\\n              getNode[parent]->left = getNode[child];\\n             else\\n             getNode[parent]->right = getNode[child];\\n\\n         vis[parent] = true; //mark both parent and child nodes as visited so\\n         vis[child] = true; //that we do not redeclare them in next iterations\\n         isNotRoot[child] = true; //if a node is child of some other node, it cannot be a root\\n        }\\n\\n        //traverse once again to find the root node\\n        for(auto it : descriptions)\\n        {\\n            if(isNotRoot[it[0]] == false) { //this means current node is the root\\n                rootVal = it[0];\\n                break;  //no need to traverse further as we already found the root\\n            }\\n        }\\n    return getNode[rootVal]; //return the root node\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088901,
                "title": "node-map-parent-map-can-help-in-this-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a node map: INT-> TreeNode\\nCreate a parent map: INT -> INT\\nIf 21, is parent of 20, then p[20]=21;\\n\\nTraverse through each element of vector: refer as a\\n1. a[0] is parent: Look if it is present in node map, else create parent\\n2. a[1] is child: Look if it is present in node map, else create child\\n3. a[2] isLeft : \\n        YES: parent -> left = child; \\n        NO: parent ->right = child;\\n4. In the parent map mark: parent of a[1]is a[0];\\nNow, get the first element\\'s parent value.\\nLook if this has a parent.\\nDo this until you find an value which does not have a parent.\\n\\nFind its TreeNode in node map. return it.\\nDone\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        map<int,TreeNode*> m;\\n        map<int,int> p;\\n        TreeNode *head=NULL;\\n        for(auto a: descriptions)\\n        {\\n            TreeNode *parent = m[a[0]] = (m.find(a[0])!= m.end())? m[a[0]]: new TreeNode(a[0]);\\n            TreeNode *child  = m[a[1]] = (m.find(a[1])!= m.end())? m[a[1]]: new TreeNode(a[1]);\\n            p[a[1]]=a[0];\\n            ( a[2]?parent->left:parent->right ) = child;\\n        }\\n        int val=descriptions[0][0];\\n        while(p.find(val) != p.end())\\n            val=p[val];\\n        if(m.find(val) !=m.end()) return m[val];\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        map<int,TreeNode*> m;\\n        map<int,int> p;\\n        TreeNode *head=NULL;\\n        for(auto a: descriptions)\\n        {\\n            TreeNode *parent = m[a[0]] = (m.find(a[0])!= m.end())? m[a[0]]: new TreeNode(a[0]);\\n            TreeNode *child  = m[a[1]] = (m.find(a[1])!= m.end())? m[a[1]]: new TreeNode(a[1]);\\n            p[a[1]]=a[0];\\n            ( a[2]?parent->left:parent->right ) = child;\\n        }\\n        int val=descriptions[0][0];\\n        while(p.find(val) != p.end())\\n            val=p[val];\\n        if(m.find(val) !=m.end()) return m[val];\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037891,
                "title": "by-using-hash-map-easy-solution",
                "content": "Time Complexity : `O(n)`\\nSpace Complexity : `O(n)`\\nwhere n is length of descriptions\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> hm = new HashMap<>();\\n        Set<Integer> hs = new HashSet<>();\\n\\n        for(int[] arr : descriptions){\\n\\n            int par = arr[0];\\n            int child = arr[1];\\n            int isLeft = arr[2];\\n\\n            hs.add(child);\\n            TreeNode parent = hm.getOrDefault(par, new TreeNode(par));\\n            if(isLeft == 1){\\n                parent.left = hm.getOrDefault(child, new TreeNode(child));\\n                hm.put(child, parent.left); \\n            }else{\\n                parent.right = hm.getOrDefault(child, new TreeNode(child));\\n                hm.put(child, parent.right);\\n            }\\n            hm.put(par, parent);\\n\\n        }\\n        int root = -1;\\n        for(int[] arr : descriptions){\\n            if(!hs.contains(arr[0])){\\n                root = arr[0];\\n                break;\\n            }\\n        }\\n\\n        return hm.getOrDefault(root, null);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> hm = new HashMap<>();\\n        Set<Integer> hs = new HashSet<>();\\n\\n        for(int[] arr : descriptions){\\n\\n            int par = arr[0];\\n            int child = arr[1];\\n            int isLeft = arr[2];\\n\\n            hs.add(child);\\n            TreeNode parent = hm.getOrDefault(par, new TreeNode(par));\\n            if(isLeft == 1){\\n                parent.left = hm.getOrDefault(child, new TreeNode(child));\\n                hm.put(child, parent.left); \\n            }else{\\n                parent.right = hm.getOrDefault(child, new TreeNode(child));\\n                hm.put(child, parent.right);\\n            }\\n            hm.put(par, parent);\\n\\n        }\\n        int root = -1;\\n        for(int[] arr : descriptions){\\n            if(!hs.contains(arr[0])){\\n                root = arr[0];\\n                break;\\n            }\\n        }\\n\\n        return hm.getOrDefault(root, null);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023290,
                "title": "use-hashtable-to-store-number-node-and-set-for-children",
                "content": "# Intuition\\nWe use hashmap so that we can get back the node of its corresponding value and set the left/right accordingly. We also add children node to the hasParent set\\nThen we end it by looping across all the nodes and returning a node that is not found in hasParent set which is the root\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n\\n        #get nodes if exist\\n        dic = {}\\n        hasParent = set()            \\n\\n        for p,c,l in descriptions:\\n\\n            dic[p] = dic.get(p,TreeNode(p))\\n            dic[c] = dic.get(c,TreeNode(c))\\n            \\n            if l:\\n                dic[p].left = dic[c]\\n            else:\\n                dic[p].right = dic[c]\\n\\n\\n            #vists child\\n            hasParent.add(c)     \\n        \\n        \\n        for node in dic:            \\n            if node not in hasParent:\\n                return dic[node]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n\\n        #get nodes if exist\\n        dic = {}\\n        hasParent = set()            \\n\\n        for p,c,l in descriptions:\\n\\n            dic[p] = dic.get(p,TreeNode(p))\\n            dic[c] = dic.get(c,TreeNode(c))\\n            \\n            if l:\\n                dic[p].left = dic[c]\\n            else:\\n                dic[p].right = dic[c]\\n\\n\\n            #vists child\\n            hasParent.add(c)     \\n        \\n        \\n        for node in dic:            \\n            if node not in hasParent:\\n                return dic[node]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006502,
                "title": "best-and-easy-solution-using-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the current node value to store the child and parent relation and later join it with its parent.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse map to store the node so that every time we don\\'t have to create the nodes again and again.\\nand a map for knowing that if a node has been child anytime in the whole journey of making the BST.\\nat last return the node that is not being part as a child in the making of BST.\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        map<int,TreeNode*>present;\\n        map<int,bool>ch;\\n        for(int i=0;i<descriptions.size();i++)\\n        {\\n            TreeNode* parent,*child;\\n            if(present.find(descriptions[i][0])==present.end())\\n            {\\n                parent=new TreeNode(descriptions[i][0]);\\n                present[descriptions[i][0]]=parent;\\n            }\\n            else parent=present[descriptions[i][0]];\\n            if(present.find(descriptions[i][1])==present.end())\\n            {\\n                child=new TreeNode(descriptions[i][1]);\\n                present[descriptions[i][1]]=child;\\n            }\\n            else child=present[descriptions[i][1]];\\n            if(descriptions[i][2]==1)\\n            parent->left=child;\\n            else\\n            parent->right=child;\\n            ch[descriptions[i][1]]=true;\\n        }\\n        for(int i=0;i<descriptions.size();i++)\\n        {\\n            if(ch.find(descriptions[i][0])==ch.end())return present[descriptions[i][0]];\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        map<int,TreeNode*>present;\\n        map<int,bool>ch;\\n        for(int i=0;i<descriptions.size();i++)\\n        {\\n            TreeNode* parent,*child;\\n            if(present.find(descriptions[i][0])==present.end())\\n            {\\n                parent=new TreeNode(descriptions[i][0]);\\n                present[descriptions[i][0]]=parent;\\n            }\\n            else parent=present[descriptions[i][0]];\\n            if(present.find(descriptions[i][1])==present.end())\\n            {\\n                child=new TreeNode(descriptions[i][1]);\\n                present[descriptions[i][1]]=child;\\n            }\\n            else child=present[descriptions[i][1]];\\n            if(descriptions[i][2]==1)\\n            parent->left=child;\\n            else\\n            parent->right=child;\\n            ch[descriptions[i][1]]=true;\\n        }\\n        for(int i=0;i<descriptions.size();i++)\\n        {\\n            if(ch.find(descriptions[i][0])==ch.end())return present[descriptions[i][0]];\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003208,
                "title": "java-o-n-easy-solution-construct-tree-like-you-construct-adjacency-map",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer,TreeNode> map = new HashMap();\\n        HashSet<Integer> childrenNodes = new HashSet();\\n        for (int[] description: descriptions) {\\n            int parent = description[0];\\n            int child = description[1];\\n            childrenNodes.add(child);\\n            boolean isLeft = description[2] == 1;\\n            if (!map.containsKey(parent)) {\\n                map.put(parent, new TreeNode(parent));\\n            }\\n            if (!map.containsKey(child)) {\\n                map.put(child, new TreeNode(child));\\n            }\\n\\n            if (isLeft) {\\n                map.get(parent).left = map.get(child);\\n            } else {\\n                map.get(parent).right = map.get(child);\\n            }\\n        }\\n\\n        for (Integer nodeVal: map.keySet()) {\\n            if (!childrenNodes.contains(nodeVal)) {\\n                return map.get(nodeVal);\\n            }\\n        }\\n        return new TreeNode(-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Graph",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        HashMap<Integer,TreeNode> map = new HashMap();\\n        HashSet<Integer> childrenNodes = new HashSet();\\n        for (int[] description: descriptions) {\\n            int parent = description[0];\\n            int child = description[1];\\n            childrenNodes.add(child);\\n            boolean isLeft = description[2] == 1;\\n            if (!map.containsKey(parent)) {\\n                map.put(parent, new TreeNode(parent));\\n            }\\n            if (!map.containsKey(child)) {\\n                map.put(child, new TreeNode(child));\\n            }\\n\\n            if (isLeft) {\\n                map.get(parent).left = map.get(child);\\n            } else {\\n                map.get(parent).right = map.get(child);\\n            }\\n        }\\n\\n        for (Integer nodeVal: map.keySet()) {\\n            if (!childrenNodes.contains(nodeVal)) {\\n                return map.get(nodeVal);\\n            }\\n        }\\n        return new TreeNode(-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002744,
                "title": "kotlin-2-maps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    fun createBinaryTree(descriptions: Array<IntArray>): TreeNode? {\\n    val starts = mutableMapOf<Int, TreeNode>()\\n    val ends = mutableMapOf<Int, TreeNode>()\\n    descriptions.forEach { row ->\\n        val s = starts[row[0]] ?: ends[row[0]] ?: TreeNode(row[0])\\n        starts[row[0]] = s\\n        val e = starts[row[1]] ?: ends[row[1]] ?: TreeNode(row[1])\\n        ends[row[1]] = e\\n        if (row[2] == 1) {\\n            s.left = e\\n        } else {\\n            s.right = e\\n        }\\n\\n    }\\n    return starts[(starts.keys - ends.keys).first()]\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    fun createBinaryTree(descriptions: Array<IntArray>): TreeNode? {\\n    val starts = mutableMapOf<Int, TreeNode>()\\n    val ends = mutableMapOf<Int, TreeNode>()\\n    descriptions.forEach { row ->\\n        val s = starts[row[0]] ?: ends[row[0]] ?: TreeNode(row[0])\\n        starts[row[0]] = s\\n        val e = starts[row[1]] ?: ends[row[1]] ?: TreeNode(row[1])\\n        ends[row[1]] = e\\n        if (row[2] == 1) {\\n            s.left = e\\n        } else {\\n            s.right = e\\n        }\\n\\n    }\\n    return starts[(starts.keys - ends.keys).first()]\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000110,
                "title": "69-optimal-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>&d){\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_map<int,int>ch,pr;\\n        for(int i=0; i<d.size(); i++){\\n            if(mp.find(d[i][0])==mp.end()){\\n                TreeNode*temp = new TreeNode(d[i][0]); \\n                mp[d[i][0]]=temp;\\n            }\\n            if(mp.find(d[i][1])==mp.end()){\\n                TreeNode*temp = new TreeNode(d[i][1]);\\n                mp[d[i][1]]=temp;\\n            }\\n            if(d[i][2]==1){\\n                mp[d[i][0]]->left=mp[d[i][1]];\\n            }\\n            else{\\n                mp[d[i][0]]->right=mp[d[i][1]];\\n            }\\n            pr[d[i][0]]++;\\n            ch[d[i][1]]++;\\n        }\\n        for(auto i:mp){\\n            if(pr.find(i.first)!=pr.end() && ch.find(i.first)==ch.end()){\\n                return i.second;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>&d){\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_map<int,int>ch,pr;\\n        for(int i=0; i<d.size(); i++){\\n            if(mp.find(d[i][0])==mp.end()){\\n                TreeNode*temp = new TreeNode(d[i][0]); \\n                mp[d[i][0]]=temp;\\n            }\\n            if(mp.find(d[i][1])==mp.end()){\\n                TreeNode*temp = new TreeNode(d[i][1]);\\n                mp[d[i][1]]=temp;\\n            }\\n            if(d[i][2]==1){\\n                mp[d[i][0]]->left=mp[d[i][1]];\\n            }\\n            else{\\n                mp[d[i][0]]->right=mp[d[i][1]];\\n            }\\n            pr[d[i][0]]++;\\n            ch[d[i][1]]++;\\n        }\\n        for(auto i:mp){\\n            if(pr.find(i.first)!=pr.end() && ch.find(i.first)==ch.end()){\\n                return i.second;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999012,
                "title": "rust-solution-translated-from-the-popular-solution",
                "content": "# Sumamry\\n\\nJust translated version of the popular solution.\\nThis was a backbreaking work actually.\\n\\n## Explanation of the Complicated Part\\n```rust\\n(*parent_node_mut).borrow_mut().left = kid_node;\\n```\\n\\n`(*parent_node_mut) ` is converting from `Rc<RefCell<TreeNode>>` to `RefCell<TreeNode>`\\n\\n`borrow_mut()` is returning `RefMut<TreeNode>` and `DerefMut` trait converting `&mut TreeNode`.\\nThen we can access the left, right value using dot `.` \\n\\n\\n# Rust Code\\n```rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn create_binary_tree(descriptions: Vec<Vec<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        let mut kids = std::collections::HashSet::new();\\n        let mut val_to_node: std::collections::HashMap<i32, Rc<RefCell<TreeNode>>> = std::collections::HashMap::new();\\n\\n        for description in descriptions {\\n            let (parent, kid, left) = (description[0], description[1], description[2]);\\n\\n            val_to_node.entry(parent).or_insert(Rc::new(RefCell::new(TreeNode::new(parent))));\\n            val_to_node.entry(kid).or_insert(Rc::new(RefCell::new(TreeNode::new(kid))));\\n            kids.insert(kid);\\n\\n            let parent_node_mut: Rc<RefCell<TreeNode>> = val_to_node.get(&parent).unwrap().clone();\\n            let kid_node: Option<Rc<RefCell<TreeNode>>> = val_to_node.get(&kid).cloned();\\n            if left == 1 {\\n                (*parent_node_mut).borrow_mut().left = kid_node;\\n            }else{\\n                (*parent_node_mut).borrow_mut().right = kid_node;\\n            }\\n        }\\n        let keys_set: std::collections::HashSet<_> = val_to_node.keys().cloned().collect();\\n        let root = keys_set.difference(&kids).next().unwrap();\\n        return val_to_node.get(&root).cloned();\\n    }\\n}\\n```\\n\\n\\n# Original C++ Code\\n```cpp\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Set<Integer> kids = new HashSet<>();\\n        Map<Integer, TreeNode> valToNode = new HashMap<>();\\n        for (int[] d : descriptions) {\\n            int parent = d[0], kid = d[1], left = d[2];\\n            valToNode.putIfAbsent(parent, new TreeNode(parent));\\n            valToNode.putIfAbsent(kid, new TreeNode(kid));\\n            kids.add(kid);\\n            if (left == 1) {\\n                valToNode.get(parent).left = valToNode.get(kid);\\n            }else {\\n                valToNode.get(parent).right = valToNode.get(kid);\\n            }\\n        }\\n        valToNode.keySet().removeAll(kids);\\n        return valToNode.values().iterator().next();\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n(*parent_node_mut).borrow_mut().left = kid_node;\\n```\n```rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn create_binary_tree(descriptions: Vec<Vec<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        let mut kids = std::collections::HashSet::new();\\n        let mut val_to_node: std::collections::HashMap<i32, Rc<RefCell<TreeNode>>> = std::collections::HashMap::new();\\n\\n        for description in descriptions {\\n            let (parent, kid, left) = (description[0], description[1], description[2]);\\n\\n            val_to_node.entry(parent).or_insert(Rc::new(RefCell::new(TreeNode::new(parent))));\\n            val_to_node.entry(kid).or_insert(Rc::new(RefCell::new(TreeNode::new(kid))));\\n            kids.insert(kid);\\n\\n            let parent_node_mut: Rc<RefCell<TreeNode>> = val_to_node.get(&parent).unwrap().clone();\\n            let kid_node: Option<Rc<RefCell<TreeNode>>> = val_to_node.get(&kid).cloned();\\n            if left == 1 {\\n                (*parent_node_mut).borrow_mut().left = kid_node;\\n            }else{\\n                (*parent_node_mut).borrow_mut().right = kid_node;\\n            }\\n        }\\n        let keys_set: std::collections::HashSet<_> = val_to_node.keys().cloned().collect();\\n        let root = keys_set.difference(&kids).next().unwrap();\\n        return val_to_node.get(&root).cloned();\\n    }\\n}\\n```\n```cpp\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Set<Integer> kids = new HashSet<>();\\n        Map<Integer, TreeNode> valToNode = new HashMap<>();\\n        for (int[] d : descriptions) {\\n            int parent = d[0], kid = d[1], left = d[2];\\n            valToNode.putIfAbsent(parent, new TreeNode(parent));\\n            valToNode.putIfAbsent(kid, new TreeNode(kid));\\n            kids.add(kid);\\n            if (left == 1) {\\n                valToNode.get(parent).left = valToNode.get(kid);\\n            }else {\\n                valToNode.get(parent).right = valToNode.get(kid);\\n            }\\n        }\\n        valToNode.keySet().removeAll(kids);\\n        return valToNode.values().iterator().next();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3959083,
                "title": "easy-solution-using-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        int rows = d.size();\\n        int cols = d[0].size();\\n        unordered_map<int,TreeNode*>mp;\\n        set<int>not_root;\\n        TreeNode*root;\\n        for(int i = 0;i<rows;i++){\\n            if(mp.find(d[i][0])==mp.end()){\\n                mp[d[i][0]]= new TreeNode(d[i][0]);\\n            }\\n            \\n            if(mp.find(d[i][1])==mp.end()){\\n                mp[d[i][1]]= new TreeNode(d[i][1]);\\n            }\\n            if(d[i][2]==1){\\n                mp[d[i][0]]->left= mp[d[i][1]];\\n                not_root.insert(d[i][1]);\\n            }else{\\n                mp[d[i][0]]->right= mp[d[i][1]];\\n                not_root.insert(d[i][1]);\\n            }\\n\\n        }\\n        for(auto v:mp){\\n            if(not_root.find(v.first)==not_root.end()){\\n                root = v.second;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n        int rows = d.size();\\n        int cols = d[0].size();\\n        unordered_map<int,TreeNode*>mp;\\n        set<int>not_root;\\n        TreeNode*root;\\n        for(int i = 0;i<rows;i++){\\n            if(mp.find(d[i][0])==mp.end()){\\n                mp[d[i][0]]= new TreeNode(d[i][0]);\\n            }\\n            \\n            if(mp.find(d[i][1])==mp.end()){\\n                mp[d[i][1]]= new TreeNode(d[i][1]);\\n            }\\n            if(d[i][2]==1){\\n                mp[d[i][0]]->left= mp[d[i][1]];\\n                not_root.insert(d[i][1]);\\n            }else{\\n                mp[d[i][0]]->right= mp[d[i][1]];\\n                not_root.insert(d[i][1]);\\n            }\\n\\n        }\\n        for(auto v:mp){\\n            if(not_root.find(v.first)==not_root.end()){\\n                root = v.second;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917865,
                "title": "easy-solution-unordered-map-c",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> mp;\\n        unordered_map<int, bool> isChild;\\n        for(auto i : descriptions){\\n            int parent = i[0], child = i[1], left = i[2];\\n            isChild[child] = true;\\n            if(mp.find(child) == mp.end()){\\n                mp[child] = new TreeNode(child);  \\n            }\\n            if(mp.find(parent) == mp.end()){\\n                mp[parent] = new TreeNode(parent);                    \\n            }\\n            if(left) mp[parent]->left = mp[child];\\n            else mp[parent]->right = mp[child];\\n        }\\n        for(auto i : descriptions){\\n            int parent = i[0];\\n            if(isChild[parent] == false) return mp[parent];\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> mp;\\n        unordered_map<int, bool> isChild;\\n        for(auto i : descriptions){\\n            int parent = i[0], child = i[1], left = i[2];\\n            isChild[child] = true;\\n            if(mp.find(child) == mp.end()){\\n                mp[child] = new TreeNode(child);  \\n            }\\n            if(mp.find(parent) == mp.end()){\\n                mp[parent] = new TreeNode(parent);                    \\n            }\\n            if(left) mp[parent]->left = mp[child];\\n            else mp[parent]->right = mp[child];\\n        }\\n        for(auto i : descriptions){\\n            int parent = i[0];\\n            if(isChild[parent] == false) return mp[parent];\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917738,
                "title": "easy-c-solution-unordered-map-and-set-beats-99-8",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        unordered_map<int, TreeNode*> mp; // val-> node address\\n        unordered_set<TreeNode*> isroot; // to keep track of root, whenever a new parent occurs add to set, if it becomes child remove.\\n        // At end set will contain only one node, i.e. root\\n        for(int i = 0 ; i < des.size() ; i++)\\n        {\\n            if(mp.find(des[i][0]) == mp.end())\\n            {\\n                TreeNode* naya = new TreeNode(des[i][0]);\\n                mp[des[i][0]] = naya;\\n                isroot.insert(naya);\\n                if(mp.find(des[i][1]) == mp.end())\\n                {\\n                    TreeNode* child = new TreeNode(des[i][1]);\\n                    mp[des[i][1]] = child;\\n                    if(des[i][2])\\n                    {\\n                        naya->left = child;\\n                    }\\n                    else\\n                    {\\n                        naya->right = child;\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* child = mp[des[i][1]];\\n                    isroot.erase(child);\\n                    if(des[i][2])\\n                    {\\n                        naya->left = child;\\n                    }\\n                    else\\n                    {\\n                        naya->right = child;\\n                    }\\n                }\\n\\n            }\\n            else\\n            {\\n                TreeNode* naya = mp[des[i][0]];\\n                if(mp.find(des[i][1]) == mp.end())\\n                {\\n                    TreeNode* child = new TreeNode(des[i][1]);\\n                    mp[des[i][1]] = child;\\n                    if(des[i][2])\\n                    {\\n                        naya->left = child;\\n                    }\\n                    else\\n                    {\\n                        naya->right = child;\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* child = mp[des[i][1]];\\n                    isroot.erase(child);\\n                    if(des[i][2])\\n                    {\\n                        naya->left = child;\\n                    }\\n                    else\\n                    {\\n                        naya->right = child;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return  *isroot.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        unordered_map<int, TreeNode*> mp; // val-> node address\\n        unordered_set<TreeNode*> isroot; // to keep track of root, whenever a new parent occurs add to set, if it becomes child remove.\\n        // At end set will contain only one node, i.e. root\\n        for(int i = 0 ; i < des.size() ; i++)\\n        {\\n            if(mp.find(des[i][0]) == mp.end())\\n            {\\n                TreeNode* naya = new TreeNode(des[i][0]);\\n                mp[des[i][0]] = naya;\\n                isroot.insert(naya);\\n                if(mp.find(des[i][1]) == mp.end())\\n                {\\n                    TreeNode* child = new TreeNode(des[i][1]);\\n                    mp[des[i][1]] = child;\\n                    if(des[i][2])\\n                    {\\n                        naya->left = child;\\n                    }\\n                    else\\n                    {\\n                        naya->right = child;\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* child = mp[des[i][1]];\\n                    isroot.erase(child);\\n                    if(des[i][2])\\n                    {\\n                        naya->left = child;\\n                    }\\n                    else\\n                    {\\n                        naya->right = child;\\n                    }\\n                }\\n\\n            }\\n            else\\n            {\\n                TreeNode* naya = mp[des[i][0]];\\n                if(mp.find(des[i][1]) == mp.end())\\n                {\\n                    TreeNode* child = new TreeNode(des[i][1]);\\n                    mp[des[i][1]] = child;\\n                    if(des[i][2])\\n                    {\\n                        naya->left = child;\\n                    }\\n                    else\\n                    {\\n                        naya->right = child;\\n                    }\\n                }\\n                else\\n                {\\n                    TreeNode* child = mp[des[i][1]];\\n                    isroot.erase(child);\\n                    if(des[i][2])\\n                    {\\n                        naya->left = child;\\n                    }\\n                    else\\n                    {\\n                        naya->right = child;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return  *isroot.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912138,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar createBinaryTree = function (descriptions) {\\n  let hash = {};\\n  let rootHash = {};\\n  for (let i = 0; i < descriptions.length; i++) {\\n    if (!(descriptions[i][0] in hash)) hash[descriptions[i][0]] = new TreeNode(descriptions[i][0]);\\n    if (!(descriptions[i][1] in hash)) hash[descriptions[i][1]] = new TreeNode(descriptions[i][1]);\\n    if (descriptions[i][2] == 1) hash[descriptions[i][0]].left = hash[descriptions[i][1]];\\n    else hash[descriptions[i][0]].right = hash[descriptions[i][1]];\\n    if (!(descriptions[i][0] in rootHash)) rootHash[descriptions[i][0]] = true;\\n    if (!(descriptions[i][1] in rootHash)) rootHash[descriptions[i][1]] = false;\\n    rootHash[descriptions[i][1]] = false;\\n  }\\n  for (let key in rootHash) {\\n    if (rootHash[key] == true) return hash[key];\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createBinaryTree = function (descriptions) {\\n  let hash = {};\\n  let rootHash = {};\\n  for (let i = 0; i < descriptions.length; i++) {\\n    if (!(descriptions[i][0] in hash)) hash[descriptions[i][0]] = new TreeNode(descriptions[i][0]);\\n    if (!(descriptions[i][1] in hash)) hash[descriptions[i][1]] = new TreeNode(descriptions[i][1]);\\n    if (descriptions[i][2] == 1) hash[descriptions[i][0]].left = hash[descriptions[i][1]];\\n    else hash[descriptions[i][0]].right = hash[descriptions[i][1]];\\n    if (!(descriptions[i][0] in rootHash)) rootHash[descriptions[i][0]] = true;\\n    if (!(descriptions[i][1] in rootHash)) rootHash[descriptions[i][1]] = false;\\n    rootHash[descriptions[i][1]] = false;\\n  }\\n  for (let key in rootHash) {\\n    if (rootHash[key] == true) return hash[key];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896115,
                "title": "easy-map-solution-99-faster",
                "content": "# Intuition\\nStoring whether this node has previously stored as parent/child or not\\n\\n# Approach\\nBasically we have to keep a track of parent child relationship. For that we can connect parent and child and store them in map with a status that whether they are the ultimate parent or not\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map< int , pair<     TreeNode* ,      int>> m;\\n        //          node->val             node    UltimateParentStatus\\n        for(int i = 0; i < descriptions.size(); i++){\\n            int parent_val = descriptions[i][0];\\n            int child_val = descriptions[i][1];\\n            int isleft = descriptions[i][2];\\n\\n            if(m[child_val].first && m[parent_val].first){\\n                if(isleft){\\n                    m[parent_val].first -> left = m[child_val].first;\\n                }else{\\n                    m[parent_val].first -> right = m[child_val].first;\\n                }\\n                m[child_val].second = 0;\\n            }else if(m[child_val].first){\\n\\n                TreeNode* parent = new TreeNode(parent_val);\\n                if(isleft){\\n                    parent -> left = m[child_val].first;\\n                }else{\\n                    parent -> right = m[child_val].first;\\n                }\\n                m[parent_val] = {parent,1};\\n                m[child_val].second = 0;\\n            }else if(m[parent_val].first){\\n                TreeNode* child = new TreeNode(child_val);\\n                if(isleft){\\n                    m[parent_val].first -> left = child;\\n                }else{\\n                    m[parent_val].first -> right = child;\\n                }\\n                m[child_val] = {child,0};\\n            }else{\\n                TreeNode* parent = new TreeNode(parent_val);\\n                TreeNode* child = new TreeNode(child_val);\\n                \\n                if(isleft){\\n                    parent -> left = child;\\n                }else{\\n                    parent -> right = child;\\n                }\\n\\n                m[child_val] = {child,0};\\n                m[parent_val] = {parent,1};\\n            }\\n        }\\n\\n        for(auto it : m){\\n            if(it.second.second == 1){\\n                return it.second.first;\\n            }\\n        }\\n\\n        return new TreeNode(0); // just for the sake of\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map< int , pair<     TreeNode* ,      int>> m;\\n        //          node->val             node    UltimateParentStatus\\n        for(int i = 0; i < descriptions.size(); i++){\\n            int parent_val = descriptions[i][0];\\n            int child_val = descriptions[i][1];\\n            int isleft = descriptions[i][2];\\n\\n            if(m[child_val].first && m[parent_val].first){\\n                if(isleft){\\n                    m[parent_val].first -> left = m[child_val].first;\\n                }else{\\n                    m[parent_val].first -> right = m[child_val].first;\\n                }\\n                m[child_val].second = 0;\\n            }else if(m[child_val].first){\\n\\n                TreeNode* parent = new TreeNode(parent_val);\\n                if(isleft){\\n                    parent -> left = m[child_val].first;\\n                }else{\\n                    parent -> right = m[child_val].first;\\n                }\\n                m[parent_val] = {parent,1};\\n                m[child_val].second = 0;\\n            }else if(m[parent_val].first){\\n                TreeNode* child = new TreeNode(child_val);\\n                if(isleft){\\n                    m[parent_val].first -> left = child;\\n                }else{\\n                    m[parent_val].first -> right = child;\\n                }\\n                m[child_val] = {child,0};\\n            }else{\\n                TreeNode* parent = new TreeNode(parent_val);\\n                TreeNode* child = new TreeNode(child_val);\\n                \\n                if(isleft){\\n                    parent -> left = child;\\n                }else{\\n                    parent -> right = child;\\n                }\\n\\n                m[child_val] = {child,0};\\n                m[parent_val] = {parent,1};\\n            }\\n        }\\n\\n        for(auto it : m){\\n            if(it.second.second == 1){\\n                return it.second.first;\\n            }\\n        }\\n\\n        return new TreeNode(0); // just for the sake of\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893057,
                "title": "python-solution-using-dict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. use a dict to store each tree node\\n2. generate the link between parents and child, at the same time find the root node\\n3. d[1] will have all the node except root node, since root node has no parent\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ n is len of descriptions\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ N is the number of node in the tree\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        dictn={}\\n        s=set()\\n        head=None\\n        for d in descriptions:\\n            if d[0] not in dictn:\\n                dictn[d[0]] = TreeNode(val=d[0])\\n            s.add(d[1])\\n            if d[1] not in dictn:\\n                dictn[d[1]] = TreeNode(val=d[1])\\n        for d in descriptions:\\n            if d[2] == 1:\\n                dictn[d[0]].left = dictn[d[1]]\\n            else:\\n                dictn[d[0]].right = dictn[d[1]]\\n            if d[0] not in s:\\n                head=dictn[d[0]]\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        dictn={}\\n        s=set()\\n        head=None\\n        for d in descriptions:\\n            if d[0] not in dictn:\\n                dictn[d[0]] = TreeNode(val=d[0])\\n            s.add(d[1])\\n            if d[1] not in dictn:\\n                dictn[d[1]] = TreeNode(val=d[1])\\n        for d in descriptions:\\n            if d[2] == 1:\\n                dictn[d[0]].left = dictn[d[1]]\\n            else:\\n                dictn[d[0]].right = dictn[d[1]]\\n            if d[0] not in s:\\n                head=dictn[d[0]]\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880602,
                "title": "bfs-o-n-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        unordered_map<int,int>mp;\\n        unordered_map<int,pair<int,int>>mp1;\\n        for(auto it : des){\\n            mp[it[1]]++;\\n        }\\n        vector<pair<int,int>>v;\\n        for(auto it : mp){\\n            v.push_back({it.second , it.first});\\n        }\\n        sort(v.begin() , v.end());\\n        int r;\\n        for(auto it : des){\\n           if(mp.find(it[0])==mp.end()) r=it[0];\\n           if(it[2])    mp1[it[0]].first = it[1];\\n           else    mp1[it[0]].second = it[1];\\n        }\\n        TreeNode* root = new TreeNode(r);\\n        TreeNode* temp = root;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            r = q.front()->val;\\n            temp = q.front();\\n            q.pop();\\n            TreeNode* root_l=NULL , *root_r = NULL;\\n            if(mp1[r].first) {\\n                root_l = new TreeNode(mp1[r].first);\\n                q.push(root_l);\\n            }\\n            if(mp1[r].second){\\n                root_r = new TreeNode(mp1[r].second);\\n                q.push(root_r);\\n            }\\n            temp->left = root_l;\\n            temp->right = root_r;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& des) {\\n        unordered_map<int,int>mp;\\n        unordered_map<int,pair<int,int>>mp1;\\n        for(auto it : des){\\n            mp[it[1]]++;\\n        }\\n        vector<pair<int,int>>v;\\n        for(auto it : mp){\\n            v.push_back({it.second , it.first});\\n        }\\n        sort(v.begin() , v.end());\\n        int r;\\n        for(auto it : des){\\n           if(mp.find(it[0])==mp.end()) r=it[0];\\n           if(it[2])    mp1[it[0]].first = it[1];\\n           else    mp1[it[0]].second = it[1];\\n        }\\n        TreeNode* root = new TreeNode(r);\\n        TreeNode* temp = root;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            r = q.front()->val;\\n            temp = q.front();\\n            q.pop();\\n            TreeNode* root_l=NULL , *root_r = NULL;\\n            if(mp1[r].first) {\\n                root_l = new TreeNode(mp1[r].first);\\n                q.push(root_l);\\n            }\\n            if(mp1[r].second){\\n                root_r = new TreeNode(mp1[r].second);\\n                q.push(root_r);\\n            }\\n            temp->left = root_l;\\n            temp->right = root_r;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865698,
                "title": "with-recursion-without-recursion",
                "content": "#  Without Recursion Code\\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        \\n        int n = descriptions.size();\\n        unordered_set<int>child;\\n        \\n        for(int i = 0; i < n; i++) {\\n            child.insert(descriptions[i][1]);\\n        }\\n\\n        int root_node;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(child.find(descriptions[i][0]) == child.end()) {\\n                root_node = descriptions[i][0];\\n            }\\n        }\\n\\n        unordered_map<int, TreeNode*>Tree;\\n\\n        for(int i = 0; i < n; i++) {\\n            \\n            int parent = descriptions[i][0];\\n            int child = descriptions[i][1];\\n            bool left = descriptions[i][2];\\n\\n            TreeNode* parent_Node;\\n\\n            if(Tree.find(parent) == Tree.end()) {\\n                parent_Node = new TreeNode(parent);\\n            } else {\\n                parent_Node = Tree[parent];\\n            }\\n\\n            TreeNode* child_Node;\\n\\n            if(Tree.find(child) == Tree.end()) {\\n                child_Node = new TreeNode(child);\\n            } else {\\n                child_Node = Tree[child];\\n            }\\n\\n            if(left) {\\n                parent_Node -> left = child_Node;\\n            } else {\\n                parent_Node -> right = child_Node;\\n            }\\n\\n            Tree[parent] = parent_Node;\\n            Tree[child] = child_Node;\\n\\n        }\\n\\n        return Tree[root_node];\\n\\n    }\\n};\\n```\\n\\n#  Recursion Code\\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode* Make_Tree(vector<pair<int,bool>> adj[], int node) {\\n\\n        if(adj[node].size() == 0) {\\n            return new TreeNode(node);\\n        }\\n\\n        TreeNode* root = new TreeNode(node);\\n\\n        for(auto it : adj[node]) {\\n            int child = it.first;\\n            bool left = it.second;\\n\\n            if(left) {\\n                root -> left = Make_Tree(adj, child);\\n            } else {\\n                root -> right = Make_Tree(adj, child);\\n            }\\n        }\\n\\n        return root;\\n\\n\\n    }\\n\\n\\n\\n\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        \\n        int n = descriptions.size();\\n        set<int>child;\\n\\n        for(int i = 0; i < n; i++) {\\n            child.insert(descriptions[i][1]);\\n        }\\n\\n        int root_node;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(child.find(descriptions[i][0]) == child.end()) {\\n                root_node = descriptions[i][0];\\n            }\\n        }\\n\\n        int m = 100001;\\n        vector<pair<int,bool>>adj[m];\\n        for(int i = 0; i < n; i++) {\\n            int parent = descriptions[i][0];\\n            int child = descriptions[i][1];\\n            bool left = descriptions[i][2];\\n            adj[parent].push_back({child, left});\\n        }\\n\\n        return Make_Tree(adj, root_node);\\n\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        \\n        int n = descriptions.size();\\n        unordered_set<int>child;\\n        \\n        for(int i = 0; i < n; i++) {\\n            child.insert(descriptions[i][1]);\\n        }\\n\\n        int root_node;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(child.find(descriptions[i][0]) == child.end()) {\\n                root_node = descriptions[i][0];\\n            }\\n        }\\n\\n        unordered_map<int, TreeNode*>Tree;\\n\\n        for(int i = 0; i < n; i++) {\\n            \\n            int parent = descriptions[i][0];\\n            int child = descriptions[i][1];\\n            bool left = descriptions[i][2];\\n\\n            TreeNode* parent_Node;\\n\\n            if(Tree.find(parent) == Tree.end()) {\\n                parent_Node = new TreeNode(parent);\\n            } else {\\n                parent_Node = Tree[parent];\\n            }\\n\\n            TreeNode* child_Node;\\n\\n            if(Tree.find(child) == Tree.end()) {\\n                child_Node = new TreeNode(child);\\n            } else {\\n                child_Node = Tree[child];\\n            }\\n\\n            if(left) {\\n                parent_Node -> left = child_Node;\\n            } else {\\n                parent_Node -> right = child_Node;\\n            }\\n\\n            Tree[parent] = parent_Node;\\n            Tree[child] = child_Node;\\n\\n        }\\n\\n        return Tree[root_node];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857728,
                "title": "smart",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution aims to construct a binary tree based on given descriptions. It uses an unordered map to store values and their corresponding nodes along with a boolean flag indicating if a node is a parent. It sorts the descriptions for ease of processing. It iterates through the descriptions, creating parent and child nodes as needed. By checking the child\\'s position in the description, it determines whether the child should be on the left or right of the parent. The solution then marks child nodes as having parents. Finally, it iterates through all nodes to find the one with no parent, which is the root node of the binary tree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution employs an unordered map to associate values with nodes and flags, enabling efficient node retrieval. It utilizes the sorted order of descriptions to ensure parents are created before children, simplifying the construction process. By distinguishing left and right children based on description values, it accurately places children in the tree structure. The solution\\'s strategy of marking nodes with parents and subsequently identifying the root by searching for nodes without parents ensures the complete tree is constructed.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// Assuming the values are unique\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,pair<TreeNode*,bool>> ValXNode;\\n        vector<TreeNode*> nodes;\\n\\n        sort(descriptions.begin() , descriptions.end());\\n\\n        for(vector<int> &description: descriptions){\\n            int parent_val = description[0];\\n            int child_val = description[1];\\n            TreeNode* parent;\\n            TreeNode* child;\\n            // get or make parent node\\n            if(ValXNode.find(parent_val) != ValXNode.end()){\\n                parent = ValXNode[parent_val].first;\\n            }\\n            else{\\n                parent = new TreeNode(parent_val);\\n                ValXNode[parent_val].first = parent;\\n            }\\n            // get or make child node\\n            if(ValXNode.find(child_val) != ValXNode.end()){\\n                child = ValXNode[child_val].first;\\n            }else{\\n                child = new TreeNode(child_val);\\n                ValXNode[child_val].first = child;\\n            }\\n\\n            // \\'child\\' is the left child\\n            if(description[2] == 1){\\n                parent->left = child;\\n            }\\n            // \\'child\\' is the right child\\n            else{\\n                parent->right = child;\\n            }\\n\\n            // mark that \\'child\\' has a parent\\n            ValXNode[child_val].second = true;\\n            // push all the nodes in nodes array\\n            nodes.push_back(parent);\\n            nodes.push_back(child);\\n        }\\n\\n        for(TreeNode* node : nodes){\\n            if(ValXNode[node->val].second == false){\\n                return node;\\n            }\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// Assuming the values are unique\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int,pair<TreeNode*,bool>> ValXNode;\\n        vector<TreeNode*> nodes;\\n\\n        sort(descriptions.begin() , descriptions.end());\\n\\n        for(vector<int> &description: descriptions){\\n            int parent_val = description[0];\\n            int child_val = description[1];\\n            TreeNode* parent;\\n            TreeNode* child;\\n            // get or make parent node\\n            if(ValXNode.find(parent_val) != ValXNode.end()){\\n                parent = ValXNode[parent_val].first;\\n            }\\n            else{\\n                parent = new TreeNode(parent_val);\\n                ValXNode[parent_val].first = parent;\\n            }\\n            // get or make child node\\n            if(ValXNode.find(child_val) != ValXNode.end()){\\n                child = ValXNode[child_val].first;\\n            }else{\\n                child = new TreeNode(child_val);\\n                ValXNode[child_val].first = child;\\n            }\\n\\n            // \\'child\\' is the left child\\n            if(description[2] == 1){\\n                parent->left = child;\\n            }\\n            // \\'child\\' is the right child\\n            else{\\n                parent->right = child;\\n            }\\n\\n            // mark that \\'child\\' has a parent\\n            ValXNode[child_val].second = true;\\n            // push all the nodes in nodes array\\n            nodes.push_back(parent);\\n            nodes.push_back(child);\\n        }\\n\\n        for(TreeNode* node : nodes){\\n            if(ValXNode[node->val].second == false){\\n                return node;\\n            }\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856979,
                "title": "easy-cpp-solution-beats-91-26-in-runtime-using-queue-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/707fae4d-f6ef-400c-a1be-31e2531c6cc9_1691048914.1945226.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        map<int, int> mp;\\n        map<int, pair<int, int>> r;\\n        for(int i=0; i<descriptions.size(); i++){\\n            mp[descriptions[i][1]] = descriptions[i][0];\\n            if(mp.find(descriptions[i][0]) == mp.end()){\\n                mp[descriptions[i][0]] = -1;\\n            }\\n            if(descriptions[i][2] == 1){\\n                r[descriptions[i][0]].first = descriptions[i][1];\\n            }\\n            else\\n                r[descriptions[i][0]].second = descriptions[i][1];\\n        }\\n        int rot;\\n        for(auto i : mp){\\n            // cout << i.first << \" \" << i.second << endl;\\n            if(i.second == -1) {\\n                rot = i.first;\\n                break;\\n            }\\n        }\\n        queue<TreeNode*> q;\\n        TreeNode* root = new TreeNode(rot);\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* tmp = q.front();\\n            q.pop();\\n            if(r[tmp->val].first != 0){\\n                tmp->left = new TreeNode(r[tmp->val].first);\\n                q.push(tmp->left);\\n            }\\n            if(r[tmp->val].second != 0){\\n                tmp->right = new TreeNode(r[tmp->val].second);\\n                q.push(tmp->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        map<int, int> mp;\\n        map<int, pair<int, int>> r;\\n        for(int i=0; i<descriptions.size(); i++){\\n            mp[descriptions[i][1]] = descriptions[i][0];\\n            if(mp.find(descriptions[i][0]) == mp.end()){\\n                mp[descriptions[i][0]] = -1;\\n            }\\n            if(descriptions[i][2] == 1){\\n                r[descriptions[i][0]].first = descriptions[i][1];\\n            }\\n            else\\n                r[descriptions[i][0]].second = descriptions[i][1];\\n        }\\n        int rot;\\n        for(auto i : mp){\\n            // cout << i.first << \" \" << i.second << endl;\\n            if(i.second == -1) {\\n                rot = i.first;\\n                break;\\n            }\\n        }\\n        queue<TreeNode*> q;\\n        TreeNode* root = new TreeNode(rot);\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* tmp = q.front();\\n            q.pop();\\n            if(r[tmp->val].first != 0){\\n                tmp->left = new TreeNode(r[tmp->val].first);\\n                q.push(tmp->left);\\n            }\\n            if(r[tmp->val].second != 0){\\n                tmp->right = new TreeNode(r[tmp->val].second);\\n                q.push(tmp->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3842795,
                "title": "python3-beats-99-5-easy-explanation",
                "content": "\\n# Approach\\n1. Create a Tree node for each node and store the pointers in the dictionary. \\n2. Add the left and right nodes for the same as you do it.\\n3. You have successfully created the tree :).\\n4. Now, you have to find the root.\\n5. Put the parents in a set from the initial array and whenever you find a left or right node in the set, remove it.\\n6. Finally you will be left with the roor node.\\n7. Return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n\\n        pointer = {}\\n\\n        for p,c,l in descriptions:\\n            if p not in pointer:\\n                pointer[p] = TreeNode(p)\\n            if c not in pointer:\\n                pointer[c] = TreeNode(c)\\n            \\n            if l:\\n                pointer[p].left = pointer[c]\\n            else:\\n                pointer[p].right = pointer[c]\\n        \\n        L = set()\\n        for i in descriptions:\\n            L.add(pointer[i[0]])\\n        \\n        for i in pointer:\\n            if pointer[i].left in L:\\n                L.remove(pointer[i].left)\\n            if pointer[i].right in L:\\n                L.remove(pointer[i].right)\\n        \\n        root = None \\n        for i in L:\\n            root = i\\n            break \\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n\\n        pointer = {}\\n\\n        for p,c,l in descriptions:\\n            if p not in pointer:\\n                pointer[p] = TreeNode(p)\\n            if c not in pointer:\\n                pointer[c] = TreeNode(c)\\n            \\n            if l:\\n                pointer[p].left = pointer[c]\\n            else:\\n                pointer[p].right = pointer[c]\\n        \\n        L = set()\\n        for i in descriptions:\\n            L.add(pointer[i[0]])\\n        \\n        for i in pointer:\\n            if pointer[i].left in L:\\n                L.remove(pointer[i].left)\\n            if pointer[i].right in L:\\n                L.remove(pointer[i].right)\\n        \\n        root = None \\n        for i in L:\\n            root = i\\n            break \\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828255,
                "title": "python-easy-understand-solution",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        db = {}\\n        Parent = set()\\n        Children = set()\\n        for i in descriptions:\\n            Parent.add(i[0])\\n            Children.add(i[1])\\n            Temp1 = db.get(i[0], TreeNode(i[0]))\\n            Temp2 = db.get(i[1], TreeNode(i[1]))\\n            if i[2]:\\n                Temp1.left = Temp2\\n            else:\\n                Temp1.right = Temp2\\n            db[i[0]] = Temp1\\n            db[i[1]] = Temp2\\n        return db[Parent.difference(Children).pop()]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        db = {}\\n        Parent = set()\\n        Children = set()\\n        for i in descriptions:\\n            Parent.add(i[0])\\n            Children.add(i[1])\\n            Temp1 = db.get(i[0], TreeNode(i[0]))\\n            Temp2 = db.get(i[1], TreeNode(i[1]))\\n            if i[2]:\\n                Temp1.left = Temp2\\n            else:\\n                Temp1.right = Temp2\\n            db[i[0]] = Temp1\\n            db[i[1]] = Temp2\\n        return db[Parent.difference(Children).pop()]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795722,
                "title": "easiest-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> nodes = new HashMap<>();\\n        Set<Integer> children = new HashSet<>();\\n\\n        for (int[] desc : descriptions) {\\n            int parent = desc[0];\\n            int child = desc[1];\\n            int isLeft = desc[2];\\n\\n            TreeNode parentNode = nodes.getOrDefault(parent, new TreeNode(parent));\\n            TreeNode childNode = nodes.getOrDefault(child, new TreeNode(child));\\n\\n            if (isLeft == 1) {\\n                parentNode.left = childNode;\\n            } else {\\n                parentNode.right = childNode;\\n            }\\n\\n            nodes.put(parent, parentNode);\\n            nodes.put(child, childNode);\\n\\n            children.add(child); // Track the nodes that appear as children\\n        }\\n\\n        // Find the root node (the node without a parent)\\n        TreeNode root = null;\\n        for (TreeNode node : nodes.values()) {\\n            if (!children.contains(node.val)) {\\n                root = node;\\n                break;\\n            }\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        Map<Integer, TreeNode> nodes = new HashMap<>();\\n        Set<Integer> children = new HashSet<>();\\n\\n        for (int[] desc : descriptions) {\\n            int parent = desc[0];\\n            int child = desc[1];\\n            int isLeft = desc[2];\\n\\n            TreeNode parentNode = nodes.getOrDefault(parent, new TreeNode(parent));\\n            TreeNode childNode = nodes.getOrDefault(child, new TreeNode(child));\\n\\n            if (isLeft == 1) {\\n                parentNode.left = childNode;\\n            } else {\\n                parentNode.right = childNode;\\n            }\\n\\n            nodes.put(parent, parentNode);\\n            nodes.put(child, childNode);\\n\\n            children.add(child); // Track the nodes that appear as children\\n        }\\n\\n        // Find the root node (the node without a parent)\\n        TreeNode root = null;\\n        for (TreeNode node : nodes.values()) {\\n            if (!children.contains(node.val)) {\\n                root = node;\\n                break;\\n            }\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787419,
                "title": "simple-java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        // HashMap To keep Track of the Values and its corresponding Node\\n        HashMap<Integer,TreeNode> hmap = new HashMap<>();\\n        // HashMap to keep track which of the following are not parents\\n        HashMap<Integer,Boolean> isChild = new HashMap<>();\\n        for(int[] desc : descriptions) {\\n            int par = desc[0];\\n            int child = desc[1];\\n            int status = desc[2];\\n            if(hmap.containsKey(par) == false) {\\n                TreeNode node = new TreeNode(par);\\n                hmap.put(par,node);\\n                isChild.put(par,false);\\n            }\\n            if(hmap.containsKey(child) == false) {\\n                TreeNode cNode = new TreeNode(child);\\n                hmap.put(child,cNode);\\n            }\\n            isChild.put(child,true);\\n            if(status == 1) {\\n                hmap.get(par).left = hmap.get(child);\\n            } else {\\n                hmap.get(par).right = hmap.get(child);\\n            }\\n        }\\n        int parent = -1;\\n        for(int key : isChild.keySet()) {\\n            if(isChild.get(key) == false) {\\n                parent = key;\\n                break;\\n            }\\n        }\\n        return hmap.get(parent);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] descriptions) {\\n        // HashMap To keep Track of the Values and its corresponding Node\\n        HashMap<Integer,TreeNode> hmap = new HashMap<>();\\n        // HashMap to keep track which of the following are not parents\\n        HashMap<Integer,Boolean> isChild = new HashMap<>();\\n        for(int[] desc : descriptions) {\\n            int par = desc[0];\\n            int child = desc[1];\\n            int status = desc[2];\\n            if(hmap.containsKey(par) == false) {\\n                TreeNode node = new TreeNode(par);\\n                hmap.put(par,node);\\n                isChild.put(par,false);\\n            }\\n            if(hmap.containsKey(child) == false) {\\n                TreeNode cNode = new TreeNode(child);\\n                hmap.put(child,cNode);\\n            }\\n            isChild.put(child,true);\\n            if(status == 1) {\\n                hmap.get(par).left = hmap.get(child);\\n            } else {\\n                hmap.get(par).right = hmap.get(child);\\n            }\\n        }\\n        int parent = -1;\\n        for(int key : isChild.keySet()) {\\n            if(isChild.get(key) == false) {\\n                parent = key;\\n                break;\\n            }\\n        }\\n        return hmap.get(parent);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770096,
                "title": "simple-solution-easy-explaintaion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThink in this way first you need to map child parent relation \\nhow do you know that element is child or parent , by maitaining \\na hashmap of value and TreeNode \\n \\nThen find the root node and return it .\\n\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] mat) {\\n\\n        HashMap<Integer,TreeNode> map = new HashMap<>();\\n\\n        for(int[] ele : mat ){\\n\\n            int parent = ele[0];\\n            int child = ele[1];\\n            int isLeft = ele[2];\\n\\n            if(!map.containsKey(parent)){\\n                map.put(parent,new TreeNode(parent));\\n            }\\n            if(!map.containsKey(child)){\\n                map.put(child,new TreeNode(child));\\n            }\\n            if(isLeft == 1){\\n                map.get(parent).left = map.get(child);\\n            }else{\\n                map.get(parent).right = map.get(child);\\n            }\\n\\n        }\\n\\n        // for finding out the root node;\\n        // how do we figure out the root node : simply root node  does not have any parent \\n\\n\\n        TreeNode root = null;\\n\\n        for(int[] ele : mat ){\\n             int parent = ele[0];\\n             int child = ele[1];\\n\\n             if(isRootNode(mat, parent)){\\n                root = map.get(parent);\\n                break;\\n             }\\n\\n\\n        }\\n        return root;\\n\\n\\n        \\n    }\\n\\n    private boolean isRootNode(int[][]ele, int parent){\\n        for(int[] e : ele){\\n            if(e[1] == parent){\\n                return false;\\n            }         \\n         }\\n         return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode createBinaryTree(int[][] mat) {\\n\\n        HashMap<Integer,TreeNode> map = new HashMap<>();\\n\\n        for(int[] ele : mat ){\\n\\n            int parent = ele[0];\\n            int child = ele[1];\\n            int isLeft = ele[2];\\n\\n            if(!map.containsKey(parent)){\\n                map.put(parent,new TreeNode(parent));\\n            }\\n            if(!map.containsKey(child)){\\n                map.put(child,new TreeNode(child));\\n            }\\n            if(isLeft == 1){\\n                map.get(parent).left = map.get(child);\\n            }else{\\n                map.get(parent).right = map.get(child);\\n            }\\n\\n        }\\n\\n        // for finding out the root node;\\n        // how do we figure out the root node : simply root node  does not have any parent \\n\\n\\n        TreeNode root = null;\\n\\n        for(int[] ele : mat ){\\n             int parent = ele[0];\\n             int child = ele[1];\\n\\n             if(isRootNode(mat, parent)){\\n                root = map.get(parent);\\n                break;\\n             }\\n\\n\\n        }\\n        return root;\\n\\n\\n        \\n    }\\n\\n    private boolean isRootNode(int[][]ele, int parent){\\n        for(int[] e : ele){\\n            if(e[1] == parent){\\n                return false;\\n            }         \\n         }\\n         return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768641,
                "title": "python",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        d = {}\\n        bt = defaultdict(list)\\n        s = set()\\n        for i in range(len(descriptions)):\\n            d[descriptions[i][1]] = descriptions[i][0]\\n            if descriptions[i][2]:\\n                if bt[descriptions[i][0]]:\\n                    bt[descriptions[i][0]][0] = descriptions[i][1]\\n                else:\\n                    bt[descriptions[i][0]].append(descriptions[i][1])\\n                    bt[descriptions[i][0]].append(0)\\n\\n            else:\\n                if bt[descriptions[i][0]]:\\n                    bt[descriptions[i][0]][1] = descriptions[i][1]\\n                else:\\n                    bt[descriptions[i][0]].append(0)\\n                    bt[descriptions[i][0]].append(descriptions[i][1])\\n             \\n    \\n            s.add(descriptions[i][0])\\n            s.add(descriptions[i][1])\\n        for i in s:\\n            if i not in d:\\n                root = i\\n                break\\n        \\n        def bfs(graph, root):\\n            root_node = TreeNode(root)\\n            q = deque()\\n            q.append([root_node])\\n\\n            while q:\\n                level = q.popleft()\\n                nl = []\\n                for child in level:\\n                    if child.val in graph:\\n                        if graph[child.val][0] != 0:\\n                            child.left = TreeNode(graph[child.val][0])\\n                            nl.append(child.left)\\n                        if graph[child.val][1] != 0:\\n                            child.right = TreeNode(graph[child.val][1])                       \\n                            nl.append(child.right)\\n                if nl:\\n                    q.append(nl)\\n            \\n            return root_node\\n        \\n        root_node = bfs(bt, root)\\n        return root_node\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        d = {}\\n        bt = defaultdict(list)\\n        s = set()\\n        for i in range(len(descriptions)):\\n            d[descriptions[i][1]] = descriptions[i][0]\\n            if descriptions[i][2]:\\n                if bt[descriptions[i][0]]:\\n                    bt[descriptions[i][0]][0] = descriptions[i][1]\\n                else:\\n                    bt[descriptions[i][0]].append(descriptions[i][1])\\n                    bt[descriptions[i][0]].append(0)\\n\\n            else:\\n                if bt[descriptions[i][0]]:\\n                    bt[descriptions[i][0]][1] = descriptions[i][1]\\n                else:\\n                    bt[descriptions[i][0]].append(0)\\n                    bt[descriptions[i][0]].append(descriptions[i][1])\\n             \\n    \\n            s.add(descriptions[i][0])\\n            s.add(descriptions[i][1])\\n        for i in s:\\n            if i not in d:\\n                root = i\\n                break\\n        \\n        def bfs(graph, root):\\n            root_node = TreeNode(root)\\n            q = deque()\\n            q.append([root_node])\\n\\n            while q:\\n                level = q.popleft()\\n                nl = []\\n                for child in level:\\n                    if child.val in graph:\\n                        if graph[child.val][0] != 0:\\n                            child.left = TreeNode(graph[child.val][0])\\n                            nl.append(child.left)\\n                        if graph[child.val][1] != 0:\\n                            child.right = TreeNode(graph[child.val][1])                       \\n                            nl.append(child.right)\\n                if nl:\\n                    q.append(nl)\\n            \\n            return root_node\\n        \\n        root_node = bfs(bt, root)\\n        return root_node\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763351,
                "title": "simple-solution-using-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int, pair<TreeNode*,bool>> m;\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        for(auto i : descriptions){\\n            int parent = i[0], child = i[1], pos = i[2];\\n\\n            if(m[parent].first==NULL) m[parent].first = new TreeNode(parent);\\n            if(m[child].first==NULL) m[child].first = new TreeNode(child);\\n\\n            if(pos==1)  m[parent].first -> left = m[child].first;\\n            else m[parent].first -> right = m[child].first;\\n\\n            m[child].second = true;\\n        }\\n\\n        TreeNode* root;\\n\\n        for(auto it:m){\\n            if(!it.second.second){\\n                root = it.second.first;\\n                break;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, pair<TreeNode*,bool>> m;\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        for(auto i : descriptions){\\n            int parent = i[0], child = i[1], pos = i[2];\\n\\n            if(m[parent].first==NULL) m[parent].first = new TreeNode(parent);\\n            if(m[child].first==NULL) m[child].first = new TreeNode(child);\\n\\n            if(pos==1)  m[parent].first -> left = m[child].first;\\n            else m[parent].first -> right = m[child].first;\\n\\n            m[child].second = true;\\n        }\\n\\n        TreeNode* root;\\n\\n        for(auto it:m){\\n            if(!it.second.second){\\n                root = it.second.first;\\n                break;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762915,
                "title": "c-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n            unordered_map<int,TreeNode*>mp;\\n            unordered_set<int>childs;  \\n            for(int i=0;i<d.size();i++){\\n               if(mp.find(d[i][0])==mp.end())mp[d[i][0]]=new TreeNode(d[i][0]);\\n               if(mp.find(d[i][1])==mp.end())mp[d[i][1]]=new TreeNode(d[i][1]);\\n                childs.insert(d[i][1]);\\n                TreeNode*parent=  mp[d[i][0]];\\n                TreeNode*child=  mp[d[i][1]];\\n                if(d[i][2]==1)parent->left=child;\\n                else parent->right=child;\\n            }\\n            for(int i=0;i<d.size();i++){\\n                  if(childs.find(d[i][0])==childs.end())return mp[d[i][0]];\\n            }\\n            return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& d) {\\n            unordered_map<int,TreeNode*>mp;\\n            unordered_set<int>childs;  \\n            for(int i=0;i<d.size();i++){\\n               if(mp.find(d[i][0])==mp.end())mp[d[i][0]]=new TreeNode(d[i][0]);\\n               if(mp.find(d[i][1])==mp.end())mp[d[i][1]]=new TreeNode(d[i][1]);\\n                childs.insert(d[i][1]);\\n                TreeNode*parent=  mp[d[i][0]];\\n                TreeNode*child=  mp[d[i][1]];\\n                if(d[i][2]==1)parent->left=child;\\n                else parent->right=child;\\n            }\\n            for(int i=0;i<d.size();i++){\\n                  if(childs.find(d[i][0])==childs.end())return mp[d[i][0]];\\n            }\\n            return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744774,
                "title": "c-optimized",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> mp;\\n        int rootVal = 0;\\n        for(auto& v : descriptions) {\\n            TreeNode* parent = mp[v[0]];\\n            TreeNode* son = mp[v[1]];\\n            if (parent == nullptr) {\\n                parent = new TreeNode(v[0]);\\n                mp[v[0]] = parent;\\n                rootVal ^= v[0];\\n            }\\n            if (son == nullptr) {\\n                son = new TreeNode(v[1]);\\n                mp[v[1]] = son; \\n            } else {\\n                rootVal ^= v[1];\\n            }\\n            if (v[2]) {\\n                parent->left = son;\\n            } else {\\n                parent->right = son;\\n            }\\n        }\\n        return mp[rootVal];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\\n        unordered_map<int, TreeNode*> mp;\\n        int rootVal = 0;\\n        for(auto& v : descriptions) {\\n            TreeNode* parent = mp[v[0]];\\n            TreeNode* son = mp[v[1]];\\n            if (parent == nullptr) {\\n                parent = new TreeNode(v[0]);\\n                mp[v[0]] = parent;\\n                rootVal ^= v[0];\\n            }\\n            if (son == nullptr) {\\n                son = new TreeNode(v[1]);\\n                mp[v[1]] = son; \\n            } else {\\n                rootVal ^= v[1];\\n            }\\n            if (v[2]) {\\n                parent->left = son;\\n            } else {\\n                parent->right = son;\\n            }\\n        }\\n        return mp[rootVal];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734441,
                "title": "python-easy-to-understand",
                "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n\\n        indegree = {}\\n        tree = {}\\n        for d in descriptions:\\n            if d[0] not in tree:\\n                parent_treenode = TreeNode(d[0])\\n                tree[d[0]] = parent_treenode\\n\\n            else:\\n                parent_treenode = tree[d[0]]\\n\\n            if d[1] not in  tree:\\n                child_treenode = TreeNode(d[1])\\n                tree[d[1]] = child_treenode\\n\\n            else:\\n                child_treenode = tree[d[1]]\\n\\n            if parent_treenode not in indegree:\\n                indegree[parent_treenode] = 0\\n            \\n            if child_treenode in indegree:\\n                indegree[child_treenode] += 1\\n            else:\\n                indegree[child_treenode] = 1\\n\\n            if d[2] == 1:\\n                parent_treenode.left = child_treenode\\n            else:\\n                parent_treenode.right = child_treenode\\n\\n        for i in indegree:\\n            if indegree[i] == 0:\\n                return i\\n\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n\\n        indegree = {}\\n        tree = {}\\n        for d in descriptions:\\n            if d[0] not in tree:\\n                parent_treenode = TreeNode(d[0])\\n                tree[d[0]] = parent_treenode\\n\\n            else:\\n                parent_treenode = tree[d[0]]\\n\\n            if d[1] not in  tree:\\n                child_treenode = TreeNode(d[1])\\n                tree[d[1]] = child_treenode\\n\\n            else:\\n                child_treenode = tree[d[1]]\\n\\n            if parent_treenode not in indegree:\\n                indegree[parent_treenode] = 0\\n            \\n            if child_treenode in indegree:\\n                indegree[child_treenode] += 1\\n            else:\\n                indegree[child_treenode] = 1\\n\\n            if d[2] == 1:\\n                parent_treenode.left = child_treenode\\n            else:\\n                parent_treenode.right = child_treenode\\n\\n        for i in indegree:\\n            if indegree[i] == 0:\\n                return i\\n\\n            \\n\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1870229,
                "content": [
                    {
                        "username": "only_22",
                        "content": "Scala solutions will most likely exceed Memory limits... An issue has been raised with Leetcode - more details in Solutions."
                    },
                    {
                        "username": "Msey",
                        "content": "If you are not python guy with setdefault function I\\'ve got bad news for you"
                    },
                    {
                        "username": "Deep_down",
                        "content": "what is the bad news :)\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Add a constraint\\n- All node values are unique.\\n\\n___(This will be really helpful)___"
                    }
                ]
            },
            {
                "id": 1833529,
                "content": [
                    {
                        "username": "only_22",
                        "content": "Scala solutions will most likely exceed Memory limits... An issue has been raised with Leetcode - more details in Solutions."
                    },
                    {
                        "username": "Msey",
                        "content": "If you are not python guy with setdefault function I\\'ve got bad news for you"
                    },
                    {
                        "username": "Deep_down",
                        "content": "what is the bad news :)\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Add a constraint\\n- All node values are unique.\\n\\n___(This will be really helpful)___"
                    }
                ]
            },
            {
                "id": 2029622,
                "content": [
                    {
                        "username": "only_22",
                        "content": "Scala solutions will most likely exceed Memory limits... An issue has been raised with Leetcode - more details in Solutions."
                    },
                    {
                        "username": "Msey",
                        "content": "If you are not python guy with setdefault function I\\'ve got bad news for you"
                    },
                    {
                        "username": "Deep_down",
                        "content": "what is the bad news :)\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Add a constraint\\n- All node values are unique.\\n\\n___(This will be really helpful)___"
                    }
                ]
            }
        ]
    },
    {
        "title": "Divide Array Into Equal Pairs",
        "question_content": "<p>You are given an integer array <code>nums</code> consisting of <code>2 * n</code> integers.</p>\n\n<p>You need to divide <code>nums</code> into <code>n</code> pairs such that:</p>\n\n<ul>\n\t<li>Each element belongs to <strong>exactly one</strong> pair.</li>\n\t<li>The elements present in a pair are <strong>equal</strong>.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if nums can be divided into</em> <code>n</code> <em>pairs, otherwise return</em> <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,3,2,2,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nThere are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.\nIf nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> \nThere is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 500</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1863995,
                "title": "java-python-3-4-1-liner-o-n-code",
                "content": "**Method 1: Count and check parity**\\n\\n```java\\n    public boolean divideArray(int[] nums) {\\n        int[] cnt = new int[501];\\n        for (int n : nums)\\n            ++cnt[n];\\n        return IntStream.of(cnt).allMatch(n -> n % 2 == 0);\\n    }\\n```\\n\\n```python\\n    def divideArray(self, nums: List[int]) -> bool:\\n        return all(v % 2 == 0 for v in Counter(nums).values())\\n```\\n\\n---\\n\\n**Method 2: check parity by boolean array**\\n\\n```java\\n    public boolean divideArray(int[] nums) {\\n        boolean[] odd = new boolean[501];\\n        for (int n : nums)\\n            odd[n] = !odd[n];\\n        return Arrays.equals(odd, new boolean[501]);\\n    }\\n```\\n```python\\n    def divideArray(self, nums: List[int]) -> bool:\\n        odd = [False] * 501\\n        for n in nums:\\n            odd[n] = not odd[n]\\n        return not any(odd)\\n```\\n\\n---\\n\\n**Method 3: HashSet** - credit to **@SunnyvaleCA**.\\n\\n```java\\n    public boolean divideArray(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (!seen.add(num)) {\\n                seen.remove(num);\\n            }\\n        }\\n        return seen.isEmpty();\\n    }\\n```\\n```python\\n    def divideArray(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for num in nums:\\n            if num in seen:\\n                seen.discard(num)\\n            else:\\n                seen.add(num)\\n        return not seen\\n```\\nor simplify it to follows: - credit to **@stefan4trivia**\\n\\n```python\\nclass stefan4trivia:\\n    def divideArray(self, nums: List[int], test_case_number = [0]) -> bool:\\n        seen = set()\\n        for n in nums:\\n            seen ^= {n}\\n        return not seen\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public boolean divideArray(int[] nums) {\\n        int[] cnt = new int[501];\\n        for (int n : nums)\\n            ++cnt[n];\\n        return IntStream.of(cnt).allMatch(n -> n % 2 == 0);\\n    }\\n```\n```python\\n    def divideArray(self, nums: List[int]) -> bool:\\n        return all(v % 2 == 0 for v in Counter(nums).values())\\n```\n```java\\n    public boolean divideArray(int[] nums) {\\n        boolean[] odd = new boolean[501];\\n        for (int n : nums)\\n            odd[n] = !odd[n];\\n        return Arrays.equals(odd, new boolean[501]);\\n    }\\n```\n```python\\n    def divideArray(self, nums: List[int]) -> bool:\\n        odd = [False] * 501\\n        for n in nums:\\n            odd[n] = not odd[n]\\n        return not any(odd)\\n```\n```java\\n    public boolean divideArray(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (!seen.add(num)) {\\n                seen.remove(num);\\n            }\\n        }\\n        return seen.isEmpty();\\n    }\\n```\n```python\\n    def divideArray(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for num in nums:\\n            if num in seen:\\n                seen.discard(num)\\n            else:\\n                seen.add(num)\\n        return not seen\\n```\n```python\\nclass stefan4trivia:\\n    def divideArray(self, nums: List[int], test_case_number = [0]) -> bool:\\n        seen = set()\\n        for n in nums:\\n            seen ^= {n}\\n        return not seen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864351,
                "title": "c-easy-o-n-solution-2-approaches",
                "content": "**Please upvote if you find this solution helpful :)**\\n**Approach-1 :**\\n*Time Complexity - O(Nlog(N))\\nSpace Complexity - O(1)*\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) \\n    {\\n        int n =nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i=1;\\n        while(i<n)\\n        {\\n            if(nums[i-1] != nums[i])\\n                return false;\\n            i = i+2;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n**Code:**\\n**Approach-2 :**\\n*Time Complexity - O(N)\\nSpace Complexity - O(N)*\\n\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mpp;\\n        \\n        for(int i=0; i<n; i++){\\n            mpp[nums[i]]++;    \\n        }\\n        \\n        //count total pairs\\n        int totalPairs = 0;\\n        for(auto it: mpp){\\n            totalPairs += it.second/2;\\n        }\\n        \\n        return (totalPairs == n/2);\\n    }\\n};\\n```\\n\\n**Please upvote if you find this solution helpful :)**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) \\n    {\\n        int n =nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i=1;\\n        while(i<n)\\n        {\\n            if(nums[i-1] != nums[i])\\n                return false;\\n            i = i+2;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mpp;\\n        \\n        for(int i=0; i<n; i++){\\n            mpp[nums[i]]++;    \\n        }\\n        \\n        //count total pairs\\n        int totalPairs = 0;\\n        for(auto it: mpp){\\n            totalPairs += it.second/2;\\n        }\\n        \\n        return (totalPairs == n/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105016,
                "title": "why-xoring-does-not-work",
                "content": "as even occurence of a number does not affect the XOR, the result should be zero\\nbut this approach is not working. What\\'s wrong? any idea?\\n```\\nint xorr=0;\\nfor(int i=0; i<nums.size(); i++){\\n\\txorr^=nums[i];\\n}\\n\\nreturn xorr==0 ;\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nint xorr=0;\\nfor(int i=0; i<nums.size(); i++){\\n\\txorr^=nums[i];\\n}\\n\\nreturn xorr==0 ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894695,
                "title": "javascript-clean-and-easy-to-understand",
                "content": "Let me know if you have any doubts. I try to answer/help.\\n\\nPlease upvote if you liked the solution.\\n\\n```\\nvar divideArray = function(nums) {\\n  const numMap = new Map();\\n  for (const num of nums) {\\n    numMap.has(num) ? numMap.delete(num) : numMap.set(num, true);\\n  }\\n  return numMap.size === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar divideArray = function(nums) {\\n  const numMap = new Map();\\n  for (const num of nums) {\\n    numMap.has(num) ? numMap.delete(num) : numMap.set(num, true);\\n  }\\n  return numMap.size === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864011,
                "title": "java-easy",
                "content": "```\\n\\n/*\\nThing here is that each number\\'s frequency must be even,\\nSo that they can be in pair that satisfy given condition \\n*/\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int freq[] = new int[501];\\n        \\n        //count freuency\\n        //O(N)\\n        for (int i = 0; i < nums.length; i++) {\\n            freq[nums[i]]++;\\n        }\\n        \\n        //check if frequency is even or not\\n        //O(500) - O(1)\\n        for (int f : freq) {\\n            if (f % 2 != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n```\\n\\nTC - O(N)\\nSC - O(501) or O(1)\\n\\nFeel free to upvote :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n/*\\nThing here is that each number\\'s frequency must be even,\\nSo that they can be in pair that satisfy given condition \\n*/\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int freq[] = new int[501];\\n        \\n        //count freuency\\n        //O(N)\\n        for (int i = 0; i < nums.length; i++) {\\n            freq[nums[i]]++;\\n        }\\n        \\n        //check if frequency is even or not\\n        //O(500) - O(1)\\n        for (int f : freq) {\\n            if (f % 2 != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863925,
                "title": "all-of",
                "content": "Just check that the count of all characters is even.\\n\\n**C++**\\n```cpp\\nbool divideArray(vector<int>& nums) {\\n    int cnt[501] = {};\\n    for (int n : nums)\\n        ++cnt[n];\\n    return all_of(begin(cnt), end(cnt), [](int cnt){ return cnt % 2 == 0; });\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool divideArray(vector<int>& nums) {\\n    int cnt[501] = {};\\n    for (int n : nums)\\n        ++cnt[n];\\n    return all_of(begin(cnt), end(cnt), [](int cnt){ return cnt % 2 == 0; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1869444,
                "title": "using-hashmap-cpp-easy-to-understand",
                "content": "```\\nPls Upvote \\n\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        \\n        unordered_map<int,int> hello ;\\n        \\n        for (int i=0;i<nums.size();i++)\\n            hello[nums[i]]++ ;\\n        \\n        \\n        for (auto& c:hello)\\n            if (c.second%2==1)\\n                return false ;\\n        \\n        return true ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nPls Upvote \\n\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        \\n        unordered_map<int,int> hello ;\\n        \\n        for (int i=0;i<nums.size();i++)\\n            hello[nums[i]]++ ;\\n        \\n        \\n        for (auto& c:hello)\\n            if (c.second%2==1)\\n                return false ;\\n        \\n        return true ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592428,
                "title": "java-beginners-friendly-best-approach",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n       // int count = 0;\\n        for( int i = 0; i< nums.length ; i+=2){\\n            if(nums[i] != nums[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n       // int count = 0;\\n        for( int i = 0; i< nums.length ; i+=2){\\n            if(nums[i] != nums[i+1]){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1864079,
                "title": "python-solution-using-counter-beats-99-o-n",
                "content": "```py\\nclass Solution:\\n\\n    def divideArray(self, nums: List[int]) -> bool:\\n        lena = len(nums)\\n        count = sum(num//2 for num in Counter(nums).values())\\n        return (lena/2 == count)\\n        \\n```\\nOr, to simplify it:\\n```\\n    def divideArray(self, nums: List[int]) -> bool:\\n        return all(i % 2 == 0 for i in Counter(nums).values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n\\n    def divideArray(self, nums: List[int]) -> bool:\\n        lena = len(nums)\\n        count = sum(num//2 for num in Counter(nums).values())\\n        return (lena/2 == count)\\n        \\n```\n```\\n    def divideArray(self, nums: List[int]) -> bool:\\n        return all(i % 2 == 0 for i in Counter(nums).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864213,
                "title": "2206-divide-array-into-equal-pairs",
                "content": "class Solution {\\n    public boolean divideArray(int[] nums) {\\n        if(nums.length%2!=0)\\n            return false;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]!=nums[i+1])\\n                return false;\\n                else{\\n                    i=i+2;\\n                }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean divideArray(int[] nums) {\\n        if(nums.length%2!=0)\\n            return false;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]!=nums[i+1])\\n                return false;\\n                else{\\n                    i=i+2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3091715,
                "title": "100-faster-no-map-no-list-java-c",
                "content": "```\\nplease upvote, if you find it useful\\n```\\n\\n\\n# Java\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int[] n = new int[501];\\n        for(int i=0;i<nums.length;i++){\\n            n[nums[i]]++;\\n        }\\n        for(int i=0;i<501;i++){\\n            if(n[i]%2==1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n# C++\\n\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n[501]={};\\n        int size =nums.size();\\n        for(int i=0;i<size;i++){\\n            n[nums[i]]++;\\n        }\\n        for(int i=0;i<501;i++){\\n            if(n[i]%2==1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nplease upvote, if you find it useful\\n```\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int[] n = new int[501];\\n        for(int i=0;i<nums.length;i++){\\n            n[nums[i]]++;\\n        }\\n        for(int i=0;i<501;i++){\\n            if(n[i]%2==1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n[501]={};\\n        int size =nums.size();\\n        for(int i=0;i<size;i++){\\n            n[nums[i]]++;\\n        }\\n        for(int i=0;i<501;i++){\\n            if(n[i]%2==1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975869,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n    Set<Integer>set=new HashSet<>();\\n    for(int i:nums){\\n        if(set.contains(i)){\\n            set.remove(i);\\n        }else{\\n            set.add(i);\\n        }\\n    }\\n    return set.size()==0;\\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n    Set<Integer>set=new HashSet<>();\\n    for(int i:nums){\\n        if(set.contains(i)){\\n            set.remove(i);\\n        }else{\\n            set.add(i);\\n        }\\n    }\\n    return set.size()==0;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491426,
                "title": "c-easy-to-understand-why-wrong-with-xor",
                "content": "//most will get confused like why we can\\'t do this with xor as xor of even occurence of nums will give zero.\\ndont get confused that the xor of other numbers also give 0 like [2,3,4,5] so this approach is wrong.\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=1;\\n        sort(nums.begin(),nums.end());\\n        while(i<n){\\n            if(nums[i]!=nums[i-1])\\n                return false;\\n            else\\n                i=i+2;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=1;\\n        sort(nums.begin(),nums.end());\\n        while(i<n){\\n            if(nums[i]!=nums[i-1])\\n                return false;\\n            else\\n                i=i+2;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469061,
                "title": "typescript-javascript-set-5-lines",
                "content": "```\\nfunction divideArray(nums: number[]): boolean {\\n  const set = new Set<number>();\\n  for(const num of nums){\\n    if(set.has(num))\\n      set.delete(num)\\n    else\\n      set.add(num)\\n  }\\n  return set.size === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nfunction divideArray(nums: number[]): boolean {\\n  const set = new Set<number>();\\n  for(const num of nums){\\n    if(set.has(num))\\n      set.delete(num)\\n    else\\n      set.add(num)\\n  }\\n  return set.size === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3188685,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n            i++;\\n           continue;\\n            }\\n           else \\n           return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n            i++;\\n           continue;\\n            }\\n           else \\n           return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091411,
                "title": "java-hashmap-2-line-code-with-explanation",
                "content": "# Approach\\nFirst count the frequency of every element and if the number of frequency is even number then return true otherwise false;\\n\\n\\n\\n**PLEASE UPVOTE IF YOU LIKE IT**\\n# Code\\n```\\nclass Solution {\\n    public boolean divideArray(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int i : map.keySet()) {\\n            if (map.get(i) % 2 != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int i : map.keySet()) {\\n            if (map.get(i) % 2 != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865957,
                "title": "c-easy-to-understand-using-sort-with-explanation-beginners-friendly",
                "content": "Please upvote if it helps\\n\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) \\n    {\\n        int size = nums.size();\\n        sort(nums.begin(),nums.end());          // sort the value so the ame values come together\\n        \\n        int itr = 1;\\n        while(itr<size)\\n        {\\n            // if elemets of pair are not equal then return false\\n            if(nums[itr]!=nums[itr-1])\\n                return false;\\n            // move pointer by 2 steps\\n            itr = itr + 2;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) \\n    {\\n        int size = nums.size();\\n        sort(nums.begin(),nums.end());          // sort the value so the ame values come together\\n        \\n        int itr = 1;\\n        while(itr<size)\\n        {\\n            // if elemets of pair are not equal then return false\\n            if(nums[itr]!=nums[itr-1])\\n                return false;\\n            // move pointer by 2 steps\\n            itr = itr + 2;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864067,
                "title": "just-keep-on-diving-count-by-2",
                "content": "We are told if we can make `N Pairs of  equal values`.\\n\\nFor that we will divide the count of every element by 2 as how many pairs we can make , and if result is not found.\\nKeep on getting the count of pairs.\\n\\n**Number of Pairs= Count of element/2**\\n\\nGet the count of pairs we can make from every element.\\n\\n# C++\\n    \\n\\tbool divideArray(vector<int>& nums) {\\n        int n= size(nums);\\n        unordered_map<int,int> mp;\\n        for(auto i:nums) mp[i]++;\\n        int cnt=0;\\n        for(auto &i:mp) cnt+= (i.second/2);\\n        return cnt==(n/2);\\n    }\\n\\t\\n# Java\\n     public boolean divideArray(int[] nums){\\n        int n= nums.length;\\n        HashMap<Integer,Integer> mp= new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int cnt= mp.containsKey(nums[i])? mp.get(nums[i]) : 0;\\n            mp.put(nums[i],cnt+1);\\n        }\\n        int res=0;\\n        for(int i:mp.values()) res+= i/2;\\n        return res==(n/2);\\n    }\\n**Time** - O(N)\\n**Space** - O(Number of unique values in array) -> O(501), if all element are present one time",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "We are told if we can make `N Pairs of  equal values`.\\n\\nFor that we will divide the count of every element by 2 as how many pairs we can make , and if result is not found.\\nKeep on getting the count of pairs.\\n\\n**Number of Pairs= Count of element/2**\\n\\nGet the count of pairs we can make from every element.\\n\\n# C++\\n    \\n\\tbool divideArray(vector<int>& nums) {\\n        int n= size(nums);\\n        unordered_map<int,int> mp;\\n        for(auto i:nums) mp[i]++;\\n        int cnt=0;\\n        for(auto &i:mp) cnt+= (i.second/2);\\n        return cnt==(n/2);\\n    }\\n\\t\\n# Java\\n     public boolean divideArray(int[] nums){\\n        int n= nums.length;\\n        HashMap<Integer,Integer> mp= new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int cnt= mp.containsKey(nums[i])? mp.get(nums[i]) : 0;\\n            mp.put(nums[i],cnt+1);\\n        }\\n        int res=0;\\n        for(int i:mp.values()) res+= i/2;\\n        return res==(n/2);\\n    }\\n**Time** - O(N)\\n**Space** - O(Number of unique values in array) -> O(501), if all element are present one time",
                "codeTag": "Unknown"
            },
            {
                "id": 1864061,
                "title": "cpp-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& v) {\\n        unordered_map<int,int> mp;\\n        for(auto x:v)mp[x]++;\\n        for(auto it:mp){\\n            if(it.second&1)return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& v) {\\n        unordered_map<int,int> mp;\\n        for(auto x:v)mp[x]++;\\n        for(auto it:mp){\\n            if(it.second&1)return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864042,
                "title": "c-bruce-force-o-n-log-n-solution",
                "content": "\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\tsort(nums.begin(),nums.end());\\n        int count=0;\\n        int n=nums.size()/2;\\n        for(int i=0; i<2*n; i+=2){\\n            if(nums[i]==nums[i+1]){\\n                count++;\\n            }\\n        }\\n        if(count==n){\\n            return true;\\n        }\\n        return false;",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\tsort(nums.begin(),nums.end());\\n        int count=0;\\n        int n=nums.size()/2;\\n        for(int i=0; i<2*n; i+=2){\\n            if(nums[i]==nums[i+1]){\\n                count++;\\n            }\\n        }\\n        if(count==n){\\n            return true;\\n        }\\n        return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 3311954,
                "title": "c-solution-using-unordered-map",
                "content": "# Intuition\\nEvery number should be part of a pair.\\n\\n# Approach\\nAs each number should be part of a pair and each number in a pair is equal the frequency of any given number should be even. Use a map to store frequency of each number and later iterate over every key of the map to check if the value is even.\\n\\n# Complexity\\n- Time complexity:\\nTime to add keys and frequency to the map + time to access each key and check for val % 2.\\nO(N)*O(1) + O(N)*O(1) = O(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for( int i = 0; i < nums.size(); i++ ){\\n            mp[nums[i]] ++;\\n        }\\n        for(auto it : mp){\\n            if( it.second % 2 != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for( int i = 0; i < nums.size(); i++ ){\\n            mp[nums[i]] ++;\\n        }\\n        for(auto it : mp){\\n            if( it.second % 2 != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078543,
                "title": "easy-to-understand-c-solution-using-map-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        map <int,int> mp;\\n        for(auto it:nums)\\n            mp[it]++;\\n        for(auto it:mp){ if((it.second)%2!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        map <int,int> mp;\\n        for(auto it:nums)\\n            mp[it]++;\\n        for(auto it:mp){ if((it.second)%2!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067680,
                "title": "unordered-map-logic-of-c-esay-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans[nums[i]]++;\\n        }\\n        for(auto j:ans){\\n            if(j.second%2==1){\\n                return false;\\n            }\\n        }\\n            return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans[nums[i]]++;\\n        }\\n        for(auto j:ans){\\n            if(j.second%2==1){\\n                return false;\\n            }\\n        }\\n            return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042079,
                "title": "c-bit-solution",
                "content": "# Logic\\nXOR of number with itself is zero.\\n\\n# Approach\\nI am looping through the array *nums*. Checking is done by xoring i and i+1 bit. If it is not zero loop returns zero.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        sort(nums.begin(), nums.end());\\n        \\n       for(int i = 0; i < n; i += 2){\\n           if((nums[i]^nums[i+1]) != 0)\\n                return false;\\n       }\\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        sort(nums.begin(), nums.end());\\n        \\n       for(int i = 0; i < n; i += 2){\\n           if((nums[i]^nums[i+1]) != 0)\\n                return false;\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769552,
                "title": "java-easy-solution-hashset",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n       Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (!seen.add(num)) {\\n                seen.remove(num);\\n            }\\n        }\\n        return seen.isEmpty();  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n       Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (!seen.add(num)) {\\n                seen.remove(num);\\n            }\\n        }\\n        return seen.isEmpty();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307709,
                "title": "go-90-faster-solution-speed-10-ms-memory-4-1-mb",
                "content": "# **Hey,mate! This is my quick solution**\\n\\tfunc divideArray(nums []int)(bool) {\\n\\t\\tsort.Ints(nums)\\n\\t\\tres := true\\n\\t\\tfor i := 0 ; i < len(nums); i+=2{\\n\\t\\t\\tif nums[i]!=nums[i+1] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n# **if you like it ,please, push arrow to lift up solution to the top ,thanks!**",
                "solutionTags": [
                    "Go"
                ],
                "code": "# **Hey,mate! This is my quick solution**\\n\\tfunc divideArray(nums []int)(bool) {\\n\\t\\tsort.Ints(nums)\\n\\t\\tres := true\\n\\t\\tfor i := 0 ; i < len(nums); i+=2{\\n\\t\\t\\tif nums[i]!=nums[i+1] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n# **if you like it ,please, push arrow to lift up solution to the top ,thanks!**",
                "codeTag": "Unknown"
            },
            {
                "id": 2263826,
                "title": "o-1-space-and-o-n-time-complexity-one-pass-solution-java",
                "content": "int xor1=0;\\n        int xor2=0;\\n        for(int x: nums)\\n        {\\n            xor1^=x;\\n            xor2^=-x;\\n        }\\n        return xor1==0 && xor2==0;",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "int xor1=0;\\n        int xor2=0;\\n        for(int x: nums)\\n        {\\n            xor1^=x;\\n            xor2^=-x;\\n        }\\n        return xor1==0 && xor2==0;",
                "codeTag": "Unknown"
            },
            {
                "id": 2114640,
                "title": "easy-python-solution",
                "content": "```\\ndef divideArray(self, nums: List[int]) -> bool:\\n        for i in nums:\\n            if nums.count(i)%2==1:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef divideArray(self, nums: List[int]) -> bool:\\n        for i in nums:\\n            if nums.count(i)%2==1:\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1915915,
                "title": "c-easy-solution-100-faster-well-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int i,j,k=0;\\n        \\n        // for all the nums size which are odd that can\\'t form any pair         \\n        if(nums.size()%2!=0){\\n            return false;\\n        }\\n        \\n        // Sorting the numbers to bring the same items nearer         \\n        sort(nums.begin(),nums.end());\\n        \\n        // Moving Two steps after every loop         \\n        for(i=0;i<nums.size();i+=2){\\n            if(nums[i]==nums[i+1]);\\n            else\\n            return false; // If the pairs are not same returning false\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int i,j,k=0;\\n        \\n        // for all the nums size which are odd that can\\'t form any pair         \\n        if(nums.size()%2!=0){\\n            return false;\\n        }\\n        \\n        // Sorting the numbers to bring the same items nearer         \\n        sort(nums.begin(),nums.end());\\n        \\n        // Moving Two steps after every loop         \\n        for(i=0;i<nums.size();i+=2){\\n            if(nums[i]==nums[i+1]);\\n            else\\n            return false; // If the pairs are not same returning false\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869368,
                "title": "easy-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function (nums) {\\n    let map = {};\\n    for (let num of nums) {\\n        map[num] ? delete map[num] : (map[num] = true);\\n    }\\n    return Object.keys(map).length === 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function (nums) {\\n    let map = {};\\n    for (let num of nums) {\\n        map[num] ? delete map[num] : (map[num] = true);\\n    }\\n    return Object.keys(map).length === 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1866778,
                "title": "c-frequency-map-vs-sorting-5-solutions-explained-100-time-4ms-35-space-13-2mb",
                "content": "Base problem that is asking you to create a frequency map and to check if any numbers appears an odd amount of times.\\n\\nWhich is what we will concretely do, creating the frequency map `freq` and then populating it so that it stores the frequency (value) of each unique element (key) in `nums`.\\n\\nWe will then loop through all the values and, if any one of them is odd`, will `return` `false`.\\n\\nIf no element matches that case, we will just `return` `true` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        // support variables\\n        unordered_map<int, int> freq;\\n        // populating the frequency map\\n        for (int n: nums) freq[n]++;\\n        // looking for mismatched pairs\\n        for (auto &e: freq) if (e.second & 1) return false;\\n        return true;\\n    }\\n};\\n```\\n\\nI got slightly better performance replacing the hashmap with an array coupled with a set:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        // support variables\\n        int freq[501] = {};\\n        unordered_set<int> uniques;\\n        // populating the frequency map\\n        for (int &n: nums) {\\n            freq[n]++;\\n            uniques.insert(n);\\n        }\\n        // looking for mismatched pairs\\n        for (int n: uniques) if (freq[n] & 1) return false;\\n        return true;\\n    }\\n};\\n```\\n\\nTrying to put another exit case in the very first loop also helped me - no point in continuing if we get more unique elements than half the size of `nums` - it has to be a `false` case:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        // support variables\\n        int freq[501] = {}, threshold = nums.size() >> 1;\\n        unordered_set<int> uniques;\\n        // populating the frequency map\\n        for (int &n: nums) {\\n            freq[n]++;\\n            uniques.insert(n);\\n            if (uniques.size() > threshold) return false;\\n        }\\n        // looking for mismatched pairs\\n        for (int n: uniques) if (freq[n] & 1) return false;\\n        return true;\\n    }\\n};\\n```\\n\\nAnd, hey: since we have a threshold now, we might as well reserve enough space in the first solution, so avoid reallocations with the frequency map and include the same logic with it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        // support variables\\n        int threshold = nums.size() >> 1;\\n        unordered_map<int, int> freq;\\n        freq.reserve(threshold);\\n        // populating the frequency map\\n        for (int n: nums) {\\n            freq[n]++;\\n            if (freq.size() > threshold) return false;\\n        }\\n        // looking for mismatched pairs\\n        for (auto &e: freq) if (e.second & 1) return false;\\n        return true;\\n    }\\n};\\n```\\n\\nGiven the small size of `nums`, the naive implementation works surprisingly faster than expected, on top of course consuming much less space:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        // preparing nums\\n        sort(begin(nums), end(nums));\\n        // populating the frequency map\\n        for (int i = 0, lmt = nums.size(); i < lmt; i += 2) {\\n            if (nums[i] != nums[i + 1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nSo fast, it gave me a top performance:\\n![image](https://assets.leetcode.com/users/images/1c558309-8058-413b-bda5-4e88d5c526d0_1647768648.104005.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        // support variables\\n        unordered_map<int, int> freq;\\n        // populating the frequency map\\n        for (int n: nums) freq[n]++;\\n        // looking for mismatched pairs\\n        for (auto &e: freq) if (e.second & 1) return false;\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        // support variables\\n        int freq[501] = {};\\n        unordered_set<int> uniques;\\n        // populating the frequency map\\n        for (int &n: nums) {\\n            freq[n]++;\\n            uniques.insert(n);\\n        }\\n        // looking for mismatched pairs\\n        for (int n: uniques) if (freq[n] & 1) return false;\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        // support variables\\n        int freq[501] = {}, threshold = nums.size() >> 1;\\n        unordered_set<int> uniques;\\n        // populating the frequency map\\n        for (int &n: nums) {\\n            freq[n]++;\\n            uniques.insert(n);\\n            if (uniques.size() > threshold) return false;\\n        }\\n        // looking for mismatched pairs\\n        for (int n: uniques) if (freq[n] & 1) return false;\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        // support variables\\n        int threshold = nums.size() >> 1;\\n        unordered_map<int, int> freq;\\n        freq.reserve(threshold);\\n        // populating the frequency map\\n        for (int n: nums) {\\n            freq[n]++;\\n            if (freq.size() > threshold) return false;\\n        }\\n        // looking for mismatched pairs\\n        for (auto &e: freq) if (e.second & 1) return false;\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        // preparing nums\\n        sort(begin(nums), end(nums));\\n        // populating the frequency map\\n        for (int i = 0, lmt = nums.size(); i < lmt; i += 2) {\\n            if (nums[i] != nums[i + 1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864286,
                "title": "c-counting-or-sorting",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Counting\\n\\nThe count of each unique number should be even.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/divide-array-into-equal-pairs/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(U) where `U` is the number of unique numbers in `A`\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& A) {\\n        unordered_map<int, int> m;\\n        for (int n : A) m[n]++;\\n        for (auto &[n, cnt] : m) {\\n            if (cnt % 2) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n## Solution 2. Sorting\\n\\nAll even-indexed numbers should equal their next numbers.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/divide-array-into-equal-pairs/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& A) {\\n        sort(begin(A), end(A));\\n        for (int i = 0; i < A.size(); i += 2) {\\n            if (A[i] != A[i + 1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/divide-array-into-equal-pairs/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(U) where `U` is the number of unique numbers in `A`\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& A) {\\n        unordered_map<int, int> m;\\n        for (int n : A) m[n]++;\\n        for (auto &[n, cnt] : m) {\\n            if (cnt % 2) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/divide-array-into-equal-pairs/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& A) {\\n        sort(begin(A), end(A));\\n        for (int i = 0; i < A.size(); i += 2) {\\n            if (A[i] != A[i + 1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864075,
                "title": "c-use-hashmap-to-count-frequency-of-2-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mpp;\\n        \\n        for(int i=0; i<n; i++){\\n            mpp[nums[i]]++;    \\n        }\\n        \\n        //count total pairs\\n        int totalPairs = 0;\\n        for(auto &it: mpp){\\n            totalPairs += it.second/2;\\n        }\\n        \\n        return (totalPairs == n/2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mpp;\\n        \\n        for(int i=0; i<n; i++){\\n            mpp[nums[i]]++;    \\n        }\\n        \\n        //count total pairs\\n        int totalPairs = 0;\\n        for(auto &it: mpp){\\n            totalPairs += it.second/2;\\n        }\\n        \\n        return (totalPairs == n/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863989,
                "title": "java-simple-solution-hashset",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : nums){\\n            if(set.contains(i)){\\n                set.remove(i);\\n            }else{\\n                set.add(i);\\n            }\\n        }\\n        return set.size() == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : nums){\\n            if(set.contains(i)){\\n                set.remove(i);\\n            }else{\\n                set.add(i);\\n            }\\n        }\\n        return set.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567287,
                "title": "simplest-python-1-liner",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        return all(not x&1 for x in Counter(nums).values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        return all(not x&1 for x in Counter(nums).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308051,
                "title": "very-easy-to-understand-and-simple-code-for-beginners-beats-95-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1-> check if the size of the array is even because pairs can only be formed if the nums of elemtns are even.\\n2-> Sort the array\\n3-> Start checking from the 1st index, if u will start from the 0th index as we have to find pair we have to increment i by 2 so in this case(0th index) last index will go out of bound.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        if(nums.size()%2!=0)\\n            return false;\\n\\n        sort(nums.begin(),nums.end());\\n        int i=1;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i-1])\\n                return false;\\n            i+=2;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        if(nums.size()%2!=0)\\n            return false;\\n\\n        sort(nums.begin(),nums.end());\\n        int i=1;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i-1])\\n                return false;\\n            i+=2;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139999,
                "title": "easy-to-understand-c-solution",
                "content": "\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1; i+=2)\\n            if(nums[i] != nums[i+1])\\n                return false;\\n        \\n        return true;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1; i+=2)\\n            if(nums[i] != nums[i+1])\\n                return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134936,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it:m)\\n        {\\n            if(it.second%2!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it:m)\\n        {\\n            if(it.second%2!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133696,
                "title": "java-hashmap-easy-solution",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\nCount the frequency of each element. All of the frequencies should be even.\\n``` java []\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i : nums) {\\n            map.put(i, 1 + map.getOrDefault(i, 0));\\n        }\\n\\n        for (int count : map.values()) {\\n            if (count % 2 == 1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n``` \\n##### Time complexity: $$O(n)$$\\n##### Space complexity: $$O(n)$$\\n---\\n### Using a frequency array instead of hashmap:\\n``` java []\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int[] f = new int[501];\\n        for (int i : nums) {\\n            f[i]++;\\n        }\\n\\n        for (int i : nums) {\\n            if (f[i] % 2 == 1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n##### Time complexity: $$O(n)$$\\n##### Space complexity: $$O(1)$$",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Counting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i : nums) {\\n            map.put(i, 1 + map.getOrDefault(i, 0));\\n        }\\n\\n        for (int count : map.values()) {\\n            if (count % 2 == 1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int[] f = new int[501];\\n        for (int i : nums) {\\n            f[i]++;\\n        }\\n\\n        for (int i : nums) {\\n            if (f[i] % 2 == 1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939608,
                "title": "c-map-array",
                "content": "- Count the frequency of each number.\\n- If a number reapeats an odd amount of times, then there will be one left unpaired, hence return false.\\n```C++ []\\n    bool divideArray(vector<int>& nums) {\\n        int count[500] = {0};\\n        for(int &n : nums)  \\n            ++count[n-1];\\n        for(int &n : count)\\n            if(n%2 != 0)\\n                return false;\\n        return true;\\n```\\n```C++ []\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> count;\\n        for(int &n : nums)\\n            ++count[n];\\n        for(pair<int,int> n : count)\\n            if(n.second%2 != 0)\\n                return false;\\n        return true;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\n    bool divideArray(vector<int>& nums) {\\n        int count[500] = {0};\\n        for(int &n : nums)  \\n            ++count[n-1];\\n        for(int &n : count)\\n            if(n%2 != 0)\\n                return false;\\n        return true;\\n```\n```C++ []\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> count;\\n        for(int &n : nums)\\n            ++count[n];\\n        for(pair<int,int> n : count)\\n            if(n.second%2 != 0)\\n                return false;\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2804814,
                "title": "python-5-easy-method-for-this-solution",
                "content": "```\\n#1- by hash table\\n\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        hash=set()\\n        for i in nums:\\n            if i in hash:\\n                hash.remove(i)\\n            else:\\n                hash.add(i)\\n        if len(hash)==0:\\n            return True\\n        else:\\n            return False\\n        \\n#2- by stack\\n\\n        nums.sort()\\n        l=[]\\n        for i in nums:\\n            if l and i==l[-1]:\\n                l.pop()\\n            else:\\n                l.append(i)\\n        if len(l)==0:\\n            return True \\n        else:\\n            return False\\n                \\n            \\n        \\n#3- by dictionary ( the best one with least time complexity)        \\n        d={}\\n        for i in nums:\\n            d[i]=d.get(i,0)+1\\n        for v in d.values():\\n            if v%2==1:\\n                return False\\n        return True\\n        \\n        \\n        \\n        \\n    #4- by bit manipulation   \\n        nums.sort()\\n        for i in range (0,len(nums),2):\\n            if nums[i]^nums[i+1]!=0:\\n                return False\\n        return True\\n\\n#5> by array \\n\\t\\tnums.sort()\\n        for i in range (0,len(nums),2):\\n            if nums[i]!=nums[i+1]:\\n                return False\\n        return True\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Hash Table",
                    "Stack",
                    "Bit Manipulation"
                ],
                "code": "```\\n#1- by hash table\\n\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        hash=set()\\n        for i in nums:\\n            if i in hash:\\n                hash.remove(i)\\n            else:\\n                hash.add(i)\\n        if len(hash)==0:\\n            return True\\n        else:\\n            return False\\n        \\n#2- by stack\\n\\n        nums.sort()\\n        l=[]\\n        for i in nums:\\n            if l and i==l[-1]:\\n                l.pop()\\n            else:\\n                l.append(i)\\n        if len(l)==0:\\n            return True \\n        else:\\n            return False\\n                \\n            \\n        \\n#3- by dictionary ( the best one with least time complexity)        \\n        d={}\\n        for i in nums:\\n            d[i]=d.get(i,0)+1\\n        for v in d.values():\\n            if v%2==1:\\n                return False\\n        return True\\n        \\n        \\n        \\n        \\n    #4- by bit manipulation   \\n        nums.sort()\\n        for i in range (0,len(nums),2):\\n            if nums[i]^nums[i+1]!=0:\\n                return False\\n        return True\\n\\n#5> by array \\n\\t\\tnums.sort()\\n        for i in range (0,len(nums),2):\\n            if nums[i]!=nums[i+1]:\\n                return False\\n        return True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735098,
                "title": "easy-simple-solution-cpp",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for( auto x : nums)m[x]++;\\n\\n        for( auto x : nums)\\n        {\\n            if( m[x]%2!=0)return false;\\n\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for( auto x : nums)m[x]++;\\n\\n        for( auto x : nums)\\n        {\\n            if( m[x]%2!=0)return false;\\n\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695869,
                "title": "python-simple-solution-in-o-n-faster-than-97-13",
                "content": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        d=dict()\\n        for i in nums:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if v%2!=0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        d=dict()\\n        for i in nums:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if v%2!=0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668219,
                "title": "java-solution-using-hashmap-o-n-solution-easy-to-understand",
                "content": "Logic is to count frequency of elements in array and checking if frequency is even.\\nIf we encounter a odd frequency, one element will be left out and a pair could not be formed with that element, hence return FALSE.\\n\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){ //Counting Frequency of Elements in Array\\n            int ele = nums[i];\\n            if(map.containsKey(ele)){\\n                map.put(ele, map.get(ele)+1);\\n            }\\n            else{\\n                map.put(ele,1);\\n            }\\n        }\\n        \\n        for(Map.Entry<Integer,Integer> e: map.entrySet()){\\n            if(e.getValue()%2 != 0){ // Condition to check whether frequency is even or odd\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){ //Counting Frequency of Elements in Array\\n            int ele = nums[i];\\n            if(map.containsKey(ele)){\\n                map.put(ele, map.get(ele)+1);\\n            }\\n            else{\\n                map.put(ele,1);\\n            }\\n        }\\n        \\n        for(Map.Entry<Integer,Integer> e: map.entrySet()){\\n            if(e.getValue()%2 != 0){ // Condition to check whether frequency is even or odd\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625580,
                "title": "python-o-n-simple-solution",
                "content": "Time Complexcity : best -> O(N)\\n                            wrost -> O(NlogN)\\nSpace Complexcity O(N)\\n```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        if len(nums)%2!=0:\\n            return False\\n        n=len(nums)\\n        nums.sort()\\n        p1,p2=[],[]\\n        for i in range(n):\\n            if i%2==0:\\n                p1.append(nums[i])\\n            else:\\n                p2.append(nums[i])\\n        for i in range(len(p1)):\\n            if p1[i]!=p2[i]:\\n                return False\\n        return True\\n```\\n**pls vote if helpfull**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        if len(nums)%2!=0:\\n            return False\\n        n=len(nums)\\n        nums.sort()\\n        p1,p2=[],[]\\n        for i in range(n):\\n            if i%2==0:\\n                p1.append(nums[i])\\n            else:\\n                p2.append(nums[i])\\n        for i in range(len(p1)):\\n            if p1[i]!=p2[i]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434749,
                "title": "java-stream-solution",
                "content": "`This is not faster solution`\\n\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n            return Arrays.stream(nums)\\n                .boxed()\\n                .collect(Collectors.groupingBy(i -> i, Collectors.counting()))\\n                .entrySet()\\n                .stream()\\n                .allMatch(entry -> entry.getValue() % 2 == 0);   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n            return Arrays.stream(nums)\\n                .boxed()\\n                .collect(Collectors.groupingBy(i -> i, Collectors.counting()))\\n                .entrySet()\\n                .stream()\\n                .allMatch(entry -> entry.getValue() % 2 == 0);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370816,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:    \\n        count = 0\\n        for i in nums:\\n            if nums.count(i)%2==0:\\n                count += 1\\n            \\n        if count == len(nums):\\n                return True\\n        else:\\n                return False  \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:    \\n        count = 0\\n        for i in nums:\\n            if nums.count(i)%2==0:\\n                count += 1\\n            \\n        if count == len(nums):\\n                return True\\n        else:\\n                return False  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323145,
                "title": "js-1-liner-just-for-fun",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function(nums) {\\n  return !nums.reduce((acc, cur) => (acc[cur]++, acc), new Uint16Array(501)).some(n => n % 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function(nums) {\\n  return !nums.reduce((acc, cur) => (acc[cur]++, acc), new Uint16Array(501)).some(n => n % 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2214919,
                "title": "easy-c-using-map",
                "content": "First check the size of array, if odd then return false as no pairs exists. Then, if size is even, implement using map.\\n\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pairs = 0;\\n        unordered_map<int, int> mp;\\n        if(n&1){\\n            return false;\\n        }\\n        for(int i=0; i<n; i++){\\n            mp[nums[i]]++;\\n        }         \\n        for(auto it:mp){\\n            pairs += it.second/2;\\n        }\\n        return (pairs == n/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pairs = 0;\\n        unordered_map<int, int> mp;\\n        if(n&1){\\n            return false;\\n        }\\n        for(int i=0; i<n; i++){\\n            mp[nums[i]]++;\\n        }         \\n        for(auto it:mp){\\n            pairs += it.second/2;\\n        }\\n        return (pairs == n/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205079,
                "title": "easy-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function (nums) {\\n    nums = nums.sort((a, b) => a - b)\\n    console.log(nums)\\n    for (let i = 0; i < nums.length - 1; i = i + 2) {\\n        if (nums[i] !== nums[i + 1]) return false\\n    }\\n    return true\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function (nums) {\\n    nums = nums.sort((a, b) => a - b)\\n    console.log(nums)\\n    for (let i = 0; i < nums.length - 1; i = i + 2) {\\n        if (nums[i] !== nums[i + 1]) return false\\n    }\\n    return true\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200910,
                "title": "very-easy-beginner-friendly-solution-using-intuition",
                "content": "Step-1: Sort the array, this will bring all the same numbers together and we are going to leverage this fact in the next step.\\nStep-2: Since only even length arrays can meet the condition, hence can hop off two places each time on array traversal.\\nStep-3: Keep on comparing \\'i-th\\' and \\'i+1-th\\', if they are not same, return false. Else return true.\\n\\n\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<nums.length;i+=2){\\n            if(nums[i]!=nums[i+1]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<nums.length;i+=2){\\n            if(nums[i]!=nums[i+1]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150489,
                "title": "javascript-set-solution",
                "content": "This algorithm is quite easy to understand. We just filter duplicates. \\nIf there any - we return false.\\n\\nThe reason why we use `Set` is to cache values. So if we have three `2`s, then it will: `add`, `delete`, `add`. So, we end up with single `2` in our `Set` which means we should return `false`.\\n\\nI hope the explanation helps.\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nconst divideArray = nums => {\\n  const set = new Set();\\n\\n  for (const num of nums) {\\n    if (set.has(num)) {\\n      set.delete(num);\\n    } else {\\n      set.add(num);\\n    }\\n  }\\n\\n  return set.size === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nconst divideArray = nums => {\\n  const set = new Set();\\n\\n  for (const num of nums) {\\n    if (set.has(num)) {\\n      set.delete(num);\\n    } else {\\n      set.add(num);\\n    }\\n  }\\n\\n  return set.size === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2133798,
                "title": "best-and-easy-cpp-c-solution-for-beginners",
                "content": "\\n# Best and Easy C++ solution \\n**solution takes less than 15ms to compile, faster than 80% solutions & takes less space more than 80% of successful submissions**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n=nums.size();\\n        bool pairs = true ;\\n        int np,npa;\\n        if(n%2 == 0){\\n            int np= n/2;\\n            npa = 0;\\n            sort(nums.begin(),nums.end());\\n            for(int i = 0; i<n-1;i++){\\n                if(nums[i]==nums[i+1]){\\n                    npa++;\\n                    i++;\\n                }\\n            }\\n            if(np==npa){\\n             pairs = true;\\n         }\\n            else {\\n                pairs= false;\\n            }\\n         \\n        }\\n        \\n                \\n       return pairs; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n=nums.size();\\n        bool pairs = true ;\\n        int np,npa;\\n        if(n%2 == 0){\\n            int np= n/2;\\n            npa = 0;\\n            sort(nums.begin(),nums.end());\\n            for(int i = 0; i<n-1;i++){\\n                if(nums[i]==nums[i+1]){\\n                    npa++;\\n                    i++;\\n                }\\n            }\\n            if(np==npa){\\n             pairs = true;\\n         }\\n            else {\\n                pairs= false;\\n            }\\n         \\n        }\\n        \\n                \\n       return pairs; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056782,
                "title": "java-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i=i+2)\\n            if((nums[i] ^ nums[i+1]) != 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i=i+2)\\n            if((nums[i] ^ nums[i+1]) != 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028903,
                "title": "1ms-100-faster-both-set-and-array-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        // Map<Integer,Integer>map=new HashMap<>();\\n        // for(int num : nums)map.put(num,map.getOrDefault(num,0)+1);\\n        // for(Map.Entry<Integer,Integer>m : map.entrySet())\\n        //     if(m.getValue()%2!=0)return false;\\n        // return true;\\n        int freq[]=new int[501];\\n        for(int num  : nums)freq[num]++;\\n        for(int i=0;i<=500;i++)if(freq[i]%2!=0)return false;\\n        return true;\\n    }\\n}\\n```\\n\\nPlease upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        // Map<Integer,Integer>map=new HashMap<>();\\n        // for(int num : nums)map.put(num,map.getOrDefault(num,0)+1);\\n        // for(Map.Entry<Integer,Integer>m : map.entrySet())\\n        //     if(m.getValue()%2!=0)return false;\\n        // return true;\\n        int freq[]=new int[501];\\n        for(int num  : nums)freq[num]++;\\n        for(int i=0;i<=500;i++)if(freq[i]%2!=0)return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933813,
                "title": "java-solution",
                "content": "```\\n\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n      Map<Integer,Integer>  map = new HashMap<>();\\n\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t    map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n\\t\\t}\\n\\t\\tfor(Integer i : map.keySet()){\\n\\t\\t   if(map.get(i)%2 !=0){\\n\\t\\t\\t    return false;\\n\\t\\t    }\\t\\n\\t\\t}\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n      Map<Integer,Integer>  map = new HashMap<>();\\n\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t    map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n\\t\\t}\\n\\t\\tfor(Integer i : map.keySet()){\\n\\t\\t   if(map.get(i)%2 !=0){\\n\\t\\t\\t    return false;\\n\\t\\t    }\\t\\n\\t\\t}\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895454,
                "title": "minimal-kotlin-solution-using-hashset",
                "content": "````\\n    fun divideArray(nums: IntArray): Boolean {\\n        \\n        val set = HashSet<Int>() \\n        \\n        nums.forEach{\\n            if(!set.add(it)) set.remove(it)\\n        }\\n        \\n        return set.isEmpty()\\n    }\\n````\\n",
                "solutionTags": [
                    "Kotlin",
                    "Ordered Set"
                ],
                "code": "````\\n    fun divideArray(nums: IntArray): Boolean {\\n        \\n        val set = HashSet<Int>() \\n        \\n        nums.forEach{\\n            if(!set.add(it)) set.remove(it)\\n        }\\n        \\n        return set.isEmpty()\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1879355,
                "title": "beginner-friendly-python-solution",
                "content": "**Time Complexity : O(n)**\\n```\\nclass Solution(object):\\n    def divideArray(self, nums):\\n        st = set()\\n        for num in nums:\\n            if num in st:\\n                st.remove(num)\\n            else:\\n                st.add(num)\\n        return len(st) == 0\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def divideArray(self, nums):\\n        st = set()\\n        for num in nums:\\n            if num in st:\\n                st.remove(num)\\n            else:\\n                st.add(num)\\n        return len(st) == 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864997,
                "title": "rust-solution",
                "content": "1. Simple fast solution (0 ms)\\n```\\nimpl Solution {\\n    pub fn divide_array(nums: Vec<i32>) -> bool {\\n        let mut counter = [0; 501];\\n        nums.iter().for_each(|&x| counter[x as usize] += 1);\\n        counter.iter().filter(|x| **x > 0).all(|&x| x & 1 == 0)\\n    }\\n}\\n```\\n\\n2. Slow functional one-liner (50 ms)\\n```\\nimpl Solution {\\n    pub fn divide_array(nums: Vec<i32>) -> bool {\\n        nums.iter()\\n            .fold([0; 501], |mut acc, &x| {\\n                acc[x as usize] += 1;\\n                acc\\n            })\\n            .iter()\\n            .filter(|x| **x > 0)\\n            .all(|&x| x & 1 == 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn divide_array(nums: Vec<i32>) -> bool {\\n        let mut counter = [0; 501];\\n        nums.iter().for_each(|&x| counter[x as usize] += 1);\\n        counter.iter().filter(|x| **x > 0).all(|&x| x & 1 == 0)\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn divide_array(nums: Vec<i32>) -> bool {\\n        nums.iter()\\n            .fold([0; 501], |mut acc, &x| {\\n                acc[x as usize] += 1;\\n                acc\\n            })\\n            .iter()\\n            .filter(|x| **x > 0)\\n            .all(|&x| x & 1 == 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864569,
                "title": "c-one-line",
                "content": "```\\n public bool DivideArray(int[] nums) =>  \\n\\t nums.GroupBy(x => x).Select(x => x.Count()).All(x => x % 2 == 0);\\n         \\n\\t\\t \\n               \\n```",
                "solutionTags": [],
                "code": "```\\n public bool DivideArray(int[] nums) =>  \\n\\t nums.GroupBy(x => x).Select(x => x.Count()).All(x => x % 2 == 0);\\n         \\n\\t\\t \\n               \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864306,
                "title": "divide-array-into-equal-pairs-t-c-o-n-s-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) \\n    {\\n        unordered_map<int, int> map; \\n\\t\\t// Store the frequency each number.\\n        for (int i = 0; i < nums.size(); i++)\\n            map[nums[i]]++;\\n\\t\\t// If all frequencies are divisible by 2 return true else false.\\n        for (int i = 0; i < nums.size(); i++)\\n            if (map[nums[i]] % 2 != 0)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) \\n    {\\n        unordered_map<int, int> map; \\n\\t\\t// Store the frequency each number.\\n        for (int i = 0; i < nums.size(); i++)\\n            map[nums[i]]++;\\n\\t\\t// If all frequencies are divisible by 2 return true else false.\\n        for (int i = 0; i < nums.size(); i++)\\n            if (map[nums[i]] % 2 != 0)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864017,
                "title": "python-solution-using-dictionary",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        c = Counter(nums)\\n        for i in c:\\n            if c[i]%2 != 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        c = Counter(nums)\\n        for i in c:\\n            if c[i]%2 != 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355404,
                "title": "c-golang-counting",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int freq[501] = {0};\\n        for(int num: nums) {\\n            freq[num]++;\\n        }\\n        for(int i = 0; i < 501; i++) {\\n            if(freq[i] % 2) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n// Golang\\nfunc divideArray(nums []int) bool {\\n    freq := make([]int, 501)\\n    for _, num := range nums {\\n        freq[num]++\\n    }\\n    for i := 0; i < 501; i++ {\\n        if freq[i] % 2 == 1 {return false}\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Counting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int freq[501] = {0};\\n        for(int num: nums) {\\n            freq[num]++;\\n        }\\n        for(int i = 0; i < 501; i++) {\\n            if(freq[i] % 2) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n// Golang\\nfunc divideArray(nums []int) bool {\\n    freq := make([]int, 501)\\n    for _, num := range nums {\\n        freq[num]++\\n    }\\n    for i := 0; i < 501; i++ {\\n        if freq[i] % 2 == 1 {return false}\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345311,
                "title": "c-solution-with-map",
                "content": "```\\n// Runtime: 19 ms, faster than 40.00% of C++ online submissions for Divide Array Into Equal Pairs.\\n// Memory Usage: 14.8 MB, less than 13.95% of C++ online submissions for Divide Array Into Equal Pairs.\\nbool divideArray(vector<int>& nums) {\\n\\tmap<int, int> mnums;\\n\\tfor (const int& n : nums)\\n\\t\\tmnums[n]++;\\n\\tfor (const auto& it : mnums)\\n\\t\\tif (it.second % 2)\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Runtime: 19 ms, faster than 40.00% of C++ online submissions for Divide Array Into Equal Pairs.\\n// Memory Usage: 14.8 MB, less than 13.95% of C++ online submissions for Divide Array Into Equal Pairs.\\nbool divideArray(vector<int>& nums) {\\n\\tmap<int, int> mnums;\\n\\tfor (const int& n : nums)\\n\\t\\tmnums[n]++;\\n\\tfor (const auto& it : mnums)\\n\\t\\tif (it.second % 2)\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286815,
                "title": "divide-array-into-equal-pairs-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int i, n;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            n = count(nums.begin(), nums.end(), nums[i]);\\n            if(n%2!=0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int i, n;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            n = count(nums.begin(), nums.end(), nums[i]);\\n            if(n%2!=0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168519,
                "title": "simple-approach-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pair=n/2;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.second%2!=0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pair=n/2;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.second%2!=0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146010,
                "title": "divide-array-into-equal-pairs",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        if len(nums)%2!=0:\\n            return False\\n        else:\\n            for i in nums:\\n                if nums.count(i)%2!=0:\\n                    return False\\n            else:\\n                return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        if len(nums)%2!=0:\\n            return False\\n        else:\\n            for i in nums:\\n                if nums.count(i)%2!=0:\\n                    return False\\n            else:\\n                return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102577,
                "title": "best-solution-ever-only-using-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n- o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int xor =0;\\n        int yor =0;\\n        for(int x : nums){\\n            xor = xor ^ x;\\n            yor = yor ^ (x+1);\\n        }\\n        \\n        return (xor == 0 && yor ==0) ? true : false;\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int xor =0;\\n        int yor =0;\\n        for(int x : nums){\\n            xor = xor ^ x;\\n            yor = yor ^ (x+1);\\n        }\\n        \\n        return (xor == 0 && yor ==0) ? true : false;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060968,
                "title": "java-bit-manipulation",
                "content": "# Intuition\\nThis is usually done using by creating an array and counting each occurence. This consumes a lot of space\\n\\n# Approach\\n\\nInstead follow this xor method to count whether number of occurences of a number is odd or even\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int num = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int ref = 1 << nums[i];\\n            num = num^ref;\\n        }\\n        if(num == 0)return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int num = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int ref = 1 << nums[i];\\n            num = num^ref;\\n        }\\n        if(num == 0)return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038676,
                "title": "easy-pizy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n =nums.size();\\n        if(n%2 !=0){\\n            return false;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i=i+2){\\n            if(nums[i-1] != nums[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n =nums.size();\\n        if(n%2 !=0){\\n            return false;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i=i+2){\\n            if(nums[i-1] != nums[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910371,
                "title": "two-solutions-in-kotlin",
                "content": "Approach 1: Using array\\n```\\nclass Solution {\\n    fun divideArray(nums: IntArray): Boolean {\\n        var arr = IntArray(501)\\n\\n        for (num in nums) {\\n            arr[num]++\\n        }\\n\\n        for (num in arr) {\\n            if (num != 0 && num % 2 != 0) return false\\n        }\\n\\n        return true\\n    }\\n}\\n```\\n\\nApproach 2: Using hashset\\n```\\nclass Solution {\\n    fun divideArray(nums: IntArray): Boolean {\\n        var hash = HashSet<Int>()\\n\\n        for (num in nums) {\\n            if (!hash.add(num)) hash.remove(num) \\n        }\\n\\n        return hash.isEmpty()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun divideArray(nums: IntArray): Boolean {\\n        var arr = IntArray(501)\\n\\n        for (num in nums) {\\n            arr[num]++\\n        }\\n\\n        for (num in arr) {\\n            if (num != 0 && num % 2 != 0) return false\\n        }\\n\\n        return true\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun divideArray(nums: IntArray): Boolean {\\n        var hash = HashSet<Int>()\\n\\n        for (num in nums) {\\n            if (!hash.add(num)) hash.remove(num) \\n        }\\n\\n        return hash.isEmpty()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901416,
                "title": "simple-java-solution-with-o-n-complexity-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n      int[]freq = new int[501];\\n      for(int i = 0; i<nums.length;i++){\\n          freq[nums[i]]++;\\n      }\\n      for(int i = 0; i<freq.length;i++){\\n          if(freq[i]%2 == 1)\\n          return false;\\n      }\\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n      int[]freq = new int[501];\\n      for(int i = 0; i<nums.length;i++){\\n          freq[nums[i]]++;\\n      }\\n      for(int i = 0; i<freq.length;i++){\\n          if(freq[i]%2 == 1)\\n          return false;\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871644,
                "title": "c-easy-solution-2-approaches",
                "content": "**Approach-1**\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        for(int i:nums){\\n            mp[i]++;\\n        }\\n        for(auto &it:mp){\\n            if(it.second%2==1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**Approach-2**\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i]!=nums[i+1]){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n***Please visit my Profile***",
                "solutionTags": [
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        for(int i:nums){\\n            mp[i]++;\\n        }\\n        for(auto &it:mp){\\n            if(it.second%2==1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i]!=nums[i+1]){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802236,
                "title": "python-5-lines-of-code-zip-odd-and-even-indexed-numbers",
                "content": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        for (a,b) in zip(nums[::2], nums[1::2]):\\n            if a!=b:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        for (a,b) in zip(nums[::2], nums[1::2]):\\n            if a!=b:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702868,
                "title": "java-beginner-friendly-solution-easy-to-understand",
                "content": "Upvote if you like the solution.\\n```\\npublic boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 0; i<nums.length; i+=2){\\n            if(nums[i] != nums[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 0; i<nums.length; i+=2){\\n            if(nums[i] != nums[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643576,
                "title": "easy",
                "content": "```\\nbool divideArray(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool divideArray(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2639884,
                "title": "easy-c-2-approaches",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n\\t\\n\\t//method1\\n\\t\\n         sort(nums.begin(),nums.end());\\n       \\n       for(int i=0; i<nums.size()-1; i=i+2){\\n            if(nums[i]!=nums[i+1]){\\n               return false;\\n        }\\n      }\\n       \\n        return true;\\n        \\n\\t\\t// method 2\\n        map<int,int> mpp;\\n        for(int i=0; i<nums.size() ; i++){\\n            mpp[nums[i]]++;\\n        }\\n        for(auto it: mpp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n\\t\\n\\t//method1\\n\\t\\n         sort(nums.begin(),nums.end());\\n       \\n       for(int i=0; i<nums.size()-1; i=i+2){\\n            if(nums[i]!=nums[i+1]){\\n               return false;\\n        }\\n      }\\n       \\n        return true;\\n        \\n\\t\\t// method 2\\n        map<int,int> mpp;\\n        for(int i=0; i<nums.size() ; i++){\\n            mpp[nums[i]]++;\\n        }\\n        for(auto it: mpp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601377,
                "title": "javascript-solution-easy-to-understand",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function(nums) {\\n    nums.sort((a, b)=>a-b);\\n    let len = nums.length/2;\\n    let res = 0;\\n    for(let i=0; i<nums.length-1; i++) {\\n        if(nums[i] === nums[i+1]) {\\n            res++;\\n            i++;\\n        }\\n    }\\n    return res === len;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function(nums) {\\n    nums.sort((a, b)=>a-b);\\n    let len = nums.length/2;\\n    let res = 0;\\n    for(let i=0; i<nums.length-1; i++) {\\n        if(nums[i] === nums[i+1]) {\\n            res++;\\n            i++;\\n        }\\n    }\\n    return res === len;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2578250,
                "title": "quick-map-java",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int[] map = new int[501];\\n        for (int i: nums) map[i]++;\\n        for (int i: map)\\n            if (i % 2 == 1) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int[] map = new int[501];\\n        for (int i: nums) map[i]++;\\n        for (int i: map)\\n            if (i % 2 == 1) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547131,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n     \\n\\t if(nums.size()%2==0){\\n             sort(nums.begin(),nums.end());\\n            for(int i=0;i<nums.size()-1;i++){\\n                   if(nums[i]!=nums[i+1]){\\n                              return false;\\n                    }\\n                i++;\\n            }\\n            return true;\\n        }\\n        \\n     return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n     \\n\\t if(nums.size()%2==0){\\n             sort(nums.begin(),nums.end());\\n            for(int i=0;i<nums.size()-1;i++){\\n                   if(nums[i]!=nums[i+1]){\\n                              return false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2540664,
                "title": "bitset-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        bitset<501> bs;\\n        for(auto num : nums) bs.flip(num);\\n        for(int i=0;i<501;i++) if(bs[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        bitset<501> bs;\\n        for(auto num : nums) bs.flip(num);\\n        for(int i=0;i<501;i++) if(bs[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531446,
                "title": "c-hashmap-no-sorting-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto i : mp)\\n        {\\n            if(i.second % 2 != 0)\\n                return false;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto i : mp)\\n        {\\n            if(i.second % 2 != 0)\\n                return false;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524587,
                "title": "begineer-friendly-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i+=2){\\n            if(nums[i] != nums[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nUpVote  :-)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i+=2){\\n            if(nums[i] != nums[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501851,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n        List<Integer> lst = new ArrayList<>();\\n        for(Map.Entry<Integer,Integer> i : map.entrySet()){\\n            lst.add(i.getValue());\\n        }\\n        for(int i =0;i<map.size();i++){\\n            if(lst.get(i)%2!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n        List<Integer> lst = new ArrayList<>();\\n        for(Map.Entry<Integer,Integer> i : map.entrySet()){\\n            lst.add(i.getValue());\\n        }\\n        for(int i =0;i<map.size();i++){\\n            if(lst.get(i)%2!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461786,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] arr) {\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            if (arr[i] == -1) continue;\\n            boolean b = false;\\n            for (int j = i+1; j < arr.length; j++) {\\n                if (arr[j] == -1) continue;\\n                if (arr[i] == arr[j]) {\\n                    arr[i] = -1;\\n                    arr[j] = -1;\\n                    b = true;\\n                    break;\\n                }\\n            }\\n            if (!b) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] arr) {\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            if (arr[i] == -1) continue;\\n            boolean b = false;\\n            for (int j = i+1; j < arr.length; j++) {\\n                if (arr[j] == -1) continue;\\n                if (arr[i] == arr[j]) {\\n                    arr[i] = -1;\\n                    arr[j] = -1;\\n                    b = true;\\n                    break;\\n                }\\n            }\\n            if (!b) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445571,
                "title": "c-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int m[501];\\n        for(int i=0;i<501;i++)\\n            m[i]=0;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        for(int i=0;i<501;i++){\\n            if(m[i]%2!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int m[501];\\n        for(int i=0;i<501;i++)\\n            m[i]=0;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        for(int i=0;i<501;i++){\\n            if(m[i]%2!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434526,
                "title": "cpp-easy-and-fast-o-n-solution-using-hashmap-without-sorting",
                "content": "```\\n  bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(int i=0;i<nums.size();i++){\\n            map[nums[i]]++;\\n        }\\n        for(auto i = map.begin();i!=map.end();i++){\\n            if(i->second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(int i=0;i<nums.size();i++){\\n            map[nums[i]]++;\\n        }\\n        for(auto i = map.begin();i!=map.end();i++){\\n            if(i->second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2434455,
                "title": "python-easy-solution-beats-99-05",
                "content": "Simple python solution \\nTime Complexity : O(n)\\nUsed hash map and check if frequency is even or not\\n```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        re=dict()\\n        for x in nums:\\n            if re.get(x)!=None:\\n                re[x]+=1\\n            else:\\n                re[x]=1\\n        for i in re:\\n            if re[i]%2!=0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        re=dict()\\n        for x in nums:\\n            if re.get(x)!=None:\\n                re[x]+=1\\n            else:\\n                re[x]=1\\n        for i in re:\\n            if re[i]%2!=0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430240,
                "title": "c-solution-very-easy-using-for-loop-simple-code-using-for-loop",
                "content": "**Easiest CPP Solution Using For LOOP**\\n\\n### class Solution {\\n### public:\\n###     bool divideArray(vector & nums) {\\n###            int n =nums.size();\\n###         sort(nums.begin(), nums.end());\\n###         for(int i=0;i<n;i=i+2)\\n###         {\\n###             if(nums[i] != nums[i+1])\\n###                 return false;\\n###         }\\n###         return true;\\n###     }\\n### };",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\n### public:\\n###     bool divideArray(vector & nums) {\\n###            int n =nums.size();\\n###         sort(nums.begin(), nums.end());\\n###         for(int i=0;i<n;i=i+2)\\n###         {\\n###             if(nums[i] != nums[i+1])\\n###                 return false;\\n###         }",
                "codeTag": "Java"
            },
            {
                "id": 2406631,
                "title": "python",
                "content": "\\tnums.sort()\\n\\n\\tfor i in range(0, len(nums), 2):\\n\\t\\tif nums[i] != nums[i+1]:\\n\\t\\t\\treturn False\\n\\n\\treturn True",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tnums.sort()\\n\\n\\tfor i in range(0, len(nums), 2):\\n\\t\\tif nums[i] != nums[i+1]:\\n\\t\\t\\treturn False\\n\\n\\treturn True",
                "codeTag": "Unknown"
            },
            {
                "id": 2398968,
                "title": "simple-java-solution-o-1-space-faster-than-96-of-all-java-submissions",
                "content": "**Upvote if you like the solution**\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        // Time Complexity - O(n)\\n        // Space Complexity - O(1) = constant time\\n        int n[] = new int[501];\\n        \\n        for(int i=0;i<nums.length;i++)\\n            n[nums[i]]++;\\n        \\n        for(int i=0;i<n.length;i++)\\n            if(n[i]!=0 && (n[i]&1)!=0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        // Time Complexity - O(n)\\n        // Space Complexity - O(1) = constant time\\n        int n[] = new int[501];\\n        \\n        for(int i=0;i<nums.length;i++)\\n            n[nums[i]]++;\\n        \\n        for(int i=0;i<n.length;i++)\\n            if(n[i]!=0 && (n[i]&1)!=0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396291,
                "title": "2206-c-o-n-solution",
                "content": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        \\n        unordered_map<int,int> m;\\n        \\n        for(auto x: nums){\\n            m[x]++;\\n        }\\n       \\n        \\n        int n = nums.size()/2;\\n        \\n        for(auto it : m){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        \\n        \\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        \\n        unordered_map<int,int> m;\\n        \\n        for(auto x: nums){\\n            m[x]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2383219,
                "title": "easy-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(int i:nums){\\n            hmap.put(i,hmap.getOrDefault(i,0)+1);\\n        }\\n        int pair = nums.length/2,count=0;\\n        for(int key:hmap.keySet()){\\n            count+=(hmap.get(key)/2);\\n        }\\n        return count==pair;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean divideArray(int[] nums) {\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(int i:nums){\\n            hmap.put(i,hmap.getOrDefault(i,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2348675,
                "title": "javascript",
                "content": "```\\nvar divideArray = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    for (let i = 0; i < nums.length-1; i += 2) {\\n        if (nums[i] !== nums[i+1]) return false\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar divideArray = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    for (let i = 0; i < nums.length-1; i += 2) {\\n        if (nums[i] !== nums[i+1]) return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2332751,
                "title": "python3-o-n-o-n-runtime-148ms-42-39-memory-14mb-17-26",
                "content": "```\\nfrom collections import Counter as c\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 148ms 42.39% || Memory: 14mb 17.26%\\n    def divideArray(self, array: List[int]) -> bool:\\n        if not array:\\n            return False\\n\\n        arrFreq = c(array)\\n        numOfPartiation = len(array) // 2\\n        for key in arrFreq:\\n            freqOfCurrKey = arrFreq[key]\\n            numOfPartiation -= freqOfCurrKey // 2\\n\\n        return numOfPartiation == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter as c\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 148ms 42.39% || Memory: 14mb 17.26%\\n    def divideArray(self, array: List[int]) -> bool:\\n        if not array:\\n            return False\\n\\n        arrFreq = c(array)\\n        numOfPartiation = len(array) // 2\\n        for key in arrFreq:\\n            freqOfCurrKey = arrFreq[key]\\n            numOfPartiation -= freqOfCurrKey // 2\\n\\n        return numOfPartiation == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309385,
                "title": "java-only-for-loop-and-arrays-sort",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n      \\n      Arrays.sort(nums);\\n      for(int i=0;i<nums.length;i+=2)\\n      {\\n         if(nums[i]!=nums[i+1])\\n             return false;\\n      }\\n      return true;\\n       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n      \\n      Arrays.sort(nums);\\n      for(int i=0;i<nums.length;i+=2)\\n      {\\n         if(nums[i]!=nums[i+1])\\n             return false;\\n      }\\n      return true;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277100,
                "title": "2206-divide-array-into-equal-pairs",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool divideArray(vector<int>& nums) {\\n\\t\\t   unordered_map<int,int>ump;\\n\\t\\t\\tfor(auto itr:nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tump[itr]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto itr:ump)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(itr.second%2!=0)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool divideArray(vector<int>& nums) {\\n\\t\\t   unordered_map<int,int>ump;\\n\\t\\t\\tfor(auto itr:nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tump[itr]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2272962,
                "title": "java-solution",
                "content": "```\\npublic boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=1;\\n        while(i<nums.length){\\n            if(nums[i] != nums[i-1]){\\n                return false;\\n            }\\n            i+=2;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=1;\\n        while(i<nums.length){\\n            if(nums[i] != nums[i-1]){\\n                return false;\\n            }\\n            i+=2;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228528,
                "title": "python-solution-elegant-using-counter-dict",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        \\n        if len(nums) % 2 != 0:\\n            return False\\n        \\n        c = Counter(nums)\\n        if all(x % 2 == 0 for x in c.values()) == False:\\n            return False\\n        \\n        return True",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        \\n        if len(nums) % 2 != 0:\\n            return False\\n        \\n        c = Counter(nums)\\n        if all(x % 2 == 0 for x in c.values()) == False:\\n            return False\\n        \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2212988,
                "title": "c-easy-map-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(auto i:nums){\\n            m[i]++;\\n        }\\n        for(auto i:nums){\\n            if(m[i]%2!=0) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(auto i:nums){\\n            m[i]++;\\n        }\\n        for(auto i:nums){\\n            if(m[i]%2!=0) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188572,
                "title": "any-chance-i-misunderstood-the-question-this-passed-all-test-cases",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i =0; i<nums.length; i+= 2){\\n            if(nums[i] != nums[i+1])\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i =0; i<nums.length; i+= 2){\\n            if(nums[i] != nums[i+1])\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2155232,
                "title": "simple-implementation-o-n-time-o-n-space-using-hashmap-with-explanation",
                "content": "we will simply store the frequency of element of array in map  and we know that to be a pair frequency should be divisible by 2 so we store the count of pair and at the end we will check if count==n/2 or not if it is equal we will return true else false.\\n```\\nbool divideArray(vector<int>& nums) {\\n        \\n        int n =nums.size();\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        int count=0;\\n        for(auto x:mp)\\n        {\\n            if(x.second%2==0)\\n                count+=x.second/2;\\n                \\n        }\\n        if(count==n/2)\\n            return true;\\n        return false;\\n        \\n        \\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool divideArray(vector<int>& nums) {\\n        \\n        int n =nums.size();\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        int count=0;\\n        for(auto x:mp)\\n        {\\n            if(x.second%2==0)\\n                count+=x.second/2;\\n                \\n        }\\n        if(count==n/2)\\n            return true;\\n        return false;\\n        \\n        \\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2076930,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        if len(nums)%2 !=0: return False\\n        nums.sort()\\n        i=0\\n        while i< len(nums):\\n            if nums[i] == nums[i + 1]:\\n                i += 2\\n            else:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        if len(nums)%2 !=0: return False\\n        nums.sort()\\n        i=0\\n        while i< len(nums):\\n            if nums[i] == nums[i + 1]:\\n                i += 2\\n            else:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072603,
                "title": "python-easy-1-liner-using-set-operation",
                "content": "The approach is quite straightforward. When you hit the first element of the pair, add it to set. Then discard it from the set when you hit second element of a pair. If this set is empty after visiting all elements in input array, then we met all the conditions specified by the problem.\\n\\nThe set operation with `^` in python can be denoted as : \\n``` \\nA = A ^ B = (A u B) - (A n B)\\n```\\n\\n```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:      \\n        return not reduce(lambda x,elem: x ^ {elem}, nums, set())\\n```\\n\\n\\nThe above implementation can be made more readable as follows:\\n\\n```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        not_a_pair = set()\\n        \\n        for x in nums:\\n            if x not in not_a_pair:\\n                not_a_pair.add(x)\\n            else:\\n                not_a_pair.remove(x)\\n        return not not_a_pair\\n```\\n\\n**Time - O(n)\\nSpace - O(n)**\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nA = A ^ B = (A u B) - (A n B)\\n```\n```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:      \\n        return not reduce(lambda x,elem: x ^ {elem}, nums, set())\\n```\n```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        not_a_pair = set()\\n        \\n        for x in nums:\\n            if x not in not_a_pair:\\n                not_a_pair.add(x)\\n            else:\\n                not_a_pair.remove(x)\\n        return not not_a_pair\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064657,
                "title": "python-using-set",
                "content": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        theset = set()\\n        n = len( nums)\\n        \\n        for i in range (n):\\n            if nums[i] not in theset:\\n                theset.add( nums[i])\\n            else:\\n                theset.remove( nums[i])\\n        \\n        if len( theset) == 0:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        theset = set()\\n        n = len( nums)\\n        \\n        for i in range (n):\\n            if nums[i] not in theset:\\n                theset.add( nums[i])\\n            else:\\n                theset.remove( nums[i])\\n        \\n        if len( theset) == 0:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058073,
                "title": "javascript-one-liner-beats-99",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nconst divideArray = (nums) => Object.values(nums.reduce((c, a) => (c[a] = (c[a] ?? 0) + 1, c), {})).every(val => val % 2 === 0);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nconst divideArray = (nums) => Object.values(nums.reduce((c, a) => (c[a] = (c[a] ?? 0) + 1, c), {})).every(val => val % 2 === 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1987220,
                "title": "c-o-n-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& v) {\\n        int arr[505] = {0};\\n        for(int i=0; i<v.size(); i++)\\n        arr[v[i]]++;\\n\\t\\tfor(int i=1; i<=501; i++){\\n\\t\\t\\tif(arr[i]>0){\\n\\t\\t\\t\\tif(arr[i]&1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& v) {\\n        int arr[505] = {0};\\n        for(int i=0; i<v.size(); i++)\\n        arr[v[i]]++;\\n\\t\\tfor(int i=1; i<=501; i++){\\n\\t\\t\\tif(arr[i]>0){\\n\\t\\t\\t\\tif(arr[i]&1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981989,
                "title": "divide-array-into-equal-pairs",
                "content": "public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i+=2){\\n            int pair=nums[i]^nums[i+1];\\n            if(pair!=0)\\n                return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i+=2){\\n            int pair=nums[i]^nums[i+1];\\n            if(pair!=0)\\n                return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1979276,
                "title": "4-line-of-code-cpp",
                "content": "```\\nbool divideArray(vector<int>& nums) {\\n        map<int,int>map;\\n        for(auto i:nums)map[i]++;\\n        for(auto i:map)if(i.second&1)return false;\\n        return true;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool divideArray(vector<int>& nums) {\\n        map<int,int>map;\\n        for(auto i:nums)map[i]++;\\n        for(auto i:map)if(i.second&1)return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1951092,
                "title": "runtime-70-ms-faster-than-90-29-of-javascript-online-submissions",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function(nums) {\\n    const hashMap = {};\\n    \\n    for (let index = 0; index < nums.length; index++) {\\n        const item = nums[index];\\n        const value = hashMap[item] ?? 0;\\n        \\n        hashMap[item] = value + 1;\\n    }\\n    \\n    for (let key in hashMap) {\\n        const value = hashMap[key];\\n\\n        if (value % 2 !== 0) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```\\n\\nRuntime: 70 ms, faster than 90.29% of JavaScript online submissions for Divide Array Into Equal Pairs.\\nMemory Usage: 44.6 MB, less than 57.33% of JavaScript online submissions for Divide Array Into Equal Pairs.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function(nums) {\\n    const hashMap = {};\\n    \\n    for (let index = 0; index < nums.length; index++) {\\n        const item = nums[index];\\n        const value = hashMap[item] ?? 0;\\n        \\n        hashMap[item] = value + 1;\\n    }\\n    \\n    for (let key in hashMap) {\\n        const value = hashMap[key];\\n\\n        if (value % 2 !== 0) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941671,
                "title": "easy-and-simple-solution-1-ms-faster-than-99-98-java-submissions",
                "content": "****Please upvote if you like this solution****\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int n = nums.length;\\n        int[] count = new int[501];\\n\\n        if (n % 2 != 0) {\\n            return false;\\n        }\\n\\n        // counting occurrence\\n        for (int num : nums) {\\n            count[num]++;\\n        }\\n\\n        for (int i : count) {\\n            if (i % 2 != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int n = nums.length;\\n        int[] count = new int[501];\\n\\n        if (n % 2 != 0) {\\n            return false;\\n        }\\n\\n        // counting occurrence\\n        for (int num : nums) {\\n            count[num]++;\\n        }\\n\\n        for (int i : count) {\\n            if (i % 2 != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920427,
                "title": "python3-easy-solution-99-faster",
                "content": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n\\n        tar = len(nums) // 2\\n        hash_map = {}\\n\\n        for num in nums:\\n            hash_map[num] = hash_map.get(num, 0) + 1\\n        \\n        for x, y in hash_map.items():\\n            tar -= y // 2\\n\\n        return tar == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n\\n        tar = len(nums) // 2\\n        hash_map = {}\\n\\n        for num in nums:\\n            hash_map[num] = hash_map.get(num, 0) + 1\\n        \\n        for x, y in hash_map.items():\\n            tar -= y // 2\\n\\n        return tar == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901352,
                "title": "python-o-n-o-n",
                "content": "```python\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        counts = [0] * (max(nums) + 1)\\n        for num in nums:\\n            counts[num] += 1\\n        for count in counts:\\n            if count & 1:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        counts = [0] * (max(nums) + 1)\\n        for num in nums:\\n            counts[num] += 1\\n        for count in counts:\\n            if count & 1:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899472,
                "title": "c-easy-solution-using-map",
                "content": "```\\nbool divideArray(vector<int>& nums) {\\n       map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]++;\\n        for(auto it:m){\\n            if(it.second%2!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool divideArray(vector<int>& nums) {\\n       map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]++;\\n        for(auto it:m){\\n            if(it.second%2!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1883338,
                "title": "hashmaps-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        int count = nums.size();\\n        for(int i =0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n    \\n        for(auto i:m){\\n            if(i.second%2==0){\\n                count-=i.second;\\n            }\\n        }\\n        return count==0;\\n    }\\n};\\n \\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        int count = nums.size();\\n        for(int i =0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1879866,
                "title": "python3-one-liner",
                "content": "```\\ndef divideArray(self, nums: List[int]) -> bool:\\n\\treturn sorted(nums)[::2] == sorted(nums)[1::2]\\n```",
                "solutionTags": [],
                "code": "```\\ndef divideArray(self, nums: List[int]) -> bool:\\n\\treturn sorted(nums)[::2] == sorted(nums)[1::2]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1879336,
                "title": "beginner-friendly-javascript-solution",
                "content": "**Time Complexity : O(n)**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function(nums) {\\n    var set = new Set()\\n    for(let num of nums){\\n        if(set.has(num))    set.delete(num)\\n        else    set.add(num)\\n    }\\n    return set.size == 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar divideArray = function(nums) {\\n    var set = new Set()\\n    for(let num of nums){\\n        if(set.has(num))    set.delete(num)\\n        else    set.add(num)\\n    }\\n    return set.size == 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1879325,
                "title": "beginner-friendly-java-solution",
                "content": "**Time Complexity : O(n)**\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num : nums){\\n            if(set.contains(num))   set.remove(num);\\n            else    set.add(num);\\n        }\\n        return set.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num : nums){\\n            if(set.contains(num))   set.remove(num);\\n            else    set.add(num);\\n        }\\n        return set.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872310,
                "title": "cpp-solution-easy-to-understand-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>check;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            check[nums[i]]++;\\n        } // Mapping all the elements.\\n        for(auto p : check){\\n            if(p.second%2!=0) /* If the frequency of the elements is even then they can be clubbed together*/\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\\n**Please upvote :)**\\n##### Thank You!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>check;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            check[nums[i]]++;\\n        } // Mapping all the elements.\\n        for(auto p : check){\\n            if(p.second%2!=0) /* If the frequency of the elements is even then they can be clubbed together*/\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867963,
                "title": "java-javascript-simple-o-n-hashset",
                "content": "If the count of element is odd then the answer is false because we can\\'t make a pair with odd counts . if the count of each element is even then the answer is true.\\nInstead of maintaing count i am using a HashSet for add for 1st pair and then remove if the 1st pair found.\\n\\n### Java\\n```java\\npublic boolean divideArray(int[] nums) {\\n        HashSet<Integer> set=new HashSet(); \\n    \\n        for(int n: nums) {\\n            if(set.contains(n)) {\\n                set.remove(n);\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n\\n        return set.size() == 0;\\n    }\\n```\\n\\n### Javascript\\n```js\\nvar divideArray = function(nums) {\\n    let set = new Set();\\n    \\n    for(let n of nums) {\\n        if(set.has(n)) {\\n            set.delete(n);\\n        } else {\\n            set.add(n);\\n        }\\n    }\\n    \\n    return set.size === 0;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```java\\npublic boolean divideArray(int[] nums) {\\n        HashSet<Integer> set=new HashSet(); \\n    \\n        for(int n: nums) {\\n            if(set.contains(n)) {\\n                set.remove(n);\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n\\n        return set.size() == 0;\\n    }\\n```\n```js\\nvar divideArray = function(nums) {\\n    let set = new Set();\\n    \\n    for(let n of nums) {\\n        if(set.has(n)) {\\n            set.delete(n);\\n        } else {\\n            set.add(n);\\n        }\\n    }\\n    \\n    return set.size === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865507,
                "title": "simple-o-n-solution-using-hashmap-c",
                "content": "\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool divideArray(vector<int>& nums) {\\n\\t\\t\\t\\tint n=nums.size();\\n\\t\\t\\t\\tunordered_map<int,int> mp1;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\tmp1[nums[i]]++;\\n        \\n\\t\\t\\t\\tfor(auto x:mp1)\\n\\t\\t\\t\\t\\tif(x.second%2!=0)\\n\\t\\t\\t\\t\\t   return false;\\n\\t     return true;\\n       }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool divideArray(vector<int>& nums) {\\n\\t\\t\\t\\tint n=nums.size();\\n\\t\\t\\t\\tunordered_map<int,int> mp1;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\tmp1[nums[i]]++;\\n        \\n\\t\\t\\t\\tfor(auto x:mp1)\\n\\t\\t\\t\\t\\tif(x.second%2!=0)\\n\\t\\t\\t\\t\\t   return false;\\n\\t     return true;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1865402,
                "title": "easy-c-solution-beginners-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        if(nums.size()%2!=0)\\n            return false;\\n        sort(nums.begin(),nums.end());\\n         for(int i=1;i<nums.size();i=i+2)\\n        {            if(nums[i]!=nums[i-1])return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Like it? Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        if(nums.size()%2!=0)\\n            return false;\\n        sort(nums.begin(),nums.end());\\n         for(int i=1;i<nums.size();i=i+2)\\n        {            if(nums[i]!=nums[i-1])return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864986,
                "title": "memory-usage-beats-100-simple-and-short-python3-solution",
                "content": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        for i in range(0,len(nums),2):\\n            if nums[i] != nums[i+1]:\\n                return False\\n        return True\\n```\\n\\nRuntime - 127ms\\nMemory Usage - 13.9mb\\n\\nFor solutions to other LeetCode problems that I have solved, you can check my github repository :\\nhttps://github.com/harshitpoddar09/LeetCode-Solutions\\n\\nPlease upvote if you found this useful so that others can get help as well!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        for i in range(0,len(nums),2):\\n            if nums[i] != nums[i+1]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864877,
                "title": "java-solution-4ms-100-faster-using-sorting",
                "content": "```\\n int n = nums.length;\\n        int pairs = n/2;\\n        Arrays.sort(nums);\\n        int count =0;\\n            \\n            for(int i=1;i<n;i+=2)\\n            {\\n                    if(nums[i]==nums[i-1])\\n                    {\\n                            count++;\\n                    }\\n            }\\n            if(count==pairs)\\n            {\\n                    return true;\\n            }\\n            return false;\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n int n = nums.length;\\n        int pairs = n/2;\\n        Arrays.sort(nums);\\n        int count =0;\\n            \\n            for(int i=1;i<n;i+=2)\\n            {\\n                    if(nums[i]==nums[i-1])\\n                    {\\n                            count++;\\n                    }\\n            }\\n            if(count==pairs)\\n            {\\n                    return true;\\n            }\\n            return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864875,
                "title": "java-sort",
                "content": "```\\npublic boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i = i + 2) {\\n            if (nums[i] != nums[i + 1]) return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i = i + 2) {\\n            if (nums[i] != nums[i + 1]) return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1864325,
                "title": "python-one-linear-optimized-solution-o-n",
                "content": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        d = {}\\n        for i in nums:\\n            if i not in d:\\n                d[i] = 1\\n            else:\\n                d[i]+=1\\n        for j in d.values():\\n            if j%2!=0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        d = {}\\n        for i in nums:\\n            if i not in d:\\n                d[i] = 1\\n            else:\\n                d[i]+=1\\n        for j in d.values():\\n            if j%2!=0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864252,
                "title": "c-few-lines-of-code-neat-and-clean-19-march-contest-solution",
                "content": "#****upvote if helps \\n\\n\\tsort(nums.begin(), nums.end());\\n        bool chk  = false;\\n        if(nums.size() %2 != 0)  return false;\\n        for(int i=0;i<nums.size() ; i +=2) {\\n            if(nums[i] == nums[i+1])  chk = true; \\n            else return false;\\n        }\\n        return chk;\\n\\t\\t\\n\\t\\t\\n#**** this is the brute force approch to solve this if you  any other approch you can comment below ;",
                "solutionTags": [
                    "C"
                ],
                "code": "#****upvote if helps \\n\\n\\tsort(nums.begin(), nums.end());\\n        bool chk  = false;\\n        if(nums.size() %2 != 0)  return false;\\n        for(int i=0;i<nums.size() ; i +=2) {\\n            if(nums[i] == nums[i+1])  chk = true; \\n            else return false;\\n        }\\n        return chk;\\n\\t\\t\\n\\t\\t\\n#**** this is the brute force approch to solve this if you  any other approch you can comment below ;",
                "codeTag": "Unknown"
            },
            {
                "id": 1864198,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) \\n    {\\n        unordered_map<int,int>mp;\\n        for(auto &it:nums)\\n        {\\n            mp[it]++;\\n        }\\n        for(auto &it:mp)\\n        {\\n            if(it.second%2)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) \\n    {\\n        unordered_map<int,int>mp;\\n        for(auto &it:nums)\\n        {\\n            mp[it]++;\\n        }\\n        for(auto &it:mp)\\n        {\\n            if(it.second%2)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864142,
                "title": "java-c-o-n-hash-set-easy-step-by-step-dry-run",
                "content": "\\n\\tIf you like it, do UpVote :)\\n\\nInstead of brute-force, we can use HashSet as additional space to optimize our solution.\\n## Complexity: \\n\\tTime: O(n),\\n\\tSpace: O(n)  (in worst case, when all elements are unique)\\n\\n## Dry-Run\\n\\n\\t\\n\\t[3,  2,  3,  2,  2,  2]\\n\\n\\t ----------------\\n\\t| num  | HashSet |  \\n\\t| ---------------|\\n\\t|  3  | {3}      |   // added 3\\n\\t|  2  | {3,2}    |   // added 3\\n\\t|  3  | {2}      |   // 3 already in hashSet. So, removed 3\\n\\t|  2  | {}       |   // 2 already in hashSet. So, removed 2 \\n\\t|  2  | {2}      |   // added 2\\n\\t|  2  | {}       |   // 2 already in hashSet. So, removed 2\\n\\t ----------------\\n\\tIn the end, if HashSet is empty, return true\\n\\t\\t\\t    Else, return false\\n## Code (Java)\\n\\t\\tpublic boolean divideArray(int[] nums) {\\n\\t\\t\\tif(nums.length % 2 != 0){ return false; }               // if nums length is odd, we can not even make pairs from array of odd length\\n\\t\\t\\tSet<Integer> hs = new HashSet<>();                      // create hash set\\n\\t\\t\\tfor(int num : nums){                                    \\n\\t\\t\\t\\tif(! hs.contains(num)){ hs.add(num); }              // add to hash set, when num is not there\\n\\t\\t\\t\\telse{ hs.remove(num); }                             // remove from hash set, when num is there\\n\\t\\t\\t}\\n\\t\\t\\tif(hs.size() > 0){ return false; }                      // in the end, we should have all \\'num\\' removed. If not, then return false \\n\\t\\t\\treturn true;\\n\\t\\t}\\n//\\n//\\n//\\n## Code (C++)\\n    bool divideArray(vector<int>& nums) {\\n        if(nums.size() % 2 != 0){ return false; }               // if nums length is odd, we can not even make pairs from array of odd length\\n\\t\\tunordered_set <int> hs;                                 // create hash set\\n\\t\\tfor(int num : nums){   \\n\\t\\t\\tif(hs.find(num) == hs.end()){ hs.insert(num); }              // add to hash set, when num is not there\\n\\t\\t\\telse{ hs.erase(num); }                             // remove from hash set, when num is there\\n\\t\\t}\\n\\t\\tif(hs.size() > 0){ return false; }                      // in the end, we should have all \\'num\\' removed. If not, then return false \\n\\t\\treturn true;\\n    }\\n//\\n//\\nIf you like it, pls **UpVote** :)\\nIf you need more explanation or, got more optimized way, **comment** below.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "\\n\\tIf you like it, do UpVote :)\\n\\nInstead of brute-force, we can use HashSet as additional space to optimize our solution.\\n## Complexity: \\n\\tTime: O(n),\\n\\tSpace: O(n)  (in worst case, when all elements are unique)\\n\\n## Dry-Run\\n\\n\\t\\n\\t[3,  2,  3,  2,  2,  2]\\n\\n\\t ----------------\\n\\t| num  | HashSet |  \\n\\t| ---------------|\\n\\t|  3  | {3}      |   // added 3\\n\\t|  2  | {3,2}    |   // added 3\\n\\t|  3  | {2}      |   // 3 already in hashSet. So, removed 3\\n\\t|  2  | {}       |   // 2 already in hashSet. So, removed 2 \\n\\t|  2  | {2}      |   // added 2\\n\\t|  2  | {}       |   // 2 already in hashSet. So, removed 2\\n\\t ----------------\\n\\tIn the end, if HashSet is empty, return true\\n\\t\\t\\t    Else, return false\\n## Code (Java)\\n\\t\\tpublic boolean divideArray(int[] nums) {\\n\\t\\t\\tif(nums.length % 2 != 0){ return false; }               // if nums length is odd, we can not even make pairs from array of odd length\\n\\t\\t\\tSet<Integer> hs = new HashSet<>();                      // create hash set\\n\\t\\t\\tfor(int num : nums){                                    \\n\\t\\t\\t\\tif(! hs.contains(num)){ hs.add(num); }              // add to hash set, when num is not there\\n\\t\\t\\t\\telse{ hs.remove(num); }                             // remove from hash set, when num is there\\n\\t\\t\\t}\\n\\t\\t\\tif(hs.size() > 0){ return false; }                      // in the end, we should have all \\'num\\' removed. If not, then return false \\n\\t\\t\\treturn true;\\n\\t\\t}\\n//\\n//\\n//\\n## Code (C++)\\n    bool divideArray(vector<int>& nums) {\\n        if(nums.size() % 2 != 0){ return false; }               // if nums length is odd, we can not even make pairs from array of odd length\\n\\t\\tunordered_set <int> hs;                                 // create hash set\\n\\t\\tfor(int num : nums){   \\n\\t\\t\\tif(hs.find(num) == hs.end()){ hs.insert(num); }              // add to hash set, when num is not there\\n\\t\\t\\telse{ hs.erase(num); }                             // remove from hash set, when num is there\\n\\t\\t}\\n\\t\\tif(hs.size() > 0){ return false; }                      // in the end, we should have all \\'num\\' removed. If not, then return false \\n\\t\\treturn true;\\n    }\\n//\\n//\\nIf you like it, pls **UpVote** :)\\nIf you need more explanation or, got more optimized way, **comment** below.",
                "codeTag": "Unknown"
            },
            {
                "id": 1864130,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto &it : nums){\\n            mp[it]++;\\n        }\\n        for(auto &it : mp){\\n            if(it.second%2!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto &it : nums){\\n            mp[it]++;\\n        }\\n        for(auto &it : mp){\\n            if(it.second%2!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864087,
                "title": "java-hashmap-o-n",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        for(int key : map.keySet()){\\n            if(map.get(key) % 2 != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        for(int key : map.keySet()){\\n            if(map.get(key) % 2 != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864068,
                "title": "java-clean-solution",
                "content": "\\n    public boolean divideArray(int[] nums) {\\n        int[] frequency = new int[501];\\n        for (int num: nums)\\n            frequency[num]++;\\n        for (int count: frequency) {\\n            if (count % 2 != 0) return false;\\n        }\\n        return true;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public boolean divideArray(int[] nums) {\\n        int[] frequency = new int[501];\\n        for (int num: nums)\\n            frequency[num]++;\\n        for (int count: frequency) {\\n            if (count % 2 != 0) return false;\\n        }\\n        return true;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1864047,
                "title": "using-hashmap-o-n-solution",
                "content": "Here the idea which I used is very straightforward... keep the count of each array element and if the count of the number is even then we can make a pair...so counting the elements which have even number of Occurrences gives us the answer\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        for(auto x : nums){\\n            mp[x]++;\\n            \\n        }\\n        for(auto x : mp){\\n            if(x.second%2 == 1)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        for(auto x : nums){\\n            mp[x]++;\\n            \\n        }\\n        for(auto x : mp){\\n            if(x.second%2 == 1)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864015,
                "title": "cpp",
                "content": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        if(nums.size()%2!=0){\\n            return false;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();){\\n            if(nums[i]!=nums[i+1])\\n                return false;\\n            else{\\n                i=i+2;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        if(nums.size()%2!=0){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1863975,
                "title": "c-solution-easy-understanding-o-n",
                "content": "First, we want to figure out how many of each number there is.\\nThen, if there isn\\'t an even number of it then return false.\\nOtherwise, if all numbers have an even count, return true.\\n```    \\nbool divideArray(vector<int>& nums) {\\n        std::map<int, int> countedNums;\\n        for (int n : nums) {\\n            countedNums[n]++;\\n        }\\n        \\n        for (auto it = countedNums.begin(); it != countedNums.end(); it++) {\\n            if (it->second % 2 == 1) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```    \\nbool divideArray(vector<int>& nums) {\\n        std::map<int, int> countedNums;\\n        for (int n : nums) {\\n            countedNums[n]++;\\n        }\\n        \\n        for (auto it = countedNums.begin(); it != countedNums.end(); it++) {\\n            if (it->second % 2 == 1) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1863931,
                "title": "java-solution-sort-array-tc-o-nlogn-sc-o-1",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = 1; i < n; i+= 2) {\\n            if(nums[i] == nums[i - 1]) {\\n                count++;\\n            }\\n        }\\n        \\n        return count == n/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = 1; i < n; i+= 2) {\\n            if(nums[i] == nums[i - 1]) {\\n                count++;\\n            }\\n        }\\n        \\n        return count == n/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863914,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n    int n = nums.length;\\n    int count = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            count = 0;\\n            for(int j = 0 ; j < n ; j++){\\n                if(nums[i] == nums[j])\\n                    count++;\\n            }\\n            if(count % 2 != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n    int n = nums.length;\\n    int count = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            count = 0;\\n            for(int j = 0 ; j < n ; j++){\\n                if(nums[i] == nums[j])\\n                    count++;\\n            }\\n            if(count % 2 != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863883,
                "title": "python3-one-pass-o-n",
                "content": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        seen=set()\\n        total=0\\n        for el in nums:\\n            if el in seen:\\n                total+=1\\n                seen.remove(el)\\n            else:\\n                seen.add(el)\\n        return total==len(nums)//2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        seen=set()\\n        total=0\\n        for el in nums:\\n            if el in seen:\\n                total+=1\\n                seen.remove(el)\\n            else:\\n                seen.add(el)\\n        return total==len(nums)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863873,
                "title": "java-array-vs-hashmap",
                "content": "```\\nclass Solution\\n{\\n    public boolean divideArray(int[] nums)\\n    {\\n        int[] freq = new int[500];\\n        for(int i : nums)\\n            freq[i-1]++;\\n        for(int i :freq)\\n            if((i & 1) != 0)\\n                return false;\\n        return true;\\n    }\\n}\\n\\nclass Solution\\n{\\n    public boolean divideArray(int[] nums)\\n    {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums)\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        for(int i : map.keySet())\\n            if(map.get(i) % 2 != 0)\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean divideArray(int[] nums)\\n    {\\n        int[] freq = new int[500];\\n        for(int i : nums)\\n            freq[i-1]++;\\n        for(int i :freq)\\n            if((i & 1) != 0)\\n                return false;\\n        return true;\\n    }\\n}\\n\\nclass Solution\\n{\\n    public boolean divideArray(int[] nums)\\n    {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums)\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        for(int i : map.keySet())\\n            if(map.get(i) % 2 != 0)\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094551,
                "title": "python-one-line-std-lib",
                "content": "# Complexity\\nTime and space complextity is O(n)\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        return all(c % 2 == 0 for c in Counter(nums).values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        return all(c % 2 == 0 for c in Counter(nums).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094095,
                "title": "beats-99-30-of-c-users",
                "content": "# Intuition\\nTo divide the array into pairs with equal elements, we need to make sure the number of a given element in the array is even.\\n\\n# Approach\\n1. We\\'ll use a map to count the occurrences of each element.\\n2. For each unique element, we need an even count for it to form pairs. If any element has an odd count, we can\\'t form pairs, so we return false.\\n\\n# Complexity\\n- Time complexity:  O(n) since we have only single loops and not nested (best of 99.27% of C++ users)\\n\\n- Space complexity: O(1) since the count array has a fixed size of 501 (derived from problem constraints), which is a constant. (beats 57% of C++ users)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        vector<int> arr(501, 0);\\n        int max = 0;\\n\\n        // Count occurrences of each element in the array\\n        for(auto x: nums) {\\n            arr[x]++;\\n            if(arr[x] > max) max = arr[x];\\n        } \\n\\n        // Check if each unique element has an even count\\n        for(auto x: arr) if(x%2 != 0) return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        vector<int> arr(501, 0);\\n        int max = 0;\\n\\n        // Count occurrences of each element in the array\\n        for(auto x: nums) {\\n            arr[x]++;\\n            if(arr[x] > max) max = arr[x];\\n        } \\n\\n        // Check if each unique element has an even count\\n        for(auto x: arr) if(x%2 != 0) return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092196,
                "title": "accepted-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func divideArray(_ nums: [Int]) -> Bool {\\n        \\n        var numsCopy = nums.sorted()\\n    \\n        while !numsCopy.isEmpty {\\n            if Set(numsCopy.prefix(2)).count == 1 {\\n                numsCopy.removeFirst(2)\\n            } else {\\n                return false\\n            }\\n        }\\n    \\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    func divideArray(_ nums: [Int]) -> Bool {\\n        \\n        var numsCopy = nums.sorted()\\n    \\n        while !numsCopy.isEmpty {\\n            if Set(numsCopy.prefix(2)).count == 1 {\\n                numsCopy.removeFirst(2)\\n            } else {\\n                return false\\n            }\\n        }\\n    \\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091938,
                "title": "easy-java-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        for(i=0;i<nums.length-1.;i+=2)\\n        {\\n        if(nums[i]==nums[i+1])\\n        {\\n    \\n        continue;\\n        }\\n        else\\n        {\\n        return false;\\n        }        \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        for(i=0;i<nums.length-1.;i+=2)\\n        {\\n        if(nums[i]==nums[i+1])\\n        {\\n    \\n        continue;\\n        }\\n        else\\n        {\\n        return false;\\n        }        \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091543,
                "title": "easy-and-understandable-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func divideArray(_ nums: [Int]) -> Bool {\\n        let sortedNums = nums.sorted()\\n\\n        for i in 0..<nums.count{\\n            if i % 2 == 0 && sortedNums[i] != sortedNums[i+1]{\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func divideArray(_ nums: [Int]) -> Bool {\\n        let sortedNums = nums.sorted()\\n\\n        for i in 0..<nums.count{\\n            if i % 2 == 0 && sortedNums[i] != sortedNums[i+1]{\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088176,
                "title": "easiest-you-will-find-better-that-97-69",
                "content": "# Intuition\\nTrying to sort the array and then comparing the last elements one by one, as the shall form pairs, if two of the elements does not find the pair, we will return False.\\nIf the nums becomes empty means that we have found pair for each elemetns. Hence True\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        while nums!= []:\\n            if nums.pop()!=nums.pop():\\n                return False\\n\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        while nums!= []:\\n            if nums.pop()!=nums.pop():\\n                return False\\n\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088168,
                "title": "beats-100-very-easy-java-solution",
                "content": "#Upvote if You Like It\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int[] arr = new int[501];\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++ ){\\n            arr[nums[i]]++;\\n            if(arr[nums[i]] % 2 == 0){\\n                count++;\\n            }\\n        }\\n        return count == nums.length/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean divideArray(int[] nums) {\\n        int[] arr = new int[501];\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++ ){\\n            arr[nums[i]]++;\\n            if(arr[nums[i]] % 2 == 0){\\n                count++;\\n            }\\n        }\\n        return count == nums.length/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085020,
                "title": "a-funny-solution-easy-to-understand-1-liner-97-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def divideArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        temp = [i for i in nums if nums.count(i) % 2 == 0]\\n        return temp == nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def divideArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        temp = [i for i in nums if nums.count(i) % 2 == 0]\\n        return temp == nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083710,
                "title": "very-easy-solution-100-beast-learn-and-learn-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n\\n       sort(nums.begin(),nums.end()); \\n       for(int i=0;i<nums.size()-1;) \\n       { \\n           if(nums[i]!=nums[i+1]) \\n           { \\n               \\n               return false;\\n           } \\n           i=i+2;\\n       } \\n       return true;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n\\n       sort(nums.begin(),nums.end()); \\n       for(int i=0;i<nums.size()-1;) \\n       { \\n           if(nums[i]!=nums[i+1]) \\n           { \\n               \\n               return false;\\n           } \\n           i=i+2;\\n       } \\n       return true;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077708,
                "title": "using-hashmap-c-beats-88",
                "content": "# Complexity\\n- Time complexity:O(N * log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it: mp){\\n            if(it.second % 2 != 0)return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it: mp){\\n            if(it.second % 2 != 0)return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076432,
                "title": "python-easy-dictionary-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n\\n        rval = True\\n        for i in d.values():\\n            if i%2 == 0:\\n                rval = True\\n            elif i%2 != 0:\\n                rval = False\\n                break\\n\\n        return rval\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divideArray(self, nums: List[int]) -> bool:\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n\\n        rval = True\\n        for i in d.values():\\n            if i%2 == 0:\\n                rval = True\\n            elif i%2 != 0:\\n                rval = False\\n                break\\n\\n        return rval\\n            \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1771517,
                "content": [
                    {
                        "username": "tess_",
                        "content": "how to solve this using bit manipulation without hashmap or sorting?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "My code passes 130 test cases. It fails for this one:\\n[9,9,19,10,9,12,2,12,3,3,11,5,8,4,13,6,2,11,9,19,11,15,9,17,15,12,5,14,12,16,18,16,10,3,8,9,16,20,2,4,16,12,11,14,20,16,2,18,17,20,3,13,16,17,1,1,11,20,20,4]\\n\\nMy code is as follows:\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n%2!=0) return false;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans= ans^nums[i];\\n        }\\n        if(ans==0)\\n        {\\n            return true;\\n        }\\n        else \\n        {\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "anujeet98",
                        "content": "[3,4,2,5] xor will give you 0 for this. This will not have same numbers in each pair."
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "I am also getting same result.... I don\\'t know why is it happening."
                    },
                    {
                        "username": "krishan2443",
                        "content": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int x=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            x = x^nums[i];\\n        }\\n        if(x==0) return true;\\n        else return false;\\n    }\\n};\\nI\\'m also stuck on this test case\\nissue with above solution:- because some elements in this are odd whose xor is also equal to zero for ex:- 12^11^4^7^16^20=0 for the above test case"
                    },
                    {
                        "username": "speedyy",
                        "content": "From the below comment \\n\" \\n[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails.\\n\""
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "why can we just take xor of all elements and if xor==0 return true else false.\\nThis solution doesnt seems to work..can anyone explain me please..\\n\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int len=nums.size();\\n        if(len&1)\\n            return false;\\n        \\n        int xorr=0;\\n        for(const int &num:nums){\\n            xorr^=num;\\n        }\\n        return !xorr;\\n    }\\n};"
                    },
                    {
                        "username": "saichandra004",
                        "content": "The XOR output seems to repeat after every 4th iteration which means =>\n0 ^ 1 ^ 2 ^ 3 = 0\n4 ^ 5 ^ 6 ^ 7 = 0\n8 ^ 9 ^ 10 ^ 11 = 0\n\nFor every 4th iteration the xor returns back the original number because the previous one is zero.\nHence all xors in the pattern 4n are the number itself.\n\n\nAnd hence XOR won't work in this case, we might think XOR of same numbers are zero and hence we test if an element is repeated, but unfortunately 4n cycles come up as False Positive cases."
                    },
                    {
                        "username": "anujeet98",
                        "content": "you can get xor of multiple numbers as 0. This will neglect the 2nd condition in the question"
                    },
                    {
                        "username": "hariharareddyg",
                        "content": "[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails."
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "It doesn\\'t work because the xor of multiple elements can equal 0. For example 20^17^6^12^11^4 is 0, so if there were an array with those only those 6 elements in odd quantities, xoring all the values would give 0."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip : \\n1. Sort The Array\\n2. Check consecutive element equality count and if count value;\\n3. Return if C== size/2 (according to question) "
                    },
                    {
                        "username": "speedyy",
                        "content": "Why would you sort it when you can do it in O(n) ? Not a good tip!"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "How to solve this problem only using XOR\\n"
                    },
                    {
                        "username": "nikhilshukla311",
                        "content": "expected \\'nums\\' to have 4 <= size <= 4 but got 5\\nwhy this error is coming?\\nplease help"
                    },
                    {
                        "username": "speedyy",
                        "content": "Plz put your code here, it will be helpful to understand the error msg "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2206.%20Divide%20Array%20Into%20Equal%20Pairs.cpp\\n\\nThis repository contains all LEETCODE SOLUTION IN C++\\nPlease leave a STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "speedyy",
                        "content": "\" \\uD83D\\uDCA1 Discussion Rules\\n  1. Please don\\'t post any solutions in this discussion tab. \""
                    }
                ]
            },
            {
                "id": 1736779,
                "content": [
                    {
                        "username": "tess_",
                        "content": "how to solve this using bit manipulation without hashmap or sorting?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "My code passes 130 test cases. It fails for this one:\\n[9,9,19,10,9,12,2,12,3,3,11,5,8,4,13,6,2,11,9,19,11,15,9,17,15,12,5,14,12,16,18,16,10,3,8,9,16,20,2,4,16,12,11,14,20,16,2,18,17,20,3,13,16,17,1,1,11,20,20,4]\\n\\nMy code is as follows:\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n%2!=0) return false;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans= ans^nums[i];\\n        }\\n        if(ans==0)\\n        {\\n            return true;\\n        }\\n        else \\n        {\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "anujeet98",
                        "content": "[3,4,2,5] xor will give you 0 for this. This will not have same numbers in each pair."
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "I am also getting same result.... I don\\'t know why is it happening."
                    },
                    {
                        "username": "krishan2443",
                        "content": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int x=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            x = x^nums[i];\\n        }\\n        if(x==0) return true;\\n        else return false;\\n    }\\n};\\nI\\'m also stuck on this test case\\nissue with above solution:- because some elements in this are odd whose xor is also equal to zero for ex:- 12^11^4^7^16^20=0 for the above test case"
                    },
                    {
                        "username": "speedyy",
                        "content": "From the below comment \\n\" \\n[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails.\\n\""
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "why can we just take xor of all elements and if xor==0 return true else false.\\nThis solution doesnt seems to work..can anyone explain me please..\\n\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int len=nums.size();\\n        if(len&1)\\n            return false;\\n        \\n        int xorr=0;\\n        for(const int &num:nums){\\n            xorr^=num;\\n        }\\n        return !xorr;\\n    }\\n};"
                    },
                    {
                        "username": "saichandra004",
                        "content": "The XOR output seems to repeat after every 4th iteration which means =>\n0 ^ 1 ^ 2 ^ 3 = 0\n4 ^ 5 ^ 6 ^ 7 = 0\n8 ^ 9 ^ 10 ^ 11 = 0\n\nFor every 4th iteration the xor returns back the original number because the previous one is zero.\nHence all xors in the pattern 4n are the number itself.\n\n\nAnd hence XOR won't work in this case, we might think XOR of same numbers are zero and hence we test if an element is repeated, but unfortunately 4n cycles come up as False Positive cases."
                    },
                    {
                        "username": "anujeet98",
                        "content": "you can get xor of multiple numbers as 0. This will neglect the 2nd condition in the question"
                    },
                    {
                        "username": "hariharareddyg",
                        "content": "[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails."
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "It doesn\\'t work because the xor of multiple elements can equal 0. For example 20^17^6^12^11^4 is 0, so if there were an array with those only those 6 elements in odd quantities, xoring all the values would give 0."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip : \\n1. Sort The Array\\n2. Check consecutive element equality count and if count value;\\n3. Return if C== size/2 (according to question) "
                    },
                    {
                        "username": "speedyy",
                        "content": "Why would you sort it when you can do it in O(n) ? Not a good tip!"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "How to solve this problem only using XOR\\n"
                    },
                    {
                        "username": "nikhilshukla311",
                        "content": "expected \\'nums\\' to have 4 <= size <= 4 but got 5\\nwhy this error is coming?\\nplease help"
                    },
                    {
                        "username": "speedyy",
                        "content": "Plz put your code here, it will be helpful to understand the error msg "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2206.%20Divide%20Array%20Into%20Equal%20Pairs.cpp\\n\\nThis repository contains all LEETCODE SOLUTION IN C++\\nPlease leave a STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "speedyy",
                        "content": "\" \\uD83D\\uDCA1 Discussion Rules\\n  1. Please don\\'t post any solutions in this discussion tab. \""
                    }
                ]
            },
            {
                "id": 1682002,
                "content": [
                    {
                        "username": "tess_",
                        "content": "how to solve this using bit manipulation without hashmap or sorting?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "My code passes 130 test cases. It fails for this one:\\n[9,9,19,10,9,12,2,12,3,3,11,5,8,4,13,6,2,11,9,19,11,15,9,17,15,12,5,14,12,16,18,16,10,3,8,9,16,20,2,4,16,12,11,14,20,16,2,18,17,20,3,13,16,17,1,1,11,20,20,4]\\n\\nMy code is as follows:\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n%2!=0) return false;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans= ans^nums[i];\\n        }\\n        if(ans==0)\\n        {\\n            return true;\\n        }\\n        else \\n        {\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "anujeet98",
                        "content": "[3,4,2,5] xor will give you 0 for this. This will not have same numbers in each pair."
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "I am also getting same result.... I don\\'t know why is it happening."
                    },
                    {
                        "username": "krishan2443",
                        "content": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int x=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            x = x^nums[i];\\n        }\\n        if(x==0) return true;\\n        else return false;\\n    }\\n};\\nI\\'m also stuck on this test case\\nissue with above solution:- because some elements in this are odd whose xor is also equal to zero for ex:- 12^11^4^7^16^20=0 for the above test case"
                    },
                    {
                        "username": "speedyy",
                        "content": "From the below comment \\n\" \\n[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails.\\n\""
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "why can we just take xor of all elements and if xor==0 return true else false.\\nThis solution doesnt seems to work..can anyone explain me please..\\n\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int len=nums.size();\\n        if(len&1)\\n            return false;\\n        \\n        int xorr=0;\\n        for(const int &num:nums){\\n            xorr^=num;\\n        }\\n        return !xorr;\\n    }\\n};"
                    },
                    {
                        "username": "saichandra004",
                        "content": "The XOR output seems to repeat after every 4th iteration which means =>\n0 ^ 1 ^ 2 ^ 3 = 0\n4 ^ 5 ^ 6 ^ 7 = 0\n8 ^ 9 ^ 10 ^ 11 = 0\n\nFor every 4th iteration the xor returns back the original number because the previous one is zero.\nHence all xors in the pattern 4n are the number itself.\n\n\nAnd hence XOR won't work in this case, we might think XOR of same numbers are zero and hence we test if an element is repeated, but unfortunately 4n cycles come up as False Positive cases."
                    },
                    {
                        "username": "anujeet98",
                        "content": "you can get xor of multiple numbers as 0. This will neglect the 2nd condition in the question"
                    },
                    {
                        "username": "hariharareddyg",
                        "content": "[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails."
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "It doesn\\'t work because the xor of multiple elements can equal 0. For example 20^17^6^12^11^4 is 0, so if there were an array with those only those 6 elements in odd quantities, xoring all the values would give 0."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip : \\n1. Sort The Array\\n2. Check consecutive element equality count and if count value;\\n3. Return if C== size/2 (according to question) "
                    },
                    {
                        "username": "speedyy",
                        "content": "Why would you sort it when you can do it in O(n) ? Not a good tip!"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "How to solve this problem only using XOR\\n"
                    },
                    {
                        "username": "nikhilshukla311",
                        "content": "expected \\'nums\\' to have 4 <= size <= 4 but got 5\\nwhy this error is coming?\\nplease help"
                    },
                    {
                        "username": "speedyy",
                        "content": "Plz put your code here, it will be helpful to understand the error msg "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2206.%20Divide%20Array%20Into%20Equal%20Pairs.cpp\\n\\nThis repository contains all LEETCODE SOLUTION IN C++\\nPlease leave a STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "speedyy",
                        "content": "\" \\uD83D\\uDCA1 Discussion Rules\\n  1. Please don\\'t post any solutions in this discussion tab. \""
                    }
                ]
            },
            {
                "id": 2024416,
                "content": [
                    {
                        "username": "tess_",
                        "content": "how to solve this using bit manipulation without hashmap or sorting?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "My code passes 130 test cases. It fails for this one:\\n[9,9,19,10,9,12,2,12,3,3,11,5,8,4,13,6,2,11,9,19,11,15,9,17,15,12,5,14,12,16,18,16,10,3,8,9,16,20,2,4,16,12,11,14,20,16,2,18,17,20,3,13,16,17,1,1,11,20,20,4]\\n\\nMy code is as follows:\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n%2!=0) return false;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans= ans^nums[i];\\n        }\\n        if(ans==0)\\n        {\\n            return true;\\n        }\\n        else \\n        {\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "anujeet98",
                        "content": "[3,4,2,5] xor will give you 0 for this. This will not have same numbers in each pair."
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "I am also getting same result.... I don\\'t know why is it happening."
                    },
                    {
                        "username": "krishan2443",
                        "content": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int x=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            x = x^nums[i];\\n        }\\n        if(x==0) return true;\\n        else return false;\\n    }\\n};\\nI\\'m also stuck on this test case\\nissue with above solution:- because some elements in this are odd whose xor is also equal to zero for ex:- 12^11^4^7^16^20=0 for the above test case"
                    },
                    {
                        "username": "speedyy",
                        "content": "From the below comment \\n\" \\n[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails.\\n\""
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "why can we just take xor of all elements and if xor==0 return true else false.\\nThis solution doesnt seems to work..can anyone explain me please..\\n\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int len=nums.size();\\n        if(len&1)\\n            return false;\\n        \\n        int xorr=0;\\n        for(const int &num:nums){\\n            xorr^=num;\\n        }\\n        return !xorr;\\n    }\\n};"
                    },
                    {
                        "username": "saichandra004",
                        "content": "The XOR output seems to repeat after every 4th iteration which means =>\n0 ^ 1 ^ 2 ^ 3 = 0\n4 ^ 5 ^ 6 ^ 7 = 0\n8 ^ 9 ^ 10 ^ 11 = 0\n\nFor every 4th iteration the xor returns back the original number because the previous one is zero.\nHence all xors in the pattern 4n are the number itself.\n\n\nAnd hence XOR won't work in this case, we might think XOR of same numbers are zero and hence we test if an element is repeated, but unfortunately 4n cycles come up as False Positive cases."
                    },
                    {
                        "username": "anujeet98",
                        "content": "you can get xor of multiple numbers as 0. This will neglect the 2nd condition in the question"
                    },
                    {
                        "username": "hariharareddyg",
                        "content": "[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails."
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "It doesn\\'t work because the xor of multiple elements can equal 0. For example 20^17^6^12^11^4 is 0, so if there were an array with those only those 6 elements in odd quantities, xoring all the values would give 0."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip : \\n1. Sort The Array\\n2. Check consecutive element equality count and if count value;\\n3. Return if C== size/2 (according to question) "
                    },
                    {
                        "username": "speedyy",
                        "content": "Why would you sort it when you can do it in O(n) ? Not a good tip!"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "How to solve this problem only using XOR\\n"
                    },
                    {
                        "username": "nikhilshukla311",
                        "content": "expected \\'nums\\' to have 4 <= size <= 4 but got 5\\nwhy this error is coming?\\nplease help"
                    },
                    {
                        "username": "speedyy",
                        "content": "Plz put your code here, it will be helpful to understand the error msg "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2206.%20Divide%20Array%20Into%20Equal%20Pairs.cpp\\n\\nThis repository contains all LEETCODE SOLUTION IN C++\\nPlease leave a STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "speedyy",
                        "content": "\" \\uD83D\\uDCA1 Discussion Rules\\n  1. Please don\\'t post any solutions in this discussion tab. \""
                    }
                ]
            },
            {
                "id": 1896143,
                "content": [
                    {
                        "username": "tess_",
                        "content": "how to solve this using bit manipulation without hashmap or sorting?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "My code passes 130 test cases. It fails for this one:\\n[9,9,19,10,9,12,2,12,3,3,11,5,8,4,13,6,2,11,9,19,11,15,9,17,15,12,5,14,12,16,18,16,10,3,8,9,16,20,2,4,16,12,11,14,20,16,2,18,17,20,3,13,16,17,1,1,11,20,20,4]\\n\\nMy code is as follows:\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n%2!=0) return false;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans= ans^nums[i];\\n        }\\n        if(ans==0)\\n        {\\n            return true;\\n        }\\n        else \\n        {\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "anujeet98",
                        "content": "[3,4,2,5] xor will give you 0 for this. This will not have same numbers in each pair."
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "I am also getting same result.... I don\\'t know why is it happening."
                    },
                    {
                        "username": "krishan2443",
                        "content": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int x=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            x = x^nums[i];\\n        }\\n        if(x==0) return true;\\n        else return false;\\n    }\\n};\\nI\\'m also stuck on this test case\\nissue with above solution:- because some elements in this are odd whose xor is also equal to zero for ex:- 12^11^4^7^16^20=0 for the above test case"
                    },
                    {
                        "username": "speedyy",
                        "content": "From the below comment \\n\" \\n[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails.\\n\""
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "why can we just take xor of all elements and if xor==0 return true else false.\\nThis solution doesnt seems to work..can anyone explain me please..\\n\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int len=nums.size();\\n        if(len&1)\\n            return false;\\n        \\n        int xorr=0;\\n        for(const int &num:nums){\\n            xorr^=num;\\n        }\\n        return !xorr;\\n    }\\n};"
                    },
                    {
                        "username": "saichandra004",
                        "content": "The XOR output seems to repeat after every 4th iteration which means =>\n0 ^ 1 ^ 2 ^ 3 = 0\n4 ^ 5 ^ 6 ^ 7 = 0\n8 ^ 9 ^ 10 ^ 11 = 0\n\nFor every 4th iteration the xor returns back the original number because the previous one is zero.\nHence all xors in the pattern 4n are the number itself.\n\n\nAnd hence XOR won't work in this case, we might think XOR of same numbers are zero and hence we test if an element is repeated, but unfortunately 4n cycles come up as False Positive cases."
                    },
                    {
                        "username": "anujeet98",
                        "content": "you can get xor of multiple numbers as 0. This will neglect the 2nd condition in the question"
                    },
                    {
                        "username": "hariharareddyg",
                        "content": "[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails."
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "It doesn\\'t work because the xor of multiple elements can equal 0. For example 20^17^6^12^11^4 is 0, so if there were an array with those only those 6 elements in odd quantities, xoring all the values would give 0."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip : \\n1. Sort The Array\\n2. Check consecutive element equality count and if count value;\\n3. Return if C== size/2 (according to question) "
                    },
                    {
                        "username": "speedyy",
                        "content": "Why would you sort it when you can do it in O(n) ? Not a good tip!"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "How to solve this problem only using XOR\\n"
                    },
                    {
                        "username": "nikhilshukla311",
                        "content": "expected \\'nums\\' to have 4 <= size <= 4 but got 5\\nwhy this error is coming?\\nplease help"
                    },
                    {
                        "username": "speedyy",
                        "content": "Plz put your code here, it will be helpful to understand the error msg "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2206.%20Divide%20Array%20Into%20Equal%20Pairs.cpp\\n\\nThis repository contains all LEETCODE SOLUTION IN C++\\nPlease leave a STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "speedyy",
                        "content": "\" \\uD83D\\uDCA1 Discussion Rules\\n  1. Please don\\'t post any solutions in this discussion tab. \""
                    }
                ]
            },
            {
                "id": 1799563,
                "content": [
                    {
                        "username": "tess_",
                        "content": "how to solve this using bit manipulation without hashmap or sorting?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "My code passes 130 test cases. It fails for this one:\\n[9,9,19,10,9,12,2,12,3,3,11,5,8,4,13,6,2,11,9,19,11,15,9,17,15,12,5,14,12,16,18,16,10,3,8,9,16,20,2,4,16,12,11,14,20,16,2,18,17,20,3,13,16,17,1,1,11,20,20,4]\\n\\nMy code is as follows:\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n%2!=0) return false;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans= ans^nums[i];\\n        }\\n        if(ans==0)\\n        {\\n            return true;\\n        }\\n        else \\n        {\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "anujeet98",
                        "content": "[3,4,2,5] xor will give you 0 for this. This will not have same numbers in each pair."
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "I am also getting same result.... I don\\'t know why is it happening."
                    },
                    {
                        "username": "krishan2443",
                        "content": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int x=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            x = x^nums[i];\\n        }\\n        if(x==0) return true;\\n        else return false;\\n    }\\n};\\nI\\'m also stuck on this test case\\nissue with above solution:- because some elements in this are odd whose xor is also equal to zero for ex:- 12^11^4^7^16^20=0 for the above test case"
                    },
                    {
                        "username": "speedyy",
                        "content": "From the below comment \\n\" \\n[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails.\\n\""
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "why can we just take xor of all elements and if xor==0 return true else false.\\nThis solution doesnt seems to work..can anyone explain me please..\\n\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int len=nums.size();\\n        if(len&1)\\n            return false;\\n        \\n        int xorr=0;\\n        for(const int &num:nums){\\n            xorr^=num;\\n        }\\n        return !xorr;\\n    }\\n};"
                    },
                    {
                        "username": "saichandra004",
                        "content": "The XOR output seems to repeat after every 4th iteration which means =>\n0 ^ 1 ^ 2 ^ 3 = 0\n4 ^ 5 ^ 6 ^ 7 = 0\n8 ^ 9 ^ 10 ^ 11 = 0\n\nFor every 4th iteration the xor returns back the original number because the previous one is zero.\nHence all xors in the pattern 4n are the number itself.\n\n\nAnd hence XOR won't work in this case, we might think XOR of same numbers are zero and hence we test if an element is repeated, but unfortunately 4n cycles come up as False Positive cases."
                    },
                    {
                        "username": "anujeet98",
                        "content": "you can get xor of multiple numbers as 0. This will neglect the 2nd condition in the question"
                    },
                    {
                        "username": "hariharareddyg",
                        "content": "[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails."
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "It doesn\\'t work because the xor of multiple elements can equal 0. For example 20^17^6^12^11^4 is 0, so if there were an array with those only those 6 elements in odd quantities, xoring all the values would give 0."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip : \\n1. Sort The Array\\n2. Check consecutive element equality count and if count value;\\n3. Return if C== size/2 (according to question) "
                    },
                    {
                        "username": "speedyy",
                        "content": "Why would you sort it when you can do it in O(n) ? Not a good tip!"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "How to solve this problem only using XOR\\n"
                    },
                    {
                        "username": "nikhilshukla311",
                        "content": "expected \\'nums\\' to have 4 <= size <= 4 but got 5\\nwhy this error is coming?\\nplease help"
                    },
                    {
                        "username": "speedyy",
                        "content": "Plz put your code here, it will be helpful to understand the error msg "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2206.%20Divide%20Array%20Into%20Equal%20Pairs.cpp\\n\\nThis repository contains all LEETCODE SOLUTION IN C++\\nPlease leave a STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "speedyy",
                        "content": "\" \\uD83D\\uDCA1 Discussion Rules\\n  1. Please don\\'t post any solutions in this discussion tab. \""
                    }
                ]
            },
            {
                "id": 1795243,
                "content": [
                    {
                        "username": "tess_",
                        "content": "how to solve this using bit manipulation without hashmap or sorting?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "My code passes 130 test cases. It fails for this one:\\n[9,9,19,10,9,12,2,12,3,3,11,5,8,4,13,6,2,11,9,19,11,15,9,17,15,12,5,14,12,16,18,16,10,3,8,9,16,20,2,4,16,12,11,14,20,16,2,18,17,20,3,13,16,17,1,1,11,20,20,4]\\n\\nMy code is as follows:\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n%2!=0) return false;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans= ans^nums[i];\\n        }\\n        if(ans==0)\\n        {\\n            return true;\\n        }\\n        else \\n        {\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "anujeet98",
                        "content": "[3,4,2,5] xor will give you 0 for this. This will not have same numbers in each pair."
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "I am also getting same result.... I don\\'t know why is it happening."
                    },
                    {
                        "username": "krishan2443",
                        "content": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int x=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            x = x^nums[i];\\n        }\\n        if(x==0) return true;\\n        else return false;\\n    }\\n};\\nI\\'m also stuck on this test case\\nissue with above solution:- because some elements in this are odd whose xor is also equal to zero for ex:- 12^11^4^7^16^20=0 for the above test case"
                    },
                    {
                        "username": "speedyy",
                        "content": "From the below comment \\n\" \\n[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails.\\n\""
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "why can we just take xor of all elements and if xor==0 return true else false.\\nThis solution doesnt seems to work..can anyone explain me please..\\n\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int len=nums.size();\\n        if(len&1)\\n            return false;\\n        \\n        int xorr=0;\\n        for(const int &num:nums){\\n            xorr^=num;\\n        }\\n        return !xorr;\\n    }\\n};"
                    },
                    {
                        "username": "saichandra004",
                        "content": "The XOR output seems to repeat after every 4th iteration which means =>\n0 ^ 1 ^ 2 ^ 3 = 0\n4 ^ 5 ^ 6 ^ 7 = 0\n8 ^ 9 ^ 10 ^ 11 = 0\n\nFor every 4th iteration the xor returns back the original number because the previous one is zero.\nHence all xors in the pattern 4n are the number itself.\n\n\nAnd hence XOR won't work in this case, we might think XOR of same numbers are zero and hence we test if an element is repeated, but unfortunately 4n cycles come up as False Positive cases."
                    },
                    {
                        "username": "anujeet98",
                        "content": "you can get xor of multiple numbers as 0. This will neglect the 2nd condition in the question"
                    },
                    {
                        "username": "hariharareddyg",
                        "content": "[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails."
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "It doesn\\'t work because the xor of multiple elements can equal 0. For example 20^17^6^12^11^4 is 0, so if there were an array with those only those 6 elements in odd quantities, xoring all the values would give 0."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip : \\n1. Sort The Array\\n2. Check consecutive element equality count and if count value;\\n3. Return if C== size/2 (according to question) "
                    },
                    {
                        "username": "speedyy",
                        "content": "Why would you sort it when you can do it in O(n) ? Not a good tip!"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "How to solve this problem only using XOR\\n"
                    },
                    {
                        "username": "nikhilshukla311",
                        "content": "expected \\'nums\\' to have 4 <= size <= 4 but got 5\\nwhy this error is coming?\\nplease help"
                    },
                    {
                        "username": "speedyy",
                        "content": "Plz put your code here, it will be helpful to understand the error msg "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2206.%20Divide%20Array%20Into%20Equal%20Pairs.cpp\\n\\nThis repository contains all LEETCODE SOLUTION IN C++\\nPlease leave a STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "speedyy",
                        "content": "\" \\uD83D\\uDCA1 Discussion Rules\\n  1. Please don\\'t post any solutions in this discussion tab. \""
                    }
                ]
            },
            {
                "id": 1759073,
                "content": [
                    {
                        "username": "tess_",
                        "content": "how to solve this using bit manipulation without hashmap or sorting?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "My code passes 130 test cases. It fails for this one:\\n[9,9,19,10,9,12,2,12,3,3,11,5,8,4,13,6,2,11,9,19,11,15,9,17,15,12,5,14,12,16,18,16,10,3,8,9,16,20,2,4,16,12,11,14,20,16,2,18,17,20,3,13,16,17,1,1,11,20,20,4]\\n\\nMy code is as follows:\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n%2!=0) return false;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans= ans^nums[i];\\n        }\\n        if(ans==0)\\n        {\\n            return true;\\n        }\\n        else \\n        {\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "anujeet98",
                        "content": "[3,4,2,5] xor will give you 0 for this. This will not have same numbers in each pair."
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "I am also getting same result.... I don\\'t know why is it happening."
                    },
                    {
                        "username": "krishan2443",
                        "content": "class Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int x=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            x = x^nums[i];\\n        }\\n        if(x==0) return true;\\n        else return false;\\n    }\\n};\\nI\\'m also stuck on this test case\\nissue with above solution:- because some elements in this are odd whose xor is also equal to zero for ex:- 12^11^4^7^16^20=0 for the above test case"
                    },
                    {
                        "username": "speedyy",
                        "content": "From the below comment \\n\" \\n[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails.\\n\""
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "why can we just take xor of all elements and if xor==0 return true else false.\\nThis solution doesnt seems to work..can anyone explain me please..\\n\\nclass Solution {\\npublic:\\n    bool divideArray(vector<int>& nums) {\\n        int len=nums.size();\\n        if(len&1)\\n            return false;\\n        \\n        int xorr=0;\\n        for(const int &num:nums){\\n            xorr^=num;\\n        }\\n        return !xorr;\\n    }\\n};"
                    },
                    {
                        "username": "saichandra004",
                        "content": "The XOR output seems to repeat after every 4th iteration which means =>\n0 ^ 1 ^ 2 ^ 3 = 0\n4 ^ 5 ^ 6 ^ 7 = 0\n8 ^ 9 ^ 10 ^ 11 = 0\n\nFor every 4th iteration the xor returns back the original number because the previous one is zero.\nHence all xors in the pattern 4n are the number itself.\n\n\nAnd hence XOR won't work in this case, we might think XOR of same numbers are zero and hence we test if an element is repeated, but unfortunately 4n cycles come up as False Positive cases."
                    },
                    {
                        "username": "anujeet98",
                        "content": "you can get xor of multiple numbers as 0. This will neglect the 2nd condition in the question"
                    },
                    {
                        "username": "hariharareddyg",
                        "content": "[8,4,11,7] lets take an example test case if we calculate xor of all numbers it will be zero but it doesnt form pairs. so you code fails."
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "It doesn\\'t work because the xor of multiple elements can equal 0. For example 20^17^6^12^11^4 is 0, so if there were an array with those only those 6 elements in odd quantities, xoring all the values would give 0."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip : \\n1. Sort The Array\\n2. Check consecutive element equality count and if count value;\\n3. Return if C== size/2 (according to question) "
                    },
                    {
                        "username": "speedyy",
                        "content": "Why would you sort it when you can do it in O(n) ? Not a good tip!"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "How to solve this problem only using XOR\\n"
                    },
                    {
                        "username": "nikhilshukla311",
                        "content": "expected \\'nums\\' to have 4 <= size <= 4 but got 5\\nwhy this error is coming?\\nplease help"
                    },
                    {
                        "username": "speedyy",
                        "content": "Plz put your code here, it will be helpful to understand the error msg "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2206.%20Divide%20Array%20Into%20Equal%20Pairs.cpp\\n\\nThis repository contains all LEETCODE SOLUTION IN C++\\nPlease leave a STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    bool divideArray(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "speedyy",
                        "content": "\" \\uD83D\\uDCA1 Discussion Rules\\n  1. Please don\\'t post any solutions in this discussion tab. \""
                    }
                ]
            }
        ]
    }
]