[
    {
        "title": "Minimum Operations to Make All Array Elements Equal",
        "question_content": "You are given an array nums consisting of positive integers.\nYou are also given an integer array queries of size m. For the ith query, you want to make all of the elements of nums equal to queries[i]. You can perform the following operation on the array any number of times:\n\n\tIncrease or decrease an element of the array by 1.\n\nReturn an array answer of size m where answer[i] is the minimum number of operations to make all elements of nums equal to queries[i].\nNote that after each query the array is reset to its original state.\n&nbsp;\nExample 1:\n\nInput: nums = [3,1,6,8], queries = [1,5]\nOutput: [14,10]\nExplanation: For the first query we can do the following operations:\n- Decrease nums[0] 2 times, so that nums = [1,1,6,8].\n- Decrease nums[2] 5 times, so that nums = [1,1,1,8].\n- Decrease nums[3] 7 times, so that nums = [1,1,1,1].\nSo the total number of operations for the first query is 2 + 5 + 7 = 14.\nFor the second query we can do the following operations:\n- Increase nums[0] 2 times, so that nums = [5,1,6,8].\n- Increase nums[1] 4 times, so that nums = [5,5,6,8].\n- Decrease nums[2] 1 time, so that nums = [5,5,5,8].\n- Decrease nums[3] 3 times, so that nums = [5,5,5,5].\nSo the total number of operations for the second query is 2 + 4 + 1 + 3 = 10.\n\nExample 2:\n\nInput: nums = [2,9,6,3], queries = [10]\nOutput: [20]\nExplanation: We can increase each value in the array to 10. The total number of operations will be 8 + 1 + 4 + 7 = 20.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\tm == queries.length\n\t1 <= n, m <= 105\n\t1 <= nums[i], queries[i] <= 109",
        "solutions": [
            {
                "id": 3341928,
                "title": "c-java-python3-prefix-sums-binary-search",
                "content": "# Intuition\\n* If there are `j` numbers in `nums` that are smaller than `query[i]`, you need to find `query[i] * j - sum(j numbers smaller than query[i])` to find increments required in `nums`\\n* If there are `k` numbers in `nums` that are greater than `query[i]`, you need to find `sum(k numbers larger than query[i]) - query[i] * k` to find decrements required in `nums`\\n* Sum of above two values is `ans[i]`\\n![Screen Shot 2023-03-26 at 12.05.05 PM.png](https://assets.leetcode.com/users/images/a0061bf7-ab30-41dc-be3c-0b0bf2872469_1679857679.0441012.png)\\n\\n\\n# Approach\\n* To find smaller numbers than `query[i]` we can sort the array and use binary search\\n* Binary search over sorted `nums` to find index of `query[i]`\\n* Then use prefix sums to find sum of number in smaller and larger segments\\n* `prefix[n] - prefix[i]` is sum of numbers greater than or equal to `query[i]`\\n* `prefix[i]` is sum of numbers smaller than `query[i]`\\n* `query[i] * i - prefix[i]` is increments required\\n*  `prefix[n] - prefix[i] - query[i] * (n - i)` is decrements required\\n* Total = `query[i] * i - prefix[i] + prefix[n] - prefix[i] - query[i] * (n - i)`\\n* Can be simplified to `query[i] * (2 * i - n) + prefix[n] - 2 * prefix[i]`\\n\\n# Complexity\\n- Time complexity: `O((n + m) * log(n))`\\n\\n- Space complexity: `O(n)`\\n\\n# Code\\n**Python3**:\\n```\\ndef minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n    nums.sort()\\n    ans, n, prefix = [], len(nums), [0] + list(accumulate(nums))\\n    for x in queries:\\n        i = bisect_left(nums, x)\\n        ans.append(x * (2 * i - n) + prefix[n] - 2 * prefix[i])\\n    return ans\\n```\\n```\\ndef minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n    nums.sort()\\n    prefix = [0] + list(accumulate(nums))\\n    for x in queries:\\n        i = bisect_left(nums, x)\\n        yield x * (2 * i - len(nums)) + prefix[-1] - 2 * prefix[i]\\n```\\n**C++**:\\n```\\nvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n    sort(nums.begin(), nums.end());\\n    int n = nums.size();\\n    vector<long long> ans, prefix(n + 1);\\n    for (int i = 0; i < n; i++)\\n        prefix[i + 1] = prefix[i] + (long long) nums[i];\\n    for (int& x : queries) {\\n        int i = lower_bound(nums.begin(), nums.end(), x) - nums.begin();\\n        ans.push_back(1LL * x * (2 * i - n) + prefix[n] - 2 * prefix[i]);\\n    }\\n    return ans;\\n}\\n```\\n\\n**Java**:\\n```\\npublic List<Long> minOperations(int[] nums, int[] queries) {\\n    Arrays.sort(nums);\\n    List<Long> ans = new ArrayList<>();\\n    int n = nums.length;\\n    long[] prefix = new long[n + 1];\\n    for (int i = 1; i <= n; i++)\\n        prefix[i] = prefix[i - 1] + nums[i - 1];\\n    for (int x: queries) {\\n        int i = bisect_left(nums, x);\\n        ans.add(1L * x * (2 * i - n) + prefix[n] - 2 * prefix[i]);\\n    }\\n    return ans;\\n}\\nprivate int bisect_left(int[] nums, int x) {\\n    int lo = 0, hi = nums.length;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if (nums[mid] < x) lo = mid + 1;\\n        else hi = mid;\\n    }\\n    return lo;\\n}\\n```\\n\\n**Java using Arrays.binarySearch**:\\n```\\npublic List<Long> minOperations(int[] nums, int[] queries) {\\n    Arrays.sort(nums);\\n    List<Long> ans = new ArrayList<>();\\n    int n = nums.length;\\n    long[] prefix = new long[n + 1];\\n    for (int i = 1; i <= n; i++)\\n        prefix[i] = prefix[i - 1] + nums[i - 1];\\n    for (int x: queries) {\\n        int i = Arrays.binarySearch(nums, x);\\n        if (i < 0) i = -(i + 1); // convert negative index to insertion point\\n        ans.add(1L * x * (2 * i - n) + prefix[n] - 2 * prefix[i]);\\n    }\\n    return ans;\\n}\\n```\\n*Good to know*: In Java, Arrays.binarySearch returns a negative index when the target element is not found in the array. The negative index returned is equal to -(insertion point) - 1, where the insertion point is the index at which the target element would be inserted into the array to maintain the sorted order.\\n\\nFor example, suppose we have an array arr = {1, 3, 5, 7, 9} and we want to search for the element 4. The Arrays.binarySearch(arr, 4) method would return -3. To convert this to the insertion point, we take the absolute value of the negative index and subtract 1: insertion point = |-(-3)| - 1 = 2.\\n\\nTherefore, the insertion point for the element 4 in the sorted array arr would be at index 2, which is the position where we would need to insert 4 to maintain the sorted order.\\n\\n**More binary search problems:**\\n[Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/solutions/3311975/c-java-python3-binary-search-1-liner/)\\n[Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/1802415/python3-java-c-binary-search-1-liner/)\\n[Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/solutions/3262163/c-java-python3-1-line-ologn/)\\n[Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/solutions/2947983/c-java-python-binary-search-and-sorting/)\\n[Number of Flowers in Full Bloom](https://leetcode.com/problems/number-of-flowers-in-full-bloom/solutions/1976804/python3-2-lines-sort-and-binary-search/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n    nums.sort()\\n    ans, n, prefix = [], len(nums), [0] + list(accumulate(nums))\\n    for x in queries:\\n        i = bisect_left(nums, x)\\n        ans.append(x * (2 * i - n) + prefix[n] - 2 * prefix[i])\\n    return ans\\n```\n```\\ndef minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n    nums.sort()\\n    prefix = [0] + list(accumulate(nums))\\n    for x in queries:\\n        i = bisect_left(nums, x)\\n        yield x * (2 * i - len(nums)) + prefix[-1] - 2 * prefix[i]\\n```\n```\\nvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n    sort(nums.begin(), nums.end());\\n    int n = nums.size();\\n    vector<long long> ans, prefix(n + 1);\\n    for (int i = 0; i < n; i++)\\n        prefix[i + 1] = prefix[i] + (long long) nums[i];\\n    for (int& x : queries) {\\n        int i = lower_bound(nums.begin(), nums.end(), x) - nums.begin();\\n        ans.push_back(1LL * x * (2 * i - n) + prefix[n] - 2 * prefix[i]);\\n    }\\n    return ans;\\n}\\n```\n```\\npublic List<Long> minOperations(int[] nums, int[] queries) {\\n    Arrays.sort(nums);\\n    List<Long> ans = new ArrayList<>();\\n    int n = nums.length;\\n    long[] prefix = new long[n + 1];\\n    for (int i = 1; i <= n; i++)\\n        prefix[i] = prefix[i - 1] + nums[i - 1];\\n    for (int x: queries) {\\n        int i = bisect_left(nums, x);\\n        ans.add(1L * x * (2 * i - n) + prefix[n] - 2 * prefix[i]);\\n    }\\n    return ans;\\n}\\nprivate int bisect_left(int[] nums, int x) {\\n    int lo = 0, hi = nums.length;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if (nums[mid] < x) lo = mid + 1;\\n        else hi = mid;\\n    }\\n    return lo;\\n}\\n```\n```\\npublic List<Long> minOperations(int[] nums, int[] queries) {\\n    Arrays.sort(nums);\\n    List<Long> ans = new ArrayList<>();\\n    int n = nums.length;\\n    long[] prefix = new long[n + 1];\\n    for (int i = 1; i <= n; i++)\\n        prefix[i] = prefix[i - 1] + nums[i - 1];\\n    for (int x: queries) {\\n        int i = Arrays.binarySearch(nums, x);\\n        if (i < 0) i = -(i + 1); // convert negative index to insertion point\\n        ans.add(1L * x * (2 * i - n) + prefix[n] - 2 * prefix[i]);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3342118,
                "title": "image-explanation-sorting-prefix-sums-binary-search-easy-concise",
                "content": "# Video Solution (`Aryan Mittal`)\\n\\n`Minimum Operations to Make All Array Elements Equal` by `Aryan Mittal`\\n![Leetcode Contest5.png](https://assets.leetcode.com/users/images/bea8dd52-30ea-4442-a9f9-a7a366152238_1679811067.7837667.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/284b7d00-abb6-4ef9-a924-c6cdb9de9bc5_1679806649.1803951.png)\\n![image.png](https://assets.leetcode.com/users/images/fe473f07-b0e2-455c-ad33-82f46a71d73f_1679806658.4850094.png)\\n![image.png](https://assets.leetcode.com/users/images/a7ff49be-3116-4bed-91de-0aa42603517a_1679806665.3169062.png)\\n![image.png](https://assets.leetcode.com/users/images/553fda03-cd0e-48b4-bf2b-284b9dd0d3b0_1679806672.547002.png)\\n![image.png](https://assets.leetcode.com/users/images/2da0afd5-624f-4417-8d08-807ecc6d21ac_1679806685.2036808.png)\\n\\n\\n# Code\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<ll> prefSum(n+1, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            prefSum[i+1] = prefSum[i] + nums[i];\\n        }\\n        \\n        nums.insert(nums.begin(), 0);\\n        n++;\\n        \\n        vector<ll> ans;\\n        for(auto q : queries){\\n            ll lidx = lower_bound(nums.begin(), nums.end(), q) - nums.begin() - 1;\\n            ll uidx = upper_bound(nums.begin(), nums.end(), q) - nums.begin();\\n            \\n            ll val = q*lidx - (prefSum[lidx] - prefSum[0]);\\n            \\n            if(uidx!=n){\\n                val +=  (prefSum[n-1] - prefSum[uidx-1]) - q*(n-uidx);\\n            }\\n            \\n            ans.push_back(val);\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<ll> prefSum(n+1, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            prefSum[i+1] = prefSum[i] + nums[i];\\n        }\\n        \\n        nums.insert(nums.begin(), 0);\\n        n++;\\n        \\n        vector<ll> ans;\\n        for(auto q : queries){\\n            ll lidx = lower_bound(nums.begin(), nums.end(), q) - nums.begin() - 1;\\n            ll uidx = upper_bound(nums.begin(), nums.end(), q) - nums.begin();\\n            \\n            ll val = q*lidx - (prefSum[lidx] - prefSum[0]);\\n            \\n            if(uidx!=n){\\n                val +=  (prefSum[n-1] - prefSum[uidx-1]) - q*(n-uidx);\\n            }\\n            \\n            ans.push_back(val);\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341978,
                "title": "prefix-sum",
                "content": "To make all elements equal, we need to increase elements smaller than query `q`, and decrease larger ones.\\n    \\nWe sort our array first, so we can find index `i` of first element larger than `q`.\\n    \\nThen, we use the prefix sum array to get:\\n- sum of smaller elements `ps[i]`.\\n- sum of larger elements `ps[-1] - ps[i]`.\\n    \\nThe number of operations is:\\n- `q * i - ps[i]` for smaller elements.\\n- `ps[-1] - ps[i] - q * (n - i)` for larger elements.\\n    \\n**Python 3**\\n```python\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        ps, n = [0] + list(accumulate(nums)), len(nums)\\n        splits = [(q, bisect_left(nums, q)) for q in queries]\\n        return [q * i - ps[i]  + (ps[-1] - ps[i]) - q * (n - i) for q, i in splits] \\n```\\n**C++**\\n```cpp\\nvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n    vector<long long> ps{0}, res;\\n    sort(begin(nums), end(nums));\\n    for (int n : nums)\\n        ps.push_back(ps.back() + n);\\n    for (long long q : queries) {\\n        int i = upper_bound(begin(nums), end(nums), q) - begin(nums);\\n        res.push_back(q * i - ps[i] + (ps.back() - ps[i]) - q * (nums.size() - i));\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        ps, n = [0] + list(accumulate(nums)), len(nums)\\n        splits = [(q, bisect_left(nums, q)) for q in queries]\\n        return [q * i - ps[i]  + (ps[-1] - ps[i]) - q * (n - i) for q, i in splits] \\n```\n```cpp\\nvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n    vector<long long> ps{0}, res;\\n    sort(begin(nums), end(nums));\\n    for (int n : nums)\\n        ps.push_back(ps.back() + n);\\n    for (long long q : queries) {\\n        int i = upper_bound(begin(nums), end(nums), q) - begin(nums);\\n        res.push_back(q * i - ps[i] + (ps.back() - ps[i]) - q * (nums.size() - i));\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342606,
                "title": "explained-prefix-sum-lowerbound-very-simple-easy-to-understand-solution",
                "content": "# Approach\\n\\n1. Evaluate prefix sum array\\n2. find the index of lower bound of the query q\\n3. Once we found the index, the lower half evaluation would take \\n        (ind * q - v[ind-1]) operations.\\n4. Upper half array can be evaluated as equal which take \\n        (v.back() - v[ind-1]) - ( nums.size() - ind )*q;\\n..............^ cur sum....................^sum when all equal\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<long long> ans, v;\\n        v.push_back(nums[0]);\\n        for(int i = 1; i < nums.size(); ++i) v.push_back(v.back() + (long long)nums[i]);\\n        for(auto q: queries){\\n            long long ind = (lower_bound(nums.begin(), nums.end(), q) - nums.begin());\\n            long long opLow= ind*(long long)q - ((ind > 0)?v[ind-1]:0); \\n            long long opHigh = (v.back() - ((ind > 0)?v[ind-1]:0 ) ) - ( (long long)nums.size() - ind )*(long long)q; \\n            ans.push_back(opLow + opHigh);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<long long> ans, v;\\n        v.push_back(nums[0]);\\n        for(int i = 1; i < nums.size(); ++i) v.push_back(v.back() + (long long)nums[i]);\\n        for(auto q: queries){\\n            long long ind = (lower_bound(nums.begin(), nums.end(), q) - nums.begin());\\n            long long opLow= ind*(long long)q - ((ind > 0)?v[ind-1]:0); \\n            long long opHigh = (v.back() - ((ind > 0)?v[ind-1]:0 ) ) - ( (long long)nums.size() - ind )*(long long)q; \\n            ans.push_back(opLow + opHigh);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342069,
                "title": "easiest-solution-ever-just-binary-search",
                "content": "# Intuition\\nTRIPPY\\'S CODING TECHNIQUE \\nHERE I AM PRESENTING JAVA CODE USE VECTOR IN PLACE OF ARRAY FOR C++\\n\\n# Approach\\nSS APROACH\\nJUST SMILE AND SOLVE\\n\\n# Complexity\\nNOTHING COMPLEX\\n\\n# PLEASE UPVOTE\\nPLEASE UPVOTE IF I HELPED YOU \\nTHANK YOU\\nLOVE FOR YOU BY TRIPPY \\n\\n# Code\\n```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        \\n        int n = nums.length;\\n        int m = queries.length;\\n        \\n        List<Long> list = new ArrayList<>();\\n        \\n        Arrays.sort(nums);\\n        long[] arr1 = new long[n];\\n        long[] arr2 = new long[n];\\n        \\n        arr1[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            arr1[i] = arr1[i-1]+nums[i];\\n        }\\n        \\n        arr2[n-1] = nums[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            arr2[i] = arr2[i+1]+nums[i];\\n        }\\n        \\n        for(int i : queries){\\n            long sum = 0l;\\n            int s=0; int e = n-1;\\n            \\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                \\n                if(nums[mid] <= i){ s = mid+1; }\\n                else{ e = mid-1; }\\n            }\\n            \\n            sum += s>0 ?((long)i * (long)s) - arr1[s-1] :0;\\n            \\n            sum += s<n ?arr2[s] - ((long)(n-s) * (long)i) :0;\\n            \\n            list.add(sum);\\n        }\\n        \\n        return list;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        \\n        int n = nums.length;\\n        int m = queries.length;\\n        \\n        List<Long> list = new ArrayList<>();\\n        \\n        Arrays.sort(nums);\\n        long[] arr1 = new long[n];\\n        long[] arr2 = new long[n];\\n        \\n        arr1[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            arr1[i] = arr1[i-1]+nums[i];\\n        }\\n        \\n        arr2[n-1] = nums[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            arr2[i] = arr2[i+1]+nums[i];\\n        }\\n        \\n        for(int i : queries){\\n            long sum = 0l;\\n            int s=0; int e = n-1;\\n            \\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                \\n                if(nums[mid] <= i){ s = mid+1; }\\n                else{ e = mid-1; }\\n            }\\n            \\n            sum += s>0 ?((long)i * (long)s) - arr1[s-1] :0;\\n            \\n            sum += s<n ?arr2[s] - ((long)(n-s) * (long)i) :0;\\n            \\n            list.add(sum);\\n        }\\n        \\n        return list;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341955,
                "title": "java-python-3-sort-compute-prefix-sum-then-binary-search",
                "content": "Within each query, for each number in `nums`, if it is less than `q`,  we need to deduct it from `q` and get the number of  the increment operations; if it is NO less than `q`, we need to deduct `q` from the number to get the number of the decrement operations.\\n\\nTherfore, we can sort `nums`, then use prefix sum to compute the partial sum of the sorted `nums`. Use binary search to find the index of the `nums`, `idx`, to separate the less than  part and NO less than part. With these information we can compute the total operations needed for a specific query `q`.\\n\\n**Note:**\\n`nums[0 ...  idx - 1] <= q, nums[idx ... n - 1] > q`\\n`prefixSum[idx] = sum(nums[0 ...  idx - 1])`\\n`prefixSum[n] - prefixSum[idx] = sum(nums[idx ... n - 1])`\\n`idx * q - prefixSum[idx]` : # of increment operations needed for `nums[0 ...  idx - 1]`\\n`prefixSum[n] - prefixSum[idx] - (n - idx) * q`:  # of  decrement operations needed for `nums[idx ... n - 1]`\\n```java\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefixSum = new long[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\\n        }\\n        List<Long> ans = new ArrayList<>();\\n        for (int q : queries) {\\n            int idx = binarySearch(nums, q); // There are idx numbers in nums less than q.\\n            ans.add(1L * q * idx - prefixSum[idx] + prefixSum[n] - prefixSum[idx] - 1L * (n - idx) * q);\\n        }\\n        return ans;\\n    }\\n    private int binarySearch(int[] nums, int key) {\\n        int lo = 0, hi = nums.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (key > nums[mid]) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n```\\n```python\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        prefix_sum, n = [0], len(nums)\\n        for num in nums:\\n            prefix_sum.append(num + prefix_sum[-1])\\n        ans = []\\n        for q in queries:\\n            idx = bisect.bisect(nums, q) # There are idx numbers in nums less than q.\\n            ans.append(q * idx - prefix_sum[idx] + prefix_sum[-1] - prefix_sum[idx] - q * (n - idx))    \\n        return ans\\n```\\n\\n**Analysis:**\\n\\nLet `n = nums.length, m = queries.length`:\\nSort cost time `O(nlogn)`, each query cost time `O(logn)` and all quries cost `O(mlogn)`; `prefixSum` and sorting cost space `O(n)`, therefore\\n\\nTime: `O((m + n) * logn)`, space: `O(n)` (`O(m + n)` if including return space).",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefixSum = new long[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\\n        }\\n        List<Long> ans = new ArrayList<>();\\n        for (int q : queries) {\\n            int idx = binarySearch(nums, q); // There are idx numbers in nums less than q.\\n            ans.add(1L * q * idx - prefixSum[idx] + prefixSum[n] - prefixSum[idx] - 1L * (n - idx) * q);\\n        }\\n        return ans;\\n    }\\n    private int binarySearch(int[] nums, int key) {\\n        int lo = 0, hi = nums.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (key > nums[mid]) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n```\n```python\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        prefix_sum, n = [0], len(nums)\\n        for num in nums:\\n            prefix_sum.append(num + prefix_sum[-1])\\n        ans = []\\n        for q in queries:\\n            idx = bisect.bisect(nums, q) # There are idx numbers in nums less than q.\\n            ans.append(q * idx - prefix_sum[idx] + prefix_sum[-1] - prefix_sum[idx] - q * (n - idx))    \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3342694,
                "title": "prefix-sum-easy-to-understand-explained-using-example",
                "content": "# Intuition\\nThe brute force approach would be to iterate through the queries array and for each query, iterate through the nums array to calculate the number of operations for each element. However, this solution\\'s time complexity is O(n*m), which doesn\\'t satisfy the given constraint.\\n\\nAnother way is to calculate the prefix sum array, and then for each query, calculate the number of operations using the prefix sum. See the example below to understand better.\\n\\n### Example\\nFor nums=[3,1,6,4,8] and queries=[4,2]\\n\\nWe will first sort the nums array and then find the index where the element becomes greater than current element.\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/382d446e-e781-4364-8040-e589da875f9f_1679814220.262036.png)\\n\\n\\n\\n- prefix_sum= [0, 1, 4, 8, 14, 22]\\n\\n- left operations = (no. of elements smaller or equal to q) * q - sum of smaller or equal elements to q\\n\\n        = idx*q - prefix_sum[idx]\\n        = 3 * 4 - 8 = 4\\n- right operations = sum of elements greater than q - (no. of elements greater than q) * q \\n\\n         = (prefix_sum[n] - prefix_sum[idx]) - (n-idx) * q\\n         = 14 - 2 * 4 = 6\\n\\n- total operations = left+right\\n    \\n         = 4+6 = 10\\n\\nNow, it\\'s your turn to dry run the above approach for q=2. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long> ans;\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<long long> prefixSum(n+1);\\n\\n        prefixSum[0] = 0;\\n        for (int i=1;i<=n;++i) {\\n            prefixSum[i] = prefixSum[i-1] + (nums[i-1]) ; // calculating the prefix sum\\n        }\\n        for (long long q:queries) {\\n            auto itr = upper_bound(nums.begin(), nums.end(),q); // find the iterator where nums[idx]>q\\n            int idx = itr-nums.begin(); \\n            long long left= idx*q-prefixSum[idx]; // number of operations for smaller elements\\n            long long right= (prefixSum[n]-prefixSum[idx])-(n-idx)*q; // number of operations for larger elements\\n            // cout<<left<<\" \"<<right<<endl;\\n            ans.push_back(left + right);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long> ans;\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<long long> prefixSum(n+1);\\n\\n        prefixSum[0] = 0;\\n        for (int i=1;i<=n;++i) {\\n            prefixSum[i] = prefixSum[i-1] + (nums[i-1]) ; // calculating the prefix sum\\n        }\\n        for (long long q:queries) {\\n            auto itr = upper_bound(nums.begin(), nums.end(),q); // find the iterator where nums[idx]>q\\n            int idx = itr-nums.begin(); \\n            long long left= idx*q-prefixSum[idx]; // number of operations for smaller elements\\n            long long right= (prefixSum[n]-prefixSum[idx])-(n-idx)*q; // number of operations for larger elements\\n            // cout<<left<<\" \"<<right<<endl;\\n            ans.push_back(left + right);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3342296,
                "title": "c-binary-search-4-liner-easy-to-understand-a",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse binary search to find the position of the element (which we want make all elements to this element) in the sorted array. Then, store then answer using the formula in approach section\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`ans.push_back(1LL * x * (2 * i - n) + prefix[n] - 2 * prefix[i]);`\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<long long> ans, prefix(n + 1);\\n        for (int i = 0; i < n; i++)\\n            prefix[i + 1] = prefix[i] + (long long) nums[i];\\n        for (int x : queries) {\\n            int i = lower_bound(nums.begin(), nums.end(), x) - nums.begin();\\n            ans.push_back(1LL * x * (2 * i - n) + prefix[n] - 2 * prefix[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<long long> ans, prefix(n + 1);\\n        for (int i = 0; i < n; i++)\\n            prefix[i + 1] = prefix[i] + (long long) nums[i];\\n        for (int x : queries) {\\n            int i = lower_bound(nums.begin(), nums.end(), x) - nums.begin();\\n            ans.push_back(1LL * x * (2 * i - n) + prefix[n] - 2 * prefix[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342243,
                "title": "optimal-approach-prefix-sum-binary-search-fully-explained-approach-o-n-log-n-c",
                "content": "# Approach\\n- We want to make all the numbers equal to $$x$$.\\n- There can be two types of numbers in the array ->\\n  1. that are $$<= x$$ (Type 1)\\n  2. that are $$> x$$ (Type 2)\\n- For numbers of **type 1** $$(<=x)$$, we would increase their value to make them equal to $$x$$.\\n Suppose there are $$a$$ numbers that are $$<=x$$. The operations required to change all these numbers to $$x$$ will be $$a*x$$ $$-$$ $$(sum$$ $$of$$ $$all$$ $$these$$ $$numbers) $$ \\n\\n\\n\\n- For numbers of **type 2** $$(>x)$$, we would decrease their value to make them equal to $$x$$.\\n Suppose there are $$b$$ numbers that are $$>x$$. The operations required to change all these numbers to $$x$$ will be $$(sum$$ $$of$$ $$all$$ $$these$$ $$numbers)$$ $$-$$ $$b*x$$  \\n\\n- **Note-** We can find sum in O(1) by using prefix array.\\n\\n- The total number of operations would be the sum of operations of both.\\n\\nFor example, nums = [3,1,6,8], queries = [1,5]\\n\\n![parth lc 2602 soln.jpg](https://assets.leetcode.com/users/images/8fab782c-c990-4ea4-8f65-727bbed120a9_1679808299.6859477.jpeg)\\n\\n\\n# Complexity\\n- Time complexity : $$O(N * log N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n\\n        vector<ll> pre(n,0);\\n        pre[0]=1ll*nums[0];\\n        for(int i=1 ; i<n ; i++) pre[i]=pre[i-1]+1ll*nums[i];\\n        \\n        vector<ll> ans;\\n        for(int q:queries) {\\n            auto it = --upper_bound(nums.begin(),nums.end(),q);\\n            int i = it - nums.begin();\\n            \\n            long long x = (i<0) ? 0 : (1ll*(i+1)*q - pre[i]);\\n            long long y = (i<0) ? (pre[n-1] - 1ll*n*q) : (pre[n-1] - pre[i] - 1ll*(n-i-1)*q);\\n            \\n            ans.push_back(x+y);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Do let me know if you have any doubt in the solution\\u2714.\\n## Please upvote\\uD83D\\uDD3C if you liked the solution\\n## \\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/945d1086-e6fa-418c-b9db-f0ffe3083328_1679817112.9945686.png)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n\\n        vector<ll> pre(n,0);\\n        pre[0]=1ll*nums[0];\\n        for(int i=1 ; i<n ; i++) pre[i]=pre[i-1]+1ll*nums[i];\\n        \\n        vector<ll> ans;\\n        for(int q:queries) {\\n            auto it = --upper_bound(nums.begin(),nums.end(),q);\\n            int i = it - nums.begin();\\n            \\n            long long x = (i<0) ? 0 : (1ll*(i+1)*q - pre[i]);\\n            long long y = (i<0) ? (pre[n-1] - 1ll*n*q) : (pre[n-1] - pre[i] - 1ll*(n-i-1)*q);\\n            \\n            ans.push_back(x+y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342581,
                "title": "easiest-solution-ever-just-binary-search",
                "content": "# Intuition\\nSIMPLY BINARY SEARCH \\n\\n# Approach\\nSS APROACH\\nJUST SMILE AND SOLVE\\n\\n# Complexity\\nNOTHING COMPLEX\\n\\n# PLEASE UPVOTE\\nPLEASE UPVOTE IF I HELPED YOU \\nTHANK YOU\\nLOVE FOR YOU \\n\\n# Code\\n```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        \\n        int n = nums.length;\\n        int m = queries.length;\\n        \\n        List<Long> list = new ArrayList<>();\\n        \\n        Arrays.sort(nums);\\n        long[] arr1 = new long[n];\\n        long[] arr2 = new long[n];\\n        \\n        arr1[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            arr1[i] = arr1[i-1]+nums[i];\\n        }\\n        \\n        arr2[n-1] = nums[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            arr2[i] = arr2[i+1]+nums[i];\\n        }\\n        \\n        for(int i : queries){\\n            long sum = 0l;\\n            int s=0; int e = n-1;\\n            \\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                \\n                if(nums[mid] <= i){ s = mid+1; }\\n                else{ e = mid-1; }\\n            }\\n            \\n            sum += s>0 ?((long)i * (long)s) - arr1[s-1] :0;\\n            \\n            sum += s<n ?arr2[s] - ((long)(n-s) * (long)i) :0;\\n            \\n            list.add(sum);\\n        }\\n        \\n        return list;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        \\n        int n = nums.length;\\n        int m = queries.length;\\n        \\n        List<Long> list = new ArrayList<>();\\n        \\n        Arrays.sort(nums);\\n        long[] arr1 = new long[n];\\n        long[] arr2 = new long[n];\\n        \\n        arr1[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            arr1[i] = arr1[i-1]+nums[i];\\n        }\\n        \\n        arr2[n-1] = nums[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            arr2[i] = arr2[i+1]+nums[i];\\n        }\\n        \\n        for(int i : queries){\\n            long sum = 0l;\\n            int s=0; int e = n-1;\\n            \\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                \\n                if(nums[mid] <= i){ s = mid+1; }\\n                else{ e = mid-1; }\\n            }\\n            \\n            sum += s>0 ?((long)i * (long)s) - arr1[s-1] :0;\\n            \\n            sum += s<n ?arr2[s] - ((long)(n-s) * (long)i) :0;\\n            \\n            list.add(sum);\\n        }\\n        \\n        return list;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342315,
                "title": "easy-c-solution-using-binary-search-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve each query in log n time using binary search (upper_bound) and prefix sum in sorted array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the array.\\n2. Calculate prefix sum array of size n+1, and calcculate sum of all element along with that.\\n3. Find upper bound for each query. check if query is greater then maximum element then push ans as n*query - total sum, if query is smaller then smallest element of array then push ans as total sum- n*query.\\n4. If above two condition not satify then we will use upper bound to divide the array into two parts, in first part we will find sum of first part using index of upper bound and prefix sum and subtract first part sum with (ind)*query where ind is index of upper bound. and in second part subtract (n-ind)*query from sum of seccond part. Add both part and push into ans.\\n5. return the ans\\n\\n# Complexity\\n- Time complexity: O(N*LOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long> ans,pre;\\n        sort(nums.begin(),nums.end());\\n        long long sum=0;\\n        pre.push_back(0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            pre.push_back(sum);\\n        }\\n        int n=nums.size();\\n        for(int i=0;i<queries.size();i++)\\n        {\\n           int c=queries[i];\\n           auto b=upper_bound(nums.begin(),nums.end(),c);\\n           if(c>=nums[n-1])\\n           {\\n              ans.push_back((long long)n*(long long)c  - sum);\\n           }\\n           else if(c<=nums[0])\\n           {\\n               ans.push_back(sum-(long long)n*(long long)c);\\n           }\\n           else\\n           {\\n               int ind=b-nums.begin();\\n               long long  res=abs((sum-pre[ind])-(long long)(n-ind)*(long long)c);\\n               res+=abs((long long)ind*(long long)c -pre[ind]);\\n               ans.push_back(res);\\n           }\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long> ans,pre;\\n        sort(nums.begin(),nums.end());\\n        long long sum=0;\\n        pre.push_back(0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            pre.push_back(sum);\\n        }\\n        int n=nums.size();\\n        for(int i=0;i<queries.size();i++)\\n        {\\n           int c=queries[i];\\n           auto b=upper_bound(nums.begin(),nums.end(),c);\\n           if(c>=nums[n-1])\\n           {\\n              ans.push_back((long long)n*(long long)c  - sum);\\n           }\\n           else if(c<=nums[0])\\n           {\\n               ans.push_back(sum-(long long)n*(long long)c);\\n           }\\n           else\\n           {\\n               int ind=b-nums.begin();\\n               long long  res=abs((sum-pre[ind])-(long long)(n-ind)*(long long)c);\\n               res+=abs((long long)ind*(long long)c -pre[ind]);\\n               ans.push_back(res);\\n           }\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347750,
                "title": "day-361-100-0ms-explained-dry-run-meme",
                "content": "# Please Upvote as it really motivates me\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### \\u2022\\tThe intuition behind this code is to first sort the input array of numbers and the array of queries. Then, for each query, we calculate the prefix sum of all numbers in the input array that are less than the current query. We use this prefix sum to calculate the number of operations required to make all numbers in the input array equal to the query.\\n##### \\u2022\\tTo do this, we first calculate the total sum of all numbers in the input array. Then, we subtract twice the prefix sum from this total sum, since we need to add q to all numbers less than q and subtract q from all numbers greater than q. The factor of 2 is because we need to perform both additions and subtractions. Finally, we add q times the number of elements less than q that we have already processed, since we have already added q to these elements.\\n##### \\u2022\\tThis approach allows us to efficiently calculate the answer for each query in O(n log n) time, where n is the length of the input array.\\n\\n\\n\\n# Explain\\n<!-- Describe your approach to solving the problem. -->\\n\\n##### \\u2022\\tThe code is implementing the following approach:\\n\\n##### \\u2022\\tSort the input array of numbers in ascending order using the sort() function from the STL library.\\n##### \\u2022\\tsort(nums.begin(), nums.end());\\n##### \\u2022\\tCreate a vector of pairs called aug to store the queries and their respective indices. For each query in the input array queries, create a pair with the query value and its index and add it to the aug vector.\\n##### \\u2022\\tvector<pair<int, int>> aug;\\n##### \\u2022\\tfor (int i = 0; i < queries.size(); ++i) {\\n##### \\u2022\\taug.emplace_back(queries[i], i);\\n##### \\u2022\\t}\\n##### \\u2022\\tSort the aug vector of pairs in increasing order of query value.\\n##### \\u2022\\tsort(aug.begin(), aug.end());\\n##### \\u2022\\tCreate a new vector called ans to store the answers for each query. The size of ans is the same as the size of queries.\\n##### \\u2022\\tvector<long long> ans(queries.size());\\n##### \\u2022\\tCalculate the total sum of all numbers in the input array nums using the accumulate() function from the STL library.\\n##### \\u2022\\tlong long total = accumulate(nums.begin(), nums.end(), 0ll);\\n##### \\u2022\\tInitialize a variable called prefix to 0. This variable will be used to calculate the prefix sum of all numbers in nums that are less than the current query.\\n##### \\u2022\\tlong long prefix = 0;\\n##### \\u2022\\tInitialize a variable called k to 0. This variable will be used to keep track of the number of elements in nums that are less than the current query.\\n##### \\u2022\\tint k = 0;\\n##### \\u2022\\tLoop through each pair in the aug vector. For each pair, calculate the number of operations required to make all numbers in nums equal to the current query.\\n##### \\u2022\\tfor (auto& [q, i] : aug) {\\n##### \\u2022\\t// Calculate prefix sum of all numbers less than q\\n##### \\u2022\\twhile (k < nums.size() && nums[k] < q)\\no\\tprefix += nums[k++];\\n##### \\u2022\\t// Calculate answer for current query\\n##### \\u2022\\tans[i] = total - 2*prefix + (long long) q*(2*k - nums.size());\\n##### \\u2022\\t}\\n##### \\u2022\\tReturn the ans vector, which contains the answers for all queries.\\n##### \\u2022\\treturn ans;\\n##### \\u2022\\tOverall, the approach involves sorting the input array and the queries, and then iterating through the queries and calculating the prefix sum of all numbers less than the current query. This prefix sum is then used to calculate the number of operations required to make all numbers in the input array equal to the current query.\\n\\n\\n\\n\\n# Code\\n```c++ []\\nvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n    sort(nums.begin(), nums.end());\\n    vector<pair<int, int>> aug;\\n    for (int i = 0; i < queries.size(); ++i) {\\n        aug.emplace_back(queries[i], i);\\n    }\\n    sort(aug.begin(), aug.end());\\n    vector<long long> ans(queries.size());\\n    long long total = accumulate(nums.begin(), nums.end(), 0ll);\\n    long long prefix = 0;\\n    int k = 0;\\n    for (auto& [q, i] : aug) {\\n        while (k < nums.size() && nums[k] < q) {\\n            prefix += nums[k];\\n            k++;\\n        }\\n        ans[i] = total - 2 * prefix + (long long) q * (2 * k - nums.size());\\n    }\\n    return ans;\\n}\\n```\\n```python []\\ndef minOperations(self,nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        aug = [(q, i) for i, q in enumerate(queries)]\\n        aug.sort()\\n        total = sum(nums)\\n        prefix = 0\\n        k = 0\\n        ans = [0] * len(queries)\\n        for q, i in aug:\\n            while k < len(nums) and nums[k] < q:\\n                prefix += nums[k]\\n                k += 1\\n            ans[i] = total - 2 * prefix + q * (2 * k - len(nums))\\n        return ans\\n```\\n```java []\\npublic List<Long> minOperations(int[] nums, int[] queries) {\\n        int n = nums.length,m = queries.length;\\n        \\n        Arrays.sort(nums);\\n        \\n        long[] psum = new long[n + 1];\\n        for(int i = 0;i < n;i++) psum[i + 1] = psum[i] + nums[i];\\n        \\n        List<Long> ans = new ArrayList<>();\\n        \\n        for(int i = 0;i < m;i++){\\n            \\n            int si = 0,ei = n - 1,idx = 0;\\n            while(si <= ei){\\n                int mid = si + (ei - si) / 2;\\n                \\n                if(nums[mid] <= queries[i]){\\n                    idx = mid + 1;\\n                    si = mid + 1;\\n                }else{\\n                    idx = mid;\\n                    ei = mid - 1;\\n                }\\n            }\\n            \\n            long left = (1L * queries[i] * idx) - psum[si]; \\n            long right = (psum[n] - psum[idx]) - (1L * queries[i] * (n - idx));\\n            \\n            ans.add(left + right);\\n        }\\n        return ans;\\n    }\\n# explaination\\n\\n\\n##### \\u2022\\tThe minOperations function takes two integer arrays as input, nums and queries, and returns a list of long integers as output. For each query in the queries array, the function computes the minimum number of operations required to make all the elements in the nums array greater than or equal to the query value.\\n\\n##### \\u2022\\tFirst, the function initializes two variables, n and m, to the lengths of the nums and queries arrays respectively. It then sorts the nums array in ascending order using Arrays.sort().\\n\\n##### \\u2022\\tNext, the function initializes a new array called psum of length n + 1. It then populates the psum array with prefix sums of the nums array using a for loop. Specifically, it sets psum[0] to 0, and for each index i from 0 to n - 1, it sets psum[i + 1] to psum[i] + nums[i].\\n\\n##### \\u2022\\tThe function then initializes an empty list called ans to store the results of each query.\\n\\n##### \\u2022\\tFor each query in the queries array, the function performs a binary search on the nums array to find the index of the first element that is greater than the query value. It initializes three variables, si, ei, and idx, to 0, n - 1, and 0 respectively. It then enters a while loop that continues as long as si is less than or equal to ei. In each iteration of the loop, it calculates the midpoint of the current search range using (si + ei) / 2. If the midpoint element is less than or equal to the query value, it updates idx to the midpoint index plus 1, and sets si to the midpoint index plus 1. Otherwise, it updates idx to the midpoint index, and sets ei to the midpoint index minus 1. Once the loop exits, idx will contain the index\\n\\n\\n\\n```\\nHERE https://leetcode.com/problems/minimum-operations-to-make-all-array-elements-equal/solutions/3347750/100-0ms-explained-dry-run-meme/\\n\\n# DRY RUN 1\\nFirst, we sort the nums vector in ascending order: nums = [1, 3, 6, 8]. Next, we create a new vector called aug, which will store pairs of each query and its index in the queries vector. In this case, aug = [(1, 0), (5, 1)]. We sort the aug vector in ascending order based on the query value: aug = [(1, 0), (5, 1)]. We create a new vector called ans to store the results of each query. We calculate the total sum of the nums vector using the accumulate function: total = 18. We initialize the prefix variable to 0. We set k to 0. We loop through each pair in the aug vector. For the first pair, q = 1 and i = 0. For the second pair, q = 5 and i = 1. For each pair, we loop through the nums vector while k < nums.size() and nums[k] < q. In this case, k starts at 0 and nums[k] = 1, which is less than q = 1, so we do not enter the loop. For the second pair, k is still 0 and nums[k] = 1, which is less than q = 5, so we enter the loop. We add nums[k] = 1 to prefix, increment k to 1, and check if nums[k] < q. Since nums[k] = 3 is less than q = 5, we add nums[k] = 3 to prefix, increment k to 2, and check again. Since nums[k] = 6 is not less than q = 5, we exit the loop. For the first pair, we calculate ans[i] = total - 2prefix + (long long) q(2k - nums.size()) = 18 - 20 + (long long) 1*(20 - 4) = 14. For the second pair, we calculate ans[i] = total - 2prefix + (long long) q*(2k - nums.size()) = 18 - 24 + (long long) 5*(2*2 - 4) = 10. We return the ans vector: [14, 10].\\n\\n# dry run 2\\n\\nFirst, we sort the nums vector in ascending order: nums = [2, 3, 6, 9]. Next, we create a new vector called aug, which will store pairs of each query and its index in the queries vector. In this case, aug = [(10, 0)]. We sort the aug vector in ascending order based on the query value: aug = [(10, 0)]. We create a new vector called ans to store the results of each query. We calculate the total sum of the nums vector using the accumulate function: total = 20. We initialize the prefix variable to 0. We set k to 0. We loop through each pair in the aug vector. For the only pair, q = 10 and i = 0. For the pair, we loop through the nums vector while k < nums.size() and nums[k] < q. In this case, k starts at 0 and nums[k] = 2, which is less than q = 10, so we enter the loop. We add nums[k] = 2 to prefix, increment k to 1, and check if nums[k] < q. Since nums[k] = 3 is less than q = 10, we add nums[k] = 3 to prefix, increment k to 2, and check again. Since nums[k] = 6 is less than q = 10, we add nums[k] = 6 to prefix, increment k to 3, and check again. Since nums[k] = 9 is not less than q = 10, we exit the loop. For the pair, we calculate ans[i] = total - 2 * prefix + (long long) q * (2 * k - nums.size()) = 20 - 2 * (2 + 3 + 6) + (long long) 10 * (2 * 4 - 4) = 20. We return the ans vector: [20].\\n\\n# Complexity\\n# Time complexity: \\nO(nlogn + qlogq), where n is the length of the nums vector and q is the length of the queries vector. The sort function has a time complexity of O(nlogn) for sorting the nums vector and O(qlogq) for sorting the aug vector. The while loop inside the for loop has a time complexity of O(n) in the worst case, but since k is incremented at each iteration, the total time complexity of the while loop is O(n) for all iterations of the for loop. Therefore, the overall time complexity of the code is dominated by the sort function, which has a time complexity of O(nlogn + qlogq).\\n\\n# Space complexity: \\nO(q), where q is the length of the queries vector. The aug vector has a space complexity of O(q) and the ans vector has a space complexity of O(q), so the total space complexity of the code is O(q).\\n\\n![meme2.png](https://assets.leetcode.com/users/images/2c7cfc1f-c87f-4834-ae01-1a77f1492a41_1679859715.9243956.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```c++ []\\nvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n    sort(nums.begin(), nums.end());\\n    vector<pair<int, int>> aug;\\n    for (int i = 0; i < queries.size(); ++i) {\\n        aug.emplace_back(queries[i], i);\\n    }\\n    sort(aug.begin(), aug.end());\\n    vector<long long> ans(queries.size());\\n    long long total = accumulate(nums.begin(), nums.end(), 0ll);\\n    long long prefix = 0;\\n    int k = 0;\\n    for (auto& [q, i] : aug) {\\n        while (k < nums.size() && nums[k] < q) {\\n            prefix += nums[k];\\n            k++;\\n        }\\n        ans[i] = total - 2 * prefix + (long long) q * (2 * k - nums.size());\\n    }\\n    return ans;\\n}\\n```\n```python []\\ndef minOperations(self,nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        aug = [(q, i) for i, q in enumerate(queries)]\\n        aug.sort()\\n        total = sum(nums)\\n        prefix = 0\\n        k = 0\\n        ans = [0] * len(queries)\\n        for q, i in aug:\\n            while k < len(nums) and nums[k] < q:\\n                prefix += nums[k]\\n                k += 1\\n            ans[i] = total - 2 * prefix + q * (2 * k - len(nums))\\n        return ans\\n```\n```java []\\npublic List<Long> minOperations(int[] nums, int[] queries) {\\n        int n = nums.length,m = queries.length;\\n        \\n        Arrays.sort(nums);\\n        \\n        long[] psum = new long[n + 1];\\n        for(int i = 0;i < n;i++) psum[i + 1] = psum[i] + nums[i];\\n        \\n        List<Long> ans = new ArrayList<>();\\n        \\n        for(int i = 0;i < m;i++){\\n            \\n            int si = 0,ei = n - 1,idx = 0;\\n            while(si <= ei){\\n                int mid = si + (ei - si) / 2;\\n                \\n                if(nums[mid] <= queries[i]){\\n                    idx = mid + 1;\\n                    si = mid + 1;\\n                }else{\\n                    idx = mid;\\n                    ei = mid - 1;\\n                }\\n            }\\n            \\n            long left = (1L * queries[i] * idx) - psum[si]; \\n            long right = (psum[n] - psum[idx]) - (1L * queries[i] * (n - idx));\\n            \\n            ans.add(left + right);\\n        }\\n        return ans;\\n    }\\n# explaination\\n\\n\\n##### \\u2022\\tThe minOperations function takes two integer arrays as input, nums and queries, and returns a list of long integers as output. For each query in the queries array, the function computes the minimum number of operations required to make all the elements in the nums array greater than or equal to the query value.\\n\\n##### \\u2022\\tFirst, the function initializes two variables, n and m, to the lengths of the nums and queries arrays respectively. It then sorts the nums array in ascending order using Arrays.sort().\\n\\n##### \\u2022\\tNext, the function initializes a new array called psum of length n + 1. It then populates the psum array with prefix sums of the nums array using a for loop. Specifically, it sets psum[0] to 0, and for each index i from 0 to n - 1, it sets psum[i + 1] to psum[i] + nums[i].\\n\\n##### \\u2022\\tThe function then initializes an empty list called ans to store the results of each query.\\n\\n##### \\u2022\\tFor each query in the queries array, the function performs a binary search on the nums array to find the index of the first element that is greater than the query value. It initializes three variables, si, ei, and idx, to 0, n - 1, and 0 respectively. It then enters a while loop that continues as long as si is less than or equal to ei. In each iteration of the loop, it calculates the midpoint of the current search range using (si + ei) / 2. If the midpoint element is less than or equal to the query value, it updates idx to the midpoint index plus 1, and sets si to the midpoint index plus 1. Otherwise, it updates idx to the midpoint index, and sets ei to the midpoint index minus 1. Once the loop exits, idx will contain the index\\n\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3342113,
                "title": "java-solution-100-faster-binarysearch",
                "content": "**Search for all the numbers smaller than the query element the sum total should be number of element*query if sum of all smaller elements is  less then we need to add the difference number of time  And in the case of larger element we need to subtract the Sum total from sum of larger elements!!!**\\n```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        long prefix[]=new long[n];\\n        ArrayList<Long> list=new ArrayList<>();\\n        prefix[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=0;i<queries.length;i++){\\n            int l=0;\\n            int r=n-1;\\n            long max=(long)queries[i]*n;\\n            while(l<r){\\n                int mid=(l+r)>>1;\\n                if(nums[mid]<queries[i]){\\n                    l=mid+1;\\n                }\\n                else{\\n                    r=mid;\\n                }\\n            }\\n\\t\\t\\t//no smaller element\\n            if(l<=0){\\n                long diff=(long)Math.abs(prefix[n-1]-max);\\n                list.add(diff);\\n                continue;\\n            }\\n\\t\\t\\t//all smaller\\n            if(l>=n-1){\\n                long diff=(long)Math.abs(max-prefix[n-1]);\\n                list.add(diff);\\n                continue;\\n            }\\n            else{\\n                int lowerHalfEnd=l;\\n                if(nums[l]!=queries[i]){\\n                    lowerHalfEnd=l-1;\\n                }\\n                long smallerMax=(long)queries[i]*(lowerHalfEnd+1);\\n                long LargerMax=(long)queries[i]*(n-lowerHalfEnd-1);\\n                long total=(long)(smallerMax-prefix[lowerHalfEnd])+(prefix[n-1]-prefix[lowerHalfEnd]-LargerMax);\\n                list.add(total);\\n            }\\n        }\\n        return list;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        long prefix[]=new long[n];\\n        ArrayList<Long> list=new ArrayList<>();\\n        prefix[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=0;i<queries.length;i++){\\n            int l=0;\\n            int r=n-1;\\n            long max=(long)queries[i]*n;\\n            while(l<r){\\n                int mid=(l+r)>>1;\\n                if(nums[mid]<queries[i]){\\n                    l=mid+1;\\n                }\\n                else{\\n                    r=mid;\\n                }\\n            }\\n\\t\\t\\t//no smaller element\\n            if(l<=0){\\n                long diff=(long)Math.abs(prefix[n-1]-max);\\n                list.add(diff);\\n                continue;\\n            }\\n\\t\\t\\t//all smaller\\n            if(l>=n-1){\\n                long diff=(long)Math.abs(max-prefix[n-1]);\\n                list.add(diff);\\n                continue;\\n            }\\n            else{\\n                int lowerHalfEnd=l;\\n                if(nums[l]!=queries[i]){\\n                    lowerHalfEnd=l-1;\\n                }\\n                long smallerMax=(long)queries[i]*(lowerHalfEnd+1);\\n                long LargerMax=(long)queries[i]*(n-lowerHalfEnd-1);\\n                long total=(long)(smallerMax-prefix[lowerHalfEnd])+(prefix[n-1]-prefix[lowerHalfEnd]-LargerMax);\\n                list.add(total);\\n            }\\n        }\\n        return list;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775301,
                "title": "c-easy-solution-beats-100-binary-search-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &nums,int temp)\\n    {\\n        int n = nums.size();\\n        int ans=-1;\\n        int l=0,h=n-1;\\n        while(l<=h)\\n        {\\n            int m = (l+h)/2;\\n            if(nums[m]>=temp)\\n            {\\n                ans=m;\\n                h=m-1;\\n            }\\n            else\\n            l=m+1;\\n        }\\n        return ans;\\n    }\\n\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        int n = nums.size();\\n        int m = q.size();\\n        vector<long long> v;\\n        sort(nums.begin(),nums.end());\\n        vector<long long> p(n+1, 0);\\n        for(int i=0;i<n;i++)\\n        {\\n            p[i+1] = p[i]+nums[i];\\n        }\\n        for(auto it:q)\\n        {\\n            if(it<nums[0] || it>nums[n-1])\\n            {\\n                v.push_back(abs(p[n]-(it*1LL*n)));\\n                continue;\\n            }\\n            int temp = f(nums,it);\\n            long long sum = abs(p[temp]-(temp*1LL*it))+abs(p[n]-p[temp]-((n-temp)*1LL*it));\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<int> &nums,int temp)\\n    {\\n        int n = nums.size();\\n        int ans=-1;\\n        int l=0,h=n-1;\\n        while(l<=h)\\n        {\\n            int m = (l+h)/2;\\n            if(nums[m]>=temp)\\n            {\\n                ans=m;\\n                h=m-1;\\n            }\\n            else\\n            l=m+1;\\n        }\\n        return ans;\\n    }\\n\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        int n = nums.size();\\n        int m = q.size();\\n        vector<long long> v;\\n        sort(nums.begin(),nums.end());\\n        vector<long long> p(n+1, 0);\\n        for(int i=0;i<n;i++)\\n        {\\n            p[i+1] = p[i]+nums[i];\\n        }\\n        for(auto it:q)\\n        {\\n            if(it<nums[0] || it>nums[n-1])\\n            {\\n                v.push_back(abs(p[n]-(it*1LL*n)));\\n                continue;\\n            }\\n            int temp = f(nums,it);\\n            long long sum = abs(p[temp]-(temp*1LL*it))+abs(p[n]-p[temp]-((n-temp)*1LL*it));\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503219,
                "title": "c-binary-search-easy-to-uderstand",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<ll> v;//ans array\\n        vector<ll> ps;//previous sum array\\n        sort(nums.begin(),nums.end());\\n        ll sum = 0,s;\\n        for(auto &i: nums){sum += i;ps.push_back(sum);}\\n        int x = 0,n=nums.size();\\n        for(auto &i: queries){\\n            x = upper_bound(nums.begin(),nums.end(),i)-nums.begin();//binary search\\n            if(x==0){\\n                v.push_back((sum-n*1LL*i));\\n            } else if(x==n){\\n                v.push_back((x*1LL*i - ps[x-1]));\\n            }else{\\n                v.push_back((x*1LL*i - ps[x-1]) + (sum-ps[x-1]-i*1LL*(n-x)));\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<ll> v;//ans array\\n        vector<ll> ps;//previous sum array\\n        sort(nums.begin(),nums.end());\\n        ll sum = 0,s;\\n        for(auto &i: nums){sum += i;ps.push_back(sum);}\\n        int x = 0,n=nums.size();\\n        for(auto &i: queries){\\n            x = upper_bound(nums.begin(),nums.end(),i)-nums.begin();//binary search\\n            if(x==0){\\n                v.push_back((sum-n*1LL*i));\\n            } else if(x==n){\\n                v.push_back((x*1LL*i - ps[x-1]));\\n            }else{\\n                v.push_back((x*1LL*i - ps[x-1]) + (sum-ps[x-1]-i*1LL*(n-x)));\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344695,
                "title": "c-most-easy-solution-using-prefix-suffix-sum-and-binary-search",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        ll m=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<ll> suff(m,0);\\n        vector<ll>pref(m,0);\\n        vector<ll> ans;\\n        suff[m-1]=nums[m-1];\\n        pref[0]=nums[0];\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            suff[i]=nums[i]+suff[i+1];// calculating the suffix sum\\n        }\\n        for(int i=1;i<m;i++)\\n            pref[i]=pref[i-1]+nums[i];// calculating the prefix sum\\n        for(int i=0;i<queries.size();i++)\\n        {\\n           ll ind=lower_bound(nums.begin(),nums.end(),queries[i])-nums.begin();\\n            ll inl=ind*queries[i]*1LL; // no of elements to left of index is ind\\n            ll rl=(m-ind)*queries[i]*1LL;//no of elements to right of index is m-ind where m is no of elements present in array\\n\\t\\t\\t                                          //multiplying with queries[i] gives the sum required\\n            ll sum=0;\\n            // cout<<ind<<endl;\\n            //cout<<inl<<\" \"<<rl<<endl;\\n            if(ind==m)\\n            {\\n                ans.push_back(inl-pref[m-1]);\\n                continue;\\n            }\\n            if(ind-1>=0)\\n            {\\n                sum+=(inl-pref[ind-1]);\\n            }\\n            sum+=(suff[ind]-rl);\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        ll m=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<ll> suff(m,0);\\n        vector<ll>pref(m,0);\\n        vector<ll> ans;\\n        suff[m-1]=nums[m-1];\\n        pref[0]=nums[0];\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            suff[i]=nums[i]+suff[i+1];// calculating the suffix sum\\n        }\\n        for(int i=1;i<m;i++)\\n            pref[i]=pref[i-1]+nums[i];// calculating the prefix sum\\n        for(int i=0;i<queries.size();i++)\\n        {\\n           ll ind=lower_bound(nums.begin(),nums.end(),queries[i])-nums.begin();\\n            ll inl=ind*queries[i]*1LL; // no of elements to left of index is ind\\n            ll rl=(m-ind)*queries[i]*1LL;//no of elements to right of index is m-ind where m is no of elements present in array\\n\\t\\t\\t                                          //multiplying with queries[i] gives the sum required\\n            ll sum=0;\\n            // cout<<ind<<endl;\\n            //cout<<inl<<\" \"<<rl<<endl;\\n            if(ind==m)\\n            {\\n                ans.push_back(inl-pref[m-1]);\\n                continue;\\n            }\\n            if(ind-1>=0)\\n            {\\n                sum+=(inl-pref[ind-1]);\\n            }\\n            sum+=(suff[ind]-rl);\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3342275,
                "title": "c-sorting-binary-search-prefix-sum-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPartition the array in set of elements greeater than queries[i] and set of elements smaller than queries[i]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nAfter partitioning \\nFor smaller set \\nrequired value to be added = (no.of elements * queries[i])- (sum of all elements)\\nFor greater set \\nrequired value to be added = (sum of all elements)-(no.of elements * queries[i])\\nadd both values and push into answer vector\\n\\nDo above process m query length times  \\n\\n\\n# Complexity\\n- Time complexity:O(nlogn + mlogn + n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) Prefix array \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long n=nums.size(), m=queries.size();\\n\\n        vector<long long> ans;\\n        sort(nums.begin(), nums.end());\\n\\n        vector<long long> prefix(n);\\n        for(int i=0;i<n;i++) prefix[i]=(long long)nums[i];\\n        for(int i=1;i<n;i++){\\n            prefix[i]+=prefix[i-1];\\n        }\\n\\n        for(int i=0;i<queries.size();i++){\\n            long long value=queries[i];\\n            int index=-1;\\n            \\n            long long low=0, high=n-1;\\n            while(low<=high){\\n                long long mid=low+(high-low)/2;\\n                if(nums[mid]<=value){\\n                    index=mid;\\n                    low=mid+1;\\n                }\\n                else high=mid-1;          \\n            }\\n            if(index==-1){\\n                ans.push_back(prefix[n-1]-(value*n));\\n            }\\n            else{\\n                long long req1=(index+1)*value-prefix[index];\\n                long long req2=(prefix[n-1]-prefix[index])-(n-index-1)*value;\\n                ans.push_back(req1+req2);               \\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long n=nums.size(), m=queries.size();\\n\\n        vector<long long> ans;\\n        sort(nums.begin(), nums.end());\\n\\n        vector<long long> prefix(n);\\n        for(int i=0;i<n;i++) prefix[i]=(long long)nums[i];\\n        for(int i=1;i<n;i++){\\n            prefix[i]+=prefix[i-1];\\n        }\\n\\n        for(int i=0;i<queries.size();i++){\\n            long long value=queries[i];\\n            int index=-1;\\n            \\n            long long low=0, high=n-1;\\n            while(low<=high){\\n                long long mid=low+(high-low)/2;\\n                if(nums[mid]<=value){\\n                    index=mid;\\n                    low=mid+1;\\n                }\\n                else high=mid-1;          \\n            }\\n            if(index==-1){\\n                ans.push_back(prefix[n-1]-(value*n));\\n            }\\n            else{\\n                long long req1=(index+1)*value-prefix[index];\\n                long long req2=(prefix[n-1]-prefix[index])-(n-index-1)*value;\\n                ans.push_back(req1+req2);               \\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342205,
                "title": "prefix-suffix-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<long long> ps(n + 1), ss(n + 1), ans;\\n        for(int i=1; i<=n; i++) ps[i]  = ps[i - 1] + nums[i  - 1];\\n        for(int i=n-1; i>=0; i--) ss[i] = ss[i + 1] + nums[i];\\n        \\n        for(int q : queries) {\\n            long long pos = lower_bound(nums.begin(), nums.end(), q) - nums.begin();\\n            long long val = pos * q  - ps[pos] + ss[pos] - (n - pos) * q;\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Suffix Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<long long> ps(n + 1), ss(n + 1), ans;\\n        for(int i=1; i<=n; i++) ps[i]  = ps[i - 1] + nums[i  - 1];\\n        for(int i=n-1; i>=0; i--) ss[i] = ss[i + 1] + nums[i];\\n        \\n        for(int q : queries) {\\n            long long pos = lower_bound(nums.begin(), nums.end(), q) - nums.begin();\\n            long long val = pos * q  - ps[pos] + ss[pos] - (n - pos) * q;\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342032,
                "title": "detailed-explanation-of-code-and-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy intuition is simpler just finding the number of element that are smaller than ith element of query and using prefix sum find its sum and similarly for the element that are greater than the ith element of query.Then, calculate the answer by taking difference from prefixsum and the (numberofelement * i*th* elementofquery). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialize variables:\\n\\n->m is the size of the q vector (number of queries).\\n->n is the size of the nums vector (number of elements in the array).\\n->ans is a vector of size m initialized with zeros, used to store the final answer for each query.\\n->sum is a vector of size n initialized with zeros, used to store the prefix sum of the sorted nums vector.\\n\\n2.Sort the nums vector in non-decreasing order.\\n\\n3.Calculate the prefix sum of the sorted nums vector and store it in the sum vector.\\n\\n4.Iterate through each query in q:\\na. Find the first element that is greater than the queried value q[i] using upper_bound from the C++ Standard Library. This function returns an iterator pointing to the first element that is greater than the given value.\\nb. Calculate the index of the found element in the nums vector.\\nc. Calculate the sum of the elements lower than the queried value (lower_sum) and the sum of the elements greater than the queried value (upper_sum) using the prefix sum.\\nd. Calculate the total cost for both the lower elements (final_lower_sum) and the upper elements (final_upper_sum).\\ne. Add both costs and store the result in the ans vector.\\n\\nReturn the ans vector containing the minimum total cost for each query.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)+O(mlog(n)). \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for storing prefixsum.\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n    int m=q.size(),n=nums.size();\\n    vector<long long> ans(m,0),sum(n,0);\\n    sort(nums.begin(),nums.end());\\n    sum[0]=nums[0];\\n    for(int i=1;i<n;i++)\\n    {\\n     sum[i]=nums[i];\\n     sum[i]+=sum[i-1];   \\n    }\\n     \\n    for(int i=0;i<m;i++)\\n    {\\n     vector<int>::iterator upper;   \\n     upper = upper_bound(nums.begin(), nums.end(), q[i]);\\n     int index=upper-nums.begin();   \\n     \\n     long long lower_sum=0,upper_sum=0;\\n     if(index!=0)   \\n     lower_sum=sum[index-1];\\n     \\n     upper_sum=sum[n-1]-lower_sum;\\n      \\n     long long final_lower_sum=((1ll*q[i]*index)-lower_sum);\\n     long long final_upper_sum=(upper_sum-(1ll*q[i]*(n-index)));   \\n        \\n     ans[i]=(final_lower_sum+final_upper_sum);   \\n    }    \\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n    int m=q.size(),n=nums.size();\\n    vector<long long> ans(m,0),sum(n,0);\\n    sort(nums.begin(),nums.end());\\n    sum[0]=nums[0];\\n    for(int i=1;i<n;i++)\\n    {\\n     sum[i]=nums[i];\\n     sum[i]+=sum[i-1];   \\n    }\\n     \\n    for(int i=0;i<m;i++)\\n    {\\n     vector<int>::iterator upper;   \\n     upper = upper_bound(nums.begin(), nums.end(), q[i]);\\n     int index=upper-nums.begin();   \\n     \\n     long long lower_sum=0,upper_sum=0;\\n     if(index!=0)   \\n     lower_sum=sum[index-1];\\n     \\n     upper_sum=sum[n-1]-lower_sum;\\n      \\n     long long final_lower_sum=((1ll*q[i]*index)-lower_sum);\\n     long long final_upper_sum=(upper_sum-(1ll*q[i]*(n-index)));   \\n        \\n     ans[i]=(final_lower_sum+final_upper_sum);   \\n    }    \\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428419,
                "title": "c",
                "content": "# Complexity\\n- Time complexity:`O(n log n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        int n = nums.size();\\n        int q = queries.size();\\n\\n        // SORT THE ARRAY\\n        sort(nums.begin(),nums.end());\\n\\n        // CALCULATE PREFIX OF NUMS \\n        vector<long long>prefix(n,0);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<n;i++) prefix[i] = prefix[i-1] + nums[i];\\n        \\n        // USE LONG LONG FOR AVOID RUNTIME\\n        vector<long long>ans;\\n\\n        long long increment = 0 , decrement = 0;\\n        long long value = 0;\\n\\n        // processing each query \\n        for(auto q : queries){\\n            \\n            // binary search\\n            int lo = 0 , hi = n-1;\\n            int mid; value = q;\\n\\n            // find position of current query element in sorted nums\\n            while(lo <= hi){\\n\\n                mid = lo + (hi - lo)/2;\\n\\n                if(nums[mid] <= value) lo = mid + 1;\\n                else hi = mid - 1;\\n                \\n            }\\n\\n            // reset increment & decrement\\n            increment = 0 , decrement = 0;\\n\\n            // get length of less than current query element which are need to increment\\n            if(lo > 0) increment = abs((value * lo) - prefix[lo-1]);\\n\\n            // get length of greater than current query element which are need to decrement\\n            if(lo == 0) decrement = abs((value*n) - prefix[n-1]);\\n            else decrement = abs((value * (n-lo)) - (prefix[n-1] - prefix[lo-1]));\\n\\n            // store answerr for current query\\n            ans.push_back(increment + decrement);\\n        }\\n        \\n        // return result\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        int n = nums.size();\\n        int q = queries.size();\\n\\n        // SORT THE ARRAY\\n        sort(nums.begin(),nums.end());\\n\\n        // CALCULATE PREFIX OF NUMS \\n        vector<long long>prefix(n,0);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<n;i++) prefix[i] = prefix[i-1] + nums[i];\\n        \\n        // USE LONG LONG FOR AVOID RUNTIME\\n        vector<long long>ans;\\n\\n        long long increment = 0 , decrement = 0;\\n        long long value = 0;\\n\\n        // processing each query \\n        for(auto q : queries){\\n            \\n            // binary search\\n            int lo = 0 , hi = n-1;\\n            int mid; value = q;\\n\\n            // find position of current query element in sorted nums\\n            while(lo <= hi){\\n\\n                mid = lo + (hi - lo)/2;\\n\\n                if(nums[mid] <= value) lo = mid + 1;\\n                else hi = mid - 1;\\n                \\n            }\\n\\n            // reset increment & decrement\\n            increment = 0 , decrement = 0;\\n\\n            // get length of less than current query element which are need to increment\\n            if(lo > 0) increment = abs((value * lo) - prefix[lo-1]);\\n\\n            // get length of greater than current query element which are need to decrement\\n            if(lo == 0) decrement = abs((value*n) - prefix[n-1]);\\n            else decrement = abs((value * (n-lo)) - (prefix[n-1] - prefix[lo-1]));\\n\\n            // store answerr for current query\\n            ans.push_back(increment + decrement);\\n        }\\n        \\n        // return result\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389336,
                "title": "sort-prefix-sum-binary-search",
                "content": "# Java\\n```\\npublic List<Long> minOperations(int[] nums, int[] queries) {\\n    List<Long> result = new ArrayList<>();\\n    Arrays.sort(nums);\\n\\n    long[] prefixSum = new long[nums.length];\\n    for (int i = 0; i < nums.length; ++i) {\\n      prefixSum[i] = (i > 0 ? prefixSum[i - 1] : 0) + nums[i];\\n    }\\n\\n    for (int query : queries) {\\n      int index = firstIndexOfMoreOrEqual(nums, query);\\n\\n      long leftSum = index == 0 ? 0 : prefixSum[index - 1], leftCount = index;\\n      long rightSum = prefixSum[prefixSum.length - 1] - leftSum, rightCount = nums.length - leftCount;\\n\\n      long leftDifference = query * leftCount - leftSum;\\n      long rightDifference = rightSum - query * rightCount;\\n\\n      result.add(leftDifference + rightDifference);\\n    }\\n\\n    return result;\\n  }\\n\\n  private int firstIndexOfMoreOrEqual(int[] nums, int value) {\\n    int left = 0, right = nums.length;\\n\\n    while (left < right) {\\n      int middle = left + (right - left) / 2;\\n\\n      if (nums[middle] < value)\\n        left = middle + 1;\\n      else\\n        right = middle;\\n    }\\n\\n    return left;\\n  }\\n```\\n\\n# C++\\n```\\n\\npublic:\\n    vector<long long> minOperations(vector<int> &nums, vector<int> &queries) {\\n        vector<long long> result;\\n        sort(nums.begin(), nums.end());\\n\\n        vector<long long> prefixSum(nums.size());\\n        for (int i = 0; i < nums.size(); ++i) {\\n            prefixSum[i] = (i > 0 ? prefixSum[i - 1] : 0) + nums[i];\\n        }\\n\\n        for (int query: queries) {\\n            int index = firstIndexOfMoreOrEqual(nums, query);\\n\\n            long leftSum = index == 0 ? 0 : prefixSum[index - 1], leftCount = index;\\n            long rightSum = prefixSum[prefixSum.size() - 1] - leftSum, rightCount = nums.size() - leftCount;\\n\\n            long leftDifference = query * leftCount - leftSum;\\n            long rightDifference = rightSum - query * rightCount;\\n\\n            result.push_back(leftDifference + rightDifference);\\n        }\\n\\n        return result;\\n    }\\n\\nprivate:\\n    int firstIndexOfMoreOrEqual(vector<int> &nums, int value) {\\n        int left = 0, right = nums.size();\\n\\n        while (left < right) {\\n            int middle = left + (right - left) / 2;\\n\\n            if (nums[middle] < value)\\n                left = middle + 1;\\n            else\\n                right = middle;\\n        }\\n\\n        return left;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\npublic List<Long> minOperations(int[] nums, int[] queries) {\\n    List<Long> result = new ArrayList<>();\\n    Arrays.sort(nums);\\n\\n    long[] prefixSum = new long[nums.length];\\n    for (int i = 0; i < nums.length; ++i) {\\n      prefixSum[i] = (i > 0 ? prefixSum[i - 1] : 0) + nums[i];\\n    }\\n\\n    for (int query : queries) {\\n      int index = firstIndexOfMoreOrEqual(nums, query);\\n\\n      long leftSum = index == 0 ? 0 : prefixSum[index - 1], leftCount = index;\\n      long rightSum = prefixSum[prefixSum.length - 1] - leftSum, rightCount = nums.length - leftCount;\\n\\n      long leftDifference = query * leftCount - leftSum;\\n      long rightDifference = rightSum - query * rightCount;\\n\\n      result.add(leftDifference + rightDifference);\\n    }\\n\\n    return result;\\n  }\\n\\n  private int firstIndexOfMoreOrEqual(int[] nums, int value) {\\n    int left = 0, right = nums.length;\\n\\n    while (left < right) {\\n      int middle = left + (right - left) / 2;\\n\\n      if (nums[middle] < value)\\n        left = middle + 1;\\n      else\\n        right = middle;\\n    }\\n\\n    return left;\\n  }\\n```\n```\\n\\npublic:\\n    vector<long long> minOperations(vector<int> &nums, vector<int> &queries) {\\n        vector<long long> result;\\n        sort(nums.begin(), nums.end());\\n\\n        vector<long long> prefixSum(nums.size());\\n        for (int i = 0; i < nums.size(); ++i) {\\n            prefixSum[i] = (i > 0 ? prefixSum[i - 1] : 0) + nums[i];\\n        }\\n\\n        for (int query: queries) {\\n            int index = firstIndexOfMoreOrEqual(nums, query);\\n\\n            long leftSum = index == 0 ? 0 : prefixSum[index - 1], leftCount = index;\\n            long rightSum = prefixSum[prefixSum.size() - 1] - leftSum, rightCount = nums.size() - leftCount;\\n\\n            long leftDifference = query * leftCount - leftSum;\\n            long rightDifference = rightSum - query * rightCount;\\n\\n            result.push_back(leftDifference + rightDifference);\\n        }\\n\\n        return result;\\n    }\\n\\nprivate:\\n    int firstIndexOfMoreOrEqual(vector<int> &nums, int value) {\\n        int left = 0, right = nums.size();\\n\\n        while (left < right) {\\n            int middle = left + (right - left) / 2;\\n\\n            if (nums[middle] < value)\\n                left = middle + 1;\\n            else\\n                right = middle;\\n        }\\n\\n        return left;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3384487,
                "title": "sorting-upperbound-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose we have a query \\'a\\' then we have to know the number of elements which is greater than \\'a\\' and less than or equal to \\'a\\' in nums array and their sum Let\\'s if \\'b\\' number is greater and \\'c\\' number is less than or equal to in nums array. And their sum is sa and sb. Then, if we change the all elements to \\'a\\' then their sum would be \\'a\\' * \\'b\\' and \\'a\\' * \\'c\\'. Then, simply add their difference value and store them.\\n\\nHow to find how many numbers are greater than particular query \\'q\\' in nums array ? \\n-> Here, Comes sorting. Sort the array and use binary search or STL upperbound and find their index.\\n\\nHow to find the sum of numbers are greater than particular query \\'q\\' in nums array ?\\n-> Use the concept of prefix sum\\n\\n# Complexity\\n- Time complexity: $$O(m * log(n))$$\\n- m = length of queries array\\n- n = length of nums array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n- n = length of nums array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& Q) {\\n        int m = size(Q), n = size(nums);\\n        sort(begin(nums),end(nums));\\n        vector<long long> ans, pf(n+1);\\n        \\n        for(int i=1; i<=n; ++i)\\n            pf[i] = pf[i-1] + 0ll + nums[i-1];\\n\\n        for(int&q: Q){\\n            int idx = upper_bound(begin(nums),end(nums),q) - begin(nums);\\n            long long bigger = pf[n] - pf[idx], smaller = pf[idx];\\n            long long bgreq = (n-idx)*1ll*q, smreq = idx*1ll*q;\\n            long long e = bigger-bgreq + smreq-smaller;\\n            ans.push_back(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& Q) {\\n        int m = size(Q), n = size(nums);\\n        sort(begin(nums),end(nums));\\n        vector<long long> ans, pf(n+1);\\n        \\n        for(int i=1; i<=n; ++i)\\n            pf[i] = pf[i-1] + 0ll + nums[i-1];\\n\\n        for(int&q: Q){\\n            int idx = upper_bound(begin(nums),end(nums),q) - begin(nums);\\n            long long bigger = pf[n] - pf[idx], smaller = pf[idx];\\n            long long bgreq = (n-idx)*1ll*q, smreq = idx*1ll*q;\\n            long long e = bigger-bgreq + smreq-smaller;\\n            ans.push_back(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360172,
                "title": "c-95-fast-with-best-explanation",
                "content": "# Intuition\\nDivide nums into 2 subarray\\nsuppose we have nums = [2,6,8] and we need to find operations for query [5]. \\nJust find elements that are greater than 5 and that are lower than it. Here, [6,8] are greater and [2] is lower.\\n\\nFor greater, sum of these elements is 6+8 = 14. We need to bring these 2 elements equal to 5. Then there sum would be 10. That means we need to perform 14-10 = 4 operations.\\n\\nFor lower element, current sum is 2. We need to make it 5. That means we need (5 - 2) = 3 operations.\\n\\n# Approach\\nUse prefix sum to fetch sum in O(1)\\nFind lenght of subarrays using binary search(upper_bound)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<long long> sum;\\n        \\n        // Prefix Sum\\n        long long sumi = 0;\\n        for(auto &i : nums){\\n            sumi += i;\\n            sum.push_back(sumi);\\n        }\\n\\n        vector<long long> ans;\\n\\n        for(auto &i : queries){\\n            long long cnt = 0;\\n\\n            // Length of bigger elements subarray\\n            long long bigger = upper_bound(nums.begin(), nums.end(), i) - nums.begin();\\n            bigger = nums.size() - bigger;\\n\\n            // Lenght of smaller elements subarray\\n            long long shorter = nums.size() - bigger - 1;\\n            while(shorter >= 0 && nums[shorter] == i) shorter--;\\n            shorter = shorter + 1;\\n\\n            // Sum of greater and smaller elements\\n            long long leftSum = 0, rightSum = 0;\\n            if(shorter > 0) leftSum = sum[shorter-1];\\n            if(bigger > 0){\\n                rightSum = sum.back();\\n                if(bigger != nums.size()) rightSum -= sum[nums.size() - bigger - 1];\\n            }\\n\\n            cnt += rightSum - (bigger * i);\\n            cnt += (shorter * i) - leftSum;\\n\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<long long> sum;\\n        \\n        // Prefix Sum\\n        long long sumi = 0;\\n        for(auto &i : nums){\\n            sumi += i;\\n            sum.push_back(sumi);\\n        }\\n\\n        vector<long long> ans;\\n\\n        for(auto &i : queries){\\n            long long cnt = 0;\\n\\n            // Length of bigger elements subarray\\n            long long bigger = upper_bound(nums.begin(), nums.end(), i) - nums.begin();\\n            bigger = nums.size() - bigger;\\n\\n            // Lenght of smaller elements subarray\\n            long long shorter = nums.size() - bigger - 1;\\n            while(shorter >= 0 && nums[shorter] == i) shorter--;\\n            shorter = shorter + 1;\\n\\n            // Sum of greater and smaller elements\\n            long long leftSum = 0, rightSum = 0;\\n            if(shorter > 0) leftSum = sum[shorter-1];\\n            if(bigger > 0){\\n                rightSum = sum.back();\\n                if(bigger != nums.size()) rightSum -= sum[nums.size() - bigger - 1];\\n            }\\n\\n            cnt += rightSum - (bigger * i);\\n            cnt += (shorter * i) - leftSum;\\n\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352192,
                "title": "optimized-java-solution-binary-search-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(q*log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] q) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n    \\n        List<Long> ans = new ArrayList<>();\\n\\n        long[] prefix = new long[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            prefix[i] = prefix[i-1] + nums[i-1];\\n        }\\n\\n        for(int val : q) {\\n            int i = Arrays.binarySearch(nums, val);\\n            if(i < 0) i = -(i + 1);\\n            ans.add(1L * val * (2*i-n) + prefix[n] - 2 * prefix[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] q) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n    \\n        List<Long> ans = new ArrayList<>();\\n\\n        long[] prefix = new long[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            prefix[i] = prefix[i-1] + nums[i-1];\\n        }\\n\\n        for(int val : q) {\\n            int i = Arrays.binarySearch(nums, val);\\n            if(i < 0) i = -(i + 1);\\n            ans.add(1L * val * (2*i-n) + prefix[n] - 2 * prefix[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350967,
                "title": "easy-solution-in-python-3",
                "content": "# Intuition\\nIt can be solved using naive approach in O(n^2) time complexity, which includes one outer for loop for iterating in queries list and the inner outer loop for calculating the sum (as shown) in \\'nums\\' list. Since, this solution is not optimal, we have to reduce the time complexity further.\\n# Naive approach:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        ans=[]\\n        for i in range(len(queries)):\\n            summ=0\\n            for j in range(0,len(nums)):\\n                summ+=abs(nums[j]-queries[i])\\n            ans.append(summ)\\n        return(ans)\\n\\n# Approach\\nTo reduce the T.C, the other possible methods for getting the summ varibale should be either O(log(n)) or O(1). Since we know that, if we make a prefix sum array, we can retrieve sum in O(1) only, we have used that here.\\nThe reason for using binary search here is: If we can get the index of a number (say i), we can get the sum of elements upto the \\'i\\'th index using prefix_sum array(that too in O(1) time).\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n) for the extra array that i took (arr)\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        n=len(nums)\\n        nums.sort()\\n        arr=nums.copy()\\n        for i in range(1,len(nums)):  #Prefix_sum\\n            nums[i]+=nums[i-1]\\n        \\n\\n        def binary_search(nums,x):\\n            start=0\\n            end=len(nums)-1 \\n            while(start<=end):\\n                mid=(start+end)//2\\n                if(nums[mid]==x):\\n                    return(mid)\\n                elif(nums[mid]>x):\\n                    end=mid-1\\n                else:\\n                    start=mid+1 \\n            return(start)\\n        \\n\\n        ans=[]\\n        for i in range(0,len(queries)):\\n            summ=0\\n            index=binary_search(arr,queries[i])  #to get the index\\n            if(index==0):\\n                summ=nums[-1]-(n*queries[i])\\n            else:\\n                summ=(index*queries[i])-(nums[index-1])    #for summ of elements before index\\n                summ+=(nums[-1]-nums[index-1])-((n-index)*queries[i])     #for summ of elements after index\\n            ans.append(summ)\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        n=len(nums)\\n        nums.sort()\\n        arr=nums.copy()\\n        for i in range(1,len(nums)):  #Prefix_sum\\n            nums[i]+=nums[i-1]\\n        \\n\\n        def binary_search(nums,x):\\n            start=0\\n            end=len(nums)-1 \\n            while(start<=end):\\n                mid=(start+end)//2\\n                if(nums[mid]==x):\\n                    return(mid)\\n                elif(nums[mid]>x):\\n                    end=mid-1\\n                else:\\n                    start=mid+1 \\n            return(start)\\n        \\n\\n        ans=[]\\n        for i in range(0,len(queries)):\\n            summ=0\\n            index=binary_search(arr,queries[i])  #to get the index\\n            if(index==0):\\n                summ=nums[-1]-(n*queries[i])\\n            else:\\n                summ=(index*queries[i])-(nums[index-1])    #for summ of elements before index\\n                summ+=(nums[-1]-nums[index-1])-((n-index)*queries[i])     #for summ of elements after index\\n            ans.append(summ)\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346794,
                "title": "entire-thought-process-intuition-binary-search-prefix-sum-approach",
                "content": "# Intuition\\n\\n    * Let\\'s try, to to make some observations:\\n\\n    Input: nums = [3,1,6,8], queries = [1,5]\\n    Output: [14, 10]\\n    \\n    queires[0] = 1, ans = 14, \\n    answer 14 can be easily compute as (total_sum_of_nums - nums_size * queries[0]) -> (18 - 4 * 1) -> 14\\n\\n    queries[1] = 5, ans = 10, \\n    but the above point is NOT always valid for all \"i\"th queries.\\n    \\n    For example here, (18 - 4 * 5) -> -2 \\n    \\n    #1 -ve is indicating that we\\'ve to add some more items on couple of indices.\\n    \\n    #2 -ve answer also indicating that some of the elements in \"nums\" are lesser than \"queries[i]\"\\n    \\n    #3 Also total_sum of array(nums) doesn\\'t give us the information about the elements that\\n        are at different indices in \"nums\" array.\\n        \\n    #4 From [3, 1, 6, 8], queries[1] = 5, this thought is came from Obs#2\\n    \\n            Q: all the elements that are smaller(or equal can be added here)\\n                    than (5 : current ith query) would contribute how much in our final answer?\\n                    \\n            A: (count_of_elements * queries[i] - sum_of_all_those_elements)\\n            \\n                for example, here for the 1st query:\\n                \\n                cont_of_elements = 2 -> {1, 3} -> [1 & 3 are smaller than 5]\\n                \\n                contribution = (2 * 5 - (1 + 3)) = 6\\n                \\n                \\n                Similarly, total contribution of elements in our final answer from\\n                elements larger than queries[i] can be given as:\\n                \\n                contribution = (sum_of_all_such_elements - count_of_such_elements * queries[i])\\n                \\n                contribution = ((6 + 8) - (2 * 5)) -> (14 - 10) -> 4\\n                \\n                \\n                now add the contributions = (6 + 4) -> 10 [final answer for 1st query]\\n                \\n                \\n            * Counting part can be efficiently computed using \"Binary Search\" and for getting a sum of elements\\n                for any sub-array can be easily computed in O(1) with the help of \"prefix-sum\" array.\\n                    - But \"Binary Search\" can be applied only in monotonic data, hence sorting required.\\n                \\n        \\n        +++ Now, I got the approach. Excellent man :).\\n\\n# Complexity\\n- Time complexity: O(N + N * log(N)) -> O(N * log(N))\\n- Space complexity: O(N)\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        \\n        int N = nums.length;\\n        long[] prefixSum = new long[N];\\n        \\n        for(int i = 0; i < N; i += 1) {\\n            if(i == 0) prefixSum[i] = nums[i];\\n            else {\\n                prefixSum[i] = prefixSum[i - 1] + nums[i];\\n            }\\n        }\\n                \\n        List<Long> answer = new ArrayList<>();\\n        \\n        for(int i = 0; i < queries.length; i += 1) {\\n            int queryEle = queries[i];\\n            int idx = upperBound(nums, queryEle);\\n            if(idx == N) {\\n                answer.add(((N * 1L * queryEle) - prefixSum[N - 1]));\\n            } else {\\n                long contri1 = (prefixSum[N - 1] - prefixSum[idx] + nums[idx]) - (N - idx) * 1L * queryEle; // for larger > queries[i]\\n                long contri2 = 0;\\n                if(idx != 0) \\n                    contri2 = (idx * 1L * queryEle) - (prefixSum[idx - 1] - prefixSum[0] + nums[0]); // for smaller <= queries[i]\\n                answer.add((contri1 + contri2));\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    // returns the first index (idx) such that nums[idx] > target\\n    private int upperBound(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(nums[mid] <= target)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        \\n        int N = nums.length;\\n        long[] prefixSum = new long[N];\\n        \\n        for(int i = 0; i < N; i += 1) {\\n            if(i == 0) prefixSum[i] = nums[i];\\n            else {\\n                prefixSum[i] = prefixSum[i - 1] + nums[i];\\n            }\\n        }\\n                \\n        List<Long> answer = new ArrayList<>();\\n        \\n        for(int i = 0; i < queries.length; i += 1) {\\n            int queryEle = queries[i];\\n            int idx = upperBound(nums, queryEle);\\n            if(idx == N) {\\n                answer.add(((N * 1L * queryEle) - prefixSum[N - 1]));\\n            } else {\\n                long contri1 = (prefixSum[N - 1] - prefixSum[idx] + nums[idx]) - (N - idx) * 1L * queryEle; // for larger > queries[i]\\n                long contri2 = 0;\\n                if(idx != 0) \\n                    contri2 = (idx * 1L * queryEle) - (prefixSum[idx - 1] - prefixSum[0] + nums[0]); // for smaller <= queries[i]\\n                answer.add((contri1 + contri2));\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    // returns the first index (idx) such that nums[idx] > target\\n    private int upperBound(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(nums[mid] <= target)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342978,
                "title": "best-code-in-c-binarysearch-sorting-prefixsum",
                "content": "# Complexity\\n- Time complexity:\\nO(mlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size(),m=queries.size();\\n        long long pSum=0;\\n        sort(nums.begin(),nums.end());\\n        vector<long long> prefixSum(n),ans;\\n        for(int i=0;i<n;i++){\\n            pSum+=nums[i];\\n            prefixSum[i]=pSum;\\n        }\\n        for(auto it:queries){\\n            auto ub=upper_bound(nums.begin(),nums.end(),it);\\n            int ind=ub-nums.begin();\\n            long long minOper=0, req_sum=0, curr_sum;\\n            if(ind>0){\\n                req_sum = (long)it * ind, curr_sum = prefixSum[ind-1];\\n                minOper = req_sum - curr_sum;\\n            }\\n            req_sum = (long)it * (n-ind), curr_sum = (ind>0)? (prefixSum[n-1]-prefixSum[ind-1]) : prefixSum[n-1];\\n            minOper += curr_sum - req_sum;\\n            ans.push_back(minOper);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/e7ad9666-2c12-4662-98d1-859bc5d261e5_1679819969.3035681.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size(),m=queries.size();\\n        long long pSum=0;\\n        sort(nums.begin(),nums.end());\\n        vector<long long> prefixSum(n),ans;\\n        for(int i=0;i<n;i++){\\n            pSum+=nums[i];\\n            prefixSum[i]=pSum;\\n        }\\n        for(auto it:queries){\\n            auto ub=upper_bound(nums.begin(),nums.end(),it);\\n            int ind=ub-nums.begin();\\n            long long minOper=0, req_sum=0, curr_sum;\\n            if(ind>0){\\n                req_sum = (long)it * ind, curr_sum = prefixSum[ind-1];\\n                minOper = req_sum - curr_sum;\\n            }\\n            req_sum = (long)it * (n-ind), curr_sum = (ind>0)? (prefixSum[n-1]-prefixSum[ind-1]) : prefixSum[n-1];\\n            minOper += curr_sum - req_sum;\\n            ans.push_back(minOper);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342435,
                "title": "prefix-suffix-sum-binary-search-c",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long int> v;\\n        sort(nums.begin(),nums.end());\\n        vector<long long int> l(nums.size()),r(nums.size());\\n        l[0] = nums[0];\\n        r[nums.size()-1] = nums[nums.size()-1];\\n        for(int i = 1; i < nums.size(); i++){\\n            l[i] += nums[i]+l[i-1];\\n        }\\n        for(int i = nums.size()-2; i>=0; i--){\\n            r[i] += nums[i]+r[i+1];\\n        }\\n        for(int i = 0; i < queries.size(); i++){\\n            int a = 0, b = nums.size()-1, mid,k=nums.size();\\n            while(a<=b){\\n                mid = (b-a)/2+a;\\n                if(nums[mid]>=queries[i]){\\n                    k = mid;\\n                    b = mid-1;\\n                }else{\\n                    a= mid+1;\\n                }\\n            }\\n            long long int aa = 0;\\n            if(k-1>=0){\\n                aa += k*1LL*queries[i]-l[k-1];\\n            }if(k<nums.size()){\\n                aa += r[k]-(nums.size()-k)*1LL*queries[i];\\n            }\\n            v.push_back(aa);\\n        }\\n        return v;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long int> v;\\n        sort(nums.begin(),nums.end());\\n        vector<long long int> l(nums.size()),r(nums.size());\\n        l[0] = nums[0];\\n        r[nums.size()-1] = nums[nums.size()-1];\\n        for(int i = 1; i < nums.size(); i++){\\n            l[i] += nums[i]+l[i-1];\\n        }\\n        for(int i = nums.size()-2; i>=0; i--){\\n            r[i] += nums[i]+r[i+1];\\n        }\\n        for(int i = 0; i < queries.size(); i++){\\n            int a = 0, b = nums.size()-1, mid,k=nums.size();\\n            while(a<=b){\\n                mid = (b-a)/2+a;\\n                if(nums[mid]>=queries[i]){\\n                    k = mid;\\n                    b = mid-1;\\n                }else{\\n                    a= mid+1;\\n                }\\n            }\\n            long long int aa = 0;\\n            if(k-1>=0){\\n                aa += k*1LL*queries[i]-l[k-1];\\n            }if(k<nums.size()){\\n                aa += r[k]-(nums.size()-k)*1LL*queries[i];\\n            }\\n            v.push_back(aa);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342408,
                "title": "no-binary-search-just-use-sweep-line-and-prefix-sum",
                "content": "# Intuition\\nFor a given query `x`, answer will be sum of `left answer` and `right answer`.\\n`left answer` = `x` * `number of smaller values than x` - `sum of smaller values than x`\\n`right answer` = `sum of bigger values than x` - `x` * `number of bigger values than x`\\n\\n\\n# Approach\\nSort both array and queries.\\nYou can find number of smaller(`ln`) and larger values(`rn`) using sweep line.\\nAnd find sum of smaller(`ls`) and larger values(`rs`) using prefix sum + sweep line.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(nlogn + mlogm + n + m)`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(n)` for prefix sum\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tvector<long long> minOperations(vector<int>& a, vector<int>& queries) {\\n\\t\\tsort(a.begin(), a.end());\\n\\t\\tvector dp(1, 0ll);\\n\\t\\tfor(auto &x: a) dp.push_back(dp.back() + x);\\n\\n\\t\\tvector <pair <long long, int>> q;\\n\\t\\tfor(int i = 0; i < queries.size(); i++) q.push_back({queries[i], i});\\n\\t\\tsort(q.begin(), q.end());\\n\\n\\t\\tvector ans(q.size(), 0ll);\\n\\t\\tlong long i = 0, n = a.size(), ln = 0, rn = n, ls = 0, rs = dp[n];\\n\\t\\tfor(auto &[x, idx]: q) {\\n\\t\\t\\tfor( ; i < n && a[i] <= x; i++) {\\n\\t\\t\\t\\tln = i + 1, rn = n - (i + 1);\\n\\t\\t\\t\\tls = dp[i + 1], rs = dp[n] - dp[i + 1];\\n\\t\\t\\t}\\n\\t\\t\\tans[idx] = (x * ln - ls) + (rs - x * rn);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<long long> minOperations(vector<int>& a, vector<int>& queries) {\\n\\t\\tsort(a.begin(), a.end());\\n\\t\\tvector dp(1, 0ll);\\n\\t\\tfor(auto &x: a) dp.push_back(dp.back() + x);\\n\\n\\t\\tvector <pair <long long, int>> q;\\n\\t\\tfor(int i = 0; i < queries.size(); i++) q.push_back({queries[i], i});\\n\\t\\tsort(q.begin(), q.end());\\n\\n\\t\\tvector ans(q.size(), 0ll);\\n\\t\\tlong long i = 0, n = a.size(), ln = 0, rn = n, ls = 0, rs = dp[n];\\n\\t\\tfor(auto &[x, idx]: q) {\\n\\t\\t\\tfor( ; i < n && a[i] <= x; i++) {\\n\\t\\t\\t\\tln = i + 1, rn = n - (i + 1);\\n\\t\\t\\t\\tls = dp[i + 1], rs = dp[n] - dp[i + 1];\\n\\t\\t\\t}\\n\\t\\t\\tans[idx] = (x * ln - ls) + (rs - x * rn);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341882,
                "title": "javascript-sorting-binary-search-prefix-sum",
                "content": "**Solution: Sorting, Binary Search & Prefix Sum**\\n\\n1. Sort nums in asc order.\\n2. Get the prefix sum from the left and right of nums.\\n3. For each query, binary search for the split point - the first element where `nums[i] >= query`\\n  From there, we can calculate the absolute difference of the two segments of nums.\\n  Segment one: `query * i - leftSum[i - 1]`\\n  Segment two: `rightSum[i] - query * (n - i)`\\n\\n`n = length of nums`, `m = number of queries`\\nTime Complexity: `O(n log(n) + m log(n))`\\nSpace Complexity: `O(n + m)`\\n```\\nvar minOperations = function(nums, queries) {\\n  nums.sort((a, b) => a - b);\\n  let n = nums.length;\\n  let left = [...nums], right = [...nums];\\n  for (let i = 1; i < n; i++) left[i] += left[i - 1];\\n  for (let i = n - 2; i >= 0; i--) right[i] += right[i + 1];\\n  let ans = [];\\n  for (let query of queries) {\\n    let splitIndex = getSplitIndex(query);\\n    let leftDiff = splitIndex > 0 ? query * splitIndex - left[splitIndex - 1] : 0;\\n    let rightDiff = splitIndex < n ? right[splitIndex] - query * (n - splitIndex) : 0;\\n    ans.push(leftDiff + rightDiff);\\n  }\\n  return ans;\\n  \\n  function getSplitIndex(query) {\\n    let low = 0, high = n - 1;\\n    while (low < high) {\\n      let mid = Math.floor((low + high) / 2);\\n      if (nums[mid] >= query) high = mid;\\n      else low = mid + 1;\\n    }\\n    return nums[low] >= query ? low : n;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(nums, queries) {\\n  nums.sort((a, b) => a - b);\\n  let n = nums.length;\\n  let left = [...nums], right = [...nums];\\n  for (let i = 1; i < n; i++) left[i] += left[i - 1];\\n  for (let i = n - 2; i >= 0; i--) right[i] += right[i + 1];\\n  let ans = [];\\n  for (let query of queries) {\\n    let splitIndex = getSplitIndex(query);\\n    let leftDiff = splitIndex > 0 ? query * splitIndex - left[splitIndex - 1] : 0;\\n    let rightDiff = splitIndex < n ? right[splitIndex] - query * (n - splitIndex) : 0;\\n    ans.push(leftDiff + rightDiff);\\n  }\\n  return ans;\\n  \\n  function getSplitIndex(query) {\\n    let low = 0, high = n - 1;\\n    while (low < high) {\\n      let mid = Math.floor((low + high) / 2);\\n      if (nums[mid] >= query) high = mid;\\n      else low = mid + 1;\\n    }\\n    return nums[low] >= query ? low : n;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3389368,
                "title": "python-solution-sort-prefixsum-binsearch",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        prefix_sum = [nums[0]]\\n        ans = []\\n        for i in range(1, len(nums)):\\n            prefix_sum.append(prefix_sum[-1] + nums[i])\\n        \\n        for target in queries:\\n            l = 0\\n            r = len(nums) - 1\\n            pos = -2 # -2 for not found case\\n            #left bin search             \\n            while l <= r:\\n                mid = (l + r) // 2\\n                if nums[mid] > target:\\n                    r = mid - 1\\n                elif nums[mid] < target:\\n                    l = mid + 1\\n                else:\\n                    pos = mid\\n                    r = mid - 1     \\n\\n            if pos == -2:\\n                pos = min(l, r)\\n            # pos == -1 leftmost case\\n            if pos == -1:\\n                ans.append(prefix_sum[-1] - (len(nums))*target)\\n            else:\\n                ans.append((pos+1)*target - prefix_sum[pos] + prefix_sum[-1] - prefix_sum[pos] - (len(nums) -1 - pos)*target)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        prefix_sum = [nums[0]]\\n        ans = []\\n        for i in range(1, len(nums)):\\n            prefix_sum.append(prefix_sum[-1] + nums[i])\\n        \\n        for target in queries:\\n            l = 0\\n            r = len(nums) - 1\\n            pos = -2 # -2 for not found case\\n            #left bin search             \\n            while l <= r:\\n                mid = (l + r) // 2\\n                if nums[mid] > target:\\n                    r = mid - 1\\n                elif nums[mid] < target:\\n                    l = mid + 1\\n                else:\\n                    pos = mid\\n                    r = mid - 1     \\n\\n            if pos == -2:\\n                pos = min(l, r)\\n            # pos == -1 leftmost case\\n            if pos == -1:\\n                ans.append(prefix_sum[-1] - (len(nums))*target)\\n            else:\\n                ans.append((pos+1)*target - prefix_sum[pos] + prefix_sum[-1] - prefix_sum[pos] - (len(nums) -1 - pos)*target)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347216,
                "title": "magical-formula-lol-o-nlogn-binary-search-prefix-sum",
                "content": "// Intuition behind this is to isolate numbers less than queries[i] and number greater or equal to queries[i]  and then perform this magical formula\\n    // ans[i] = (idx*x-res[idx-1]) + res[n-1]-res[idx-1]-x*n-idx  --> key formula I derived (all terms are used in code)\\n\\t// 1,3,6,8   \\n    // 1,4,10,18  -> prefix sum array\\n    // check for 5\\n    // lower bound of 5 will give us index 2\\n\\t// Then apply this formula, think of it and you will get to know why I isolated numbers greater than queries[i] and less than queries[i] seprately\\n    \\n\\t\\n\\t\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\t\\tvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n\\t\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\t\\tint n =nums.size();\\n\\t\\t\\t\\tvector<long long> sumarray(n);\\n\\t\\t\\t\\tlong long sum=0;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\t\\tsumarray[i] = sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong long q = queries.size();\\n\\t\\t\\t\\tvector<long long> ans(q);\\n\\t\\t\\t\\tfor(int i=0;i<q;i++){\\n\\t\\t\\t\\t\\tlong long x = queries[i];\\n\\t\\t\\t\\t\\tlong long idx = lower_bound(nums.begin(),nums.end(),x)-nums.begin();\\n\\t\\t\\t\\t\\tif(idx == 0 || idx == n ) ans[i] = abs(n*x - sumarray[n-1] );\\n\\t\\t\\t\\t\\telse ans[i] = (idx*x - sumarray[idx-1] ) + sumarray[n-1]-sumarray[idx-1]-x*(n-idx);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\t\\tvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n\\t\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\t\\tint n =nums.size();\\n\\t\\t\\t\\tvector<long long> sumarray(n);\\n\\t\\t\\t\\tlong long sum=0;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\t\\tsumarray[i] = sum;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3347082,
                "title": "golang-156-ms-10-9-mb",
                "content": "# Complexity\\n- Time complexity: $$O((n+m)*logn)$$\\n- Space complexity: $$O(n+m)$$\\n# Code\\n```\\nfunc minOperations(nums []int, queries []int) []int64 {\\n\\tn := len(nums)\\n\\tsort.Ints(nums)\\n\\tprefixSums := make([]int, n)\\n\\tprefixSums[0] = nums[0]\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tprefixSums[i] = prefixSums[i-1] + nums[i]\\n\\t}\\n\\tresult := make([]int64, len(queries))\\n\\tfor i, query := range queries {\\n\\t\\tidx := sort.SearchInts(nums, query)\\n\\t\\tif idx == 0 {\\n\\t\\t\\tresult[i] = int64(prefixSums[n-1] - query*n)\\n\\t\\t} else {\\n\\t\\t\\tresult[i] = int64(prefixSums[n-1] - query*(n-idx) + query*idx - prefixSums[idx-1]<<1)\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minOperations(nums []int, queries []int) []int64 {\\n\\tn := len(nums)\\n\\tsort.Ints(nums)\\n\\tprefixSums := make([]int, n)\\n\\tprefixSums[0] = nums[0]\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tprefixSums[i] = prefixSums[i-1] + nums[i]\\n\\t}\\n\\tresult := make([]int64, len(queries))\\n\\tfor i, query := range queries {\\n\\t\\tidx := sort.SearchInts(nums, query)\\n\\t\\tif idx == 0 {\\n\\t\\t\\tresult[i] = int64(prefixSums[n-1] - query*n)\\n\\t\\t} else {\\n\\t\\t\\tresult[i] = int64(prefixSums[n-1] - query*(n-idx) + query*idx - prefixSums[idx-1]<<1)\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3346476,
                "title": "c-sorting-prefix-sum-binary-search-faster-easy-to-understand",
                "content": "* ***Using Sorting && Binary Search***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        int n = nums.size();\\n        \\n        int m = queries.size();\\n        \\n        // sort the nums\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // find the prefix sum array\\n        \\n        vector<long long> prefix(n, 0);\\n        \\n        prefix[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            prefix[i] = nums[i] + prefix[i - 1];\\n        }\\n        \\n        long long total_sum = prefix[n - 1];\\n        \\n        vector<long long> ans(m);\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            long long min_op = 0;\\n            \\n            int tar = queries[i];\\n            \\n            // find the index of the upper bound of tar\\n            \\n            int idx = upper_bound(nums.begin(), nums.end(), tar) - nums.begin();\\n            \\n            // cal. the operations required till idx - 1\\n            \\n            long long left_sum = 0;\\n            \\n            if(idx > 0)\\n            {\\n                left_sum += prefix[idx - 1];\\n            }\\n            \\n            long long left_req_sum = (long long) tar * (long long) idx;\\n            \\n            min_op += abs(left_req_sum - left_sum);\\n            \\n            // cal. the operations required from idx to n - 1\\n            \\n            long long right_sum = total_sum;\\n            \\n            if(idx > 0)\\n            {\\n                right_sum -= prefix[idx - 1];\\n            }\\n            \\n            long long right_req_sum = (long long) (n - idx) * (long long) tar;\\n            \\n            min_op += abs(right_sum - right_req_sum);\\n            \\n            ans[i] = min_op;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        int n = nums.size();\\n        \\n        int m = queries.size();\\n        \\n        // sort the nums\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // find the prefix sum array\\n        \\n        vector<long long> prefix(n, 0);\\n        \\n        prefix[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            prefix[i] = nums[i] + prefix[i - 1];\\n        }\\n        \\n        long long total_sum = prefix[n - 1];\\n        \\n        vector<long long> ans(m);\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            long long min_op = 0;\\n            \\n            int tar = queries[i];\\n            \\n            // find the index of the upper bound of tar\\n            \\n            int idx = upper_bound(nums.begin(), nums.end(), tar) - nums.begin();\\n            \\n            // cal. the operations required till idx - 1\\n            \\n            long long left_sum = 0;\\n            \\n            if(idx > 0)\\n            {\\n                left_sum += prefix[idx - 1];\\n            }\\n            \\n            long long left_req_sum = (long long) tar * (long long) idx;\\n            \\n            min_op += abs(left_req_sum - left_sum);\\n            \\n            // cal. the operations required from idx to n - 1\\n            \\n            long long right_sum = total_sum;\\n            \\n            if(idx > 0)\\n            {\\n                right_sum -= prefix[idx - 1];\\n            }\\n            \\n            long long right_req_sum = (long long) (n - idx) * (long long) tar;\\n            \\n            min_op += abs(right_sum - right_req_sum);\\n            \\n            ans[i] = min_op;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345976,
                "title": "c-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<long long> sums(nums.size(), 0);\\n        sums[0] = nums[0];\\n        for(int i = 1; i < nums.size(); i++) sums[i] = nums[i] + sums[i-1];\\n        vector<long long> ans(queries.size(), 0);\\n        for(int i = 0; i < queries.size(); i++){\\n            auto it = upper_bound(nums.begin(), nums.end(), queries[i]);\\n            long long index = (int)(it - nums.begin());\\n            long long v1 = queries[i] * index;\\n            long long v2 = queries[i] * (nums.size()-index);\\n            long long res1 = 0;\\n            if(index != 0) res1 = v1 - sums[index - 1];\\n            long long res2 = 0;\\n            if(index == 0) res2 = sums[sums.size()-1] - v2;\\n            else if(index != nums.size()) res2 = sums[sums.size()-1] - sums[index - 1] - v2;\\n            ans[i] = res1 + res2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<long long> sums(nums.size(), 0);\\n        sums[0] = nums[0];\\n        for(int i = 1; i < nums.size(); i++) sums[i] = nums[i] + sums[i-1];\\n        vector<long long> ans(queries.size(), 0);\\n        for(int i = 0; i < queries.size(); i++){\\n            auto it = upper_bound(nums.begin(), nums.end(), queries[i]);\\n            long long index = (int)(it - nums.begin());\\n            long long v1 = queries[i] * index;\\n            long long v2 = queries[i] * (nums.size()-index);\\n            long long res1 = 0;\\n            if(index != 0) res1 = v1 - sums[index - 1];\\n            long long res2 = 0;\\n            if(index == 0) res2 = sums[sums.size()-1] - v2;\\n            else if(index != nums.size()) res2 = sums[sums.size()-1] - sums[index - 1] - v2;\\n            ans[i] = res1 + res2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345165,
                "title": "sort-binary-search",
                "content": "# Intuition\\nBrute force will give TLE. Look for a pivot from where either we only need to increment or decrement.\\n\\n# Approach\\nCarefully note that the answer does not depend on the order of the elements. In such a case, we can utilize binary search to identify a pivot 1) before which all elements are smaller 2) after which all elements are bigger. For binary, we first need to sort it.\\nOnce completed, our answer will be sum of both the above cases using pattern.\\n\\n# Complexity\\n- Time complexity: $$O(mlog(n))$$ , where m is no. of queries.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<long long> prefix(n + 1);\\n        for (int i=0;i<n;++i) {\\n            prefix[i+1] = prefix[i] + (long long)nums[i];\\n        }\\n        vector<long long> ans;\\n        for (auto &query : queries) {\\n            int left = 0, right = n;\\n            while (left < right) {\\n                int mid = left + (right - left) / 2;\\n                if (query < nums[mid]) {\\n                    right = mid;\\n                }\\n                else {\\n                    left = mid + 1;\\n                }\\n            }\\n            long long inc = (long long)query * left - prefix[left];\\n            long long dec = prefix[n] - prefix[left] - (long long)query * (n - left);\\n            ans.push_back(inc + dec);\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<long long> prefix(n + 1);\\n        for (int i=0;i<n;++i) {\\n            prefix[i+1] = prefix[i] + (long long)nums[i];\\n        }\\n        vector<long long> ans;\\n        for (auto &query : queries) {\\n            int left = 0, right = n;\\n            while (left < right) {\\n                int mid = left + (right - left) / 2;\\n                if (query < nums[mid]) {\\n                    right = mid;\\n                }\\n                else {\\n                    left = mid + 1;\\n                }\\n            }\\n            long long inc = (long long)query * left - prefix[left];\\n            long long dec = prefix[n] - prefix[left] - (long long)query * (n - left);\\n            ans.push_back(inc + dec);\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344158,
                "title": "sorting-prefix-sum-binary-search",
                "content": "# Intuition\\nIntuition is we need to make all element equal to given target and there is time constraint to we need to think like number of elements that are going to be increase i.e number which is less than target and decrease the number which is greater than the target.\\n\\n# Approach\\nAs going on each index will lead to TLE so to optimize this ,sort the array and now we can find index till that we need to increase and after that we need to decrease.For this purpose I used lower bound.Now to count the step I use prefix sum .To avoid runtime error ,use long long.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))-for sorting\\nO(n)-for prefix sum\\nO(n*(log(n)))-for quering \\n\\n- Space complexity:\\nO(n)-for prefix sum\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        vector<long long >ans;\\n      sort(nums.begin(),nums.end());\\n        vector<long long >prefix(n);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++)prefix[i]=nums[i]+prefix[i-1];\\n      \\n        for(auto x:queries)\\n        {\\n          long long  target=x;\\n          long long  l=0,h=n-1;\\n          long long idx=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n          if(idx<n)\\n          {\\n            if(nums[idx]>target )idx--;\\n          }\\n          else idx--;\\n          \\n          // cout<<idx<<endl;\\n          if(idx<0)\\n          {\\n            long long rest=prefix[n-1]-(n)*target;\\n          ans.push_back(rest);\\n          }\\n          else\\n          {\\n            long long cnt=(idx+1)*(1ll)*target-prefix[idx];\\n          long long rest=prefix[n-1]-prefix[idx]-(n-idx-1)*target;\\n          long long res=cnt+rest;\\n          ans.push_back(res);\\n          }\\n          \\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        vector<long long >ans;\\n      sort(nums.begin(),nums.end());\\n        vector<long long >prefix(n);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++)prefix[i]=nums[i]+prefix[i-1];\\n      \\n        for(auto x:queries)\\n        {\\n          long long  target=x;\\n          long long  l=0,h=n-1;\\n          long long idx=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n          if(idx<n)\\n          {\\n            if(nums[idx]>target )idx--;\\n          }\\n          else idx--;\\n          \\n          // cout<<idx<<endl;\\n          if(idx<0)\\n          {\\n            long long rest=prefix[n-1]-(n)*target;\\n          ans.push_back(rest);\\n          }\\n          else\\n          {\\n            long long cnt=(idx+1)*(1ll)*target-prefix[idx];\\n          long long rest=prefix[n-1]-prefix[idx]-(n-idx-1)*target;\\n          long long res=cnt+rest;\\n          ans.push_back(res);\\n          }\\n          \\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3342944,
                "title": "easy-solution-using-prefix-sum-lower-bound-upper-bound",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        vector<long long> ans;\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        // Ye brute force hai.\\n\\n        // for(int i = 0; i < queries.size(); i++) {\\n        //     long long temp = 0;\\n        //     for(int j = 0; j < nums.size(); j++) {\\n        //         temp += abs(nums[j] - queries[i]);\\n        //     }\\n        //     ans.push_back(temp);\\n        // }\\n\\n        // Prefix nikal lo pahle\\n        vector<long long> prefix(n+1);\\n        prefix[0] = 0;\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            prefix[i+1] = sum;\\n        }\\n\\n        for(auto q: queries) {\\n\\n            \\n            long long lb = lower_bound(nums.begin(), nums.end(), q) - nums.begin() - 1;\\n            // lb pe -1 kia hai kyuni ye equal ya usse bada element ka pointer\\n            // return karta hai to mujhe usse niche wala chaiye, to agr equal \\n            // hua to -1 karu ga aur agr bada hua to -1 karu ga usse niche jane k\\n            // liye\\n            long long ub = upper_bound(nums.begin(), nums.end(), q) - nums.begin();\\n            long long left = 0;\\n            if(lb != -1) {\\n                left += (q*(lb+1)) - (prefix[lb+1] - prefix[0]);\\n            }\\n            long long right = 0;\\n            if(ub != n) {\\n                right += (prefix[n] - prefix[ub]) - (q*(n-ub));\\n            }  \\n            ans.push_back(left+right);\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        vector<long long> ans;\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        // Ye brute force hai.\\n\\n        // for(int i = 0; i < queries.size(); i++) {\\n        //     long long temp = 0;\\n        //     for(int j = 0; j < nums.size(); j++) {\\n        //         temp += abs(nums[j] - queries[i]);\\n        //     }\\n        //     ans.push_back(temp);\\n        // }\\n\\n        // Prefix nikal lo pahle\\n        vector<long long> prefix(n+1);\\n        prefix[0] = 0;\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            prefix[i+1] = sum;\\n        }\\n\\n        for(auto q: queries) {\\n\\n            \\n            long long lb = lower_bound(nums.begin(), nums.end(), q) - nums.begin() - 1;\\n            // lb pe -1 kia hai kyuni ye equal ya usse bada element ka pointer\\n            // return karta hai to mujhe usse niche wala chaiye, to agr equal \\n            // hua to -1 karu ga aur agr bada hua to -1 karu ga usse niche jane k\\n            // liye\\n            long long ub = upper_bound(nums.begin(), nums.end(), q) - nums.begin();\\n            long long left = 0;\\n            if(lb != -1) {\\n                left += (q*(lb+1)) - (prefix[lb+1] - prefix[0]);\\n            }\\n            long long right = 0;\\n            if(ub != n) {\\n                right += (prefix[n] - prefix[ub]) - (q*(n-ub));\\n            }  \\n            ans.push_back(left+right);\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342621,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<long long>ans;\\n        long long total=accumulate(nums.begin(),nums.end(),0ll);\\n        vector<long long>temp(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            temp[i+1]=temp[i]+nums[i];    \\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int index=lower_bound(nums.begin(),nums.end(),q[i])-nums.begin();\\n            long long left_sum=1ll*q[i]*(index)-temp[index];\\n            long long right_sum=(total-temp[index])-1ll*q[i]*(n-index);\\n            ans.push_back(left_sum+right_sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<long long>ans;\\n        long long total=accumulate(nums.begin(),nums.end(),0ll);\\n        vector<long long>temp(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            temp[i+1]=temp[i]+nums[i];    \\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int index=lower_bound(nums.begin(),nums.end(),q[i])-nums.begin();\\n            long long left_sum=1ll*q[i]*(index)-temp[index];\\n            long long right_sum=(total-temp[index])-1ll*q[i]*(n-index);\\n            ans.push_back(left_sum+right_sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342541,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        n=len(nums)\\n        prefix=[0]+list(accumulate(nums))\\n        ans=[]\\n        for x in queries:\\n            i=bisect_left(nums,x)\\n            ans.append(x*(2*i-n)+prefix[n]-2*prefix[i])\\n\\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        n=len(nums)\\n        prefix=[0]+list(accumulate(nums))\\n        ans=[]\\n        for x in queries:\\n            i=bisect_left(nums,x)\\n            ans.append(x*(2*i-n)+prefix[n]-2*prefix[i])\\n\\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342445,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    vector<long long> minOperations(vector<int>& a, vector<int>& q) {\\n        sort(a.begin(),a.end());\\n        int n=a.size();\\n        ll pre[n],suf[n];\\n        pre[0]=a[0],suf[n-1]=a[n-1];\\n        for(int i=1;i<n;i++)pre[i]=pre[i-1]+a[i];\\n        for(int i=n-2;i>=0;i--)suf[i]=suf[i+1]+a[i];\\n        vector<ll> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            ll no=q[i];\\n            ll s=upper_bound(a.begin(),a.end(),no)-a.begin();\\n            if(s==0)ans.push_back(suf[s]-(n-s)*no);\\n            else if(s==n)ans.push_back(no*s-pre[s-1]);\\n            else ans.push_back(no*s-pre[s-1]+suf[s]-(n-s)*no);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    vector<long long> minOperations(vector<int>& a, vector<int>& q) {\\n        sort(a.begin(),a.end());\\n        int n=a.size();\\n        ll pre[n],suf[n];\\n        pre[0]=a[0],suf[n-1]=a[n-1];\\n        for(int i=1;i<n;i++)pre[i]=pre[i-1]+a[i];\\n        for(int i=n-2;i>=0;i--)suf[i]=suf[i+1]+a[i];\\n        vector<ll> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            ll no=q[i];\\n            ll s=upper_bound(a.begin(),a.end(),no)-a.begin();\\n            if(s==0)ans.push_back(suf[s]-(n-s)*no);\\n            else if(s==n)ans.push_back(no*s-pre[s-1]);\\n            else ans.push_back(no*s-pre[s-1]+suf[s]-(n-s)*no);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342260,
                "title": "java-sorting-prefix-sum-binary-search",
                "content": "## Complexity\\n- Time complexity: O((m+n)logn)\\n\\n- Space complexity: O(n)\\n\\n## Code\\n``` java []\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        List<Long> list = new ArrayList<>();\\n        long[] prefix = new long[nums.length+2]; // taking prefix[0] an prefix[prefix.length-1] as 0 to avoid Index Out Of Bound\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            prefix[i+1]=sum;\\n        }\\n        for(int x:queries){\\n            int idx = Arrays.binarySearch(nums,x);\\n            if(idx<0){\\n                idx = -1*(idx+2);\\n            }\\n            list.add(((long)(idx+1)*x - prefix[idx+1]) + ((prefix[prefix.length-2] - prefix[idx+1]) - (long)(nums.length - idx - 1)*x));\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sort",
                    "Prefix Sum"
                ],
                "code": "``` java []\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        List<Long> list = new ArrayList<>();\\n        long[] prefix = new long[nums.length+2]; // taking prefix[0] an prefix[prefix.length-1] as 0 to avoid Index Out Of Bound\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            prefix[i+1]=sum;\\n        }\\n        for(int x:queries){\\n            int idx = Arrays.binarySearch(nums,x);\\n            if(idx<0){\\n                idx = -1*(idx+2);\\n            }\\n            list.add(((long)(idx+1)*x - prefix[idx+1]) + ((prefix[prefix.length-2] - prefix[idx+1]) - (long)(nums.length - idx - 1)*x));\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342137,
                "title": "sorting-prefix-sum-binarysearch-java-attention-the-overflow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        List<Long> res = new ArrayList<>();\\n        int n = nums.length;\\n        long[] record = new long[n];\\n        Arrays.sort(nums);      \\n        record[0] = nums[0];\\n        for(int i = 1; i < n; i++){\\n            record[i] = record[i-1] + nums[i];\\n        }\\n        \\n        \\n        for(int i = 0; i < queries.length; i++){\\n            long cur = 0;\\n            int tmp = search(nums, queries[i]);\\n            if(tmp == -1)tmp = 0;\\n            cur += Math.abs(record[tmp] - (long)queries[i] * (tmp+1));\\n            cur += Math.abs(record[n-1] - record[tmp] - (long)queries[i] * (n-tmp-1)); \\n            res.add(cur);\\n        }\\n        return res;\\n    }\\n    \\n    public int search(int[] arr, int target){\\n        int left = 0, right = arr.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right-left) / 2;\\n            \\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        List<Long> res = new ArrayList<>();\\n        int n = nums.length;\\n        long[] record = new long[n];\\n        Arrays.sort(nums);      \\n        record[0] = nums[0];\\n        for(int i = 1; i < n; i++){\\n            record[i] = record[i-1] + nums[i];\\n        }\\n        \\n        \\n        for(int i = 0; i < queries.length; i++){\\n            long cur = 0;\\n            int tmp = search(nums, queries[i]);\\n            if(tmp == -1)tmp = 0;\\n            cur += Math.abs(record[tmp] - (long)queries[i] * (tmp+1));\\n            cur += Math.abs(record[n-1] - record[tmp] - (long)queries[i] * (n-tmp-1)); \\n            res.add(cur);\\n        }\\n        return res;\\n    }\\n    \\n    public int search(int[] arr, int target){\\n        int left = 0, right = arr.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right-left) / 2;\\n            \\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342098,
                "title": "c-easy-solution-binary-search-sorting-o-nlongn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<long long> res;\\n    \\n    static int next(vector<int>& arr, int target) {\\n        int start = 0, end = arr.size() - 1;\\n        if (end == 0) return -1;\\n        if (target > arr[end]) return end;\\n\\n        int ans = -1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2; // avoid overflow\\n            if (arr[mid] >= target) {\\n                end = mid - 1;\\n            } else {\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n   \\n    void helper(vector<int>& nums, vector<long long>& prefix, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int pos = next(nums, k);\\n        \\n        long long currRes = (pos == -1 ? 0 : abs(((pos + 1LL) * (long long)k) - prefix[pos])) * 1LL;\\n        long long nextSum = (pos == -1 ? prefix[n - 1] : prefix[n - 1] - prefix[pos]) * 1LL;\\n        long long total = (pos == -1 ? (long long)k * (n) : (long long)k * ((n - 1) - pos)) * 1LL;\\n        res.push_back(currRes + abs(total - nextSum));\\n    }\\n    \\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        int m = queries.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<long long> prefix(n);\\n        long long sum = 0LL;\\n        for(int i = 0; i < n; i++){\\n            sum += (long long)nums[i]; // cast to long long to avoid overflow\\n            prefix[i] = sum * 1LL;\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            helper(nums, prefix, queries[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<long long> res;\\n    \\n    static int next(vector<int>& arr, int target) {\\n        int start = 0, end = arr.size() - 1;\\n        if (end == 0) return -1;\\n        if (target > arr[end]) return end;\\n\\n        int ans = -1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2; // avoid overflow\\n            if (arr[mid] >= target) {\\n                end = mid - 1;\\n            } else {\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n   \\n    void helper(vector<int>& nums, vector<long long>& prefix, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int pos = next(nums, k);\\n        \\n        long long currRes = (pos == -1 ? 0 : abs(((pos + 1LL) * (long long)k) - prefix[pos])) * 1LL;\\n        long long nextSum = (pos == -1 ? prefix[n - 1] : prefix[n - 1] - prefix[pos]) * 1LL;\\n        long long total = (pos == -1 ? (long long)k * (n) : (long long)k * ((n - 1) - pos)) * 1LL;\\n        res.push_back(currRes + abs(total - nextSum));\\n    }\\n    \\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        int m = queries.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<long long> prefix(n);\\n        long long sum = 0LL;\\n        for(int i = 0; i < n; i++){\\n            sum += (long long)nums[i]; // cast to long long to avoid overflow\\n            prefix[i] = sum * 1LL;\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            helper(nums, prefix, queries[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342068,
                "title": "runtime-235-ms-beats-100",
                "content": "# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution \\n{\\npublic:\\n  vector<long long int>prefix;\\n  vector<long long> minOperations(vector<int>& nums, vector<int>& queries) \\n\\t{\\n\\t\\t  //to perform the binary search on the array we need to sort the array\\n\\t\\t sort(nums.begin() , nums.end());\\n\\t\\t \\n         //first of all we need to do the preprocessing of the nums \\n\\t\\t for(int i=0;i<nums.size();i++)\\n\\t\\t {\\n\\t\\t     if(prefix.size() == 0)\\n\\t\\t\\t {\\n\\t\\t\\t      prefix.push_back(nums[i]);\\n\\t\\t\\t }\\t\\n\\t\\t\\t else\\n\\t\\t\\t {\\n\\t\\t\\t \\tlong long int sum = 0LL + prefix.back() + nums[i];\\n\\t\\t\\t \\tprefix.push_back(sum);\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t \\n\\t\\t //processing the each query \\n\\t\\t vector<long long int>ans;\\n\\t\\t for(int i=0;i<queries.size();i++)\\n\\t\\t {\\n\\t\\t \\n\\t\\t \\t  int ele = queries[i];\\n\\t\\t      long long int val = binary_search_(ele,nums);\\t\\n\\t\\t      ans.push_back(val);\\n\\t\\t }    \\n\\t\\t return ans;\\n    }\\n    long long int binary_search_(int &ele,vector<int>&nums)\\n    {\\n    \\tint start = 0;\\n    \\tint end   = nums.size()-1;\\n    \\tint pos = -1;\\n    \\t\\n    \\twhile(start <= end)\\n    \\t{\\n    \\t\\tlong long int mid = (start + ((end - start)/2));\\n    \\t\\t\\n    \\t\\t//we need to find the last pos of the ele in the nums\\n    \\t    if(nums[mid] == ele)\\n\\t\\t\\t{\\n\\t\\t\\t    pos = mid;\\n\\t\\t\\t\\tstart = mid+1;\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\telse if(ele > nums[mid])\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = mid+1;\\n\\t\\t\\t}\\n\\t\\t\\telse if(ele < nums[mid])\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = mid-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(pos == -1)\\n\\t\\t{\\n\\t\\t\\tlong long int ans = 0;\\n\\t\\t\\tif(start>=0 and start<nums.size())\\n\\t\\t\\t{\\n\\t\\t\\t     long long int bigger = 0LL + ((nums.size()-1) - start + 1);\\t\\n\\t\\t\\t     long long int sum    = prefix[prefix.size()+-1];\\n\\t\\t\\t     \\n\\t\\t\\t     if(start > 0) sum = sum - prefix[start-1];\\n\\t\\t\\t     \\n\\t\\t\\t     long long int val = (sum - (bigger*ele));\\n\\t\\t\\t     \\n\\t\\t\\t     ans = ans + 0LL + val;\\n\\t\\t\\t}\\n\\t\\t\\tif((end>=0 and end<nums.size()))\\n\\t\\t\\t{\\n\\t\\t\\t\\t//taking out the smaller elements \\n\\t\\t\\t    long long int smaller = 0LL + (end - 0 + 1);\\t\\n\\t\\t\\t    long long int sum     = 0LL + prefix[end];\\n\\t\\t\\t\\tlong long int val     = 0LL + ((smaller*ele) - sum);     \\n\\t\\t\\t    ans = ans + 0LL + val;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\telse if(pos != -1)\\n\\t\\t{\\t  \\n\\t\\t      \\n\\t\\t      long long int ans = 0;\\n\\t\\t      \\n\\t\\t      long long int smaller = 0LL + pos - 0 + 1;\\n\\t\\t      \\n\\t\\t      //if(ele == 1) cout<<\"smaller = \"<<smaller<<endl;\\n\\t\\t      \\n\\t\\t      \\n\\t\\t      if(smaller > 0)\\n\\t\\t      {\\n\\t\\t      \\t\\n\\t\\t\\t  \\n\\t\\t      long long int sum     = 0LL + prefix[pos];\\n\\t\\t      long long int val1     = 0LL + ((smaller*ele) - sum);     \\n\\t\\t      \\n\\t\\t      ans = ans + 0LL + val1;\\n\\t\\t      \\n\\t\\t     }\\n\\t\\t      \\n\\t\\t       \\n\\t\\t      long long int bigger = 0LL + ((nums.size()-1) - (pos+1) + 1);\\n\\t\\t      \\n\\t\\t      //if(ele == 1) cout<<\"bigger = \"<<bigger<<endl;\\n\\t\\t      \\n\\t\\t      if(bigger > 0)\\n\\t\\t      {\\n\\t\\t      \\t\\n\\t\\t      long long int sum    = 0LL + prefix[prefix.size()-1];\\n\\t\\t      \\n\\t\\t      if(pos+1-1 >= 0) sum = sum - prefix[pos+1-1];\\n\\t\\t      long long int val2 = (sum - (bigger*ele));\\n\\t\\t      \\n\\t\\t      \\n\\t\\t      \\n\\t\\t      ans = ans + 0LL + val2;\\n\\t\\t     }\\n\\t\\t     //cout<<\"ans = \"<<ans<<endl;\\n\\t\\t     return ans; \\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution \\n{\\npublic:\\n  vector<long long int>prefix;\\n  vector<long long> minOperations(vector<int>& nums, vector<int>& queries) \\n\\t{\\n\\t\\t  //to perform the binary search on the array we need to sort the array\\n\\t\\t sort(nums.begin() , nums.end());\\n\\t\\t \\n         //first of all we need to do the preprocessing of the nums \\n\\t\\t for(int i=0;i<nums.size();i++)\\n\\t\\t {\\n\\t\\t     if(prefix.size() == 0)\\n\\t\\t\\t {\\n\\t\\t\\t      prefix.push_back(nums[i]);\\n\\t\\t\\t }\\t\\n\\t\\t\\t else\\n\\t\\t\\t {\\n\\t\\t\\t \\tlong long int sum = 0LL + prefix.back() + nums[i];\\n\\t\\t\\t \\tprefix.push_back(sum);\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t \\n\\t\\t //processing the each query \\n\\t\\t vector<long long int>ans;\\n\\t\\t for(int i=0;i<queries.size();i++)\\n\\t\\t {\\n\\t\\t \\n\\t\\t \\t  int ele = queries[i];\\n\\t\\t      long long int val = binary_search_(ele,nums);\\t\\n\\t\\t      ans.push_back(val);\\n\\t\\t }    \\n\\t\\t return ans;\\n    }\\n    long long int binary_search_(int &ele,vector<int>&nums)\\n    {\\n    \\tint start = 0;\\n    \\tint end   = nums.size()-1;\\n    \\tint pos = -1;\\n    \\t\\n    \\twhile(start <= end)\\n    \\t{\\n    \\t\\tlong long int mid = (start + ((end - start)/2));\\n    \\t\\t\\n    \\t\\t//we need to find the last pos of the ele in the nums\\n    \\t    if(nums[mid] == ele)\\n\\t\\t\\t{\\n\\t\\t\\t    pos = mid;\\n\\t\\t\\t\\tstart = mid+1;\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\telse if(ele > nums[mid])\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = mid+1;\\n\\t\\t\\t}\\n\\t\\t\\telse if(ele < nums[mid])\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = mid-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(pos == -1)\\n\\t\\t{\\n\\t\\t\\tlong long int ans = 0;\\n\\t\\t\\tif(start>=0 and start<nums.size())\\n\\t\\t\\t{\\n\\t\\t\\t     long long int bigger = 0LL + ((nums.size()-1) - start + 1);\\t\\n\\t\\t\\t     long long int sum    = prefix[prefix.size()+-1];\\n\\t\\t\\t     \\n\\t\\t\\t     if(start > 0) sum = sum - prefix[start-1];\\n\\t\\t\\t     \\n\\t\\t\\t     long long int val = (sum - (bigger*ele));\\n\\t\\t\\t     \\n\\t\\t\\t     ans = ans + 0LL + val;\\n\\t\\t\\t}\\n\\t\\t\\tif((end>=0 and end<nums.size()))\\n\\t\\t\\t{\\n\\t\\t\\t\\t//taking out the smaller elements \\n\\t\\t\\t    long long int smaller = 0LL + (end - 0 + 1);\\t\\n\\t\\t\\t    long long int sum     = 0LL + prefix[end];\\n\\t\\t\\t\\tlong long int val     = 0LL + ((smaller*ele) - sum);     \\n\\t\\t\\t    ans = ans + 0LL + val;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\telse if(pos != -1)\\n\\t\\t{\\t  \\n\\t\\t      \\n\\t\\t      long long int ans = 0;\\n\\t\\t      \\n\\t\\t      long long int smaller = 0LL + pos - 0 + 1;\\n\\t\\t      \\n\\t\\t      //if(ele == 1) cout<<\"smaller = \"<<smaller<<endl;\\n\\t\\t      \\n\\t\\t      \\n\\t\\t      if(smaller > 0)\\n\\t\\t      {\\n\\t\\t      \\t\\n\\t\\t\\t  \\n\\t\\t      long long int sum     = 0LL + prefix[pos];\\n\\t\\t      long long int val1     = 0LL + ((smaller*ele) - sum);     \\n\\t\\t      \\n\\t\\t      ans = ans + 0LL + val1;\\n\\t\\t      \\n\\t\\t     }\\n\\t\\t      \\n\\t\\t       \\n\\t\\t      long long int bigger = 0LL + ((nums.size()-1) - (pos+1) + 1);\\n\\t\\t      \\n\\t\\t      //if(ele == 1) cout<<\"bigger = \"<<bigger<<endl;\\n\\t\\t      \\n\\t\\t      if(bigger > 0)\\n\\t\\t      {\\n\\t\\t      \\t\\n\\t\\t      long long int sum    = 0LL + prefix[prefix.size()-1];\\n\\t\\t      \\n\\t\\t      if(pos+1-1 >= 0) sum = sum - prefix[pos+1-1];\\n\\t\\t      long long int val2 = (sum - (bigger*ele));\\n\\t\\t      \\n\\t\\t      \\n\\t\\t      \\n\\t\\t      ans = ans + 0LL + val2;\\n\\t\\t     }\\n\\t\\t     //cout<<\"ans = \"<<ans<<endl;\\n\\t\\t     return ans; \\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3341959,
                "title": "binary-search-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        int n = size(nums);\\n        sort(begin(nums), end(nums));\\n        \\n        vector<long long> pre(n);\\n        \\n        pre[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            pre[i] = 0LL + pre[i-1] + nums[i];\\n        }\\n        \\n        int m = size(queries);\\n        vector<long long> res;\\n        \\n        for(int i = 0; i < m; i++) {\\n            long long val = queries[i];\\n            \\n            int lb = (upper_bound(begin(nums), end(nums),val) - begin(nums));\\n            \\n            lb--;\\n            // cout << lb << \\' \\';\\n            long long ans = 0;\\n            if(lb != -1 and lb < n) {\\n                long long sum = 1LL * val * (lb+1);\\n                ans += 0LL + abs(sum - pre[lb]);\\n            }\\n            long long rem;\\n            if(lb == -1)rem = n;\\n            else  rem = n-lb-1;\\n            \\n            if(rem) {\\n                long long sum = 1LL * val * rem;\\n                long long sums;\\n                if(lb == -1)sums = pre[n-1];\\n                else\\n                sums = 0LL + pre[n-1] - pre[lb];\\n                \\n                ans += 0LL + abs(sum - sums);\\n            }\\n            res.push_back(ans);\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        int n = size(nums);\\n        sort(begin(nums), end(nums));\\n        \\n        vector<long long> pre(n);\\n        \\n        pre[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            pre[i] = 0LL + pre[i-1] + nums[i];\\n        }\\n        \\n        int m = size(queries);\\n        vector<long long> res;\\n        \\n        for(int i = 0; i < m; i++) {\\n            long long val = queries[i];\\n            \\n            int lb = (upper_bound(begin(nums), end(nums),val) - begin(nums));\\n            \\n            lb--;\\n            // cout << lb << \\' \\';\\n            long long ans = 0;\\n            if(lb != -1 and lb < n) {\\n                long long sum = 1LL * val * (lb+1);\\n                ans += 0LL + abs(sum - pre[lb]);\\n            }\\n            long long rem;\\n            if(lb == -1)rem = n;\\n            else  rem = n-lb-1;\\n            \\n            if(rem) {\\n                long long sum = 1LL * val * rem;\\n                long long sums;\\n                if(lb == -1)sums = pre[n-1];\\n                else\\n                sums = 0LL + pre[n-1] - pre[lb];\\n                \\n                ans += 0LL + abs(sum - sums);\\n            }\\n            res.push_back(ans);\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3341892,
                "title": "nlogn-easy-solution",
                "content": "For each query target in queries, the solution performs binary search on the sorted array nums to find the index i such that nums[i] is the smallest element greater than or equal to the target. It then calculates the sum of the following two parts:\\n\\nThe total number of operations required to make the first i elements of nums equal to target. This is calculated as i * target - prefix[i-1] where prefix[i-1] represents the sum of the first i-1 elements of nums.\\n\\nThe total number of operations required to make the last n-i elements of nums equal to target. This is calculated as (prefix[n-1] - prefix[i-1]) - (n - i) * target where prefix[n-1] - prefix[i-1] represents the sum of the last n-i elements of nums.\\n        \\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        prefix = []\\n        nums.sort()\\n        prev = 0\\n        for num in nums:\\n            prev += num\\n            prefix.append(prev)\\n        \\n        data = []\\n        for target in queries:\\n            i = 0\\n            k = len(prefix)\\n            tot = 0\\n            while i < k:\\n                j = (i + k) // 2\\n                if nums[j] > target: k = j\\n                else: i = j + 1\\n        \\n            backs = prefix[i - 1] if i != 0 else 0\\n            tot += i * target - backs\\n            tot += (prefix[-1] - backs) - (len(nums) - i) * target\\n            data.append(tot)\\n        \\n        return data\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        prefix = []\\n        nums.sort()\\n        prev = 0\\n        for num in nums:\\n            prev += num\\n            prefix.append(prev)\\n        \\n        data = []\\n        for target in queries:\\n            i = 0\\n            k = len(prefix)\\n            tot = 0\\n            while i < k:\\n                j = (i + k) // 2\\n                if nums[j] > target: k = j\\n                else: i = j + 1\\n        \\n            backs = prefix[i - 1] if i != 0 else 0\\n            tot += i * target - backs\\n            tot += (prefix[-1] - backs) - (len(nums) - i) * target\\n            data.append(tot)\\n        \\n        return data\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967779,
                "title": "go-o-q-logn-prefix-sum-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(q * logn), where q is the length of queries\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minOperations(nums []int, queries []int) []int64 {\\n    answers := make([]int64, len(queries))\\n    prefixSum := make([]int, len(nums))\\n    prefixSumVal := 0\\n    // Sort the nums \\n    sort.Ints(nums)\\n\\n    // Find prefixSum \\n    for i := 0; i< len(nums); i++ {\\n        prefixSumVal += nums[i]\\n        prefixSum[i] = prefixSumVal\\n    }\\n\\n    for i, q := range queries {\\n        var operations int64\\n \\n        // Find the index of the immediate smaller element\\n        smallerIndex := findSmallerIndex(nums, q)\\n        if smallerIndex > -1 {\\n            // Means smaller elements exist \\n            // Check how many smaller elements exist \\n            smallerCount := smallerIndex + 1 \\n            prefixSumSmallerIndex := prefixSum[smallerIndex]\\n            expectedPrefixSum := smallerCount * q \\n            operations += Abs(int64(expectedPrefixSum - prefixSumSmallerIndex))\\n        }\\n\\n        // Find the index of the immediate larger element \\n        largerIndex := findLargerIndex(nums, q)\\n        if largerIndex > -1 {\\n            // Larger index exists \\n            // Check the count for larger index\\n            largerCount := len(nums) - largerIndex\\n            prefixSumLargerIndex := prefixSum[len(nums) -  1]\\n            if largerIndex > 0 {\\n                prefixSumLargerIndex -= prefixSum[largerIndex - 1]\\n            }\\n\\n            expectedSum := largerCount * q\\n            operations += Abs(int64(prefixSumLargerIndex - expectedSum))\\n        } \\n        answers[i] = operations\\n    }\\n\\n    return answers\\n}\\n\\nfunc findSmallerIndex(nums []int, target int) int {\\n    index := -1 \\n\\n    start := 0 \\n    end := len(nums) - 1 \\n\\n    for start <= end {\\n        mid := (start + end) / 2 \\n        if nums[mid] >= target {\\n            end = mid - 1\\n        }else {\\n            index = mid\\n            start = mid + 1\\n        }\\n    }\\n\\n    return index\\n}\\n\\nfunc findLargerIndex(nums []int, target int) int{\\n    index := -1 \\n    start := 0 \\n    end := len(nums) - 1\\n\\n    for start <= end {\\n        mid := (start + end) / 2\\n        if nums[mid] <= target {\\n            start = mid + 1\\n        }else {\\n            index = mid\\n            end = mid - 1\\n        }\\n    }\\n    return index\\n}\\n\\nfunc Abs(num int64) int64{\\n    if num < 0 {\\n        return 0-num\\n    }else {\\n        return num\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minOperations(nums []int, queries []int) []int64 {\\n    answers := make([]int64, len(queries))\\n    prefixSum := make([]int, len(nums))\\n    prefixSumVal := 0\\n    // Sort the nums \\n    sort.Ints(nums)\\n\\n    // Find prefixSum \\n    for i := 0; i< len(nums); i++ {\\n        prefixSumVal += nums[i]\\n        prefixSum[i] = prefixSumVal\\n    }\\n\\n    for i, q := range queries {\\n        var operations int64\\n \\n        // Find the index of the immediate smaller element\\n        smallerIndex := findSmallerIndex(nums, q)\\n        if smallerIndex > -1 {\\n            // Means smaller elements exist \\n            // Check how many smaller elements exist \\n            smallerCount := smallerIndex + 1 \\n            prefixSumSmallerIndex := prefixSum[smallerIndex]\\n            expectedPrefixSum := smallerCount * q \\n            operations += Abs(int64(expectedPrefixSum - prefixSumSmallerIndex))\\n        }\\n\\n        // Find the index of the immediate larger element \\n        largerIndex := findLargerIndex(nums, q)\\n        if largerIndex > -1 {\\n            // Larger index exists \\n            // Check the count for larger index\\n            largerCount := len(nums) - largerIndex\\n            prefixSumLargerIndex := prefixSum[len(nums) -  1]\\n            if largerIndex > 0 {\\n                prefixSumLargerIndex -= prefixSum[largerIndex - 1]\\n            }\\n\\n            expectedSum := largerCount * q\\n            operations += Abs(int64(prefixSumLargerIndex - expectedSum))\\n        } \\n        answers[i] = operations\\n    }\\n\\n    return answers\\n}\\n\\nfunc findSmallerIndex(nums []int, target int) int {\\n    index := -1 \\n\\n    start := 0 \\n    end := len(nums) - 1 \\n\\n    for start <= end {\\n        mid := (start + end) / 2 \\n        if nums[mid] >= target {\\n            end = mid - 1\\n        }else {\\n            index = mid\\n            start = mid + 1\\n        }\\n    }\\n\\n    return index\\n}\\n\\nfunc findLargerIndex(nums []int, target int) int{\\n    index := -1 \\n    start := 0 \\n    end := len(nums) - 1\\n\\n    for start <= end {\\n        mid := (start + end) / 2\\n        if nums[mid] <= target {\\n            start = mid + 1\\n        }else {\\n            index = mid\\n            end = mid - 1\\n        }\\n    }\\n    return index\\n}\\n\\nfunc Abs(num int64) int64{\\n    if num < 0 {\\n        return 0-num\\n    }else {\\n        return num\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941499,
                "title": "binary-search-in-c",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long n=nums.size();\\n        vector<long long> ans;\\n        long long sum=0;\\n        vector<long long> ps(n);\\n        sort(nums.begin(),nums.end());\\n        ps[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            ps[i]=ps[i-1]+nums[i];\\n        }\\n        for(auto i:queries){\\n            long long low =lower_bound(nums.begin(),nums.end(),i)-nums.begin();\\n            if(low==n||low==0){\\n                ans.push_back(abs((n*i)-(ps[n-1])));\\n            }\\n            else {\\n                if(i<nums[low]) low--;\\n                ans.push_back(abs((low+1)*(long long)i-ps[low])+abs((n-low-1)*(long long)i-(ps[n-1]-ps[low])));\\n                // cout<<low<<\" \"<<abs((low+1)*i-ps[low])<<\" \"<<abs((n-low-1)*i-(ps[n-1]-ps[low]))<<\" \"<<ps[low]<<i<<endl;\\n            }\\n            // ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long n=nums.size();\\n        vector<long long> ans;\\n        long long sum=0;\\n        vector<long long> ps(n);\\n        sort(nums.begin(),nums.end());\\n        ps[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            ps[i]=ps[i-1]+nums[i];\\n        }\\n        for(auto i:queries){\\n            long long low =lower_bound(nums.begin(),nums.end(),i)-nums.begin();\\n            if(low==n||low==0){\\n                ans.push_back(abs((n*i)-(ps[n-1])));\\n            }\\n            else {\\n                if(i<nums[low]) low--;\\n                ans.push_back(abs((low+1)*(long long)i-ps[low])+abs((n-low-1)*(long long)i-(ps[n-1]-ps[low])));\\n                // cout<<low<<\" \"<<abs((low+1)*i-ps[low])<<\" \"<<abs((n-low-1)*i-(ps[n-1]-ps[low]))<<\" \"<<ps[low]<<i<<endl;\\n            }\\n            // ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3877723,
                "title": "prefix-sum-upper-bound-beats-95-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate prefix sum of an array and then find using upper bound. Like if we have partition [7,14] as prefix and need to convert all to 5 the we should have value like [5,10]. So at last just sub both sides.  \\n\\n# Complexity\\n- Time complexity:$$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(),nums.end());\\n        long long n=nums.size();\\n        vector<long long>pre(n);\\n        pre[0]=nums[0];\\n\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        vector<long long>ans;\\n        for(int i=0;i<q.size();i++){\\n            long long upr=upper_bound(nums.begin(),nums.end(),q[i])-nums.begin();\\n            long long temp=0;\\n            upr-=1;\\n            if(upr<0){\\n                temp=pre[n-1] - (n)*q[i];\\n                ans.push_back(temp);\\n            }\\n            else{\\n                temp=abs(((n-1)-upr)*q[i] - (pre[n-1] - pre[upr]));     \\n                temp+=abs((upr+1)*q[i] - pre[upr]);\\n                ans.push_back(temp);\\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(),nums.end());\\n        long long n=nums.size();\\n        vector<long long>pre(n);\\n        pre[0]=nums[0];\\n\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        vector<long long>ans;\\n        for(int i=0;i<q.size();i++){\\n            long long upr=upper_bound(nums.begin(),nums.end(),q[i])-nums.begin();\\n            long long temp=0;\\n            upr-=1;\\n            if(upr<0){\\n                temp=pre[n-1] - (n)*q[i];\\n                ans.push_back(temp);\\n            }\\n            else{\\n                temp=abs(((n-1)-upr)*q[i] - (pre[n-1] - pre[upr]));     \\n                temp+=abs((upr+1)*q[i] - pre[upr]);\\n                ans.push_back(temp);\\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876388,
                "title": "c-python-prefix-sum-solution-with-explanation",
                "content": "number <= queries[i]: (size of number <= queries[i]) * queries[i] - sum(number <= queries[i])\\nnumber > queries[i]: sum(number > queries[i]) - (size of number > queries[i]) * queries[i]\\n\\nsort nums first,\\nand calculate prefix sum.\\n\\nuse binary search to find i where nums[i] <= queries[j] and use prefix sum to find sum(number <= queries[j])\\n\\ntc is O((n+m)logn), sc is O(n)\\n\\n### python\\n```python\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        size = len(nums)\\n        nums.sort()\\n        prefix = [0]\\n        for n in nums:\\n            prefix.append(prefix[-1] + n)\\n\\n        ans = []\\n        for q in queries:\\n            i = bisect_right(nums, q)\\n            le = q * i - prefix[i]\\n            gt = prefix[-1] - prefix[i] - q * (size - i) \\n            ans.append(gt + le)\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int size = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<long long> prefix {0};\\n        for (int& i: nums) prefix.emplace_back(prefix.back() + i);\\n        \\n        vector<long long> ans;\\n        for (int& q: queries) {\\n            int i = upper_bound(nums.begin(), nums.end(), q) - nums.begin();\\n            long long le = (long long) q * i - prefix[i];\\n            long long gt = prefix.back() - prefix[i] - (long long) (size - i) * q;\\n            ans.emplace_back(gt + le);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        size = len(nums)\\n        nums.sort()\\n        prefix = [0]\\n        for n in nums:\\n            prefix.append(prefix[-1] + n)\\n\\n        ans = []\\n        for q in queries:\\n            i = bisect_right(nums, q)\\n            le = q * i - prefix[i]\\n            gt = prefix[-1] - prefix[i] - q * (size - i) \\n            ans.append(gt + le)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int size = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<long long> prefix {0};\\n        for (int& i: nums) prefix.emplace_back(prefix.back() + i);\\n        \\n        vector<long long> ans;\\n        for (int& q: queries) {\\n            int i = upper_bound(nums.begin(), nums.end(), q) - nums.begin();\\n            long long le = (long long) q * i - prefix[i];\\n            long long gt = prefix.back() - prefix[i] - (long long) (size - i) * q;\\n            ans.emplace_back(gt + le);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870649,
                "title": "beats-100-of-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this pro!-->\\nsort the array so as to find the position where the element in nums be divided in two parts so we can find the required steps to make all\\nelements equal to queries[i] separately for the elements before the found index and element after the found index.\\n\\nprefix_sum and suffix_sum arrays are required to find the sum of elements of nums upto required position.\\n\\nWe substract the sum found after one part of the nums from the sum required to be there if all elements equal to queries[i] , also again we find the sum of second part of nums and take the difference of it from the required sum to be there if queries[i] would be present.\\n\\nthen insert it in the array answer, ans[i]=sum;\\n\\nthen go for next i in the queries array till the queries array ends.\\n\\n                        PLEASE UPTVOTE !!!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n int cmp(const void*a,const void* b)\\n {\\n     return (*(int*)a-*(int*)b);\\n }\\nlong long* minOperations(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){\\n*returnSize=queriesSize;\\nlong long *ans=(long long*)malloc(sizeof(long long)*(*returnSize));\\nqsort(nums,numsSize,sizeof(int),cmp);\\nlong long prefix_sum[numsSize];\\nlong long suffix_sum[numsSize];\\nprefix_sum[0]=nums[0];\\nfor(int i=1;i<numsSize;i++)\\n{\\n    prefix_sum[i]=prefix_sum[i-1]+nums[i];\\n}\\nsuffix_sum[numsSize-1]=nums[numsSize-1];\\nfor(int i=numsSize-2;i>=0;i--)\\n{\\n   suffix_sum[i]=suffix_sum[i+1]+nums[i];\\n}\\nfor(int i=0;i<queriesSize;i++)\\n{\\n    long long sum=0;\\n    int l=0;\\n    int h=numsSize-1;\\n    int mid;\\n    while(l<=h)\\n    {\\n        mid=(l+h)/2;\\n        if(nums[mid]<=queries[i])\\n        {\\n            l=mid+1;\\n        }\\n        else\\n        h=mid-1;\\n    }\\n    if(l>0)\\n    {\\n      sum+=prefix_sum[l-1];\\n    }\\n    sum=((long long)l*queries[i])-sum;\\n    if(l<numsSize)\\n    {\\n        sum+=suffix_sum[l];\\n    }\\n    sum-=(long long)(numsSize-l)*queries[i];\\n    ans[i]=sum;\\n}\\nreturn ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n int cmp(const void*a,const void* b)\\n {\\n     return (*(int*)a-*(int*)b);\\n }\\nlong long* minOperations(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){\\n*returnSize=queriesSize;\\nlong long *ans=(long long*)malloc(sizeof(long long)*(*returnSize));\\nqsort(nums,numsSize,sizeof(int),cmp);\\nlong long prefix_sum[numsSize];\\nlong long suffix_sum[numsSize];\\nprefix_sum[0]=nums[0];\\nfor(int i=1;i<numsSize;i++)\\n{\\n    prefix_sum[i]=prefix_sum[i-1]+nums[i];\\n}\\nsuffix_sum[numsSize-1]=nums[numsSize-1];\\nfor(int i=numsSize-2;i>=0;i--)\\n{\\n   suffix_sum[i]=suffix_sum[i+1]+nums[i];\\n}\\nfor(int i=0;i<queriesSize;i++)\\n{\\n    long long sum=0;\\n    int l=0;\\n    int h=numsSize-1;\\n    int mid;\\n    while(l<=h)\\n    {\\n        mid=(l+h)/2;\\n        if(nums[mid]<=queries[i])\\n        {\\n            l=mid+1;\\n        }\\n        else\\n        h=mid-1;\\n    }\\n    if(l>0)\\n    {\\n      sum+=prefix_sum[l-1];\\n    }\\n    sum=((long long)l*queries[i])-sum;\\n    if(l<numsSize)\\n    {\\n        sum+=suffix_sum[l];\\n    }\\n    sum-=(long long)(numsSize-l)*queries[i];\\n    ans[i]=sum;\\n}\\nreturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863182,
                "title": "must-watch-solution-binary-search-prefix-sum-c",
                "content": "\\n# Intuition\\nO(N^2) Approach is obvious but will fail the constraints. Use Binary Seach + Prefix Sum to correctly solve the question under the Time Complexity of O(NlogN). \\n\\nPlease upvote my solution if you get any help \\uD83D\\uDC4F\\uD83D\\uDC4F\\uD83D\\uDC4F\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long calc(int a, int b){\\n        // multiply a*b with optimization\\n        long long sum=0;\\n        for(int i=0;i<a;i++) sum+=b;\\n        return sum;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n        vector<long long> ans;\\n        vector<long long> prefix;\\n        vector<long long> suffix;\\n        \\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            prefix.push_back(sum);\\n        }\\n\\n        sum=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            sum+=nums[i];\\n            suffix.push_back(sum);\\n        }\\n\\n        for(auto i:suffix) cout<<i<<\" \";\\n        for(auto i:queries){\\n            int pos = upper_bound(nums.begin(),nums.end(),i)-nums.begin();\\n            if(pos>=n){\\n                long long cur = calc(n,i)-prefix[pos-1];\\n                ans.push_back(cur);\\n            }\\n            else{\\n                long long cur=0;\\n                // Prefix Part\\n                if(pos-1>=0) cur+=calc(pos,i)-prefix[pos-1];\\n                // Suffix Part\\n                cur+=suffix[n-pos-1]-calc(n-pos,i);\\n                ans.push_back(cur);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long calc(int a, int b){\\n        // multiply a*b with optimization\\n        long long sum=0;\\n        for(int i=0;i<a;i++) sum+=b;\\n        return sum;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n        vector<long long> ans;\\n        vector<long long> prefix;\\n        vector<long long> suffix;\\n        \\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            prefix.push_back(sum);\\n        }\\n\\n        sum=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            sum+=nums[i];\\n            suffix.push_back(sum);\\n        }\\n\\n        for(auto i:suffix) cout<<i<<\" \";\\n        for(auto i:queries){\\n            int pos = upper_bound(nums.begin(),nums.end(),i)-nums.begin();\\n            if(pos>=n){\\n                long long cur = calc(n,i)-prefix[pos-1];\\n                ans.push_back(cur);\\n            }\\n            else{\\n                long long cur=0;\\n                // Prefix Part\\n                if(pos-1>=0) cur+=calc(pos,i)-prefix[pos-1];\\n                // Suffix Part\\n                cur+=suffix[n-pos-1]-calc(n-pos,i);\\n                ans.push_back(cur);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3848369,
                "title": "binary-search-sorting-prefix-sum-solution-easy-96-beats",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPosition(vector<int> &nums, int target){\\n        int ans = -1;\\n        int start = 0, end = nums.size()-1;\\n        while(start<=end){\\n            int m = start + (end-start)/2;\\n            if(nums[m]<target){\\n                start= m+1;\\n            }\\n            else{\\n                ans = m;\\n                end = m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        int m = queries.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> prefixSum;\\n        prefixSum.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            prefixSum.push_back(nums[i]+prefixSum[i-1]);\\n        }\\n        vector<long long> ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int index = findPosition(nums,queries[i]);\\n            cout<<index<<endl;\\n            // index aur uske baad ke saare mein se queries[i] minus hoga\\n            // aur baaki usse pehle ke mein se nums[i] minus hoga\\n            if(index==-1){\\n              ans[i] = (double)n*(double)queries[i] - prefixSum[n-1]; \\n            }\\n            else if(index==0){\\n                ans[i] = prefixSum[n-1] - (double)n*(double)queries[i];\\n            }\\n            else if(index==n-1){\\n                ans[i] = (nums[index] - queries[i]) + ((double)queries[i]*(double)index - prefixSum[index-1]); \\n            }\\n            else{\\n                double a = (prefixSum[n-1]-prefixSum[index-1]) - (double)((double)(n-index)*(double)queries[i]);\\n                double b = (double)queries[i]*(double)index - prefixSum[index-1];\\n                ans[i] =(long long) a+b;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPosition(vector<int> &nums, int target){\\n        int ans = -1;\\n        int start = 0, end = nums.size()-1;\\n        while(start<=end){\\n            int m = start + (end-start)/2;\\n            if(nums[m]<target){\\n                start= m+1;\\n            }\\n            else{\\n                ans = m;\\n                end = m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        int m = queries.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> prefixSum;\\n        prefixSum.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            prefixSum.push_back(nums[i]+prefixSum[i-1]);\\n        }\\n        vector<long long> ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int index = findPosition(nums,queries[i]);\\n            cout<<index<<endl;\\n            // index aur uske baad ke saare mein se queries[i] minus hoga\\n            // aur baaki usse pehle ke mein se nums[i] minus hoga\\n            if(index==-1){\\n              ans[i] = (double)n*(double)queries[i] - prefixSum[n-1]; \\n            }\\n            else if(index==0){\\n                ans[i] = prefixSum[n-1] - (double)n*(double)queries[i];\\n            }\\n            else if(index==n-1){\\n                ans[i] = (nums[index] - queries[i]) + ((double)queries[i]*(double)index - prefixSum[index-1]); \\n            }\\n            else{\\n                double a = (prefixSum[n-1]-prefixSum[index-1]) - (double)((double)(n-index)*(double)queries[i]);\\n                double b = (double)queries[i]*(double)index - prefixSum[index-1];\\n                ans[i] =(long long) a+b;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3842041,
                "title": "c-solution-without-binary-search-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>temp=q;\\n        sort(q.begin(),q.end());\\n        int n=nums.size();\\n        long long sum=0;\\n        long long total=accumulate(nums.begin(),nums.end(),0L);\\n        unordered_map<int,long long>m;\\n        long long j=0;\\n        for(long long i=0;i<q.size();i++){\\n            while(j<n && nums[j]<=q[i]){\\n                sum+=nums[j++];\\n            }\\n            m[q[i]]=((j*q[i])-sum)+((total-sum)-((n-j)*q[i]));\\n        }\\n        vector<long long>res(temp.size());\\n        for(int i=0;i<temp.size();i++){\\n            res[i]=m[temp[i]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>temp=q;\\n        sort(q.begin(),q.end());\\n        int n=nums.size();\\n        long long sum=0;\\n        long long total=accumulate(nums.begin(),nums.end(),0L);\\n        unordered_map<int,long long>m;\\n        long long j=0;\\n        for(long long i=0;i<q.size();i++){\\n            while(j<n && nums[j]<=q[i]){\\n                sum+=nums[j++];\\n            }\\n            m[q[i]]=((j*q[i])-sum)+((total-sum)-((n-j)*q[i]));\\n        }\\n        vector<long long>res(temp.size());\\n        for(int i=0;i<temp.size();i++){\\n            res[i]=m[temp[i]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833642,
                "title": "prefix-and-suffix-sum-binary-search-tc-o-m-n-log-n-n-sc-o-n-beats-78",
                "content": "# Complexity\\n- Time complexity:\\nO((m + n) * log(n) + n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * TC : O((M + N) * log(N) + N)\\n */\\nclass Solution {\\n  private int binarySearch(int[] nums, int key, int l, int r) {\\n    if (l == r) {\\n      return l;\\n    }\\n\\n    int mid = (l + r) / 2;\\n\\n    if (nums[mid] == key) {\\n      return mid;\\n    }\\n\\n    if (nums[mid] > key) {\\n      r = mid - 1;\\n    } else {\\n      l = mid + 1;\\n    }\\n\\n    return l > r ? l : this.binarySearch(nums, key, l, r);\\n  }\\n\\n  public List < Long > minOperations(int[] nums, int[] queries) {\\n    List < Long > result = new ArrayList < > ();\\n\\n    // n * log(n)\\n    Arrays.sort(nums);\\n\\n    long[] sumPrefixCost = new long[nums.length];\\n    long[] sumSuffixCost = new long[nums.length];\\n    int len = nums.length;\\n\\n    // O(n)\\n    for (int i = 0; i < nums.length; i++) {\\n      if (i == 0) {\\n        sumPrefixCost[i] = sumSuffixCost[nums.length - i - 1] = 0;\\n        continue;\\n      }\\n\\n      sumPrefixCost[i] = sumPrefixCost[i - 1] + (long)Math.abs(nums[i] - nums[i - 1]) * i;\\n      sumSuffixCost[nums.length - i - 1] = sumSuffixCost[nums.length - i] +\\n        (long)Math.abs(nums[nums.length - i] - nums[nums.length - i - 1]) * i;\\n    }\\n\\n    // O(m)\\n    for (int i = 0; i < queries.length; i++) {\\n      long cost = 0;\\n      if (queries[i] < nums[0]) {\\n        cost = sumSuffixCost[0] + (long)Math.abs(nums[0] - queries[i]) * len;\\n        result.add(cost);\\n        continue;\\n      }\\n\\n      if (queries[i] > nums[nums.length - 1]) {\\n        cost = sumPrefixCost[nums.length - 1] + (long)Math.abs(nums[nums.length - 1] - queries[i]) * len;\\n        result.add(cost);\\n        continue;\\n      }\\n\\n      // log(n)\\n      int loc = this.binarySearch(nums, queries[i], 0, nums.length - 1);\\n\\n      if (nums[loc] != queries[i]) {\\n        int left = loc - (nums[loc] > queries[i] ? 1 : 0);\\n        int right = loc + (nums[loc] < queries[i] ? 1 : 0);\\n        long tpc = sumPrefixCost[left] + (long)Math.abs(nums[left] - queries[i]) * (left + 1);\\n        long tsc = sumSuffixCost[right] + (long)Math.abs(nums[right] - queries[i]) * (len - right);\\n        cost = tpc + tsc;\\n        result.add(cost);\\n        continue;\\n      }\\n\\n      cost = sumPrefixCost[loc] + sumSuffixCost[loc];\\n      result.add(cost);\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n/**\\n * TC : O((M + N) * log(N) + N)\\n */\\nclass Solution {\\n  private int binarySearch(int[] nums, int key, int l, int r) {\\n    if (l == r) {\\n      return l;\\n    }\\n\\n    int mid = (l + r) / 2;\\n\\n    if (nums[mid] == key) {\\n      return mid;\\n    }\\n\\n    if (nums[mid] > key) {\\n      r = mid - 1;\\n    } else {\\n      l = mid + 1;\\n    }\\n\\n    return l > r ? l : this.binarySearch(nums, key, l, r);\\n  }\\n\\n  public List < Long > minOperations(int[] nums, int[] queries) {\\n    List < Long > result = new ArrayList < > ();\\n\\n    // n * log(n)\\n    Arrays.sort(nums);\\n\\n    long[] sumPrefixCost = new long[nums.length];\\n    long[] sumSuffixCost = new long[nums.length];\\n    int len = nums.length;\\n\\n    // O(n)\\n    for (int i = 0; i < nums.length; i++) {\\n      if (i == 0) {\\n        sumPrefixCost[i] = sumSuffixCost[nums.length - i - 1] = 0;\\n        continue;\\n      }\\n\\n      sumPrefixCost[i] = sumPrefixCost[i - 1] + (long)Math.abs(nums[i] - nums[i - 1]) * i;\\n      sumSuffixCost[nums.length - i - 1] = sumSuffixCost[nums.length - i] +\\n        (long)Math.abs(nums[nums.length - i] - nums[nums.length - i - 1]) * i;\\n    }\\n\\n    // O(m)\\n    for (int i = 0; i < queries.length; i++) {\\n      long cost = 0;\\n      if (queries[i] < nums[0]) {\\n        cost = sumSuffixCost[0] + (long)Math.abs(nums[0] - queries[i]) * len;\\n        result.add(cost);\\n        continue;\\n      }\\n\\n      if (queries[i] > nums[nums.length - 1]) {\\n        cost = sumPrefixCost[nums.length - 1] + (long)Math.abs(nums[nums.length - 1] - queries[i]) * len;\\n        result.add(cost);\\n        continue;\\n      }\\n\\n      // log(n)\\n      int loc = this.binarySearch(nums, queries[i], 0, nums.length - 1);\\n\\n      if (nums[loc] != queries[i]) {\\n        int left = loc - (nums[loc] > queries[i] ? 1 : 0);\\n        int right = loc + (nums[loc] < queries[i] ? 1 : 0);\\n        long tpc = sumPrefixCost[left] + (long)Math.abs(nums[left] - queries[i]) * (left + 1);\\n        long tsc = sumSuffixCost[right] + (long)Math.abs(nums[right] - queries[i]) * (len - right);\\n        cost = tpc + tsc;\\n        result.add(cost);\\n        continue;\\n      }\\n\\n      cost = sumPrefixCost[loc] + sumSuffixCost[loc];\\n      result.add(cost);\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767888,
                "title": "easy-solution-beats-99-17-must-take-glance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//#define long long ll\\n#define ll long long \\nclass Solution {\\npublic:\\n// The concept of prf_array should hit the thought if we see range queries\\n// Edge cases should be kept into mind\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<ll> prf;\\n        vector<ll> ans;\\n        ll sum=0;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;++i){\\n            sum+=nums[i];\\n            prf.push_back(sum);\\n        }\\n         for(int i=0;i<queries.size();++i){\\n            ll it=queries[i];\\n            int idx=upper_bound(nums.begin(),nums.end(),it)-nums.begin();\\n            if(idx==0){\\n                ans.push_back(sum-it*n);\\n            }else if(idx==n){  //# Our bound may go upto n not simpy upto n-1\\n                ans.push_back(it*n-sum);\\n            }else{\\n                ans.push_back(it*idx-prf[idx-1] + sum-prf[idx-1]-it*(n-idx));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n//#define long long ll\\n#define ll long long \\nclass Solution {\\npublic:\\n// The concept of prf_array should hit the thought if we see range queries\\n// Edge cases should be kept into mind\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<ll> prf;\\n        vector<ll> ans;\\n        ll sum=0;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;++i){\\n            sum+=nums[i];\\n            prf.push_back(sum);\\n        }\\n         for(int i=0;i<queries.size();++i){\\n            ll it=queries[i];\\n            int idx=upper_bound(nums.begin(),nums.end(),it)-nums.begin();\\n            if(idx==0){\\n                ans.push_back(sum-it*n);\\n            }else if(idx==n){  //# Our bound may go upto n not simpy upto n-1\\n                ans.push_back(it*n-sum);\\n            }else{\\n                ans.push_back(it*idx-prf[idx-1] + sum-prf[idx-1]-it*(n-idx));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751590,
                "title": "upper-bound-prefix-sum-c-easy-solution-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>&v,vector<int>& q) {\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n        vector<long long>res(q.size(),0);\\n        vector<long long>pre(n,0);\\n        pre[0]=v[0];\\n        for(int i=1;i<n;i++) pre[i]=v[i]+pre[i-1];\\n        for(int i=0;i<q.size();i++){\\n            long long k=upper_bound(v.begin(),v.end(),q[i])-v.begin();\\n            if(k>0) res[i]+=abs(pre[k-1]-(k)*q[i]);\\n            if(k<n and k>0) res[i]+=abs(pre[n-1]-pre[k-1]-(n-k)*q[i]);\\n            if(k==0) res[i]+=abs(pre[n-1]-(n-k)*q[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>&v,vector<int>& q) {\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n        vector<long long>res(q.size(),0);\\n        vector<long long>pre(n,0);\\n        pre[0]=v[0];\\n        for(int i=1;i<n;i++) pre[i]=v[i]+pre[i-1];\\n        for(int i=0;i<q.size();i++){\\n            long long k=upper_bound(v.begin(),v.end(),q[i])-v.begin();\\n            if(k>0) res[i]+=abs(pre[k-1]-(k)*q[i]);\\n            if(k<n and k>0) res[i]+=abs(pre[n-1]-pre[k-1]-(n-k)*q[i]);\\n            if(k==0) res[i]+=abs(pre[n-1]-(n-k)*q[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716415,
                "title": "beats-100-in-time-and-space-prefix-suffix-array-and-binary-search",
                "content": "# Intuition\\nSimple nested loop TC: O(m*n) gives TLE , so we have to use prefix,suffix array , then find the index where our target query is using binary search to reduce TC. \\n\\n# Approach\\nFirst sort the array.\\nThen for all the numbers>target operations = suffixsum- target*(nums greater than index), for numbers less than target, operations = target*(nums less than index) - prefixsum\\n\\n# Complexity\\n- Time complexity:\\nO(n(log(n))) + o(2n) + O(mlogn), n=size of nums, m= size of queries\\n== nlog(n);\\n\\n- Space complexity:\\nO(2n) == O(n);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        vector<long long> pre(n,0),suf(n,0),ans;\\n        sort(nums.begin(),nums.end());\\n        long long presum=0;\\n        long long sufsum=0;\\n        for(int i=0;i<n;i++){\\n            presum+=nums[i];\\n            sufsum+=nums[n-i-1];\\n            pre[i] = presum;\\n            suf[n-i-1] = sufsum;\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            int target=queries[i];\\n            int low=0,high=n-1;\\n            while(low<=high){\\n                int mid = low + (high-low)/2;\\n                if(nums[mid]<target) low = mid+1;\\n                else high = mid-1;\\n            }\\n            long long op=0;\\n            if(low<n)\\n                op+= suf[low]- (1LL*target*(n-low));\\n            if(high>=0){\\n                op+= (1LL*target*(high+1))-pre[high];\\n            }\\n            ans.push_back(op);\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        vector<long long> pre(n,0),suf(n,0),ans;\\n        sort(nums.begin(),nums.end());\\n        long long presum=0;\\n        long long sufsum=0;\\n        for(int i=0;i<n;i++){\\n            presum+=nums[i];\\n            sufsum+=nums[n-i-1];\\n            pre[i] = presum;\\n            suf[n-i-1] = sufsum;\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            int target=queries[i];\\n            int low=0,high=n-1;\\n            while(low<=high){\\n                int mid = low + (high-low)/2;\\n                if(nums[mid]<target) low = mid+1;\\n                else high = mid-1;\\n            }\\n            long long op=0;\\n            if(low<n)\\n                op+= suf[low]- (1LL*target*(n-low));\\n            if(high>=0){\\n                op+= (1LL*target*(high+1))-pre[high];\\n            }\\n            ans.push_back(op);\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702702,
                "title": "binary-search-prefix-sum-c-explanation",
                "content": "# Intuition\\nIt would have been easier to solve if we just had to increase or decrease elements. But since we have to do both we use binary search......\\n\\n# Approach\\nSort the given array and find the point where all elements on left are less than or equal to queries[i] and on right are greater than. See the current sums of these 2 segments using a prefix array and compare with what they could have been if all the elements in these segments were equal. Correspondingly calculate ans[i].\\n\\n# Complexity\\n- Time complexity:\\n$$ O(nlogn) $$\\n\\n- Space complexity:\\n$$ O(n) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        int m = queries.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> pre(n);\\n        pre[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i] = pre[i-1] + nums[i];\\n        }\\n        vector<long long> ans(m,0);\\n        for(int i=0;i<m;i++){\\n            if(n==1){\\n                ans[i] = abs(queries[i]-nums[0]);\\n            }\\n            else{\\n                auto it = upper_bound(nums.begin(),nums.end(),queries[i]);\\n                if(it==nums.begin()){\\n                    long long sz = n;\\n                    long long exp = sz*queries[i];\\n                    long long act = pre[n-1];\\n                    ans[i] = act-exp;\\n                }\\n                else if(it==nums.end()){\\n                    long long sz = n;\\n                    long long exp = sz*queries[i];\\n                    long long act = pre[n-1];\\n                    ans[i] = exp-act;\\n                }\\n                else{\\n                    long long sz1 = distance(it,nums.end());\\n                    long long act = (pre[n-1]-pre[n-1-sz1]);\\n                    long long exp = sz1*queries[i];\\n                    ans[i]+=act-exp;\\n                    act = pre[n-1-sz1];\\n                    sz1 = n-sz1;\\n                    exp = sz1*queries[i];\\n                    ans[i]+=exp-act;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        int m = queries.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> pre(n);\\n        pre[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i] = pre[i-1] + nums[i];\\n        }\\n        vector<long long> ans(m,0);\\n        for(int i=0;i<m;i++){\\n            if(n==1){\\n                ans[i] = abs(queries[i]-nums[0]);\\n            }\\n            else{\\n                auto it = upper_bound(nums.begin(),nums.end(),queries[i]);\\n                if(it==nums.begin()){\\n                    long long sz = n;\\n                    long long exp = sz*queries[i];\\n                    long long act = pre[n-1];\\n                    ans[i] = act-exp;\\n                }\\n                else if(it==nums.end()){\\n                    long long sz = n;\\n                    long long exp = sz*queries[i];\\n                    long long act = pre[n-1];\\n                    ans[i] = exp-act;\\n                }\\n                else{\\n                    long long sz1 = distance(it,nums.end());\\n                    long long act = (pre[n-1]-pre[n-1-sz1]);\\n                    long long exp = sz1*queries[i];\\n                    ans[i]+=act-exp;\\n                    act = pre[n-1-sz1];\\n                    sz1 = n-sz1;\\n                    exp = sz1*queries[i];\\n                    ans[i]+=exp-act;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678861,
                "title": "golang-sorting-prefix-sum-binary-search",
                "content": "# Approach\\nFirst we sort the array so we can use binary search. Then we compute prefix and suffix arrays to get the result for the query with easy lookup. Finally we use binary search to find if the element exists in the query.\\n\\nIf the element exists in the query, it is simple and we just take the sum of prefix and suffix. Otherwise we use a combination of prefix and suffix to find the answer based on the position of the queries[i].\\n\\n# Complexity\\n- Time complexity: O(N Log N)\\n- Space complexity: O(N) for the prefix and suffix arrays\\n\\n# Code\\n```\\nfunc minOperations(nums []int, queries []int) []int64 {\\n  sort.Ints(nums) \\n  n := len(nums)\\n  right := make([]int64, len(nums))\\n  left := make([]int64, len(nums))\\n  for i := len(nums)-2; i >= 0; i-- {\\n    right[i] = right[i+1] + (int64(nums[i+1] - nums[i])  * int64(n-i-1))\\n  }\\n  for i := 1; i < len(nums); i++ {\\n    left[i] = left[i-1] + int64(nums[i] - nums[i-1]) * int64(i)\\n  }\\n  res := make([]int64, len(queries))\\n  for i := 0; i < len(queries); i++ {\\n    lb := lowerBound(nums, queries[i])\\n    if lb < len(nums) && nums[lb] == queries[i] { // element exists\\n      res[i] = left[lb] + right[lb]\\n    } else {\\n      // element doesn\\'t exist. It exists between one or two elements\\n      // here both must be pointing to the same index\\n      if lb == len(nums) {\\n        // greater than all elements\\n        res[i] = left[n-1] + int64(queries[i] - nums[n-1]) * int64(n)\\n      } else if lb == 0 {\\n        // less than all elements\\n        res[i] = right[0] + int64(nums[0] - queries[i]) * int64(n)\\n      } else {\\n        // exists between two elements in the array\\n        // Make all elements before and after the same as the query element.\\n        res[i] = left[lb-1] + int64(queries[i] - nums[lb-1]) * int64(lb) +\\n          right[lb] + int64(nums[lb] - queries[i]) * int64(n - lb)\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nfunc lowerBound(nums []int, target int) int {\\n  left, right := 0, len(nums)-1\\n  for left <= right {\\n    mid := left + (right - left)/2\\n    if nums[mid] >= target {\\n      right = mid - 1\\n    } else {\\n      left = mid + 1\\n    }\\n  }\\n  return left\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nfunc minOperations(nums []int, queries []int) []int64 {\\n  sort.Ints(nums) \\n  n := len(nums)\\n  right := make([]int64, len(nums))\\n  left := make([]int64, len(nums))\\n  for i := len(nums)-2; i >= 0; i-- {\\n    right[i] = right[i+1] + (int64(nums[i+1] - nums[i])  * int64(n-i-1))\\n  }\\n  for i := 1; i < len(nums); i++ {\\n    left[i] = left[i-1] + int64(nums[i] - nums[i-1]) * int64(i)\\n  }\\n  res := make([]int64, len(queries))\\n  for i := 0; i < len(queries); i++ {\\n    lb := lowerBound(nums, queries[i])\\n    if lb < len(nums) && nums[lb] == queries[i] { // element exists\\n      res[i] = left[lb] + right[lb]\\n    } else {\\n      // element doesn\\'t exist. It exists between one or two elements\\n      // here both must be pointing to the same index\\n      if lb == len(nums) {\\n        // greater than all elements\\n        res[i] = left[n-1] + int64(queries[i] - nums[n-1]) * int64(n)\\n      } else if lb == 0 {\\n        // less than all elements\\n        res[i] = right[0] + int64(nums[0] - queries[i]) * int64(n)\\n      } else {\\n        // exists between two elements in the array\\n        // Make all elements before and after the same as the query element.\\n        res[i] = left[lb-1] + int64(queries[i] - nums[lb-1]) * int64(lb) +\\n          right[lb] + int64(nums[lb] - queries[i]) * int64(n - lb)\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nfunc lowerBound(nums []int, target int) int {\\n  left, right := 0, len(nums)-1\\n  for left <= right {\\n    mid := left + (right - left)/2\\n    if nums[mid] >= target {\\n      right = mid - 1\\n    } else {\\n      left = mid + 1\\n    }\\n  }\\n  return left\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3675036,
                "title": "prefix-sum-binary-search-python3-solution-with-mathematical-steps",
                "content": "```\\n\\'\\'\\'\\n- [1, 3, 6, 8] => [5, 5, 5, 5]\\n\\t\\tconvert to 5,\\n\\t\\t(5-1) + (5-3) + (6-5) + (8-5)\\n\\t\\t(5-1+5-3) + (6-5+8-5)\\n\\t\\t5*2 - (1+3) + (-5*2 + (5+8))\\n\\t\\t((query*index) - left_part) + (right_part -query*(legth-index))\\n\\'\\'\\'\\n\\nclass Solution:\\n    \\n    def findIndex(self, target: int, nums: List[int]) -> int:\\n        \\n        lo, hi = 0, len(nums)-1\\n        ans = len(nums)\\n        \\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            if nums[mid] >= target:\\n                ans = mid\\n                hi = mid-1\\n            else:\\n                lo = mid+1\\n                \\n        return ans\\n    \\n    \\n    # O(nlogn) time,\\n    # O(n) space,\\n    # Approach: prefix sum, binary search, math\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        prefix_sum = [0]\\n        tot = 0\\n        for num in nums:\\n            tot += num\\n            prefix_sum.append(tot)\\n            \\n        answer = []\\n        for query in queries:\\n            ops = 0\\n            index = self.findIndex(query, nums)\\n            left_part = prefix_sum[index]\\n            right_part = prefix_sum[len(nums)]-prefix_sum[index]\\n            ops += query*index - left_part\\n            ops += right_part - query*(len(nums)-index)\\n            answer.append(ops)\\n            \\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n\\'\\'\\'\\n- [1, 3, 6, 8] => [5, 5, 5, 5]\\n\\t\\tconvert to 5,\\n\\t\\t(5-1) + (5-3) + (6-5) + (8-5)\\n\\t\\t(5-1+5-3) + (6-5+8-5)\\n\\t\\t5*2 - (1+3) + (-5*2 + (5+8))\\n\\t\\t((query*index) - left_part) + (right_part -query*(legth-index))\\n\\'\\'\\'\\n\\nclass Solution:\\n    \\n    def findIndex(self, target: int, nums: List[int]) -> int:\\n        \\n        lo, hi = 0, len(nums)-1\\n        ans = len(nums)\\n        \\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            if nums[mid] >= target:\\n                ans = mid\\n                hi = mid-1\\n            else:\\n                lo = mid+1\\n                \\n        return ans\\n    \\n    \\n    # O(nlogn) time,\\n    # O(n) space,\\n    # Approach: prefix sum, binary search, math\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        prefix_sum = [0]\\n        tot = 0\\n        for num in nums:\\n            tot += num\\n            prefix_sum.append(tot)\\n            \\n        answer = []\\n        for query in queries:\\n            ops = 0\\n            index = self.findIndex(query, nums)\\n            left_part = prefix_sum[index]\\n            right_part = prefix_sum[len(nums)]-prefix_sum[index]\\n            ops += query*index - left_part\\n            ops += right_part - query*(len(nums)-index)\\n            answer.append(ops)\\n            \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673149,
                "title": "prefix-sum-approach-explained-with-example-why-binary-search-required-simple-codepre",
                "content": "# Intuition\\nSum Property of Array plays a vital role. Think as if want to make n element equal to x , we for sure know that final sum of array HAS to be n*x. And also we know current sum of array. So it pretty obvious that difference between current sum and desired sum is our answer.\\n\\nDepending on query there are three cases as:\\n1. Query less than minimum element of array: In this case ,we have to reduce all array elements\\n2. Query larger than maximum element of array: In this case,we have to increase all array elements\\n3. Query in betweem minimum and maaximum element : In this case , array gets divided into two part, as array is sorted, first half consist all elements less than query which are to be increased .While second half contains elements greater than query meaning they are to be reduced. Binary search is use to find articulate index of array \\n# Approach\\narr[]= [5,7,12,16,27] in sorted format\\n\\nprefix_sum[] = [5,12,24,40,67]\\n\\n\\nquery=30 (more than max of array)\\nif all element are made 30 , and we know 30 is more than max element and we anyway HAVE to increase every element. Desired final sum would be 30*5 and current array sum is 67. \\nSo ans = 5*30 - 67\\ni.e ans=query*n -prefix[n-1]\\n\\n\\n\\nquery= 4 (less than min of array)\\nif all element are made 4 , and we know 4 is less than min element and we anyway HAVE to decrease every element. \\nDesired final sum would be 4*5 and current array sum is 67. \\nSo ans= 67-5*4 =47\\ni.e ans=prefix[n-1] - query*n\\n\\nquery= 15(element lying in middle of min and max of array)\\nthen first three element has to be increased \\nans1 = 3*15 -(sum of three elements) =21\\nand last two elements has to be decreased \\n\\nans2 = (sum of two elements ) -2*15 = 13\\nans=34\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n\\n        vector<long long > ans,prefix(n);\\n        sort(nums.begin(),nums.end());\\n        prefix[0]=nums[0];\\n\\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1]+nums[i];\\n\\n        for(auto query:queries){\\n\\n            int idx= upper_bound(nums.begin(),nums.end(),query) - nums.begin();\\n            //idx tells how many elements are less than query and how many element are greater query \\n\\n            if(idx==0){\\n                //query is lesser than all elements in num and we have to reduce all elements\\n                ans.push_back(prefix[n-1]-n*1LL*query);\\n            }\\n            else if(idx==n){\\n                //query is larger than all elements in num and we have to increase all elements\\n                ans.push_back(n*1LL*query- prefix[n-1]);\\n            }\\n            else{\\n                    long long ans1=query*1LL*idx - prefix[idx-1];\\n                    long long ans2=(prefix[n-1]-prefix[idx-1]) -query*1LL*(n-idx); \\n                    ans.push_back(ans1+ans2);\\n            }\\n\\n\\n        }\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n\\n        vector<long long > ans,prefix(n);\\n        sort(nums.begin(),nums.end());\\n        prefix[0]=nums[0];\\n\\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1]+nums[i];\\n\\n        for(auto query:queries){\\n\\n            int idx= upper_bound(nums.begin(),nums.end(),query) - nums.begin();\\n            //idx tells how many elements are less than query and how many element are greater query \\n\\n            if(idx==0){\\n                //query is lesser than all elements in num and we have to reduce all elements\\n                ans.push_back(prefix[n-1]-n*1LL*query);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3667031,
                "title": "c-prefix-sum-binary-search-lowerbound",
                "content": "**Time Complexity: O(N * logN)\\nSpace Complexity: O(N)**\\nTestcase to understand why we have to check for -1\\n[3,2,6,8]\\n[1,5]\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        // 1,3,6,8\\n        // pos = 1, index = 0;\\n        // pos = 5, index = 2;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> prefix(n,0);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        vector<long long> ans;\\n        for(auto i:queries){\\n            int index=upper_bound(nums.begin(),nums.end(),i)-nums.begin()-1;\\n            int leftcount=index+1,rightcount=n-index-1;\\n            long long val=0;\\n            cout<<index<<endl;\\n            if(index==-1) {\\n                val=prefix[n-1]-i*1ll*n;\\n            }\\n            else{\\n                val=i*1ll*leftcount-prefix[index];\\n                val+=(prefix[n-1]-prefix[index])-i*1ll*rightcount;\\n            }\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        // 1,3,6,8\\n        // pos = 1, index = 0;\\n        // pos = 5, index = 2;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> prefix(n,0);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        vector<long long> ans;\\n        for(auto i:queries){\\n            int index=upper_bound(nums.begin(),nums.end(),i)-nums.begin()-1;\\n            int leftcount=index+1,rightcount=n-index-1;\\n            long long val=0;\\n            cout<<index<<endl;\\n            if(index==-1) {\\n                val=prefix[n-1]-i*1ll*n;\\n            }\\n            else{\\n                val=i*1ll*leftcount-prefix[index];\\n                val+=(prefix[n-1]-prefix[index])-i*1ll*rightcount;\\n            }\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3666110,
                "title": "c-brute-force-optimal-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        //OPTIMAL APPROACH: We sort the array and then partion aray such that\\n        // all element less than query[i] onside and all greater other side\\n        //then operation needed= Query[i]*(No. of element less than Q[i]) -\\n        //(sum o element less then Q[i])+Q[i]*(No. of element more than Q[i])\\n        //-(sum o element less then Q[i]).\\n        //We use binary search to find count of element less than and greater\\n        //than Q[i], and use prefix sum array to find the sum of all less\\n        //and greater element than Q[i]\\n        //So total Time complexity=O(nlogn)\\n\\n        int n=nums.size();\\n        //taking an ans array that store required ans\\n        vector<long long> ans;\\n        //sort the nums so that we apply binary search\\n        sort(nums.begin(),nums.end());\\n        //taking the prefix sum which give sum of range of value\\n        vector<long long> prefix(n+1,0);\\n        for(int i=0;i<n;i++){\\n            prefix[i+1]=prefix[i]+nums[i];\\n        }\\n        // for(int i=0;i<prefix.size();i++){\\n        //     cout<<prefix[i]<<\" \";\\n        // }\\n        // val=prefix[n]-prefix[2];\\n        // cout<<\"VAL:\"<<val;\\n        nums.insert(nums.begin(), 0);\\n        n++;\\n        //for each query we partion array in two half and apply above formula\\n        for(int i=0;i<queries.size();i++){\\n            long long target=queries[i];\\n            long long ind1=lower_bound(nums.begin(),nums.end(),target)-\\n            nums.begin()-1;\\n            long long  ind2=upper_bound(nums.begin(),nums.end(),target)-\\n            nums.begin();\\n\\n            long long operation=target*ind1-(prefix[ind1]-prefix[0]);\\n            if(ind2!=n){\\n                operation+=(prefix[n-1]-prefix[ind2-1])-target*(n-ind2);\\n            }\\n            ans.push_back(operation);\\n\\n        }\\n        return ans;\\n\\n        //BRUTE FORCE: For a query we go to each element of nums and find\\n        //min no. of operation if the query size is n and nums size n \\n        //tyen it take O(n2) which give TLE so we need to optimize\\n        // vector<long long> ans;\\n        // for(int i=0;i<queries.size();i++){\\n        //     long long target =queries[i];\\n        //     long long val=0;\\n        //     for(int j=0;j<nums.size();j++){\\n        //         val+=abs(1ll*nums[j]-target);\\n        //     }\\n        //     ans.push_back(val);\\n        // }\\n        // return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        //OPTIMAL APPROACH: We sort the array and then partion aray such that\\n        // all element less than query[i] onside and all greater other side\\n        //then operation needed= Query[i]*(No. of element less than Q[i]) -\\n        //(sum o element less then Q[i])+Q[i]*(No. of element more than Q[i])\\n        //-(sum o element less then Q[i]).\\n        //We use binary search to find count of element less than and greater\\n        //than Q[i], and use prefix sum array to find the sum of all less\\n        //and greater element than Q[i]\\n        //So total Time complexity=O(nlogn)\\n\\n        int n=nums.size();\\n        //taking an ans array that store required ans\\n        vector<long long> ans;\\n        //sort the nums so that we apply binary search\\n        sort(nums.begin(),nums.end());\\n        //taking the prefix sum which give sum of range of value\\n        vector<long long> prefix(n+1,0);\\n        for(int i=0;i<n;i++){\\n            prefix[i+1]=prefix[i]+nums[i];\\n        }\\n        // for(int i=0;i<prefix.size();i++){\\n        //     cout<<prefix[i]<<\" \";\\n        // }\\n        // val=prefix[n]-prefix[2];\\n        // cout<<\"VAL:\"<<val;\\n        nums.insert(nums.begin(), 0);\\n        n++;\\n        //for each query we partion array in two half and apply above formula\\n        for(int i=0;i<queries.size();i++){\\n            long long target=queries[i];\\n            long long ind1=lower_bound(nums.begin(),nums.end(),target)-\\n            nums.begin()-1;\\n            long long  ind2=upper_bound(nums.begin(),nums.end(),target)-\\n            nums.begin();\\n\\n            long long operation=target*ind1-(prefix[ind1]-prefix[0]);\\n            if(ind2!=n){\\n                operation+=(prefix[n-1]-prefix[ind2-1])-target*(n-ind2);\\n            }\\n            ans.push_back(operation);\\n\\n        }\\n        return ans;\\n\\n        //BRUTE FORCE: For a query we go to each element of nums and find\\n        //min no. of operation if the query size is n and nums size n \\n        //tyen it take O(n2) which give TLE so we need to optimize\\n        // vector<long long> ans;\\n        // for(int i=0;i<queries.size();i++){\\n        //     long long target =queries[i];\\n        //     long long val=0;\\n        //     for(int j=0;j<nums.size();j++){\\n        //         val+=abs(1ll*nums[j]-target);\\n        //     }\\n        //     ans.push_back(val);\\n        // }\\n        // return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3665254,
                "title": "easy-bs-and-sorting-c-solutions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>v(n+1);\\n        vector<long long>w(n+1);\\n        vector<long long>res;\\n        long long ref=0,reff=0;\\n        for(int i=0;i<n;i++){\\n            ref+=(nums[n-1-i]-nums[0]);\\n            reff+=(nums[n-1]-nums[i]);\\n            v[n-1-i]=ref;\\n            w[i+1]=reff;\\n        }\\n        for(auto i:queries){\\n            long long j=lower_bound(nums.begin(),nums.end(),i)-nums.begin();\\n            long long ans=v[j]+w[j]-((i-nums[0])*(n-j))-((nums[n-1]-i)*(j));\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>v(n+1);\\n        vector<long long>w(n+1);\\n        vector<long long>res;\\n        long long ref=0,reff=0;\\n        for(int i=0;i<n;i++){\\n            ref+=(nums[n-1-i]-nums[0]);\\n            reff+=(nums[n-1]-nums[i]);\\n            v[n-1-i]=ref;\\n            w[i+1]=reff;\\n        }\\n        for(auto i:queries){\\n            long long j=lower_bound(nums.begin(),nums.end(),i)-nums.begin();\\n            long long ans=v[j]+w[j]-((i-nums[0])*(n-j))-((nums[n-1]-i)*(j));\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665250,
                "title": "easy-binary-search-sorting-prefix-suffix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can easily find solution in O(nq) by brute-force but we required some preprocessing to prevent from O(n) traversal of array for every query. We can store some prefix-suffix sum to easily calculate total operation needed for every query.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the array and then store a prefix sum by assuming, we are making all the element equal to minimum element and similarily suffix sum by assuming, we are making all element equal to maximum element.\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>v(n+1);\\n        vector<long long>w(n+1);\\n        vector<long long>res;\\n        long long ref=0,reff=0;\\n        for(int i=0;i<n;i++){\\n            ref+=(nums[n-1-i]-nums[0]);\\n            reff+=(nums[n-1]-nums[i]);\\n            v[n-1-i]=ref;\\n            w[i+1]=reff;\\n        }\\n        for(auto i:queries){\\n            long long j=lower_bound(nums.begin(),nums.end(),i)-nums.begin();\\n            long long ans=v[j]+w[j]-((i-nums[0])*(n-j))-((nums[n-1]-i)*(j));\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>v(n+1);\\n        vector<long long>w(n+1);\\n        vector<long long>res;\\n        long long ref=0,reff=0;\\n        for(int i=0;i<n;i++){\\n            ref+=(nums[n-1-i]-nums[0]);\\n            reff+=(nums[n-1]-nums[i]);\\n            v[n-1-i]=ref;\\n            w[i+1]=reff;\\n        }\\n        for(auto i:queries){\\n            long long j=lower_bound(nums.begin(),nums.end(),i)-nums.begin();\\n            long long ans=v[j]+w[j]-((i-nums[0])*(n-j))-((nums[n-1]-i)*(j));\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664480,
                "title": "c-solution-binary-search-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int lowerBound(vector<int> &nums, int target){\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while(left < right){\\n             int mid = left + (right - left) / 2;\\n            \\n            if(nums[mid] < target)\\n                    left = mid +1;\\n                \\n            else\\n                right = mid;\\n        }\\n        \\n        if(nums[left] != target && nums[left]< target)\\n            left = right +1;\\n        \\n        return left;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<long long> prefix(nums.size() + 1), suffix(nums.size() + 1);\\n        for (int i = 1; i <= nums.size(); i++)\\n            prefix[i] = prefix[i - 1] + nums[i - 1];\\n        for (int i = nums.size() - 1; i >= 0; i--)\\n            suffix[i] = suffix[i + 1] + nums[i];\\n        \\n\\n        vector<long long> ans;\\n        for (auto query : queries) {\\n            long long index = lowerBound(nums, query);\\n            long long val = (index * query) - prefix[index] + suffix[index] - ((nums.size() - index) * query);\\n                \\n            ans.push_back(val);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lowerBound(vector<int> &nums, int target){\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while(left < right){\\n             int mid = left + (right - left) / 2;\\n            \\n            if(nums[mid] < target)\\n                    left = mid +1;\\n                \\n            else\\n                right = mid;\\n        }\\n        \\n        if(nums[left] != target && nums[left]< target)\\n            left = right +1;\\n        \\n        return left;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<long long> prefix(nums.size() + 1), suffix(nums.size() + 1);\\n        for (int i = 1; i <= nums.size(); i++)\\n            prefix[i] = prefix[i - 1] + nums[i - 1];\\n        for (int i = nums.size() - 1; i >= 0; i--)\\n            suffix[i] = suffix[i + 1] + nums[i];\\n        \\n\\n        vector<long long> ans;\\n        for (auto query : queries) {\\n            long long index = lowerBound(nums, query);\\n            long long val = (index * query) - prefix[index] + suffix[index] - ((nums.size() - index) * query);\\n                \\n            ans.push_back(val);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664382,
                "title": "presum-floor-and-ceil-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long ceil_(vector<int>& nums, int& val){\\n         int l = 0, r = nums.size()-1;\\n         int ans = nums.size();\\n         while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] <= val)\\n            l = mid +1;\\n            else{\\n                ans = mid;\\n                r = mid-1;\\n            }\\n         }\\n         return ans;\\n    }\\n\\n    long long floor_(vector<int>& nums, int& val){\\n         int l = 0, r = nums.size()-1;\\n         int ans = -1;\\n         while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] < val){\\n            ans = mid;\\n            l = mid +1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n         }\\n         return ans;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        vector<long long> presum(n+1, 0);\\n        sort(nums.begin(), nums.end());\\n        presum[0]=0;\\n        for(int i=0; i<n; i++){\\n            presum[i+1] = nums[i] + presum[i];\\n        }\\n        vector<long long> ans;\\n        for(auto x : queries){\\n            long long  f = floor_(nums, x);\\n            long long c = ceil_(nums, x);\\n            long long res = abs(x*(n-c) - (presum[n] - presum[c])) +\\n                            abs(x*(f+1) - (presum[f+1])) ;\\n           ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ceil_(vector<int>& nums, int& val){\\n         int l = 0, r = nums.size()-1;\\n         int ans = nums.size();\\n         while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] <= val)\\n            l = mid +1;\\n            else{\\n                ans = mid;\\n                r = mid-1;\\n            }\\n         }\\n         return ans;\\n    }\\n\\n    long long floor_(vector<int>& nums, int& val){\\n         int l = 0, r = nums.size()-1;\\n         int ans = -1;\\n         while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] < val){\\n            ans = mid;\\n            l = mid +1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n         }\\n         return ans;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        vector<long long> presum(n+1, 0);\\n        sort(nums.begin(), nums.end());\\n        presum[0]=0;\\n        for(int i=0; i<n; i++){\\n            presum[i+1] = nums[i] + presum[i];\\n        }\\n        vector<long long> ans;\\n        for(auto x : queries){\\n            long long  f = floor_(nums, x);\\n            long long c = ceil_(nums, x);\\n            long long res = abs(x*(n-c) - (presum[n] - presum[c])) +\\n                            abs(x*(f+1) - (presum[f+1])) ;\\n           ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664194,
                "title": "c-sorting-prefix-sum-upper-bound-beats-90",
                "content": "```\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<ll> minOperations(vector<int>& nums, vector<int>& queries)\\n    {\\n        int n=nums.size() ;\\n        sort(nums.begin(),nums.end());\\n       \\n        vector<ll>pref_sum(n);\\n        pref_sum[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++)\\n            pref_sum[i]=pref_sum[i-1] + nums[i];\\n        \\n        vector<ll>ans;\\n        for(int &x : queries )\\n        {\\n            ll ub = upper_bound(nums.begin(),nums.end(),x) - nums.begin();\\n            \\n            ll curr= pref_sum[n-1] + ub*x - (n-ub)*x;\\n            if(ub>0) curr -=2*pref_sum[ub-1];\\n            \\n            ans.push_back(curr);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<ll> minOperations(vector<int>& nums, vector<int>& queries)\\n    {\\n        int n=nums.size() ;\\n        sort(nums.begin(),nums.end());\\n       \\n        vector<ll>pref_sum(n);\\n        pref_sum[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++)\\n            pref_sum[i]=pref_sum[i-1] + nums[i];\\n        \\n        vector<ll>ans;\\n        for(int &x : queries )\\n        {\\n            ll ub = upper_bound(nums.begin(),nums.end(),x) - nums.begin();\\n            \\n            ll curr= pref_sum[n-1] + ub*x - (n-ub)*x;\\n            if(ub>0) curr -=2*pref_sum[ub-1];\\n            \\n            ans.push_back(curr);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663859,
                "title": "binary-seacrh-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> prefix(n,0);\\n        long long totalSum=0;\\n        \\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        totalSum=prefix[n-1];\\n        vector<long long> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int ind= upper_bound(nums.begin(),nums.end(),queries[i])-nums.begin();;\\n            if(ind==0||ind==n)\\n            {\\n                long long x=abs(totalSum-n*1LL*queries[i]);\\n                ans.push_back(x);\\n            }\\n            else\\n            {\\n                long long p=ind*1LL*queries[i]-prefix[ind-1];\\n                long long s=(totalSum-prefix[ind-1])-(n-ind)*1LL*queries[i];\\n                ans.push_back(p+s);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> prefix(n,0);\\n        long long totalSum=0;\\n        \\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        totalSum=prefix[n-1];\\n        vector<long long> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int ind= upper_bound(nums.begin(),nums.end(),queries[i])-nums.begin();;\\n            if(ind==0||ind==n)\\n            {\\n                long long x=abs(totalSum-n*1LL*queries[i]);\\n                ans.push_back(x);\\n            }\\n            else\\n            {\\n                long long p=ind*1LL*queries[i]-prefix[ind-1];\\n                long long s=(totalSum-prefix[ind-1])-(n-ind)*1LL*queries[i];\\n                ans.push_back(p+s);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663840,
                "title": "sorting-prefix-sum-binary-search",
                "content": "class Solution(object):\\n    def minOperations(self, nums, queries):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        nums.sort()\\n        n = len(nums)\\n        cumulative_arr = [nums[i] for i in range(n)]\\n        \\n        for i in range(1,n):\\n            cumulative_arr[i] += cumulative_arr[i-1]\\n        \\n        #print cumulative_arr\\n        \\n        \\n        res = []\\n        \\n        for q in queries:\\n            l = 0\\n            r = n-1\\n            \\n            while l <= r:\\n                m = (l+r)//2\\n                \\n                if nums[m] <= q:\\n                    l = m+1\\n                else:\\n                    r = m-1\\n            \\n            if l == n:\\n                cur = q*n - cumulative_arr[-1]\\n            elif l == 0:\\n                cur = cumulative_arr[-1] - q*n\\n            else:\\n                cur = q*l - cumulative_arr[l-1]\\n                cur += (cumulative_arr[-1] - cumulative_arr[l-1] - (n-l)*q)\\n            \\n            res.append(cur)\\n        #print res\\n        return res\\n            \\n            \\n                \\n        \\n        \\n",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "class Solution(object):\\n    def minOperations(self, nums, queries):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        nums.sort()\\n        n = len(nums)\\n        cumulative_arr = [nums[i] for i in range(n)]\\n        \\n        for i in range(1,n):\\n            cumulative_arr[i] += cumulative_arr[i-1]\\n        \\n        #print cumulative_arr\\n        \\n        \\n        res = []\\n        \\n        for q in queries:\\n            l = 0\\n            r = n-1\\n            \\n            while l <= r:\\n                m = (l+r)//2\\n                \\n                if nums[m] <= q:\\n                    l = m+1\\n                else:\\n                    r = m-1\\n            \\n            if l == n:\\n                cur = q*n - cumulative_arr[-1]\\n            elif l == 0:\\n                cur = cumulative_arr[-1] - q*n\\n            else:\\n                cur = q*l - cumulative_arr[l-1]\\n                cur += (cumulative_arr[-1] - cumulative_arr[l-1] - (n-l)*q)\\n            \\n            res.append(cur)\\n        #print res\\n        return res\\n            \\n            \\n                \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3663532,
                "title": "offline-query-processing",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        n = len(nums)\\n        q = len(queries)\\n        nums.sort()\\n        for i in range(q):\\n            queries[i] = [queries[i], i]\\n        queries.sort()\\n        res = [0] * q\\n        i = 0\\n        s = 0\\n        rsum = sum(nums)\\n        for q, pos in queries:\\n            while i < n and nums[i] <= q:\\n                s += nums[i]\\n                rsum -= nums[i]\\n                i += 1\\n            res[pos] = i * q - s + rsum - q * (n - i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        n = len(nums)\\n        q = len(queries)\\n        nums.sort()\\n        for i in range(q):\\n            queries[i] = [queries[i], i]\\n        queries.sort()\\n        res = [0] * q\\n        i = 0\\n        s = 0\\n        rsum = sum(nums)\\n        for q, pos in queries:\\n            while i < n and nums[i] <= q:\\n                s += nums[i]\\n                rsum -= nums[i]\\n                i += 1\\n            res[pos] = i * q - s + rsum - q * (n - i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606354,
                "title": "c-faster-than-100-binary-search-prefix-sum",
                "content": "# Intuition\\nAt first sort array `nums`, then go through array queries and calculate the result.\\n\\n# Approach\\nAt first sort the array `nums`:\\n```\\nArray.Sort(nums);\\n```\\nThan create an array with sums of items in `nums` from 0 to each index:\\n```\\nvar sums = CalculateSums(nums);\\n```\\nFinally calculate the result:\\n```\\nfor (int i = 0; i < queries.Length; i++)\\n{\\n    rs.Add(MinOperations(queries[i], sums, nums));\\n}\\n```\\nFor each index i in result calculate the value:\\n```\\nprivate long MinOperations(int query, long[] sums, int[] nums)\\n{\\n    var rs = 0L;\\n    var index = GetIndex(query, nums);\\n    if (0 < index) rs += index * (long)query - sums[index - 1];\\n    rs += (sums[sums.Length - 1] - ((index - 1 >= 0) ? sums[index - 1] : 0)) - (sums.Length - index) * (long)query;\\n    return rs;\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$, where n is len(nums).\\n\\n- Space complexity:\\n$$O(n)$$, where n is len(nums).\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<long> MinOperations(int[] nums, int[] queries) {\\n        Array.Sort(nums);\\n        var sums = CalculateSums(nums);\\n        var rs = new List<long>();\\n        for (int i = 0; i < queries.Length; i++)\\n        {\\n            rs.Add(MinOperations(queries[i], sums, nums));\\n        }\\n        return rs;\\n    }\\n    private long MinOperations(int query, long[] sums, int[] nums)\\n    {\\n        var rs = 0L;\\n        var index = GetIndex(query, nums);\\n        if (0 < index) rs += index * (long)query - sums[index - 1];\\n        rs += (sums[sums.Length - 1] - ((index - 1 >= 0) ? sums[index - 1] : 0)) - (sums.Length - index) * (long)query;\\n        return rs;\\n    }\\n    private int GetIndex(int query, int[] nums)\\n    {\\n        var index0 = 0;\\n        if (query <= nums[index0]) return index0;\\n        var index1 = nums.Length - 1;\\n        if (nums[index1] < query) return index1 + 1;\\n        while (index1 - index0 > 1)\\n        {\\n            var indexMid = (index0 + index1) / 2;\\n            if (nums[indexMid] < query)\\n            {\\n                index0 = indexMid;\\n            }\\n            else\\n            {\\n                index1 = indexMid;\\n            }\\n        }\\n        return index1;\\n    }\\n    private long[] CalculateSums(int[] nums)\\n    {\\n        var rs = new long[nums.Length];\\n        rs[0] = nums[0];\\n        long sum = rs[0];\\n        for (int i = 1; i < rs.Length; i++)\\n        {\\n            rs[i] = rs[i - 1] + (long)nums[i];\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nArray.Sort(nums);\\n```\n```\\nvar sums = CalculateSums(nums);\\n```\n```\\nfor (int i = 0; i < queries.Length; i++)\\n{\\n    rs.Add(MinOperations(queries[i], sums, nums));\\n}\\n```\n```\\nprivate long MinOperations(int query, long[] sums, int[] nums)\\n{\\n    var rs = 0L;\\n    var index = GetIndex(query, nums);\\n    if (0 < index) rs += index * (long)query - sums[index - 1];\\n    rs += (sums[sums.Length - 1] - ((index - 1 >= 0) ? sums[index - 1] : 0)) - (sums.Length - index) * (long)query;\\n    return rs;\\n}\\n```\n```\\npublic class Solution {\\n    public IList<long> MinOperations(int[] nums, int[] queries) {\\n        Array.Sort(nums);\\n        var sums = CalculateSums(nums);\\n        var rs = new List<long>();\\n        for (int i = 0; i < queries.Length; i++)\\n        {\\n            rs.Add(MinOperations(queries[i], sums, nums));\\n        }\\n        return rs;\\n    }\\n    private long MinOperations(int query, long[] sums, int[] nums)\\n    {\\n        var rs = 0L;\\n        var index = GetIndex(query, nums);\\n        if (0 < index) rs += index * (long)query - sums[index - 1];\\n        rs += (sums[sums.Length - 1] - ((index - 1 >= 0) ? sums[index - 1] : 0)) - (sums.Length - index) * (long)query;\\n        return rs;\\n    }\\n    private int GetIndex(int query, int[] nums)\\n    {\\n        var index0 = 0;\\n        if (query <= nums[index0]) return index0;\\n        var index1 = nums.Length - 1;\\n        if (nums[index1] < query) return index1 + 1;\\n        while (index1 - index0 > 1)\\n        {\\n            var indexMid = (index0 + index1) / 2;\\n            if (nums[indexMid] < query)\\n            {\\n                index0 = indexMid;\\n            }\\n            else\\n            {\\n                index1 = indexMid;\\n            }\\n        }\\n        return index1;\\n    }\\n    private long[] CalculateSums(int[] nums)\\n    {\\n        var rs = new long[nums.Length];\\n        rs[0] = nums[0];\\n        long sum = rs[0];\\n        for (int i = 1; i < rs.Length; i++)\\n        {\\n            rs[i] = rs[i - 1] + (long)nums[i];\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572650,
                "title": "easy-to-understand-prefix-sum-using-upper-bound-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long> v;\\n        int n = nums.size();\\n        int m = queries.size();\\n        sort(nums.begin(), nums.end());\\n        vector<long long> ps;\\n        ps.push_back(nums[0]);\\n        for(int i=1; i<n; i++){\\n            ps.push_back(ps[i-1]+nums[i]);\\n        }\\n        for(int i=0; i<m; i++){\\n            int q = queries[i];\\n            auto it = upper_bound(nums.begin(), nums.end(), q);\\n            int val = (it == nums.end()) ? n : distance(nums.begin(), it);\\n            if(val==0){\\n                v.push_back(ps[n-1] - (long long)n*q);\\n            }\\n            else if(val == n){\\n                v.push_back((long long)n*q - ps[n-1]);\\n            }\\n            else{\\n                v.push_back((val)*(long long)q-ps[val-1] + (ps[n-1]-ps[val-1])-(long long)q*(n-val));\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long> v;\\n        int n = nums.size();\\n        int m = queries.size();\\n        sort(nums.begin(), nums.end());\\n        vector<long long> ps;\\n        ps.push_back(nums[0]);\\n        for(int i=1; i<n; i++){\\n            ps.push_back(ps[i-1]+nums[i]);\\n        }\\n        for(int i=0; i<m; i++){\\n            int q = queries[i];\\n            auto it = upper_bound(nums.begin(), nums.end(), q);\\n            int val = (it == nums.end()) ? n : distance(nums.begin(), it);\\n            if(val==0){\\n                v.push_back(ps[n-1] - (long long)n*q);\\n            }\\n            else if(val == n){\\n                v.push_back((long long)n*q - ps[n-1]);\\n            }\\n            else{\\n                v.push_back((val)*(long long)q-ps[val-1] + (ps[n-1]-ps[val-1])-(long long)q*(n-val));\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551532,
                "title": "prefixsum-binarysearch-solution-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        arr=nums[:]\\n        ans=[]\\n        n=len(nums)\\n        for i in range(n):\\n            if(i==0):continue\\n            else:\\n                nums[i]+=nums[i-1]\\n        for q in queries:\\n            if(arr[n-1]<=q):\\n                ans.append(q*n-nums[n-1])\\n            elif(arr[0]>=q):\\n                ans.append(nums[n-1]-q*n)\\n            else:\\n                l=0\\n                r=len(nums)-1\\n                while(l<r):\\n                    mid=(l+r)//2\\n                    if(arr[mid]>=q):r=mid\\n                    elif(arr[mid]<q):l=mid+1\\n                ans.append(q*r-nums[r-1]+nums[n-1]-q*(n-r)-nums[r-1])\\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        arr=nums[:]\\n        ans=[]\\n        n=len(nums)\\n        for i in range(n):\\n            if(i==0):continue\\n            else:\\n                nums[i]+=nums[i-1]\\n        for q in queries:\\n            if(arr[n-1]<=q):\\n                ans.append(q*n-nums[n-1])\\n            elif(arr[0]>=q):\\n                ans.append(nums[n-1]-q*n)\\n            else:\\n                l=0\\n                r=len(nums)-1\\n                while(l<r):\\n                    mid=(l+r)//2\\n                    if(arr[mid]>=q):r=mid\\n                    elif(arr[mid]<q):l=mid+1\\n                ans.append(q*r-nums[r-1]+nums[n-1]-q*(n-r)-nums[r-1])\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527475,
                "title": "python-bisect-and-prefix-sum-solution",
                "content": "# Intuition\\n\\nWe can start with naive implementation like that:\\n\\n        ans = [None] * len(queries)\\n        for i, query in enumerate(queries):\\n          query_res = 0\\n          for num in nums:\\n          query_res += abs(query - num)\\n          ans[i] = query_res\\n\\n\\nans[0] = abs(3-1)+abs(1-1)+abs(6-1)+(8-1)=2+0+5+7=14\\nans[1] = abs(3-5)+abs(1-5)+abs(6-5)+(8-5)=2+4+1+3=10\\n\\n\\n\\n# Approach\\nNaive approach might be improved by using prefix sum.\\n\\n# Complexity\\n- Time complexity:\\n $$O(NlogN)$$ + $$O(n)$$ + $$O(k)$$ * $$O(logN)$$ = \\n  $$O(klogN)$$ if k > n or\\n  $$O(nlogN)$$ if n > n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        ans = [None] * len(queries)\\n        \\'\\'\\'\\n        Sorted_values: [1,3,6 ,8 ]\\n        Prefix_sum:    [1,4,10,18]\\n\\n        q:1 \\n            - Find value 1 at position `k`:\\n                - res = (q-nums[k]) + \\\\\\n                        k*q - prefix_sum[:(k-1)] + \\\\\\n                        (prefix_sum[-1]-prefix_sum[:k-1]-(n-k-1)*q)\\n                k=0\\n                  res = (1-1) (4-0-1)*1-18-1=18-1-3\\n        q:5\\n            k = 1 \\n                        k       left_from_k     right_from_k\\n                  res = (5-3)  + 1*5-1        + 18-4-(4-1-1)*5      = 2+4+4 = 10\\n\\n\\n        \\'\\'\\'\\n\\n        n = len(nums)\\n        arr = sorted(nums)\\n        \\n\\n        prefix_sum = [None] * n\\n        prefix_sum[0] = arr[0]\\n        for i in range(1,n):\\n            prefix_sum[i] = prefix_sum[i-1]+arr[i]\\n\\n        # print(f\"arr: {arr} prefix_sum: {prefix_sum}\")\\n\\n\\n        ans = [0] * len(queries)\\n        for i, q in enumerate(queries):\\n            k = bisect_left(arr, q)\\n            if k > (n-1):\\n                k = n-1\\n            # print(f\"k: {k}\")\\n            # print(f\"arr[k]: {arr[k]}\")\\n            ans[i] = (abs(q-arr[k])) + \\\\\\n                    (k*q - prefix_sum[k-1] if k > 0 else 0) + \\\\\\n                    (prefix_sum[-1]-prefix_sum[k]-(n-k-1)*q)\\n\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        ans = [None] * len(queries)\\n        \\'\\'\\'\\n        Sorted_values: [1,3,6 ,8 ]\\n        Prefix_sum:    [1,4,10,18]\\n\\n        q:1 \\n            - Find value 1 at position `k`:\\n                - res = (q-nums[k]) + \\\\\\n                        k*q - prefix_sum[:(k-1)] + \\\\\\n                        (prefix_sum[-1]-prefix_sum[:k-1]-(n-k-1)*q)\\n                k=0\\n                  res = (1-1) (4-0-1)*1-18-1=18-1-3\\n        q:5\\n            k = 1 \\n                        k       left_from_k     right_from_k\\n                  res = (5-3)  + 1*5-1        + 18-4-(4-1-1)*5      = 2+4+4 = 10\\n\\n\\n        \\'\\'\\'\\n\\n        n = len(nums)\\n        arr = sorted(nums)\\n        \\n\\n        prefix_sum = [None] * n\\n        prefix_sum[0] = arr[0]\\n        for i in range(1,n):\\n            prefix_sum[i] = prefix_sum[i-1]+arr[i]\\n\\n        # print(f\"arr: {arr} prefix_sum: {prefix_sum}\")\\n\\n\\n        ans = [0] * len(queries)\\n        for i, q in enumerate(queries):\\n            k = bisect_left(arr, q)\\n            if k > (n-1):\\n                k = n-1\\n            # print(f\"k: {k}\")\\n            # print(f\"arr[k]: {arr[k]}\")\\n            ans[i] = (abs(q-arr[k])) + \\\\\\n                    (k*q - prefix_sum[k-1] if k > 0 else 0) + \\\\\\n                    (prefix_sum[-1]-prefix_sum[k]-(n-k-1)*q)\\n\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513133,
                "title": "c-prefix-sum-binary-search-upperbound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntill upper bound it will be the query-element and after it will element-query \\nso we use prefix sum to reduce time complexity\\nplease feel free to ask any doubts\\n\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long>pre(nums.size());\\n        pre[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        vector<long long >res;\\n        for(auto i:queries){\\n            long long ub=upper_bound(nums.begin(),nums.end(),i)-nums.begin();\\n           long long ans;\\n           if(ub!=0)ans=ub*i-pre[ub-1]+pre[nums.size()-1]-pre[ub-1]-(nums.size()-ub)*i;\\n           else\\n           {\\n               ans=pre[nums.size()-1]-(nums.size()-ub)*i;\\n           }\\n\\n            res.push_back(ans);\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long>pre(nums.size());\\n        pre[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        vector<long long >res;\\n        for(auto i:queries){\\n            long long ub=upper_bound(nums.begin(),nums.end(),i)-nums.begin();\\n           long long ans;\\n           if(ub!=0)ans=ub*i-pre[ub-1]+pre[nums.size()-1]-pre[ub-1]-(nums.size()-ub)*i;\\n           else\\n           {\\n               ans=pre[nums.size()-1]-(nums.size()-ub)*i;\\n           }\\n\\n            res.push_back(ans);\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509691,
                "title": "prefix-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- we need to tell for each query how many operation do we need to make everyone equal \\n- now here we are not worried about order here we just need to know how many element are greater than query[i] and how many smaller \\n- and we need to there sum so that we could calculate number of operation.\\n- we can know how may bigger than certain number by using BinarySearch if array is sorted.\\n- sort the array \\n- now calculate prefix sum to get cumilated sum in O(1).\\n- now use upper_bound to get first element which is greater than query[i] and then calulate left ans and right answer\\n-` left anser=number of element in left * query[i]-total sum;`\\n- right asnwer =similar to left .\\n- calculate for left and right and push into answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<ll>prefix(nums.size()+1,0);\\n        for(ll i=0;i<nums.size();i++)\\n        {\\n            prefix[i+1]=prefix[i]+nums[i];\\n        }\\n        vector<ll>v;\\n        for(auto &it:queries)\\n        {\\n            ll ans=f(it,nums,prefix);\\n            v.push_back(ans);\\n        }\\n        return v;\\n    }\\n    ll f(int num,vector<int>&v,vector<ll>&prefix)\\n    {\\n        ll ind=upper_bound(v.begin(),v.end(),num)-v.begin();\\n        ll sum=prefix[v.size()]-prefix[ind]-(v.size()-ind)*num;\\n        sum+=ind*num-prefix[ind];\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<ll>prefix(nums.size()+1,0);\\n        for(ll i=0;i<nums.size();i++)\\n        {\\n            prefix[i+1]=prefix[i]+nums[i];\\n        }\\n        vector<ll>v;\\n        for(auto &it:queries)\\n        {\\n            ll ans=f(it,nums,prefix);\\n            v.push_back(ans);\\n        }\\n        return v;\\n    }\\n    ll f(int num,vector<int>&v,vector<ll>&prefix)\\n    {\\n        ll ind=upper_bound(v.begin(),v.end(),num)-v.begin();\\n        ll sum=prefix[v.size()]-prefix[ind]-(v.size()-ind)*num;\\n        sum+=ind*num-prefix[ind];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505403,
                "title": "sorting",
                "content": "# Complexity\\n- Time complexity: $$O(n * log n + q * log q)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(q)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public IList<long> MinOperations(int[] nums, int[] queries)\\n    {\\n        int n = queries.Length;\\n        var result = new long[n];\\n        \\n        Array.Sort(nums);\\n        var idx = Enumerable.Range(0, n).ToArray();\\n        Array.Sort(queries, idx);\\n\\n        long sum = 0;\\n        foreach (var t in nums)\\n        {\\n            sum += Math.Abs(t - queries[0]);\\n        }\\n\\n        result[idx[0]] = sum;\\n        long prev = 0;\\n        while (prev < nums.Length && nums[prev] <= queries[0])\\n        {\\n            prev++;\\n        }\\n        long j = prev;\\n        for (int i = 1; i < queries.Length; i++)\\n        {\\n            if (queries[i] == queries[i - 1])\\n            {\\n                result[idx[i]] = sum;\\n                continue;\\n            }\\n\\n            while (j < nums.Length && nums[j] <= queries[i])\\n            {\\n                sum -= nums[j] - queries[i - 1];\\n                sum += queries[i] - nums[j];\\n                j++;\\n            }\\n\\n            sum += prev * (queries[i] - queries[i - 1]);\\n            sum -= (nums.Length - j) * (queries[i] - queries[i - 1]);\\n            result[idx[i]] = sum;\\n            prev = j;\\n        }\\n        \\n        return result.ToList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<long> MinOperations(int[] nums, int[] queries)\\n    {\\n        int n = queries.Length;\\n        var result = new long[n];\\n        \\n        Array.Sort(nums);\\n        var idx = Enumerable.Range(0, n).ToArray();\\n        Array.Sort(queries, idx);\\n\\n        long sum = 0;\\n        foreach (var t in nums)\\n        {\\n            sum += Math.Abs(t - queries[0]);\\n        }\\n\\n        result[idx[0]] = sum;\\n        long prev = 0;\\n        while (prev < nums.Length && nums[prev] <= queries[0])\\n        {\\n            prev++;\\n        }\\n        long j = prev;\\n        for (int i = 1; i < queries.Length; i++)\\n        {\\n            if (queries[i] == queries[i - 1])\\n            {\\n                result[idx[i]] = sum;\\n                continue;\\n            }\\n\\n            while (j < nums.Length && nums[j] <= queries[i])\\n            {\\n                sum -= nums[j] - queries[i - 1];\\n                sum += queries[i] - nums[j];\\n                j++;\\n            }\\n\\n            sum += prev * (queries[i] - queries[i - 1]);\\n            sum -= (nums.Length - j) * (queries[i] - queries[i - 1]);\\n            result[idx[i]] = sum;\\n            prev = j;\\n        }\\n        \\n        return result.ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502251,
                "title": "c-binary-search-solution",
                "content": "\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int getIndex(vector<int>& nums,int tar){\\n        int l = 0,r = nums.size()-1;\\n        int res = 0;\\n        while(l <= r){\\n            int mid = l+(r-l)/2;\\n            if(nums[mid] == tar){\\n                res = mid;\\n                l = mid+1;\\n            }else if(nums[mid] > tar){\\n                r = mid - 1;\\n            }else{\\n                res = mid;\\n                l = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long>preSum(nums.size());\\n        int n = nums.size();\\n        preSum[0] = nums[0];\\n\\n        for(int i = 1;i<nums.size();i++){\\n            preSum[i] = preSum[i-1]+nums[i];\\n        }\\n        vector<long long >res(queries.size());\\n        \\n        for(int i = 0;i<queries.size();i++){\\n            long long oper = 0;\\n            int idx = getIndex(nums,queries[i]);\\n            // cout<<idx<<\" \";\\n            long long requiredSum = (idx+1)*(long long)queries[i];\\n            oper = abs(requiredSum-preSum[idx]);\\n            long long  reqLast = (n - idx-1)*(long long)queries[i];\\n            oper += preSum[nums.size()-1]-preSum[idx]-reqLast;\\n            res[i] = oper;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int getIndex(vector<int>& nums,int tar){\\n        int l = 0,r = nums.size()-1;\\n        int res = 0;\\n        while(l <= r){\\n            int mid = l+(r-l)/2;\\n            if(nums[mid] == tar){\\n                res = mid;\\n                l = mid+1;\\n            }else if(nums[mid] > tar){\\n                r = mid - 1;\\n            }else{\\n                res = mid;\\n                l = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long>preSum(nums.size());\\n        int n = nums.size();\\n        preSum[0] = nums[0];\\n\\n        for(int i = 1;i<nums.size();i++){\\n            preSum[i] = preSum[i-1]+nums[i];\\n        }\\n        vector<long long >res(queries.size());\\n        \\n        for(int i = 0;i<queries.size();i++){\\n            long long oper = 0;\\n            int idx = getIndex(nums,queries[i]);\\n            // cout<<idx<<\" \";\\n            long long requiredSum = (idx+1)*(long long)queries[i];\\n            oper = abs(requiredSum-preSum[idx]);\\n            long long  reqLast = (n - idx-1)*(long long)queries[i];\\n            oper += preSum[nums.size()-1]-preSum[idx]-reqLast;\\n            res[i] = oper;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3497752,
                "title": "c-binary-search-prefix-sum-easy-solution",
                "content": "```\\nvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n       \\n        sort( nums.begin() , nums.end() ) ;\\n        int n = nums.size() ;\\n        vector<long long >prefix( n , 0 ) , suffix( n , 0 ) ;\\n        \\n        prefix[0] = nums[0] ;\\n        \\n        for( int i = 1 ; i < n ; i++ )\\n        {\\n            prefix[i] = prefix[i-1] + nums[i] ;\\n        }\\n        \\n        suffix[n-1] = nums[n-1] ;\\n        \\n        for( int i = n-2 ; i >= 0  ; i-- )\\n        {\\n            suffix[i] = suffix[i+1] + nums[i] ;\\n        }\\n        \\n        \\n        vector<long long >ans( queries.size() , 0 ) ;\\n        \\n        for( int i = 0 ; i < queries.size() ; i++ )\\n        {\\n            int idx = upper_bound( nums.begin() , nums.end() , queries[i] ) - nums.begin() ;\\n               \\n            if( idx > 0 )\\n            {\\n               ans[i] += ( ( long long )idx*queries[i] - prefix[idx-1] ) ;\\n            }\\n            \\n            if( idx < n )\\n            {\\n              ans[i] += ( suffix[idx] - ( long long )(n-idx)*queries[i] ) ;\\n            }\\n           \\n        }\\n        \\n        return ans ;\\n        \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n       \\n        sort( nums.begin() , nums.end() ) ;\\n        int n = nums.size() ;\\n        vector<long long >prefix( n , 0 ) , suffix( n , 0 ) ;\\n        \\n        prefix[0] = nums[0] ;\\n        \\n        for( int i = 1 ; i < n ; i++ )\\n        {\\n            prefix[i] = prefix[i-1] + nums[i] ;\\n        }\\n        \\n        suffix[n-1] = nums[n-1] ;\\n        \\n        for( int i = n-2 ; i >= 0  ; i-- )\\n        {\\n            suffix[i] = suffix[i+1] + nums[i] ;\\n        }\\n        \\n        \\n        vector<long long >ans( queries.size() , 0 ) ;\\n        \\n        for( int i = 0 ; i < queries.size() ; i++ )\\n        {\\n            int idx = upper_bound( nums.begin() , nums.end() , queries[i] ) - nums.begin() ;\\n               \\n            if( idx > 0 )\\n            {\\n               ans[i] += ( ( long long )idx*queries[i] - prefix[idx-1] ) ;\\n            }\\n            \\n            if( idx < n )\\n            {\\n              ans[i] += ( suffix[idx] - ( long long )(n-idx)*queries[i] ) ;\\n            }\\n           \\n        }\\n        \\n        return ans ;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475424,
                "title": "rust-python-n-m-log-n-detailed-explanation-with-math",
                "content": "# Intuition\\nLets look how to address this for one query and the value is $v$.\\n\\n- If the numbers are below $v$. Then the results are $v - a_1 + v - a_2 + ... v - a_n = v \\\\cdot n -  \\\\sum_{i=1}^{n} a_i $\\n- If the numbers are above $v$. With similar logic, results are $\\\\sum_{i=1}^{n} a_i - v \\\\cdot n$\\n\\nSo we need to find how many numbers are below and above the $v$ and prefix sums to be able to quickly find sums. To be do both of those efficiently you need to sort array of numbers.\\n\\nAfter the sorting you will have:\\n\\n$a_1, a_2, ..., a_k$ **v** $a_{k + 1}, ..., a_n$\\n\\nThe result is:\\n\\n$v \\\\cdot k - \\\\sum_{i=1}^{k} a_i + s - \\\\sum_{i=1}^{k} a_i - v\\\\cdot n + v \\\\cdot k = s + 2 vk -vn - 2 \\\\sum_{i=1}^{k} a_i = s + v (2k - n) - 2 \\\\sum_{i=1}^{k} a_i$\\n\\nThe value of `s` is a full sum: `prefix[-1]`. The value of sum is `prefix[k]`. \\n\\n# Complexity\\n- Time complexity: $O((n + m) \\\\log n)$\\n- Space complexity: $O(n)$\\n\\n\\n```Rust []\\nimpl Solution {\\n  pub fn min_operations(mut nums: Vec<i32>, queries: Vec<i32>) -> Vec<i64> {\\n    nums.sort_unstable();\\n    let n = nums.len();\\n\\n    let mut prefix: Vec<i64> = vec![0; n + 1];\\n    for i in 0 .. n {\\n      prefix[i + 1] = prefix[i] + nums[i] as i64;\\n    }\\n\\n    let mut res: Vec<i64> = vec![0; queries.len()];\\n    for i in 0 .. queries.len() {\\n      let k = match nums.binary_search(&queries[i]) {\\n        Err(k) => k,\\n        Ok(k)  => k,\\n      };\\n      res[i] = prefix[n] + (queries[i] as i64) * (2 * k - n) as i64 - 2 * prefix[k];\\n    }\\n\\n    return res;\\n  }\\n}\\n```\\n```python []\\nfrom bisect import bisect_right\\n\\nclass Solution:\\n  def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n    nums.sort()\\n\\n    n = len(nums)\\n    prefix = [0] * (n + 1)\\n    for i, v in enumerate(nums):\\n      prefix[i + 1] = prefix[i] + v\\n\\n    res, s = [0] * len(queries), prefix[-1]\\n    for i, v in enumerate(queries):\\n      k = bisect_right(nums, v)\\n      res[i] = s + v * (2 * k - n) - 2 * prefix[k]\\n    \\n    return res\\n```\\n\\n\\nQuestion to rust pro (this is my first weeks, so not so fluent). Is there a way to combine two arms in match (err/ok)?\\n",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Math"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn min_operations(mut nums: Vec<i32>, queries: Vec<i32>) -> Vec<i64> {\\n    nums.sort_unstable();\\n    let n = nums.len();\\n\\n    let mut prefix: Vec<i64> = vec![0; n + 1];\\n    for i in 0 .. n {\\n      prefix[i + 1] = prefix[i] + nums[i] as i64;\\n    }\\n\\n    let mut res: Vec<i64> = vec![0; queries.len()];\\n    for i in 0 .. queries.len() {\\n      let k = match nums.binary_search(&queries[i]) {\\n        Err(k) => k,\\n        Ok(k)  => k,\\n      };\\n      res[i] = prefix[n] + (queries[i] as i64) * (2 * k - n) as i64 - 2 * prefix[k];\\n    }\\n\\n    return res;\\n  }\\n}\\n```\n```python []\\nfrom bisect import bisect_right\\n\\nclass Solution:\\n  def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n    nums.sort()\\n\\n    n = len(nums)\\n    prefix = [0] * (n + 1)\\n    for i, v in enumerate(nums):\\n      prefix[i + 1] = prefix[i] + v\\n\\n    res, s = [0] * len(queries), prefix[-1]\\n    for i, v in enumerate(queries):\\n      k = bisect_right(nums, v)\\n      res[i] = s + v * (2 * k - n) - 2 * prefix[k]\\n    \\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474417,
                "title": "math-binary-search-prefix-sum",
                "content": "# Problem -\\n- For each query[ q ] you can find the minCost by just summing up of the cost that each element will take\\n- i.e If nums = {0,1,5,10} and query[ q ] = 4 , Then cost = 4 + 3 + 1 + 6 = 14\\nwhich is the nothing but , just the absolute difference between each number and the query[ q ].\\n\\n- Now focus on the ideal case\\n  Nums = {x1,x2,x3,x4,x5,...,xn} ,  query[q] = k\\n  Then Cost = abs(x1-k) + abs(x2-k) + . . . + abs(xn-k)\\n  Again the computation will take O(n) for each query.\\n  Resulting in O(n*q) Time Complexity for \\'q\\' Queries\\n\\n# Idea Building -\\n- Here we cannot just simplify the equation as the absolute value can be either negative or postive on opening.\\n- So Here , what we can do is , Just Sort and try to find a Positon = \\'Pos\\'  , Such that\\n  nums[0,pos] <= k and nums[pos+1,n-1] > k.\\n \\n- So that we can get rid of absolute and now the value of each bracket will greater tha equal to zero . Because till nums[Pos] Bracket , \\'k\\' will be either equal or larger , so (k-nums[Pos]) >= 0 , Similarly after nums[Pos] , \\'k\\' will smaller in each bracket , so (nums[Pos+1]-k) > 0\\n\\n- Since we computed the sign of each bracket . so , now we can take some common stuff out and simplify the Equation.\\n\\n# Procedure -\\n\\n**# Step1 :** Sort the given nums array\\n- now nums = { x1 , x2 , x3 , , , xn } where , x1 <= x2 <= x3 <= ... <= xn\\n- Say for Query[q] = k , Position(as explained above) = \\' Pos \\'\\n- Then cost :\\n\\n= (k-nums[0]) + (k-nums[1]) + (k-nums[3]) + . . . + (k-nums[Pos]) + (nums[Pos+1]-k) + (nums[Pos+2]-k) + . . . + (nums[n-1]-k)\\n\\n= (Pos+1)*k - (nums[0] + nums[1] + . . . + nums[Pos]) + (nums[Pos+1] + nums[Pos+2] + . . . + nums[n-1]) + (n-(Pos+1))*k\\n\\n= (Pos+1)*k - PrefixSum[Pos] + (PrefixSum[n-1]-PrefixSum[Pos]) + (n-Pos-1)*k\\n\\n= (Pos+1)*k + PrefixSum[n-1] - 2 * PrefixSum[Pos] - (n-Pos-1)*k\\n\\n= (n + 2*(Pos+1))*k + Prefix[n-1] - 2 * PrefixSum[Pos]\\n\\nThis is the simplified equation.\\n\\nFor Each Query Complexity = O(logn) + O(1)\\nFor finding Position = \\'Pos\\' &  O(1) for computing Formula\\nFor Sorting : O(nlogn)\\n\\nFor \\'q\\' Queries Time Complexity = O(q*logn) + O(nlogn)\\n\\n# Understood ? Now Go Code it By YourSelf !!\\n\\n\\n# Code -\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        vector<long long> prefix(n);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<n;i++) prefix[i] = prefix[i-1] + nums[i];\\n        \\n        int q = queries.size();\\n\\n        vector<long long int> ans(q);\\n        for(int k=0;k<q;k++){\\n            long long num = queries[k];\\n            int i = lower_bound(nums.begin(),nums.end(),num) - nums.begin();\\n            if(i == n || nums[i] != num) i--;\\n            ans[k] = (i+1)*num + prefix[n-1] - (n-i-1)*num;\\n            if(i >= 0) ans[k] -= 2*prefix[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        vector<long long> prefix(n);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<n;i++) prefix[i] = prefix[i-1] + nums[i];\\n        \\n        int q = queries.size();\\n\\n        vector<long long int> ans(q);\\n        for(int k=0;k<q;k++){\\n            long long num = queries[k];\\n            int i = lower_bound(nums.begin(),nums.end(),num) - nums.begin();\\n            if(i == n || nums[i] != num) i--;\\n            ans[k] = (i+1)*num + prefix[n-1] - (n-i-1)*num;\\n            if(i >= 0) ans[k] -= 2*prefix[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465336,
                "title": "simple-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        long long int p[n];\\n        p[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n           p[i]=p[i-1]+nums[i];\\n        int i=0;\\n        vector<long long>ans;\\n        for(int i=0;i<queries.size();i++){\\n          long long int tar=queries[i];\\n          int upr=lower_bound(nums.begin(),nums.end(),tar)-nums.begin();\\n          if(upr==n){\\n            ans.push_back(n*tar-p[n-1]);\\n          }\\n          else if(upr==0){\\n            ans.push_back(p[n-1]-n*tar);\\n          }\\n          else{\\n            long long int inc=p[n-1]-p[upr-1];\\n            long long int dsc=p[upr-1];\\n            long long int ops=inc-(n-upr)*tar+(upr*tar)-dsc;\\n            ans.push_back(ops);\\n          }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        long long int p[n];\\n        p[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n           p[i]=p[i-1]+nums[i];\\n        int i=0;\\n        vector<long long>ans;\\n        for(int i=0;i<queries.size();i++){\\n          long long int tar=queries[i];\\n          int upr=lower_bound(nums.begin(),nums.end(),tar)-nums.begin();\\n          if(upr==n){\\n            ans.push_back(n*tar-p[n-1]);\\n          }\\n          else if(upr==0){\\n            ans.push_back(p[n-1]-n*tar);\\n          }\\n          else{\\n            long long int inc=p[n-1]-p[upr-1];\\n            long long int dsc=p[upr-1];\\n            long long int ops=inc-(n-upr)*tar+(upr*tar)-dsc;\\n            ans.push_back(ops);\\n          }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454652,
                "title": "java-o-n-k-lgn-prefix-sum-and-binarysearch-reuse-lc2615-codes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReuse the calculate distance codes from [2615. Sum of Distances\\n](https://leetcode.com/problems/sum-of-distances/description/) and [its solution](https://leetcode.com/problems/sum-of-distances/solutions/3398461/java-prefix-sum-solution-with-summap-and-countmap/?orderBy=most_votes). \\nFind the index by binarySearch. Use (leftCount * target) - leftSum + (rightCount * target) - rightSum + math.abs(nums[index] - target).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSort O(nlgn) + Query O(k * lgn), n is the length of nums, k is the length of queries.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        long[] sum = new long[nums.length];\\n        sum[0] = (long)nums[0];\\n        for(int i = 1; i < nums.length; ++i){\\n            sum[i] = sum[i - 1] + (long)nums[i];\\n        }\\n        List<Long> res = new ArrayList<>();\\n        for(int query: queries){\\n            res.add(getOperations(sum, nums, query));\\n        }\\n        return res;\\n    }\\n\\n    public long getOperations(long[] sum, int[] nums, int target){\\n        long res = 0;\\n        int index = getIndex(nums, target);\\n        int leftCounts = index;\\n        int rightCounts = nums.length - 1 - index;\\n        if(leftCounts > 0){\\n            res += (long)leftCounts * target - sum[index - 1];\\n        }\\n        if(rightCounts > 0){\\n            res += sum[nums.length - 1] - sum[index] - (long)rightCounts * target;\\n        }\\n        res += (long)Math.abs(target - nums[index]);\\n        return res;\\n    }\\n\\n    public int getIndex(int[] nums, int target){\\n        int index = Arrays.binarySearch(nums, target);\\n        if(index < 0) \\n            index = -(index + 1);\\n        if(index == nums.length) --index;\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        long[] sum = new long[nums.length];\\n        sum[0] = (long)nums[0];\\n        for(int i = 1; i < nums.length; ++i){\\n            sum[i] = sum[i - 1] + (long)nums[i];\\n        }\\n        List<Long> res = new ArrayList<>();\\n        for(int query: queries){\\n            res.add(getOperations(sum, nums, query));\\n        }\\n        return res;\\n    }\\n\\n    public long getOperations(long[] sum, int[] nums, int target){\\n        long res = 0;\\n        int index = getIndex(nums, target);\\n        int leftCounts = index;\\n        int rightCounts = nums.length - 1 - index;\\n        if(leftCounts > 0){\\n            res += (long)leftCounts * target - sum[index - 1];\\n        }\\n        if(rightCounts > 0){\\n            res += sum[nums.length - 1] - sum[index] - (long)rightCounts * target;\\n        }\\n        res += (long)Math.abs(target - nums[index]);\\n        return res;\\n    }\\n\\n    public int getIndex(int[] nums, int target){\\n        int index = Arrays.binarySearch(nums, target);\\n        if(index < 0) \\n            index = -(index + 1);\\n        if(index == nums.length) --index;\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443660,
                "title": "c-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n         \\n         vector<long long int> s(nums.size(),0);\\n         s[0]=nums[0];\\n         vector<long long> f;\\n\\n         for(int i=1;i<nums.size();i++)\\n         s[i]=s[i-1]+nums[i];\\n\\n         for(auto i: queries)\\n         {\\n             int st=0,e=nums.size()-1,mx=-1;\\n             while(st<=e)\\n             {\\n                 int m=(st+e)/2;\\n                 if(nums[m]<=i)\\n                 {\\n                     mx=max(mx,m);\\n                     st=m+1;\\n                 }\\n                 else\\n                 e=m-1;\\n             };\\n           long long q;\\n           if(mx!=-1)  \\n           q=1LL*(mx+1)*i-s[mx]+s[s.size()-1]-s[mx]-(nums.size()-1-mx)*1LL*i;\\n           else\\n               q=s[s.size()-1]-(nums.size()-1-mx)*1LL*i;\\n           \\n           f.push_back(q);\\n         }\\n         return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n         \\n         vector<long long int> s(nums.size(),0);\\n         s[0]=nums[0];\\n         vector<long long> f;\\n\\n         for(int i=1;i<nums.size();i++)\\n         s[i]=s[i-1]+nums[i];\\n\\n         for(auto i: queries)\\n         {\\n             int st=0,e=nums.size()-1,mx=-1;\\n             while(st<=e)\\n             {\\n                 int m=(st+e)/2;\\n                 if(nums[m]<=i)\\n                 {\\n                     mx=max(mx,m);\\n                     st=m+1;\\n                 }\\n                 else\\n                 e=m-1;\\n             };\\n           long long q;\\n           if(mx!=-1)  \\n           q=1LL*(mx+1)*i-s[mx]+s[s.size()-1]-s[mx]-(nums.size()-1-mx)*1LL*i;\\n           else\\n               q=s[s.size()-1]-(nums.size()-1-mx)*1LL*i;\\n           \\n           f.push_back(q);\\n         }\\n         return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437632,
                "title": "binary-search-prefix-sum-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        long long sum=0,n=nums.size();\\n        vector<long long>dp(n,0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            dp[i]=sum;\\n        }\\n        vector<long long>v;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int val=queries[i];\\n            int index=lower_bound(nums.begin(),nums.end(),val)-nums.begin();\\n            long long left=0,right=dp[n-1];\\n            if(index-1>=0)\\n            {\\n                left=dp[index-1];\\n                right-=dp[index-1];\\n            }\\n            v.push_back(1LL*index*val-left+right-(n-index)*val);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        long long sum=0,n=nums.size();\\n        vector<long long>dp(n,0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            dp[i]=sum;\\n        }\\n        vector<long long>v;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int val=queries[i];\\n            int index=lower_bound(nums.begin(),nums.end(),val)-nums.begin();\\n            long long left=0,right=dp[n-1];\\n            if(index-1>=0)\\n            {\\n                left=dp[index-1];\\n                right-=dp[index-1];\\n            }\\n            v.push_back(1LL*index*val-left+right-(n-index)*val);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434391,
                "title": "c-easy-solution-best-explanation-optimized-sorting-prefix-sum-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***# PLEASE UPVOTE !!***\\n# Approach\\n```\\nint binary(vector<int> &nums , int target){\\n```\\nDefine a function named binary that takes a reference to a vector of integers nums and an integer target as input, and returns an integer.\\n\\n```\\n    int low = 0 , high = nums.size()-1 ;\\n```\\nDeclare two integer variables low and high and initialize them to 0 and nums.size()-1, respectively.\\n\\n```\\n    while(low+1<high){\\n```\\nStart a while loop that continues as long as low+1 is less than high.\\n\\n```\\n        int mid = (low+ high)/2 ;\\n```\\nCalculate the middle index mid as the average of low and high.\\n\\n```\\n        if(nums[mid]<=target) low = mid ;\\n        else high = mid ;\\n```\\nIf the value at nums[mid] is less than or equal to the target, update low to mid; otherwise, update high to mid.\\n\\n```\\n    }\\n    return low;\\n```\\nEnd the while loop and return the value of low.\\n\\n```\\nvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n```\\nDefine a function named minOperations that takes two references to vectors of integers nums and queries as input, and returns a vector of long long integers.\\n\\n```\\n    sort(nums.begin() , nums.end());\\n```\\nSort the nums vector in ascending order using the sort function.\\n\\n```\\n    long long n = nums.size();\\n```\\nDeclare a long long integer variable n and initialize it to the size of the nums vector.\\n\\n```\\n    vector<long long> answer;\\n```\\nDeclare an empty vector of long long integers named answer.\\n\\n```\\n    vector<long long> prefix(n , 0);\\n```\\nDeclare a vector of long long integers named prefix of size n, and initialize all its values to 0.\\n\\n```\\n    prefix[0]=nums[0];\\n```\\nSet the value at index 0 of the prefix vector to the first value in the sorted nums vector.\\n\\n```\\n    for(int i=1 ;i<n ;i++){\\n        prefix[i] = prefix[i-1] + nums[i] ;\\n    }\\n```\\nIterate over the sorted nums vector from index 1 to n-1, and set the value at each index i of the prefix vector to the sum of the value at index i-1 of the prefix vector and the value at index i of the sorted nums vector.\\n\\n```\\n    for(int i=0 ;i<queries.size(); i++){\\n        long long  temp=0 ;\\n```\\nIterate over the queries vector using a for loop, and declare a long long integer variable temp and initialize it to 0 for each iteration.\\n\\n```\\n        if(nums[0]>=queries[i]){\\n            temp = prefix[n-1] - (n*queries[i]) ;\\n        }\\n```\\nIf the first value in the sorted nums vector is greater than or equal to the current queries[i], set temp to the difference between the sum of all values in the prefix vector and (n*queries[i]).\\n\\n```\\n        else if(nums[n-1]<=queries[i]){\\n            temp = (n*queries[i] - prefix[n-1]) ;\\n        }\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int binary(vector<int> &nums , int target){\\n        int low = 0 , high = nums.size()-1 ;\\n        while(low+1<high){\\n            int mid = (low+ high)/2 ;\\n            if(nums[mid]<=target) low = mid ;\\n            else high = mid ;\\n        }\\n        return low;\\n    }\\n\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin() , nums.end());\\n        long long n = nums.size();\\n        vector<long long> answer;\\n        vector<long long> prefix(n , 0);\\n        prefix[0]=nums[0];\\n        for(int i=1 ;i<n ;i++){\\n            prefix[i] = prefix[i-1] + nums[i] ;\\n        }\\n        for(int i=0 ;i<queries.size(); i++){\\n            long long  temp=0 ;\\n            if(nums[0]>=queries[i]){\\n                temp = prefix[n-1] - (n*queries[i]) ;\\n            }\\n            else if(nums[n-1]<=queries[i]){\\n                temp = (n*queries[i] - prefix[n-1]) ;\\n            }\\n            else{\\n                long long index = binary(nums , queries[i]) ;\\n                temp =  ((index+1)*queries[i]) - prefix[index];\\n                temp+=  (prefix[n-1]-prefix[index]) - (n-index-1)*queries[i] ;\\n            }\\n            answer.push_back(temp);\\n        }\\n        return answer ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nint binary(vector<int> &nums , int target){\\n```\n```\\n    int low = 0 , high = nums.size()-1 ;\\n```\n```\\n    while(low+1<high){\\n```\n```\\n        int mid = (low+ high)/2 ;\\n```\n```\\n        if(nums[mid]<=target) low = mid ;\\n        else high = mid ;\\n```\n```\\n    }\\n    return low;\\n```\n```\\nvector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n```\n```\\n    sort(nums.begin() , nums.end());\\n```\n```\\n    long long n = nums.size();\\n```\n```\\n    vector<long long> answer;\\n```\n```\\n    vector<long long> prefix(n , 0);\\n```\n```\\n    prefix[0]=nums[0];\\n```\n```\\n    for(int i=1 ;i<n ;i++){\\n        prefix[i] = prefix[i-1] + nums[i] ;\\n    }\\n```\n```\\n    for(int i=0 ;i<queries.size(); i++){\\n        long long  temp=0 ;\\n```\n```\\n        if(nums[0]>=queries[i]){\\n            temp = prefix[n-1] - (n*queries[i]) ;\\n        }\\n```\n```\\n        else if(nums[n-1]<=queries[i]){\\n            temp = (n*queries[i] - prefix[n-1]) ;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int binary(vector<int> &nums , int target){\\n        int low = 0 , high = nums.size()-1 ;\\n        while(low+1<high){\\n            int mid = (low+ high)/2 ;\\n            if(nums[mid]<=target) low = mid ;\\n            else high = mid ;\\n        }\\n        return low;\\n    }\\n\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin() , nums.end());\\n        long long n = nums.size();\\n        vector<long long> answer;\\n        vector<long long> prefix(n , 0);\\n        prefix[0]=nums[0];\\n        for(int i=1 ;i<n ;i++){\\n            prefix[i] = prefix[i-1] + nums[i] ;\\n        }\\n        for(int i=0 ;i<queries.size(); i++){\\n            long long  temp=0 ;\\n            if(nums[0]>=queries[i]){\\n                temp = prefix[n-1] - (n*queries[i]) ;\\n            }\\n            else if(nums[n-1]<=queries[i]){\\n                temp = (n*queries[i] - prefix[n-1]) ;\\n            }\\n            else{\\n                long long index = binary(nums , queries[i]) ;\\n                temp =  ((index+1)*queries[i]) - prefix[index];\\n                temp+=  (prefix[n-1]-prefix[index]) - (n-index-1)*queries[i] ;\\n            }\\n            answer.push_back(temp);\\n        }\\n        return answer ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432925,
                "title": "c-sorting-binary-search-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<long long unsigned> prefix(n);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        vector<long long> ans;\\n        for(int i=0;i<queries.size();i++){\\n            \\n            int start=0;\\n            int end=n-1;\\n            int num=queries[i];\\n            int index=-1;\\n            while(start<=end){\\n                \\n                int mid=(start+end)/2;\\n                if(nums[mid]<=num){\\n                    index=mid;\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(index==-1){\\n                \\n                long long unsigned right=(long long unsigned)(prefix[n-1])-((long long unsigned)num*n);\\n                ans.push_back(right);\\n            }\\n            else{\\n                \\n                long long unsigned left=((long long unsigned)num*(index+1))-prefix[index];\\n                long long unsigned right=(prefix[n-1]-prefix[index])-((long long unsigned)num*(n-index-1));\\n                ans.push_back(left+right);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<long long unsigned> prefix(n);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3431985,
                "title": "python-o-nlogn-solution-using-prefix-suffix-sum",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n\\n        # sort nums, make two arrays , prefix sum and suffix sum\\n        # find the position of the query in the nums,\\n        # use prefix sum for left and subtract i*ownval - prefixsum[i] \\n        # use suffix sum for right and subtract suffixsum - i*ownval \\n        n = len(nums)\\n        prefixsum ,suffixsum = [0]*n , [0]*n\\n        nums.sort() \\n        prefixsum[0] = nums[0]\\n        suffixsum[n-1] = nums[n-1]\\n        for i in range(1,n):\\n            prefixsum[i] = prefixsum[i-1]+nums[i]\\n            suffixsum[n-i-1] = suffixsum[n-i] + nums[n-i-1]\\n\\n        res = []\\n        for q in queries:\\n            x = bisect.bisect_left(nums,q);\\n            temp = 0\\n            if(x > 0 ): temp = (x)*q - prefixsum[x-1]\\n            if(x<n): temp += suffixsum[x] - (n-x)*q\\n            res.append(temp)\\n        \\n        return res \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n\\n        # sort nums, make two arrays , prefix sum and suffix sum\\n        # find the position of the query in the nums,\\n        # use prefix sum for left and subtract i*ownval - prefixsum[i] \\n        # use suffix sum for right and subtract suffixsum - i*ownval \\n        n = len(nums)\\n        prefixsum ,suffixsum = [0]*n , [0]*n\\n        nums.sort() \\n        prefixsum[0] = nums[0]\\n        suffixsum[n-1] = nums[n-1]\\n        for i in range(1,n):\\n            prefixsum[i] = prefixsum[i-1]+nums[i]\\n            suffixsum[n-i-1] = suffixsum[n-i] + nums[n-i-1]\\n\\n        res = []\\n        for q in queries:\\n            x = bisect.bisect_left(nums,q);\\n            temp = 0\\n            if(x > 0 ): temp = (x)*q - prefixsum[x-1]\\n            if(x<n): temp += suffixsum[x] - (n-x)*q\\n            res.append(temp)\\n        \\n        return res \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429185,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint cmp(const void*a, const void *b){\\n    return *(int*)a -*(int*)b;\\n}\\nint binarysearch(int *nums,int numsSize,int val){\\n    int left=0;\\n    int right=numsSize-1;\\n    while(left<right){\\n        int mid=left+(right-left)/2;\\n        if(nums[mid]<val) left=mid+1;\\n        else right=mid;\\n    }\\n    return left;\\n}\\nlong long* minOperations(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){\\n    *returnSize=queriesSize;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    long long *temp=(long long*)calloc(numsSize,sizeof(long long));\\n    long long  *res=(long long*)calloc(queriesSize,sizeof(long long));\\n    temp[0]=nums[0];\\n    for(int i=1;i<numsSize;i++){\\n        temp[i]=nums[i]+temp[i-1];\\n    }\\n    //for(int i=0;i<numsSize;i++){\\n    //    printf(\" %d \",temp[i]);\\n    //}\\n    //printf(\"\\\\n\");\\n    for(int i=0;i<queriesSize;i++){\\n        \\n        if(queries[i] <= nums[0]) res[i] = temp[numsSize-1] - (long long)queries[i] * numsSize;\\n        else if(queries[i] >= nums[numsSize - 1])\\n            res[i] = (long long)queries[i] * numsSize - temp[numsSize-1];\\n        else{\\n            int idx=binarysearch(nums,numsSize,queries[i]);    \\n            // long long right=(temp[numsSize-1]-temp[idx-1])-(long long)queries[i]*(numsSize-idx);\\n            // long long  left = (long long)queries[i]*(idx)-temp[idx-1]; \\n            res[i]= (long long)queries[i]*(2*idx-numsSize)+temp[numsSize-1]-2*temp[idx-1];\\n        }\\n        \\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint cmp(const void*a, const void *b){\\n    return *(int*)a -*(int*)b;\\n}\\nint binarysearch(int *nums,int numsSize,int val){\\n    int left=0;\\n    int right=numsSize-1;\\n    while(left<right){\\n        int mid=left+(right-left)/2;\\n        if(nums[mid]<val) left=mid+1;\\n        else right=mid;\\n    }\\n    return left;\\n}\\nlong long* minOperations(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){\\n    *returnSize=queriesSize;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    long long *temp=(long long*)calloc(numsSize,sizeof(long long));\\n    long long  *res=(long long*)calloc(queriesSize,sizeof(long long));\\n    temp[0]=nums[0];\\n    for(int i=1;i<numsSize;i++){\\n        temp[i]=nums[i]+temp[i-1];\\n    }\\n    //for(int i=0;i<numsSize;i++){\\n    //    printf(\" %d \",temp[i]);\\n    //}\\n    //printf(\"\\\\n\");\\n    for(int i=0;i<queriesSize;i++){\\n        \\n        if(queries[i] <= nums[0]) res[i] = temp[numsSize-1] - (long long)queries[i] * numsSize;\\n        else if(queries[i] >= nums[numsSize - 1])\\n            res[i] = (long long)queries[i] * numsSize - temp[numsSize-1];\\n        else{\\n            int idx=binarysearch(nums,numsSize,queries[i]);    \\n            // long long right=(temp[numsSize-1]-temp[idx-1])-(long long)queries[i]*(numsSize-idx);\\n            // long long  left = (long long)queries[i]*(idx)-temp[idx-1]; \\n            res[i]= (long long)queries[i]*(2*idx-numsSize)+temp[numsSize-1]-2*temp[idx-1];\\n        }\\n        \\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3427197,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findans(vector<int>&nums,int target){\\n        int i = 0;\\n        int j = nums.size() -1;\\n        int mid;\\n        while(i<=j){\\n            mid = (i+j)/2;\\n            if(nums[mid]==target)return mid;\\n            else if(nums[mid]<target)i = mid+1;\\n            else j = mid - 1;\\n        }\\n        return mid;\\n    }\\n\\n    \\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long>s(nums.size(),0);\\n        s[0] = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n            s[i] = nums[i] + s[i-1];\\n        }\\n        vector<long long>v(q.size(),0);\\n        long long sum = s[s.size()-1];\\n        for(int i = 0;i<q.size();i++){\\n            int x = lower_bound(nums.begin(),nums.end(),q[i])-nums.begin();\\n            if(x==0){\\n                v[i] = sum - ((q[i]*1ll)*s.size());\\n            }\\n            else if(x>=nums.size()-1){\\n                v[i] = -(sum - ((q[i]*1ll)*s.size()));\\n            }\\n            else{\\n                long long left = -((s[x-1]) - ((q[i]*1ll)*x));\\n                long long right = ((sum - s[x-1]) - ((q[i]*1ll)*(nums.size()-x)));\\n                cout<<(sum - s[x-1]);\\n                // cout<<left<<\" \"<<right;\\n                v[i] = left + right;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findans(vector<int>&nums,int target){\\n        int i = 0;\\n        int j = nums.size() -1;\\n        int mid;\\n        while(i<=j){\\n            mid = (i+j)/2;\\n            if(nums[mid]==target)return mid;\\n            else if(nums[mid]<target)i = mid+1;\\n            else j = mid - 1;\\n        }\\n        return mid;\\n    }\\n\\n    \\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long>s(nums.size(),0);\\n        s[0] = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n            s[i] = nums[i] + s[i-1];\\n        }\\n        vector<long long>v(q.size(),0);\\n        long long sum = s[s.size()-1];\\n        for(int i = 0;i<q.size();i++){\\n            int x = lower_bound(nums.begin(),nums.end(),q[i])-nums.begin();\\n            if(x==0){\\n                v[i] = sum - ((q[i]*1ll)*s.size());\\n            }\\n            else if(x>=nums.size()-1){\\n                v[i] = -(sum - ((q[i]*1ll)*s.size()));\\n            }\\n            else{\\n                long long left = -((s[x-1]) - ((q[i]*1ll)*x));\\n                long long right = ((sum - s[x-1]) - ((q[i]*1ll)*(nums.size()-x)));\\n                cout<<(sum - s[x-1]);\\n                // cout<<left<<\" \"<<right;\\n                v[i] = left + right;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3424576,
                "title": "sort-prefix-sum-binary-search-for-query-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        using ll = long long;\\n        vector<ll> prefixSums{0};\\n\\n        sort(begin(nums), end(nums));\\n        for (auto n: nums)\\n            prefixSums.push_back(prefixSums.back() + n);\\n\\n        vector<ll> res;\\n        for (auto q: queries) {\\n            auto it = lower_bound(begin(nums), end(nums), q);\\n            auto index = it - begin(nums);\\n            auto left = index * q - prefixSums[index];\\n            auto right = prefixSums[nums.size()] - prefixSums[index] - (nums.size()-index) * q;\\n            res.push_back(left + right);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        using ll = long long;\\n        vector<ll> prefixSums{0};\\n\\n        sort(begin(nums), end(nums));\\n        for (auto n: nums)\\n            prefixSums.push_back(prefixSums.back() + n);\\n\\n        vector<ll> res;\\n        for (auto q: queries) {\\n            auto it = lower_bound(begin(nums), end(nums), q);\\n            auto index = it - begin(nums);\\n            auto left = index * q - prefixSums[index];\\n            auto right = prefixSums[nums.size()] - prefixSums[index] - (nums.size()-index) * q;\\n            res.push_back(left + right);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421630,
                "title": "quick-sort-prefix-sums",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst sort ```nums``` and ```queries```. Let ```prefix[i]``` denotes the sum of all ```ki``` numbers in sorted ```nums``` smaller than ```queries[i]```. Then ```sum(nums)-prefix[i]``` equals the sum of all numbers in sorted ```nums``` larger than or equal to ```queries[i]```. Then the number of operations to make all elements equal to ```queries[i]``` is equal to ```queries[i]*ki - prefix[i] + sum(nums) - prefix[i] - queries[i]*(n-ki)```.\\n\\n# Complexity\\n- Time complexity: ```O(n log n) + O(m log m)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(m)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        n, m = len(nums), len(queries)\\n        nums.sort()\\n        ind_q = [i for i in range(m)]\\n        sorted_q = sorted(ind_q, key=lambda x: queries[x])\\n        ans = [0 for i in range(m)]\\n        prefix = [0 for i in range(m)]\\n        sumnums = sum(nums)\\n        ki = 0\\n        for i, ind in enumerate(sorted_q):\\n            q = queries[ind]\\n            prefix[i] = prefix[i-1] if i > 0 else prefix[i]\\n            while ki < n and nums[ki] < q:\\n                prefix[i] += nums[ki]\\n                ki += 1\\n            ans[ind] = q*(ki) - prefix[i] + sumnums - prefix[i] - q*(n-ki)\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```nums```\n```queries```\n```prefix[i]```\n```ki```\n```nums```\n```queries[i]```\n```sum(nums)-prefix[i]```\n```nums```\n```queries[i]```\n```queries[i]```\n```queries[i]*ki - prefix[i] + sum(nums) - prefix[i] - queries[i]*(n-ki)```\n```O(n log n) + O(m log m)```\n```O(m)```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        n, m = len(nums), len(queries)\\n        nums.sort()\\n        ind_q = [i for i in range(m)]\\n        sorted_q = sorted(ind_q, key=lambda x: queries[x])\\n        ans = [0 for i in range(m)]\\n        prefix = [0 for i in range(m)]\\n        sumnums = sum(nums)\\n        ki = 0\\n        for i, ind in enumerate(sorted_q):\\n            q = queries[ind]\\n            prefix[i] = prefix[i-1] if i > 0 else prefix[i]\\n            while ki < n and nums[ki] < q:\\n                prefix[i] += nums[ki]\\n                ki += 1\\n            ans[ind] = q*(ki) - prefix[i] + sumnums - prefix[i] - q*(n-ki)\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415965,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        \\n     int n=nums.length;\\n        Arrays.sort(nums);\\n        long prefix[]=new long[n];\\n        ArrayList<Long> list=new ArrayList<>();\\n        prefix[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=0;i<queries.length;i++){\\n            int l=0;\\n            int r=n-1;\\n            long max=(long)queries[i]*n;\\n            while(l<r){\\n                int mid=(l+r)>>1;\\n                if(nums[mid]<queries[i]){\\n                    l=mid+1;\\n                }\\n                else{\\n                    r=mid;\\n                }\\n            }\\n\\t\\t\\t//no smaller element\\n            if(l<=0){\\n                long diff=(long)Math.abs(prefix[n-1]-max);\\n                list.add(diff);\\n                continue;\\n            }\\n\\t\\t\\t//all smaller\\n            if(l>=n-1){\\n                long diff=(long)Math.abs(max-prefix[n-1]);\\n                list.add(diff);\\n                continue;\\n            }\\n            else{\\n                int lowerHalfEnd=l;\\n                if(nums[l]!=queries[i]){\\n                    lowerHalfEnd=l-1;\\n                }\\n                long smallerMax=(long)queries[i]*(lowerHalfEnd+1);\\n                long LargerMax=(long)queries[i]*(n-lowerHalfEnd-1);\\n                long total=(long)(smallerMax-prefix[lowerHalfEnd])+(prefix[n-1]-prefix[lowerHalfEnd]-LargerMax);\\n                list.add(total);\\n            }\\n        }\\n        return list;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        \\n     int n=nums.length;\\n        Arrays.sort(nums);\\n        long prefix[]=new long[n];\\n        ArrayList<Long> list=new ArrayList<>();\\n        prefix[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=0;i<queries.length;i++){\\n            int l=0;\\n            int r=n-1;\\n            long max=(long)queries[i]*n;\\n            while(l<r){\\n                int mid=(l+r)>>1;\\n                if(nums[mid]<queries[i]){\\n                    l=mid+1;\\n                }\\n                else{\\n                    r=mid;\\n                }\\n            }\\n\\t\\t\\t//no smaller element\\n            if(l<=0){\\n                long diff=(long)Math.abs(prefix[n-1]-max);\\n                list.add(diff);\\n                continue;\\n            }\\n\\t\\t\\t//all smaller\\n            if(l>=n-1){\\n                long diff=(long)Math.abs(max-prefix[n-1]);\\n                list.add(diff);\\n                continue;\\n            }\\n            else{\\n                int lowerHalfEnd=l;\\n                if(nums[l]!=queries[i]){\\n                    lowerHalfEnd=l-1;\\n                }\\n                long smallerMax=(long)queries[i]*(lowerHalfEnd+1);\\n                long LargerMax=(long)queries[i]*(n-lowerHalfEnd-1);\\n                long total=(long)(smallerMax-prefix[lowerHalfEnd])+(prefix[n-1]-prefix[lowerHalfEnd]-LargerMax);\\n                list.add(total);\\n            }\\n        }\\n        return list;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415824,
                "title": "simple-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    void binary(vector<int>& nums, int st, int end, int& target, int& k){\\n        if(st<=end){\\n            int mid=(st+end)/2;\\n            if(nums[mid]<=target){\\n                k=max(k,mid);\\n                return binary(nums,mid+1,end,target,k);\\n            }\\n            else{\\n                return binary(nums,st,mid-1,target,k);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long>prefix;\\n        int n=nums.size();\\n        long long sum1=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum1+=nums[i];\\n            prefix.pb(sum1);\\n        }\\n        vector<long long>res;\\n        for(int i=0;i<queries.size();i++){\\n            int val=queries[i];\\n            int k=-1;\\n            binary(nums,0,nums.size()-1,val,k);\\n            long long ans1=0;\\n            long long ans2=0;\\n            if(k>=0){\\n                ans1=((long long)(k+1)*queries[i])-prefix[k];\\n                ans2=prefix[nums.size()-1]-prefix[k]-((long long)(n-1-k)*queries[i]);\\n            }\\n            else{\\n                ans2=prefix[nums.size()-1]-((long long)(n)*queries[i]);\\n            }\\n            long long ans=ans1+ans2;\\n            res.pb(ans);\\n        }\\n        return res;\\n    }\\n};\\n/*\\n[50,84,76,41,64,82,20,22,64,7,38,92,39,28,22,3,41,46,47,50,88,51,9,49,38,67,26,65,89,27,71,25,77,72,65,41,84,68,51,26,84,24,79,41,96,83,92,9,93,84,35,70,74,79,37,38,26,26,41,26]\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    void binary(vector<int>& nums, int st, int end, int& target, int& k){\\n        if(st<=end){\\n            int mid=(st+end)/2;\\n            if(nums[mid]<=target){\\n                k=max(k,mid);\\n                return binary(nums,mid+1,end,target,k);\\n            }\\n            else{\\n                return binary(nums,st,mid-1,target,k);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long>prefix;\\n        int n=nums.size();\\n        long long sum1=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum1+=nums[i];\\n            prefix.pb(sum1);\\n        }\\n        vector<long long>res;\\n        for(int i=0;i<queries.size();i++){\\n            int val=queries[i];\\n            int k=-1;\\n            binary(nums,0,nums.size()-1,val,k);\\n            long long ans1=0;\\n            long long ans2=0;\\n            if(k>=0){\\n                ans1=((long long)(k+1)*queries[i])-prefix[k];\\n                ans2=prefix[nums.size()-1]-prefix[k]-((long long)(n-1-k)*queries[i]);\\n            }\\n            else{\\n                ans2=prefix[nums.size()-1]-((long long)(n)*queries[i]);\\n            }\\n            long long ans=ans1+ans2;\\n            res.pb(ans);\\n        }\\n        return res;\\n    }\\n};\\n/*\\n[50,84,76,41,64,82,20,22,64,7,38,92,39,28,22,3,41,46,47,50,88,51,9,49,38,67,26,65,89,27,71,25,77,72,65,41,84,68,51,26,84,24,79,41,96,83,92,9,93,84,35,70,74,79,37,38,26,26,41,26]\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415412,
                "title": "using-binary-search-and-prefix-sum-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to find sum of absolute differnce between nums[i]-q\\ni.e operations to make all element equal to q \\n\\n# Approach\\ndivide array in two parts all elements <=q and the rest >q.\\nuse binary search to find a breaking index and get sum of all left side and on right side.\\nlen1= number of elements on left side.\\nlen2= number of elements on right side.\\nsum of elements  till breaking point say left \\nsum of res elements sum say right\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binary_serach1(vector<int>&nums, int value){\\n        int low=0,high=nums.size()-1;\\n        int index=high;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]<=value){\\n                index=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return index;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long >res;\\n        sort(nums.begin(),nums.end());\\n        vector<long long >prefix;\\n        long long int sum=0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum+=nums[i];\\n            prefix.push_back(sum);\\n        }\\n        for(int q:queries){\\n            int index=binary_serach1(nums,q);\\n            int len1= index+1;\\n            int len2= nums.size()-len1;\\n            long long int temp=0;\\n            long long int  left=0;\\n            for(int i=0;i<len1; i++){\\n                left+=q;\\n            }\\n            long long int right=0;\\n            for(int i=0;i<len2; i++){\\n                right+=q;\\n            }\\n//below line giving run time error so i.e. add q to left and right\\n// long long int temp = abs((len1*q)- prefix[index]) + abs((len2*q)-(sum-prefix[index])); \\n             temp = abs((left)- prefix[index]) + abs((right)-(sum-prefix[index])); \\n            res.push_back(temp);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binary_serach1(vector<int>&nums, int value){\\n        int low=0,high=nums.size()-1;\\n        int index=high;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]<=value){\\n                index=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return index;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long >res;\\n        sort(nums.begin(),nums.end());\\n        vector<long long >prefix;\\n        long long int sum=0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum+=nums[i];\\n            prefix.push_back(sum);\\n        }\\n        for(int q:queries){\\n            int index=binary_serach1(nums,q);\\n            int len1= index+1;\\n            int len2= nums.size()-len1;\\n            long long int temp=0;\\n            long long int  left=0;\\n            for(int i=0;i<len1; i++){\\n                left+=q;\\n            }\\n            long long int right=0;\\n            for(int i=0;i<len2; i++){\\n                right+=q;\\n            }\\n//below line giving run time error so i.e. add q to left and right\\n// long long int temp = abs((len1*q)- prefix[index]) + abs((len2*q)-(sum-prefix[index])); \\n             temp = abs((left)- prefix[index]) + abs((right)-(sum-prefix[index])); \\n            res.push_back(temp);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413997,
                "title": "prefix-sum-sorting-binary-search-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Make all elements equal -> Sum -> `Prefix Sum` problem.\\n2. Since order is not important, we can sort nums first to speed up later search.\\n3. Build `preSum`\\n4. Since we already sort the `nums`, now \\nwe `binary search` for the `queries[i]`, the `target`, to split \\n`left preSum` (<= target) and \\n`right preSum` (> target)\\n5. Final is doing the simple math.\\n```\\n(target*count - left_preSum) + (right_preSum - target*(n-count)) \\n```\\n6. Congratulation!\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size(), k = queries.size();\\n        vector<long long> preSum(n+1, 0);\\n        sort(nums.begin(), nums.end());\\n        preSum[0] = 0LL;\\n        for(int i = 1; i <= n; ++i) preSum[i] = 1LL * preSum[i-1] + nums[i-1];\\n        \\n        vector<long long> ans(k);\\n        for(int i = 0; i < k; ++i){\\n            int t = queries[i];\\n            int count = lower_bound(nums.begin(), nums.end(), t) - nums.begin();\\n            // ans[i] = (t*count - preSum[count]) + (preSum[n] - preSum[count] - t*count);\\n            ans[i] = preSum[n] - 2* preSum[count] + 1LL*(2*count - n)*t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n(target*count - left_preSum) + (right_preSum - target*(n-count)) \\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size(), k = queries.size();\\n        vector<long long> preSum(n+1, 0);\\n        sort(nums.begin(), nums.end());\\n        preSum[0] = 0LL;\\n        for(int i = 1; i <= n; ++i) preSum[i] = 1LL * preSum[i-1] + nums[i-1];\\n        \\n        vector<long long> ans(k);\\n        for(int i = 0; i < k; ++i){\\n            int t = queries[i];\\n            int count = lower_bound(nums.begin(), nums.end(), t) - nums.begin();\\n            // ans[i] = (t*count - preSum[count]) + (preSum[n] - preSum[count] - t*count);\\n            ans[i] = preSum[n] - 2* preSum[count] + 1LL*(2*count - n)*t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397970,
                "title": "beats-99-5-cpp",
                "content": "![image.png](https://assets.leetcode.com/users/images/6ded4ae6-5a06-4c84-9ace-011410eb0668_1681058354.3835206.png)\\n\\n\\n# Code\\n```\\n#include <cstdlib>\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int> &nums, vector<int> &queries)\\n    {\\n        vector<long long> ans;\\n        vector<long long> prefix(nums.size(), 0);\\n        // sort\\n        sort(nums.begin(), nums.end());\\n        prefix[0] = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            prefix[i] = prefix[i - 1] + nums[i];\\n        }\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            long long x = queries[i];\\n\\n            auto it = lower_bound(nums.begin(), nums.end(), x);\\n            long long index = it - nums.begin();\\n            // debug(index);\\n            // sum after index\\n            long long sum1 = prefix[nums.size() - 1] - prefix[(index-1)>0?index-1:0];\\n\\n            // sum before index\\n            long long sum2 = prefix[(index-1)>0?index-1:0];\\n            // debug(prefix);\\n            // debug(sum1, sum2);\\n            long long ans1 = sum1 - (nums.size()-index) * x + abs((index) * x - sum2);\\n            ans.push_back(ans1);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// 1 3 6 8 \\n\\n// 1 4 10 18\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <cstdlib>\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int> &nums, vector<int> &queries)\\n    {\\n        vector<long long> ans;\\n        vector<long long> prefix(nums.size(), 0);\\n        // sort\\n        sort(nums.begin(), nums.end());\\n        prefix[0] = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            prefix[i] = prefix[i - 1] + nums[i];\\n        }\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            long long x = queries[i];\\n\\n            auto it = lower_bound(nums.begin(), nums.end(), x);\\n            long long index = it - nums.begin();\\n            // debug(index);\\n            // sum after index\\n            long long sum1 = prefix[nums.size() - 1] - prefix[(index-1)>0?index-1:0];\\n\\n            // sum before index\\n            long long sum2 = prefix[(index-1)>0?index-1:0];\\n            // debug(prefix);\\n            // debug(sum1, sum2);\\n            long long ans1 = sum1 - (nums.size()-index) * x + abs((index) * x - sum2);\\n            ans.push_back(ans1);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// 1 3 6 8 \\n\\n// 1 4 10 18\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3397569,
                "title": "well-explained-c-soln",
                "content": "# Intuition\\nlets take the example \\n1  3 6 8 and querey [ 1, 5]\\nfor 5 in query array  our ans is  :\\n5-1 + 5-3 + 6-5 + 8-5   = 7\\nwe are substracting 5 from elements which are greater than 5 and we are substracting element if they are <= 5\\n5-1 + 5-3 + 6-5 + 8-5   this can be written as \\n2*5 - (1+3) // all smaller nd equal elements \\n(8+6) - 2*5 // all greater elements \\nwe can use binary search to find this index where all elements are smaller than or equal to 5 \\nthen we can use prefix sum to compute this.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) \\n    {   int n  = nums.size(); \\n        vector<long long > pre (n,0); \\n        vector<long long > res ; \\n        long long int sum = 0  ; \\n        sort(nums.begin(),nums.end());\\n\\n        \\n        for(int i = 0; i<n;i++)\\n        {\\n            pre[i] = nums[i] + sum ; \\n            sum = pre[i]; \\n        }\\n         \\n\\n        for(int i = 0; i<queries.size();i++)\\n        {\\n            long long int l = 0 , h = n-1 , mid , ans=-1;\\n            sum = 0; \\n            // findig the numbers which are smaller or less than \\n            while(l<=h)\\n            {\\n                mid = (l+h)/2;\\n                if(nums[mid]<=queries[i])\\n                {\\n                  ans = mid ;\\n                  l = mid +1; \\n                }\\n                else h = mid -1; \\n            } \\n            \\n            if(ans==-1)\\n            {\\n\\n            res.push_back(pre[n-1]-(long long)queries[i]*n);\\n            continue;\\n            }\\n            //elements which are to be decreased \\n            sum  = queries[i]*(ans+1) - pre[ans];\\n            //elements which are to be decreased \\n           sum +=  (pre[n-1] - pre[ans]) - queries[i]*(n-ans-1)  ;\\n            res.push_back(sum);\\n\\n\\n        }\\n\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) \\n    {   int n  = nums.size(); \\n        vector<long long > pre (n,0); \\n        vector<long long > res ; \\n        long long int sum = 0  ; \\n        sort(nums.begin(),nums.end());\\n\\n        \\n        for(int i = 0; i<n;i++)\\n        {\\n            pre[i] = nums[i] + sum ; \\n            sum = pre[i]; \\n        }\\n         \\n\\n        for(int i = 0; i<queries.size();i++)\\n        {\\n            long long int l = 0 , h = n-1 , mid , ans=-1;\\n            sum = 0; \\n            // findig the numbers which are smaller or less than \\n            while(l<=h)\\n            {\\n                mid = (l+h)/2;\\n                if(nums[mid]<=queries[i])\\n                {\\n                  ans = mid ;\\n                  l = mid +1; \\n                }\\n                else h = mid -1; \\n            } \\n            \\n            if(ans==-1)\\n            {\\n\\n            res.push_back(pre[n-1]-(long long)queries[i]*n);\\n            continue;\\n            }\\n            //elements which are to be decreased \\n            sum  = queries[i]*(ans+1) - pre[ans];\\n            //elements which are to be decreased \\n           sum +=  (pre[n-1] - pre[ans]) - queries[i]*(n-ans-1)  ;\\n            res.push_back(sum);\\n\\n\\n        }\\n\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395436,
                "title": "swift-prefix-sum-binary-search",
                "content": "**Prefix Sum + Binary Search (accepted answer)**\\n```\\nclass Solution {\\n    func minOperations(_ nums: [Int], _ queries: [Int]) -> [Int] {\\n        let nums = nums.sorted()\\n        let prefixSums = nums.reduce(into: [0]) { $0.append($1 + $0.last!) }\\n        \\n        return queries.map { q in \\n            var (left, right) = (0, nums.count)\\n            while left < right {\\n                let mid = (left+right)/2\\n                (left, right) = nums[mid] > q ? (left, mid) : (mid+1, right)\\n            }\\n            let totalAmountBelowAverage = q * left - prefixSums[left]\\n            let totalAmountAboveAverage = prefixSums.last! - prefixSums[left] - q * (nums.count - left) \\n            return totalAmountBelowAverage + totalAmountAboveAverage\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minOperations(_ nums: [Int], _ queries: [Int]) -> [Int] {\\n        let nums = nums.sorted()\\n        let prefixSums = nums.reduce(into: [0]) { $0.append($1 + $0.last!) }\\n        \\n        return queries.map { q in \\n            var (left, right) = (0, nums.count)\\n            while left < right {\\n                let mid = (left+right)/2\\n                (left, right) = nums[mid] > q ? (left, mid) : (mid+1, right)\\n            }\\n            let totalAmountBelowAverage = q * left - prefixSums[left]\\n            let totalAmountAboveAverage = prefixSums.last! - prefixSums[left] - q * (nums.count - left) \\n            return totalAmountBelowAverage + totalAmountAboveAverage\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391458,
                "title": "python-code-using-binary-search-prefix-sum-and-suffix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to think in terms of subarray sum, as the problem is making all the array elements equal to given query.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order to calculate the subarray sum we can use of the concepts prefix sum and suffix sum. And we also need to find out floor of the given element in the query. By using the floor index, we can make the rest of the array elements equal to query.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor sorting the nums array: NlogN\\nFor calculating prefix_sum and suffix_sum: N + N\\nFor iterating through the queries array and cacluating the floor index: (Q * logN)\\nOverall: NlogN + N + N + Q * logN\\nWorst case time complexity: O(N*logN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIn this code, I am using extra space to store the prefix sum and suffix sum of nums array. N + N\\nWorst case space complexity: O(N)\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        def floor(x, arr):\\n            \\'\\'\\'\\n            this is  binary search function which returns the floor of a given number x in the array\\n            \\'\\'\\'\\n            lo = 0\\n            hi = len(arr) - 1\\n            ans = -1\\n            while lo <= hi:\\n                mid = (lo + hi)//2\\n                if arr[mid] <= x:\\n                    ans = mid\\n                    lo = mid + 1\\n                else:\\n                    hi = mid -1\\n            return ans\\n        \\n        nums.sort()\\n        n = len(nums)\\n        prefix_sum = [0] * n\\n        prefix_sum[0] = nums[0]\\n        for i in range(1, n):\\n            prefix_sum[i] = prefix_sum[i-1] + nums[i]\\n            \\n        suffix_sum = [0] * n\\n        suffix_sum[n-1] = nums[n-1]\\n        for i in range(n-2, -1 , -1):\\n            suffix_sum[i] = suffix_sum[i+1] + nums[i]\\n        \\n        ans = []\\n        # iterate through queries\\n        for query in queries:\\n            result = 0\\n            floor_index = floor(query, nums)\\n            # print(floor_index)\\n            if floor_index == -1 or n == 1:\\n                sum_array = prefix_sum[n-1]\\n                result += abs(sum_array - (query * n))\\n            else:\\n                result += abs(query - nums[floor_index])\\n                if floor_index == 0:\\n                    right_sub_sum = suffix_sum[floor_index + 1]\\n                    result += abs(right_sub_sum - ((n - floor_index - 1) * query))\\n                elif floor_index == n - 1:\\n                    left_sub_sum = prefix_sum[floor_index - 1]\\n                    result += abs(left_sub_sum - (floor_index * query))\\n                else:\\n                    left_sub_sum = prefix_sum[floor_index - 1]\\n                    result += abs(left_sub_sum - (floor_index * query))\\n                    right_sub_sum = suffix_sum[floor_index + 1]\\n                    result += abs(right_sub_sum - ((n - floor_index - 1) * query))\\n            ans.append(result)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        def floor(x, arr):\\n            \\'\\'\\'\\n            this is  binary search function which returns the floor of a given number x in the array\\n            \\'\\'\\'\\n            lo = 0\\n            hi = len(arr) - 1\\n            ans = -1\\n            while lo <= hi:\\n                mid = (lo + hi)//2\\n                if arr[mid] <= x:\\n                    ans = mid\\n                    lo = mid + 1\\n                else:\\n                    hi = mid -1\\n            return ans\\n        \\n        nums.sort()\\n        n = len(nums)\\n        prefix_sum = [0] * n\\n        prefix_sum[0] = nums[0]\\n        for i in range(1, n):\\n            prefix_sum[i] = prefix_sum[i-1] + nums[i]\\n            \\n        suffix_sum = [0] * n\\n        suffix_sum[n-1] = nums[n-1]\\n        for i in range(n-2, -1 , -1):\\n            suffix_sum[i] = suffix_sum[i+1] + nums[i]\\n        \\n        ans = []\\n        # iterate through queries\\n        for query in queries:\\n            result = 0\\n            floor_index = floor(query, nums)\\n            # print(floor_index)\\n            if floor_index == -1 or n == 1:\\n                sum_array = prefix_sum[n-1]\\n                result += abs(sum_array - (query * n))\\n            else:\\n                result += abs(query - nums[floor_index])\\n                if floor_index == 0:\\n                    right_sub_sum = suffix_sum[floor_index + 1]\\n                    result += abs(right_sub_sum - ((n - floor_index - 1) * query))\\n                elif floor_index == n - 1:\\n                    left_sub_sum = prefix_sum[floor_index - 1]\\n                    result += abs(left_sub_sum - (floor_index * query))\\n                else:\\n                    left_sub_sum = prefix_sum[floor_index - 1]\\n                    result += abs(left_sub_sum - (floor_index * query))\\n                    right_sub_sum = suffix_sum[floor_index + 1]\\n                    result += abs(right_sub_sum - ((n - floor_index - 1) * query))\\n            ans.append(result)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388077,
                "title": "sorting-prefix-sums-binary-search",
                "content": "The idea is to sort the array\\nafter sorting the array, for a given query query[i] we find the upper bound in the array\\nThen we compute this  [0,  indexjustbefore(upper_bound)] and  [indexjustbefore(upperbound)+1, endofarray]\\nafter we do this , we know that elements of the first array are lesser than or equal to query[i] and elements of the second array are greater than query[i].\\n\\nThen we do the maths.\\n\\nwe substract the sum first array from  query[i]*length_of_first array   and subtract query[i]*length_of_second_array from sum of the second array\\nthe sum of this two values is the answer \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long compute(vector<long long>&prefix, int l, int r) {\\n        \\n        if(r < 0 || l == prefix.size())return 0;\\n        \\n        if(l == 0){\\n            return prefix[r];\\n        }\\n        \\n        return prefix[r]-prefix[l-1];\\n        \\n    }\\n    \\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        vector<long long>prefix(nums.size()), answer;\\n        prefix[0]  = nums[0];\\n        \\n        \\n        for(int i = 1; i < nums.size(); i++){\\n             prefix[i] = prefix[i-1] + nums[i];\\n        }\\n        \\n        \\n        for(int i = 0; i < queries.size(); i++){\\n            \\n                int k = prev(upper_bound(nums.begin(), nums.end(), queries[i]))-nums.begin();\\n                \\n                long long left = compute(prefix, 0, k), right = compute(prefix, k+1, nums.size()-1);\\n            \\n                left = (k-0+1ll)*queries[i]-left;\\n                right = right - (queries[i]*(nums.size()-k-1));\\n                \\n                answer.push_back(left + right);\\n                \\n        }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long compute(vector<long long>&prefix, int l, int r) {\\n        \\n        if(r < 0 || l == prefix.size())return 0;\\n        \\n        if(l == 0){\\n            return prefix[r];\\n        }\\n        \\n        return prefix[r]-prefix[l-1];\\n        \\n    }\\n    \\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        vector<long long>prefix(nums.size()), answer;\\n        prefix[0]  = nums[0];\\n        \\n        \\n        for(int i = 1; i < nums.size(); i++){\\n             prefix[i] = prefix[i-1] + nums[i];\\n        }\\n        \\n        \\n        for(int i = 0; i < queries.size(); i++){\\n            \\n                int k = prev(upper_bound(nums.begin(), nums.end(), queries[i]))-nums.begin();\\n                \\n                long long left = compute(prefix, 0, k), right = compute(prefix, k+1, nums.size()-1);\\n            \\n                left = (k-0+1ll)*queries[i]-left;\\n                right = right - (queries[i]*(nums.size()-k-1));\\n                \\n                answer.push_back(left + right);\\n                \\n        }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381157,
                "title": "c-prefix-sum-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can optimize the process by iterating through the array of queries and, for each target number, dividing the nums array into two parts: one containing elements smaller than the target number, and the other containing elements equal to or larger than the target number.\\n\\n Sorting the array allows us to efficiently apply binary search to find the index of the first element that is bigger than the target number. Let x represent the number of elements in the bigger part of the array, while (n-x) represents the number of elements in the smaller part. The target sum of the subarray for the bigger part of the array can be calculated as x * targetnumber, while the actual sum of the subarray for the bigger part would be prefix[index..n-1]. Similarly, the actual sum of the subarray for the smaller part would be prefix[0..index-1]. By subtracting the sum of the smaller part from the sum of the bigger part, we can obtain the answer for the current query. This optimized approach avoids unnecessary sorting and leverages binary search for efficient calculations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn) + (m*longn) = O(max(n,m)logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        int m = queries.size();\\n        vector<long long> res;\\n        sort(nums.begin(), nums.end());\\n        vector<long long> prefix(n,0);\\n        prefix[0] = nums[0];\\n\\n        for(int i=1; i<n; i++){\\n            prefix[i] = prefix[i-1] + nums[i];\\n        }\\n\\n        for(int target:queries){\\n            /*\\n            [ smaller ][equal & bigger ]\\n            */\\n            long long currSum = 0;\\n            //find bigger subarray\\n            auto iter = lower_bound(nums.begin(), nums.end(), target);\\n            long long bigIndex = iter - nums.begin();\\n            long long targetSumA = (n - bigIndex)*target;\\n            long long prefixSumA = bigIndex==0?prefix[n-1]:prefix[n-1]-prefix[bigIndex-1];\\n            currSum+= prefixSumA - targetSumA;\\n            //find smaller subarray\\n            if(iter!=nums.begin()){\\n                //[0.....prev(iter)]\\n                long long smallIndex = prev(iter)-nums.begin();\\n                long long targetSumB = (smallIndex+1)*target;\\n                long long prefixSumB = prefix[smallIndex];\\n                currSum+=targetSumB-prefixSumB;\\n            }\\n\\n            res.push_back(currSum);\\n        }        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size();\\n        int m = queries.size();\\n        vector<long long> res;\\n        sort(nums.begin(), nums.end());\\n        vector<long long> prefix(n,0);\\n        prefix[0] = nums[0];\\n\\n        for(int i=1; i<n; i++){\\n            prefix[i] = prefix[i-1] + nums[i];\\n        }\\n\\n        for(int target:queries){\\n            /*\\n            [ smaller ][equal & bigger ]\\n            */\\n            long long currSum = 0;\\n            //find bigger subarray\\n            auto iter = lower_bound(nums.begin(), nums.end(), target);\\n            long long bigIndex = iter - nums.begin();\\n            long long targetSumA = (n - bigIndex)*target;\\n            long long prefixSumA = bigIndex==0?prefix[n-1]:prefix[n-1]-prefix[bigIndex-1];\\n            currSum+= prefixSumA - targetSumA;\\n            //find smaller subarray\\n            if(iter!=nums.begin()){\\n                //[0.....prev(iter)]\\n                long long smallIndex = prev(iter)-nums.begin();\\n                long long targetSumB = (smallIndex+1)*target;\\n                long long prefixSumB = prefix[smallIndex];\\n                currSum+=targetSumB-prefixSumB;\\n            }\\n\\n            res.push_back(currSum);\\n        }        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374748,
                "title": "lower-bound-with-formula-derivation",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector < long long > minOperations(vector<int> &nums, vector<int> &queries)\\n        {\\n            long long n = nums.size(), sum = 0;\\n\\n            sort(nums.begin(), nums.end());\\n            vector < long long > prefix;\\n            for (auto it: nums)\\n            {\\n                sum += it;\\n                prefix.push_back(sum);\\n            }\\n\\n            vector < long long > ans;\\n\\n            for (auto it: queries)\\n            {\\n\\n                int pos = lower_bound(nums.begin(), nums.end(), it) - nums.begin();\\n              \\n\\n                if (pos == n || pos == 0)\\n                {\\n                    ans.push_back(abs(it *n - prefix[n - 1]));\\n                }\\n                else\\n                {\\n                   \\t// long long   left = it *pos - prefix[pos - 1];\\n\\n                   \\t// long long  right = prefix[n - 1] - prefix[pos - 1] - it *(n - pos);\\n                   \\t// ans.push_back(left + right);\\n                    \\n                    // To prevent from run time error solve left+right to get below formula\\n                    long long cal = it *(2 *pos - n) + prefix[n - 1] - 2 *prefix[pos - 1];\\n                    ans.push_back(cal);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector < long long > minOperations(vector<int> &nums, vector<int> &queries)\\n        {\\n            long long n = nums.size(), sum = 0;\\n\\n            sort(nums.begin(), nums.end());\\n            vector < long long > prefix;\\n            for (auto it: nums)\\n            {\\n                sum += it;\\n                prefix.push_back(sum);\\n            }\\n\\n            vector < long long > ans;\\n\\n            for (auto it: queries)\\n            {\\n\\n                int pos = lower_bound(nums.begin(), nums.end(), it) - nums.begin();\\n              \\n\\n                if (pos == n || pos == 0)\\n                {\\n                    ans.push_back(abs(it *n - prefix[n - 1]));\\n                }\\n                else\\n                {\\n                   \\t// long long   left = it *pos - prefix[pos - 1];\\n\\n                   \\t// long long  right = prefix[n - 1] - prefix[pos - 1] - it *(n - pos);\\n                   \\t// ans.push_back(left + right);\\n                    \\n                    // To prevent from run time error solve left+right to get below formula\\n                    long long cal = it *(2 *pos - n) + prefix[n - 1] - 2 *prefix[pos - 1];\\n                    ans.push_back(cal);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372056,
                "title": "python-bs-prefixsums",
                "content": "This is a tricky problem (or not???). I\\'m stuck :( (needed a hit #3 about optimization)\\n\\nHow to figure out the solution???\\nDry run a few examples (what I did later) and watch what you\\'re doing:\\n[3,1,6,8], q = 1, 5, 9\\nwhy 1, 5, and 9? Because these are the **edge cases**!\\n\\n1. How many operations need be done **to increase**?\\n2. How many operations need be done **to decrease**?\\n3. to increase + to decrease = total ;)\\n4. At this moment you realize that you need to split the array in 2 parts, but how?\\n5. Criterion: elements to be **increased** to `q`, elements to be **decreased** to `q`\\n6. how to group the elements that are lower than `q` and higher then `q`? -> sort\\n7. how to calc required operations to **increase** to `q` and to **decrease** to `q`?\\n8. **decrease** is `num - q`, **increase** is `q - num` (e.g. 5-3 + 5-1 to **increase**, 6-5 + 8-5 to **decrease**)\\n9. Now we know what we do\\n10. Optimize: 5-3 + 5-1 to **increase**, 6-5 + 8-5 to **decrease**:\\n10.1. increase: 5-3 + 5-1 => 5x2 - (3+1) => q\\\\*num_of_elements_less_than_q + prefix_sum_of_the_elements\\n10.2. decrease: 6-5 + 8-5 => (6+8) - 5x2 => prefix_sum_of_the_elements - q\\\\*num_of_elements_greater_than_q\\n10.3. How to find the split point quickly? O(1) or O(logn) ? BS on sorted array: you\\'ll get num of smaller and num of greater than q. Sums can be calced in O(1) via prefix_sumx with 0 first elements.\\n11. return sum of number of increasing and decreasing operations. \\n---\\n\\n1. sort nums\\n2. split nums into 2 parts: lower than `q` and higher. This is done in order to calc steps needed to 1) increase lower elements to `q` and 2) decrease higher elements to `q`. Find via lowerbound BS.\\n3. When found calc required operations this way:\\n- `lower-to-q = q*i - ps[i]` for elements < `q`\\n- `higher-to-q = ps[-1] - ps[i] - q*(N - i)` for elements > `q`\\n4. Add `lower-to-q` and `higher-to-q`\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        \"\"\"\\n           *\\n           0   1   2   3\\n           1 + 3 + 6 + 8, q = 1, n = 4\\n        ps 0   1   4  10  18\\n         | 1 + 1 + 1 + 1\\n           1x0-0 + 18-1x4 -> same range [0,n], q*i - ps[i] + ps[-1] - ps[i] - q*(n - i)\\n         \\n                   *\\n           0   1   2   3\\n           1 + 3   6 + 8, q = 5, n = 4\\n        ps 0   1   4  10  18\\n           5 + 5 | 5 + 5\\n           5x2-4 + 14-5x2 -> same range [0,n], q*i - ps[i] + ps[-1] - ps[i] - q*(n - i)\\n           \\n                          *\\n           0   1   2   3  4\\n           1 + 3   6 + 8, q = 9, n = 4\\n        ps 0   1   4  10  18\\n           9 + 9 + 9 + 9 |\\n           9x4-18 + 0-9x0 -> same range [0,n], q*i - ps[i] + ps[-1] - ps[i] - q*(n - i)\\n        \"\"\"\\n        \\n        N = len(nums)\\n        nums.sort()\\n        ps = [0]\\n        for num in nums:\\n            ps.append(ps[-1] + num)\\n        \\n        res = []\\n        for q in queries:\\n            i = bisect_left(nums, q)\\n            res.append(q * i - ps[i] + ps[-1] - ps[i] - q * (N - i))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        \"\"\"\\n           *\\n           0   1   2   3\\n           1 + 3 + 6 + 8, q = 1, n = 4\\n        ps 0   1   4  10  18\\n         | 1 + 1 + 1 + 1\\n           1x0-0 + 18-1x4 -> same range [0,n], q*i - ps[i] + ps[-1] - ps[i] - q*(n - i)\\n         \\n                   *\\n           0   1   2   3\\n           1 + 3   6 + 8, q = 5, n = 4\\n        ps 0   1   4  10  18\\n           5 + 5 | 5 + 5\\n           5x2-4 + 14-5x2 -> same range [0,n], q*i - ps[i] + ps[-1] - ps[i] - q*(n - i)\\n           \\n                          *\\n           0   1   2   3  4\\n           1 + 3   6 + 8, q = 9, n = 4\\n        ps 0   1   4  10  18\\n           9 + 9 + 9 + 9 |\\n           9x4-18 + 0-9x0 -> same range [0,n], q*i - ps[i] + ps[-1] - ps[i] - q*(n - i)\\n        \"\"\"\\n        \\n        N = len(nums)\\n        nums.sort()\\n        ps = [0]\\n        for num in nums:\\n            ps.append(ps[-1] + num)\\n        \\n        res = []\\n        for q in queries:\\n            i = bisect_left(nums, q)\\n            res.append(q * i - ps[i] + ps[-1] - ps[i] - q * (N - i))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369955,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<long long >ans,v;\\n        long long sum=0,sum1=0;\\n        for(auto x:nums){sum+=x;v.push_back(sum);}\\n        v.push_back(0);\\n        for(long long  x:queries){\\n         long long  y=lower_bound(nums.begin(),nums.end(),x)-nums.begin();\\n        if(y==0)sum1=0;\\n        else sum1=v[y-1];\\n         ans.push_back(2*x*y+sum-2*sum1-x*n);\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<long long >ans,v;\\n        long long sum=0,sum1=0;\\n        for(auto x:nums){sum+=x;v.push_back(sum);}\\n        v.push_back(0);\\n        for(long long  x:queries){\\n         long long  y=lower_bound(nums.begin(),nums.end(),x)-nums.begin();\\n        if(y==0)sum1=0;\\n        else sum1=v[y-1];\\n         ans.push_back(2*x*y+sum-2*sum1-x*n);\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369924,
                "title": "explain-me-this-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long> pre(nums.size(),0);\\n        pre[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            pre[i] = pre[i-1]+nums[i];\\n        }\\n        vector<long long> v;\\n        for(int i=0;i<q.size();i++){\\n            int l = 0;\\n            int h = nums.size()-1;\\n            int ans = 0;\\n            int mid;\\n            while(l<=h){\\n                 mid = l + (h-l)/2;\\n                if(nums[mid] <= q[i]){\\n                    ans = mid;\\n                    l = mid+1;\\n                }\\n                else{\\n                    h = mid-1;\\n                }\\n            }\\n            long long x = (ans+1);\\n            x *= q[i];\\n            long long a = abs(x - pre[ans]);\\n            long long c = pre[pre.size()-1]-pre[ans]; \\n            long long d = nums.size()*q[i];\\n            long long y = (ans+1);\\n            y *=q[i];\\n            d -= y;\\n            long long b  = abs(d-c);\\n            v.push_back(a+b);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long> pre(nums.size(),0);\\n        pre[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            pre[i] = pre[i-1]+nums[i];\\n        }\\n        vector<long long> v;\\n        for(int i=0;i<q.size();i++){\\n            int l = 0;\\n            int h = nums.size()-1;\\n            int ans = 0;\\n            int mid;\\n            while(l<=h){\\n                 mid = l + (h-l)/2;\\n                if(nums[mid] <= q[i]){\\n                    ans = mid;\\n                    l = mid+1;\\n                }\\n                else{\\n                    h = mid-1;\\n                }\\n            }\\n            long long x = (ans+1);\\n            x *= q[i];\\n            long long a = abs(x - pre[ans]);\\n            long long c = pre[pre.size()-1]-pre[ans]; \\n            long long d = nums.size()*q[i];\\n            long long y = (ans+1);\\n            y *=q[i];\\n            d -= y;\\n            long long b  = abs(d-c);\\n            v.push_back(a+b);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369067,
                "title": "binary-search-prefix-sum-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int search(int[] nums,int target){\\n        int n = nums.length;\\n        if(target>nums[n-1]) return n;\\n        else if(target<nums[0]) return -1;\\n        int l=0,r=n-1;\\n        int mid = (n-1)/2;\\n        while(l<=r){\\n            if(nums[mid]==target) return mid;\\n            else if(mid>0 && nums[mid-1]<=target && nums[mid]>=target) return mid-1;\\n            else if(mid<n-1 && nums[mid+1]>=target && nums[mid]<=target) return mid;\\n            else if(nums[mid]>target) r=mid-1;\\n            else l=mid+1;\\n            mid = l+(r-l)/2;\\n        }\\n        return -1;\\n    }\\n    \\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        List<Long> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        prefix[0]=(long)nums[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i] = prefix[i-1]+(1L*nums[i]);\\n        }\\n        for(int i=0;i<queries.length;i++){\\n            int x = search(nums,queries[i]);\\n            if(x==n){\\n                list.add((1L*n*queries[i])-prefix[n-1]);\\n            }\\n            else if(x==-1){\\n                list.add(prefix[n-1]-(1L*n*queries[i]));\\n            }\\n            else{\\n                \\n                list.add(((1L*(x+1)*queries[i])-prefix[x])+((prefix[n-1]-prefix[x])-(1L*(n-x-1)*(queries[i]))));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums,int target){\\n        int n = nums.length;\\n        if(target>nums[n-1]) return n;\\n        else if(target<nums[0]) return -1;\\n        int l=0,r=n-1;\\n        int mid = (n-1)/2;\\n        while(l<=r){\\n            if(nums[mid]==target) return mid;\\n            else if(mid>0 && nums[mid-1]<=target && nums[mid]>=target) return mid-1;\\n            else if(mid<n-1 && nums[mid+1]>=target && nums[mid]<=target) return mid;\\n            else if(nums[mid]>target) r=mid-1;\\n            else l=mid+1;\\n            mid = l+(r-l)/2;\\n        }\\n        return -1;\\n    }\\n    \\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        List<Long> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        prefix[0]=(long)nums[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i] = prefix[i-1]+(1L*nums[i]);\\n        }\\n        for(int i=0;i<queries.length;i++){\\n            int x = search(nums,queries[i]);\\n            if(x==n){\\n                list.add((1L*n*queries[i])-prefix[n-1]);\\n            }\\n            else if(x==-1){\\n                list.add(prefix[n-1]-(1L*n*queries[i]));\\n            }\\n            else{\\n                \\n                list.add(((1L*(x+1)*queries[i])-prefix[x])+((prefix[n-1]-prefix[x])-(1L*(n-x-1)*(queries[i]))));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367758,
                "title": "simple-explanation-java-prefixsum-binarysearch",
                "content": "# Intuition\\nFor all the smaller values, to reach to x, we need to increment them. That increment value across all those element is: `(sum of all smaller element) - (x) * totalSmallerElements `\\n\\nFor all the bigger values than x, we need to decrement them to make it equal to x. Total number of decrements will be: `(sum of all bigger elements) - (x) * totalBiggerElements `\\n\\nWe perform above operation for each element of `queries` array. \\n# Approach\\n\\nTo compute sum of smaller and bigger elements, we use prefixSum.\\nTo find smallestElementThanX - we use binary search. \\n\\n# Complexity\\nTime complexity: O((n + m) * log(n))\\n\\nSpace complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        List<Long> ans = new ArrayList<>();\\n        int total = nums.length;\\n        Arrays.sort(nums);\\n        long[] prefixSum = new long[nums.length+1];\\n\\n        for(int i  = 1; i <= nums.length; i++) {\\n            prefixSum[i] += prefixSum[i-1] + nums[i-1];\\n        }\\n\\n        for(int i : queries) {\\n            int index = findFirstSmallestNumberInSortedArray(nums, i);\\n            // We devide the sorted nums into 2 parts. Left part smaller than i, right part smaller than i. \\n            // division index is index. \\n            // For all the smaller values, to reach to i, we need to increment them. That increment value across all those element is:\\n            // (sum of all smaller element) - (i) * totalSmallerElements \\n            // For all the bigger values than i, we need to decrement them to make it equalto i. Total number of decrements will be: \\n            // (sum of all bigger elements) - (i) * totalBiggerElements \\n\\n            // To compute sum of smaller and bigger elements, we use prefixSum on sorted array. \\n            Long totalSmallerElements = index*1L;\\n            Long totalBiggerElements = total*1L - index*1L;\\n            Long smallerElementsSum= totalSmallerElements * i*1L - prefixSum[index]*1L;\\n            Long biggerElementsSum = prefixSum[total]*1L - prefixSum[index]*1L - totalBiggerElements * i * 1L;\\n            Long val =  smallerElementsSum + biggerElementsSum;\\n            ans.add(val);\\n        }\\n        return ans;\\n    }\\n\\n\\n    // Finds the index of an element which is smaller than val. \\n    // That way we can divide the given sorted array into 2 parts. \\n    private int findFirstSmallestNumberInSortedArray(int[] nums, int val) {\\n        int left = 0;\\n        int right = nums.length;\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] < val) left = mid+1;\\n            else right = mid;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        List<Long> ans = new ArrayList<>();\\n        int total = nums.length;\\n        Arrays.sort(nums);\\n        long[] prefixSum = new long[nums.length+1];\\n\\n        for(int i  = 1; i <= nums.length; i++) {\\n            prefixSum[i] += prefixSum[i-1] + nums[i-1];\\n        }\\n\\n        for(int i : queries) {\\n            int index = findFirstSmallestNumberInSortedArray(nums, i);\\n            // We devide the sorted nums into 2 parts. Left part smaller than i, right part smaller than i. \\n            // division index is index. \\n            // For all the smaller values, to reach to i, we need to increment them. That increment value across all those element is:\\n            // (sum of all smaller element) - (i) * totalSmallerElements \\n            // For all the bigger values than i, we need to decrement them to make it equalto i. Total number of decrements will be: \\n            // (sum of all bigger elements) - (i) * totalBiggerElements \\n\\n            // To compute sum of smaller and bigger elements, we use prefixSum on sorted array. \\n            Long totalSmallerElements = index*1L;\\n            Long totalBiggerElements = total*1L - index*1L;\\n            Long smallerElementsSum= totalSmallerElements * i*1L - prefixSum[index]*1L;\\n            Long biggerElementsSum = prefixSum[total]*1L - prefixSum[index]*1L - totalBiggerElements * i * 1L;\\n            Long val =  smallerElementsSum + biggerElementsSum;\\n            ans.add(val);\\n        }\\n        return ans;\\n    }\\n\\n\\n    // Finds the index of an element which is smaller than val. \\n    // That way we can divide the given sorted array into 2 parts. \\n    private int findFirstSmallestNumberInSortedArray(int[] nums, int val) {\\n        int left = 0;\\n        int right = nums.length;\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] < val) left = mid+1;\\n            else right = mid;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367668,
                "title": "functional-solution",
                "content": "# Intuition\\nThe intuition is that, given a query `q`, if either all elements in `nums` are greater than or equal to `q`, or less than or equal to `q`, then the answer is `average(nums) - q`\\n\\n# Approach\\nFunctional.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom itertools import accumulate\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        lscan = list(accumulate(nums))\\n        rscan = list(accumulate(nums[::-1]))[::-1]\\n        \\n        def f(q):\\n            i = bisect_left(nums, q)\\n            left = lscan[i-1] if i > 0 else 0\\n            right = rscan[i] if i < len(rscan) else 0\\n            return abs(q*i - left) + abs(right - q*(len(rscan)-i))\\n            \\n        return [f(q) for q in queries]      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import accumulate\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        lscan = list(accumulate(nums))\\n        rscan = list(accumulate(nums[::-1]))[::-1]\\n        \\n        def f(q):\\n            i = bisect_left(nums, q)\\n            left = lscan[i-1] if i > 0 else 0\\n            right = rscan[i] if i < len(rscan) else 0\\n            return abs(q*i - left) + abs(right - q*(len(rscan)-i))\\n            \\n        return [f(q) for q in queries]      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367462,
                "title": "easy-c-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search and prefix sum\\n\\n# Complexity\\n- Time complexity: O(n.log(n)) + m.log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>pre(n);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n\\n        vector<long long>ans(queries.size());\\n        for(int i=0;i<queries.size();i++){\\n            long long x=queries[i];\\n            int ind=lower_bound(nums.begin(),nums.end(),x)-nums.begin();\\n            long long l=0,r=0;\\n\\n            if(ind>0) l=x*(ind)-pre[ind-1];\\n            if(ind>0) r=(pre[n-1]-pre[ind-1])-x*(n-ind);\\n            else r=pre[n-1]-x*(n-ind);\\n            ans[i]=l+r;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>pre(n);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n\\n        vector<long long>ans(queries.size());\\n        for(int i=0;i<queries.size();i++){\\n            long long x=queries[i];\\n            int ind=lower_bound(nums.begin(),nums.end(),x)-nums.begin();\\n            long long l=0,r=0;\\n\\n            if(ind>0) l=x*(ind)-pre[ind-1];\\n            if(ind>0) r=(pre[n-1]-pre[ind-1])-x*(n-ind);\\n            else r=pre[n-1]-x*(n-ind);\\n            ans[i]=l+r;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366264,
                "title": "implemented-using-sorting-binary-search-and-prefixsum-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(N log(N)+q log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] q) {\\n                Arrays.sort(nums);\\n        long  []pf=new long [nums.length];\\n        List<Long> list=new ArrayList<>();\\n        pf[0]=nums[0];\\n        int mod=1000000007;\\n        for (int i = 1; i < pf.length; i++) {\\n            pf[i]=(pf[i-1]+nums[i]);\\n        }\\n        int n=nums.length;\\n        for (int i = 0; i < q.length; i++) {\\n           long  target=q[i];\\n            int index=search(nums, target);\\n          \\n            if(index<=0){\\n                list.add(pf[nums.length-1]-(target*nums.length));\\n            }\\n            else{\\n               long  ans=(target*index)-pf[index-1];\\n               ans=(ans+(pf[n-1]-pf[index-1])-(target*(n-index)));\\n               list.add(ans);\\n            }  \\n            \\n        }\\n        return list;\\n    }\\n    public int  search(int []arr,long  target) {\\n        int start=0;\\n        int end=arr.length;\\n        int ans=-1;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if(arr[mid]<target){\\n                start=mid+1;\\n            }else if(arr[mid]>=target){\\n                ans=mid;\\n                end=mid;\\n            }\\n            \\n        }\\n        if(ans==-1){\\n            ans=arr.length;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] q) {\\n                Arrays.sort(nums);\\n        long  []pf=new long [nums.length];\\n        List<Long> list=new ArrayList<>();\\n        pf[0]=nums[0];\\n        int mod=1000000007;\\n        for (int i = 1; i < pf.length; i++) {\\n            pf[i]=(pf[i-1]+nums[i]);\\n        }\\n        int n=nums.length;\\n        for (int i = 0; i < q.length; i++) {\\n           long  target=q[i];\\n            int index=search(nums, target);\\n          \\n            if(index<=0){\\n                list.add(pf[nums.length-1]-(target*nums.length));\\n            }\\n            else{\\n               long  ans=(target*index)-pf[index-1];\\n               ans=(ans+(pf[n-1]-pf[index-1])-(target*(n-index)));\\n               list.add(ans);\\n            }  \\n            \\n        }\\n        return list;\\n    }\\n    public int  search(int []arr,long  target) {\\n        int start=0;\\n        int end=arr.length;\\n        int ans=-1;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if(arr[mid]<target){\\n                start=mid+1;\\n            }else if(arr[mid]>=target){\\n                ans=mid;\\n                end=mid;\\n            }\\n            \\n        }\\n        if(ans==-1){\\n            ans=arr.length;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365573,
                "title": "python-easy-solution-sorting-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        \\n        n = len(nums)\\n        nums.sort()\\n        acc = [0] + list(accumulate(nums,operator.add))\\n        ans = []\\n        \\n        for q in queries:\\n            pos = bisect_left(nums,q)\\n            ans.append( (q*(pos) - acc[pos]) + ((acc[-1]-acc[pos]) - (n-pos)*q) )\\n    \\n        return ans\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        \\n        n = len(nums)\\n        nums.sort()\\n        acc = [0] + list(accumulate(nums,operator.add))\\n        ans = []\\n        \\n        for q in queries:\\n            pos = bisect_left(nums,q)\\n            ans.append( (q*(pos) - acc[pos]) + ((acc[-1]-acc[pos]) - (n-pos)*q) )\\n    \\n        return ans\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364951,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def minOperations(nums: Array[Int], queries: Array[Int]): List[Long] = {\\n      def search(nums: Array[Int], target: Int): Int = {\\n        @scala.annotation.tailrec\\n        def helper(left: Int, right: Int): Int = {\\n          val mid = left + (right - left) / 2\\n          mid match {\\n            case _ if left > right => left\\n            case mid if (nums(mid) == target) => mid\\n            case mid if (nums(mid) < target) => helper(mid + 1, right)\\n            case _ => helper(left, mid - 1)\\n          }\\n        }\\n        helper(0, nums.length - 1)\\n      }\\n      val sortedNums = nums.sorted\\n      val n = nums.length\\n      val indexes = queries.map(search(sortedNums, _))\\n      val prefixSum = sortedNums.scanLeft(0L)(_ + _)\\n      indexes.indices.map(i =>  1L * queries(i) * indexes(i) - prefixSum(indexes(i)) + prefixSum.last - prefixSum(indexes(i)) - 1L * queries(i) * (n - indexes(i))).toList\\n  }\\n}\\n```\\nor\\n\\n```\\n  def minOperations(nums: Array[Int], queries: Array[Int]): List[Long] = {\\n    import scala.collection.Searching.search\\n    val sortedNums = nums.sorted\\n    val pSum = sortedNums.scanLeft(0L)(_ + _)\\n    queries.map { q =>\\n      val i = sortedNums.search(q).insertionPoint\\n      q.toLong * i - pSum(i) + pSum.last - pSum(i) - q.toLong * (sortedNums.length - i)\\n    }.toList\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def minOperations(nums: Array[Int], queries: Array[Int]): List[Long] = {\\n      def search(nums: Array[Int], target: Int): Int = {\\n        @scala.annotation.tailrec\\n        def helper(left: Int, right: Int): Int = {\\n          val mid = left + (right - left) / 2\\n          mid match {\\n            case _ if left > right => left\\n            case mid if (nums(mid) == target) => mid\\n            case mid if (nums(mid) < target) => helper(mid + 1, right)\\n            case _ => helper(left, mid - 1)\\n          }\\n        }\\n        helper(0, nums.length - 1)\\n      }\\n      val sortedNums = nums.sorted\\n      val n = nums.length\\n      val indexes = queries.map(search(sortedNums, _))\\n      val prefixSum = sortedNums.scanLeft(0L)(_ + _)\\n      indexes.indices.map(i =>  1L * queries(i) * indexes(i) - prefixSum(indexes(i)) + prefixSum.last - prefixSum(indexes(i)) - 1L * queries(i) * (n - indexes(i))).toList\\n  }\\n}\\n```\n```\\n  def minOperations(nums: Array[Int], queries: Array[Int]): List[Long] = {\\n    import scala.collection.Searching.search\\n    val sortedNums = nums.sorted\\n    val pSum = sortedNums.scanLeft(0L)(_ + _)\\n    queries.map { q =>\\n      val i = sortedNums.search(q).insertionPoint\\n      q.toLong * i - pSum(i) + pSum.last - pSum(i) - q.toLong * (sortedNums.length - i)\\n    }.toList\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3363297,
                "title": "simple-prefixsum-adhoc-algorithm-specially-designed-for-begineer-s-easy-to-understand",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        ll prefix[n];\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1] + nums[i];\\n        \\n        vector<ll>ans;\\n        for(auto q: queries){\\n            ll temp=0;\\n            int idx = lower_bound(nums.begin(),nums.end(),q) - nums.begin(); // this will point the index where value>=q;\\n            // So for all the elements from index[0,idx-1] we will assume numbers are less than q;\\n           if(idx-1>=0){\\n                ll elementOnLeft = idx;\\n                ll prefixSum = prefix[idx-1];\\n                temp+=q*elementOnLeft - prefixSum;\\n           }\\n           if(idx<n){\\n               // here are the values that are >=q;\\n               ll elementOnRight = n-idx;\\n               ll sufixSum = prefix[n-1] - (idx-1>=0?prefix[idx-1]:0);\\n               temp+=sufixSum - q*elementOnRight;\\n           }\\n            \\n          ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        ll prefix[n];\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1] + nums[i];\\n        \\n        vector<ll>ans;\\n        for(auto q: queries){\\n            ll temp=0;\\n            int idx = lower_bound(nums.begin(),nums.end(),q) - nums.begin(); // this will point the index where value>=q;\\n            // So for all the elements from index[0,idx-1] we will assume numbers are less than q;\\n           if(idx-1>=0){\\n                ll elementOnLeft = idx;\\n                ll prefixSum = prefix[idx-1];\\n                temp+=q*elementOnLeft - prefixSum;\\n           }\\n           if(idx<n){\\n               // here are the values that are >=q;\\n               ll elementOnRight = n-idx;\\n               ll sufixSum = prefix[n-1] - (idx-1>=0?prefix[idx-1]:0);\\n               temp+=sufixSum - q*elementOnRight;\\n           }\\n            \\n          ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361177,
                "title": "c-prefix-sum-upper-bound",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<ll>prefix(n);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        vector<ll>ans;\\n        for(int i=0;i<queries.size();i++){\\n            ll index=upper_bound(nums.begin(),nums.end(),queries[i])-nums.begin();\\n            int flag=0;\\n            if(index==0  and nums[index]!=queries[i]){\\n                flag=1;\\n            }\\n            if(index!=0) index-=1;\\n            ll sum=0;\\n            if(flag==0){\\n                sum+=((queries[i]*(index+1))-(prefix[index]));\\n                sum+=abs((queries[i]*(n-index-1)-(prefix[n-1]-prefix[index])));\\n            }\\n            else\\n                sum+=abs((queries[i]*(n-index)-(prefix[n-1])));\\n            \\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<ll>prefix(n);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        vector<ll>ans;\\n        for(int i=0;i<queries.size();i++){\\n            ll index=upper_bound(nums.begin(),nums.end(),queries[i])-nums.begin();\\n            int flag=0;\\n            if(index==0  and nums[index]!=queries[i]){\\n                flag=1;\\n            }\\n            if(index!=0) index-=1;\\n            ll sum=0;\\n            if(flag==0){\\n                sum+=((queries[i]*(index+1))-(prefix[index]));\\n                sum+=abs((queries[i]*(n-index-1)-(prefix[n-1]-prefix[index])));\\n            }\\n            else\\n                sum+=abs((queries[i]*(n-index)-(prefix[n-1])));\\n            \\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360512,
                "title": "python-solution-sort-prefix-sum-and-binary-search-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Sort nums.\\n2. Create a prefix_sum arr, prefix_sum[i] => sum of distance from index 0 to index 0, 1, ... , n.\\n3. For Each Query, do the binary search to get the first index of value \\nthat greater or last index of value that eqaul to the query value.\\n4. calculate the result base on three sceanarios\\n    - query value is less than nums[0] (prefix_sum[-1] plus (query value - min(nums)) * n)\\n    - query value is greater than nums[-1] (will be (query value * n) - prefix_sum[-1])\\n    - query value is within min(nums) and max(nums) (calculate left part and right part and add them)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        prefix_sum = [0]\\n        curr = 0\\n        n = len(nums)\\n        for i in range(1, n):\\n            curr += nums[i] - nums[i - 1]\\n            prefix_sum.append(curr + prefix_sum[-1])\\n        res = []\\n        for q in queries:\\n            idx = bisect.bisect_right(nums, q)\\n            if idx == 0:\\n                res.append(prefix_sum[-1] + (nums[0] - q) * n)\\n            else:\\n                curr = (q - nums[0]) * idx - prefix_sum[idx - 1]\\n                if idx < n:\\n                    curr += prefix_sum[-1] - prefix_sum[idx - 1] - (n - idx) * (q - nums[0])\\n                res.append(curr)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        prefix_sum = [0]\\n        curr = 0\\n        n = len(nums)\\n        for i in range(1, n):\\n            curr += nums[i] - nums[i - 1]\\n            prefix_sum.append(curr + prefix_sum[-1])\\n        res = []\\n        for q in queries:\\n            idx = bisect.bisect_right(nums, q)\\n            if idx == 0:\\n                res.append(prefix_sum[-1] + (nums[0] - q) * n)\\n            else:\\n                curr = (q - nums[0]) * idx - prefix_sum[idx - 1]\\n                if idx < n:\\n                    curr += prefix_sum[-1] - prefix_sum[idx - 1] - (n - idx) * (q - nums[0])\\n                res.append(curr)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360431,
                "title": "preifx-binary-search",
                "content": "\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n       \\n        vector<int> cmp(nums.begin(), nums.end());\\n        vector<long long> ret;\\n        vector<long long> pre(nums.size()+1);\\n        sort(cmp.begin(), cmp.end());\\n        \\n        long long sum=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=cmp[i];\\n            pre[i+1] = sum;\\n        }\\n        \\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            auto it = lower_bound(cmp.begin(), cmp.end(), queries[i]);\\n            long long ans=0;\\n            if(it != cmp.begin())\\n            {\\n                \\n                ans = (pre[nums.size()] - pre[it-cmp.begin()]) - (nums.size()-(it-cmp.begin()))*queries[i];\\n                ans += queries[i]*(it-cmp.begin()) - pre[it-cmp.begin()];\\n            }else{\\n                \\n                ans = queries[i] * cmp.size() - pre[cmp.size()];  \\n            }\\n            \\n            ret.push_back(abs(ans));\\n        }\\n        \\n        return ret;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n       \\n        vector<int> cmp(nums.begin(), nums.end());\\n        vector<long long> ret;\\n        vector<long long> pre(nums.size()+1);\\n        sort(cmp.begin(), cmp.end());\\n        \\n        long long sum=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=cmp[i];\\n            pre[i+1] = sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3358756,
                "title": "python-and-c-solutions",
                "content": "\\n```python []\\nclass Solution:\\n    def find_index(self,nums,val,r):\\n        l=0\\n        ans=r+1\\n        while l<=r:\\n            mid=l+((r-l)>>1)\\n            if nums[mid]==val:return mid\\n            elif nums[mid]>val:\\n                ans=mid\\n                r=mid-1\\n            else:\\n                l=mid+1\\n        return ans\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        pre=[]\\n        temp=0\\n        for i in nums:\\n            pre.append(temp+i)\\n            temp=pre[-1]\\n        length=len(nums)\\n        res=[]\\n        for i in queries:\\n            ind=self.find_index(nums,i,length-1)\\n            if ind==length:\\n                ans=((ind)*i-pre[ind-1])\\n                res.append(ans)\\n            elif ind==0 and nums[ind]!=i:\\n                ans=-((length)*i-pre[-1])\\n                res.append(ans)\\n            elif nums[ind]==i:\\n                left=((ind)*i-pre[ind-1]) if ind!=0 else 0\\n                right=(pre[-1]-pre[ind]-(length-1-ind)*i) if ind!=length-1 else 0\\n                res.append(left+right)\\n            else:\\n                left=((ind)*i-pre[ind-1]) if ind!=0 else 0\\n                right=(pre[-1]-(pre[ind-1] if ind!=0 else 0)-(length-ind)*i) if ind!=length-1 else 0\\n                res.append(left+right)\\n        return res\\n\\n            \\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int find_index(vector<int> &nums,int val,int r){\\n        int l=0;\\n        int ans=r+1;\\n        while (l<=r){\\n            int mid=l+((r-l)>>1);\\n            if (nums[mid]==val) return mid;\\n            else if (nums[mid]>val){\\n                ans=mid;\\n                r=mid-1;}\\n            else l=mid+1;\\n        }\\n        return ans;}\\n    \\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<long long> pre;\\n        long long temp=0;\\n        for (auto &i: nums){\\n            pre.push_back(temp+i);\\n            temp=pre[pre.size()-1];\\n        }\\n        long long length=nums.size();\\n        vector<long long> res;\\n        for (auto &i:queries){\\n            long long ind=find_index(nums,i,length-1);\\n            if (ind==length){\\n                long long ans=((ind)*i-pre[ind-1]);\\n                res.push_back(ans);}\\n            else if (ind==0 && nums[ind]!=i){\\n                long long ans=-((length)*i-pre[pre.size()-1]);\\n                res.push_back(ans);}\\n            else if (nums[ind]==i){\\n                long long left = (ind!=0) ?((ind)*i-pre[ind-1])  : 0;\\n                long long right=  (ind!=length-1) ? (pre[pre.size()-1]-pre[ind]-(length-1-ind)*i) : 0;\\n                res.push_back(left+right);}\\n            else{\\n                long long left= (ind!=0)? (ind*i-pre[ind-1]) : 0;\\n                long long right;\\n                if (ind!=length-1) {\\n                    right=(ind!=0)? (pre[pre.size()-1]-pre[ind-1]-(length-ind)*i) : (pre[pre.size()-1]-(length-ind)*i);}\\n                else {\\n                    right=0;\\n                }\\n                res.push_back(left+right);}\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def find_index(self,nums,val,r):\\n        l=0\\n        ans=r+1\\n        while l<=r:\\n            mid=l+((r-l)>>1)\\n            if nums[mid]==val:return mid\\n            elif nums[mid]>val:\\n                ans=mid\\n                r=mid-1\\n            else:\\n                l=mid+1\\n        return ans\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        pre=[]\\n        temp=0\\n        for i in nums:\\n            pre.append(temp+i)\\n            temp=pre[-1]\\n        length=len(nums)\\n        res=[]\\n        for i in queries:\\n            ind=self.find_index(nums,i,length-1)\\n            if ind==length:\\n                ans=((ind)*i-pre[ind-1])\\n                res.append(ans)\\n            elif ind==0 and nums[ind]!=i:\\n                ans=-((length)*i-pre[-1])\\n                res.append(ans)\\n            elif nums[ind]==i:\\n                left=((ind)*i-pre[ind-1]) if ind!=0 else 0\\n                right=(pre[-1]-pre[ind]-(length-1-ind)*i) if ind!=length-1 else 0\\n                res.append(left+right)\\n            else:\\n                left=((ind)*i-pre[ind-1]) if ind!=0 else 0\\n                right=(pre[-1]-(pre[ind-1] if ind!=0 else 0)-(length-ind)*i) if ind!=length-1 else 0\\n                res.append(left+right)\\n        return res\\n\\n            \\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int find_index(vector<int> &nums,int val,int r){\\n        int l=0;\\n        int ans=r+1;\\n        while (l<=r){\\n            int mid=l+((r-l)>>1);\\n            if (nums[mid]==val) return mid;\\n            else if (nums[mid]>val){\\n                ans=mid;\\n                r=mid-1;}\\n            else l=mid+1;\\n        }\\n        return ans;}\\n    \\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<long long> pre;\\n        long long temp=0;\\n        for (auto &i: nums){\\n            pre.push_back(temp+i);\\n            temp=pre[pre.size()-1];\\n        }\\n        long long length=nums.size();\\n        vector<long long> res;\\n        for (auto &i:queries){\\n            long long ind=find_index(nums,i,length-1);\\n            if (ind==length){\\n                long long ans=((ind)*i-pre[ind-1]);\\n                res.push_back(ans);}\\n            else if (ind==0 && nums[ind]!=i){\\n                long long ans=-((length)*i-pre[pre.size()-1]);\\n                res.push_back(ans);}\\n            else if (nums[ind]==i){\\n                long long left = (ind!=0) ?((ind)*i-pre[ind-1])  : 0;\\n                long long right=  (ind!=length-1) ? (pre[pre.size()-1]-pre[ind]-(length-1-ind)*i) : 0;\\n                res.push_back(left+right);}\\n            else{\\n                long long left= (ind!=0)? (ind*i-pre[ind-1]) : 0;\\n                long long right;\\n                if (ind!=length-1) {\\n                    right=(ind!=0)? (pre[pre.size()-1]-pre[ind-1]-(length-ind)*i) : (pre[pre.size()-1]-(length-ind)*i);}\\n                else {\\n                    right=0;\\n                }\\n                res.push_back(left+right);}\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357410,
                "title": "javascript-prefix-sum-binary-search",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar minOperations = function (nums, queries) {\\n  const n = nums.length;\\n  const m = queries.length;\\n  nums.sort((a, b) => a - b);\\n\\n  const preSum = [0];\\n  for (const num of nums) {\\n    const lastVal = preSum[preSum.length - 1];\\n    preSum.push(lastVal + num);\\n  }\\n\\n  const ans = new Array(m).fill();\\n  for (let i = 0; i < m; i++) {\\n    const idx = binarySearch(queries[i], nums);\\n    const leftLen = idx + 1;\\n    const expectedLeftSum = leftLen * queries[i];\\n    const preSumLeft = preSum[idx + 1];\\n\\n    const rightLen = n - leftLen;\\n    const expectedRightSum = rightLen * queries[i];\\n    const preSumRight = preSum[n] - preSum[idx + 1];\\n\\n    ans[i] = expectedLeftSum - preSumLeft + preSumRight - expectedRightSum;\\n  }\\n\\n  return ans;\\n};\\n\\nfunction binarySearch(target, nums) {\\n  let low = 0;\\n  let high = nums.length - 1;\\n  let ans = -1;\\n\\n  while (low <= high) {\\n    const mid = Math.floor((low + high) / 2);\\n    if (nums[mid] <= target) {\\n      ans = mid;\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar minOperations = function (nums, queries) {\\n  const n = nums.length;\\n  const m = queries.length;\\n  nums.sort((a, b) => a - b);\\n\\n  const preSum = [0];\\n  for (const num of nums) {\\n    const lastVal = preSum[preSum.length - 1];\\n    preSum.push(lastVal + num);\\n  }\\n\\n  const ans = new Array(m).fill();\\n  for (let i = 0; i < m; i++) {\\n    const idx = binarySearch(queries[i], nums);\\n    const leftLen = idx + 1;\\n    const expectedLeftSum = leftLen * queries[i];\\n    const preSumLeft = preSum[idx + 1];\\n\\n    const rightLen = n - leftLen;\\n    const expectedRightSum = rightLen * queries[i];\\n    const preSumRight = preSum[n] - preSum[idx + 1];\\n\\n    ans[i] = expectedLeftSum - preSumLeft + preSumRight - expectedRightSum;\\n  }\\n\\n  return ans;\\n};\\n\\nfunction binarySearch(target, nums) {\\n  let low = 0;\\n  let high = nums.length - 1;\\n  let ans = -1;\\n\\n  while (low <= high) {\\n    const mid = Math.floor((low + high) / 2);\\n    if (nums[mid] <= target) {\\n      ans = mid;\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356464,
                "title": "java-prefix-sum-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* For n numbers all of them bellow query, the target is n * quuery.\\n* If we know the sum of those numbers, the diff is Math.abs(query * n - sum)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo the task becomes: finding the sum up to any point (prefix sum) and finding the index above which all numbers are greater than query, and bellow which all numbers are lower. On a sorted array of course.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * log(n) + q* log(n)), where n is a length of the n array, and q is a length of the queries array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n + q)\\n# Code\\n```\\nclass Solution {\\n\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        long[] upTo = new long[nums.length];\\n        int upToIndex = 0;\\n        long upToPrevious = 0L;\\n        for (int n : nums) {\\n            upTo[upToIndex] = upToPrevious + n;\\n            upToPrevious = upTo[upToIndex];\\n            upToIndex++;\\n        } \\n        long total = upTo[nums.length - 1];\\n        List<Long> result = new ArrayList<>();\\n        for (int query : queries) {\\n            if (query <= nums[0]) {\\n                result.add(total - (long) query * nums.length);\\n            } else if (query >= nums[nums.length - 1]) {\\n                result.add((long) query * nums.length - total);\\n            } else {\\n                int mid = getMiddle(nums, query);\\n                long res = total - 2 * upTo[mid] - (long) query * (nums.length - 2 * mid - 2);\\n                result.add(res);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    int getMiddle(int[] nums, int query) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (query < nums[middle]) {\\n                high = middle - 1;\\n            } else {\\n                low = middle + 1;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        long[] upTo = new long[nums.length];\\n        int upToIndex = 0;\\n        long upToPrevious = 0L;\\n        for (int n : nums) {\\n            upTo[upToIndex] = upToPrevious + n;\\n            upToPrevious = upTo[upToIndex];\\n            upToIndex++;\\n        } \\n        long total = upTo[nums.length - 1];\\n        List<Long> result = new ArrayList<>();\\n        for (int query : queries) {\\n            if (query <= nums[0]) {\\n                result.add(total - (long) query * nums.length);\\n            } else if (query >= nums[nums.length - 1]) {\\n                result.add((long) query * nums.length - total);\\n            } else {\\n                int mid = getMiddle(nums, query);\\n                long res = total - 2 * upTo[mid] - (long) query * (nums.length - 2 * mid - 2);\\n                result.add(res);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    int getMiddle(int[] nums, int query) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (query < nums[middle]) {\\n                high = middle - 1;\\n            } else {\\n                low = middle + 1;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355598,
                "title": "simple-sort-binary-search-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(Nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n\\n        long long n = nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        vector<long long>pre(n,0);\\n        pre[0] = (long long)nums[0];\\n\\n        for(int i = 1;i<n;i++){\\n            pre[i] = (long long)pre[i-1] + (long long)nums[i];\\n        }\\n\\n        vector<long long>vec;\\n        for(auto iter : q){\\n            long long lb = lower_bound(nums.begin(),nums.end(),iter)-nums.begin();\\n            long long ub = upper_bound(nums.begin(),nums.end(),iter)-nums.begin();\\n            long long ans = 0;\\n            if(lb==n){\\n                ans+=(iter*n-pre[n-1]);\\n            }\\n            else if(lb==0){\\n                ans+=0;\\n            }\\n            else{\\n                ans+=(lb*iter-pre[lb-1]);\\n            }\\n            if(ub==n){\\n                ans+=0;\\n            }\\n            else if(ub==0){\\n                ans+=(pre[n-1]-n*iter);\\n            }\\n            else{\\n                ans+=((pre[n-1]-pre[ub-1])-(n-ub)*iter);\\n            }\\n            vec.push_back(ans);\\n        }\\n\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n\\n        long long n = nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        vector<long long>pre(n,0);\\n        pre[0] = (long long)nums[0];\\n\\n        for(int i = 1;i<n;i++){\\n            pre[i] = (long long)pre[i-1] + (long long)nums[i];\\n        }\\n\\n        vector<long long>vec;\\n        for(auto iter : q){\\n            long long lb = lower_bound(nums.begin(),nums.end(),iter)-nums.begin();\\n            long long ub = upper_bound(nums.begin(),nums.end(),iter)-nums.begin();\\n            long long ans = 0;\\n            if(lb==n){\\n                ans+=(iter*n-pre[n-1]);\\n            }\\n            else if(lb==0){\\n                ans+=0;\\n            }\\n            else{\\n                ans+=(lb*iter-pre[lb-1]);\\n            }\\n            if(ub==n){\\n                ans+=0;\\n            }\\n            else if(ub==0){\\n                ans+=(pre[n-1]-n*iter);\\n            }\\n            else{\\n                ans+=((pre[n-1]-pre[ub-1])-(n-ub)*iter);\\n            }\\n            vec.push_back(ans);\\n        }\\n\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355038,
                "title": "python-binary-search-o-n-log-n",
                "content": "1. Given a query `q`, the number of operations would be `sum([q-n for n in nums if n < q]) + sum([n-q for n in nums if n >= q])`.\\n2. First we sort `nums`. For each `q`, use binary search to find the index seperating `n < q` and `n >= q`. \\nTo avoid repeating calculation, we need to save the partial sums of `nums` beforehand.\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        arr_par = []\\n        partial_sum = 0\\n        for n in nums:\\n            partial_sum += n\\n            arr_par.append(partial_sum)\\n        total = partial_sum\\n        \\n        ans = []\\n        for q in queries:\\n            idx = bisect_left(nums, q)\\n            left_sum = arr_par[idx-1] if idx > 0 else 0\\n            right_sum = total - left_sum\\n            ans.append(q * idx - left_sum + right_sum - q * (len(nums)-idx))\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "1. Given a query `q`, the number of operations would be `sum([q-n for n in nums if n < q]) + sum([n-q for n in nums if n >= q])`.\\n2. First we sort `nums`. For each `q`, use binary search to find the index seperating `n < q` and `n >= q`. \\nTo avoid repeating calculation, we need to save the partial sums of `nums` beforehand.\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        arr_par = []\\n        partial_sum = 0\\n        for n in nums:\\n            partial_sum += n\\n            arr_par.append(partial_sum)\\n        total = partial_sum\\n        \\n        ans = []\\n        for q in queries:\\n            idx = bisect_left(nums, q)\\n            left_sum = arr_par[idx-1] if idx > 0 else 0\\n            right_sum = total - left_sum\\n            ans.append(q * idx - left_sum + right_sum - q * (len(nums)-idx))\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3353875,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>, queries: Vec<i32>) -> Vec<i64> {\\n        fn upper_bound<T: Ord>(arr: &[T], x: &T) -> Result<usize, usize> {\\n            let mut left = 0;\\n            let len = arr.len();\\n            let mut right = len;\\n            while left < right {\\n                let mid = left + (right - left) / 2;\\n                match arr[mid].cmp(x) {\\n                    std::cmp::Ordering::Greater => right = mid,\\n                    _ => left = mid + 1,\\n                }\\n            }\\n            assert_eq!(left, right);\\n            if left == len {\\n                Err(left)\\n            } else {\\n                Ok(left)\\n            }\\n        }\\n\\n        let mut ps = vec![0];\\n        let mut nums = nums.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        nums.sort();\\n        for n in nums.iter() {\\n            ps.push(ps.last().unwrap() + n);\\n        }\\n        let queries = queries.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let mut res = vec![];\\n        for q in queries.iter() {\\n            let i = upper_bound(&nums, q).unwrap_or_else(|e|e);\\n            res.push(q * i as i64 - ps[i] + (ps.last().unwrap() - ps[i]) - q * (nums.len() - i) as i64);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>, queries: Vec<i32>) -> Vec<i64> {\\n        fn upper_bound<T: Ord>(arr: &[T], x: &T) -> Result<usize, usize> {\\n            let mut left = 0;\\n            let len = arr.len();\\n            let mut right = len;\\n            while left < right {\\n                let mid = left + (right - left) / 2;\\n                match arr[mid].cmp(x) {\\n                    std::cmp::Ordering::Greater => right = mid,\\n                    _ => left = mid + 1,\\n                }\\n            }\\n            assert_eq!(left, right);\\n            if left == len {\\n                Err(left)\\n            } else {\\n                Ok(left)\\n            }\\n        }\\n\\n        let mut ps = vec![0];\\n        let mut nums = nums.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        nums.sort();\\n        for n in nums.iter() {\\n            ps.push(ps.last().unwrap() + n);\\n        }\\n        let queries = queries.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let mut res = vec![];\\n        for q in queries.iter() {\\n            let i = upper_bound(&nums, q).unwrap_or_else(|e|e);\\n            res.push(q * i as i64 - ps[i] + (ps.last().unwrap() - ps[i]) - q * (nums.len() - i) as i64);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3351464,
                "title": "sort-prefix-sum-binary-search-python3",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        \\n        n = len(nums)\\n        nums.sort()\\n        diff = [0]*n\\n        for i in range(1,n):\\n            diff[i] = nums[i]-nums[i-1] + diff[i-1]\\n        \\n        partial_diff = [0]*n\\n        for i in range(1,n):\\n            partial_diff[i] = diff[i] + partial_diff[i-1]\\n        ans = []\\n        def bin_search(val):\\n            l,h,ans = 0,n-1,-1\\n            while l<=h:\\n                mid = (l+h)//2\\n                if diff[mid] <= val:\\n                    ans = mid\\n                    l = mid+1\\n                else:\\n                    h = mid - 1\\n            return ans\\n                \\n        for x in queries:\\n            curr_diff = x - nums[0]\\n            if curr_diff < 0:\\n                curr_ans = abs(n*curr_diff) +  partial_diff[-1]\\n                ans.append(curr_ans)\\n            else:\\n                pos = bin_search(curr_diff)\\n                sum1=sum2=0\\n                if pos+1 < len(nums):\\n                    sum2 = partial_diff[-1]-partial_diff[pos]\\n                    sum2 -= ((n-pos-1)*curr_diff)\\n                \\n                sum1 = (pos+1)*curr_diff - partial_diff[pos]\\n                ans.append(sum1+sum2)\\n                \\n        \\n        return ans\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n        \\n        n = len(nums)\\n        nums.sort()\\n        diff = [0]*n\\n        for i in range(1,n):\\n            diff[i] = nums[i]-nums[i-1] + diff[i-1]\\n        \\n        partial_diff = [0]*n\\n        for i in range(1,n):\\n            partial_diff[i] = diff[i] + partial_diff[i-1]\\n        ans = []\\n        def bin_search(val):\\n            l,h,ans = 0,n-1,-1\\n            while l<=h:\\n                mid = (l+h)//2\\n                if diff[mid] <= val:\\n                    ans = mid\\n                    l = mid+1\\n                else:\\n                    h = mid - 1\\n            return ans\\n                \\n        for x in queries:\\n            curr_diff = x - nums[0]\\n            if curr_diff < 0:\\n                curr_ans = abs(n*curr_diff) +  partial_diff[-1]\\n                ans.append(curr_ans)\\n            else:\\n                pos = bin_search(curr_diff)\\n                sum1=sum2=0\\n                if pos+1 < len(nums):\\n                    sum2 = partial_diff[-1]-partial_diff[pos]\\n                    sum2 -= ((n-pos-1)*curr_diff)\\n                \\n                sum1 = (pos+1)*curr_diff - partial_diff[pos]\\n                ans.append(sum1+sum2)\\n                \\n        \\n        return ans\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351308,
                "title": "sort-prefixsum-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        //sort array make prefix sum array of long long\\n        //use binary search to find lowerbound of queries[i]\\n        // left_size = lowerbound+1\\n        //right_size= n-lowerbound-1\\n        //left_move = left_size*queries[i] - prefix[lowerbound]\\n        //right_move = right_size*queries[i]- ( prefix[n-1]-prefix[lowerbound])\\n        \\n        sort(nums.begin(),nums.end());\\n        long long sum=0;\\n        vector<long long> prefix,ans;\\n        long long n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(long long)nums[i];\\n            prefix.push_back(sum);\\n        }\\n       \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long lowerbound= upper_bound(nums.begin(),nums.end(),queries[i])-nums.begin()-1;\\n            long long left_size=0,left_move=0;\\n            long long right_size=0, right_move=0;\\n            if(lowerbound!=-1)\\n            {\\n                left_size= lowerbound+1;\\n                left_move= (long long)left_size*(long long)queries[i]- prefix[lowerbound];\\n            }\\n           \\n            if(lowerbound!=nums.size()-1)\\n            {\\n                right_size= (long long)nums.size()-(long long)lowerbound-(long long)1;\\n                right_move= (long long)prefix[n-1];\\n                if(lowerbound>=0)\\n                    right_move-=(long long)prefix[lowerbound];\\n              \\n                right_move -=right_size*queries[i];\\n              \\n            }\\n            \\n           \\n            ans.push_back(right_move+left_move);\\n                \\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        //sort array make prefix sum array of long long\\n        //use binary search to find lowerbound of queries[i]\\n        // left_size = lowerbound+1\\n        //right_size= n-lowerbound-1\\n        //left_move = left_size*queries[i] - prefix[lowerbound]\\n        //right_move = right_size*queries[i]- ( prefix[n-1]-prefix[lowerbound])\\n        \\n        sort(nums.begin(),nums.end());\\n        long long sum=0;\\n        vector<long long> prefix,ans;\\n        long long n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(long long)nums[i];\\n            prefix.push_back(sum);\\n        }\\n       \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long lowerbound= upper_bound(nums.begin(),nums.end(),queries[i])-nums.begin()-1;\\n            long long left_size=0,left_move=0;\\n            long long right_size=0, right_move=0;\\n            if(lowerbound!=-1)\\n            {\\n                left_size= lowerbound+1;\\n                left_move= (long long)left_size*(long long)queries[i]- prefix[lowerbound];\\n            }\\n           \\n            if(lowerbound!=nums.size()-1)\\n            {\\n                right_size= (long long)nums.size()-(long long)lowerbound-(long long)1;\\n                right_move= (long long)prefix[n-1];\\n                if(lowerbound>=0)\\n                    right_move-=(long long)prefix[lowerbound];\\n              \\n                right_move -=right_size*queries[i];\\n              \\n            }\\n            \\n           \\n            ans.push_back(right_move+left_move);\\n                \\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351097,
                "title": "javascript-binary-search-prefix-sum-355ms",
                "content": "```\\nconst preSum = (a) => { let pre = [0]; for (let i = 0; i < a.length; i++) { pre.push(pre[i] + a[i]); } return pre; };\\nconst subArraySum = (a, l, r) => a[r + 1] - a[l];\\n\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nconst minOperations = (a, b) => {\\n    a.sort((x, y) => x - y);\\n    let res = [], bi = new Bisect(), n = a.length, pre = preSum(a);\\n    for (const v of b) {\\n        let l = bi.bisect_right(a, v), cnt = n - l, sum = subArraySum(pre, l, n - 1), moveDown = sum - cnt * v;\\n        let r = l - 1, cnt2 = r + 1, sum2 = subArraySum(pre, 0, r), moveUp = cnt2 * v - sum2;\\n        let use = moveDown + moveUp;\\n        res.push(use);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nconst preSum = (a) => { let pre = [0]; for (let i = 0; i < a.length; i++) { pre.push(pre[i] + a[i]); } return pre; };\\nconst subArraySum = (a, l, r) => a[r + 1] - a[l];\\n\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nconst minOperations = (a, b) => {\\n    a.sort((x, y) => x - y);\\n    let res = [], bi = new Bisect(), n = a.length, pre = preSum(a);\\n    for (const v of b) {\\n        let l = bi.bisect_right(a, v), cnt = n - l, sum = subArraySum(pre, l, n - 1), moveDown = sum - cnt * v;\\n        let r = l - 1, cnt2 = r + 1, sum2 = subArraySum(pre, 0, r), moveUp = cnt2 * v - sum2;\\n        let use = moveDown + moveUp;\\n        res.push(use);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3351009,
                "title": "java-detailed-explanation-sorting-prefix-sum-binary-search",
                "content": "# Intuition\\nProbably initially brute force with $$O(n*m)$$ seem like a good idea. But the problem\\'s limit is $$1 <= n, m <= 10^5$$ , so obviously $$m*n$$ goes beyond the time limit.\\nActually, for calculating the result it is not necessary to calculate everything one by one. It is enogh to compare numbers less than current request (how much they lack), compare numbers more than current request (how much they exceed the required amount) and sum them.\\n\\n# Approach\\n1. sort initial $$nums$$ for faster search of less and more numbers\\n2. calculate prefix sum in order to easily calculate sum of less nums and sum of bigger nums\\n3. iterate through the $$queries$$ and for each query: \\n- find index of the first num in $$nums$$ that is bigger than current query (much faster with binary search)\\n- calculate sum of less numbers -> so many units are missing for numbers smaller than the current query. calculate the same for bigger numbers -> that many units need to be reduced. sum them \\u2013 it is a result for current query. \\n\\n# Complexity\\n- Time complexity: $$O(n*log(n) + n + m*log(n))$$ \\nn*log(n) \\u2013 for sorting $$nums$$\\nn \\u2013 for calculating prefix sum\\nm*log(n) \\u2013 to iterate through $$queries$$, find an index using binary search, and calculate the result for the current query\\n\\n- Space complexity: $$O(n)$$ for prefix sum of $$nums$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        long[] prefixSum = new long[nums.length];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        List<Long> result = new ArrayList<>();\\n        for (Integer query : queries) {\\n            int equalsOrMoreIndex = findEqualsOrMoreIndex(nums, query);\\n            long tmp = 0;\\n            if (equalsOrMoreIndex > 0) {\\n                long sumAfterIncrement = (long) query * equalsOrMoreIndex;\\n                long sumNow = prefixSum[equalsOrMoreIndex - 1];\\n                tmp += (sumAfterIncrement - sumNow);\\n            }\\n            while (equalsOrMoreIndex < nums.length && nums[equalsOrMoreIndex] == query) {\\n                equalsOrMoreIndex++;\\n            }\\n            if (equalsOrMoreIndex < nums.length) {\\n                long sumAfterDecrement = (long) query * (nums.length - equalsOrMoreIndex);\\n                long sumNow = prefixSum[prefixSum.length - 1];\\n                if (equalsOrMoreIndex > 0) {\\n                    sumNow -= prefixSum[equalsOrMoreIndex - 1];\\n                }\\n                tmp += sumNow - sumAfterDecrement;\\n            }\\n            result.add(tmp);\\n        }\\n        return result;\\n    }\\n\\n    private int findEqualsOrMoreIndex(int[] nums, int num) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left <= right) {\\n            int middle = left + (right - left) / 2;\\n            if (nums[middle] < num) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        long[] prefixSum = new long[nums.length];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        List<Long> result = new ArrayList<>();\\n        for (Integer query : queries) {\\n            int equalsOrMoreIndex = findEqualsOrMoreIndex(nums, query);\\n            long tmp = 0;\\n            if (equalsOrMoreIndex > 0) {\\n                long sumAfterIncrement = (long) query * equalsOrMoreIndex;\\n                long sumNow = prefixSum[equalsOrMoreIndex - 1];\\n                tmp += (sumAfterIncrement - sumNow);\\n            }\\n            while (equalsOrMoreIndex < nums.length && nums[equalsOrMoreIndex] == query) {\\n                equalsOrMoreIndex++;\\n            }\\n            if (equalsOrMoreIndex < nums.length) {\\n                long sumAfterDecrement = (long) query * (nums.length - equalsOrMoreIndex);\\n                long sumNow = prefixSum[prefixSum.length - 1];\\n                if (equalsOrMoreIndex > 0) {\\n                    sumNow -= prefixSum[equalsOrMoreIndex - 1];\\n                }\\n                tmp += sumNow - sumAfterDecrement;\\n            }\\n            result.add(tmp);\\n        }\\n        return result;\\n    }\\n\\n    private int findEqualsOrMoreIndex(int[] nums, int num) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left <= right) {\\n            int middle = left + (right - left) / 2;\\n            if (nums[middle] < num) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350641,
                "title": "prefix-sum-simple-easy-approach-c",
                "content": "```       \\n\\nsort(nums.begin(),nums.end());\\n        \\n        long long n = nums.size();\\n        vector<long long>prefix (n+1,0);\\n        for(int i = 0;i<n;i++){\\n            prefix[i+1] = prefix[i] + nums[i];\\n        }\\n        vector<long long>ans;\\n        for(auto x:queries){\\n            \\n          long long j = lower_bound(nums.begin(),nums.end(),x)-nums.begin();\\n            \\n            \\n //prefix[n] - prefix[j] gives total sum of nums having greater or equal than queries\\n            // j-n gives total no of nums having greater or equal to queries\\n            //j gives total no of nums in which nums is less than queries in which we need to increase the no to make equal to queries (particular) which can be done by queries[i] - nums[i]; \\n            ans.push_back(  prefix[n] - prefix[j] + x*(j-n) + x*j - prefix[j]) ;\\n        }\\n        return ans;\\n    }```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```       \\n\\nsort(nums.begin(),nums.end());\\n        \\n        long long n = nums.size();\\n        vector<long long>prefix (n+1,0);\\n        for(int i = 0;i<n;i++){\\n            prefix[i+1] = prefix[i] + nums[i];\\n        }\\n        vector<long long>ans;\\n        for(auto x:queries){\\n            \\n          long long j = lower_bound(nums.begin(),nums.end(),x)-nums.begin();\\n            \\n            \\n //prefix[n] - prefix[j] gives total sum of nums having greater or equal than queries\\n            // j-n gives total no of nums having greater or equal to queries\\n            //j gives total no of nums in which nums is less than queries in which we need to increase the no to make equal to queries (particular) which can be done by queries[i] - nums[i]; \\n            ans.push_back(  prefix[n] - prefix[j] + x*(j-n) + x*j - prefix[j]) ;\\n        }\\n        return ans;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 3350277,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        List<Long> result = new ArrayList<>();\\n        long[] prefixSum = new long[nums.length];\\n        long[] suffixSum = new long[nums.length];\\n        prefixSum[0] = nums[0];\\n        suffixSum[nums.length - 1] = nums[nums.length - 1];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i + 1] + nums[i];\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            int query = queries[i];\\n            int index = findIndex(nums, query);\\n            long suffix = 0;\\n            long prefix = 0;\\n            if (index >= prefixSum.length) {\\n                result.add((long) query * prefixSum.length - prefixSum[prefixSum.length - 1]);\\n                continue;\\n            }\\n            if (index - 1 >= 0 && index - 1 < prefixSum.length) {\\n                prefix = Math.abs(prefixSum[index - 1] - (long) (index) * (long) query);\\n            }  \\n            if (index + 1 >= 0 && index + 1 < suffixSum.length) {\\n                suffix = Math.abs(suffixSum[index + 1] - (long) (suffixSum.length - index - 1) * (long) query);\\n            }\\n            result.add(suffix + prefix + (long) Math.abs(query - nums[index]));\\n        }\\n        return result;\\n    }\\n    public int findIndex(int[] nums, int value) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == value) {\\n                return mid;\\n            }\\n            if (nums[mid] > value) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        List<Long> result = new ArrayList<>();\\n        long[] prefixSum = new long[nums.length];\\n        long[] suffixSum = new long[nums.length];\\n        prefixSum[0] = nums[0];\\n        suffixSum[nums.length - 1] = nums[nums.length - 1];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i + 1] + nums[i];\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            int query = queries[i];\\n            int index = findIndex(nums, query);\\n            long suffix = 0;\\n            long prefix = 0;\\n            if (index >= prefixSum.length) {\\n                result.add((long) query * prefixSum.length - prefixSum[prefixSum.length - 1]);\\n                continue;\\n            }\\n            if (index - 1 >= 0 && index - 1 < prefixSum.length) {\\n                prefix = Math.abs(prefixSum[index - 1] - (long) (index) * (long) query);\\n            }  \\n            if (index + 1 >= 0 && index + 1 < suffixSum.length) {\\n                suffix = Math.abs(suffixSum[index + 1] - (long) (suffixSum.length - index - 1) * (long) query);\\n            }\\n            result.add(suffix + prefix + (long) Math.abs(query - nums[index]));\\n        }\\n        return result;\\n    }\\n    public int findIndex(int[] nums, int value) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == value) {\\n                return mid;\\n            }\\n            if (nums[mid] > value) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349773,
                "title": "easy-c-solution-using-sorting-prefix-sum-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nORDER DOES NOT MATTER HERE SO SORT THE ARRAY AND STORE THE PREFIX SUM IN AN ARRAY AND FOR EACH QUERY FIND THE LOWER BOUND OF THE GIVEN QUERY ELEMENT.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSO THE INDEX RETURNED BY LOWER BOUND IMPLIES THAT THE ELMENTS TO THE LEFT THE REQ SUM IS TARGET*INDEX AND CURR SUM IS PR[IDX] SO ADD ABS OF REQ SUM - CURR TO ANS.\\nAND SIMILARLY FOR ALL THE ELEMENTS TO THE RIGHT SO THE REQ SUM IS TARGET*(N-IDX) AND CURR SUM IS PR[N]-PR[IDX] SO ADD ABS OF REQ SUM- CURR TO ANS.\\nADD ANS TO RES ARRAY.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLOGN) + O(N) + O(MLOGN) ~= O(NLOGN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n            sort(nums.begin(),nums.end());\\n            int n = nums.size();\\n            vector<long long> p(n+1);\\n            long long sum = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                    sum += nums[i];\\n                    p[i+1] = sum;\\n            }\\n            vector<long long> res;\\n            \\n            for(int i=0;i<q.size();i++)\\n            {\\n                long long cur = 0;\\n                long long int idx = lower_bound(nums.begin(), nums.end(), q[i]) - nums.begin();\\n                long long l = p[idx];\\n                long long lv = q[i] * idx;\\n                cur += abs(lv - l);\\n                long long h = p[n] - p[idx];\\n                long long rv = q[i] * (n - idx);\\n                cur += abs(rv - h);\\n                res.push_back(cur);\\n            }\\n            \\n            return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n            sort(nums.begin(),nums.end());\\n            int n = nums.size();\\n            vector<long long> p(n+1);\\n            long long sum = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                    sum += nums[i];\\n                    p[i+1] = sum;\\n            }\\n            vector<long long> res;\\n            \\n            for(int i=0;i<q.size();i++)\\n            {\\n                long long cur = 0;\\n                long long int idx = lower_bound(nums.begin(), nums.end(), q[i]) - nums.begin();\\n                long long l = p[idx];\\n                long long lv = q[i] * idx;\\n                cur += abs(lv - l);\\n                long long h = p[n] - p[idx];\\n                long long rv = q[i] * (n - idx);\\n                cur += abs(rv - h);\\n                res.push_back(cur);\\n            }\\n            \\n            return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349394,
                "title": "python-binary-search-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\'\\'\\'\\n\\nThe key point of the problem is to find the sum of the differences between each query value in queries and the values in nums.\\n\\nTherefore, first sort nums and then calculate the prefix sum.\\n\\nThen, to find the position of a query in nums, use binary search. If the query value is smaller than a value in nums, calculate the sum as query * idx - prefix[idx]. If it is greater, calculate the sum as prefix[-1] - prefix[idx] - (len(nums)-idx-1) * query.\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n\\n        #1 Sort the list \\n\\n        nums.append(0) # Add [0] for finding the leftmost index\\n        nums.sort()\\n\\n        #2 Binary Search \\n\\n        def helper(target):\\n            left = 0 \\n            right = len(nums)-1\\n            while left <= right :\\n                mid = (left+right)//2\\n                if nums[mid] <= target : \\n                    left = mid + 1 \\n                else :\\n                    right = mid - 1 \\n            return right \\n\\n        #3 Make prefix array\\n\\n        prefix = []\\n        tmp = 0 \\n        for num in nums :\\n            tmp += num\\n            prefix.append(tmp)\\n\\n        #4 Find index \\n\\n        ans = []\\n        tmp = 0\\n        for query in queries:\\n            idx = helper(query)\\n            tmp += query * (idx) - prefix[idx]\\n            tmp += prefix[-1] - prefix[idx] - (len(nums)-idx-1) * query\\n            ans.append(tmp)\\n            tmp = 0\\n        return ans \\n            \\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\'\\'\\'\\n\\nThe key point of the problem is to find the sum of the differences between each query value in queries and the values in nums.\\n\\nTherefore, first sort nums and then calculate the prefix sum.\\n\\nThen, to find the position of a query in nums, use binary search. If the query value is smaller than a value in nums, calculate the sum as query * idx - prefix[idx]. If it is greater, calculate the sum as prefix[-1] - prefix[idx] - (len(nums)-idx-1) * query.\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n\\n        #1 Sort the list \\n\\n        nums.append(0) # Add [0] for finding the leftmost index\\n        nums.sort()\\n\\n        #2 Binary Search \\n\\n        def helper(target):\\n            left = 0 \\n            right = len(nums)-1\\n            while left <= right :\\n                mid = (left+right)//2\\n                if nums[mid] <= target : \\n                    left = mid + 1 \\n                else :\\n                    right = mid - 1 \\n            return right \\n\\n        #3 Make prefix array\\n\\n        prefix = []\\n        tmp = 0 \\n        for num in nums :\\n            tmp += num\\n            prefix.append(tmp)\\n\\n        #4 Find index \\n\\n        ans = []\\n        tmp = 0\\n        for query in queries:\\n            idx = helper(query)\\n            tmp += query * (idx) - prefix[idx]\\n            tmp += prefix[-1] - prefix[idx] - (len(nums)-idx-1) * query\\n            ans.append(tmp)\\n            tmp = 0\\n        return ans \\n            \\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349393,
                "title": "easy-and-best-solution-by-using-hasing-and-lower-bound",
                "content": "\\n# Approach\\nhashing and lower bound\\n\\n# Complexity\\n- Time complexity:\\nO(n(log n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<long long> minOperations(vector<int> &nums, vector<int> &queries)\\n{\\n    vector<long long> hash(nums.size(), 0);\\n    sort(nums.begin(), nums.end());\\n    hash[0] = nums[0];\\n    for (int i = 1; i < nums.size(); i++)\\n    {\\n\\n        hash[i] = hash[i - 1] + nums[i];\\n    }\\n\\n    vector<long long> cans;\\n    for (int i = 0; i < queries.size(); i++)\\n    {\\n        int it = lower_bound(nums.begin(), nums.end(), queries[i]) - nums.begin();\\n        if ((it == nums.size())||(queries[i] != nums[it] && it > 0))\\n        {\\n            it = it - 1;\\n        }\\n        long long sum = 0;\\n        long long toltalbefor = queries[i] *1LL* (it + 1);\\n\\n        long long totalafter = queries[i] *1LL* (nums.size() - (it + 1));\\n\\n        sum = sum + abs(hash[it] - toltalbefor);\\n\\n        sum += abs((hash[hash.size() - 1] - hash[it]) - totalafter);\\n\\n        cans.push_back(sum);\\n    }\\n    return cans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<long long> minOperations(vector<int> &nums, vector<int> &queries)\\n{\\n    vector<long long> hash(nums.size(), 0);\\n    sort(nums.begin(), nums.end());\\n    hash[0] = nums[0];\\n    for (int i = 1; i < nums.size(); i++)\\n    {\\n\\n        hash[i] = hash[i - 1] + nums[i];\\n    }\\n\\n    vector<long long> cans;\\n    for (int i = 0; i < queries.size(); i++)\\n    {\\n        int it = lower_bound(nums.begin(), nums.end(), queries[i]) - nums.begin();\\n        if ((it == nums.size())||(queries[i] != nums[it] && it > 0))\\n        {\\n            it = it - 1;\\n        }\\n        long long sum = 0;\\n        long long toltalbefor = queries[i] *1LL* (it + 1);\\n\\n        long long totalafter = queries[i] *1LL* (nums.size() - (it + 1));\\n\\n        sum = sum + abs(hash[it] - toltalbefor);\\n\\n        sum += abs((hash[hash.size() - 1] - hash[it]) - totalafter);\\n\\n        cans.push_back(sum);\\n    }\\n    return cans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349270,
                "title": "java-prefix-sum-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Sort nums, and create a prefix sum array\\n2. Use binary search to search for the index of the largest element in nums array that is strictly smaller than current query and the smallest element in nums array that is strictly larger than current query.  \\n\\n**Just one thing to mention here, use long to store prefix sum.**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$m = nums.length, n = queries.length$$\\n$$O(mlogm) + O(nlogm)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m)$$\\n\\n# Code\\n```java\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        int mod = 1_000_000_007;\\n        List<Long> result = new ArrayList<>();\\n        int length = nums.length;\\n        Arrays.sort(nums);\\n        long[] prefix = new long[length];\\n        prefix[0]= nums[0] + 0L;\\n        for (int i = 1; i < length; i ++) {\\n            prefix[i] = prefix[i - 1] + nums[i] + 0L;\\n        }\\n        for (int q : queries) {\\n            int lower = lower(nums, q);\\n            int higher = higher(nums, q);\\n            \\n            long sum = 0L;\\n            if (lower >= 0 && nums[lower] < q) {\\n                long val = Math.abs((lower + 1L) * (q + 0L) - (prefix[lower] + 0L)); \\n                sum += val;\\n            }\\n            if (higher < length && nums[higher] > q) {\\n                long val = Math.abs((prefix[length - 1] - prefix[higher] + nums[higher] + 0L) - (length - higher + 0L) * (q + 0L));\\n                sum += val;\\n            }\\n\\n            result.add(sum);\\n        }\\n        \\n        return result;\\n    }\\n\\n    private int lower(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right - 1) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] >= target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n\\n        return nums[right] < target ? right : left;\\n    }\\n\\n    private int higher(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right - 1) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return nums[left] > target ? left : right;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        int mod = 1_000_000_007;\\n        List<Long> result = new ArrayList<>();\\n        int length = nums.length;\\n        Arrays.sort(nums);\\n        long[] prefix = new long[length];\\n        prefix[0]= nums[0] + 0L;\\n        for (int i = 1; i < length; i ++) {\\n            prefix[i] = prefix[i - 1] + nums[i] + 0L;\\n        }\\n        for (int q : queries) {\\n            int lower = lower(nums, q);\\n            int higher = higher(nums, q);\\n            \\n            long sum = 0L;\\n            if (lower >= 0 && nums[lower] < q) {\\n                long val = Math.abs((lower + 1L) * (q + 0L) - (prefix[lower] + 0L)); \\n                sum += val;\\n            }\\n            if (higher < length && nums[higher] > q) {\\n                long val = Math.abs((prefix[length - 1] - prefix[higher] + nums[higher] + 0L) - (length - higher + 0L) * (q + 0L));\\n                sum += val;\\n            }\\n\\n            result.add(sum);\\n        }\\n        \\n        return result;\\n    }\\n\\n    private int lower(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right - 1) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] >= target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n\\n        return nums[right] < target ? right : left;\\n    }\\n\\n    private int higher(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right - 1) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return nums[left] > target ? left : right;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349217,
                "title": "sort-prefix-sum-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo make nums elements =  values, we need to do either addition or subtraction.\\n\\nSome elements > values, so we need to subtract.\\nSome elements < values, so we need to add.\\n\\nWhat we can do is we sort the nums, find the last index which is <= value. For elements uptill index: number of `operations = (index+1) * value - sumTill index elements` \\n\\nFor remaining elements `operations =  (sum of last n - index - 1 elements) - (n-index-1) * value`\\n \\n\\n### IMPORTANT\\nWe can use bisect_left to find lower bound of value in nums. This return first index >= value in nums. So to get last index <= value, we can simply do:\\n`index = bisect_lower(nums, value+1)` and then `index -= 1`\\n\\n\\n\\n# Complexity\\n- Time complexity: O(nlog(n) + n + m*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n\\n        n = len(nums)\\n        m = len(queries)\\n        ans = [0]*m\\n\\n        nums.sort()\\n\\n        prefix = [0]*n\\n        prefix[0] = nums[0]\\n\\n        for i in range(1, n):\\n            prefix[i] = nums[i] + prefix[i-1]\\n\\n        # def lastIndex(value): # <=  value\\n        #     l = 0\\n        #     r = n-1\\n\\n        #     while l <= r:\\n        #         mid = (l+r)//2\\n        #         if nums[mid] > value:\\n        #             r = mid - 1\\n        #         else:\\n        #             l = mid + 1\\n\\n        #     return min(l, r)     \\n\\n\\n        for i in range(m):\\n            \\n            value = queries[i]\\n            index = bisect_left(nums, value+1) # alternative\\n            index -= 1 # last index <= value\\n            operations = 0\\n\\n\\n            if index  == -1:  # means every value in nums is greater than query\\n                operations = prefix[n-1] - n * value\\n            else:\\n                # till index all values are  <= value\\n                operations += (index+1) * value - prefix[index]\\n                # rest are greater than value\\n                operations += (prefix[n-1] - prefix[index]) - (n-index-1) * value \\n\\n            \\n            ans[i] = operations\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\\n\\n        n = len(nums)\\n        m = len(queries)\\n        ans = [0]*m\\n\\n        nums.sort()\\n\\n        prefix = [0]*n\\n        prefix[0] = nums[0]\\n\\n        for i in range(1, n):\\n            prefix[i] = nums[i] + prefix[i-1]\\n\\n        # def lastIndex(value): # <=  value\\n        #     l = 0\\n        #     r = n-1\\n\\n        #     while l <= r:\\n        #         mid = (l+r)//2\\n        #         if nums[mid] > value:\\n        #             r = mid - 1\\n        #         else:\\n        #             l = mid + 1\\n\\n        #     return min(l, r)     \\n\\n\\n        for i in range(m):\\n            \\n            value = queries[i]\\n            index = bisect_left(nums, value+1) # alternative\\n            index -= 1 # last index <= value\\n            operations = 0\\n\\n\\n            if index  == -1:  # means every value in nums is greater than query\\n                operations = prefix[n-1] - n * value\\n            else:\\n                # till index all values are  <= value\\n                operations += (index+1) * value - prefix[index]\\n                # rest are greater than value\\n                operations += (prefix[n-1] - prefix[index]) - (n-index-1) * value \\n\\n            \\n            ans[i] = operations\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349208,
                "title": "c-easy-code-prefix-sum-sorting-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long>res;\\n        vector<long long> prefix;\\n        prefix.push_back(0);\\n        for(int i:nums){\\n            if(prefix.empty()){\\n                prefix.push_back(i);\\n            }else{\\n                prefix.push_back(prefix.back()+i);\\n            }\\n        }\\n        for(int i:q){\\n           int pos=upper_bound(nums.begin(),nums.end(),i)-nums.begin();\\n           long long x=0;\\n           x+=(prefix.back()-prefix[pos]-i*(nums.size()-pos));\\n           x+=(1LL*i*(pos)-prefix[pos]);\\n           res.push_back(x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(),nums.end());\\n        vector<long long>res;\\n        vector<long long> prefix;\\n        prefix.push_back(0);\\n        for(int i:nums){\\n            if(prefix.empty()){\\n                prefix.push_back(i);\\n            }else{\\n                prefix.push_back(prefix.back()+i);\\n            }\\n        }\\n        for(int i:q){\\n           int pos=upper_bound(nums.begin(),nums.end(),i)-nums.begin();\\n           long long x=0;\\n           x+=(prefix.back()-prefix[pos]-i*(nums.size()-pos));\\n           x+=(1LL*i*(pos)-prefix[pos]);\\n           res.push_back(x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349204,
                "title": "easy-and-short-c-solution-using-prefixsum-and-suffixsum",
                "content": "# Intuition\\n- just sort the array and store the prefixSum and suffixSum\\n- and then find the lower bound of each query to find the pos of elements which are greater than query and smaller than query     \\n- for each element which is greater than query we have to dec it by 1 till it is equal to query \\n- for each element which is smaller than query we have to add it by 1 till it is equal to query \\n- to do it in more optimised way we can find the total sum of elements smaller than query (using prefixsum) and we can find the \\n`actual sum = no of smaller elements * query` and the diff of this sum and prefix sum is the no of operation required to make all smaller elements equal to query we have to do the same for greater elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long temp1 = 0,temp2 = 0, n = nums.size();\\n        vector<long long> prefixSum, suffixSum(n),ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<n;i++){         // find prefix and suffixSum\\n            temp1 += nums[i];\\n            temp2 += nums[n-i-1];\\n            prefixSum.push_back(temp1);\\n            suffixSum[n-i-1] = temp2;\\n        }\\n        for(auto i : queries){          // find lower bound\\n            int pos = lower_bound(nums.begin(),nums.end(),i) - nums.begin();\\n            long long sumTillPos = pos>0 ? prefixSum[pos-1] : 0;\\n            long long sumAfterPos = pos <n ? suffixSum[pos] : 0;\\n            long long querySumTillPos = (long long)(pos) * i;\\n            long long querySumAfterPos = (n-pos) * i;\\n            ans.push_back((querySumTillPos - sumTillPos) + (sumAfterPos - querySumAfterPos));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long temp1 = 0,temp2 = 0, n = nums.size();\\n        vector<long long> prefixSum, suffixSum(n),ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<n;i++){         // find prefix and suffixSum\\n            temp1 += nums[i];\\n            temp2 += nums[n-i-1];\\n            prefixSum.push_back(temp1);\\n            suffixSum[n-i-1] = temp2;\\n        }\\n        for(auto i : queries){          // find lower bound\\n            int pos = lower_bound(nums.begin(),nums.end(),i) - nums.begin();\\n            long long sumTillPos = pos>0 ? prefixSum[pos-1] : 0;\\n            long long sumAfterPos = pos <n ? suffixSum[pos] : 0;\\n            long long querySumTillPos = (long long)(pos) * i;\\n            long long querySumAfterPos = (n-pos) * i;\\n            ans.push_back((querySumTillPos - sumTillPos) + (sumAfterPos - querySumAfterPos));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349189,
                "title": "c-using-prefix-sum-and-upper-bound",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector <long long> prefix(n+1,0);\\n        vector <long long> ans;\\n        for(int i=0;i<n;i++){\\n            prefix[i+1]=prefix[i]+nums[i];\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            int upi=upper_bound(nums.begin(),nums.end(),queries[i])-nums.begin();\\n            long long t=0;\\n            if(upi == -1){\\n               t=(n*queries[i])-prefix[n];\\n            }\\n            else{\\n               t=(prefix[n]-prefix[upi])-(1LL*(n-upi)*queries[i]);\\n               t+=(1LL*(upi)*queries[i])-prefix[upi];\\n            }\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector <long long> prefix(n+1,0);\\n        vector <long long> ans;\\n        for(int i=0;i<n;i++){\\n            prefix[i+1]=prefix[i]+nums[i];\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            int upi=upper_bound(nums.begin(),nums.end(),queries[i])-nums.begin();\\n            long long t=0;\\n            if(upi == -1){\\n               t=(n*queries[i])-prefix[n];\\n            }\\n            else{\\n               t=(prefix[n]-prefix[upi])-(1LL*(n-upi)*queries[i]);\\n               t+=(1LL*(upi)*queries[i])-prefix[upi];\\n            }\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349040,
                "title": "prefix-and-suffix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        long n=nums.size(),m=q.size(),l,r,mid,target, idx;\\n        \\n        vector<long long>presum(n,0);\\n        vector<long long>sufsum(n,0);\\n        vector<long long>ans;\\n        \\n        sort(nums.begin(),nums.end());\\n        presum[0]=nums[0];\\n        sufsum[n-1]=nums[n-1];\\n        \\n        for(int i=1;i<n;i++){\\n            presum[i]=presum[i-1]+nums[i];\\n            sufsum[n-1-i]=sufsum[n-i]+nums[n-1-i];\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            l=0;r=0;\\n            target=q[i];\\n            vector<int>::iterator low;  \\n            low=lower_bound (nums.begin(), nums.end(), target);\\n            idx=low-nums.begin();\\n            <!-- cout<<idx<<\" \"; -->\\n            \\n            if(idx>=n){\\n                ans.push_back(abs(presum[n-1] -(q[i]*n)));\\n                continue;\\n            }\\n            if(idx>0) { \\n              l=(q[i]*idx)-presum[idx-1];\\n          }\\n            r=sufsum[idx]-(q[i]*(n-idx));\\n            cout<<l<<\" \"<<r<< \" \";\\n            ans.push_back(l+r);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        long n=nums.size(),m=q.size(),l,r,mid,target, idx;\\n        \\n        vector<long long>presum(n,0);\\n        vector<long long>sufsum(n,0);\\n        vector<long long>ans;\\n        \\n        sort(nums.begin(),nums.end());\\n        presum[0]=nums[0];\\n        sufsum[n-1]=nums[n-1];\\n        \\n        for(int i=1;i<n;i++){\\n            presum[i]=presum[i-1]+nums[i];\\n            sufsum[n-1-i]=sufsum[n-i]+nums[n-1-i];\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            l=0;r=0;\\n            target=q[i];\\n            vector<int>::iterator low;  \\n            low=lower_bound (nums.begin(), nums.end(), target);\\n            idx=low-nums.begin();\\n            <!-- cout<<idx<<\" \"; -->\\n            \\n            if(idx>=n){\\n                ans.push_back(abs(presum[n-1] -(q[i]*n)));\\n                continue;\\n            }\\n            if(idx>0) { \\n              l=(q[i]*idx)-presum[idx-1];\\n          }\\n            r=sufsum[idx]-(q[i]*(n-idx));\\n            cout<<l<<\" \"<<r<< \" \";\\n            ans.push_back(l+r);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3349016,
                "title": "simple-c-solution-using-sorting-prefix-and-suffix-sum",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& arr, vector<int>& queries) {\\n        long long n = arr.size();\\n        int m = queries.size();\\n        sort(arr.begin() , arr.end());\\n        vector<long long> ans(m,0);\\n        vector<long long> prefix(n , 0);\\n        prefix[0] = arr[0];\\n        for(int i=1 ; i<n ; i++){\\n            prefix[i] = arr[i] + prefix[i-1];\\n        }\\n        \\n        vector<long long> suffix(n , 0);\\n        suffix[n-1] = arr[n-1];\\n        for(int i=n-2 ; i>=0; i--){\\n            suffix[i] = suffix[i+1] + arr[i];\\n        }\\n\\n        for(int i=0 ; i<m;  i++){\\n            long long increment = 0;\\n           \\n            auto it = lower_bound(arr.begin() , arr.end() , queries[i]);\\n            long long index = it-arr.begin();\\n            if(index==n){\\n                increment = queries[i]*n - prefix[n-1];\\n            }\\n            else{\\n                if(arr[index]==queries[i]){\\n                    increment = queries[i]*(index+1) - prefix[index]  +\\n                        suffix[index]- queries[i]*(n-index) ;\\n                }\\n                else{\\n                    increment = queries[i]*(index) - (index==0 ? 0 : prefix[index-1])  +\\n                        suffix[index]- queries[i]*(n-index) ;\\n                }\\n                \\n            }\\n\\n            \\n            \\n            ans[i] = increment;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// 1 3 6 8\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& arr, vector<int>& queries) {\\n        long long n = arr.size();\\n        int m = queries.size();\\n        sort(arr.begin() , arr.end());\\n        vector<long long> ans(m,0);\\n        vector<long long> prefix(n , 0);\\n        prefix[0] = arr[0];\\n        for(int i=1 ; i<n ; i++){\\n            prefix[i] = arr[i] + prefix[i-1];\\n        }\\n        \\n        vector<long long> suffix(n , 0);\\n        suffix[n-1] = arr[n-1];\\n        for(int i=n-2 ; i>=0; i--){\\n            suffix[i] = suffix[i+1] + arr[i];\\n        }\\n\\n        for(int i=0 ; i<m;  i++){\\n            long long increment = 0;\\n           \\n            auto it = lower_bound(arr.begin() , arr.end() , queries[i]);\\n            long long index = it-arr.begin();\\n            if(index==n){\\n                increment = queries[i]*n - prefix[n-1];\\n            }\\n            else{\\n                if(arr[index]==queries[i]){\\n                    increment = queries[i]*(index+1) - prefix[index]  +\\n                        suffix[index]- queries[i]*(n-index) ;\\n                }\\n                else{\\n                    increment = queries[i]*(index) - (index==0 ? 0 : prefix[index-1])  +\\n                        suffix[index]- queries[i]*(n-index) ;\\n                }\\n                \\n            }\\n\\n            \\n            \\n            ans[i] = increment;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// 1 3 6 8\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348961,
                "title": "antarnab",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n     //   public List<Long> minOperations(int[] nums, int[] queries) {\\n    Arrays.sort(nums);\\n    List<Long> ans = new ArrayList<>();\\n    int n = nums.length;\\n    long[] prefix = new long[n + 1];\\n    for (int i = 1; i <= n; i++)\\n        prefix[i] = prefix[i - 1] + nums[i - 1];\\n    for (int x: queries) {\\n        int i = bisect_left(nums, x);\\n        ans.add(1L * x * (2 * i - n) + prefix[n] - 2 * prefix[i]);\\n    }\\n    return ans;\\n}\\nprivate int bisect_left(int[] nums, int x) {\\n    int lo = 0, hi = nums.length;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if (nums[mid] < x) lo = mid + 1;\\n        else hi = mid;\\n    }\\n    return lo;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n     //   public List<Long> minOperations(int[] nums, int[] queries) {\\n    Arrays.sort(nums);\\n    List<Long> ans = new ArrayList<>();\\n    int n = nums.length;\\n    long[] prefix = new long[n + 1];\\n    for (int i = 1; i <= n; i++)\\n        prefix[i] = prefix[i - 1] + nums[i - 1];\\n    for (int x: queries) {\\n        int i = bisect_left(nums, x);\\n        ans.add(1L * x * (2 * i - n) + prefix[n] - 2 * prefix[i]);\\n    }\\n    return ans;\\n}\\nprivate int bisect_left(int[] nums, int x) {\\n    int lo = 0, hi = nums.length;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if (nums[mid] < x) lo = mid + 1;\\n        else hi = mid;\\n    }\\n    return lo;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348376,
                "title": "easy-c-solution-using-prefix-sum-and-binary-search",
                "content": "# Intuition\\nThe Basic Intution is to find the number of elements present in nums that are greater or equal to the current queries and the number of elements present in nums which are lesser than it. If we optimally find those things then the task will be easy. We just need to find the difference of the sum of all greater elements and sum of same number of query element. Then we also add the difference of the sum of all lesser elements and the sum of same number of query element. That\\'s will be our answer. \\n\\n# Approach\\nTo find how many numbers are greater than the current query element we can sort the array nums and use binary search. Also to find the summations we can use prefix sum technique.\\n\\n# Complexity\\n- Time complexity:\\nO(m * log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size(), m = queries.size();\\n\\n        // Our answer vector\\n        vector<long long> ans(m, 0);\\n\\n        // Sorting the elements to perform binary search\\n        sort(nums.begin(), nums.end());\\n\\n        // Declaring prefix sum vector\\n        vector<long long> prefix(nums.begin(), nums.end());\\n        // Calculating Prefix Sums\\n        for(int i=1;i<n;i++) prefix[i] += prefix[i-1];\\n\\n\\n        for(int i=0;i<m;i++){\\n            // Using lower bound function to find the \\n            // smallest element that is greater or equal to queries[i]\\n            int ind = lower_bound(nums.begin(),nums.end(),queries[i])-nums.begin();\\n\\n            // If no such element found\\n            if(ind == n){\\n                long long res = queries[i]*1LL*n - prefix[n-1];\\n                ans[i] = res;\\n            }\\n            // If the first element satisfies the condition\\n            else if(ind == 0){\\n                long long res = prefix[n-1] - queries[i]*1LL*n;\\n                ans[i] = res;\\n            }\\n            // If the element is in range [1,n-1]\\n            else{\\n                long long res = 0;\\n\\n                // For greater elements prefix sum will be greater\\n                res += prefix[n-1]-prefix[ind-1] - queries[i] * 1LL* (n-ind);\\n\\n                // For lesser elements prefix sum will be lesser\\n                res += queries[i]*1LL*ind - prefix[ind-1];\\n                ans[i] = res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Please Upvote if you find it helpful\\n/*\\n \\n{\\\\__/}\\n( o.o)\\n/> \\u2665\\u2665\\u2665\\n \\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n = nums.size(), m = queries.size();\\n\\n        // Our answer vector\\n        vector<long long> ans(m, 0);\\n\\n        // Sorting the elements to perform binary search\\n        sort(nums.begin(), nums.end());\\n\\n        // Declaring prefix sum vector\\n        vector<long long> prefix(nums.begin(), nums.end());\\n        // Calculating Prefix Sums\\n        for(int i=1;i<n;i++) prefix[i] += prefix[i-1];\\n\\n\\n        for(int i=0;i<m;i++){\\n            // Using lower bound function to find the \\n            // smallest element that is greater or equal to queries[i]\\n            int ind = lower_bound(nums.begin(),nums.end(),queries[i])-nums.begin();\\n\\n            // If no such element found\\n            if(ind == n){\\n                long long res = queries[i]*1LL*n - prefix[n-1];\\n                ans[i] = res;\\n            }\\n            // If the first element satisfies the condition\\n            else if(ind == 0){\\n                long long res = prefix[n-1] - queries[i]*1LL*n;\\n                ans[i] = res;\\n            }\\n            // If the element is in range [1,n-1]\\n            else{\\n                long long res = 0;\\n\\n                // For greater elements prefix sum will be greater\\n                res += prefix[n-1]-prefix[ind-1] - queries[i] * 1LL* (n-ind);\\n\\n                // For lesser elements prefix sum will be lesser\\n                res += queries[i]*1LL*ind - prefix[ind-1];\\n                ans[i] = res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Please Upvote if you find it helpful\\n/*\\n \\n{\\\\__/}\\n( o.o)\\n/> \\u2665\\u2665\\u2665\\n \\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348375,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Sort the input array `A` and calculate the suffix sums `S` to formulate the answer `ans` for each target `T` of the input `queries` in O(NlogN) time, ie. we perform binary search to find the `i`<sup>th</sup> pivot index and accumulate the absolute difference between the expected sum and actual sum to-the-left and to-the-right as `L` and `R` correspondingly.\\n\\nNote: the expected sum is the cardinality of the elements to-the-left and to-the-right multipled by the target `T`, and we subtract `0` from `i` as a no-op to \"align\" the code for readability\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minOperations(A: IntArray, queries: IntArray): List<Long> {\\n        var N = A.size\\n        A.sort()\\n        var S = longArrayOf(*A.map{ it.toLong() }.toLongArray(), 0)\\n        for (i in N - 1 downTo 0)\\n            S[i] += S[i + 1]\\n        var ans = mutableListOf<Long>()\\n        for (T in queries) {\\n            var i = A.binarySearch(T)\\n            if (i < 0)\\n                i = -(i + 1)\\n            var L = Math.abs((i - 0) * T.toLong() - (S[0] - S[i]))\\n            var R = Math.abs((N - i) * T.toLong() - (S[i] - S[N]))\\n            ans.add(L + R)\\n        }\\n        return ans.toList()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minOperations = (A, queries, ans = []) => {\\n    let N = A.length;\\n    A.sort((a, b) => a - b);\\n    let S = [...A, 0];\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] += S[i + 1];\\n    for (let T of queries) {\\n        let i = _.sortedLastIndex(A, T);\\n        let L = Math.abs((i - 0) * T - (S[0] - S[i])),\\n            R = Math.abs((N - i) * T - (S[i] - S[N]));\\n        ans.push(L + R);\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minOperations(self, A: List[int], queries: List[int]) -> List[int]:\\n        N = len(A)\\n        A.sort()\\n        S = A[:] + [0]\\n        for i in reversed(range(N)):\\n            S[i] += S[i + 1]\\n        ans = []\\n        for T in queries:\\n            i = bisect_right(A, T)\\n            L = abs((i - 0) * T - (S[0] - S[i]))\\n            R = abs((N - i) * T - (S[i] - S[N]))\\n            ans.append(L + R)\\n        return ans\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VL = Vec<i64>;\\nimpl Solution {\\n    pub fn min_operations(mut A: VI, queries: VI) -> VL {\\n        let N = A.len();\\n        A.sort();\\n        let mut S = A.clone().into_iter().map(|x| x as i64).collect::<VL>(); S.push(0i64);\\n        for i in (0..N).rev() {\\n            S[i] += S[i + 1];\\n        }\\n        let mut ans: VL = vec![];\\n        for T in queries {\\n            let i = A.partition_point(|&x| x < T);\\n            let L = ((i - 0) as i64 * T as i64 - (S[0] - S[i])).abs();\\n            let R = ((N - i) as i64 * T as i64 - (S[i] - S[N])).abs();\\n            ans.push(L + R);\\n        }\\n        ans\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    VL minOperations(VI& A, VI& queries, VL ans = {}) {\\n        LL N = A.size();\\n        sort(A.begin(), A.end());\\n        VL S; copy(A.begin(), A.end(), back_inserter(S)), S.push_back(0);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] += S[i + 1];\\n        for (auto T: queries) {\\n            auto i = distance(A.begin(), upper_bound(A.begin(), A.end(), T));\\n            auto L = abs((i - 0) * T - (S[0] - S[i])),\\n                 R = abs((N - i) * T - (S[i] - S[N]));\\n            ans.push_back(L + R);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minOperations(A: IntArray, queries: IntArray): List<Long> {\\n        var N = A.size\\n        A.sort()\\n        var S = longArrayOf(*A.map{ it.toLong() }.toLongArray(), 0)\\n        for (i in N - 1 downTo 0)\\n            S[i] += S[i + 1]\\n        var ans = mutableListOf<Long>()\\n        for (T in queries) {\\n            var i = A.binarySearch(T)\\n            if (i < 0)\\n                i = -(i + 1)\\n            var L = Math.abs((i - 0) * T.toLong() - (S[0] - S[i]))\\n            var R = Math.abs((N - i) * T.toLong() - (S[i] - S[N]))\\n            ans.add(L + R)\\n        }\\n        return ans.toList()\\n    }\\n}\\n```\n```\\nlet minOperations = (A, queries, ans = []) => {\\n    let N = A.length;\\n    A.sort((a, b) => a - b);\\n    let S = [...A, 0];\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] += S[i + 1];\\n    for (let T of queries) {\\n        let i = _.sortedLastIndex(A, T);\\n        let L = Math.abs((i - 0) * T - (S[0] - S[i])),\\n            R = Math.abs((N - i) * T - (S[i] - S[N]));\\n        ans.push(L + R);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, A: List[int], queries: List[int]) -> List[int]:\\n        N = len(A)\\n        A.sort()\\n        S = A[:] + [0]\\n        for i in reversed(range(N)):\\n            S[i] += S[i + 1]\\n        ans = []\\n        for T in queries:\\n            i = bisect_right(A, T)\\n            L = abs((i - 0) * T - (S[0] - S[i]))\\n            R = abs((N - i) * T - (S[i] - S[N]))\\n            ans.append(L + R)\\n        return ans\\n```\n```\\ntype VI = Vec<i32>;\\ntype VL = Vec<i64>;\\nimpl Solution {\\n    pub fn min_operations(mut A: VI, queries: VI) -> VL {\\n        let N = A.len();\\n        A.sort();\\n        let mut S = A.clone().into_iter().map(|x| x as i64).collect::<VL>(); S.push(0i64);\\n        for i in (0..N).rev() {\\n            S[i] += S[i + 1];\\n        }\\n        let mut ans: VL = vec![];\\n        for T in queries {\\n            let i = A.partition_point(|&x| x < T);\\n            let L = ((i - 0) as i64 * T as i64 - (S[0] - S[i])).abs();\\n            let R = ((N - i) as i64 * T as i64 - (S[i] - S[N])).abs();\\n            ans.push(L + R);\\n        }\\n        ans\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    VL minOperations(VI& A, VI& queries, VL ans = {}) {\\n        LL N = A.size();\\n        sort(A.begin(), A.end());\\n        VL S; copy(A.begin(), A.end(), back_inserter(S)), S.push_back(0);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] += S[i + 1];\\n        for (auto T: queries) {\\n            auto i = distance(A.begin(), upper_bound(A.begin(), A.end(), T));\\n            auto L = abs((i - 0) * T - (S[0] - S[i])),\\n                 R = abs((N - i) * T - (S[i] - S[N]));\\n            ans.push_back(L + R);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348065,
                "title": "simple-solution-prefixsum-sum-sorting-upper-bound-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());        \\n        vector<long long> preSum,ans;\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            preSum.push_back(sum);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            int idx=upper_bound(nums.begin(),nums.end(),queries[i])-nums.begin();\\n            long long steps=0;\\n            if(idx==0){\\n              steps+=(preSum[n-1]-(1ll*n*queries[i]));  \\n            }\\n            else {\\n                idx-=1;\\n                long long leftSum=preSum[idx],rightSum=preSum[n-1]-preSum[idx];\\n                steps+=(1ll*(idx+1)*queries[i])-leftSum;\\n                steps+=(rightSum-(1ll*(n-idx-1)*queries[i]));\\n            }\\n            ans.push_back(steps);\\n        }\\n     return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());        \\n        vector<long long> preSum,ans;\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            preSum.push_back(sum);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            int idx=upper_bound(nums.begin(),nums.end(),queries[i])-nums.begin();\\n            long long steps=0;\\n            if(idx==0){\\n              steps+=(preSum[n-1]-(1ll*n*queries[i]));  \\n            }\\n            else {\\n                idx-=1;\\n                long long leftSum=preSum[idx],rightSum=preSum[n-1]-preSum[idx];\\n                steps+=(1ll*(idx+1)*queries[i])-leftSum;\\n                steps+=(rightSum-(1ll*(n-idx-1)*queries[i]));\\n            }\\n            ans.push_back(steps);\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347773,
                "title": "simple-prefix-sum-solution",
                "content": "# Code\\n```\\nusing ll = long long int;\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(), nums.end());\\n        ll n=nums.size();\\n        vector<ll> ans;\\n        vector<ll> ps={nums[0]};\\n        for(ll i=1;i<nums.size();i++) ps.push_back(ps[i-1]+nums[i]);\\n        // for(auto x: ps) cout<<x<<\" \";\\n        for(ll i=0;i<q.size();i++){\\n            ll id=lower_bound(nums.begin(), nums.end(), q[i])-nums.begin();\\n            if(id==0){\\n                if(nums[id]==q[i]){\\n                    ans.push_back(ps[n-1]-ps[0]-q[i]*(n-1));\\n                }\\n                else{\\n                    ans.push_back(ps[n-1]-q[i]*n);\\n                }\\n            }\\n            else if(id==n){\\n                ans.push_back(q[i]*n-ps[n-1]);\\n            }\\n            else if(id==n-1){\\n                if(nums[id]==q[i]){\\n                    ans.push_back(q[i]*(n-1)-ps[n-2]);\\n                }\\n                else{\\n                    ans.push_back(q[i]*(n-1)-ps[n-2] + nums[id]-q[i]);\\n                }\\n            }\\n            else{\\n                ll l, r;\\n                if(nums[id]==q[i]){\\n                    l=id-1; r=id+1;\\n                    ans.push_back(q[i]*(l+1)-ps[l]+ps[n-1]-ps[id]-q[i]*(n-r));\\n                }\\n                else{\\n                    l=id-1, r=id;\\n                    ans.push_back(q[i]*(l+1)-ps[l]+ps[n-1]-ps[id-1]-q[i]*(n-r));\\n                }\\n            }\\n        }\\n        // cout<<\"\\\\n\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing ll = long long int;\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& q) {\\n        sort(nums.begin(), nums.end());\\n        ll n=nums.size();\\n        vector<ll> ans;\\n        vector<ll> ps={nums[0]};\\n        for(ll i=1;i<nums.size();i++) ps.push_back(ps[i-1]+nums[i]);\\n        // for(auto x: ps) cout<<x<<\" \";\\n        for(ll i=0;i<q.size();i++){\\n            ll id=lower_bound(nums.begin(), nums.end(), q[i])-nums.begin();\\n            if(id==0){\\n                if(nums[id]==q[i]){\\n                    ans.push_back(ps[n-1]-ps[0]-q[i]*(n-1));\\n                }\\n                else{\\n                    ans.push_back(ps[n-1]-q[i]*n);\\n                }\\n            }\\n            else if(id==n){\\n                ans.push_back(q[i]*n-ps[n-1]);\\n            }\\n            else if(id==n-1){\\n                if(nums[id]==q[i]){\\n                    ans.push_back(q[i]*(n-1)-ps[n-2]);\\n                }\\n                else{\\n                    ans.push_back(q[i]*(n-1)-ps[n-2] + nums[id]-q[i]);\\n                }\\n            }\\n            else{\\n                ll l, r;\\n                if(nums[id]==q[i]){\\n                    l=id-1; r=id+1;\\n                    ans.push_back(q[i]*(l+1)-ps[l]+ps[n-1]-ps[id]-q[i]*(n-r));\\n                }\\n                else{\\n                    l=id-1, r=id;\\n                    ans.push_back(q[i]*(l+1)-ps[l]+ps[n-1]-ps[id-1]-q[i]*(n-r));\\n                }\\n            }\\n        }\\n        // cout<<\"\\\\n\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3347325,
                "title": "beats-100-prefix-sum-binary-search-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long> res;\\n        int n = nums.size();\\n        vector<long long> forwardpre(n,0) , backwardpre(n,0);\\n\\n        sort(nums.begin(),nums.end());\\n\\n        forwardpre[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            forwardpre[i] = forwardpre[i-1] + nums[i];\\n        }\\n\\n        backwardpre[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            backwardpre[i] = backwardpre[i+1] + nums[i];\\n        }\\n\\n        for(long long it:queries){\\n            long long ans = 0;\\n            int index = lower_bound(nums.begin(),nums.end(),it) - nums.begin();\\n            if(index == n || index == 0)ans += abs((n*it) - forwardpre[n-1]);\\n            else{\\n                ans += abs((index*it)-forwardpre[index-1]) + \\n                        abs(backwardpre[index] - (n-index)*it);\\n            }\\n            res.push_back(ans);\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        vector<long long> res;\\n        int n = nums.size();\\n        vector<long long> forwardpre(n,0) , backwardpre(n,0);\\n\\n        sort(nums.begin(),nums.end());\\n\\n        forwardpre[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            forwardpre[i] = forwardpre[i-1] + nums[i];\\n        }\\n\\n        backwardpre[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            backwardpre[i] = backwardpre[i+1] + nums[i];\\n        }\\n\\n        for(long long it:queries){\\n            long long ans = 0;\\n            int index = lower_bound(nums.begin(),nums.end(),it) - nums.begin();\\n            if(index == n || index == 0)ans += abs((n*it) - forwardpre[n-1]);\\n            else{\\n                ans += abs((index*it)-forwardpre[index-1]) + \\n                        abs(backwardpre[index] - (n-index)*it);\\n            }\\n            res.push_back(ans);\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347076,
                "title": "c-easy-solution-prefix-suffix-binary-search-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //TC=O(N*Log(N)) N=size of nums\\n    //SC=O(N)+O(N)\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        vector<long long> v;\\n          vector<long long> prefix(n,0),suffix(n,0);  \\n          vector<int>::iterator upper,lower;\\n          sort(nums.begin(),nums.end());                                  \\n         long long temp=0;\\n          for(int i=0;i<nums.size();i++){\\n              temp+=nums[i];\\n              prefix[i]=temp;                         \\n          }        \\n         temp=0;\\n         for(int i=n-1;i>=0;i--){\\n             temp+=nums[i];\\n            suffix[i]=temp;   \\n        }      \\n          for(int i=0;i<queries.size();i++){\\n                upper=upper_bound(nums.begin(),nums.end(),queries[i]);\\n                lower=lower_bound(nums.begin(),nums.end(),queries[i]);\\n              int no1= (upper - nums.begin());\\n              int no2= (lower - nums.begin());             \\n              long long p=-1,s=-1;\\n              long long sum=0;            \\n              if(no2>=1){   \\n                  p=prefix[no2-1];\\n              }\\n              if(no1<n && no1>=0){\\n                  s=suffix[no1];                 \\n              }              \\n              if(p!=-1){\\n                  long long curr=0;\\n                  if(no2>=1){\\n                      curr=(long long)(no2)*queries[i];\\n                  }\\n                  sum+=abs(p-curr);\\n              }\\n              if(s!=-1){\\n                  long long curr=0;\\n                  if(no1>=0 && no1<n){\\n                      \\n                      curr= (long long)(n-no1)*queries[i];\\n                  }                \\n                  sum+=abs(s-curr);\\n              }\\n             v.push_back(sum);\\n          }\\n            \\n        return v;          \\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //TC=O(N*Log(N)) N=size of nums\\n    //SC=O(N)+O(N)\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        int n=nums.size();\\n        vector<long long> v;\\n          vector<long long> prefix(n,0),suffix(n,0);  \\n          vector<int>::iterator upper,lower;\\n          sort(nums.begin(),nums.end());                                  \\n         long long temp=0;\\n          for(int i=0;i<nums.size();i++){\\n              temp+=nums[i];\\n              prefix[i]=temp;                         \\n          }        \\n         temp=0;\\n         for(int i=n-1;i>=0;i--){\\n             temp+=nums[i];\\n            suffix[i]=temp;   \\n        }      \\n          for(int i=0;i<queries.size();i++){\\n                upper=upper_bound(nums.begin(),nums.end(),queries[i]);\\n                lower=lower_bound(nums.begin(),nums.end(),queries[i]);\\n              int no1= (upper - nums.begin());\\n              int no2= (lower - nums.begin());             \\n              long long p=-1,s=-1;\\n              long long sum=0;            \\n              if(no2>=1){   \\n                  p=prefix[no2-1];\\n              }\\n              if(no1<n && no1>=0){\\n                  s=suffix[no1];                 \\n              }              \\n              if(p!=-1){\\n                  long long curr=0;\\n                  if(no2>=1){\\n                      curr=(long long)(no2)*queries[i];\\n                  }\\n                  sum+=abs(p-curr);\\n              }\\n              if(s!=-1){\\n                  long long curr=0;\\n                  if(no1>=0 && no1<n){\\n                      \\n                      curr= (long long)(n-no1)*queries[i];\\n                  }                \\n                  sum+=abs(s-curr);\\n              }\\n             v.push_back(sum);\\n          }\\n            \\n        return v;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346765,
                "title": "python-simple-prefix-sum-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums, queries):\\n        nums.sort()\\n        ans, n, result = [0], len(nums), []\\n\\n        for num in nums:\\n            ans.append(ans[-1] + num)\\n\\n        for q in queries:\\n            idx = bisect.bisect_left(nums,q)\\n            result.append(q*idx - ans[idx] + ans[-1] - ans[idx] - q*(n-idx))\\n\\n        return result\\n\\n\\n        \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums, queries):\\n        nums.sort()\\n        ans, n, result = [0], len(nums), []\\n\\n        for num in nums:\\n            ans.append(ans[-1] + num)\\n\\n        for q in queries:\\n            idx = bisect.bisect_left(nums,q)\\n            result.append(q*idx - ans[idx] + ans[-1] - ans[idx] - q*(n-idx))\\n\\n        return result\\n\\n\\n        \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1843987,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nCalculate net increment and decrement separately and add them.\n\nFor e.g.:-\n`1 3 5 7 9`\n\nsay we need to convert all to `5`.\n\nwe find `5` at index `2`.\n\nbefore 5, there are 2 elements, whose sum is `1+3 = 4`. We want both of them to be 5, so as there are 2 elements, there final sum would be `2*5 = 10`.\n\nso required increment = `10-4 = 6.`\n\nSimilarly we can calculate decrement for the right side and finally add them. \n\nUse prefix sum to get sum left/right of any index.\n\nHope you will figure the rest out ! :)"
                    },
                    {
                        "username": "atulya_jaiswal",
                        "content": "Very nice explanation, thank you.\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Its a really good question for learning. 2-3 good algorithms/techniques are used to get the optimal time complexity."
                    },
                    {
                        "username": "sachin-123",
                        "content": "yup, i did it using BS and Prefix sum... there might be other way\\'s to solve it..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good problem to combine several algorithms in one solution"
                    },
                    {
                        "username": "vimal__divyendu",
                        "content": "class Solution {\\npublic:\\n    long long bs(long long int k,vector<int>nums,int n){\\n        long long int low=0;\\n        long long int high=n-1;\\n        long long int l=-1;\\n        while(low<=high){\\n            long long int mid=low+(high-low)/2;\\n            if(k>=nums[mid]){\\n                low=mid+1;\\n                l=mid;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long int>psum(n,0);\\n        psum[0]=nums[0];\\n        for(long long int i=1;i<n;i++){\\n            psum[i]=psum[i-1]+nums[i];\\n        }\\n        vector<long long int>v;\\n        for(long long int i=0;i<queries.size();i++){\\n            long long int k=queries[i];\\n            long long int pos=bs(k,nums,n);\\n            if(pos==-1){\\n                long long int r=psum[n-1]-(n*k);\\n                v.push_back(r);\\n                continue;\\n            }\\n            long long int u=0;\\n            u=k*(pos+1)-psum[pos];\\n            long long int e=n-pos-1;\\n            u+=(psum[n-1]-psum[pos])-(k*e);\\n            v.push_back(u);   \\n        }\\n        return v;\\n    }\\n};\\nWhy is my code giving memory limit exceeded at test case 25/31?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "To be honest, a very good question. I have learnt so much new things in this question. These type of questions keeps your interest in programming alive :)  Problem Upvoted"
                    },
                    {
                        "username": "Destravna",
                        "content": "how can u even come up with something like this on the spot ??????"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Can anybody say why below testcase giving me wrong answer for one element\\n## Code :\\n```\\n/**\\nfor a given query:\\nthere can be two types of element in arry\\n1. (num<=query) :\\nlet a = num of element which is <=query\\nfor this total increment(x) = a * query - (sum of a element); \\n(bascially expecteed sum - actual sum)\\n\\n2. num>query:\\nlet b = um of element which is >query\\ntotal increment(y) = sum of b elemnt - (b*query)\\n------\\ntotal = x+y\\nNow we sort the array and do binary search to get the element from where the logic starts for (num>query) -> at lo of index will find the element that starts the type 2\\nnow to get the sum at any index we prep the prefix sum arr\\nso formula becomes = query*(id) - prefix[id-1]\\nsimilary for second type getting the sum is tricky\\nsum = totalSum(basically prefix[n-1]) -  sum till mid(prefix[id-1])\\nthen increment can be = sum - (query* (n-id))\\n\\nNote : nums[0.....id-1] <=q\\nnums[id....n-1] >q\\nid will be at lo of binary search\\n\\n\\n */\\n\\nclass Solution {\\n    private int binarySearch(int[] nums, int q){\\n        int n = nums.length;\\n        int lo = 0;\\n        int hi = n-1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)>>1;\\n            if(nums[mid]<=q){\\n                lo = mid+1;\\n            }else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        prefix[0] = nums[0];\\n        if(n>1){\\n            //checking boundary for single element array\\n            for(int i = 1;i<n;i++){\\n                prefix[i] = prefix[i-1] + nums[i];\\n            }\\n        }\\n\\n        List<Long> ans  = new ArrayList<>();\\n        for(int q:queries){\\n            int id = binarySearch(nums,q);\\n            System.out.println(id);\\n            long x = -1;\\n            long y = -1;\\n            if(id==0){\\n                //no element lesser or equal to q\\n                x = 0;\\n                y = prefix[n-1] - (q*n);\\n\\n            }else if(id==n-1){\\n                //no element greater than to count\\n                y = 0;\\n                x = (q*id) - prefix[n-1];\\n            }else{\\n                x = (q*id) - prefix[id-1];\\n                y = prefix[n-1] - prefix[id-1]- (q*(n-id));\\n            }\\n            \\n            ans.add(x+y);\\n        }\\n\\n        return ans;\\n    \\n    }\\n}\\n```\\n\\n## Testcase\\n```\\nInput\\nnums =\\n[67,53,67,35,88,76,92,99,12,80,78,11,59,49,52,50,10,89,46,100,74,90,7,76,34,78,85,74,38,12,75,46,60,43,88,32,5,61,53,99,13,82,11,75,83,80,53,98,46,95,67,70,90,21,10,23,43,80,22,23,62,74,78,4,50,47,39,82,90,73,34,47,78,89,99,76,45,64,58,14,3,57,30,21,73,32,11,76,46]\\nqueries =\\n[59,60,14,62,61,83,45,73,45,76,73,12,50,11,55,92,22,74,73,23,32,80,73,84,92,76,82,43,22,62,80,22,53,46,82,79,75,53,76,5,51,83,77,3,50,76,98,78,49,76,19,9,6,5,27,42,41,90,52,53,75,67,76,97,49,32,76,78,99,83,23,21,72,10,73,35,25,34,34,60,66,88,13,46,49,73,38,34,78,12,99,82,89,74,14,85,47]\\n```\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1843860,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nCalculate net increment and decrement separately and add them.\n\nFor e.g.:-\n`1 3 5 7 9`\n\nsay we need to convert all to `5`.\n\nwe find `5` at index `2`.\n\nbefore 5, there are 2 elements, whose sum is `1+3 = 4`. We want both of them to be 5, so as there are 2 elements, there final sum would be `2*5 = 10`.\n\nso required increment = `10-4 = 6.`\n\nSimilarly we can calculate decrement for the right side and finally add them. \n\nUse prefix sum to get sum left/right of any index.\n\nHope you will figure the rest out ! :)"
                    },
                    {
                        "username": "atulya_jaiswal",
                        "content": "Very nice explanation, thank you.\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Its a really good question for learning. 2-3 good algorithms/techniques are used to get the optimal time complexity."
                    },
                    {
                        "username": "sachin-123",
                        "content": "yup, i did it using BS and Prefix sum... there might be other way\\'s to solve it..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good problem to combine several algorithms in one solution"
                    },
                    {
                        "username": "vimal__divyendu",
                        "content": "class Solution {\\npublic:\\n    long long bs(long long int k,vector<int>nums,int n){\\n        long long int low=0;\\n        long long int high=n-1;\\n        long long int l=-1;\\n        while(low<=high){\\n            long long int mid=low+(high-low)/2;\\n            if(k>=nums[mid]){\\n                low=mid+1;\\n                l=mid;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long int>psum(n,0);\\n        psum[0]=nums[0];\\n        for(long long int i=1;i<n;i++){\\n            psum[i]=psum[i-1]+nums[i];\\n        }\\n        vector<long long int>v;\\n        for(long long int i=0;i<queries.size();i++){\\n            long long int k=queries[i];\\n            long long int pos=bs(k,nums,n);\\n            if(pos==-1){\\n                long long int r=psum[n-1]-(n*k);\\n                v.push_back(r);\\n                continue;\\n            }\\n            long long int u=0;\\n            u=k*(pos+1)-psum[pos];\\n            long long int e=n-pos-1;\\n            u+=(psum[n-1]-psum[pos])-(k*e);\\n            v.push_back(u);   \\n        }\\n        return v;\\n    }\\n};\\nWhy is my code giving memory limit exceeded at test case 25/31?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "To be honest, a very good question. I have learnt so much new things in this question. These type of questions keeps your interest in programming alive :)  Problem Upvoted"
                    },
                    {
                        "username": "Destravna",
                        "content": "how can u even come up with something like this on the spot ??????"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Can anybody say why below testcase giving me wrong answer for one element\\n## Code :\\n```\\n/**\\nfor a given query:\\nthere can be two types of element in arry\\n1. (num<=query) :\\nlet a = num of element which is <=query\\nfor this total increment(x) = a * query - (sum of a element); \\n(bascially expecteed sum - actual sum)\\n\\n2. num>query:\\nlet b = um of element which is >query\\ntotal increment(y) = sum of b elemnt - (b*query)\\n------\\ntotal = x+y\\nNow we sort the array and do binary search to get the element from where the logic starts for (num>query) -> at lo of index will find the element that starts the type 2\\nnow to get the sum at any index we prep the prefix sum arr\\nso formula becomes = query*(id) - prefix[id-1]\\nsimilary for second type getting the sum is tricky\\nsum = totalSum(basically prefix[n-1]) -  sum till mid(prefix[id-1])\\nthen increment can be = sum - (query* (n-id))\\n\\nNote : nums[0.....id-1] <=q\\nnums[id....n-1] >q\\nid will be at lo of binary search\\n\\n\\n */\\n\\nclass Solution {\\n    private int binarySearch(int[] nums, int q){\\n        int n = nums.length;\\n        int lo = 0;\\n        int hi = n-1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)>>1;\\n            if(nums[mid]<=q){\\n                lo = mid+1;\\n            }else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        prefix[0] = nums[0];\\n        if(n>1){\\n            //checking boundary for single element array\\n            for(int i = 1;i<n;i++){\\n                prefix[i] = prefix[i-1] + nums[i];\\n            }\\n        }\\n\\n        List<Long> ans  = new ArrayList<>();\\n        for(int q:queries){\\n            int id = binarySearch(nums,q);\\n            System.out.println(id);\\n            long x = -1;\\n            long y = -1;\\n            if(id==0){\\n                //no element lesser or equal to q\\n                x = 0;\\n                y = prefix[n-1] - (q*n);\\n\\n            }else if(id==n-1){\\n                //no element greater than to count\\n                y = 0;\\n                x = (q*id) - prefix[n-1];\\n            }else{\\n                x = (q*id) - prefix[id-1];\\n                y = prefix[n-1] - prefix[id-1]- (q*(n-id));\\n            }\\n            \\n            ans.add(x+y);\\n        }\\n\\n        return ans;\\n    \\n    }\\n}\\n```\\n\\n## Testcase\\n```\\nInput\\nnums =\\n[67,53,67,35,88,76,92,99,12,80,78,11,59,49,52,50,10,89,46,100,74,90,7,76,34,78,85,74,38,12,75,46,60,43,88,32,5,61,53,99,13,82,11,75,83,80,53,98,46,95,67,70,90,21,10,23,43,80,22,23,62,74,78,4,50,47,39,82,90,73,34,47,78,89,99,76,45,64,58,14,3,57,30,21,73,32,11,76,46]\\nqueries =\\n[59,60,14,62,61,83,45,73,45,76,73,12,50,11,55,92,22,74,73,23,32,80,73,84,92,76,82,43,22,62,80,22,53,46,82,79,75,53,76,5,51,83,77,3,50,76,98,78,49,76,19,9,6,5,27,42,41,90,52,53,75,67,76,97,49,32,76,78,99,83,23,21,72,10,73,35,25,34,34,60,66,88,13,46,49,73,38,34,78,12,99,82,89,74,14,85,47]\\n```\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1857564,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nCalculate net increment and decrement separately and add them.\n\nFor e.g.:-\n`1 3 5 7 9`\n\nsay we need to convert all to `5`.\n\nwe find `5` at index `2`.\n\nbefore 5, there are 2 elements, whose sum is `1+3 = 4`. We want both of them to be 5, so as there are 2 elements, there final sum would be `2*5 = 10`.\n\nso required increment = `10-4 = 6.`\n\nSimilarly we can calculate decrement for the right side and finally add them. \n\nUse prefix sum to get sum left/right of any index.\n\nHope you will figure the rest out ! :)"
                    },
                    {
                        "username": "atulya_jaiswal",
                        "content": "Very nice explanation, thank you.\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Its a really good question for learning. 2-3 good algorithms/techniques are used to get the optimal time complexity."
                    },
                    {
                        "username": "sachin-123",
                        "content": "yup, i did it using BS and Prefix sum... there might be other way\\'s to solve it..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good problem to combine several algorithms in one solution"
                    },
                    {
                        "username": "vimal__divyendu",
                        "content": "class Solution {\\npublic:\\n    long long bs(long long int k,vector<int>nums,int n){\\n        long long int low=0;\\n        long long int high=n-1;\\n        long long int l=-1;\\n        while(low<=high){\\n            long long int mid=low+(high-low)/2;\\n            if(k>=nums[mid]){\\n                low=mid+1;\\n                l=mid;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long int>psum(n,0);\\n        psum[0]=nums[0];\\n        for(long long int i=1;i<n;i++){\\n            psum[i]=psum[i-1]+nums[i];\\n        }\\n        vector<long long int>v;\\n        for(long long int i=0;i<queries.size();i++){\\n            long long int k=queries[i];\\n            long long int pos=bs(k,nums,n);\\n            if(pos==-1){\\n                long long int r=psum[n-1]-(n*k);\\n                v.push_back(r);\\n                continue;\\n            }\\n            long long int u=0;\\n            u=k*(pos+1)-psum[pos];\\n            long long int e=n-pos-1;\\n            u+=(psum[n-1]-psum[pos])-(k*e);\\n            v.push_back(u);   \\n        }\\n        return v;\\n    }\\n};\\nWhy is my code giving memory limit exceeded at test case 25/31?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "To be honest, a very good question. I have learnt so much new things in this question. These type of questions keeps your interest in programming alive :)  Problem Upvoted"
                    },
                    {
                        "username": "Destravna",
                        "content": "how can u even come up with something like this on the spot ??????"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Can anybody say why below testcase giving me wrong answer for one element\\n## Code :\\n```\\n/**\\nfor a given query:\\nthere can be two types of element in arry\\n1. (num<=query) :\\nlet a = num of element which is <=query\\nfor this total increment(x) = a * query - (sum of a element); \\n(bascially expecteed sum - actual sum)\\n\\n2. num>query:\\nlet b = um of element which is >query\\ntotal increment(y) = sum of b elemnt - (b*query)\\n------\\ntotal = x+y\\nNow we sort the array and do binary search to get the element from where the logic starts for (num>query) -> at lo of index will find the element that starts the type 2\\nnow to get the sum at any index we prep the prefix sum arr\\nso formula becomes = query*(id) - prefix[id-1]\\nsimilary for second type getting the sum is tricky\\nsum = totalSum(basically prefix[n-1]) -  sum till mid(prefix[id-1])\\nthen increment can be = sum - (query* (n-id))\\n\\nNote : nums[0.....id-1] <=q\\nnums[id....n-1] >q\\nid will be at lo of binary search\\n\\n\\n */\\n\\nclass Solution {\\n    private int binarySearch(int[] nums, int q){\\n        int n = nums.length;\\n        int lo = 0;\\n        int hi = n-1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)>>1;\\n            if(nums[mid]<=q){\\n                lo = mid+1;\\n            }else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        prefix[0] = nums[0];\\n        if(n>1){\\n            //checking boundary for single element array\\n            for(int i = 1;i<n;i++){\\n                prefix[i] = prefix[i-1] + nums[i];\\n            }\\n        }\\n\\n        List<Long> ans  = new ArrayList<>();\\n        for(int q:queries){\\n            int id = binarySearch(nums,q);\\n            System.out.println(id);\\n            long x = -1;\\n            long y = -1;\\n            if(id==0){\\n                //no element lesser or equal to q\\n                x = 0;\\n                y = prefix[n-1] - (q*n);\\n\\n            }else if(id==n-1){\\n                //no element greater than to count\\n                y = 0;\\n                x = (q*id) - prefix[n-1];\\n            }else{\\n                x = (q*id) - prefix[id-1];\\n                y = prefix[n-1] - prefix[id-1]- (q*(n-id));\\n            }\\n            \\n            ans.add(x+y);\\n        }\\n\\n        return ans;\\n    \\n    }\\n}\\n```\\n\\n## Testcase\\n```\\nInput\\nnums =\\n[67,53,67,35,88,76,92,99,12,80,78,11,59,49,52,50,10,89,46,100,74,90,7,76,34,78,85,74,38,12,75,46,60,43,88,32,5,61,53,99,13,82,11,75,83,80,53,98,46,95,67,70,90,21,10,23,43,80,22,23,62,74,78,4,50,47,39,82,90,73,34,47,78,89,99,76,45,64,58,14,3,57,30,21,73,32,11,76,46]\\nqueries =\\n[59,60,14,62,61,83,45,73,45,76,73,12,50,11,55,92,22,74,73,23,32,80,73,84,92,76,82,43,22,62,80,22,53,46,82,79,75,53,76,5,51,83,77,3,50,76,98,78,49,76,19,9,6,5,27,42,41,90,52,53,75,67,76,97,49,32,76,78,99,83,23,21,72,10,73,35,25,34,34,60,66,88,13,46,49,73,38,34,78,12,99,82,89,74,14,85,47]\\n```\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015016,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nCalculate net increment and decrement separately and add them.\n\nFor e.g.:-\n`1 3 5 7 9`\n\nsay we need to convert all to `5`.\n\nwe find `5` at index `2`.\n\nbefore 5, there are 2 elements, whose sum is `1+3 = 4`. We want both of them to be 5, so as there are 2 elements, there final sum would be `2*5 = 10`.\n\nso required increment = `10-4 = 6.`\n\nSimilarly we can calculate decrement for the right side and finally add them. \n\nUse prefix sum to get sum left/right of any index.\n\nHope you will figure the rest out ! :)"
                    },
                    {
                        "username": "atulya_jaiswal",
                        "content": "Very nice explanation, thank you.\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Its a really good question for learning. 2-3 good algorithms/techniques are used to get the optimal time complexity."
                    },
                    {
                        "username": "sachin-123",
                        "content": "yup, i did it using BS and Prefix sum... there might be other way\\'s to solve it..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good problem to combine several algorithms in one solution"
                    },
                    {
                        "username": "vimal__divyendu",
                        "content": "class Solution {\\npublic:\\n    long long bs(long long int k,vector<int>nums,int n){\\n        long long int low=0;\\n        long long int high=n-1;\\n        long long int l=-1;\\n        while(low<=high){\\n            long long int mid=low+(high-low)/2;\\n            if(k>=nums[mid]){\\n                low=mid+1;\\n                l=mid;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long int>psum(n,0);\\n        psum[0]=nums[0];\\n        for(long long int i=1;i<n;i++){\\n            psum[i]=psum[i-1]+nums[i];\\n        }\\n        vector<long long int>v;\\n        for(long long int i=0;i<queries.size();i++){\\n            long long int k=queries[i];\\n            long long int pos=bs(k,nums,n);\\n            if(pos==-1){\\n                long long int r=psum[n-1]-(n*k);\\n                v.push_back(r);\\n                continue;\\n            }\\n            long long int u=0;\\n            u=k*(pos+1)-psum[pos];\\n            long long int e=n-pos-1;\\n            u+=(psum[n-1]-psum[pos])-(k*e);\\n            v.push_back(u);   \\n        }\\n        return v;\\n    }\\n};\\nWhy is my code giving memory limit exceeded at test case 25/31?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "To be honest, a very good question. I have learnt so much new things in this question. These type of questions keeps your interest in programming alive :)  Problem Upvoted"
                    },
                    {
                        "username": "Destravna",
                        "content": "how can u even come up with something like this on the spot ??????"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Can anybody say why below testcase giving me wrong answer for one element\\n## Code :\\n```\\n/**\\nfor a given query:\\nthere can be two types of element in arry\\n1. (num<=query) :\\nlet a = num of element which is <=query\\nfor this total increment(x) = a * query - (sum of a element); \\n(bascially expecteed sum - actual sum)\\n\\n2. num>query:\\nlet b = um of element which is >query\\ntotal increment(y) = sum of b elemnt - (b*query)\\n------\\ntotal = x+y\\nNow we sort the array and do binary search to get the element from where the logic starts for (num>query) -> at lo of index will find the element that starts the type 2\\nnow to get the sum at any index we prep the prefix sum arr\\nso formula becomes = query*(id) - prefix[id-1]\\nsimilary for second type getting the sum is tricky\\nsum = totalSum(basically prefix[n-1]) -  sum till mid(prefix[id-1])\\nthen increment can be = sum - (query* (n-id))\\n\\nNote : nums[0.....id-1] <=q\\nnums[id....n-1] >q\\nid will be at lo of binary search\\n\\n\\n */\\n\\nclass Solution {\\n    private int binarySearch(int[] nums, int q){\\n        int n = nums.length;\\n        int lo = 0;\\n        int hi = n-1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)>>1;\\n            if(nums[mid]<=q){\\n                lo = mid+1;\\n            }else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        prefix[0] = nums[0];\\n        if(n>1){\\n            //checking boundary for single element array\\n            for(int i = 1;i<n;i++){\\n                prefix[i] = prefix[i-1] + nums[i];\\n            }\\n        }\\n\\n        List<Long> ans  = new ArrayList<>();\\n        for(int q:queries){\\n            int id = binarySearch(nums,q);\\n            System.out.println(id);\\n            long x = -1;\\n            long y = -1;\\n            if(id==0){\\n                //no element lesser or equal to q\\n                x = 0;\\n                y = prefix[n-1] - (q*n);\\n\\n            }else if(id==n-1){\\n                //no element greater than to count\\n                y = 0;\\n                x = (q*id) - prefix[n-1];\\n            }else{\\n                x = (q*id) - prefix[id-1];\\n                y = prefix[n-1] - prefix[id-1]- (q*(n-id));\\n            }\\n            \\n            ans.add(x+y);\\n        }\\n\\n        return ans;\\n    \\n    }\\n}\\n```\\n\\n## Testcase\\n```\\nInput\\nnums =\\n[67,53,67,35,88,76,92,99,12,80,78,11,59,49,52,50,10,89,46,100,74,90,7,76,34,78,85,74,38,12,75,46,60,43,88,32,5,61,53,99,13,82,11,75,83,80,53,98,46,95,67,70,90,21,10,23,43,80,22,23,62,74,78,4,50,47,39,82,90,73,34,47,78,89,99,76,45,64,58,14,3,57,30,21,73,32,11,76,46]\\nqueries =\\n[59,60,14,62,61,83,45,73,45,76,73,12,50,11,55,92,22,74,73,23,32,80,73,84,92,76,82,43,22,62,80,22,53,46,82,79,75,53,76,5,51,83,77,3,50,76,98,78,49,76,19,9,6,5,27,42,41,90,52,53,75,67,76,97,49,32,76,78,99,83,23,21,72,10,73,35,25,34,34,60,66,88,13,46,49,73,38,34,78,12,99,82,89,74,14,85,47]\\n```\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2014374,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nCalculate net increment and decrement separately and add them.\n\nFor e.g.:-\n`1 3 5 7 9`\n\nsay we need to convert all to `5`.\n\nwe find `5` at index `2`.\n\nbefore 5, there are 2 elements, whose sum is `1+3 = 4`. We want both of them to be 5, so as there are 2 elements, there final sum would be `2*5 = 10`.\n\nso required increment = `10-4 = 6.`\n\nSimilarly we can calculate decrement for the right side and finally add them. \n\nUse prefix sum to get sum left/right of any index.\n\nHope you will figure the rest out ! :)"
                    },
                    {
                        "username": "atulya_jaiswal",
                        "content": "Very nice explanation, thank you.\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Its a really good question for learning. 2-3 good algorithms/techniques are used to get the optimal time complexity."
                    },
                    {
                        "username": "sachin-123",
                        "content": "yup, i did it using BS and Prefix sum... there might be other way\\'s to solve it..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good problem to combine several algorithms in one solution"
                    },
                    {
                        "username": "vimal__divyendu",
                        "content": "class Solution {\\npublic:\\n    long long bs(long long int k,vector<int>nums,int n){\\n        long long int low=0;\\n        long long int high=n-1;\\n        long long int l=-1;\\n        while(low<=high){\\n            long long int mid=low+(high-low)/2;\\n            if(k>=nums[mid]){\\n                low=mid+1;\\n                l=mid;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long int>psum(n,0);\\n        psum[0]=nums[0];\\n        for(long long int i=1;i<n;i++){\\n            psum[i]=psum[i-1]+nums[i];\\n        }\\n        vector<long long int>v;\\n        for(long long int i=0;i<queries.size();i++){\\n            long long int k=queries[i];\\n            long long int pos=bs(k,nums,n);\\n            if(pos==-1){\\n                long long int r=psum[n-1]-(n*k);\\n                v.push_back(r);\\n                continue;\\n            }\\n            long long int u=0;\\n            u=k*(pos+1)-psum[pos];\\n            long long int e=n-pos-1;\\n            u+=(psum[n-1]-psum[pos])-(k*e);\\n            v.push_back(u);   \\n        }\\n        return v;\\n    }\\n};\\nWhy is my code giving memory limit exceeded at test case 25/31?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "To be honest, a very good question. I have learnt so much new things in this question. These type of questions keeps your interest in programming alive :)  Problem Upvoted"
                    },
                    {
                        "username": "Destravna",
                        "content": "how can u even come up with something like this on the spot ??????"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Can anybody say why below testcase giving me wrong answer for one element\\n## Code :\\n```\\n/**\\nfor a given query:\\nthere can be two types of element in arry\\n1. (num<=query) :\\nlet a = num of element which is <=query\\nfor this total increment(x) = a * query - (sum of a element); \\n(bascially expecteed sum - actual sum)\\n\\n2. num>query:\\nlet b = um of element which is >query\\ntotal increment(y) = sum of b elemnt - (b*query)\\n------\\ntotal = x+y\\nNow we sort the array and do binary search to get the element from where the logic starts for (num>query) -> at lo of index will find the element that starts the type 2\\nnow to get the sum at any index we prep the prefix sum arr\\nso formula becomes = query*(id) - prefix[id-1]\\nsimilary for second type getting the sum is tricky\\nsum = totalSum(basically prefix[n-1]) -  sum till mid(prefix[id-1])\\nthen increment can be = sum - (query* (n-id))\\n\\nNote : nums[0.....id-1] <=q\\nnums[id....n-1] >q\\nid will be at lo of binary search\\n\\n\\n */\\n\\nclass Solution {\\n    private int binarySearch(int[] nums, int q){\\n        int n = nums.length;\\n        int lo = 0;\\n        int hi = n-1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)>>1;\\n            if(nums[mid]<=q){\\n                lo = mid+1;\\n            }else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        prefix[0] = nums[0];\\n        if(n>1){\\n            //checking boundary for single element array\\n            for(int i = 1;i<n;i++){\\n                prefix[i] = prefix[i-1] + nums[i];\\n            }\\n        }\\n\\n        List<Long> ans  = new ArrayList<>();\\n        for(int q:queries){\\n            int id = binarySearch(nums,q);\\n            System.out.println(id);\\n            long x = -1;\\n            long y = -1;\\n            if(id==0){\\n                //no element lesser or equal to q\\n                x = 0;\\n                y = prefix[n-1] - (q*n);\\n\\n            }else if(id==n-1){\\n                //no element greater than to count\\n                y = 0;\\n                x = (q*id) - prefix[n-1];\\n            }else{\\n                x = (q*id) - prefix[id-1];\\n                y = prefix[n-1] - prefix[id-1]- (q*(n-id));\\n            }\\n            \\n            ans.add(x+y);\\n        }\\n\\n        return ans;\\n    \\n    }\\n}\\n```\\n\\n## Testcase\\n```\\nInput\\nnums =\\n[67,53,67,35,88,76,92,99,12,80,78,11,59,49,52,50,10,89,46,100,74,90,7,76,34,78,85,74,38,12,75,46,60,43,88,32,5,61,53,99,13,82,11,75,83,80,53,98,46,95,67,70,90,21,10,23,43,80,22,23,62,74,78,4,50,47,39,82,90,73,34,47,78,89,99,76,45,64,58,14,3,57,30,21,73,32,11,76,46]\\nqueries =\\n[59,60,14,62,61,83,45,73,45,76,73,12,50,11,55,92,22,74,73,23,32,80,73,84,92,76,82,43,22,62,80,22,53,46,82,79,75,53,76,5,51,83,77,3,50,76,98,78,49,76,19,9,6,5,27,42,41,90,52,53,75,67,76,97,49,32,76,78,99,83,23,21,72,10,73,35,25,34,34,60,66,88,13,46,49,73,38,34,78,12,99,82,89,74,14,85,47]\\n```\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1985806,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nCalculate net increment and decrement separately and add them.\n\nFor e.g.:-\n`1 3 5 7 9`\n\nsay we need to convert all to `5`.\n\nwe find `5` at index `2`.\n\nbefore 5, there are 2 elements, whose sum is `1+3 = 4`. We want both of them to be 5, so as there are 2 elements, there final sum would be `2*5 = 10`.\n\nso required increment = `10-4 = 6.`\n\nSimilarly we can calculate decrement for the right side and finally add them. \n\nUse prefix sum to get sum left/right of any index.\n\nHope you will figure the rest out ! :)"
                    },
                    {
                        "username": "atulya_jaiswal",
                        "content": "Very nice explanation, thank you.\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Its a really good question for learning. 2-3 good algorithms/techniques are used to get the optimal time complexity."
                    },
                    {
                        "username": "sachin-123",
                        "content": "yup, i did it using BS and Prefix sum... there might be other way\\'s to solve it..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good problem to combine several algorithms in one solution"
                    },
                    {
                        "username": "vimal__divyendu",
                        "content": "class Solution {\\npublic:\\n    long long bs(long long int k,vector<int>nums,int n){\\n        long long int low=0;\\n        long long int high=n-1;\\n        long long int l=-1;\\n        while(low<=high){\\n            long long int mid=low+(high-low)/2;\\n            if(k>=nums[mid]){\\n                low=mid+1;\\n                l=mid;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long int>psum(n,0);\\n        psum[0]=nums[0];\\n        for(long long int i=1;i<n;i++){\\n            psum[i]=psum[i-1]+nums[i];\\n        }\\n        vector<long long int>v;\\n        for(long long int i=0;i<queries.size();i++){\\n            long long int k=queries[i];\\n            long long int pos=bs(k,nums,n);\\n            if(pos==-1){\\n                long long int r=psum[n-1]-(n*k);\\n                v.push_back(r);\\n                continue;\\n            }\\n            long long int u=0;\\n            u=k*(pos+1)-psum[pos];\\n            long long int e=n-pos-1;\\n            u+=(psum[n-1]-psum[pos])-(k*e);\\n            v.push_back(u);   \\n        }\\n        return v;\\n    }\\n};\\nWhy is my code giving memory limit exceeded at test case 25/31?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "To be honest, a very good question. I have learnt so much new things in this question. These type of questions keeps your interest in programming alive :)  Problem Upvoted"
                    },
                    {
                        "username": "Destravna",
                        "content": "how can u even come up with something like this on the spot ??????"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Can anybody say why below testcase giving me wrong answer for one element\\n## Code :\\n```\\n/**\\nfor a given query:\\nthere can be two types of element in arry\\n1. (num<=query) :\\nlet a = num of element which is <=query\\nfor this total increment(x) = a * query - (sum of a element); \\n(bascially expecteed sum - actual sum)\\n\\n2. num>query:\\nlet b = um of element which is >query\\ntotal increment(y) = sum of b elemnt - (b*query)\\n------\\ntotal = x+y\\nNow we sort the array and do binary search to get the element from where the logic starts for (num>query) -> at lo of index will find the element that starts the type 2\\nnow to get the sum at any index we prep the prefix sum arr\\nso formula becomes = query*(id) - prefix[id-1]\\nsimilary for second type getting the sum is tricky\\nsum = totalSum(basically prefix[n-1]) -  sum till mid(prefix[id-1])\\nthen increment can be = sum - (query* (n-id))\\n\\nNote : nums[0.....id-1] <=q\\nnums[id....n-1] >q\\nid will be at lo of binary search\\n\\n\\n */\\n\\nclass Solution {\\n    private int binarySearch(int[] nums, int q){\\n        int n = nums.length;\\n        int lo = 0;\\n        int hi = n-1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)>>1;\\n            if(nums[mid]<=q){\\n                lo = mid+1;\\n            }else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        prefix[0] = nums[0];\\n        if(n>1){\\n            //checking boundary for single element array\\n            for(int i = 1;i<n;i++){\\n                prefix[i] = prefix[i-1] + nums[i];\\n            }\\n        }\\n\\n        List<Long> ans  = new ArrayList<>();\\n        for(int q:queries){\\n            int id = binarySearch(nums,q);\\n            System.out.println(id);\\n            long x = -1;\\n            long y = -1;\\n            if(id==0){\\n                //no element lesser or equal to q\\n                x = 0;\\n                y = prefix[n-1] - (q*n);\\n\\n            }else if(id==n-1){\\n                //no element greater than to count\\n                y = 0;\\n                x = (q*id) - prefix[n-1];\\n            }else{\\n                x = (q*id) - prefix[id-1];\\n                y = prefix[n-1] - prefix[id-1]- (q*(n-id));\\n            }\\n            \\n            ans.add(x+y);\\n        }\\n\\n        return ans;\\n    \\n    }\\n}\\n```\\n\\n## Testcase\\n```\\nInput\\nnums =\\n[67,53,67,35,88,76,92,99,12,80,78,11,59,49,52,50,10,89,46,100,74,90,7,76,34,78,85,74,38,12,75,46,60,43,88,32,5,61,53,99,13,82,11,75,83,80,53,98,46,95,67,70,90,21,10,23,43,80,22,23,62,74,78,4,50,47,39,82,90,73,34,47,78,89,99,76,45,64,58,14,3,57,30,21,73,32,11,76,46]\\nqueries =\\n[59,60,14,62,61,83,45,73,45,76,73,12,50,11,55,92,22,74,73,23,32,80,73,84,92,76,82,43,22,62,80,22,53,46,82,79,75,53,76,5,51,83,77,3,50,76,98,78,49,76,19,9,6,5,27,42,41,90,52,53,75,67,76,97,49,32,76,78,99,83,23,21,72,10,73,35,25,34,34,60,66,88,13,46,49,73,38,34,78,12,99,82,89,74,14,85,47]\\n```\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1845592,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nCalculate net increment and decrement separately and add them.\n\nFor e.g.:-\n`1 3 5 7 9`\n\nsay we need to convert all to `5`.\n\nwe find `5` at index `2`.\n\nbefore 5, there are 2 elements, whose sum is `1+3 = 4`. We want both of them to be 5, so as there are 2 elements, there final sum would be `2*5 = 10`.\n\nso required increment = `10-4 = 6.`\n\nSimilarly we can calculate decrement for the right side and finally add them. \n\nUse prefix sum to get sum left/right of any index.\n\nHope you will figure the rest out ! :)"
                    },
                    {
                        "username": "atulya_jaiswal",
                        "content": "Very nice explanation, thank you.\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Its a really good question for learning. 2-3 good algorithms/techniques are used to get the optimal time complexity."
                    },
                    {
                        "username": "sachin-123",
                        "content": "yup, i did it using BS and Prefix sum... there might be other way\\'s to solve it..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good problem to combine several algorithms in one solution"
                    },
                    {
                        "username": "vimal__divyendu",
                        "content": "class Solution {\\npublic:\\n    long long bs(long long int k,vector<int>nums,int n){\\n        long long int low=0;\\n        long long int high=n-1;\\n        long long int l=-1;\\n        while(low<=high){\\n            long long int mid=low+(high-low)/2;\\n            if(k>=nums[mid]){\\n                low=mid+1;\\n                l=mid;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\\n        long long int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long int>psum(n,0);\\n        psum[0]=nums[0];\\n        for(long long int i=1;i<n;i++){\\n            psum[i]=psum[i-1]+nums[i];\\n        }\\n        vector<long long int>v;\\n        for(long long int i=0;i<queries.size();i++){\\n            long long int k=queries[i];\\n            long long int pos=bs(k,nums,n);\\n            if(pos==-1){\\n                long long int r=psum[n-1]-(n*k);\\n                v.push_back(r);\\n                continue;\\n            }\\n            long long int u=0;\\n            u=k*(pos+1)-psum[pos];\\n            long long int e=n-pos-1;\\n            u+=(psum[n-1]-psum[pos])-(k*e);\\n            v.push_back(u);   \\n        }\\n        return v;\\n    }\\n};\\nWhy is my code giving memory limit exceeded at test case 25/31?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "To be honest, a very good question. I have learnt so much new things in this question. These type of questions keeps your interest in programming alive :)  Problem Upvoted"
                    },
                    {
                        "username": "Destravna",
                        "content": "how can u even come up with something like this on the spot ??????"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Can anybody say why below testcase giving me wrong answer for one element\\n## Code :\\n```\\n/**\\nfor a given query:\\nthere can be two types of element in arry\\n1. (num<=query) :\\nlet a = num of element which is <=query\\nfor this total increment(x) = a * query - (sum of a element); \\n(bascially expecteed sum - actual sum)\\n\\n2. num>query:\\nlet b = um of element which is >query\\ntotal increment(y) = sum of b elemnt - (b*query)\\n------\\ntotal = x+y\\nNow we sort the array and do binary search to get the element from where the logic starts for (num>query) -> at lo of index will find the element that starts the type 2\\nnow to get the sum at any index we prep the prefix sum arr\\nso formula becomes = query*(id) - prefix[id-1]\\nsimilary for second type getting the sum is tricky\\nsum = totalSum(basically prefix[n-1]) -  sum till mid(prefix[id-1])\\nthen increment can be = sum - (query* (n-id))\\n\\nNote : nums[0.....id-1] <=q\\nnums[id....n-1] >q\\nid will be at lo of binary search\\n\\n\\n */\\n\\nclass Solution {\\n    private int binarySearch(int[] nums, int q){\\n        int n = nums.length;\\n        int lo = 0;\\n        int hi = n-1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)>>1;\\n            if(nums[mid]<=q){\\n                lo = mid+1;\\n            }else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        prefix[0] = nums[0];\\n        if(n>1){\\n            //checking boundary for single element array\\n            for(int i = 1;i<n;i++){\\n                prefix[i] = prefix[i-1] + nums[i];\\n            }\\n        }\\n\\n        List<Long> ans  = new ArrayList<>();\\n        for(int q:queries){\\n            int id = binarySearch(nums,q);\\n            System.out.println(id);\\n            long x = -1;\\n            long y = -1;\\n            if(id==0){\\n                //no element lesser or equal to q\\n                x = 0;\\n                y = prefix[n-1] - (q*n);\\n\\n            }else if(id==n-1){\\n                //no element greater than to count\\n                y = 0;\\n                x = (q*id) - prefix[n-1];\\n            }else{\\n                x = (q*id) - prefix[id-1];\\n                y = prefix[n-1] - prefix[id-1]- (q*(n-id));\\n            }\\n            \\n            ans.add(x+y);\\n        }\\n\\n        return ans;\\n    \\n    }\\n}\\n```\\n\\n## Testcase\\n```\\nInput\\nnums =\\n[67,53,67,35,88,76,92,99,12,80,78,11,59,49,52,50,10,89,46,100,74,90,7,76,34,78,85,74,38,12,75,46,60,43,88,32,5,61,53,99,13,82,11,75,83,80,53,98,46,95,67,70,90,21,10,23,43,80,22,23,62,74,78,4,50,47,39,82,90,73,34,47,78,89,99,76,45,64,58,14,3,57,30,21,73,32,11,76,46]\\nqueries =\\n[59,60,14,62,61,83,45,73,45,76,73,12,50,11,55,92,22,74,73,23,32,80,73,84,92,76,82,43,22,62,80,22,53,46,82,79,75,53,76,5,51,83,77,3,50,76,98,78,49,76,19,9,6,5,27,42,41,90,52,53,75,67,76,97,49,32,76,78,99,83,23,21,72,10,73,35,25,34,34,60,66,88,13,46,49,73,38,34,78,12,99,82,89,74,14,85,47]\\n```\\n\\n\\n"
                    }
                ]
            }
        ]
    }
]