[
    {
        "title": "Maximum Rows Covered by Columns",
        "question_content": "You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\nLet us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\n\n\tFor each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\n\tNo cell in row has a value of 1.\n\nYou need to choose numSelect columns such that the number of rows that are covered is maximized.\nReturn the maximum number of rows that can be covered by a set of numSelect columns.\n&nbsp;\nExample 1:\n\nInput: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2\nOutput: 3\nExplanation: One possible way to cover 3 rows is shown in the diagram above.\nWe choose s = {0, 2}.\n- Row 0 is covered because it has no occurrences of 1.\n- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.\n- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.\n- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.\nThus, we can cover three rows.\nNote that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.\n\nExample 2:\n\nInput: matrix = [[1],[0]], numSelect = 1\nOutput: 2\nExplanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.\nTherefore, we return 2.\n\n&nbsp;\nConstraints:\n\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 12\n\tmatrix[i][j] is either 0 or 1.\n\t1 <= numSelect&nbsp;<= n",
        "solutions": [
            {
                "id": 2524995,
                "title": "who-dont-understand-code",
                "content": "why these type of problems in contest \\ni dont even understand problem",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2524673,
                "title": "brute-force-bit-magic",
                "content": "\\nLow constraints give away a brute-force solution.\\n    \\nWe try all combinations of columns (using a bit mask), where the number of columns does not exceed `cols`.\\n    \\nFor each combination, we count covered rows, and return the maximum.\\n    \\nAs an optimization, we can only consider bit masks with `cols` bits. We start from `(1 << cols) - 1`.\\n\\nThen, we use `next_popcount` to get the next mask with the same number of bits.\\n    \\n**C++**\\n```cpp\\nint next_popcount(int n) {\\n    int c = (n & -n), r = n + c;\\n    return (((r ^ n) >> 2) / c) | r;\\n}\\nint maximumRows(vector<vector<int>>& mat, int cols) {\\n    int m = mat.size(), n = mat[0].size(), res = 0;\\n    for (int mask = (1 << cols) - 1; mask < (1 << n); mask = next_popcount(mask)) {\\n        int rows = 0;\\n        for (int i = 0, j = 0; i < m; ++i) {\\n            for (j = 0; j < n; ++j)\\n                if (mat[i][j] && (mask & (1 << j)) == 0)\\n                    break;\\n            rows += j == n;\\n        }\\n        res = max(res, rows);\\n    }\\n    return res;\\n}",
                "solutionTags": [],
                "code": "\\nLow constraints give away a brute-force solution.\\n    \\nWe try all combinations of columns (using a bit mask), where the number of columns does not exceed `cols`.\\n    \\nFor each combination, we count covered rows, and return the maximum.\\n    \\nAs an optimization, we can only consider bit masks with `cols` bits. We start from `(1 << cols) - 1`.\\n\\nThen, we use `next_popcount` to get the next mask with the same number of bits.\\n    \\n**C++**\\n```cpp\\nint next_popcount(int n) {\\n    int c = (n & -n), r = n + c;\\n    return (((r ^ n) >> 2) / c) | r;\\n}\\nint maximumRows(vector<vector<int>>& mat, int cols) {\\n    int m = mat.size(), n = mat[0].size(), res = 0;\\n    for (int mask = (1 << cols) - 1; mask < (1 << n); mask = next_popcount(mask)) {\\n        int rows = 0;\\n        for (int i = 0, j = 0; i < m; ++i) {\\n            for (j = 0; j < n; ++j)\\n                if (mat[i][j] && (mask & (1 << j)) == 0)\\n                    break;\\n            rows += j == n;\\n        }\\n        res = max(res, rows);\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2524774,
                "title": "bit-masking",
                "content": "**Idea** : Generate all possible combinations to select columns, then check what asked.\\n*i\\'th* bit in mask is set if we are considering taking that column, otherwise it will be zero.\\n-Total of \\'2 power columns\\' `(1<<total_columns)` combinations are possible.\\n\\n```\\nclass Solution {\\n\\n    public int maximumRows(int[][] mat, int cols) {\\n        int max = 0;\\n        for (int mask = 0; mask < (1 << mat[0].length); mask++) {\\n            if (Integer.bitCount(mask) != cols) continue; // restricted to select ony cols columns\\n            int c = 0;\\n            for (int i = 0; i < mat.length; i++) {\\n                boolean take = true;\\n                for (int j = 0; j < mat[0].length; j++) {\\n                    if ((mask >> j & 1) == 0 && mat[i][j] == 1) {\\n                        take = false;\\n                        break;\\n                    }\\n                }\\n                if (take) c++;\\n            }\\n            max = Math.max(max, c);\\n        }\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int maximumRows(int[][] mat, int cols) {\\n        int max = 0;\\n        for (int mask = 0; mask < (1 << mat[0].length); mask++) {\\n            if (Integer.bitCount(mask) != cols) continue; // restricted to select ony cols columns\\n            int c = 0;\\n            for (int i = 0; i < mat.length; i++) {\\n                boolean take = true;\\n                for (int j = 0; j < mat[0].length; j++) {\\n                    if ((mask >> j & 1) == 0 && mat[i][j] == 1) {\\n                        take = false;\\n                        break;\\n                    }\\n                }\\n                if (take) c++;\\n            }\\n            max = Math.max(max, c);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525117,
                "title": "c-backtracking",
                "content": "**What is Asked ?**\\n `We have to find the maximum rows in which all cells having 1 should be covered by column we picking`\\n\\n**How to Do ?**\\n```\\n1. We make a recursive function in which we will pick column and not pick it\\n2. picking a column means we marked it as visited\\n3. When we reached base case we will traverse whole matrix which tells us that\\nwhether we can pick a row or not , we can pick a row only when \\'1\\' s in it are visited which \\nwe can verify by visited arrray\\n```\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int maxi = INT_MIN;\\n    void helper(vector<vector<int>> &mat , int m , int n , int cols , int idx , vector<int> &vis){\\n        if(cols == 0 or idx==n){\\n            int cnt = 0;\\n            for(int p = 0 ; p < m ; p++){\\n                bool check = true;\\n                for(int q = 0 ; q < n; q++){\\n                    // if cell is 1 and not visited then we cannot take this row\\n                    if(mat[p][q] == 1 and vis[q] == 0){\\n                        check = false;\\n                        break;\\n                    }\\n                }\\n                if(check) cnt++;\\n            }\\n            maxi = max(maxi,cnt);\\n            return;\\n        }\\n        \\n        // picking idx th column and marking column as visited\\n        vis[idx]=1;\\n        helper(mat,m,n,cols-1,idx+1,vis);\\n        vis[idx]=0;\\n        \\n        // not picking\\n        helper(mat,m,n,cols,idx+1,vis);\\n        return;\\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<int> vis(n);\\n        \\n        helper(mat,m,n,cols,0,vis);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. We make a recursive function in which we will pick column and not pick it\\n2. picking a column means we marked it as visited\\n3. When we reached base case we will traverse whole matrix which tells us that\\nwhether we can pick a row or not , we can pick a row only when \\'1\\' s in it are visited which \\nwe can verify by visited arrray\\n```\n```\\nclass Solution {\\npublic:\\n    int maxi = INT_MIN;\\n    void helper(vector<vector<int>> &mat , int m , int n , int cols , int idx , vector<int> &vis){\\n        if(cols == 0 or idx==n){\\n            int cnt = 0;\\n            for(int p = 0 ; p < m ; p++){\\n                bool check = true;\\n                for(int q = 0 ; q < n; q++){\\n                    // if cell is 1 and not visited then we cannot take this row\\n                    if(mat[p][q] == 1 and vis[q] == 0){\\n                        check = false;\\n                        break;\\n                    }\\n                }\\n                if(check) cnt++;\\n            }\\n            maxi = max(maxi,cnt);\\n            return;\\n        }\\n        \\n        // picking idx th column and marking column as visited\\n        vis[idx]=1;\\n        helper(mat,m,n,cols-1,idx+1,vis);\\n        vis[idx]=0;\\n        \\n        // not picking\\n        helper(mat,m,n,cols,idx+1,vis);\\n        return;\\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<int> vis(n);\\n        \\n        helper(mat,m,n,cols,0,vis);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525583,
                "title": "c-easy-to-understand-backtracking-solution",
                "content": "Intuition:  We will consider all possible combinations of choosing the \"cols\" amount of columns. For each such combination, we will find the number of covered rows and choose the combination that gives the maximum number of covered rows.\\n\\nApproach: For considering all possible combinations of choosing columns, let\\'s use recursion + backtracking. On each call, we will have two options: \\n1. Not to Choose this Column - make a call on the next column.\\n2. Choose this Column - mark this column as selected and call on the next column.\\n\\nBase Cases:\\n1. We have selected all required columns.\\n2. Columns size is exhausted and we haven\\'t chosen the required amount of columns.\\n\\nRemember that we **must** choose \"cols\" number of columns.\\n\\n**C++**\\n```\\nclass Solution {\\nprivate:\\n    int ans;\\n    \\n    void helper(vector<vector<int>>& mat, vector<int> &chose, int c, int n, int m, int cols) {\\n        if(cols == 0) { // We choose all required columns\\n            int cntRows = calcRow(mat, chose, n, m);\\n            ans = max(ans, cntRows);\\n            return;\\n        }\\n        \\n        if(c >= m) { // if column size is exhausted and we haven\\'t chosen the required amount of columns\\n            return;\\n        }\\n        \\n        helper(mat, chose, c + 1, n, m, cols); // not choosing this column\\n        \\n\\t\\t// choose this column\\n        chose[c] = 1; // mark this column\\n        helper(mat, chose, c + 1, n, m, cols - 1);\\n        chose[c] = 0; // unmark this column\\n    }\\n    \\n    int calcRow(vector<vector<int>>& mat, vector<int> &chose, int n, int m) {\\n        int cnt = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            bool ok = 1;\\n            for(int j = 0; j < m; j++) {\\n\\t\\t\\t\\t// If this cell in the ith row contains \\'1\\' but we haven\\'t chosen this column, thus we cannot consider this row as covered\\n                if(mat[i][j] == 1 && chose[j] == 0) {\\n\\t\\t\\t\\t\\tok = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n            }\\n            if(ok) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        ans = 0;\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> chose(m, 0); // to track the chosen columns \\n        helper(mat, chose, 0, n, m, cols);\\n        return ans;\\n    }\\n};\\n```\\n\\nN = rows, M = columns\\n\\nTC: O(N * M * 2^M)\\nSC: O(M * 2 ^ M)\\n\\nThanks, please upvote",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int ans;\\n    \\n    void helper(vector<vector<int>>& mat, vector<int> &chose, int c, int n, int m, int cols) {\\n        if(cols == 0) { // We choose all required columns\\n            int cntRows = calcRow(mat, chose, n, m);\\n            ans = max(ans, cntRows);\\n            return;\\n        }\\n        \\n        if(c >= m) { // if column size is exhausted and we haven\\'t chosen the required amount of columns\\n            return;\\n        }\\n        \\n        helper(mat, chose, c + 1, n, m, cols); // not choosing this column\\n        \\n\\t\\t// choose this column\\n        chose[c] = 1; // mark this column\\n        helper(mat, chose, c + 1, n, m, cols - 1);\\n        chose[c] = 0; // unmark this column\\n    }\\n    \\n    int calcRow(vector<vector<int>>& mat, vector<int> &chose, int n, int m) {\\n        int cnt = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            bool ok = 1;\\n            for(int j = 0; j < m; j++) {\\n\\t\\t\\t\\t// If this cell in the ith row contains \\'1\\' but we haven\\'t chosen this column, thus we cannot consider this row as covered\\n                if(mat[i][j] == 1 && chose[j] == 0) {\\n\\t\\t\\t\\t\\tok = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n            }\\n            if(ok) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        ans = 0;\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> chose(m, 0); // to track the chosen columns \\n        helper(mat, chose, 0, n, m, cols);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524730,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m,ans = 0;\\n    void recur(vector<vector<int>>& mat, vector<int>& col_arr, int idx, int remaining_cols){\\n        //if we have not selected cols columns then remaining_cols will be non zero and no updatation in ans;\\n        if(idx==m and remaining_cols!=0) return;\\n        //if we have selected cols columns then we check how many rows satisfies the given condions and update ans\\n        if(idx==m and remaining_cols==0){\\n           int res = 0;\\n            for(int j=0;j<n;j++){\\n                bool yes = true;\\n                for(int k=0;k<m;k++){\\n                    if(mat[j][k] and col_arr[k]==0){\\n                        yes = false;\\n                        break;\\n                    }\\n                }\\n                if(yes) res++;\\n            }\\n            ans = max(ans,res);\\n            return;\\n        }\\n        //lets skip this column and recur next\\n        recur(mat,col_arr,idx+1,remaining_cols);\\n        //or select this column and recur next\\n        col_arr[idx] = 1;\\n        recur(mat,col_arr,idx+1,remaining_cols-1);\\n        col_arr[idx] = 0;\\n        return;\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        n = mat.size();\\n        m = mat[0].size();\\n        vector<int>col_arr(m,0);\\n        recur(mat,col_arr,0,cols);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m,ans = 0;\\n    void recur(vector<vector<int>>& mat, vector<int>& col_arr, int idx, int remaining_cols){\\n        //if we have not selected cols columns then remaining_cols will be non zero and no updatation in ans;\\n        if(idx==m and remaining_cols!=0) return;\\n        //if we have selected cols columns then we check how many rows satisfies the given condions and update ans\\n        if(idx==m and remaining_cols==0){\\n           int res = 0;\\n            for(int j=0;j<n;j++){\\n                bool yes = true;\\n                for(int k=0;k<m;k++){\\n                    if(mat[j][k] and col_arr[k]==0){\\n                        yes = false;\\n                        break;\\n                    }\\n                }\\n                if(yes) res++;\\n            }\\n            ans = max(ans,res);\\n            return;\\n        }\\n        //lets skip this column and recur next\\n        recur(mat,col_arr,idx+1,remaining_cols);\\n        //or select this column and recur next\\n        col_arr[idx] = 1;\\n        recur(mat,col_arr,idx+1,remaining_cols-1);\\n        col_arr[idx] = 0;\\n        return;\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        n = mat.size();\\n        m = mat[0].size();\\n        vector<int>col_arr(m,0);\\n        recur(mat,col_arr,0,cols);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670072,
                "title": "python-3-5-lines-combinations-t-m-98-55",
                "content": "```\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n\\t\\n        m, n, ans = len(mat), len(mat[0]), -inf\\n        \\n        for comb in combinations((num for num in range(n)),n-cols):\\n        \\n            ct = len(set(r for r in range(m) for c in comb if mat[r][c] == 1))\\n\\n            ans = max(ans,m-ct)\\n\\n        return ans\\n```\\n[https://leetcode.com/submissions/detail/816727636/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n\\t\\n        m, n, ans = len(mat), len(mat[0]), -inf\\n        \\n        for comb in combinations((num for num in range(n)),n-cols):\\n        \\n            ct = len(set(r for r in range(m) for c in comb if mat[r][c] == 1))\\n\\n            ans = max(ans,m-ct)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524757,
                "title": "brute-force-java",
                "content": "```\\n    static int maximumRows(int[][] mat, int cols) {\\n        return getResult(mat, cols, new HashSet<Integer>(),0) ;\\n    }\\n    static int getResult(int [][] mat, int cols, Set<Integer> set, int x){\\n        int maxResult = 0;\\n        if(cols == 0){\\n            int count = 0;\\n            for(int i = 0; i < mat.length; i++) {\\n                int [] row = mat[i];\\n                boolean flag = true;\\n                for(int col = 0; col < row.length; col++){\\n                    if(row[col] == 1 && !set.contains(col)){\\n                        flag = false; break;\\n                    }\\n                }\\n                if(flag) count++;\\n\\n            }\\n            return count;\\n        }\\n\\n        for(int i = x; i < mat[0].length; i++) {\\n            set.add(i);\\n            maxResult = Math.max(maxResult, getResult(mat, cols - 1, set, i+1));\\n            set.remove(i);\\n        }\\n        return maxResult;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    static int maximumRows(int[][] mat, int cols) {\\n        return getResult(mat, cols, new HashSet<Integer>(),0) ;\\n    }\\n    static int getResult(int [][] mat, int cols, Set<Integer> set, int x){\\n        int maxResult = 0;\\n        if(cols == 0){\\n            int count = 0;\\n            for(int i = 0; i < mat.length; i++) {\\n                int [] row = mat[i];\\n                boolean flag = true;\\n                for(int col = 0; col < row.length; col++){\\n                    if(row[col] == 1 && !set.contains(col)){\\n                        flag = false; break;\\n                    }\\n                }\\n                if(flag) count++;\\n\\n            }\\n            return count;\\n        }\\n\\n        for(int i = x; i < mat[0].length; i++) {\\n            set.add(i);\\n            maxResult = Math.max(maxResult, getResult(mat, cols - 1, set, i+1));\\n            set.remove(i);\\n        }\\n        return maxResult;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2526674,
                "title": "c-solution-using-backtracking-dfs",
                "content": "We can use **DFS** with **backtracking** to fetch all the **valid combinations** for this problem that would be C(m, cols) = m! / ((m - cols)! * cols!) here C denotes Combination or Binomial Coefficient and m denotes number of columns. Then we calculate the answer for each valid combination and return the maximum of all the valid answers. \\n\\nThis DFS trick can also be used to find all the premutations too. I saw this trick first used in an atcoder contest by tourist. I have mentioned that problem below this along with tourist\\'s solution and editorial.\\n\\n**Similar Problem**\\nProblem Link: https://atcoder.jp/contests/abc236/tasks/abc236_d\\nTourist\\'s Solution: https://atcoder.jp/contests/abc236/submissions/28725135\\nEditorial: https://atcoder.jp/contests/abc236/editorial/3304\\n\\n**Note:** Learn to use lambda funtions if you code in C++ it makes your code many time easier to type then passing all the values by referance. References: https://usaco.guide/general/lambda-funcs?lang=cpp https://codeforces.com/blog/entry/89790.\\n\\n**Solution:**\\n```Cpp\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        const int n = (int)mat.size(), m = (int)mat[0].size();\\n        int ans = 0;\\n        vector<bool> vis(m, false);\\n        function<void(int, int)> dfs = [&](int u, int cnt) -> void {\\n            if(cnt == cols) {\\n                int cur = 0;\\n                for(int i = 0; i < n; i++) {\\n                    bool flag = true;\\n                    for(int j = 0; j < m; j++) {\\n                        if(!vis[j] and mat[i][j]) flag = false;\\n                        if(!flag) break;\\n                    }\\n                    cur += flag;\\n                }\\n                ans = max(ans, cur);\\n            } else {\\n                for(int i = u + 1; i < m; i++) {\\n                    vis[i] = true;\\n                    dfs(i, cnt + 1);\\n                    vis[i] = false;\\n                }\\n            }\\n        };\\n        dfs(-1, 0);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        const int n = (int)mat.size(), m = (int)mat[0].size();\\n        int ans = 0;\\n        vector<bool> vis(m, false);\\n        function<void(int, int)> dfs = [&](int u, int cnt) -> void {\\n            if(cnt == cols) {\\n                int cur = 0;\\n                for(int i = 0; i < n; i++) {\\n                    bool flag = true;\\n                    for(int j = 0; j < m; j++) {\\n                        if(!vis[j] and mat[i][j]) flag = false;\\n                        if(!flag) break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2525165,
                "title": "anyone-has-difficulty-in-understanding",
                "content": "A lot of time is wasted for the problem understanding!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2524972,
                "title": "c-bit-masking-faster-than-100-o-2-n-n",
                "content": "**Approach**\\n1. Convert each row into a decimal number and store in a vector.\\n2. Then traverse over range 1 << size of column, to go through all permutations having set_bits = cols. \\n3. For each such permutation count number of elements in above generated vector which have set bits at same position.\\n4. Store the maximum answer.\\n```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<int> nums;\\n        for(int i = 0; i < m; i++) {\\n            string str;\\n            for(int j = 0; j < n; j++) {\\n                str += (mat[i][j] + \\'0\\');\\n            }\\n            int number = stoi(str, nullptr, 2);\\n            nums.push_back(number);\\n        }\\n        int range = 1 << n;\\n        int ans = 0;\\n        for(int i = 0; i < range; i++) {\\n            int count = 0;\\n            if(__builtin_popcount(i) == cols) {\\n                for(auto it : nums) {\\n                    if((it | i) == i)\\n                        count++;\\n                }\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<int> nums;\\n        for(int i = 0; i < m; i++) {\\n            string str;\\n            for(int j = 0; j < n; j++) {\\n                str += (mat[i][j] + \\'0\\');\\n            }\\n            int number = stoi(str, nullptr, 2);\\n            nums.push_back(number);\\n        }\\n        int range = 1 << n;\\n        int ans = 0;\\n        for(int i = 0; i < range; i++) {\\n            int count = 0;\\n            if(__builtin_popcount(i) == cols) {\\n                for(auto it : nums) {\\n                    if((it | i) == i)\\n                        count++;\\n                }\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524746,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        n,m = len(mat),len(mat[0])\\n        ans = 0\\n\\n        def check(state,row,rowIncludedCount):\\n            nonlocal ans\\n            if row==n:\\n                if sum(state)<=cols:\\n                    ans = max(ans,rowIncludedCount)\\n                return\\n            \\n            check(state[::],row+1,rowIncludedCount)\\n            for j in range(m):\\n                if mat[row][j]==1:\\n                    state[j] = 1\\n            check(state,row+1,rowIncludedCount+1)\\n        \\n        check([0]*m,0,0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        n,m = len(mat),len(mat[0])\\n        ans = 0\\n\\n        def check(state,row,rowIncludedCount):\\n            nonlocal ans\\n            if row==n:\\n                if sum(state)<=cols:\\n                    ans = max(ans,rowIncludedCount)\\n                return\\n            \\n            check(state[::],row+1,rowIncludedCount)\\n            for j in range(m):\\n                if mat[row][j]==1:\\n                    state[j] = 1\\n            check(state,row+1,rowIncludedCount+1)\\n        \\n        check([0]*m,0,0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524717,
                "title": "generate-every-possible-subset-and-check",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m=mat.size(),n=mat[0].size(),ans=0;\\n        int mask=((1<<n)-1);\\n        // use mask to generate every possible columns combination\\n        while(mask){\\n            unordered_set<int>select;\\n            for(int i=0;i<n;i++){\\n                if(((mask>>i)&1)==1)\\n                    select.insert(i);\\n            }\\n            // if subset contains exaclty \"cols\" columns then we can use this subset\\n            if(select.size()==cols){\\n                int cnt=0;\\n                for(int j=0;j<m;j++){\\n                    bool flag=true;\\n                    for(int k=0;k<n;k++){\\n                        // if any row contains 1 in  column other than columns which we have in \"select\" then this row is not valid row for our answer\\n                        if(mat[j][k]==1 && select.count(k)==0){\\n                            flag=false;\\n                            break;\\n                        }\\n                    }\\n                    if(flag)\\n                        cnt++;\\n                }\\n                ans=max(ans,cnt);\\n            }\\n            mask--;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** is it helps :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m=mat.size(),n=mat[0].size(),ans=0;\\n        int mask=((1<<n)-1);\\n        // use mask to generate every possible columns combination\\n        while(mask){\\n            unordered_set<int>select;\\n            for(int i=0;i<n;i++){\\n                if(((mask>>i)&1)==1)\\n                    select.insert(i);\\n            }\\n            // if subset contains exaclty \"cols\" columns then we can use this subset\\n            if(select.size()==cols){\\n                int cnt=0;\\n                for(int j=0;j<m;j++){\\n                    bool flag=true;\\n                    for(int k=0;k<n;k++){\\n                        // if any row contains 1 in  column other than columns which we have in \"select\" then this row is not valid row for our answer\\n                        if(mat[j][k]==1 && select.count(k)==0){\\n                            flag=false;\\n                            break;\\n                        }\\n                    }\\n                    if(flag)\\n                        cnt++;\\n                }\\n                ans=max(ans,cnt);\\n            }\\n            mask--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524696,
                "title": "simple-c-solution",
                "content": "simple backtracking problem!!!\\n\\n1. mark the current column\\'s 1\\'s and reduce the number of cols you have and move onwards to other columns\\n2. unmark the current column\\'s 1\\'s and move onwards to other columns.\\n3. base case is when you reach the end column or you don\\'t have cols left to mark 1\\'s.\\n4. I later realised that you can flip steps 1 and 2 to make implementation easier but I am presenting the contest solution to you.\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& mat,int colno,int m,int n,int rem,int &res){\\n        if(rem==0||colno==n){\\n            int count = 0;\\n            for(int i=0;i<m;i++){\\n                bool flag = false;\\n                for(int j=0;j<n;j++){\\n                    if(mat[i][j]){\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                    count++;\\n            }\\n            res = max(count,res);\\n            return;\\n        }\\n        vector<bool> markedpos(m,false);\\n        //choose this column and proceed\\n        for(int i=0;i<m;i++){\\n            if(mat[i][colno]==1){\\n                mat[i][colno] = 0;\\n                markedpos[i] = true;\\n            }\\n        }\\n        backtrack(mat,colno+1,m,n,rem-1,res);\\n        //undo \\n        for(int i=0;i<m;i++){\\n            if(markedpos[i]){\\n                mat[i][colno] = 1;\\n            }\\n        }\\n        backtrack(mat,colno+1,m,n,rem,res);\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int res = 0;\\n        int m = mat.size(),n = mat[0].size();\\n        backtrack(mat,0,m,n,cols,res);\\n        return res;\\n    }\\n};\\n```\\n\\nPlease upvote if you found this helpful!",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& mat,int colno,int m,int n,int rem,int &res){\\n        if(rem==0||colno==n){\\n            int count = 0;\\n            for(int i=0;i<m;i++){\\n                bool flag = false;\\n                for(int j=0;j<n;j++){\\n                    if(mat[i][j]){\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                    count++;\\n            }\\n            res = max(count,res);\\n            return;\\n        }\\n        vector<bool> markedpos(m,false);\\n        //choose this column and proceed\\n        for(int i=0;i<m;i++){\\n            if(mat[i][colno]==1){\\n                mat[i][colno] = 0;\\n                markedpos[i] = true;\\n            }\\n        }\\n        backtrack(mat,colno+1,m,n,rem-1,res);\\n        //undo \\n        for(int i=0;i<m;i++){\\n            if(markedpos[i]){\\n                mat[i][colno] = 1;\\n            }\\n        }\\n        backtrack(mat,colno+1,m,n,rem,res);\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int res = 0;\\n        int m = mat.size(),n = mat[0].size();\\n        backtrack(mat,0,m,n,cols,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528290,
                "title": "100-faster-brute-force-c-easy-to-understand",
                "content": "**Simply check for all the combinations of columns i.e, check for a set of coulms taken that how many rows are covered tht can be furthur checked by checking all the ones in a row are present in the selected columns or not if yes count++ and at last take the maximum of this count for all the combinations of coulmns generated.**\\n*Just use a function to generate all the combinations of columns and then check the ones in a row for all these combinations generated .\\nlook the code for more understanding*\\n* And one thing also since the contraints are not big so we will not get tle for using brute force.\\n```\\n void solve(vector<vector<int>>&mat,vector<int>temp,int i,int j,int cols){\\n        if(i==j){\\n            if(temp.size()==cols)mat.push_back(temp);return;\\n        }\\n        solve(mat,temp,i+1,j,cols);\\n        temp.push_back(i);\\n        solve(mat,temp,i+1,j,cols);\\n        temp.pop_back();\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int r=mat.size(),c=mat[0].size();\\n        if(cols>=c){\\n            return r;\\n        }\\n    vector<vector<int>>tot;\\n        vector<int>temp;\\n        solve(tot,temp,0,c,cols);\\n        \\n\\n    int ans=0;\\n  \\n       \\n      for(auto x: tot){\\n          map<int,int>mp;\\n          for(auto it:x)mp[it]++;\\n          int res=0;\\n           for(int i=0;i<r;i++){\\n              \\n             bool ok=true;\\n                 for(int j=0;j<c;j++){\\n                    \\n                    if(mat[i][j]==1 and mp.find(j)==mp.end())ok=false;\\n                 }\\n             \\n             if(ok)res++;\\n                \\n            }\\n          ans=max(res,ans);\\n      }\\n        \\n        \\n\\n       \\n    return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n void solve(vector<vector<int>>&mat,vector<int>temp,int i,int j,int cols){\\n        if(i==j){\\n            if(temp.size()==cols)mat.push_back(temp);return;\\n        }\\n        solve(mat,temp,i+1,j,cols);\\n        temp.push_back(i);\\n        solve(mat,temp,i+1,j,cols);\\n        temp.pop_back();\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int r=mat.size(),c=mat[0].size();\\n        if(cols>=c){\\n            return r;\\n        }\\n    vector<vector<int>>tot;\\n        vector<int>temp;\\n        solve(tot,temp,0,c,cols);\\n        \\n\\n    int ans=0;\\n  \\n       \\n      for(auto x: tot){\\n          map<int,int>mp;\\n          for(auto it:x)mp[it]++;\\n          int res=0;\\n           for(int i=0;i<r;i++){\\n              \\n             bool ok=true;\\n                 for(int j=0;j<c;j++){\\n                    \\n                    if(mat[i][j]==1 and mp.find(j)==mp.end())ok=false;\\n                 }\\n             \\n             if(ok)res++;\\n                \\n            }\\n          ans=max(res,ans);\\n      }\\n        \\n        \\n\\n       \\n    return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524964,
                "title": "recursion-solution-pick-and-notpick-accepted",
                "content": "```\\n   public int maximumRows(int[][] mat, int cols) {\\n\\n        return helper(0, cols, mat);\\n    }\\n\\n    Set<Integer> set = new HashSet<>();\\n\\n    int helper(int col, int cols, int[][] mat) {\\n        if (cols == 0 || col == mat[0].length) {\\n            int res = count(mat);\\n            return res;\\n        }\\n        set.add(col);\\n        int pick = helper(col + 1, cols-1, mat);\\n        set.remove(col);\\n        int notPick = helper(col + 1, cols, mat);\\n        return Math.max(pick, notPick);\\n    }\\n\\n    int count(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int res = 0;\\n        for (int i = 0; i < m; i++) {\\n            int ones = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1 && !set.contains(j))\\n                    ones++;\\n            }\\n            if (ones == 0)\\n                res++;\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n   public int maximumRows(int[][] mat, int cols) {\\n\\n        return helper(0, cols, mat);\\n    }\\n\\n    Set<Integer> set = new HashSet<>();\\n\\n    int helper(int col, int cols, int[][] mat) {\\n        if (cols == 0 || col == mat[0].length) {\\n            int res = count(mat);\\n            return res;\\n        }\\n        set.add(col);\\n        int pick = helper(col + 1, cols-1, mat);\\n        set.remove(col);\\n        int notPick = helper(col + 1, cols, mat);\\n        return Math.max(pick, notPick);\\n    }\\n\\n    int count(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int res = 0;\\n        for (int i = 0; i < m; i++) {\\n            int ones = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1 && !set.contains(j))\\n                    ones++;\\n            }\\n            if (ones == 0)\\n                res++;\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524840,
                "title": "simple-solution-easy-to-understand-combinations",
                "content": "Just check all the combinations of column\\n\\n```\\n\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        m, n = len(mat), len(mat[0])\\n        maxRows = 0\\n        \\n        colToChoose = list(combinations(list(range(n)), cols))\\n        \\n        for col in colToChoose:\\n            col = set(col)\\n            rowHidden = 0\\n            for row in mat:\\n                canHide = True\\n                for i in range(n):\\n                    if(row[i] and i not in col):\\n                        canHide = False\\n                        break\\n                if(canHide):\\n                    rowHidden += 1\\n            maxRows = max(maxRows, rowHidden)\\n        return maxRows\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        m, n = len(mat), len(mat[0])\\n        maxRows = 0\\n        \\n        colToChoose = list(combinations(list(range(n)), cols))\\n        \\n        for col in colToChoose:\\n            col = set(col)\\n            rowHidden = 0\\n            for row in mat:\\n                canHide = True\\n                for i in range(n):\\n                    if(row[i] and i not in col):\\n                        canHide = False\\n                        break\\n                if(canHide):\\n                    rowHidden += 1\\n            maxRows = max(maxRows, rowHidden)\\n        return maxRows\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816465,
                "title": "brute-force-backtracking",
                "content": "```\\nclass Solution {\\nprivate:\\n    int n,m;\\n    unordered_map<int,vector<int>> col;\\n    int maxRow=0;\\n    \\n    void selectCol(int currCol,vector<int> selectedCol,int numSelect,int colSize)\\n    {\\n        if(selectedCol.size() == numSelect)\\n        {\\n            unordered_set<int> selectedColSet;\\n            for(int col : selectedCol) selectedColSet.insert(col);\\n            \\n            int count=0;\\n            \\n            for(int i=0; i<n; i++)\\n            {\\n                if(col[i].size() == 0)\\n                    count++;\\n                else\\n                {\\n                    bool flag=true;\\n                    \\n                    for(auto& tempCol : col[i])\\n                    {\\n                        if(selectedColSet.find(tempCol) == selectedColSet.end())\\n                        {\\n                            flag=false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if(flag)\\n                        count++;\\n                }\\n            }\\n            \\n            maxRow=max(maxRow,count);\\n        }\\n        else\\n        {\\n            for(int i=currCol; i<colSize; i++)\\n            {\\n                selectedCol.push_back(i);\\n                selectCol(i+1,selectedCol,numSelect,colSize);\\n                selectedCol.pop_back();\\n                selectCol(i+1,selectedCol,numSelect,colSize);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        n=matrix.size();\\n        m=matrix[0].size();        \\n                \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(matrix[i][j] == 1)\\n                    col[i].push_back(j);\\n            }\\n        }\\n        \\n        selectCol(0,{},numSelect,m);\\n        \\n        return maxRow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n,m;\\n    unordered_map<int,vector<int>> col;\\n    int maxRow=0;\\n    \\n    void selectCol(int currCol,vector<int> selectedCol,int numSelect,int colSize)\\n    {\\n        if(selectedCol.size() == numSelect)\\n        {\\n            unordered_set<int> selectedColSet;\\n            for(int col : selectedCol) selectedColSet.insert(col);\\n            \\n            int count=0;\\n            \\n            for(int i=0; i<n; i++)\\n            {\\n                if(col[i].size() == 0)\\n                    count++;\\n                else\\n                {\\n                    bool flag=true;\\n                    \\n                    for(auto& tempCol : col[i])\\n                    {\\n                        if(selectedColSet.find(tempCol) == selectedColSet.end())\\n                        {\\n                            flag=false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if(flag)\\n                        count++;\\n                }\\n            }\\n            \\n            maxRow=max(maxRow,count);\\n        }\\n        else\\n        {\\n            for(int i=currCol; i<colSize; i++)\\n            {\\n                selectedCol.push_back(i);\\n                selectCol(i+1,selectedCol,numSelect,colSize);\\n                selectedCol.pop_back();\\n                selectCol(i+1,selectedCol,numSelect,colSize);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        n=matrix.size();\\n        m=matrix[0].size();        \\n                \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(matrix[i][j] == 1)\\n                    col[i].push_back(j);\\n            }\\n        }\\n        \\n        selectCol(0,{},numSelect,m);\\n        \\n        return maxRow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528153,
                "title": "c-solution-easy-to-understand-using-backtracking",
                "content": "In this problem we apply concept of recursion of take and non take because of small constraint.\\n**Steps**\\n**1.** first we make a recursive function \\'fun\\' in which we pass current index, given matrix, given cols and visited array.\\n**2.** So visited array take care of column of matrix that which column is selected or which is not.\\n**3.** So mainly in recursive function, we try out all possible column which are possible for given cols value. we will do this with the help of take and non take method. and we update our visited array for that column which is taken.\\n**4.** For Base case, if our cols value become 0 or if we cover all column means now we check for covered row.\\n**5.** So Now we traverse our matrix and check if that column is unvisited and value of that mat[row][col]==1 means that row is not a covered row so we come out of loop of column.\\n**6.** otherwise we update the value of covered row by 1 (count++).\\n**7.** At last we take maximum of count and ans. because we have to calculate maximum row covered.\\n\\n**Code**\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint m,n;\\n\\t\\t\\t\\tint ans=INT_MIN;\\n\\t\\t\\t\\tvoid fun(int i,vector<vector<int>> &mat,int col,vector<int> vis){\\n\\t\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\t\\tif(col==0 || i==n){\\n\\n\\t\\t\\t\\t\\t\\tfor(int p=0;p<m;p++){\\n\\t\\t\\t\\t\\t\\t\\tint f=0;\\n\\t\\t\\t\\t\\t\\t\\tfor(int q=0;q<n;q++){\\n\\t\\t\\t\\t\\t\\t\\t\\tif(mat[p][q]==1 && vis[q]==0){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tf=1;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(f==0) count++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tans=max(ans,count);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfun(i+1,mat,col,vis);\\n\\t\\t\\t\\t\\tvis[i]=1;\\n\\t\\t\\t\\t\\tcol--;\\n\\t\\t\\t\\t\\tfun(i+1,mat,col,vis);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tint maximumRows(vector<vector<int>>& mat, int cols) {\\n\\t\\t\\t\\t\\tm=mat.size();\\n\\t\\t\\t\\t\\tn=mat[0].size();\\n\\t\\t\\t\\t\\tvector<int> vis(n,0);\\n\\t\\t\\t\\t\\tfun(0,mat,cols,vis);\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\t\\n**Please upvote if you like the explanation **",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint m,n;\\n\\t\\t\\t\\tint ans=INT_MIN;\\n\\t\\t\\t\\tvoid fun(int i,vector<vector<int>> &mat,int col,vector<int> vis){\\n\\t\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\t\\tif(col==0 || i==n){\\n\\n\\t\\t\\t\\t\\t\\tfor(int p=0;p<m;p++){\\n\\t\\t\\t\\t\\t\\t\\tint f=0;\\n\\t\\t\\t\\t\\t\\t\\tfor(int q=0;q<n;q++){\\n\\t\\t\\t\\t\\t\\t\\t\\tif(mat[p][q]==1 && vis[q]==0){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tf=1;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2526485,
                "title": "python-recursion-backtracking",
                "content": "# Backtracking + recursion\\n## Time -> O(2^N) {N is length of columns}\\n## Space -> O(cols)\\n\\n```\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        res = []\\n        M = len(mat)\\n        N = len(mat[0])\\n        def check(seen):\\n            count = 0\\n            for row in mat:\\n                flag = True\\n                for c in range(N): \\n                    if row[c] == 1:\\n                        if c in seen:\\n                            continue\\n                        else:\\n                            flag = False\\n                            break\\n                if flag:    \\n                    count +=1   \\n            res.append(count)\\n                     \\n        def solve(c,seen,cols):\\n            if cols == 0:\\n                check(seen)\\n                return\\n            if c == N:\\n                return\\n            else:\\n                seen.add(c)\\n                solve(c+1,seen,cols-1)\\n                seen.remove(c)\\n                solve(c+1,seen,cols)\\n        seen = set()\\n        solve(0,seen,cols)\\n        return max(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        res = []\\n        M = len(mat)\\n        N = len(mat[0])\\n        def check(seen):\\n            count = 0\\n            for row in mat:\\n                flag = True\\n                for c in range(N): \\n                    if row[c] == 1:\\n                        if c in seen:\\n                            continue\\n                        else:\\n                            flag = False\\n                            break\\n                if flag:    \\n                    count +=1   \\n            res.append(count)\\n                     \\n        def solve(c,seen,cols):\\n            if cols == 0:\\n                check(seen)\\n                return\\n            if c == N:\\n                return\\n            else:\\n                seen.add(c)\\n                solve(c+1,seen,cols-1)\\n                seen.remove(c)\\n                solve(c+1,seen,cols)\\n        seen = set()\\n        solve(0,seen,cols)\\n        return max(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525744,
                "title": "c-100-fast-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    // Global Vector to all possible column combinations\\n    vector<vector<int>>comb;\\n\\t\\n    // Function to find the number of rows a particular column combination can capture\\n    int find(vector<vector<int>>& mat1)\\n    {\\n        int c = 0;\\n        for(int i = 0; i < mat1.size(); i++)\\n        {\\n            int flg = 0;\\n            for(int j = 0; j < mat1[0].size(); j++)\\n                if(mat1[i][j] == 1)\\n                    flg = 1;\\n            if(flg == 0)\\n                c++;\\n        }\\n        return c;\\n    }\\n    \\n\\t// Function to Traverse for each Column Combination Present\\n    int find_ans(vector<vector<int>>& mat)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < comb.size(); i++)\\n        {\\n            vector<int>temp = comb[i];\\n            vector<vector<int>> mat1 = mat;\\n            for(int j = 0; j < temp.size(); j++)\\n            {\\n                int col_val = temp[j];\\n                for(int k = 0; k < mat1.size(); k++)\\n                    mat1[k][col_val] = 0;\\n            }\\n            ans = max(ans, find(mat1));\\n        }\\n        return ans;\\n    }\\n    // Function to Find all possible column combinations\\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\\n    {\\n        int col = mat[0].size();\\n        if(count == cols)\\n        {\\n            comb.push_back(tans);\\n            return;\\n        }\\n        if(idx >= col)\\n            return;\\n        \\n        helper(mat, cols, count, idx+1, tans);\\n        tans.push_back(idx);\\n        helper(mat, cols, count+1, idx+1, tans);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        vector<int>tans;\\n        helper(mat, cols, 0, 0, tans);\\n        return find_ans(mat);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Global Vector to all possible column combinations\\n    vector<vector<int>>comb;\\n\\t\\n    // Function to find the number of rows a particular column combination can capture\\n    int find(vector<vector<int>>& mat1)\\n    {\\n        int c = 0;\\n        for(int i = 0; i < mat1.size(); i++)\\n        {\\n            int flg = 0;\\n            for(int j = 0; j < mat1[0].size(); j++)\\n                if(mat1[i][j] == 1)\\n                    flg = 1;\\n            if(flg == 0)\\n                c++;\\n        }\\n        return c;\\n    }\\n    \\n\\t// Function to Traverse for each Column Combination Present\\n    int find_ans(vector<vector<int>>& mat)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < comb.size(); i++)\\n        {\\n            vector<int>temp = comb[i];\\n            vector<vector<int>> mat1 = mat;\\n            for(int j = 0; j < temp.size(); j++)\\n            {\\n                int col_val = temp[j];\\n                for(int k = 0; k < mat1.size(); k++)\\n                    mat1[k][col_val] = 0;\\n            }\\n            ans = max(ans, find(mat1));\\n        }\\n        return ans;\\n    }\\n    // Function to Find all possible column combinations\\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\\n    {\\n        int col = mat[0].size();\\n        if(count == cols)\\n        {\\n            comb.push_back(tans);\\n            return;\\n        }\\n        if(idx >= col)\\n            return;\\n        \\n        helper(mat, cols, count, idx+1, tans);\\n        tans.push_back(idx);\\n        helper(mat, cols, count+1, idx+1, tans);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        vector<int>tans;\\n        helper(mat, cols, 0, 0, tans);\\n        return find_ans(mat);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525204,
                "title": "simplest-python-solution-brute-force-combinations",
                "content": "Upvote if you like\\n\\n```\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        columns = [i for i in range(len(mat[0]))]\\n\\t\\t# All combinations of columns to select\\n        combos = combinations(columns, cols)\\n        ans = 0\\n        \\n\\t\\t# For every combo try to count number of valid rows\\n        for combo in combos:\\n            combo = set(combo)\\n            selectedRows = 0\\n            \\n            for r in range(len(mat)):\\n                for c in range(len(mat[0])):\\n                    if mat[r][c] == 1 and c not in combo:\\n                        break\\n                else:\\n\\t\\t\\t\\t# select a row only if it has 1s in the selected columns(combo) i.e. if loop never breaks\\n                    selectedRows += 1\\n            \\n            ans = max(ans, selectedRows)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        columns = [i for i in range(len(mat[0]))]\\n\\t\\t# All combinations of columns to select\\n        combos = combinations(columns, cols)\\n        ans = 0\\n        \\n\\t\\t# For every combo try to count number of valid rows\\n        for combo in combos:\\n            combo = set(combo)\\n            selectedRows = 0\\n            \\n            for r in range(len(mat)):\\n                for c in range(len(mat[0])):\\n                    if mat[r][c] == 1 and c not in combo:\\n                        break\\n                else:\\n\\t\\t\\t\\t# select a row only if it has 1s in the selected columns(combo) i.e. if loop never breaks\\n                    selectedRows += 1\\n            \\n            ans = max(ans, selectedRows)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524789,
                "title": "c-explained-clean-code-pick-notpick",
                "content": "![image](https://assets.leetcode.com/users/images/30ca8d2a-8c82-46f0-b0dd-862f2f476b1a_1662220873.5870469.png)\\n\\n***we have to apple pick-notpick on the columns of the matrix and we have to select \\'cols\\' number of subsequence lets say you selected 0th and 2nd col in the Example -1. Then we have to iterate over rows of the selected columns and have to check weather in a particular row the number of 1\\'s is equal to the number of selected columns (in other words whether  all the 1\\'s of a particular is covered or not) if all the 1\\'s are covered then that row will be counted. and at last we have to take the max count out of it!***\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxi=INT_MIN;\\n\\t\\tint n,m;\\n\\t\\tvoid f(int j,vector<int>& ds,vector<vector<int>>& mat,int cols){\\n\\t\\t\\tif(ds.size()>cols) return;\\n\\t\\t\\tif(j==n){\\n\\t\\t\\t\\tif(ds.size()==cols){\\n\\t\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\t\\t\\tint sum1=accumulate(mat[i].begin(),mat[i].end(),0);\\n\\t\\t\\t\\t\\t\\tint sum2=0;\\n\\t\\t\\t\\t\\t\\tfor(auto k:ds){\\n\\t\\t\\t\\t\\t\\t\\tsum2+=mat[i][k];\\n\\t\\t\\t\\t\\t\\t\\tif(sum1==sum2){\\n\\t\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;    \\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmaxi=max(maxi,count);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t//      Pick\\n\\t\\t\\tds.push_back(j);\\n\\t\\t\\tf(j+1,ds,mat,cols);\\n\\t\\t\\tds.pop_back();\\n\\t//      NotPick\\n\\t\\t\\tf(j+1,ds,mat,cols);\\n\\t\\t}\\n\\n\\t\\tint maximumRows(vector<vector<int>>& mat, int cols) {\\n\\t\\t\\tn=mat[0].size();\\n\\t\\t\\tm=mat.size();\\n\\t\\t\\tvector<int> ds;\\n\\t\\t\\tf(0,ds,mat,cols);\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxi=INT_MIN;\\n\\t\\tint n,m;\\n\\t\\tvoid f(int j,vector<int>& ds,vector<vector<int>>& mat,int cols){\\n\\t\\t\\tif(ds.size()>cols) return;\\n\\t\\t\\tif(j==n){\\n\\t\\t\\t\\tif(ds.size()==cols){\\n\\t\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\t\\t\\tint sum1=accumulate(mat[i].begin(),mat[i].end(),0);\\n\\t\\t\\t\\t\\t\\tint sum2=0;\\n\\t\\t\\t\\t\\t\\tfor(auto k:ds){\\n\\t\\t\\t\\t\\t\\t\\tsum2+=mat[i][k];\\n\\t\\t\\t\\t\\t\\t\\tif(sum1==sum2){\\n\\t\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;    \\n\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2524780,
                "title": "c-bitmask-o-n-2-n-7ms",
                "content": "Whenever you see `n <= 12`, start typing `for (int mask = 0; mask < (1 << n); mask++)`.\\n``` c++\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> rows(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (mat[i][j] == 1) {\\n                    rows[i] |= (1 << j);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int mask = 0; mask < (1 << m); mask++) {\\n            if (__builtin_popcount(mask) != cols) continue;\\n            int cur = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((mask | rows[i]) == mask) cur++;\\n            }\\n            ans = max(ans, cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "``` c++\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> rows(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (mat[i][j] == 1) {\\n                    rows[i] |= (1 << j);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int mask = 0; mask < (1 << m); mask++) {\\n            if (__builtin_popcount(mask) != cols) continue;\\n            int cur = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((mask | rows[i]) == mask) cur++;\\n            }\\n            ans = max(ans, cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524732,
                "title": "backtracking-simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void func(vector<vector<int>>& mat, int cols,vector <int> v,int idx,int &ans){\\n        if(cols==0){\\n            int cnt=0;\\n            for(int i=0;i<mat.size();i++){\\n                int f=1;\\n                for(int j=0;j<mat[i].size();j++){\\n                    if(mat[i][j]==1 && v[j]==0){\\n                        f=0;\\n                        break;\\n                    }\\n                }\\n                if(f==1){\\n                    cnt++;\\n                }\\n            }\\n            ans=max(cnt,ans);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<mat[0].size();i++){\\n            v[i]=1;\\n            func(mat,cols-1,v,i+1,ans);\\n            v[i]=0;\\n        }\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int ans=0;\\n        int n=mat[0].size();\\n        vector <int> v(n,0);\\n        func(mat,cols,v,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void func(vector<vector<int>>& mat, int cols,vector <int> v,int idx,int &ans){\\n        if(cols==0){\\n            int cnt=0;\\n            for(int i=0;i<mat.size();i++){\\n                int f=1;\\n                for(int j=0;j<mat[i].size();j++){\\n                    if(mat[i][j]==1 && v[j]==0){\\n                        f=0;\\n                        break;\\n                    }\\n                }\\n                if(f==1){\\n                    cnt++;\\n                }\\n            }\\n            ans=max(cnt,ans);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<mat[0].size();i++){\\n            v[i]=1;\\n            func(mat,cols-1,v,i+1,ans);\\n            v[i]=0;\\n        }\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int ans=0;\\n        int n=mat[0].size();\\n        vector <int> v(n,0);\\n        func(mat,cols,v,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524701,
                "title": "backtracking-java-solution-code-with-comments",
                "content": "Idea is to use backtraking. But before trying that we should know how to calculate which all rows are not covered by choosen columns. For that we can store this info in a map (column index to set of row indices haiving one). For each possible combination in backtraking we calculate which all rows were missed and substract if from total number of rows.\\n\\n\\n```\\nclass Solution {\\n    int result;\\n    public int maximumRows(int[][] mat, int cols) {\\n        int m = mat.length; // number of rows\\n        int n = mat[0].length; // number of columns\\n        result = -1;\\n\\n        // if cols is equal to number of columns andswer will be number of rows.\\n        if(cols == n) return m;\\n\\n        // Map to store which column index covers which all rows having value 1.\\n        Map<Integer, Set<Integer>> columnIndexToRowHavingOnes = new HashMap<>();\\n\\n        for(int i = 0; i < n; i++) columnIndexToRowHavingOnes.put(i, new HashSet<>());\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(mat[i][j] == 1) {\\n                    Set<Integer> set = columnIndexToRowHavingOnes.get(j);\\n                    set.add(i);\\n                    columnIndexToRowHavingOnes.put(j, set);\\n                }\\n            }\\n        }\\n\\n        getAnswer(0, new ArrayList<Integer>(), cols, columnIndexToRowHavingOnes, m, n);\\n\\n        return result;\\n    }\\n\\n    // Backtracking function\\n    private void getAnswer(int index, ArrayList<Integer> colChoosen, int cols, Map<Integer, Set<Integer>> columnIndexToRowHavingOnes, int m, int n){\\n\\n        // If we have chossed cols number of columns\\n        if(colChoosen.size() == cols){\\n            Set<Integer> rowNotCoveredByChoosenColumns = new HashSet<>();\\n            // For each column\\n            for(int i = 0; i < n; i++){\\n                // find which all rows were missed which have value 1\\n                if(!colChoosen.contains(i)){\\n                    rowNotCoveredByChoosenColumns.addAll(columnIndexToRowHavingOnes.get(i));\\n                }\\n            }\\n\\n            result = Math.max(result, m - rowNotCoveredByChoosenColumns.size());\\n            return;\\n        }\\n\\n        if(index == n) return;\\n\\n        // pick the column\\n        colChoosen.add(index);\\n        getAnswer(index + 1, colChoosen, cols, columnIndexToRowHavingOnes, m, n);\\n\\n        // unpick the column\\n        colChoosen.remove(colChoosen.size() - 1);\\n        getAnswer(index + 1, colChoosen, cols, columnIndexToRowHavingOnes, m, n);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int result;\\n    public int maximumRows(int[][] mat, int cols) {\\n        int m = mat.length; // number of rows\\n        int n = mat[0].length; // number of columns\\n        result = -1;\\n\\n        // if cols is equal to number of columns andswer will be number of rows.\\n        if(cols == n) return m;\\n\\n        // Map to store which column index covers which all rows having value 1.\\n        Map<Integer, Set<Integer>> columnIndexToRowHavingOnes = new HashMap<>();\\n\\n        for(int i = 0; i < n; i++) columnIndexToRowHavingOnes.put(i, new HashSet<>());\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(mat[i][j] == 1) {\\n                    Set<Integer> set = columnIndexToRowHavingOnes.get(j);\\n                    set.add(i);\\n                    columnIndexToRowHavingOnes.put(j, set);\\n                }\\n            }\\n        }\\n\\n        getAnswer(0, new ArrayList<Integer>(), cols, columnIndexToRowHavingOnes, m, n);\\n\\n        return result;\\n    }\\n\\n    // Backtracking function\\n    private void getAnswer(int index, ArrayList<Integer> colChoosen, int cols, Map<Integer, Set<Integer>> columnIndexToRowHavingOnes, int m, int n){\\n\\n        // If we have chossed cols number of columns\\n        if(colChoosen.size() == cols){\\n            Set<Integer> rowNotCoveredByChoosenColumns = new HashSet<>();\\n            // For each column\\n            for(int i = 0; i < n; i++){\\n                // find which all rows were missed which have value 1\\n                if(!colChoosen.contains(i)){\\n                    rowNotCoveredByChoosenColumns.addAll(columnIndexToRowHavingOnes.get(i));\\n                }\\n            }\\n\\n            result = Math.max(result, m - rowNotCoveredByChoosenColumns.size());\\n            return;\\n        }\\n\\n        if(index == n) return;\\n\\n        // pick the column\\n        colChoosen.add(index);\\n        getAnswer(index + 1, colChoosen, cols, columnIndexToRowHavingOnes, m, n);\\n\\n        // unpick the column\\n        colChoosen.remove(colChoosen.size() - 1);\\n        getAnswer(index + 1, colChoosen, cols, columnIndexToRowHavingOnes, m, n);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545764,
                "title": "c-easy-understanding-backtracking-solution",
                "content": "\\t#define ll int\\n\\tclass Solution {\\n\\tpublic:\\n    ll maxi =0;\\n    ll n,m;\\n    void f (ll col,ll curcol, vector<vector<int>> &mat, vector<vector<int>> &dummy){        \\n        if(col==0){\\n            ll rows =0;       \\n            // count how many rows are filled with 0 values\\n            for(int i=0;i<n;i++){\\n                bool ok = true;\\n                for(ll j=0;j<m;j++){                    \\n                    if(dummy[i][j]==1) {\\n                        ok=false; \\n                        break;\\n                    }\\n                }                \\n                if(ok) rows++;\\n            }\\n            maxi=max(maxi,rows);\\n            return;\\n        }\\n        if(curcol==m) return;\\n        for(int i=0;i<n;i++){\\n            dummy[i][curcol]=0;\\n            // if we are taking the current col fill that col with 0 \\n        }\\n        // take the current col \\n        f(col-1,curcol+1,mat,dummy);\\n        \\n        for(int i=0;i<n;i++){\\n            dummy[i][curcol]= mat[i][curcol]; \\n            // backtrack the original values \\n        }\\n        // ignore the current col\\n        f(col,curcol+1,mat,dummy);\\n\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        n = matrix.size(), m = matrix[0].size();\\n        vector<vector<ll>> dummy;\\n        dummy = matrix;\\n        f(numSelect,0,matrix,dummy);\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    ll maxi =0;\\n    ll n,m;\\n    void f (ll col,ll curcol, vector<vector<int>> &mat, vector<vector<int>> &dummy){        \\n        if(col==0){\\n            ll rows =0;       \\n            // count how many rows are filled with 0 values\\n            for(int i=0;i<n;i++){\\n                bool ok = true;\\n                for(ll j=0;j<m;j++){                    \\n                    if(dummy[i][j]==1) {\\n                        ok=false; \\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2538863,
                "title": "java-backtrack-recursion-runtime-1ms-100-faster",
                "content": "This question is similar to [698. Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/).\\nWe try all possible combinations of columns, once we select the given number of columns, we check that for how many rows in the matrix, the below condition is true:-\\n1. Each cell of the row is \\'0\\', or\\n2. If the cell of the row is \\'1\\', then the cell\\'s column value(say, \\'j\\') should be \\'1\\'(i.e. this column is selected by us) in the \\'s\\' array. (s[j]==1).\\n\\nWe return the count of the rows.\\nIn order to get our answer we maintain the maximum value(max number of rows that could be selected) in \\'ans\\'.\\n```\\nclass Solution {\\n    public int maximumRows(int[][] mat, int cols) {\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        \\n        int[] s=new int[n];\\n        \\n        return f(0,m,n,cols,mat,s);\\n    }\\n    \\n    public int f(int ind,int m,int n,int cols,int[][] mat,int[] s){\\n        \\n        if(cols==0){\\n            int count=0;\\n            for(int i=0; i<m; i++){\\n\\t\\t\\t//supposing that this row is valid\\n                boolean selected=true;\\n                for(int j=0; j<n; j++){\\n\\t\\t\\t\\t//if any cell of this row violates the given two conditions, then the row is discarded\\n                    if(mat[i][j]==1 && s[j]!=1)\\n                        selected=false;\\n                }\\n                if(selected)\\n                    count+=1;\\n            }\\n            \\n            return count;\\n        }\\n        \\n        int ans=-1;\\n        for(int i=ind; i<n; i++){\\n            \\n            s[i]=1; //do\\n            ans=Math.max(ans,f(i+1,m,n,cols-1,mat,s));\\n            s[i]=0; //undo / backtrack\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRows(int[][] mat, int cols) {\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        \\n        int[] s=new int[n];\\n        \\n        return f(0,m,n,cols,mat,s);\\n    }\\n    \\n    public int f(int ind,int m,int n,int cols,int[][] mat,int[] s){\\n        \\n        if(cols==0){\\n            int count=0;\\n            for(int i=0; i<m; i++){\\n\\t\\t\\t//supposing that this row is valid\\n                boolean selected=true;\\n                for(int j=0; j<n; j++){\\n\\t\\t\\t\\t//if any cell of this row violates the given two conditions, then the row is discarded\\n                    if(mat[i][j]==1 && s[j]!=1)\\n                        selected=false;\\n                }\\n                if(selected)\\n                    count+=1;\\n            }\\n            \\n            return count;\\n        }\\n        \\n        int ans=-1;\\n        for(int i=ind; i<n; i++){\\n            \\n            s[i]=1; //do\\n            ans=Math.max(ans,f(i+1,m,n,cols-1,mat,s));\\n            s[i]=0; //undo / backtrack\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535548,
                "title": "java-one-the-easiest-solution-with-explanation-pick-notpick-approach",
                "content": "Approach - if you look at problem in little deep , you can directly see that for each column we have two option\\n1. pick that column (if picked then, go to next index and increased the count of total picked column)\\n2.  Not pick that column (if not picked, got to next step in this case since we have not picked it total count is not going to increase).\\n\\n**Base Condition Explanation**\\nThink logically when we are going to hit base i,e {index == matrix[0].length} simple.\\nand if base condition is met that we need to do, we need to calculate total of rows covered with currently selected column.\\n\\n```\\npublic int maximumRows(int[][] mat, int cols) {\\n        boolean[] visited = new boolean[mat[0].length];\\n        return solve(mat, cols, 0, 0, visited);\\n    }\\n    private static int solve(int[][] arr, int cols, int index, int curTotalPicked, boolean[] visited) {\\n        if (index == arr[0].length) {\\n            int count = 0;\\n            for (int i = 0; i < arr.length; i++) {\\n                boolean flag = true;\\n                for (int j = 0; j < arr[0].length; j++) {\\n                    if (arr[i][j] == 1) {\\n                        if (!visited[j]) {\\n                            flag = false;\\n                        }\\n                    }\\n                }\\n\\n                if (flag) {\\n                    count++;\\n                }\\n            }\\n            return count;\\n        }\\n\\n        int pick = 0;\\n        if (curTotalPicked < cols) {\\n            visited[index] = true;\\n            pick = solve(arr, cols, index + 1, curTotalPicked + 1, visited);\\n            visited[index] = false;\\n        }\\n        int notPick = solve(arr, cols, index +1, curTotalPicked, visited);\\n        return Math.max(pick, notPick);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximumRows(int[][] mat, int cols) {\\n        boolean[] visited = new boolean[mat[0].length];\\n        return solve(mat, cols, 0, 0, visited);\\n    }\\n    private static int solve(int[][] arr, int cols, int index, int curTotalPicked, boolean[] visited) {\\n        if (index == arr[0].length) {\\n            int count = 0;\\n            for (int i = 0; i < arr.length; i++) {\\n                boolean flag = true;\\n                for (int j = 0; j < arr[0].length; j++) {\\n                    if (arr[i][j] == 1) {\\n                        if (!visited[j]) {\\n                            flag = false;\\n                        }\\n                    }\\n                }\\n\\n                if (flag) {\\n                    count++;\\n                }\\n            }\\n            return count;\\n        }\\n\\n        int pick = 0;\\n        if (curTotalPicked < cols) {\\n            visited[index] = true;\\n            pick = solve(arr, cols, index + 1, curTotalPicked + 1, visited);\\n            visited[index] = false;\\n        }\\n        int notPick = solve(arr, cols, index +1, curTotalPicked, visited);\\n        return Math.max(pick, notPick);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527822,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& v, int k) {\\n        int n=v.size(),m=v[0].size();\\n        int ans=0;\\n        for(int i=0;i<(1<<12);i++){\\n            string s=\"\";\\n            int c=0;\\n            for(int j=0;j<12;j++){\\n                if(i&(1<<j)) s+=\\'1\\';\\n                else s+=\\'0\\';\\n                if(s[j]==\\'1\\') c++;\\n            }\\n            if(c!=k) continue;\\n            int cnt=0;\\n            for(int x=0;x<n;x++){\\n                bool ok=true;\\n                for(int y=0;y<m;y++){\\n                    if(v[x][y]==1 and s[y]!=\\'1\\') {ok=false;break;}\\n                }if(ok) cnt++;\\n            }ans=max(ans,cnt);\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& v, int k) {\\n        int n=v.size(),m=v[0].size();\\n        int ans=0;\\n        for(int i=0;i<(1<<12);i++){\\n            string s=\"\";\\n            int c=0;\\n            for(int j=0;j<12;j++){\\n                if(i&(1<<j)) s+=\\'1\\';\\n                else s+=\\'0\\';\\n                if(s[j]==\\'1\\') c++;\\n            }\\n            if(c!=k) continue;\\n            int cnt=0;\\n            for(int x=0;x<n;x++){\\n                bool ok=true;\\n                for(int y=0;y<m;y++){\\n                    if(v[x][y]==1 and s[y]!=\\'1\\') {ok=false;break;}\\n                }if(ok) cnt++;\\n            }ans=max(ans,cnt);\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526808,
                "title": "c-simple-next-permutation-no-bit-masking-or-back-tracking",
                "content": "The idea is to just try all the combinations of the columns(with maximum ***cols*** columns selected) and see how many rows are being covered.\\n\\nWe can generate all the permutations using C++ next_permutation() algorithm starting from the first permutation when lexicographically sorted.\\n\\n\\n```\\nint maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n = mat.size(), m = mat[0].size(), ans=0;\\n        vector<int> perm(m,0);\\n        // Our initial arrangement should be the first arrangement in the lexicographically sorted permutations.\\n        // This helps us to loop over the next_permutations until all the permutations are covered .\\n        for(int i=0;i<cols;i++) perm[m-i-1]=1;\\n        do {\\n            int rows = 0, good;\\n            for(int i=0;i<n;i++) {\\n                good = 1;\\n                for(int j=0;j<m;j++) {\\n                    if(mat[i][j]==1 && perm[j]!=1) { \\n                        good=0; break; \\n                    }\\n                }\\n                if(good==1) rows++;\\n            }\\n            ans = max(ans, rows);\\n        } while(next_permutation(perm.begin(),perm.end()));\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n = mat.size(), m = mat[0].size(), ans=0;\\n        vector<int> perm(m,0);\\n        // Our initial arrangement should be the first arrangement in the lexicographically sorted permutations.\\n        // This helps us to loop over the next_permutations until all the permutations are covered .\\n        for(int i=0;i<cols;i++) perm[m-i-1]=1;\\n        do {\\n            int rows = 0, good;\\n            for(int i=0;i<n;i++) {\\n                good = 1;\\n                for(int j=0;j<m;j++) {\\n                    if(mat[i][j]==1 && perm[j]!=1) { \\n                        good=0; break; \\n                    }\\n                }\\n                if(good==1) rows++;\\n            }\\n            ans = max(ans, rows);\\n        } while(next_permutation(perm.begin(),perm.end()));\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2526283,
                "title": "python-brute-force",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n\\t\\t\\tm = len(mat)\\n\\t\\t\\tn = len(mat[0])\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor combination in combinations(range(n), cols):\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\t\\tcheck = True\\n\\t\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\t\\tif mat[i][j] == 1 and j not in combination:\\n\\t\\t\\t\\t\\t\\t\\tcheck = False\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tif check:\\n\\t\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tres = max(res, cnt)\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n\\t\\t\\tm = len(mat)\\n\\t\\t\\tn = len(mat[0])\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor combination in combinations(range(n), cols):\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\t\\tcheck = True\\n\\t\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\t\\tif mat[i][j] == 1 and j not in combination:\\n\\t\\t\\t\\t\\t\\t\\tcheck = False\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tif check:\\n\\t\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tres = max(res, cnt)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2525915,
                "title": "c-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>> &mat, int cols) {\\n        int m = mat.size(), n = mat[0].size();\\n        int perm = pow(2, n) - 1;\\n        vector<vector<int>> grid(perm + 1, vector<int>(n, 0));\\n        for (int i = 0; i <= perm; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if ((i & (1 << j)) >= 1) {\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        int mx = 0;\\n        for (int i = 0; i <= perm; i++) {\\n            int cnt = 0, temp = 0;\\n            unordered_set<int> st;\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    st.insert(j);\\n                    cnt++;\\n                }\\n            }\\n            if (cnt == cols) {\\n                for (int i = 0; i < m; i++) {\\n                    bool flag = false;\\n                    for (int j = 0; j < n; j++) {\\n                        if (st.count(j) == 0) {\\n                            if (mat[i][j] == 1) {\\n                                flag = true;\\n                            }\\n                        }\\n                    }\\n                    if (!flag) temp++;\\n                }\\n            }\\n            mx = max(mx, temp);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>> &mat, int cols) {\\n        int m = mat.size(), n = mat[0].size();\\n        int perm = pow(2, n) - 1;\\n        vector<vector<int>> grid(perm + 1, vector<int>(n, 0));\\n        for (int i = 0; i <= perm; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if ((i & (1 << j)) >= 1) {\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        int mx = 0;\\n        for (int i = 0; i <= perm; i++) {\\n            int cnt = 0, temp = 0;\\n            unordered_set<int> st;\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    st.insert(j);\\n                    cnt++;\\n                }\\n            }\\n            if (cnt == cols) {\\n                for (int i = 0; i < m; i++) {\\n                    bool flag = false;\\n                    for (int j = 0; j < n; j++) {\\n                        if (st.count(j) == 0) {\\n                            if (mat[i][j] == 1) {\\n                                flag = true;\\n                            }\\n                        }\\n                    }\\n                    if (!flag) temp++;\\n                }\\n            }\\n            mx = max(mx, temp);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525580,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Backtracking***\\n\\n* ***Time Complexity :- O(N * M * 2 ^ M)***\\n\\n* ***Space Complexity :- O(N * M * 2 ^ M)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // res will store all the subsequence of size k\\n    \\n    vector<vector<int>> res;\\n    \\n    vector<int> curr;\\n    \\n    // function for finding subsequence of an array\\n    \\n    void dfs(vector<int>& arr, int i, int n, int k)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            if(curr.size() == k)\\n            {\\n                res.push_back(curr);\\n            }\\n            \\n            return;\\n        }\\n        \\n        // for every no. we have two options either we can include or exclude\\n        \\n        // inclusion part\\n        \\n        curr.push_back(arr[i]);\\n        \\n        dfs(arr, i + 1, n, k);\\n        \\n        curr.pop_back();\\n        \\n        // exclusion part\\n        \\n        dfs(arr, i + 1, n, k);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        int n = mat.size();\\n        \\n        int m = mat[0].size();\\n        \\n        // declare and initialize a col_arr\\n        \\n        vector<int> col_arr(m, 0);\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            col_arr[i] = i;\\n        }\\n        \\n        // find all the subsequece of columns of size cols\\n        \\n        dfs(col_arr, 0, m, cols);\\n        \\n        // now for every column combination find the maximum row we can covered\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int k = 0; k < res.size(); k++)\\n        {\\n            vector<int> temp = res[k];\\n            \\n            unordered_set<int> s(temp.begin(), temp.end());\\n            \\n            int count = 0;\\n            \\n            // check every row can we covered or not\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                bool flag = true;\\n                \\n                for(int j = 0; j < m; j++)\\n                {\\n                    if(mat[i][j])\\n                    {\\n                        if(s.count(j) == 0)\\n                        {\\n                            flag = false;\\n                            \\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                if(flag)\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, count);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // res will store all the subsequence of size k\\n    \\n    vector<vector<int>> res;\\n    \\n    vector<int> curr;\\n    \\n    // function for finding subsequence of an array\\n    \\n    void dfs(vector<int>& arr, int i, int n, int k)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            if(curr.size() == k)\\n            {\\n                res.push_back(curr);\\n            }\\n            \\n            return;\\n        }\\n        \\n        // for every no. we have two options either we can include or exclude\\n        \\n        // inclusion part\\n        \\n        curr.push_back(arr[i]);\\n        \\n        dfs(arr, i + 1, n, k);\\n        \\n        curr.pop_back();\\n        \\n        // exclusion part\\n        \\n        dfs(arr, i + 1, n, k);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        int n = mat.size();\\n        \\n        int m = mat[0].size();\\n        \\n        // declare and initialize a col_arr\\n        \\n        vector<int> col_arr(m, 0);\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            col_arr[i] = i;\\n        }\\n        \\n        // find all the subsequece of columns of size cols\\n        \\n        dfs(col_arr, 0, m, cols);\\n        \\n        // now for every column combination find the maximum row we can covered\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int k = 0; k < res.size(); k++)\\n        {\\n            vector<int> temp = res[k];\\n            \\n            unordered_set<int> s(temp.begin(), temp.end());\\n            \\n            int count = 0;\\n            \\n            // check every row can we covered or not\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                bool flag = true;\\n                \\n                for(int j = 0; j < m; j++)\\n                {\\n                    if(mat[i][j])\\n                    {\\n                        if(s.count(j) == 0)\\n                        {\\n                            flag = false;\\n                            \\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                if(flag)\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, count);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525278,
                "title": "backtracking-c",
                "content": "Logic :\\n1. We have to take **cols** no. of columns so we have choice whether to take a particular column or not.\\n2. If we chose a particular column **ind** then we make all the elements of the rows in which column value is **ind**.\\n3. If we do not chose this column then we will backtrack and unvisit the elements which we visited.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int ind,int cnt,vector<vector<int>>& mat,int cols,int &ans,vector<vector<bool>>& vis){\\n        if(ind>mat[0].size()) return;\\n\\t\\t\\n\\t\\t// calculating the rows which are not covered by the chosen columns and substracting from the total rows ,\\n\\t\\t//then we will get the no. of rows covered by the selected columns and then checking for the max value of ans;\\n\\t\\t\\n        if(cnt==cols && ind==mat[0].size()){\\n            int t=0;\\n            for(int i=0;i<mat.size();i++){\\n                \\n                for(int j=0;j<mat[0].size();j++){\\n                    if(vis[i][j]==0&&mat[i][j]==1){\\n                        t++;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(ans<mat.size()-t) ans=mat.size()-t;\\n            return;\\n        }\\n        //taken the current column\\n        for(int i=0;i<mat.size();i++){\\n            vis[i][ind]=1;\\n        }\\n        solve(ind+1,cnt+1,mat,cols,ans,vis);\\n        //not taken the current column \\n        for(int i=0;i<mat.size();i++){\\n            vis[i][ind]=0;\\n        }\\n        solve(ind+1,cnt,mat,cols,ans,vis);\\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        int ans=0;\\n        solve(0,0,mat,cols,ans,vis);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(int ind,int cnt,vector<vector<int>>& mat,int cols,int &ans,vector<vector<bool>>& vis){\\n        if(ind>mat[0].size()) return;\\n\\t\\t\\n\\t\\t// calculating the rows which are not covered by the chosen columns and substracting from the total rows ,\\n\\t\\t//then we will get the no. of rows covered by the selected columns and then checking for the max value of ans;\\n\\t\\t\\n        if(cnt==cols && ind==mat[0].size()){\\n            int t=0;\\n            for(int i=0;i<mat.size();i++){\\n                \\n                for(int j=0;j<mat[0].size();j++){\\n                    if(vis[i][j]==0&&mat[i][j]==1){\\n                        t++;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(ans<mat.size()-t) ans=mat.size()-t;\\n            return;\\n        }\\n        //taken the current column\\n        for(int i=0;i<mat.size();i++){\\n            vis[i][ind]=1;\\n        }\\n        solve(ind+1,cnt+1,mat,cols,ans,vis);\\n        //not taken the current column \\n        for(int i=0;i<mat.size();i++){\\n            vis[i][ind]=0;\\n        }\\n        solve(ind+1,cnt,mat,cols,ans,vis);\\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        int ans=0;\\n        solve(0,0,mat,cols,ans,vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525107,
                "title": "cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    vector<int> v;\\n    int dp[13][4097][13];\\n    int m, n;\\n\\t\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        m = mat.size();\\n        n = mat[0].size();\\n        \\n        for (int i =0; i < m; i++) {\\n            \\n            int a = 0;\\n            for (int j = 0; j < n; j++) {\\n                a *= 2;\\n                a += mat[i][j];\\n            }\\n            v.push_back(a);\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return dfs(0, 0, cols);\\n    }\\n    \\n    int dfs(int i, int j, int cols) {\\n        \\n        if (dp[i][j][cols] != -1) return dp[i][j][cols];\\n        \\n        if (cols == 0 | i == n) {\\n            int ans = 0;\\n            for (auto& num : v) {\\n                if ((~j) & num) continue;\\n                ans += 1;\\n            }\\n            \\n            return dp[i][j][cols] = ans;\\n        }\\n        \\n        int case1 = dfs(i+1, j | (1 << i), cols - 1);\\n        int case2 = dfs(i+1, j, cols);\\n        \\n        return dp[i][j][cols] = max(case1, case2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    vector<int> v;\\n    int dp[13][4097][13];\\n    int m, n;\\n\\t\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        m = mat.size();\\n        n = mat[0].size();\\n        \\n        for (int i =0; i < m; i++) {\\n            \\n            int a = 0;\\n            for (int j = 0; j < n; j++) {\\n                a *= 2;\\n                a += mat[i][j];\\n            }\\n            v.push_back(a);\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return dfs(0, 0, cols);\\n    }\\n    \\n    int dfs(int i, int j, int cols) {\\n        \\n        if (dp[i][j][cols] != -1) return dp[i][j][cols];\\n        \\n        if (cols == 0 | i == n) {\\n            int ans = 0;\\n            for (auto& num : v) {\\n                if ((~j) & num) continue;\\n                ans += 1;\\n            }\\n            \\n            return dp[i][j][cols] = ans;\\n        }\\n        \\n        int case1 = dfs(i+1, j | (1 << i), cols - 1);\\n        int case2 = dfs(i+1, j, cols);\\n        \\n        return dp[i][j][cols] = max(case1, case2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525012,
                "title": "whoever-understand-this-is-a-god-javascript-combinations",
                "content": "FYI, I wrote this solutions and got accepted (just 4 sec before end time) in biweekly contest 86. I understand the code is very brute force. Anyway I\\'m trying to improve my skills. So, ya enjoy reading my solution and if you understand it, now only god, you and I know it :)\\n```\\n/**\\n * @param {number[][]} mat\\n * @param {number} cols\\n * @return {number}\\n */\\nfunction getCombinations(n, k) {\\n    const ans = [];\\n    const arr = [];\\n    \\n    function dfs(i) {\\n        arr.push(i);\\n        \\n        if (arr.length === k) {\\n            ans.push(Array.from(arr));\\n            arr.pop();\\n            return;\\n        }\\n        \\n        for (let j = i + 1; j < n; j++) {\\n            dfs(j);\\n        }\\n        \\n        arr.pop();\\n    }\\n    \\n    for (let i = 0; i < n; i++) {\\n        dfs(i);\\n    }\\n    \\n    return ans;\\n}\\n\\nvar maximumRows = function(mat, cols) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    \\n    let min = 0; // to store no. of rows with all 0\\'s\\n    let ans = 0;\\n    \\n    const map = {}; // to store rows with column numbers having 1\\'s. From ex 1 :- {1: [0, 2], 2: [1, 2]}\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (mat[i][j]) {\\n                if (map[i]) {\\n                    map[i].push(j); // at row i, jth column is having 1\\n                } else {\\n                    map[i] = [j];\\n                }\\n            }\\n        }\\n        if (!map[i]) { // if all values in row i are 0\\'s\\n            min++;\\n        }\\n    }\\n\\t\\n\\t// I need more practice on bit masking so I choose backtracking way to get combinations \\n    // https://leetcode.com/problems/combinations/discuss/2523710/JavaScript-or-TC-O(n!)-or-SC-O(n)\\n    const combinations = getCombinations(n, cols); \\n    const rows = Object.values(map);\\n    \\n\\t// loop through each combination and see if rows having cell value 1 is chosen or not\\n    for (const comb of combinations) {\\n         // assigned min because min contains the count of rows with all 0\\'s (which indicates covered)\\n\\t\\tlet combAns = min;\\n        for (const row of rows) {\\n            // count to check if we reached end of row (all 1\\'s cell of this row are in chosen column combination\\n\\t\\t\\tlet count = 0; \\n            for (let i = 0; i < row.length; i++) {\\n\\t\\t\\t// row[i] holds the cell with value 1, and if that doesn\\'t include in the chosen combination, we break the loop. So, this row is not covered.\\n                if (!comb.includes(row[i])) { \\n                    break;\\n                } else {\\n                    count++;\\n                }\\n            }\\n            if (count === row.length) {\\n                combAns++;\\n            }\\n        }\\n\\t\\t// once we have rows count (combAns) covered by this combination (comb), we take max \\n        ans = Math.max(ans, combAns);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @param {number} cols\\n * @return {number}\\n */\\nfunction getCombinations(n, k) {\\n    const ans = [];\\n    const arr = [];\\n    \\n    function dfs(i) {\\n        arr.push(i);\\n        \\n        if (arr.length === k) {\\n            ans.push(Array.from(arr));\\n            arr.pop();\\n            return;\\n        }\\n        \\n        for (let j = i + 1; j < n; j++) {\\n            dfs(j);\\n        }\\n        \\n        arr.pop();\\n    }\\n    \\n    for (let i = 0; i < n; i++) {\\n        dfs(i);\\n    }\\n    \\n    return ans;\\n}\\n\\nvar maximumRows = function(mat, cols) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    \\n    let min = 0; // to store no. of rows with all 0\\'s\\n    let ans = 0;\\n    \\n    const map = {}; // to store rows with column numbers having 1\\'s. From ex 1 :- {1: [0, 2], 2: [1, 2]}\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (mat[i][j]) {\\n                if (map[i]) {\\n                    map[i].push(j); // at row i, jth column is having 1\\n                } else {\\n                    map[i] = [j];\\n                }\\n            }\\n        }\\n        if (!map[i]) { // if all values in row i are 0\\'s\\n            min++;\\n        }\\n    }\\n\\t\\n\\t// I need more practice on bit masking so I choose backtracking way to get combinations \\n    // https://leetcode.com/problems/combinations/discuss/2523710/JavaScript-or-TC-O(n!)-or-SC-O(n)\\n    const combinations = getCombinations(n, cols); \\n    const rows = Object.values(map);\\n    \\n\\t// loop through each combination and see if rows having cell value 1 is chosen or not\\n    for (const comb of combinations) {\\n         // assigned min because min contains the count of rows with all 0\\'s (which indicates covered)\\n\\t\\tlet combAns = min;\\n        for (const row of rows) {\\n            // count to check if we reached end of row (all 1\\'s cell of this row are in chosen column combination\\n\\t\\t\\tlet count = 0; \\n            for (let i = 0; i < row.length; i++) {\\n\\t\\t\\t// row[i] holds the cell with value 1, and if that doesn\\'t include in the chosen combination, we break the loop. So, this row is not covered.\\n                if (!comb.includes(row[i])) { \\n                    break;\\n                } else {\\n                    count++;\\n                }\\n            }\\n            if (count === row.length) {\\n                combAns++;\\n            }\\n        }\\n\\t\\t// once we have rows count (combAns) covered by this combination (comb), we take max \\n        ans = Math.max(ans, combAns);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524785,
                "title": "easy-short-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int m, n, res;\\n    long long func(const vector<vector<int>>& v, int c, const int&x, int bm) {\\n        if (__builtin_popcount(bm) == x) {\\n            int ans = m;\\n            for (int i = 0;i < m;++i) {\\n                for (int j = 0;j < n;++j) {\\n                    if (v[i][j] == 1 && !(bm & (1 << j))) {\\n                        --ans;\\n                        break;\\n                    }\\n                }\\n            }\\n            return ans;\\n        }\\n        if (c == n) {\\n            return LLONG_MIN;\\n        }\\n        return max(func(v, c + 1, x, bm), func(v, c + 1, x, bm | (1 << c)));\\n    }\\n    int maximumRows(vector<vector<int>>& v, int x) {\\n        m = v.size(), n = v[0].size();\\n        return func(v, 0, x, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n, res;\\n    long long func(const vector<vector<int>>& v, int c, const int&x, int bm) {\\n        if (__builtin_popcount(bm) == x) {\\n            int ans = m;\\n            for (int i = 0;i < m;++i) {\\n                for (int j = 0;j < n;++j) {\\n                    if (v[i][j] == 1 && !(bm & (1 << j))) {\\n                        --ans;\\n                        break;\\n                    }\\n                }\\n            }\\n            return ans;\\n        }\\n        if (c == n) {\\n            return LLONG_MIN;\\n        }\\n        return max(func(v, c + 1, x, bm), func(v, c + 1, x, bm | (1 << c)));\\n    }\\n    int maximumRows(vector<vector<int>>& v, int x) {\\n        m = v.size(), n = v[0].size();\\n        return func(v, 0, x, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586964,
                "title": "brute-force-using-backtracking-c",
                "content": "I tried generating all possible combination of **numSelect** columns using the `f( )` function using backtracking. Then just iteraterd over the matrix for each combination of columns, checked the given condition which just says that if the cell is equal to 1 then it has to be a part of the column selected by current combination of columns.\\n\\n```\\nclass Solution\\n{\\n    int rows, cols;\\n\\n    void f(int idx, int numSelect, vector<vector<int>> &combs, vector<int> cur)\\n    {\\n        if (numSelect <= 0 or idx>=cols)\\n        {\\n            if(numSelect<=0)\\n                combs.push_back(cur);\\n            return;\\n        }\\n        for (int i = idx; i < cols; i++)\\n        {\\n            cur.push_back(i);\\n            f(i+1, numSelect - 1, combs, cur);\\n            cur.pop_back();\\n            f(i+1, numSelect, combs, cur);\\n        }\\n    }\\n\\n    int help(vector<vector<int>> &matrix, int numSelect)\\n    {\\n        vector<vector<int>> combs;\\n        vector<int> cur;\\n        f(0, numSelect, combs, cur);\\n        int maxi= 0;\\n        for (auto &v : combs)\\n        {\\n            int cnt = 0;\\n            for (int j = 0; j < rows; j++)\\n            {\\n                bool is=true;\\n                for (int k = 0; k < cols; k++)\\n                {\\n                    if(find(v.begin(), v.end(), k) == v.end() and matrix[j][k]==1){\\n                        is =false;\\n                        break;\\n                    }\\n                }\\n                if(is)\\n                {\\n                    cnt++;\\n                }\\n            }\\n            maxi=max(maxi,cnt);\\n        }\\n        return maxi;\\n    }\\n\\npublic:\\n    int maximumRows(vector<vector<int>> &matrix, int numSelect)\\n    {\\n        rows = matrix.size(), cols = matrix[0].size();\\n        return help(matrix, numSelect);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    int rows, cols;\\n\\n    void f(int idx, int numSelect, vector<vector<int>> &combs, vector<int> cur)\\n    {\\n        if (numSelect <= 0 or idx>=cols)\\n        {\\n            if(numSelect<=0)\\n                combs.push_back(cur);\\n            return;\\n        }\\n        for (int i = idx; i < cols; i++)\\n        {\\n            cur.push_back(i);\\n            f(i+1, numSelect - 1, combs, cur);\\n            cur.pop_back();\\n            f(i+1, numSelect, combs, cur);\\n        }\\n    }\\n\\n    int help(vector<vector<int>> &matrix, int numSelect)\\n    {\\n        vector<vector<int>> combs;\\n        vector<int> cur;\\n        f(0, numSelect, combs, cur);\\n        int maxi= 0;\\n        for (auto &v : combs)\\n        {\\n            int cnt = 0;\\n            for (int j = 0; j < rows; j++)\\n            {\\n                bool is=true;\\n                for (int k = 0; k < cols; k++)\\n                {\\n                    if(find(v.begin(), v.end(), k) == v.end() and matrix[j][k]==1){\\n                        is =false;\\n                        break;\\n                    }\\n                }\\n                if(is)\\n                {\\n                    cnt++;\\n                }\\n            }\\n            maxi=max(maxi,cnt);\\n        }\\n        return maxi;\\n    }\\n\\npublic:\\n    int maximumRows(vector<vector<int>> &matrix, int numSelect)\\n    {\\n        rows = matrix.size(), cols = matrix[0].size();\\n        return help(matrix, numSelect);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630562,
                "title": "c-easy-to-undersatand-step-by-step",
                "content": "```\\nclass Solution {\\npublic:\\n    int n, ans=0;\\n    vector<int> row_sums;\\n    \\n    int sumOfRow(vector<int> &vec){\\n        int res=0;\\n        for(auto a:vec) res+=a;\\n        return res;\\n    }\\n    \\n    int isPossible(vector<int> &a, vector<int> &b){\\n        int res=0;\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) res++;\\n            else continue;\\n        }\\n        return res;\\n    }\\n    \\n    void helper(vector<vector<int>>& matrix, int c, int count, vector<int> c_sums){\\n        if(c==matrix[0].size()){\\n            if(count==n){\\n                int temp=isPossible(c_sums, row_sums);\\n                if(temp)\\n                    ans=max(ans, temp);\\n            }\\n            return;\\n        }\\n        \\n        helper(matrix, c+1, count, c_sums);\\n        \\n        for(int i=0; i<matrix.size(); i++){\\n            c_sums[i]+=matrix[i][c];\\n        }\\n        helper(matrix, c+1, count+1, c_sums);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        n=numSelect;\\n        for(auto a:matrix){\\n            row_sums.push_back(sumOfRow(a));\\n        }\\n        \\n        vector<int> c_sums(matrix.size(), 0);\\n        helper(matrix, 0, 0, c_sums);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int n, ans=0;\\n    vector<int> row_sums;\\n    \\n    int sumOfRow(vector<int> &vec){\\n        int res=0;\\n        for(auto a:vec) res+=a;\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2592743,
                "title": "maximum-rows-covered-by-columns-solution-java",
                "content": "class Solution {\\n  public int maximumRows(int[][] matrix, int numSelect) {\\n    dfs(matrix, /*colIndex=*/0, numSelect, /*mask=*/0);\\n    return ans;\\n  }\\n\\n  private int ans = 0;\\n\\n  private void dfs(int[][] matrix, int colIndex, int leftColsCount, int mask) {\\n    if (leftColsCount == 0) {\\n      ans = Math.max(ans, getAllZerosRowCount(matrix, mask));\\n      return;\\n    }\\n    if (colIndex == matrix[0].length)\\n      return;\\n\\n    // choose this column\\n    dfs(matrix, colIndex + 1, leftColsCount - 1, mask | 1 << colIndex);\\n    // not choose this column\\n    dfs(matrix, colIndex + 1, leftColsCount, mask);\\n  }\\n\\n  int getAllZerosRowCount(int[][] matrix, int mask) {\\n    int count = 0;\\n    for (int[] row : matrix) {\\n      boolean isAllZeros = true;\\n      for (int i = 0; i < row.length; ++i) {\\n        if (row[i] == 1 && (mask >> i & 1) == 0) {\\n          isAllZeros = false;\\n          break;\\n        }\\n      }\\n      if (isAllZeros)\\n        ++count;\\n    }\\n    return count;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Backtracking",
                    "Bit Manipulation",
                    "Matrix",
                    "Enumeration"
                ],
                "code": "class Solution {\\n  public int maximumRows(int[][] matrix, int numSelect) {\\n    dfs(matrix, /*colIndex=*/0, numSelect, /*mask=*/0);\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2583361,
                "title": "no-backtracking-do-bit-manipulation",
                "content": "\\n\\t\\tclass Solution:\\n\\t\\t\\tdef maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n\\t\\t\\t\\tn = len(matrix)\\n\\t\\t\\t\\ta = [int(\\'\\'.join([str(j) for j in matrix[i]]),2) for i in range(n)]\\n\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tans = a[i] \\n\\t\\t\\t\\t\\tcur = 0\\n\\t\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\t\\tif bin(ans|a[j]).count(\\'1\\') <= numSelect:\\n\\t\\t\\t\\t\\t\\t\\tans|=a[j]\\n\\t\\t\\t\\t\\t\\t\\tcur+=1                     \\n\\t\\t\\t\\t\\tres = max(cur,res)\\n\\t\\t\\t\\treturn res",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\t\\tclass Solution:\\n\\t\\t\\tdef maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n\\t\\t\\t\\tn = len(matrix)\\n\\t\\t\\t\\ta = [int(\\'\\'.join([str(j) for j in matrix[i]]),2) for i in range(n)]\\n\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tans = a[i] \\n\\t\\t\\t\\t\\tcur = 0\\n\\t\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\t\\tif bin(ans|a[j]).count(\\'1\\') <= numSelect:\\n\\t\\t\\t\\t\\t\\t\\tans|=a[j]\\n\\t\\t\\t\\t\\t\\t\\tcur+=1                     \\n\\t\\t\\t\\t\\tres = max(cur,res)\\n\\t\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2554988,
                "title": "python-brute-force",
                "content": "```\\nm = len(matrix)\\n        n = len(matrix[0])\\n        colcombs = list(itertools.combinations(list(range(n)), numSelect))\\n        \\n        maxcovered = 0\\n        for i in range(len(colcombs)):\\n            covered = 0\\n            for j in range(m):\\n                flag = 0\\n                if all(x == 0 for x in matrix[j]):\\n                    flag = 1\\n                  \\n                if all (k in colcombs[i]  for k in range(n) if matrix[j][k] == 1):\\n                    flag = 1\\n                \\n                if flag == 1:\\n                    covered+=1\\n            maxcovered = max(covered, maxcovered)\\n        \\n        return(maxcovered)\\n",
                "solutionTags": [],
                "code": "```\\nm = len(matrix)\\n        n = len(matrix[0])\\n        colcombs = list(itertools.combinations(list(range(n)), numSelect))\\n        \\n        maxcovered = 0\\n        for i in range(len(colcombs)):\\n            covered = 0\\n            for j in range(m):\\n                flag = 0\\n                if all(x == 0 for x in matrix[j]):\\n                    flag = 1\\n                  \\n                if all (k in colcombs[i]  for k in range(n) if matrix[j][k] == 1):\\n                    flag = 1\\n                \\n                if flag == 1:\\n                    covered+=1\\n            maxcovered = max(covered, maxcovered)\\n        \\n        return(maxcovered)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2540212,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int no(int n){\\n        int re = 0;\\n        while(n){ n = n&(n-1); re++;} return  re;\\n    }\\n    \\n    int find(vector<vector<int>>& nums,int bit){\\n        unordered_set<int> st;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0; j<nums[0].size();++j){\\n                if(nums[i][j] && !bool(bit&(1<<j))) st.insert(i);\\n            }\\n        }\\n        return nums.size()-st.size();\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& nums, int numSelect) {\\n        int n = nums.size(), m = nums[0].size();\\n        int bit = (1<<m)-1, re = 0;\\n        for(int i = bit; i>0; i = bit&(i-1)){\\n            if(no(i)==numSelect){\\n                re = max(find(nums,i),re);\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int no(int n){\\n        int re = 0;\\n        while(n){ n = n&(n-1); re++;} return  re;\\n    }\\n    \\n    int find(vector<vector<int>>& nums,int bit){\\n        unordered_set<int> st;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0; j<nums[0].size();++j){\\n                if(nums[i][j] && !bool(bit&(1<<j))) st.insert(i);\\n            }\\n        }\\n        return nums.size()-st.size();\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& nums, int numSelect) {\\n        int n = nums.size(), m = nums[0].size();\\n        int bit = (1<<m)-1, re = 0;\\n        for(int i = bit; i>0; i = bit&(i-1)){\\n            if(no(i)==numSelect){\\n                re = max(find(nums,i),re);\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539294,
                "title": "my-java-solution",
                "content": "***Time Complexity is probably Exponential but I can\\'t say the exact figure.***\\n***Space Complexity: O(N - cols)***\\n```\\nclass Solution {\\n    int M, N;\\n    public int maximumRows(int[][] mat, int cols) {\\n        M = mat.length;\\n        N = mat[0].length;\\n        if(cols == N) return M;\\n        return findMaxRow(N - cols, mat, new ArrayList<>());\\n    }\\n    private int findMaxRow(int cols, int[][] mat, List<Integer> list) {\\n        if(cols == 0) {\\n            int rows = 0;\\n            for(int i=0 ;i<M ;i++) {\\n                boolean isAdded = true;\\n                for(int j : list) {\\n                    if(mat[i][j] == 1) {\\n                        isAdded = false;\\n                        break;\\n                    }\\n                }\\n                if(isAdded) rows++;\\n            }\\n            return rows;\\n        }\\n        \\n        int last = list.size() != 0 ? list.get(list.size() - 1) : -1;\\n        int maxRow = -1;\\n        \\n        for(int i=last + 1 ;i<N ;i++) {\\n            list.add(i);\\n            maxRow = Math.max(maxRow, findMaxRow(cols - 1, mat, list));\\n            list.remove(list.size() - 1);\\n        }\\n        return maxRow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int M, N;\\n    public int maximumRows(int[][] mat, int cols) {\\n        M = mat.length;\\n        N = mat[0].length;\\n        if(cols == N) return M;\\n        return findMaxRow(N - cols, mat, new ArrayList<>());\\n    }\\n    private int findMaxRow(int cols, int[][] mat, List<Integer> list) {\\n        if(cols == 0) {\\n            int rows = 0;\\n            for(int i=0 ;i<M ;i++) {\\n                boolean isAdded = true;\\n                for(int j : list) {\\n                    if(mat[i][j] == 1) {\\n                        isAdded = false;\\n                        break;\\n                    }\\n                }\\n                if(isAdded) rows++;\\n            }\\n            return rows;\\n        }\\n        \\n        int last = list.size() != 0 ? list.get(list.size() - 1) : -1;\\n        int maxRow = -1;\\n        \\n        for(int i=last + 1 ;i<N ;i++) {\\n            list.add(i);\\n            maxRow = Math.max(maxRow, findMaxRow(cols - 1, mat, list));\\n            list.remove(list.size() - 1);\\n        }\\n        return maxRow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536364,
                "title": "simple-backtracking-java-solution",
                "content": "```\\nclass Solution {    \\n    public int calculateNumberOfRows(int [][]mat,Set<Integer> cols){\\n        int n=mat.length,m=mat[0].length;\\n        int cnt=0;\\n        int i,j;\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++) {\\n                if(mat[i][j]==1 && !cols.contains(j)) break;\\n            }\\n            if(j==m) cnt+=1;\\n        }\\n        return cnt;\\n    }\\n    public int maximumRows(int[][] mat, int cols,Set<Integer> col,int colNum,int n) {\\n        if(cols==0 ){\\n            return calculateNumberOfRows(mat,col);            \\n        }\\n        if(colNum>=n) return Integer.MIN_VALUE;\\n        \\n        //pick\\n        col.add(colNum);\\n        int pick=maximumRows(mat,cols-1,col,colNum+1,n);        \\n        col.remove(colNum);\\n        \\n        //not pick\\n        int notPick=maximumRows(mat,cols,col,colNum+1,n);                \\n        return Math.max(pick,notPick);\\n    }\\n    public int maximumRows(int[][] mat, int cols) {\\n        Set<Integer> col=new HashSet<>();\\n        return maximumRows(mat,cols,col,0,mat[0].length);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {    \\n    public int calculateNumberOfRows(int [][]mat,Set<Integer> cols){\\n        int n=mat.length,m=mat[0].length;\\n        int cnt=0;\\n        int i,j;\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++) {\\n                if(mat[i][j]==1 && !cols.contains(j)) break;\\n            }\\n            if(j==m) cnt+=1;\\n        }\\n        return cnt;\\n    }\\n    public int maximumRows(int[][] mat, int cols,Set<Integer> col,int colNum,int n) {\\n        if(cols==0 ){\\n            return calculateNumberOfRows(mat,col);            \\n        }\\n        if(colNum>=n) return Integer.MIN_VALUE;\\n        \\n        //pick\\n        col.add(colNum);\\n        int pick=maximumRows(mat,cols-1,col,colNum+1,n);        \\n        col.remove(colNum);\\n        \\n        //not pick\\n        int notPick=maximumRows(mat,cols,col,colNum+1,n);                \\n        return Math.max(pick,notPick);\\n    }\\n    public int maximumRows(int[][] mat, int cols) {\\n        Set<Integer> col=new HashSet<>();\\n        return maximumRows(mat,cols,col,0,mat[0].length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532020,
                "title": "c-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m(size(mat)), n(size(mat[0]));\\n        int ans = 0, rows;\\n        bool flag;\\n        for(int mask = 1; mask <= (1<<n); mask++) {\\n            if(__builtin_popcount(mask) != cols) continue; \\n            vector<int> col_set(n,0);\\n            rows = 0;\\n            for(int i = 0; i < n; i++) {\\n                if(mask & (1<<i)) {\\n                    col_set[i] = 1;\\n                }\\n            }\\n            for(int i = 0; i < m; i++) {\\n                flag = true;\\n                for(int j = 0; j < n; j++) {\\n\\t                if(!col_set[j] and mat[i][j]) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag) rows += 1;\\n            }\\n            ans = max(ans,rows);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m(size(mat)), n(size(mat[0]));\\n        int ans = 0, rows;\\n        bool flag;\\n        for(int mask = 1; mask <= (1<<n); mask++) {\\n            if(__builtin_popcount(mask) != cols) continue; \\n            vector<int> col_set(n,0);\\n            rows = 0;\\n            for(int i = 0; i < n; i++) {\\n                if(mask & (1<<i)) {\\n                    col_set[i] = 1;\\n                }\\n            }\\n            for(int i = 0; i < m; i++) {\\n                flag = true;\\n                for(int j = 0; j < n; j++) {\\n\\t                if(!col_set[j] and mat[i][j]) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag) rows += 1;\\n            }\\n            ans = max(ans,rows);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530699,
                "title": "simple-backtracking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void pickcolumn(int i,vector<vector<int>>& mat, int cols,int currcols, vector<bool>&visited, int &ans){\\n        if(i==mat[0].size()){\\n            int count=0;\\n            for(int i=0;i<mat.size();i++){\\n                bool flag=true;\\n                for(int j=0;j<mat[0].size();j++){\\n                    if(mat[i][j]==1){\\n                        if(!visited[j]){\\n                          flag=false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(flag){\\n                    count++;\\n                }\\n            }\\n            ans=max(ans,count);\\n            return;\\n        }\\n        \\n        if(currcols<cols){\\n          visited[i]=true;  \\n          pickcolumn(i+1,mat,cols,currcols+1,visited,ans);    \\n          visited[i]=false;\\n        }\\n        pickcolumn(i+1,mat,cols,currcols,visited,ans);\\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        int currcols=0;\\n        int ans=0;\\n        vector<bool>visited(mat[0].size(),0);\\n        pickcolumn(0,mat, cols,currcols,visited,ans);\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    void pickcolumn(int i,vector<vector<int>>& mat, int cols,int currcols, vector<bool>&visited, int &ans){\\n        if(i==mat[0].size()){\\n            int count=0;\\n            for(int i=0;i<mat.size();i++){\\n                bool flag=true;\\n                for(int j=0;j<mat[0].size();j++){\\n                    if(mat[i][j]==1){\\n                        if(!visited[j]){\\n                          flag=false;\\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2528409,
                "title": "c-backtracking-intuitive-approach-4-ms",
                "content": "* Try all possible combination of columns \\n* Check against each combination of columns for the maximum covered rows\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &mat, int curCol , int column, vector<int> &selectedColumn){\\n        \\n        if(column == 0){\\n            int count = 0;\\n            int selectedRows = mat.size();\\n            for(int i =0; i< mat.size(); i++){\\n                for(int j = 0; j < mat[0].size();j++){\\n                    if(selectedColumn[j]) continue;\\n                    if(mat[i][j] == 1){\\n                        selectedRows--;\\n                       break; \\n                    }\\n                    \\n                }\\n            }\\n            return selectedRows;\\n        }\\n        if(curCol >= mat[0].size()) return 0;\\n        selectedColumn[curCol] =1;\\n        int pick = solve(mat, curCol+1, column-1, selectedColumn);\\n            \\n        selectedColumn[curCol] =0;\\n        int notPick = solve(mat, curCol+1, column, selectedColumn);\\n        return max(pick, notPick);\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        vector<int> selectedColumn(mat[0].size());\\n        return solve(mat, 0, cols, selectedColumn);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &mat, int curCol , int column, vector<int> &selectedColumn){\\n        \\n        if(column == 0){\\n            int count = 0;\\n            int selectedRows = mat.size();\\n            for(int i =0; i< mat.size(); i++){\\n                for(int j = 0; j < mat[0].size();j++){\\n                    if(selectedColumn[j]) continue;\\n                    if(mat[i][j] == 1){\\n                        selectedRows--;\\n                       break; \\n                    }\\n                    \\n                }\\n            }\\n            return selectedRows;\\n        }\\n        if(curCol >= mat[0].size()) return 0;\\n        selectedColumn[curCol] =1;\\n        int pick = solve(mat, curCol+1, column-1, selectedColumn);\\n            \\n        selectedColumn[curCol] =0;\\n        int notPick = solve(mat, curCol+1, column, selectedColumn);\\n        return max(pick, notPick);\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        vector<int> selectedColumn(mat[0].size());\\n        return solve(mat, 0, cols, selectedColumn);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528170,
                "title": "super-easy-recursive-code-java",
                "content": "```\\nclass Solution {\\n    int m,n,res = 0, arr[], cols,mat[][];\\n    public int maximumRows(int[][] mat, int cols) {\\n        m = mat.length;\\n        n = mat[0].length;\\n        this.cols = cols;\\n        arr = new int[cols];\\n        this.mat = mat;\\n        recurse(-1,-1);\\n        return res;\\n    }\\n    \\n    void recurse(int i, int donetill){\\n        i++; donetill++;\\n        if(i == cols) check();\\n        else{\\n            for(int j = donetill;j<n;j++){\\n                arr[i] = j;\\n                recurse(i,j);\\n            }\\n        }\\n    }\\n    \\n    void check(){\\n        int count = 0,i,j;\\n        boolean flag;\\n        HashSet<Integer> colsSelected = new HashSet<Integer>();\\n        for(int col : arr) colsSelected.add(col);\\n        for(i=0;i<m;i++){\\n            flag = true;\\n            for(j=0;j<n;j++){\\n                if(mat[i][j]==1 && !colsSelected.contains(j)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) count++;\\n        }\\n        res = Math.max(res, count);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int m,n,res = 0, arr[], cols,mat[][];\\n    public int maximumRows(int[][] mat, int cols) {\\n        m = mat.length;\\n        n = mat[0].length;\\n        this.cols = cols;\\n        arr = new int[cols];\\n        this.mat = mat;\\n        recurse(-1,-1);\\n        return res;\\n    }\\n    \\n    void recurse(int i, int donetill){\\n        i++; donetill++;\\n        if(i == cols) check();\\n        else{\\n            for(int j = donetill;j<n;j++){\\n                arr[i] = j;\\n                recurse(i,j);\\n            }\\n        }\\n    }\\n    \\n    void check(){\\n        int count = 0,i,j;\\n        boolean flag;\\n        HashSet<Integer> colsSelected = new HashSet<Integer>();\\n        for(int col : arr) colsSelected.add(col);\\n        for(i=0;i<m;i++){\\n            flag = true;\\n            for(j=0;j<n;j++){\\n                if(mat[i][j]==1 && !colsSelected.contains(j)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) count++;\\n        }\\n        res = Math.max(res, count);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526442,
                "title": "brute-force-recursive-solution-100-fast",
                "content": "![image](https://assets.leetcode.com/users/images/e86b93ad-bd92-4e2a-879c-1f51c107c7aa_1662236988.9755852.png)\\n",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/e86b93ad-bd92-4e2a-879c-1f51c107c7aa_1662236988.9755852.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2526415,
                "title": "backtracking-trying-all-combinations-of-cols",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>&nums, vector<int> temp, int i, int cols, int m){\\n        \\n        if(i==m){\\n            if(temp.size() == cols)\\n                nums.push_back(temp);\\n            \\n            return ;\\n        }\\n        \\n        // dont take this column\\n        solve(nums, temp, i+1, cols, m);\\n        \\n        // take this column\\n        temp.push_back(i);\\n        solve(nums, temp, i+1, cols, m);\\n        \\n        temp.pop_back();\\n    \\n    }\\n    \\n    int check(vector<vector<int>>& mat, unordered_set<int> &st, int n, int m){\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            bool notValidRow = false;\\n            \\n            for(int j = 0; j<m; j++){\\n                \\n                if(mat[i][j]==1 && st.find(j)==st.end()){\\n                    \\n                    notValidRow = true;\\n                    break;\\n                    \\n                }\\n            }\\n            \\n            if(!notValidRow)\\n                count++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> nums;\\n        vector<int> temp;\\n        solve( nums, temp, 0, cols, m);\\n        int res = 0;\\n        \\n        for(auto it: nums){\\n            \\n            unordered_set<int> st;\\n            \\n            for(auto i: it)\\n                st.insert(i);\\n             \\n            res = max(res,check(mat, st, n, m));\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>&nums, vector<int> temp, int i, int cols, int m){\\n        \\n        if(i==m){\\n            if(temp.size() == cols)\\n                nums.push_back(temp);\\n            \\n            return ;\\n        }\\n        \\n        // dont take this column\\n        solve(nums, temp, i+1, cols, m);\\n        \\n        // take this column\\n        temp.push_back(i);\\n        solve(nums, temp, i+1, cols, m);\\n        \\n        temp.pop_back();\\n    \\n    }\\n    \\n    int check(vector<vector<int>>& mat, unordered_set<int> &st, int n, int m){\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            bool notValidRow = false;\\n            \\n            for(int j = 0; j<m; j++){\\n                \\n                if(mat[i][j]==1 && st.find(j)==st.end()){\\n                    \\n                    notValidRow = true;\\n                    break;\\n                    \\n                }\\n            }\\n            \\n            if(!notValidRow)\\n                count++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> nums;\\n        vector<int> temp;\\n        solve( nums, temp, 0, cols, m);\\n        int res = 0;\\n        \\n        for(auto it: nums){\\n            \\n            unordered_set<int> st;\\n            \\n            for(auto i: it)\\n                st.insert(i);\\n             \\n            res = max(res,check(mat, st, n, m));\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525991,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int maximumRows(int[][] mat, int cols) {\\n        int rows = mat.length;\\n        int col = mat[0].length;\\n        int res = 0;\\n        for(int i = 0; i < (1<<col); i++) {\\n            if(getCount(i) == cols) {\\n                int cnt = 0;\\n                for(int r = 0; r < rows; r++) {\\n                    int flag = 0;\\n                    for(int c = 0; c < col; c++) {\\n                        if(mat[r][c] == 1 && !isPresent(i,c)){\\n                            flag = 1;\\n                            break;\\n                        }\\n                    }\\n                    if(flag == 0) {\\n                       cnt++; \\n                    }\\n                }\\n                res = Math.max(res,cnt);\\n            }\\n        }\\n        return res;    \\n    }\\n    public static int getCount(int i) {\\n        int cnt = 0;\\n        while(i>0) {\\n            cnt += (i&1);\\n            i = i>>1;\\n        }\\n        return cnt;\\n    }\\n    public static boolean isPresent(int mask, int i) {\\n        return ((mask>>i)&1) == 1;\\n    }\\n        \\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRows(int[][] mat, int cols) {\\n        int rows = mat.length;\\n        int col = mat[0].length;\\n        int res = 0;\\n        for(int i = 0; i < (1<<col); i++) {\\n            if(getCount(i) == cols) {\\n                int cnt = 0;\\n                for(int r = 0; r < rows; r++) {\\n                    int flag = 0;\\n                    for(int c = 0; c < col; c++) {\\n                        if(mat[r][c] == 1 && !isPresent(i,c)){\\n                            flag = 1;\\n                            break;\\n                        }\\n                    }\\n                    if(flag == 0) {\\n                       cnt++; \\n                    }\\n                }\\n                res = Math.max(res,cnt);\\n            }\\n        }\\n        return res;    \\n    }\\n    public static int getCount(int i) {\\n        int cnt = 0;\\n        while(i>0) {\\n            cnt += (i&1);\\n            i = i>>1;\\n        }\\n        return cnt;\\n    }\\n    public static boolean isPresent(int mask, int i) {\\n        return ((mask>>i)&1) == 1;\\n    }\\n        \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525827,
                "title": "bit-masking-implementation-easy-understanding-c",
                "content": "I have used concept of bitmasking:\\n1. Convert each row into a number(convert binary to decimal)\\n2. Then we select column by using set bits of 1 to 2^(number of columns)[concept of subset generation]\\n3. Then take ```AND``` and then see if the count of bits is same or not. \\n\\nEx: \\n0 0 0 -> 0\\n1 0 1 -> 5\\n0 1 1 -> 3\\n0 0 1 -> 1\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        vector<int> bit; // to store number formed from  each row\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int num=0;\\n            int b=0;\\n            for(int j=m-1;j>=0;j--){\\n                \\n        \\n                int pow=(1<<b);\\n    \\n                num=num+(mat[i][j]*pow);// converting binary to decimal\\n                b++;\\n                \\n            }\\n            bit.push_back(num);//storing formed number in bit array\\n        }\\n        \\n        int loop=(1<<m);\\n        \\n        int mx=INT_MIN;\\n        for(int i=1;i<loop;i++){// loop to generate all subsets\\n            int bit_count=__builtin_popcount(i);\\n            \\n           \\n            int cnt=0;\\n            if(bit_count==cols){\\n                \\n                for(int j=0;j<bit.size();j++){\\n                    \\n                    int check=bit[j]&i;\\n                    int bit1=__builtin_popcount(bit[j]);\\n                    int bit2=__builtin_popcount(check);\\n                    \\n                    \\n                    if(bit1==bit2 || bit[j]==0){\\n                        cnt++;\\n                    }\\n                }\\n                \\n            }\\n            mx=max(cnt,mx);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```AND```\n```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        vector<int> bit; // to store number formed from  each row\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int num=0;\\n            int b=0;\\n            for(int j=m-1;j>=0;j--){\\n                \\n        \\n                int pow=(1<<b);\\n    \\n                num=num+(mat[i][j]*pow);// converting binary to decimal\\n                b++;\\n                \\n            }\\n            bit.push_back(num);//storing formed number in bit array\\n        }\\n        \\n        int loop=(1<<m);\\n        \\n        int mx=INT_MIN;\\n        for(int i=1;i<loop;i++){// loop to generate all subsets\\n            int bit_count=__builtin_popcount(i);\\n            \\n           \\n            int cnt=0;\\n            if(bit_count==cols){\\n                \\n                for(int j=0;j<bit.size();j++){\\n                    \\n                    int check=bit[j]&i;\\n                    int bit1=__builtin_popcount(bit[j]);\\n                    int bit2=__builtin_popcount(check);\\n                    \\n                    \\n                    if(bit1==bit2 || bit[j]==0){\\n                        cnt++;\\n                    }\\n                }\\n                \\n            }\\n            mx=max(cnt,mx);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525791,
                "title": "simple-intuition-no-bits-backtracking",
                "content": "```\\nclass Solution {\\n    public int maximumRows(int[][] mat, int cols) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int onesInRow[] = new int[m];\\n        //counting number of ones in each row         \\n        List<List<Integer>> onesInCol = new ArrayList<>();\\n        \\n        for(int i=1; i<=n; i++)\\n            onesInCol.add(new ArrayList<Integer>());\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(mat[i][j] == 1){\\n                    onesInRow[i]++;\\n                    onesInCol.get(j).add(i);\\n                }\\n            }\\n        }\\n        \\n        if(cols >= n) return m;\\n        int ans=0;\\n        for(int i:onesInRow)\\n            ans+= i==0 ? 1 : 0;\\n        return ans+removeCols(0, m, n, cols, onesInRow, onesInCol, mat);\\n    }\\n    \\n    private int removeCols(int curr, int m, int n, int cols, int []onesInRow, List<List<Integer>> onesInCol, int[][] mat){\\n        if(cols == 0 || curr==n) return 0;\\n        \\n        \\n        //hataaya\\n        int ans=0;\\n        for(Integer i : onesInCol.get(curr)){            \\n            if(--onesInRow[i] == 0) ans++;\\n        }\\n        int h = ans + removeCols(curr+1, m, n, cols-1, onesInRow, onesInCol, mat);\\n        for(Integer i : onesInCol.get(curr)){            \\n            ++onesInRow[i];\\n        }\\n        //nahi hataaya\\n        int nh = removeCols(curr+1, m, n, cols, onesInRow, onesInCol, mat);\\n\\t\\t\\n        return Math.max(h, nh);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumRows(int[][] mat, int cols) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int onesInRow[] = new int[m];\\n        //counting number of ones in each row         \\n        List<List<Integer>> onesInCol = new ArrayList<>();\\n        \\n        for(int i=1; i<=n; i++)\\n            onesInCol.add(new ArrayList<Integer>());\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(mat[i][j] == 1){\\n                    onesInRow[i]++;\\n                    onesInCol.get(j).add(i);\\n                }\\n            }\\n        }\\n        \\n        if(cols >= n) return m;\\n        int ans=0;\\n        for(int i:onesInRow)\\n            ans+= i==0 ? 1 : 0;\\n        return ans+removeCols(0, m, n, cols, onesInRow, onesInCol, mat);\\n    }\\n    \\n    private int removeCols(int curr, int m, int n, int cols, int []onesInRow, List<List<Integer>> onesInCol, int[][] mat){\\n        if(cols == 0 || curr==n) return 0;\\n        \\n        \\n        //hataaya\\n        int ans=0;\\n        for(Integer i : onesInCol.get(curr)){            \\n            if(--onesInRow[i] == 0) ans++;\\n        }\\n        int h = ans + removeCols(curr+1, m, n, cols-1, onesInRow, onesInCol, mat);\\n        for(Integer i : onesInCol.get(curr)){            \\n            ++onesInRow[i];\\n        }\\n        //nahi hataaya\\n        int nh = removeCols(curr+1, m, n, cols, onesInRow, onesInCol, mat);\\n\\t\\t\\n        return Math.max(h, nh);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525618,
                "title": "plz-anyone-explain-me-the-question-first",
                "content": "Please anyone explain me the question. Thanks in advance!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2525533,
                "title": "java-beats-100-bitmask-backtraking-o-n-n-c",
                "content": "```\\nclass Solution {\\n    \\n    private int ans;\\n    \\n    public int maximumRows(int[][] mat, int cols) {\\n        var masks = new int[mat.length];\\n        // convert every row to bitmask\\n        for (int r = 0; r < mat.length; r++) {\\n            var mask = 0;\\n            for (int c = 0; c < mat[r].length; c++)\\n                if (mat[r][c] == 1)\\n                    mask |= 1 << (mat[r].length - c - 1);\\n            masks[r] = mask;\\n        }       \\n        // brute force all combination of columns\\n        backtrack(0, 0, cols, mat[0].length, masks);\\n        return ans;\\n    }\\n    \\n    private void backtrack(int idx, int mask, int c, int limit, int[] masks) {\\n        if (c == 0) {\\n            // calculate ans\\n            var count = 0;\\n            for (int m : masks)\\n                if ((mask | m) == mask)\\n                    count++;\\n            ans = Math.max(ans, count);\\n            return;\\n        }\\n\\n        if (idx == limit)\\n            return; // nothing to do\\n\\n        // include current element\\n        backtrack(idx + 1, mask | (1 << (limit - idx - 1)), c - 1, limit, masks);\\n        \\n        // exclude current element\\n        backtrack(idx + 1, mask, c, limit, masks);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int ans;\\n    \\n    public int maximumRows(int[][] mat, int cols) {\\n        var masks = new int[mat.length];\\n        // convert every row to bitmask\\n        for (int r = 0; r < mat.length; r++) {\\n            var mask = 0;\\n            for (int c = 0; c < mat[r].length; c++)\\n                if (mat[r][c] == 1)\\n                    mask |= 1 << (mat[r].length - c - 1);\\n            masks[r] = mask;\\n        }       \\n        // brute force all combination of columns\\n        backtrack(0, 0, cols, mat[0].length, masks);\\n        return ans;\\n    }\\n    \\n    private void backtrack(int idx, int mask, int c, int limit, int[] masks) {\\n        if (c == 0) {\\n            // calculate ans\\n            var count = 0;\\n            for (int m : masks)\\n                if ((mask | m) == mask)\\n                    count++;\\n            ans = Math.max(ans, count);\\n            return;\\n        }\\n\\n        if (idx == limit)\\n            return; // nothing to do\\n\\n        // include current element\\n        backtrack(idx + 1, mask | (1 << (limit - idx - 1)), c - 1, limit, masks);\\n        \\n        // exclude current element\\n        backtrack(idx + 1, mask, c, limit, masks);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525503,
                "title": "i-did-not-understand-the-question-please-help",
                "content": "Did anyone understand the problem?????",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2525454,
                "title": "bit-manipulation-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int nost(int &n){\\n        int a=0;\\n        for(int i = 0 ; i<32; i++){\\n            if(n&(1<<i))a++;\\n            \\n        }\\n        return a;\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n = mat[0].size();\\n        int m = mat.size();\\n        int ans =0;\\n        for(int i =0 ; i< (1<<n); i++){\\n            if(nost(i)==cols){\\n                int temp =m;\\n                for(int j =0 ; j< m ;j++){\\n                    for(int k=0 ; k<n; k++){\\n                        if(mat[j][k]){\\n                            if(!(i&(1<<(n-k-1)))){\\n                                temp--;\\n                                break;                                \\n                            }\\n                        }\\n                    }\\n                }\\n                ans= max(ans,temp);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int nost(int &n){\\n        int a=0;\\n        for(int i = 0 ; i<32; i++){\\n            if(n&(1<<i))a++;\\n            \\n        }\\n        return a;\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n = mat[0].size();\\n        int m = mat.size();\\n        int ans =0;\\n        for(int i =0 ; i< (1<<n); i++){\\n            if(nost(i)==cols){\\n                int temp =m;\\n                for(int j =0 ; j< m ;j++){\\n                    for(int k=0 ; k<n; k++){\\n                        if(mat[j][k]){\\n                            if(!(i&(1<<(n-k-1)))){\\n                                temp--;\\n                                break;                                \\n                            }\\n                        }\\n                    }\\n                }\\n                ans= max(ans,temp);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525409,
                "title": "for-those-who-are-finding-it-difficult-to-understand-the-problem-statement",
                "content": "## To simplify this question \\nGiven a matrix of **n** rows and **m** columns, and provided input **col**l(*which is the number of columns you have to pick*)  , you can choose any combination of colums (example say you have a matrix of columns 3) and given col input is 2 you can either choose **(12 , 13 , 23)** ie **3C2** for these elements in the set you have find max rows covered \\n**Definition of Row covered:** For a given row for every cell which contains 1 it has to belong to one of the columns in the chosen combination of colums in the set ,if 0 is present you can neglect those cells.\\nFor the maximum Row covered you have to iterate through all the combination of the column set possible **[12 , 13 , 23]** in this case and check the rows covered in these sets and return the maximum of them\\n\\nExample test case\\n<img width=\"200\" src = \"https://assets.leetcode.com/uploads/2022/07/14/rowscovered.png\">\\n\\nHere choosing **(1,3)** out of **(12,13,23)** will yield you max rows covered \\n\\nLets take **(13)**\\n**First row** :      [0 , 0 , 0 ] all zeroes no need to check already covered - **1** row covered\\n**Second row** : [1 , 0 , 1] : both 1\\'s are at column 1 and column 3 which are in your column combination **(13)** - **2** rows covered\\n**Third row** :    [0 , 1 , 1] :  first 1 is at 2nd column which is not in our column combination **(13)** so not covered ,no need to check for other cells\\n**Fourth row**    [0 , 0 , 1] first 1 at **3** which is in our column combination **(13)** so covered\\n\\nThe maximum rows covered is **3**, you can try for other column combinations **12** and **23** and the result will be less than or equal to 3 so return **3** as the answer.",
                "solutionTags": [],
                "code": "## To simplify this question \\nGiven a matrix of **n** rows and **m** columns, and provided input **col**l(*which is the number of columns you have to pick*)  , you can choose any combination of colums (example say you have a matrix of columns 3) and given col input is 2 you can either choose **(12 , 13 , 23)** ie **3C2** for these elements in the set you have find max rows covered \\n**Definition of Row covered:** For a given row for every cell which contains 1 it has to belong to one of the columns in the chosen combination of colums in the set ,if 0 is present you can neglect those cells.\\nFor the maximum Row covered you have to iterate through all the combination of the column set possible **[12 , 13 , 23]** in this case and check the rows covered in these sets and return the maximum of them\\n\\nExample test case\\n<img width=\"200\" src = \"https://assets.leetcode.com/uploads/2022/07/14/rowscovered.png\">\\n\\nHere choosing **(1,3)** out of **(12,13,23)** will yield you max rows covered \\n\\nLets take **(13)**\\n**First row** :      [0 , 0 , 0 ] all zeroes no need to check already covered - **1** row covered\\n**Second row** : [1 , 0 , 1] : both 1\\'s are at column 1 and column 3 which are in your column combination **(13)** - **2** rows covered\\n**Third row** :    [0 , 1 , 1] :  first 1 is at 2nd column which is not in our column combination **(13)** so not covered ,no need to check for other cells\\n**Fourth row**    [0 , 0 , 1] first 1 at **3** which is in our column combination **(13)** so covered\\n\\nThe maximum rows covered is **3**, you can try for other column combinations **12** and **23** and the result will be less than or equal to 3 so return **3** as the answer.",
                "codeTag": "Unknown"
            },
            {
                "id": 2525334,
                "title": "forcest-brute-of-all-brute-forces",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    int res(int i,vector<int> v,vector<vector<int>>& mat,int cols)\\n    {\\n        if(i==mat[0].size())\\n        {\\n            int ch=0;\\n            for(int i=0;i<v.size();i++)\\n                if(v[i]==1)\\n                    ch++;\\n            if(ch==cols)\\n            {\\n                int val = 0;\\n                for(int i=0;i<mat.size();i++){int c=0;\\n                    for(int j=0;j<mat[0].size();j++){\\n                        if(mat[i][j]==1&&v[j]!=1)\\n                            c=-1;}\\n                    if(c==0)\\n                        val++;\\n                }\\n                ans = max(val,ans);\\n                return -1;\\n            }\\n            else\\n                return -1;\\n        }\\n        else\\n        {\\n            v[i]=0;\\n            res(i+1,v,mat,cols);\\n            v[i]=1;\\n            res(i+1,v,mat,cols);\\n            return -1;\\n        }\\n        return -1;\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        vector<int> v;\\n        for(int i=0;i<mat[0].size();i++)\\n            v.push_back(-1);\\n        res(0,v,mat,cols);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    int res(int i,vector<int> v,vector<vector<int>>& mat,int cols)\\n    {\\n        if(i==mat[0].size())\\n        {\\n            int ch=0;\\n            for(int i=0;i<v.size();i++)\\n                if(v[i]==1)\\n                    ch++;\\n            if(ch==cols)\\n            {\\n                int val = 0;\\n                for(int i=0;i<mat.size();i++){int c=0;\\n                    for(int j=0;j<mat[0].size();j++){\\n                        if(mat[i][j]==1&&v[j]!=1)\\n                            c=-1;}\\n                    if(c==0)\\n                        val++;\\n                }\\n                ans = max(val,ans);\\n                return -1;\\n            }\\n            else\\n                return -1;\\n        }\\n        else\\n        {\\n            v[i]=0;\\n            res(i+1,v,mat,cols);\\n            v[i]=1;\\n            res(i+1,v,mat,cols);\\n            return -1;\\n        }\\n        return -1;\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        vector<int> v;\\n        for(int i=0;i<mat[0].size();i++)\\n            v.push_back(-1);\\n        res(0,v,mat,cols);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525222,
                "title": "bitmasking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n = mat.size(), m = mat[0].size();\\n        int len = (1 << m), ans = 0;\\n        for (int x = 1; x < len; x++)\\n        {\\n            // if the number of chosen columns does not equal cols skip it\\n            if (__builtin_popcount(x) != cols)\\n                continue;\\n            set<int> invalid;\\n            for (int i = 0; i < n; i++)\\n                for (int j = 0; j < m; j++)\\n                    if (mat[i][j] == 1 && !((x >> j) & 1))\\n                        invalid.emplace(i);\\n            ans = max(ans, n - (int)invalid.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int n = mat.size(), m = mat[0].size();\\n        int len = (1 << m), ans = 0;\\n        for (int x = 1; x < len; x++)\\n        {\\n            // if the number of chosen columns does not equal cols skip it\\n            if (__builtin_popcount(x) != cols)\\n                continue;\\n            set<int> invalid;\\n            for (int i = 0; i < n; i++)\\n                for (int j = 0; j < m; j++)\\n                    if (mat[i][j] == 1 && !((x >> j) & 1))\\n                        invalid.emplace(i);\\n            ans = max(ans, n - (int)invalid.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525197,
                "title": "python-simple-and-straightforward-combinations-explained",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        rows = 0\\n        \\n        # iterate over each combintion of the given numer of columns\\n        # the first argument passed to combinations is the list of columns\\' indices\\n        # the second argumnet is the number of columns we need to consider\\n        # e.g., if mat consists of 3 columns, we\\'ll iterate over the following list [(0,1), (0,2), (1,2)]\\n        for c in combinations(range(len(mat[0])), cols):\\n            \\n            # initialise temp which is the number of valid rows for the current iteration\\n            temp = 0\\n            \\n            # iterate over each row in mat\\n            for r in mat:\\n                valid = True\\n                \\n                # iterate over each number in the row (we use enumerate; the index of the number is the column\\'s index)\\n                # check if each number 1 present in the row is also present among columns we consider in the current most outer iteration (c)\\n                # if that\\'s not the case, the row is not valid\\n                for col, n in enumerate(r):\\n                    if valid and n == 1 and col not in c:\\n                        valid = False\\n                if valid:\\n                    temp += 1\\n            \\n            # at the end of the current most outer iteration (c), check if the current number of valid rows (temp) is bigger then the previous one\\n            rows = max(rows, temp)\\n        return rows\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        rows = 0\\n        \\n        # iterate over each combintion of the given numer of columns\\n        # the first argument passed to combinations is the list of columns\\' indices\\n        # the second argumnet is the number of columns we need to consider\\n        # e.g., if mat consists of 3 columns, we\\'ll iterate over the following list [(0,1), (0,2), (1,2)]\\n        for c in combinations(range(len(mat[0])), cols):\\n            \\n            # initialise temp which is the number of valid rows for the current iteration\\n            temp = 0\\n            \\n            # iterate over each row in mat\\n            for r in mat:\\n                valid = True\\n                \\n                # iterate over each number in the row (we use enumerate; the index of the number is the column\\'s index)\\n                # check if each number 1 present in the row is also present among columns we consider in the current most outer iteration (c)\\n                # if that\\'s not the case, the row is not valid\\n                for col, n in enumerate(r):\\n                    if valid and n == 1 and col not in c:\\n                        valid = False\\n                if valid:\\n                    temp += 1\\n            \\n            # at the end of the current most outer iteration (c), check if the current number of valid rows (temp) is bigger then the previous one\\n            rows = max(rows, temp)\\n        return rows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525173,
                "title": "c-backtracking-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        unordered_map<int,int> m;\\n        fun(mat,m,cols,0);\\n        return res;\\n    }\\n    void fun(vector<vector<int>>& mat,unordered_map<int,int>& m,int cols,int i)\\n    {\\n        if(cols==0)\\n        {\\n            int c=0;\\n            for(int p=0;p<mat.size();p++)\\n            {\\n                int f=1;\\n                for(int q=0;q<mat[p].size();q++)\\n                {\\n    // if for a row the element at col i is 1 and this column was not choosen then break\\n                    if(mat[p][q] && !m[q])\\n                    {\\n                        f=0;\\n                        break;\\n                    }\\n                }\\n                c+=f;\\n            }\\n            res=max(res,c);\\n            return;\\n        }\\n        if(i>=mat[0].size())\\n            return;\\n        \\n        // choose the column i or don\\'t choose the column i\\n        fun(mat,m,cols,i+1);\\n        m[i]=1;\\n        fun(mat,m,cols-1,i+1);\\n        m[i]=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        unordered_map<int,int> m;\\n        fun(mat,m,cols,0);\\n        return res;\\n    }\\n    void fun(vector<vector<int>>& mat,unordered_map<int,int>& m,int cols,int i)\\n    {\\n        if(cols==0)\\n        {\\n            int c=0;\\n            for(int p=0;p<mat.size();p++)\\n            {\\n                int f=1;\\n                for(int q=0;q<mat[p].size();q++)\\n                {\\n    // if for a row the element at col i is 1 and this column was not choosen then break\\n                    if(mat[p][q] && !m[q])\\n                    {\\n                        f=0;\\n                        break;\\n                    }\\n                }\\n                c+=f;\\n            }\\n            res=max(res,c);\\n            return;\\n        }\\n        if(i>=mat[0].size())\\n            return;\\n        \\n        // choose the column i or don\\'t choose the column i\\n        fun(mat,m,cols,i+1);\\n        m[i]=1;\\n        fun(mat,m,cols-1,i+1);\\n        m[i]=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525118,
                "title": "ruby-100-bit-mask",
                "content": "#### Runtime: 192 ms, faster than 100.00% of Ruby online submissions\\n#### Memory Usage: 211.1 MB, less than 100.00% of Ruby online submissions\\n```ruby\\ndef maximum_rows(mat, cols)\\n  m, n, max = mat.length, mat[0].length, 0\\n  ints = mat.map{ _1.reduce(0) { |s, n| s * 2 + n }}  # int form line of bits\\n  [*0...n].combination(cols).map { |comb|             # comibations of columns of `cols` length \\n    mask = comb.reduce(0) { |sum, n| sum + (1 << n) } # convert to bit mask (reversed order of bits doesn\\'t metter)\\n    ints.count { |i| mask & i == i }                  # count of mask covers i\\n  }.max                                               # return max\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bitmask"
                ],
                "code": "```ruby\\ndef maximum_rows(mat, cols)\\n  m, n, max = mat.length, mat[0].length, 0\\n  ints = mat.map{ _1.reduce(0) { |s, n| s * 2 + n }}  # int form line of bits\\n  [*0...n].combination(cols).map { |comb|             # comibations of columns of `cols` length \\n    mask = comb.reduce(0) { |sum, n| sum + (1 << n) } # convert to bit mask (reversed order of bits doesn\\'t metter)\\n    ints.count { |i| mask & i == i }                  # count of mask covers i\\n  }.max                                               # return max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2525016,
                "title": "c-solution",
                "content": "```\\npublic int MaximumRows(int[][] mat, int cols) {\\n        var m = mat.Length;\\n        var n = mat[0].Length;\\n        var max = 0;\\n        for (var i = 0; i < 1 << n; i++)\\n        {\\n            var count = 0;\\n            var set = new HashSet<int>();\\n            for (var j = 0; j < n; j++)\\n            {\\n                if ((i & (1 << j)) != 0)\\n                {\\n                    set.Add(j);\\n                }\\n            }\\n            if (set.Count != cols) continue;\\n            for (var j = 0; j < m; j++)\\n            {\\n                var flag = true;\\n                for (var k = 0; k < n; k++)\\n                {\\n                    if (mat[j][k] == 1 && !set.Contains(k))\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if (flag) count++;\\n            }\\n            max = Math.Max(max, count);\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int MaximumRows(int[][] mat, int cols) {\\n        var m = mat.Length;\\n        var n = mat[0].Length;\\n        var max = 0;\\n        for (var i = 0; i < 1 << n; i++)\\n        {\\n            var count = 0;\\n            var set = new HashSet<int>();\\n            for (var j = 0; j < n; j++)\\n            {\\n                if ((i & (1 << j)) != 0)\\n                {\\n                    set.Add(j);\\n                }\\n            }\\n            if (set.Count != cols) continue;\\n            for (var j = 0; j < m; j++)\\n            {\\n                var flag = true;\\n                for (var k = 0; k < n; k++)\\n                {\\n                    if (mat[j][k] == 1 && !set.Contains(k))\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if (flag) count++;\\n            }\\n            max = Math.Max(max, count);\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525004,
                "title": "c-solution-using-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int val=0;\\n        for(int i=0;i<(1<<m);i++)\\n        {\\n            if(__builtin_popcount(i)==cols)\\n            {\\n                int cov=0;\\n                for(int x=0;x<n;x++)\\n                {\\n                    int ans=true;\\n                    int zero=0;\\n                    int count=0;\\n                    for(int y=0;y<m;y++)\\n                    {\\n                        if(mat[x][y]==0)\\n                        {\\n                            zero++;\\n                        }\\n                        else\\n                        {\\n                            if(i&(1<<y))\\n                            {\\n                                if(mat[x][y]==1)\\n                                {\\n                                    count++;\\n                                }\\n                            }\\n                            else\\n                            {\\n                                ans=false;\\n                            }\\n                        }\\n                    }\\n                    if(zero==m)\\n                    {\\n                        cov++;\\n                    }\\n                    else\\n                    {\\n                        if(ans&&count)\\n                        {\\n                            cov++;\\n                        }\\n                    }\\n                }\\n                val=max(val,cov);\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int val=0;\\n        for(int i=0;i<(1<<m);i++)\\n        {\\n            if(__builtin_popcount(i)==cols)\\n            {\\n                int cov=0;\\n                for(int x=0;x<n;x++)\\n                {\\n                    int ans=true;\\n                    int zero=0;\\n                    int count=0;\\n                    for(int y=0;y<m;y++)\\n                    {\\n                        if(mat[x][y]==0)\\n                        {\\n                            zero++;\\n                        }\\n                        else\\n                        {\\n                            if(i&(1<<y))\\n                            {\\n                                if(mat[x][y]==1)\\n                                {\\n                                    count++;\\n                                }\\n                            }\\n                            else\\n                            {\\n                                ans=false;\\n                            }\\n                        }\\n                    }\\n                    if(zero==m)\\n                    {\\n                        cov++;\\n                    }\\n                    else\\n                    {\\n                        if(ans&&count)\\n                        {\\n                            cov++;\\n                        }\\n                    }\\n                }\\n                val=max(val,cov);\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524907,
                "title": "brute-force-bitmasking",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n       \\n        int mx = 0;\\n       \\n        for(int mask=0,cur = 0;mask<(1ll<<(mat[0].size()+1));mask++)\\n        {\\n\\t\\t\\t\\tif(__builtin_popcount(mask) > cols)  // basically checking if no of chosen \\n\\t\\t\\t\\t\\tcontinue;              //columns is exceeding the value of  cols\\n                \\n            cur = 0;\\n           \\n            for(int i=0;i<mat.size();i++)\\n            {\\n               \\n                int cnt = 0;\\n                bool flag = 1;\\n               \\n                for(int j=0;j<mat[0].size();j++)\\n                {\\n\\t\\t\\t\\t\\tif(((mask&(1<<j))==0) and mat[i][j]==1)   //  this is cutting the loop off, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//because the current bit is not set but the current column is set\\n                    {\\n                        flag = 0;\\n                        break;\\n                    }\\n                }\\n               \\n                if(flag)\\n                    cur++;  // if the current row gets checked by the condition then  increment cur\\n            }\\n           \\n            mx = max(mx,cur);\\n        }\\n       \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n       \\n        int mx = 0;\\n       \\n        for(int mask=0,cur = 0;mask<(1ll<<(mat[0].size()+1));mask++)\\n        {\\n\\t\\t\\t\\tif(__builtin_popcount(mask) > cols)  // basically checking if no of chosen \\n\\t\\t\\t\\t\\tcontinue;              //columns is exceeding the value of  cols\\n                \\n            cur = 0;\\n           \\n            for(int i=0;i<mat.size();i++)\\n            {\\n               \\n                int cnt = 0;\\n                bool flag = 1;\\n               \\n                for(int j=0;j<mat[0].size();j++)\\n                {\\n\\t\\t\\t\\t\\tif(((mask&(1<<j))==0) and mat[i][j]==1)   //  this is cutting the loop off, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//because the current bit is not set but the current column is set\\n                    {\\n                        flag = 0;\\n                        break;\\n                    }\\n                }\\n               \\n                if(flag)\\n                    cur++;  // if the current row gets checked by the condition then  increment cur\\n            }\\n           \\n            mx = max(mx,cur);\\n        }\\n       \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524847,
                "title": "brute-backtracking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    int countRow(vector<int>&temp,vector<vector<int>>&mat)\\n    {\\n        int cnt = 0;\\n        unordered_map<int,int>mpp;\\n        for(auto x:temp)mpp[x]++;\\n        \\n        for(auto row : mat)\\n        {\\n            bool flag = true;\\n            for(int i=0 ; i<row.size() ; i++)\\n            {\\n                if(row[i]==1)\\n                {\\n                    if(mpp.find(i)==mpp.end())\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag == true)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void solve(int col , vector<int>&temp ,int cols , vector<vector<int>>&mat )\\n    {\\n        if(col>=mat[0].size())\\n        {\\n            if(cols==0)\\n            {\\n                ans = max(ans , countRow(temp,mat));\\n            }\\n            return ;\\n        }\\n        \\n        // take that column \\n        temp.push_back(col);\\n        solve(col+1,temp,cols-1,mat);\\n        temp.pop_back();\\n        \\n        // don\\'t take\\n        solve(col+1,temp,cols,mat);\\n        \\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        vector<int>temp;\\n        solve(0,temp,cols,mat);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    int countRow(vector<int>&temp,vector<vector<int>>&mat)\\n    {\\n        int cnt = 0;\\n        unordered_map<int,int>mpp;\\n        for(auto x:temp)mpp[x]++;\\n        \\n        for(auto row : mat)\\n        {\\n            bool flag = true;\\n            for(int i=0 ; i<row.size() ; i++)\\n            {\\n                if(row[i]==1)\\n                {\\n                    if(mpp.find(i)==mpp.end())\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag == true)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void solve(int col , vector<int>&temp ,int cols , vector<vector<int>>&mat )\\n    {\\n        if(col>=mat[0].size())\\n        {\\n            if(cols==0)\\n            {\\n                ans = max(ans , countRow(temp,mat));\\n            }\\n            return ;\\n        }\\n        \\n        // take that column \\n        temp.push_back(col);\\n        solve(col+1,temp,cols-1,mat);\\n        temp.pop_back();\\n        \\n        // don\\'t take\\n        solve(col+1,temp,cols,mat);\\n        \\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        vector<int>temp;\\n        solve(0,temp,cols,mat);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524799,
                "title": "python3-enumeration",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/35b262c16bc702edbad6adc895bc8321a037ebaa) for solutions of biweekly 86. \\n\\n```\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        m, n = len(mat), len(mat[0])\\n        masks = []\\n        for i in range(m): \\n            mask = reduce(xor, (1<<j for j in range(n) if mat[i][j]), 0)\\n            masks.append(mask)\\n        ans = 0 \\n        for x in range(1<<n): \\n            if x.bit_count() <= cols: \\n                ans = max(ans, sum(mask & x == mask for mask in masks))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        m, n = len(mat), len(mat[0])\\n        masks = []\\n        for i in range(m): \\n            mask = reduce(xor, (1<<j for j in range(n) if mat[i][j]), 0)\\n            masks.append(mask)\\n        ans = 0 \\n        for x in range(1<<n): \\n            if x.bit_count() <= cols: \\n                ans = max(ans, sum(mask & x == mask for mask in masks))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524796,
                "title": "c-brute-force-using-recursion-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    vector<int>v;\\n    \\n    void count(vector<vector<int>>&mat){\\n        int c = 0;\\n        for(int i = 0;i<mat.size();i++){\\n            int t = 0;\\n            int co= 0 ;\\n            for(int j = 0;j<mat[i].size();j++){\\n                if(mat[i][j] == 1)t++;\\n                if(mat[i][j]==1 && v[j] == 1)co++;\\n            }\\n            if(t == co)c++;\\n        }\\n        \\n        maxi = max(maxi,c);\\n        return;\\n    }\\n    \\n    void dfs(vector<vector<int>>&mat,int c,int cols){\\n        if(cols == 0){\\n            count(mat);\\n            return;\\n        }\\n        if(c >= mat[0].size())return ;\\n        \\n        v[c] = 1;\\n        \\n        dfs(mat,c+1,cols-1);\\n        v[c]=0;\\n        dfs(mat,c+1,cols);\\n        return;\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        if(cols == mat[0].size())return mat.size();\\n        v = vector<int>(mat[0].size(),0);\\n        dfs(mat,0,cols);\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    vector<int>v;\\n    \\n    void count(vector<vector<int>>&mat){\\n        int c = 0;\\n        for(int i = 0;i<mat.size();i++){\\n            int t = 0;\\n            int co= 0 ;\\n            for(int j = 0;j<mat[i].size();j++){\\n                if(mat[i][j] == 1)t++;\\n                if(mat[i][j]==1 && v[j] == 1)co++;\\n            }\\n            if(t == co)c++;\\n        }\\n        \\n        maxi = max(maxi,c);\\n        return;\\n    }\\n    \\n    void dfs(vector<vector<int>>&mat,int c,int cols){\\n        if(cols == 0){\\n            count(mat);\\n            return;\\n        }\\n        if(c >= mat[0].size())return ;\\n        \\n        v[c] = 1;\\n        \\n        dfs(mat,c+1,cols-1);\\n        v[c]=0;\\n        dfs(mat,c+1,cols);\\n        return;\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        if(cols == mat[0].size())return mat.size();\\n        v = vector<int>(mat[0].size(),0);\\n        dfs(mat,0,cols);\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524787,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int bits(int n)\\n    {\\n        int count = 0;\\n        while (n) {\\n            n =n& (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    int binexp(int x,int n){\\n        int a=x;\\n        int prod=1;\\n        while(n)\\n        {\\n            if(n%2==1)prod=prod*a;\\n            a=a*a;\\n            n=n/2;\\n        }\\n        return prod;\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int res=0;\\n        \\n        for(int i=0;i<binexp(2,n);i++)\\n        {\\n            if(bits(i)==cols)\\n            {\\n                vector<int> v(n,0);\\n                int x=i;\\n                for(int i=0;i<n;i++)\\n                {\\n                    v[i]=x%2;\\n                    x/=2;\\n                }\\n                int count=0;\\n                for(int j=0;j<m;j++)\\n                {\\n                    bool check=true;\\n                    for(int k=0;k<n;k++)\\n                    {\\n                        if(mat[j][k]==1 && v[k]==0)\\n                        {\\n                            check=false;break;\\n                        }\\n                    }\\n                    if(check) count++;\\n                    \\n                }\\n                res=max(res,count);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bits(int n)\\n    {\\n        int count = 0;\\n        while (n) {\\n            n =n& (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    int binexp(int x,int n){\\n        int a=x;\\n        int prod=1;\\n        while(n)\\n        {\\n            if(n%2==1)prod=prod*a;\\n            a=a*a;\\n            n=n/2;\\n        }\\n        return prod;\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int res=0;\\n        \\n        for(int i=0;i<binexp(2,n);i++)\\n        {\\n            if(bits(i)==cols)\\n            {\\n                vector<int> v(n,0);\\n                int x=i;\\n                for(int i=0;i<n;i++)\\n                {\\n                    v[i]=x%2;\\n                    x/=2;\\n                }\\n                int count=0;\\n                for(int j=0;j<m;j++)\\n                {\\n                    bool check=true;\\n                    for(int k=0;k<n;k++)\\n                    {\\n                        if(mat[j][k]==1 && v[k]==0)\\n                        {\\n                            check=false;break;\\n                        }\\n                    }\\n                    if(check) count++;\\n                    \\n                }\\n                res=max(res,count);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524745,
                "title": "java-bit-mask-backtracking",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    int mask = 1073741823;\\n    int n;\\n    public int maximumRows(int[][] mat, int cols) {\\n        int[] state = new int[mat.length];\\n        n = mat[0].length;\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                state[i] <<= 1;\\n                state[i] += mat[i][j];\\n            }\\n        }\\n        backtrack(state, cols, 0);\\n        return max;\\n    }\\n    \\n    public void backtrack(int[] state, int cols, int pos) {\\n        if (pos == n || cols == 0) {\\n            int count = 0;\\n            for (int i = 0; i < state.length; i++) {\\n                if (state[i] == 0) count++;\\n            }\\n            max = Math.max(count, max);\\n            return;\\n        }\\n        \\n        // choose col\\n        int[] copystate = new int[state.length];\\n        for (int i = 0; i < state.length; i++) {\\n            copystate[i] = state[i] & (mask ^ (1 << pos));\\n        }\\n        backtrack(copystate, cols-1, pos+1);\\n        \\n        // don\\'t choose col\\n        backtrack(state, cols, pos+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    int mask = 1073741823;\\n    int n;\\n    public int maximumRows(int[][] mat, int cols) {\\n        int[] state = new int[mat.length];\\n        n = mat[0].length;\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                state[i] <<= 1;\\n                state[i] += mat[i][j];\\n            }\\n        }\\n        backtrack(state, cols, 0);\\n        return max;\\n    }\\n    \\n    public void backtrack(int[] state, int cols, int pos) {\\n        if (pos == n || cols == 0) {\\n            int count = 0;\\n            for (int i = 0; i < state.length; i++) {\\n                if (state[i] == 0) count++;\\n            }\\n            max = Math.max(count, max);\\n            return;\\n        }\\n        \\n        // choose col\\n        int[] copystate = new int[state.length];\\n        for (int i = 0; i < state.length; i++) {\\n            copystate[i] = state[i] & (mask ^ (1 << pos));\\n        }\\n        backtrack(copystate, cols-1, pos+1);\\n        \\n        // don\\'t choose col\\n        backtrack(state, cols, pos+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524744,
                "title": "gnerate-all-permutation-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    int covered(vector<vector<int>>& mat,vector<int>&nums){\\n        int count=0;\\n        for(int i=0;i<mat.size();i++){\\n            int f=1;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1 && nums[j]==0) f=0;\\n            }\\n            if(f==1) count++;\\n        }\\n        return count;\\n    }\\n    void solve(vector<int>&nums,int cols,vector<vector<int>>&mat,int i){\\n          if(i>=nums.size() && cols>0) return;\\n          if(cols==0){\\n              ans=max(ans,covered(mat,nums));\\n              return;\\n          }\\n        nums[i]=1;\\n        solve(nums,cols-1,mat,i+1);\\n        nums[i]=0;\\n        solve(nums,cols,mat,i+1);\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        ans=0;\\n        vector<int>nums(mat[0].size(),0);\\n        solve(nums,cols,mat,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    int covered(vector<vector<int>>& mat,vector<int>&nums){\\n        int count=0;\\n        for(int i=0;i<mat.size();i++){\\n            int f=1;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1 && nums[j]==0) f=0;\\n            }\\n            if(f==1) count++;\\n        }\\n        return count;\\n    }\\n    void solve(vector<int>&nums,int cols,vector<vector<int>>&mat,int i){\\n          if(i>=nums.size() && cols>0) return;\\n          if(cols==0){\\n              ans=max(ans,covered(mat,nums));\\n              return;\\n          }\\n        nums[i]=1;\\n        solve(nums,cols-1,mat,i+1);\\n        nums[i]=0;\\n        solve(nums,cols,mat,i+1);\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        ans=0;\\n        vector<int>nums(mat[0].size(),0);\\n        solve(nums,cols,mat,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095559,
                "title": "java-brurteforce-o-5544-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider every possible column combination  and get the max covered row based on selected column.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStandard backtracking algorithm \\n\\n# Complexity\\n- Time complexity: the highest possible combination for given n is 5544  * ( m*n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(columnSelect)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Set<Integer> set = new HashSet<>();\\n    int[][] mat;\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        //tying every possibilities ;\\n        mat =  matrix;\\n        return algo( numSelect,0 , mat[0].length);\\n    }\\n    public int algo( int numSelect  , int strt , int col){\\n        if( strt >= col && numSelect != 0) return Integer.MIN_VALUE;\\n        if(numSelect == 0) return rowCovered();\\n        int res =  0; \\n        for( int i  = strt ; i < col ; i++){\\n            set.add(i);\\n            res = Math.max(res , algo( numSelect - 1 , i+1 , col));\\n            set.remove(i);\\n        }\\n        return res;\\n        \\n    }\\n    public int rowCovered(){\\n        int res = 0 ;\\n        for( int i  = 0 ; i < mat.length ; i++){\\n            int sumd = 0;\\n            for( int j = 0 ; j < mat[0].length ; j++){\\n                if(mat[i][j] ==1 && !set.contains(j)) sumd = 1;\\n            }\\n            if( sumd == 0) res++;\\n        }\\n        return res;\\n    }\\n}\\n// 12\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    Set<Integer> set = new HashSet<>();\\n    int[][] mat;\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        //tying every possibilities ;\\n        mat =  matrix;\\n        return algo( numSelect,0 , mat[0].length);\\n    }\\n    public int algo( int numSelect  , int strt , int col){\\n        if( strt >= col && numSelect != 0) return Integer.MIN_VALUE;\\n        if(numSelect == 0) return rowCovered();\\n        int res =  0; \\n        for( int i  = strt ; i < col ; i++){\\n            set.add(i);\\n            res = Math.max(res , algo( numSelect - 1 , i+1 , col));\\n            set.remove(i);\\n        }\\n        return res;\\n        \\n    }\\n    public int rowCovered(){\\n        int res = 0 ;\\n        for( int i  = 0 ; i < mat.length ; i++){\\n            int sumd = 0;\\n            for( int j = 0 ; j < mat[0].length ; j++){\\n                if(mat[i][j] ==1 && !set.contains(j)) sumd = 1;\\n            }\\n            if( sumd == 0) res++;\\n        }\\n        return res;\\n    }\\n}\\n// 12\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078851,
                "title": "c-gosper-s-hack-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Gosper\\'s Hack\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int ans = 0;\\n        int r = matrix.size(), c = matrix[0].size();\\n        int k = numSelect;\\n        int state = (1 << k) - 1;\\n        while (state < (1 << c)) {\\n            int cur = r;\\n            for (int i = 0; i < r; ++i) {\\n                bool cover = true;\\n                for (int j = 0; j < c; ++j) {\\n                    if (matrix[i][j] == 1 && ((state >> j) & 1) == 0) {\\n                        cover = false;\\n                    }\\n                }\\n                if (!cover) {\\n                    cur--;\\n                }\\n            }\\n            ans = max(ans, cur);\\n            int lb = state & -state;\\n            int r = state + lb;\\n            state = ((r ^ state) >> __builtin_ctz(lb) + 2) | r;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Gosper\\'s Hack\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int ans = 0;\\n        int r = matrix.size(), c = matrix[0].size();\\n        int k = numSelect;\\n        int state = (1 << k) - 1;\\n        while (state < (1 << c)) {\\n            int cur = r;\\n            for (int i = 0; i < r; ++i) {\\n                bool cover = true;\\n                for (int j = 0; j < c; ++j) {\\n                    if (matrix[i][j] == 1 && ((state >> j) & 1) == 0) {\\n                        cover = false;\\n                    }\\n                }\\n                if (!cover) {\\n                    cur--;\\n                }\\n            }\\n            ans = max(ans, cur);\\n            int lb = state & -state;\\n            int r = state + lb;\\n            state = ((r ^ state) >> __builtin_ctz(lb) + 2) | r;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979504,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n\\n        dp = {}\\n        \\n        def backtrack(k, avail, selected):\\n            \\n            if k == 0:\\n                c = 0\\n                for r in range(len(matrix)):\\n                    if sum(matrix[r]) == 0:\\n                        c += 1\\n                        continue\\n                    f = 0\\n                    for i, k in enumerate(matrix[r]):\\n                        # print(selected, i, k)\\n                        if k ==1:\\n                            if i not in selected:\\n                                f =1\\n                                break\\n                    if not f:\\n                        c += 1\\n                # print(c, avail, selected)\\n                return c\\n            \\n            ans = 0\\n\\n            state = tuple(set(selected))\\n            if state in dp:\\n                return dp[state]\\n\\n            for i in range(len(avail)):\\n                ans = max(ans, backtrack(k-1, avail[:i]+avail[i+1:], selected+[avail[i]]))\\n            \\n            dp[state] = ans \\n\\n            return ans\\n\\n        return backtrack(numSelect, [i for i in range(len(matrix[0]))], [])\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n\\n        dp = {}\\n        \\n        def backtrack(k, avail, selected):\\n            \\n            if k == 0:\\n                c = 0\\n                for r in range(len(matrix)):\\n                    if sum(matrix[r]) == 0:\\n                        c += 1\\n                        continue\\n                    f = 0\\n                    for i, k in enumerate(matrix[r]):\\n                        # print(selected, i, k)\\n                        if k ==1:\\n                            if i not in selected:\\n                                f =1\\n                                break\\n                    if not f:\\n                        c += 1\\n                # print(c, avail, selected)\\n                return c\\n            \\n            ans = 0\\n\\n            state = tuple(set(selected))\\n            if state in dp:\\n                return dp[state]\\n\\n            for i in range(len(avail)):\\n                ans = max(ans, backtrack(k-1, avail[:i]+avail[i+1:], selected+[avail[i]]))\\n            \\n            dp[state] = ans \\n\\n            return ans\\n\\n        return backtrack(numSelect, [i for i in range(len(matrix[0]))], [])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956363,
                "title": "python-my-nooby-solution",
                "content": "This is my first time handling bits with backtracking . Great problem with practicing such skills. \\nThis is not a bitmask dp implementation. You can implement by a list / str etc. I found bits interesting and decide to use bitmask.\\n\\nbasically rows hold a dictionary that convert the existing rows into a bitmask, mapping to a count if necessary (slightly increased the speed, if you got redundant comparison you don\\'t need to go through all n rows. We & the current select mask with the row bitmask. If it is still equals to the row bitmask, it is a valid count. \\n\\nThis doesn\\'t contain dp recurrence relation propagation, it is backtracking that when base case detected, we find the number of cover rows. It is more likely you can solve in R*2**N .  \\n\\n\\n```\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        rows = defaultdict(int)\\n        cols = len(matrix[0])\\n        for r in range(len(matrix)):\\n            rm = 0\\n            for c in range(cols):\\n                if matrix[r][c] == 1:   \\n                    rm |= (1<<(cols-1-c))\\n            rows[rm] += 1\\n        \\n        def backtrack(select,index,mask):\\n            if select == 0:\\n                temp = 0\\n                for k,v in rows.items():\\n                    if k&mask == k:\\n                        temp += v \\n                return temp\\n            \\n            if index >= cols:\\n                return 0\\n            \\n            temp = 0\\n            for ind in range(index,cols):\\n                mask |= (1<<(cols-1-ind))\\n                temp = max(temp,backtrack(select-1,ind+1,mask))\\n                mask ^= (1<<(cols-1-ind))\\n            return temp\\n        return backtrack(numSelect,0,0)",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "This is my first time handling bits with backtracking . Great problem with practicing such skills. \\nThis is not a bitmask dp implementation. You can implement by a list / str etc. I found bits interesting and decide to use bitmask.\\n\\nbasically rows hold a dictionary that convert the existing rows into a bitmask, mapping to a count if necessary (slightly increased the speed, if you got redundant comparison you don\\'t need to go through all n rows. We & the current select mask with the row bitmask. If it is still equals to the row bitmask, it is a valid count. \\n\\nThis doesn\\'t contain dp recurrence relation propagation, it is backtracking that when base case detected, we find the number of cover rows. It is more likely you can solve in R*2**N .  \\n\\n\\n```\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        rows = defaultdict(int)\\n        cols = len(matrix[0])\\n        for r in range(len(matrix)):\\n            rm = 0\\n            for c in range(cols):\\n                if matrix[r][c] == 1:   \\n                    rm |= (1<<(cols-1-c))\\n            rows[rm] += 1\\n        \\n        def backtrack(select,index,mask):\\n            if select == 0:\\n                temp = 0\\n                for k,v in rows.items():\\n                    if k&mask == k:\\n                        temp += v \\n                return temp\\n            \\n            if index >= cols:\\n                return 0\\n            \\n            temp = 0\\n            for ind in range(index,cols):\\n                mask |= (1<<(cols-1-ind))\\n                temp = max(temp,backtrack(select-1,ind+1,mask))\\n                mask ^= (1<<(cols-1-ind))\\n            return temp\\n        return backtrack(numSelect,0,0)",
                "codeTag": "Java"
            },
            {
                "id": 3821288,
                "title": "c-backtracking-dfs",
                "content": "# Intuition\\nwe can try all possible combinations of `numSelect` columns and for each combination, check how many rows can be covered. We\\'ll keep track of the maximum number of rows covered throughout the process and return it as the result.\\n\\n# Approach\\n1. Initialize a variable `result` to keep track of the maximum number of rows covered. Set it to a very small value initially.\\n2. Define a helper function `dfs` that performs the backtracking.\\n3. In the `dfs` function, the base case is when we have selected `numSelect` columns. At this point, we need to calculate the number of rows covered by this selection and update the `result` accordingly.\\n4. For each column, we have two options: either select it or skip it. We use a `visited` array to keep track of the columns that are currently selected.\\n5. Recursively call the `dfs` function for the next column with updated state (selecting or skipping the current column).\\n6. Call the `dfs` function for each possible starting column to consider all possible combinations of `numSelect` columns.\\n7. Return the `result` after exploring all possible combinations.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach depends on the number of combinations of `numSelect` columns. The worst-case time complexity would be O(C(n, numSelect) * m) where C(n, numSelect) is the number of combinations of selecting `numSelect` columns from `n` columns, and `m` is the number of rows in the matrix.\\n- Space complexity: The space complexity is O(n), where `n` is the number of columns in the matrix, due to the `visited` array.\\n\\n# Code\\n```cpp\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    int result = INT_MIN;\\n    std::vector<bool> visited;\\n\\n    void dfs(std::vector<std::vector<int>>& matrix, int col, int numSelect, int current) {\\n        if (current == numSelect) {\\n            int temp = 0;\\n            for (int i = 0; i < matrix.size(); ++i) {\\n                bool flag = false;\\n                for (int j = 0; j < matrix[0].size(); ++j) {\\n                    if (matrix[i][j] == 1 && !visited[j]) {\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if (!flag) temp++;\\n            }\\n            result = std::max(result, temp);\\n            return;\\n        }\\n\\n        if (col == matrix[0].size()) return;\\n\\n        // Try selecting the current column\\n        visited[col] = true;\\n        dfs(matrix, col + 1, numSelect, current + 1);\\n        visited[col] = false;\\n\\n        // Try skipping the current column\\n        dfs(matrix, col + 1, numSelect, current);\\n    }\\n\\n    int maximumRows(std::vector<std::vector<int>>& matrix, int numSelect) {\\n        int col = matrix[0].size();\\n        visited = std::vector<bool>(col, false);\\n\\n        // Try all possible starting columns to consider all combinations\\n        for (int i = 0; i <= col - numSelect; ++i) {\\n            dfs(matrix, i, numSelect, 0);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    int result = INT_MIN;\\n    std::vector<bool> visited;\\n\\n    void dfs(std::vector<std::vector<int>>& matrix, int col, int numSelect, int current) {\\n        if (current == numSelect) {\\n            int temp = 0;\\n            for (int i = 0; i < matrix.size(); ++i) {\\n                bool flag = false;\\n                for (int j = 0; j < matrix[0].size(); ++j) {\\n                    if (matrix[i][j] == 1 && !visited[j]) {\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if (!flag) temp++;\\n            }\\n            result = std::max(result, temp);\\n            return;\\n        }\\n\\n        if (col == matrix[0].size()) return;\\n\\n        // Try selecting the current column\\n        visited[col] = true;\\n        dfs(matrix, col + 1, numSelect, current + 1);\\n        visited[col] = false;\\n\\n        // Try skipping the current column\\n        dfs(matrix, col + 1, numSelect, current);\\n    }\\n\\n    int maximumRows(std::vector<std::vector<int>>& matrix, int numSelect) {\\n        int col = matrix[0].size();\\n        visited = std::vector<bool>(col, false);\\n\\n        // Try all possible starting columns to consider all combinations\\n        for (int i = 0; i <= col - numSelect; ++i) {\\n            dfs(matrix, i, numSelect, 0);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3799920,
                "title": "maximum-rows-covered-by-columns-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxi = INT_MIN;\\n    void helper(vector<vector<int>> &mat , int m , int n , int cols , int idx , vector<int> &vis){\\n        if(cols == 0 or idx==n){\\n            int cnt = 0;\\n            for(int p = 0 ; p < m ; p++){\\n                bool check = true;\\n                for(int q = 0 ; q < n; q++){\\n                    // if cell is 1 and not visited then we cannot take this row\\n                    if(mat[p][q] == 1 and vis[q] == 0){\\n                        check = false;\\n                        break;\\n                    }\\n                }\\n                if(check) cnt++;\\n            }\\n            maxi = max(maxi,cnt);\\n            return;\\n        }\\n        \\n        // picking idx th column and marking column as visited\\n        vis[idx]=1;\\n        helper(mat,m,n,cols-1,idx+1,vis);\\n        vis[idx]=0;\\n        \\n        // not picking\\n        helper(mat,m,n,cols,idx+1,vis);\\n        return;\\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<int> vis(n);\\n        \\n        helper(mat,m,n,cols,0,vis);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi = INT_MIN;\\n    void helper(vector<vector<int>> &mat , int m , int n , int cols , int idx , vector<int> &vis){\\n        if(cols == 0 or idx==n){\\n            int cnt = 0;\\n            for(int p = 0 ; p < m ; p++){\\n                bool check = true;\\n                for(int q = 0 ; q < n; q++){\\n                    // if cell is 1 and not visited then we cannot take this row\\n                    if(mat[p][q] == 1 and vis[q] == 0){\\n                        check = false;\\n                        break;\\n                    }\\n                }\\n                if(check) cnt++;\\n            }\\n            maxi = max(maxi,cnt);\\n            return;\\n        }\\n        \\n        // picking idx th column and marking column as visited\\n        vis[idx]=1;\\n        helper(mat,m,n,cols-1,idx+1,vis);\\n        vis[idx]=0;\\n        \\n        // not picking\\n        helper(mat,m,n,cols,idx+1,vis);\\n        return;\\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<int> vis(n);\\n        \\n        helper(mat,m,n,cols,0,vis);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776665,
                "title": "easy-c-fully-explained-commented-code-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(vector<vector<int>>& matrix, int numSelect, int i) {\\n\\n        if(numSelect == 0) {\\n            int ans=0;\\n            for(int j=0; j<matrix.size();j++) {\\n                if(*max_element(matrix[j].begin(), matrix[j].end()) == 0)\\n                    ans++;\\n            }\\n            return ans;\\n        }\\n        if(i==matrix[0].size())     return 0;\\n\\n        // make ith col zero\\n        vector<int> temp;\\n        for(int j=0; j<matrix.size(); j++) {\\n            temp.push_back(matrix[j][i]);\\n            matrix[j][i]=0;\\n        }\\n        int x = func(matrix, numSelect-1, i+1);\\n        //changing values to original\\n        for(int j=0; j<matrix.size(); j++) {\\n            matrix[j][i]=temp[j];\\n        }\\n\\n        // skip current col\\n        int y = func(matrix, numSelect, i+1);\\n\\n        return max(x,y);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        return func(matrix, numSelect, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<vector<int>>& matrix, int numSelect, int i) {\\n\\n        if(numSelect == 0) {\\n            int ans=0;\\n            for(int j=0; j<matrix.size();j++) {\\n                if(*max_element(matrix[j].begin(), matrix[j].end()) == 0)\\n                    ans++;\\n            }\\n            return ans;\\n        }\\n        if(i==matrix[0].size())     return 0;\\n\\n        // make ith col zero\\n        vector<int> temp;\\n        for(int j=0; j<matrix.size(); j++) {\\n            temp.push_back(matrix[j][i]);\\n            matrix[j][i]=0;\\n        }\\n        int x = func(matrix, numSelect-1, i+1);\\n        //changing values to original\\n        for(int j=0; j<matrix.size(); j++) {\\n            matrix[j][i]=temp[j];\\n        }\\n\\n        // skip current col\\n        int y = func(matrix, numSelect, i+1);\\n\\n        return max(x,y);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        return func(matrix, numSelect, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772533,
                "title": "java-solution-beats-100-runtime-bit-masking-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought that comes to the mind is to try all the combinations of selecting `numSelect` columns out of `n` columns and then calculating the number of rows covered by each combination. The backtracking solution is possible because the matrix size parameters `m and n` are in the given range `1 <= m,n <=12`.\\n\\nAlso since `n <= 12 ` we can convert each row `r` of 1\\'s and 0\\'s into a number by setting bits where `matrix[r][col] = 1`. So instead of keeping an array to track which columns we have selected, we can use an integer to represent it.\\n\\n\\n`num = 5 = 0101` represents we have seleted 2nd and 4th column.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    int[] nums;\\n\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        m = matrix.length;\\n        n = matrix[0].length;\\n\\n        nums = new int[m];\\n\\n        // Converting the matric into a 1-D array of numbers that were created \\n        // by converting each row into a number by using bit masking\\n        for (int i=0; i<m; i++) {\\n            int num = 0;\\n            for (int j=n-1; j>=0; j--) {\\n                if (matrix[i][j] == 1) {\\n                    num = num | (1 << (n-1-j));\\n                }\\n            }\\n            nums[i] = num;\\n        }\\n\\n        return func(0, 0, numSelect);\\n    }\\n\\n    // Recursive function to try all the combinations \\n    // of selecting \"numSelect\" columns (in our case \"numSelect\"\" bits)\\n    private int func(int index, int num, int numSelect) {\\n        if (numSelect == 0) {\\n            return getRowsCovered(num);\\n        }\\n\\n        int max = 0;\\n        for (int i=index; i<n-numSelect+1; i++) {\\n            max = Math.max(func(i+1, num | (1 << i), numSelect-1), max);\\n        }\\n\\n        return max;\\n    }\\n\\n    // Checking the number of rows covered if we use the given \"num\".\\n    private int getRowsCovered(int num) {\\n        int cnt = 0;\\n\\n        for (int i=0; i<nums.length; i++) {\\n            if ((num & nums[i]) == nums[i]) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    int[] nums;\\n\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        m = matrix.length;\\n        n = matrix[0].length;\\n\\n        nums = new int[m];\\n\\n        // Converting the matric into a 1-D array of numbers that were created \\n        // by converting each row into a number by using bit masking\\n        for (int i=0; i<m; i++) {\\n            int num = 0;\\n            for (int j=n-1; j>=0; j--) {\\n                if (matrix[i][j] == 1) {\\n                    num = num | (1 << (n-1-j));\\n                }\\n            }\\n            nums[i] = num;\\n        }\\n\\n        return func(0, 0, numSelect);\\n    }\\n\\n    // Recursive function to try all the combinations \\n    // of selecting \"numSelect\" columns (in our case \"numSelect\"\" bits)\\n    private int func(int index, int num, int numSelect) {\\n        if (numSelect == 0) {\\n            return getRowsCovered(num);\\n        }\\n\\n        int max = 0;\\n        for (int i=index; i<n-numSelect+1; i++) {\\n            max = Math.max(func(i+1, num | (1 << i), numSelect-1), max);\\n        }\\n\\n        return max;\\n    }\\n\\n    // Checking the number of rows covered if we use the given \"num\".\\n    private int getRowsCovered(int num) {\\n        int cnt = 0;\\n\\n        for (int i=0; i<nums.length; i++) {\\n            if ((num & nums[i]) == nums[i]) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746069,
                "title": "java-explained-solution-using-bitmasking-and-memoisation",
                "content": "# Intuition\\nMy first thought when seeing this question was to simply try all possible combinations of columns. For each possible combination, I would then calculate its \"score\" (number of rows covered), then return the maximum possible score. Since $$m, n \\\\leq 12$$, an exponential solution may be accepted.\\n\\n# Approach\\nAs such, I decided to use a recursive backtracking approach. I create a helper function `helper(int[][] matrix, int numSelect, int memo, int m, int n)`.\\n\\n`matrix` is the untouched matrix we are given, `numSelect` is the number of remaining columns we can use, `memo` is our bitmask to track which columns have been used (we can do this since n < 32), `m` is the number of rows and `n` is the number of columns.\\n\\n`helper` first checks the stop condition, which is when `numSelect == 0`. If it is, we then calculate the row score and return it. \\n\\nOtherwise, we use a variable `max` to store the max score using the current configuration. We check the bitmask for all remaining available columns we can use. For each of these columns, we take the column, call `helper` on the new `numSelect` and `memo` mask, and take the score. We then set `max = Math.max(max, helper(...))`. Then we undo the mask, and repeat for the other available columns (this is the backtracking step).\\n\\nJust using these steps, our solution obtains a TLE (time limit exceeded) verdict. Realise that we can actually save computation time by using memoisation. In this case, there are two factors affecting our state: \\n1. `numSelect`, which is the number of columns left to allocate, and\\n2. `memo`, which records which columns are available to use.\\n\\nAs such, I use a `HashMap<Integer, HashMap<Integer, Integer>>` to store all results from `helper` to avoid duplicate computations.\\n\\nIf this solution has helped you, be sure to leave an upvote or an encouraging comment! I also welcome comments on how my code can be improved, or solution can be better explained.\\n\\n# Complexity\\n- Time complexity: $$O(n^{numSelect})$$ because for every column present, we try using that column if it is available. Note that $$numSelect \\\\leq n$$, so we can also approximate this to $$O(n^n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: We use a `HashMap<Integer, HashMap<Integer, Integer>>` for storage, where the first key is `numSelect` and the second key is our bitmask, `memo`. We only use the rightmost `n` bits of memo at most. Hence, our first key will have at most `numSelect` values, and our second key will have at most $$2^n$$ values. Hence our space complexity is approximately $$O(numSelect \\\\times 2^n) \\\\approx O(n\\\\times2^n)$$ since $$numSelect \\\\leq n$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Commented Code\\n```\\nclass Solution {\\n    //to store answers we obtained from helper\\n    HashMap<Integer, HashMap<Integer, Integer>> map;\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        this.map = new HashMap<>();\\n        //start with an empty mask and numSelect cols to allocate\\n        return helper(matrix, numSelect, 0, m, n);\\n    }\\n    private int helper(int[][] matrix, int numSelect, int memo, int m, int n) {\\n        //If computation was done previously, return the answer\\n        if (this.map.containsKey(numSelect) && this.map.get(numSelect).containsKey(memo)) {\\n            return this.map.get(numSelect).get(memo);\\n        }\\n        //If we have already allocated all columns, calculate\\n        //the row score\\n        //For it to count, all zeroes must be in our allocated columns\\n        if (numSelect == 0) {\\n            int covered = 0; //represents the row score\\n            //For each row in matrix, check if it counts toward \\n            //the row score.\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    //((memo & (1 << j)) == 0) returns true if the\\n                    //j-th column has not been allocated\\n                    //If the row contains a 1 which our columns do not\\n                    //cover, the row does not add to the score.\\n                    if (matrix[i][j] == 1 && ((memo & (1 << j)) == 0)) {\\n                        //row is not covered\\n                        break;\\n                    }\\n                    if (j == n - 1) {\\n                        covered++;\\n                    }\\n                }\\n            }\\n            return covered;\\n        }\\n        int max = 0; //max possible score with the current state\\n\\n        for (int i = 0; i < n; i++) {\\n            //For each available column, use the column and call \\n            //helper with the new state (decrement column count and update mask)\\n            if ((memo & (1 << i)) == 0) {\\n                //column not taken\\n                memo += (1 << i); //update mask\\n                max = Math.max(max, helper(matrix, numSelect - 1, memo, m, n)); //recursive call\\n                memo -= (1 << i); //revert mask (backtracking step)\\n            }\\n        }\\n\\n        //save the result to avoid duplicate computation\\n        if (!this.map.containsKey(numSelect)) {\\n            HashMap<Integer, Integer> newMap = new HashMap<>();\\n            newMap.put(memo, max);\\n            this.map.put(numSelect, newMap);\\n        } else {\\n            this.map.get(numSelect).put(memo, max);\\n        }\\n\\n        return max;\\n    }\\n}\\n```\\n\\n# Uncommented Code\\n```\\nclass Solution {\\n    HashMap<Integer, HashMap<Integer, Integer>> map;\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        this.map = new HashMap<>();\\n        return helper(matrix, numSelect, 0, m, n);\\n    }\\n    private int helper(int[][] matrix, int numSelect, int memo, int m, int n) {\\n        if (this.map.containsKey(numSelect) && this.map.get(numSelect).containsKey(memo)) {\\n            return this.map.get(numSelect).get(memo);\\n        }\\n        if (numSelect == 0) {\\n            int covered = 0; \\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (matrix[i][j] == 1 && ((memo & (1 << j)) == 0)) {\\n                        break;\\n                    }\\n                    if (j == n - 1) {\\n                        covered++;\\n                    }\\n                }\\n            }\\n            return covered;\\n        }\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            if ((memo & (1 << i)) == 0) {\\n                memo += (1 << i);\\n                max = Math.max(max, helper(matrix, numSelect - 1, memo, m, n));\\n                memo -= (1 << i);\\n            }\\n        }\\n        if (!this.map.containsKey(numSelect)) {\\n            HashMap<Integer, Integer> newMap = new HashMap<>();\\n            newMap.put(memo, max);\\n            this.map.put(numSelect, newMap);\\n        } else {\\n            this.map.get(numSelect).put(memo, max);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation",
                    "Matrix",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    //to store answers we obtained from helper\\n    HashMap<Integer, HashMap<Integer, Integer>> map;\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        this.map = new HashMap<>();\\n        //start with an empty mask and numSelect cols to allocate\\n        return helper(matrix, numSelect, 0, m, n);\\n    }\\n    private int helper(int[][] matrix, int numSelect, int memo, int m, int n) {\\n        //If computation was done previously, return the answer\\n        if (this.map.containsKey(numSelect) && this.map.get(numSelect).containsKey(memo)) {\\n            return this.map.get(numSelect).get(memo);\\n        }\\n        //If we have already allocated all columns, calculate\\n        //the row score\\n        //For it to count, all zeroes must be in our allocated columns\\n        if (numSelect == 0) {\\n            int covered = 0; //represents the row score\\n            //For each row in matrix, check if it counts toward \\n            //the row score.\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    //((memo & (1 << j)) == 0) returns true if the\\n                    //j-th column has not been allocated\\n                    //If the row contains a 1 which our columns do not\\n                    //cover, the row does not add to the score.\\n                    if (matrix[i][j] == 1 && ((memo & (1 << j)) == 0)) {\\n                        //row is not covered\\n                        break;\\n                    }\\n                    if (j == n - 1) {\\n                        covered++;\\n                    }\\n                }\\n            }\\n            return covered;\\n        }\\n        int max = 0; //max possible score with the current state\\n\\n        for (int i = 0; i < n; i++) {\\n            //For each available column, use the column and call \\n            //helper with the new state (decrement column count and update mask)\\n            if ((memo & (1 << i)) == 0) {\\n                //column not taken\\n                memo += (1 << i); //update mask\\n                max = Math.max(max, helper(matrix, numSelect - 1, memo, m, n)); //recursive call\\n                memo -= (1 << i); //revert mask (backtracking step)\\n            }\\n        }\\n\\n        //save the result to avoid duplicate computation\\n        if (!this.map.containsKey(numSelect)) {\\n            HashMap<Integer, Integer> newMap = new HashMap<>();\\n            newMap.put(memo, max);\\n            this.map.put(numSelect, newMap);\\n        } else {\\n            this.map.get(numSelect).put(memo, max);\\n        }\\n\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    HashMap<Integer, HashMap<Integer, Integer>> map;\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        this.map = new HashMap<>();\\n        return helper(matrix, numSelect, 0, m, n);\\n    }\\n    private int helper(int[][] matrix, int numSelect, int memo, int m, int n) {\\n        if (this.map.containsKey(numSelect) && this.map.get(numSelect).containsKey(memo)) {\\n            return this.map.get(numSelect).get(memo);\\n        }\\n        if (numSelect == 0) {\\n            int covered = 0; \\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (matrix[i][j] == 1 && ((memo & (1 << j)) == 0)) {\\n                        break;\\n                    }\\n                    if (j == n - 1) {\\n                        covered++;\\n                    }\\n                }\\n            }\\n            return covered;\\n        }\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            if ((memo & (1 << i)) == 0) {\\n                memo += (1 << i);\\n                max = Math.max(max, helper(matrix, numSelect - 1, memo, m, n));\\n                memo -= (1 << i);\\n            }\\n        }\\n        if (!this.map.containsKey(numSelect)) {\\n            HashMap<Integer, Integer> newMap = new HashMap<>();\\n            newMap.put(memo, max);\\n            this.map.put(numSelect, newMap);\\n        } else {\\n            this.map.get(numSelect).put(memo, max);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722460,
                "title": "100-time-submission-easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res;\\n    vector<vector<int>>v;\\n    int check(vector<int>&temp){\\n        int c=0;\\n        int n=v.size();\\n        int m=v[0].size();\\n        for(int i=0;i<n;i++){\\n            bool p=true;\\n            for(int j=0;j<m;j++){\\n                if(temp[j]==0 and v[i][j]==1) p=false;\\n            }\\n            if(p==true) c++;\\n        }\\n        return c;\\n    }\\n    void solve(int count,vector<int>&temp,int num){\\n        if(count==temp.size()){\\n            int k=0;\\n            for(int u=0;u<temp.size();u++) k+=temp[u];\\n            if(k==num){\\n                res=max(res,check(temp));\\n            }\\n            return ;\\n        }\\n        temp[count]=1;\\n        solve(count+1,temp,num);\\n        temp[count]=0;\\n        solve(count+1,temp,num);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int num) {\\n        res=INT_MIN;\\n        v=matrix;\\n        int m=v[0].size();\\n        vector<int>temp(m,0);\\n        solve(0,temp,num);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res;\\n    vector<vector<int>>v;\\n    int check(vector<int>&temp){\\n        int c=0;\\n        int n=v.size();\\n        int m=v[0].size();\\n        for(int i=0;i<n;i++){\\n            bool p=true;\\n            for(int j=0;j<m;j++){\\n                if(temp[j]==0 and v[i][j]==1) p=false;\\n            }\\n            if(p==true) c++;\\n        }\\n        return c;\\n    }\\n    void solve(int count,vector<int>&temp,int num){\\n        if(count==temp.size()){\\n            int k=0;\\n            for(int u=0;u<temp.size();u++) k+=temp[u];\\n            if(k==num){\\n                res=max(res,check(temp));\\n            }\\n            return ;\\n        }\\n        temp[count]=1;\\n        solve(count+1,temp,num);\\n        temp[count]=0;\\n        solve(count+1,temp,num);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int num) {\\n        res=INT_MIN;\\n        v=matrix;\\n        int m=v[0].size();\\n        vector<int>temp(m,0);\\n        solve(0,temp,num);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702500,
                "title": "java-bitmask",
                "content": "1. Find all combination of $s$, we can just find all $numSelect$ 1-bits from $matrix[0].length$ bits\\n2. Store each row\\'s state to a array in advance\\n3. Let $row$ represents the state of current row. If $s&row=row$, then this row is covered by $s$ \\n4. Update the max result in each iteration\\n```\\nclass Solution {\\n    int n, m;\\n\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        // bitmask\\n        // store the bitmask of each row\\n        this.n = matrix.length;\\n        this.m = matrix[0].length;\\n        int[] statesByRow = new int[n];\\n        List<Integer> s_states = getK1bitsFromNbits(numSelect, m);\\n        for (int i = 0; i < n; i++) {\\n            int state = 0;\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == 1) {\\n                    state |= (1 << j);\\n                }\\n            }\\n            statesByRow[i] = state;\\n        }\\n        int res = 0;\\n        for (int i = 0; i < s_states.size(); i++) {\\n            Integer state = s_states.get(i);\\n            int count = 0;\\n            for (int j = 0; j < this.n; j++) {\\n                if ((statesByRow[j] & state) == statesByRow[j]) count++;\\n            }\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    private List<Integer> getK1bitsFromNbits(int k, int n) {\\n        List<Integer> list = new ArrayList<>();\\n        int state = (1 << k) - 1;\\n        while (state < (1 << n)) {\\n            list.add(state);\\n            int c = state & -state;\\n            int r = state + c;\\n            state = (((r ^ state) >> 2) / c) | r;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int n, m;\\n\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        // bitmask\\n        // store the bitmask of each row\\n        this.n = matrix.length;\\n        this.m = matrix[0].length;\\n        int[] statesByRow = new int[n];\\n        List<Integer> s_states = getK1bitsFromNbits(numSelect, m);\\n        for (int i = 0; i < n; i++) {\\n            int state = 0;\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == 1) {\\n                    state |= (1 << j);\\n                }\\n            }\\n            statesByRow[i] = state;\\n        }\\n        int res = 0;\\n        for (int i = 0; i < s_states.size(); i++) {\\n            Integer state = s_states.get(i);\\n            int count = 0;\\n            for (int j = 0; j < this.n; j++) {\\n                if ((statesByRow[j] & state) == statesByRow[j]) count++;\\n            }\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    private List<Integer> getK1bitsFromNbits(int k, int n) {\\n        List<Integer> list = new ArrayList<>();\\n        int state = (1 << k) - 1;\\n        while (state < (1 << n)) {\\n            list.add(state);\\n            int c = state & -state;\\n            int r = state + c;\\n            state = (((r ^ state) >> 2) / c) | r;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680808,
                "title": "recursion-backtracking-brute-force-c",
                "content": "```\\nclass Solution {\\n    int helper(vector<vector<int>> &matrix, int numSelect, int j, vector<int>& chosen) {\\n        if(numSelect == 0 || j == matrix[0].size()) {\\n            return getNumRows(matrix, chosen);\\n        }\\n        chosen[j] = 1;\\n        int choose = helper(matrix, numSelect - 1, j + 1, chosen);\\n        chosen[j] = 0;\\n        int notchoose = helper(matrix, numSelect, j + 1, chosen);\\n        return max(choose, notchoose);\\n    }\\n    int getNumRows(vector<vector<int>> &matrix, vector<int>& chosen) {\\n        int nrows = 0;\\n        \\n        for(int i = 0; i < matrix.size(); i++) {\\n            bool include = true;\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(matrix[i][j] == 1 && chosen[j] != 1) {\\n                    include = false;\\n                    break;\\n                }\\n            }\\n            if(include) nrows++;\\n        }\\n        return nrows;\\n    }\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<int> chosen(n, 0);\\n        return helper(matrix, numSelect, 0, chosen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int helper(vector<vector<int>> &matrix, int numSelect, int j, vector<int>& chosen) {\\n        if(numSelect == 0 || j == matrix[0].size()) {\\n            return getNumRows(matrix, chosen);\\n        }\\n        chosen[j] = 1;\\n        int choose = helper(matrix, numSelect - 1, j + 1, chosen);\\n        chosen[j] = 0;\\n        int notchoose = helper(matrix, numSelect, j + 1, chosen);\\n        return max(choose, notchoose);\\n    }\\n    int getNumRows(vector<vector<int>> &matrix, vector<int>& chosen) {\\n        int nrows = 0;\\n        \\n        for(int i = 0; i < matrix.size(); i++) {\\n            bool include = true;\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(matrix[i][j] == 1 && chosen[j] != 1) {\\n                    include = false;\\n                    break;\\n                }\\n            }\\n            if(include) nrows++;\\n        }\\n        return nrows;\\n    }\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<int> chosen(n, 0);\\n        return helper(matrix, numSelect, 0, chosen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596504,
                "title": "bit-manipulation-solution-faster-than-95-19",
                "content": "Here we have to find all combination of column choose .So instead of taking extra space like storing visiting array we can take a bit mask for recognizing it\\'s we have choosen the column or not.\\n\\nlike visited[]={0,0,1,1,0,1} ,we can take mask=001101.\\n\\njava Code \\n\\n```\\nclass Solution {\\n    public int maximumRows(int[][] matrix, int k) {\\n        \\n        \\n        helper(matrix,k,0,0,0);\\n        return res;\\n        \\n    }\\n    int res=0;\\n    public void helper(int[][] mat,int k,int idx,int mask,int count)\\n    {\\n        if(idx==mat[0].length)\\n        {\\n            if(count==k)\\n            {\\n            int c=mat.length;\\n            \\n            for(int i=0;i<mat.length;i++)\\n            {\\n                for(int j=0;j<mat[0].length;j++)\\n                {\\n                    if(mat[i][j]==1 && (1<<j &mask)==0 )\\n                    {\\n                        c--;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            res=Math.max(res,c);\\n            }\\n            \\n            return;\\n        }\\n        \\n        \\n        //pick\\n        if(count<=k)\\n        helper(mat,k,idx+1,mask | 1<<idx,count+1);\\n        \\n        //not pick\\n        helper(mat,k,idx+1,mask,count);\\n    }\\n}\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRows(int[][] matrix, int k) {\\n        \\n        \\n        helper(matrix,k,0,0,0);\\n        return res;\\n        \\n    }\\n    int res=0;\\n    public void helper(int[][] mat,int k,int idx,int mask,int count)\\n    {\\n        if(idx==mat[0].length)\\n        {\\n            if(count==k)\\n            {\\n            int c=mat.length;\\n            \\n            for(int i=0;i<mat.length;i++)\\n            {\\n                for(int j=0;j<mat[0].length;j++)\\n                {\\n                    if(mat[i][j]==1 && (1<<j &mask)==0 )\\n                    {\\n                        c--;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            res=Math.max(res,c);\\n            }\\n            \\n            return;\\n        }\\n        \\n        \\n        //pick\\n        if(count<=k)\\n        helper(mat,k,idx+1,mask | 1<<idx,count+1);\\n        \\n        //not pick\\n        helper(mat,k,idx+1,mask,count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582786,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRows(self, matrix, numSelect):\\n        m, n = len(matrix), len(matrix[0])\\n        ans = [i for i in range(n)]\\n        res = [list(i) for i in combinations(ans,numSelect)]\\n\\n        def num_rows_covered(arr):\\n            count = 0\\n\\n            for i in range(m):\\n                total = 0\\n\\n                for j in range(n):\\n                    if j in arr:\\n                        if matrix[i][j] == 1:\\n                            total += 1\\n\\n                if total >= sum(matrix[i]):\\n                    count += 1\\n\\n            return count\\n\\n        return max([num_rows_covered(i) for i in res])\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRows(self, matrix, numSelect):\\n        m, n = len(matrix), len(matrix[0])\\n        ans = [i for i in range(n)]\\n        res = [list(i) for i in combinations(ans,numSelect)]\\n\\n        def num_rows_covered(arr):\\n            count = 0\\n\\n            for i in range(m):\\n                total = 0\\n\\n                for j in range(n):\\n                    if j in arr:\\n                        if matrix[i][j] == 1:\\n                            total += 1\\n\\n                if total >= sum(matrix[i]):\\n                    count += 1\\n\\n            return count\\n\\n        return max([num_rows_covered(i) for i in res])\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580605,
                "title": "c-easy-to-understand-simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    void f(vector<vector<int>>& matrix,int n,int m,int ind,vector<int>&vis,int k){\\n        if(ind>=m){\\n           int cnt=0;\\n            for(int i=0;i<n;i++){\\n                 bool a=true;\\n                for(int j=0;j<m;j++){\\n                    if(matrix[i][j]==1 && vis[j]==0){\\n                        a=false;\\n                        break;}\\n                }\\n                if(a==true)cnt++;\\n            }\\n            maxi=max(maxi,cnt);\\n        return;\\n        }\\n        if(k>0){\\n        vis[ind]=1;\\n        f(matrix,n,m,ind+1,vis,k-1);\\n        vis[ind]=0;\\n        }\\n        f(matrix,n,m,ind+1,vis,k);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> vis(m,0);\\n        f(matrix,n,m,0,vis,k);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    void f(vector<vector<int>>& matrix,int n,int m,int ind,vector<int>&vis,int k){\\n        if(ind>=m){\\n           int cnt=0;\\n            for(int i=0;i<n;i++){\\n                 bool a=true;\\n                for(int j=0;j<m;j++){\\n                    if(matrix[i][j]==1 && vis[j]==0){\\n                        a=false;\\n                        break;}\\n                }\\n                if(a==true)cnt++;\\n            }\\n            maxi=max(maxi,cnt);\\n        return;\\n        }\\n        if(k>0){\\n        vis[ind]=1;\\n        f(matrix,n,m,ind+1,vis,k-1);\\n        vis[ind]=0;\\n        }\\n        f(matrix,n,m,ind+1,vis,k);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> vis(m,0);\\n        f(matrix,n,m,0,vis,k);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454559,
                "title": "backtracking-solution-explained",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int row[];\\n    int col[];\\n    int ans=0;\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        int m= matrix.length;\\n        int n= matrix[0].length;\\n        //create row and col array to keep track of the number of ones in each row and column\\n        row= new int[m];\\n        col= new int[n];\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==1){\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n\\n        backtrack(matrix, numSelect, 0, 0);\\n        return ans;\\n\\n    }\\n\\n    void backtrack(int[][] matrix, int numSelect, int k, int column){\\n        //when we have chosen exactly numSelect columns, check for the answer, i.e. couint the rows with all zeros\\n        if(k==numSelect){\\n            ans= Math.max(ans,checkrows());\\n            return;\\n        }\\n        //we have reached the end of matrix\\n        if(column==col.length)\\n            return;\\n        //2 possibilities for each column\\n        //either we dont consider it\\n        backtrack(matrix, numSelect, k, column+1);\\n        //or we consider it\\n        chooseCol(matrix, column);\\n        backtrack(matrix, numSelect, k+1, column+1);\\n        //remove col means re fill the ones that we turned to zero for next backtracking operation\\n        removeCol(matrix, column);\\n        \\n    }\\n\\n    int checkrows(){\\n        int count=0;\\n        for(int i:row){\\n            if(i==0)\\n                count++;\\n        }\\n        return count;\\n    }\\n    //choose this column means, make all 1s to 0s in this column\\n    void chooseCol(int [][] matrix, int column){\\n        for(int i=0; i<matrix.length; i++){\\n            if(matrix[i][column]==1){\\n                row[i]--;\\n            }\\n        }\\n    }\\n\\n    void removeCol(int [][] matrix, int column){\\n        for(int i=0; i<matrix.length; i++){\\n            if(matrix[i][column]==1){\\n                row[i]++;\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int row[];\\n    int col[];\\n    int ans=0;\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        int m= matrix.length;\\n        int n= matrix[0].length;\\n        //create row and col array to keep track of the number of ones in each row and column\\n        row= new int[m];\\n        col= new int[n];\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==1){\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n\\n        backtrack(matrix, numSelect, 0, 0);\\n        return ans;\\n\\n    }\\n\\n    void backtrack(int[][] matrix, int numSelect, int k, int column){\\n        //when we have chosen exactly numSelect columns, check for the answer, i.e. couint the rows with all zeros\\n        if(k==numSelect){\\n            ans= Math.max(ans,checkrows());\\n            return;\\n        }\\n        //we have reached the end of matrix\\n        if(column==col.length)\\n            return;\\n        //2 possibilities for each column\\n        //either we dont consider it\\n        backtrack(matrix, numSelect, k, column+1);\\n        //or we consider it\\n        chooseCol(matrix, column);\\n        backtrack(matrix, numSelect, k+1, column+1);\\n        //remove col means re fill the ones that we turned to zero for next backtracking operation\\n        removeCol(matrix, column);\\n        \\n    }\\n\\n    int checkrows(){\\n        int count=0;\\n        for(int i:row){\\n            if(i==0)\\n                count++;\\n        }\\n        return count;\\n    }\\n    //choose this column means, make all 1s to 0s in this column\\n    void chooseCol(int [][] matrix, int column){\\n        for(int i=0; i<matrix.length; i++){\\n            if(matrix[i][column]==1){\\n                row[i]--;\\n            }\\n        }\\n    }\\n\\n    void removeCol(int [][] matrix, int column){\\n        for(int i=0; i<matrix.length; i++){\\n            if(matrix[i][column]==1){\\n                row[i]++;\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357560,
                "title": "c-simple-efficient-binary-tree-choice-dfs-with-state-update",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        function<int(int, int, int, bitset<12>)> dfs;\\n        int best_sofar = 0;\\n        dfs = [&dfs, &matrix, &best_sofar] (int c/*column id*/, int k/*remained selection*/, int max_covered_rows, bitset<12> skippedrows) {\\n            if(k < 0 || max_covered_rows <= best_sofar)\\n                return 0;\\n            if(c < 0)\\n                return max_covered_rows;\\n\\n            int pick = dfs(c-1, k-1, max_covered_rows, skippedrows); // pick this column\\n\\n            for(int r = matrix.size()-1; r >= 0;  --r) {\\n                if(!skippedrows[r] && matrix[r][c]) {\\n                    skippedrows[r] = true;\\n                    --max_covered_rows;\\n                }\\n            }\\n            int skip = dfs(c-1, k, max_covered_rows, skippedrows); // skip this column\\n\\n            int ans = max(pick, skip);\\n            best_sofar = max(best_sofar, ans);\\n            return ans;\\n        };\\n        return dfs(matrix[0].size()-1, numSelect, matrix.size(), bitset<12>{});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        function<int(int, int, int, bitset<12>)> dfs;\\n        int best_sofar = 0;\\n        dfs = [&dfs, &matrix, &best_sofar] (int c/*column id*/, int k/*remained selection*/, int max_covered_rows, bitset<12> skippedrows) {\\n            if(k < 0 || max_covered_rows <= best_sofar)\\n                return 0;\\n            if(c < 0)\\n                return max_covered_rows;\\n\\n            int pick = dfs(c-1, k-1, max_covered_rows, skippedrows); // pick this column\\n\\n            for(int r = matrix.size()-1; r >= 0;  --r) {\\n                if(!skippedrows[r] && matrix[r][c]) {\\n                    skippedrows[r] = true;\\n                    --max_covered_rows;\\n                }\\n            }\\n            int skip = dfs(c-1, k, max_covered_rows, skippedrows); // skip this column\\n\\n            int ans = max(pick, skip);\\n            best_sofar = max(best_sofar, ans);\\n            return ans;\\n        };\\n        return dfs(matrix[0].size()-1, numSelect, matrix.size(), bitset<12>{});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331817,
                "title": "76-ms",
                "content": "```ruby\\ndef maximum_rows a, k\\n    return a.size if (n = a[0].size) == k\\n    a.map! { _1.join.to_i(2) }\\n    r = 0\\n    f = -> i, k, m do\\n        if k.zero?\\n            r = [r, a.count { (_1 & m).zero? }].max\\n            return\\n        end\\n        f.(i + 1, k, m) if n - i > k\\n        f.(i + 1, k - 1, m ^ (1 << i))\\n    end\\n    f.(0, k, 2 ** n - 1)\\n    r\\nend\\n```\\n```ruby\\ndef maximum_rows a, k\\n    return a.size if (n = a[0].size) == k\\n    a.map! { _1.join.to_i(2) }\\n    x = 2 ** n - 1\\n    [*(0...n)].combination(k).map do | c |\\n        m = c.reduce(x) { _1 ^ (1 << _2) }\\n        a.count { (_1 & m).zero? }\\n    end .max\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bit Manipulation"
                ],
                "code": "```ruby\\ndef maximum_rows a, k\\n    return a.size if (n = a[0].size) == k\\n    a.map! { _1.join.to_i(2) }\\n    r = 0\\n    f = -> i, k, m do\\n        if k.zero?\\n            r = [r, a.count { (_1 & m).zero? }].max\\n            return\\n        end\\n        f.(i + 1, k, m) if n - i > k\\n        f.(i + 1, k - 1, m ^ (1 << i))\\n    end\\n    f.(0, k, 2 ** n - 1)\\n    r\\nend\\n```\n```ruby\\ndef maximum_rows a, k\\n    return a.size if (n = a[0].size) == k\\n    a.map! { _1.join.to_i(2) }\\n    x = 2 ** n - 1\\n    [*(0...n)].combination(k).map do | c |\\n        m = c.reduce(x) { _1 ^ (1 << _2) }\\n        a.count { (_1 & m).zero? }\\n    end .max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3331345,
                "title": "python-combination-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nenumerate all of possible combination of columns, and count how many rows are covered.\\nand think about that how to count how many rows are covered with given columns we select.\\ne.g. columns we select = [0,1,3], total columns is 4\\nrow               1000\\ncolumns we select 1011\\n\\nrow               1010\\ncolumns we select 1011\\n\\nrow               1011\\ncolumns we select 1011\\n\\nrow               0001\\ncolumns we select 1011\\n\\n...\\nthe rows in these case are covered\\n\\nwe can use (row & columns we select == columns we select) to check if a row is coverd or not.\\n\\ntc is O(n * 2^n), sc is O(len(matrix) * len(matrix[0]))\\n\\'\\'\\'\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        numRow, numCol = len(matrix), len(matrix[0])\\n        if numSelect == numCol: return numRow\\n        bitmasks = []\\n        for r in matrix:\\n            cur = 0\\n            for idx, n in enumerate(r):\\n                if n: cur |= 1 << idx\\n            bitmasks.append(cur)\\n\\n        ans = 0\\n        track = 0\\n        selected = 0\\n        def dfs(i):\\n            nonlocal ans, track, selected\\n            if numCol - i < numSelect - selected: return\\n            selected += 1\\n            track |= 1 << i\\n            if selected == numSelect:\\n                ans = max(self.countRows(bitmasks, track), ans)\\n                selected -= 1\\n                track ^= 1 << i\\n                return\\n\\n            for j in range(i+1, numCol):\\n                dfs(j)\\n            selected -= 1\\n            track ^= 1 << i\\n\\n        for i in range(numCol-numSelect+1):\\n            dfs(i)\\n        return ans\\n\\n    def countRows(self, bitmasks, track):\\n        cnt = 0\\n        for bits in bitmasks:\\n            if bits | track == track: cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```python\\n\\'\\'\\'\\nenumerate all of possible combination of columns, and count how many rows are covered.\\nand think about that how to count how many rows are covered with given columns we select.\\ne.g. columns we select = [0,1,3], total columns is 4\\nrow               1000\\ncolumns we select 1011\\n\\nrow               1010\\ncolumns we select 1011\\n\\nrow               1011\\ncolumns we select 1011\\n\\nrow               0001\\ncolumns we select 1011\\n\\n...\\nthe rows in these case are covered\\n\\nwe can use (row & columns we select == columns we select) to check if a row is coverd or not.\\n\\ntc is O(n * 2^n), sc is O(len(matrix) * len(matrix[0]))\\n\\'\\'\\'\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        numRow, numCol = len(matrix), len(matrix[0])\\n        if numSelect == numCol: return numRow\\n        bitmasks = []\\n        for r in matrix:\\n            cur = 0\\n            for idx, n in enumerate(r):\\n                if n: cur |= 1 << idx\\n            bitmasks.append(cur)\\n\\n        ans = 0\\n        track = 0\\n        selected = 0\\n        def dfs(i):\\n            nonlocal ans, track, selected\\n            if numCol - i < numSelect - selected: return\\n            selected += 1\\n            track |= 1 << i\\n            if selected == numSelect:\\n                ans = max(self.countRows(bitmasks, track), ans)\\n                selected -= 1\\n                track ^= 1 << i\\n                return\\n\\n            for j in range(i+1, numCol):\\n                dfs(j)\\n            selected -= 1\\n            track ^= 1 << i\\n\\n        for i in range(numCol-numSelect+1):\\n            dfs(i)\\n        return ans\\n\\n    def countRows(self, bitmasks, track):\\n        cnt = 0\\n        for bits in bitmasks:\\n            if bits | track == track: cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324045,
                "title": "backtracking-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int ans,rows,cols;\\n    void f(vector<vector<int>>& matrix, int numSelect, int i, vector<int> &vis)\\n    {\\n        if(numSelect==0)\\n        {\\n            int count=0;\\n            for(int x=0; x<rows; x++)\\n            {\\n                int f=1;\\n                for(int y=0; y<cols; y++)\\n                {\\n                    if(vis[y]) continue;\\n                    if(matrix[x][y])\\n                    {\\n                        f=0;\\n                        break;\\n                    }\\n                }\\n                if(f) count++;\\n            }\\n            ans=max(ans,count);\\n            return;\\n        }\\n        if(i==cols) return;\\n        vis[i]=1;\\n        f(matrix,numSelect-1,i+1,vis);\\n        vis[i]=0;\\n        f(matrix,numSelect,i+1,vis);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) \\n    {\\n        ans=0;\\n        rows=matrix.size(), cols=matrix[0].size();\\n        if(numSelect>=cols) return rows;\\n        vector<int> vis(cols,0);\\n        f(matrix,numSelect,0,vis);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int ans,rows,cols;\\n    void f(vector<vector<int>>& matrix, int numSelect, int i, vector<int> &vis)\\n    {\\n        if(numSelect==0)\\n        {\\n            int count=0;\\n            for(int x=0; x<rows; x++)\\n            {\\n                int f=1;\\n                for(int y=0; y<cols; y++)\\n                {\\n                    if(vis[y]) continue;\\n                    if(matrix[x][y])\\n                    {\\n                        f=0;\\n                        break;\\n                    }\\n                }\\n                if(f) count++;\\n            }\\n            ans=max(ans,count);\\n            return;\\n        }\\n        if(i==cols) return;\\n        vis[i]=1;\\n        f(matrix,numSelect-1,i+1,vis);\\n        vis[i]=0;\\n        f(matrix,numSelect,i+1,vis);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) \\n    {\\n        ans=0;\\n        rows=matrix.size(), cols=matrix[0].size();\\n        if(numSelect>=cols) return rows;\\n        vector<int> vis(cols,0);\\n        f(matrix,numSelect,0,vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290794,
                "title": "c-next-permutation-no-recusrion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int sel) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> arr(n, 0);\\n        // store in sorted form i.e 0,0,0,....1,1 so that next_permutation can work\\n        for(int i = 0 ; i < sel ; i++){\\n            arr[n-i-1] = 1;\\n        }\\n\\n        // Find every permutation\\n        int ans = 0;\\n        do{\\n            int cnt = 0;\\n\\n            // check for number of rows covered by zeroes\\n            vector<int> rows(m, 1);\\n            for(int i = 0 ; i < n ; i++){\\n                if(arr[i] == 1) continue;\\n                for(int j = 0 ; j < m ; j++){\\n                    if(matrix[j][i] == 1)\\n                        rows[j] = 0;\\n                }\\n            }\\n            for(auto it : rows){\\n                if(it == 1) cnt++;\\n            }\\n            ans = max(ans, cnt);\\n        }while(next_permutation(arr.begin(),arr.end()));\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int sel) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> arr(n, 0);\\n        // store in sorted form i.e 0,0,0,....1,1 so that next_permutation can work\\n        for(int i = 0 ; i < sel ; i++){\\n            arr[n-i-1] = 1;\\n        }\\n\\n        // Find every permutation\\n        int ans = 0;\\n        do{\\n            int cnt = 0;\\n\\n            // check for number of rows covered by zeroes\\n            vector<int> rows(m, 1);\\n            for(int i = 0 ; i < n ; i++){\\n                if(arr[i] == 1) continue;\\n                for(int j = 0 ; j < m ; j++){\\n                    if(matrix[j][i] == 1)\\n                        rows[j] = 0;\\n                }\\n            }\\n            for(auto it : rows){\\n                if(it == 1) cnt++;\\n            }\\n            ans = max(ans, cnt);\\n        }while(next_permutation(arr.begin(),arr.end()));\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282788,
                "title": "fast-solution-in-c",
                "content": "# Intuition\\nUsing Linq operations and bit operations wherever possible.\\n\\n# Approach\\nGiven mask bit m and row value bit v, the row is uncovered only if ~m&v = 1. Using this to speed up calculation\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumRows(int[][] matrix, int numSelect) {\\n        List<int> bitMatrix = matrix.Select(x => x.Reverse().Select((y, iy) => (y, iy)).Sum(val => val.y*(1<<val.iy))).ToList();\\n        foreach(int bit in bitMatrix) Console.Write(bit + \",\");\\n        Console.WriteLine();\\n        \\n        IEnumerable<List<int>> combs = Enumerable.Range(0, 1 << (matrix[0].Length)).Select(index => Enumerable.Range(0, matrix[0].Length)\\n                              .Where((v, i) => (index & (1 << i)) != 0).ToList());\\n        IEnumerable<int> masks = combs.Select(x => x.Sum(y => 1<<y));\\n        foreach(int bit in masks) Console.Write(bit + \",\");\\n        Console.WriteLine();\\n        masks = masks.Where(x => getBits(x) <= numSelect);\\n\\n        int maxCov = 0;\\n        int maxCovMask = 0;\\n        foreach(int mask in masks){\\n            Console.WriteLine(mask);\\n            int cov = 0;\\n            foreach(int bitMap in bitMatrix){\\n                if ( (~mask & bitMap) == 0) cov++;\\n            }\\n            if (maxCov < cov) {\\n                maxCov = cov;\\n                maxCovMask = mask;\\n            } \\n        }\\n        return maxCov;\\n    }\\n\\n    public int getBits(int val){\\n        int bits = 0;\\n        while(val>0){\\n            bits += val & 1;\\n            val >>=1;\\n        }\\n        return bits;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumRows(int[][] matrix, int numSelect) {\\n        List<int> bitMatrix = matrix.Select(x => x.Reverse().Select((y, iy) => (y, iy)).Sum(val => val.y*(1<<val.iy))).ToList();\\n        foreach(int bit in bitMatrix) Console.Write(bit + \",\");\\n        Console.WriteLine();\\n        \\n        IEnumerable<List<int>> combs = Enumerable.Range(0, 1 << (matrix[0].Length)).Select(index => Enumerable.Range(0, matrix[0].Length)\\n                              .Where((v, i) => (index & (1 << i)) != 0).ToList());\\n        IEnumerable<int> masks = combs.Select(x => x.Sum(y => 1<<y));\\n        foreach(int bit in masks) Console.Write(bit + \",\");\\n        Console.WriteLine();\\n        masks = masks.Where(x => getBits(x) <= numSelect);\\n\\n        int maxCov = 0;\\n        int maxCovMask = 0;\\n        foreach(int mask in masks){\\n            Console.WriteLine(mask);\\n            int cov = 0;\\n            foreach(int bitMap in bitMatrix){\\n                if ( (~mask & bitMap) == 0) cov++;\\n            }\\n            if (maxCov < cov) {\\n                maxCov = cov;\\n                maxCovMask = mask;\\n            } \\n        }\\n        return maxCov;\\n    }\\n\\n    public int getBits(int val){\\n        int bits = 0;\\n        while(val>0){\\n            bits += val & 1;\\n            val >>=1;\\n        }\\n        return bits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276435,
                "title": "golang-bit-manipulation",
                "content": "# Code\\n```\\nfunc setBitCount(n int) int {\\n    var count int = 0\\n    for n > 0 {\\n        n -= (n & -n)\\n        count++\\n    }\\n    return count\\n}\\n\\nfunc maximumRows(matrix [][]int, numSelect int) int {\\n    var m int = len(matrix)\\n    var n int = len(matrix[0])\\n    decimal := make([]int, m)\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            decimal[i] = decimal[i] * 2 + matrix[i][j]\\n        }\\n    }\\n    var k, ans int = 1 << n, 0\\n    for i := 0; i < k; i++ {\\n        if setBitCount(i) != numSelect {continue}\\n        var val, count int = k - i - 1, 0\\n        for j := 0; j < m; j++ {\\n            if val & decimal[j] == 0 {\\n                count++\\n            }\\n        }\\n        if count > ans {\\n            ans = count\\n        }\\n    }\\n    return ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation",
                    "Matrix",
                    "Enumeration"
                ],
                "code": "```\\nfunc setBitCount(n int) int {\\n    var count int = 0\\n    for n > 0 {\\n        n -= (n & -n)\\n        count++\\n    }\\n    return count\\n}\\n\\nfunc maximumRows(matrix [][]int, numSelect int) int {\\n    var m int = len(matrix)\\n    var n int = len(matrix[0])\\n    decimal := make([]int, m)\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            decimal[i] = decimal[i] * 2 + matrix[i][j]\\n        }\\n    }\\n    var k, ans int = 1 << n, 0\\n    for i := 0; i < k; i++ {\\n        if setBitCount(i) != numSelect {continue}\\n        var val, count int = k - i - 1, 0\\n        for j := 0; j < m; j++ {\\n            if val & decimal[j] == 0 {\\n                count++\\n            }\\n        }\\n        if count > ans {\\n            ans = count\\n        }\\n    }\\n    return ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3276397,
                "title": "c-bit-manipulation",
                "content": "# Code\\n```\\nclass Solution {\\n    int setBitCount(int n) {\\n        int count = 0;\\n        while(n) {\\n            n -= (n & -n);\\n            count++;\\n        }\\n        return count;\\n    }\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<int> decimal(m, 0);\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                decimal[i] = decimal[i] * 2 + matrix[i][j];\\n            }\\n        }\\n        int k = 1 << n, ans = 0;\\n        for(int i = 0; i < k; i++) {\\n            if(setBitCount(i) != numSelect) continue;\\n            int val = k - i - 1, count = 0;\\n            for(int j = 0; j < m; j++) {\\n                count += !(val & decimal[j]);\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Matrix",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    int setBitCount(int n) {\\n        int count = 0;\\n        while(n) {\\n            n -= (n & -n);\\n            count++;\\n        }\\n        return count;\\n    }\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<int> decimal(m, 0);\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                decimal[i] = decimal[i] * 2 + matrix[i][j];\\n            }\\n        }\\n        int k = 1 << n, ans = 0;\\n        for(int i = 0; i < k; i++) {\\n            if(setBitCount(i) != numSelect) continue;\\n            int val = k - i - 1, count = 0;\\n            for(int j = 0; j < m; j++) {\\n                count += !(val & decimal[j]);\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259708,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int m = matrix.size() ;\\n        int n = matrix[0].size() ;\\n        \\n        vector<int>ROW ;\\n        for(int i = 0; i < m; i++){\\n            int val = 0 ;\\n            for(int j = 0; j < n; j++)\\n                val = (val << 1) + matrix[i][j] ;\\n            ROW.push_back(val) ;\\n        }\\n        \\n        int ret = 0 ;\\n        for(int state = 0 ; state < (1 << n); state++){\\n            if(__builtin_popcount(state) != numSelect)\\n                continue ;\\n            int count = 0 ;\\n            for(int i = 0; i < m; i++){\\n                if((state & ROW[i]) == ROW[i])\\n                    count++ ;\\n            }\\n            ret = max(ret, count) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int m = matrix.size() ;\\n        int n = matrix[0].size() ;\\n        \\n        vector<int>ROW ;\\n        for(int i = 0; i < m; i++){\\n            int val = 0 ;\\n            for(int j = 0; j < n; j++)\\n                val = (val << 1) + matrix[i][j] ;\\n            ROW.push_back(val) ;\\n        }\\n        \\n        int ret = 0 ;\\n        for(int state = 0 ; state < (1 << n); state++){\\n            if(__builtin_popcount(state) != numSelect)\\n                continue ;\\n            int count = 0 ;\\n            for(int i = 0; i < m; i++){\\n                if((state & ROW[i]) == ROW[i])\\n                    count++ ;\\n            }\\n            ret = max(ret, count) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221224,
                "title": "python-short-clean",
                "content": "# Code\\n```\\nfrom functools import reduce\\nfrom itertools import combinations\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        lst = [reduce(lambda a, b: (a << 1) | b, col) for col in zip(*matrix)]\\n        ret = 0\\n        for com in combinations(range(n), n - numSelect):\\n            v = reduce(lambda a, b: a | b, (lst[i] for i in com), 0)\\n            ret = max(ret, m - bin(v)[2:].count(\"1\"))\\n        return ret\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import reduce\\nfrom itertools import combinations\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        lst = [reduce(lambda a, b: (a << 1) | b, col) for col in zip(*matrix)]\\n        ret = 0\\n        for com in combinations(range(n), n - numSelect):\\n            v = reduce(lambda a, b: a | b, (lst[i] for i in com), 0)\\n            ret = max(ret, m - bin(v)[2:].count(\"1\"))\\n        return ret\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091132,
                "title": "python3-easy-to-understand-no-bitmasking",
                "content": "# Intuition\\nuse bruteforce to check all possible combinations\\n\\n# Approach\\nmake a dictionary for each row as key and value containing those columns having \"1\" for that row\\n\\n# Complexity\\n- Time complexity:\\nO(2**n)\\n\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom itertools import combinations\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        d = defaultdict(set)\\n        for idxr,row in enumerate(matrix):\\n            for idxc,col in enumerate(row):\\n                if col == 1:\\n                    d[idxr].add(idxc)\\n\\n        combs = set(combinations(range(len(matrix[0])) ,numSelect))\\n\\n        maxRow = 0\\n\\n        for comb in combs:\\n            temp = 0\\n            for j in range(len(matrix)):\\n                if not d[j] - set(comb):\\n                    temp+=1\\n            if temp > maxRow:\\n                maxRow = temp\\n\\n        return maxRow        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom itertools import combinations\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        d = defaultdict(set)\\n        for idxr,row in enumerate(matrix):\\n            for idxc,col in enumerate(row):\\n                if col == 1:\\n                    d[idxr].add(idxc)\\n\\n        combs = set(combinations(range(len(matrix[0])) ,numSelect))\\n\\n        maxRow = 0\\n\\n        for comb in combs:\\n            temp = 0\\n            for j in range(len(matrix)):\\n                if not d[j] - set(comb):\\n                    temp+=1\\n            if temp > maxRow:\\n                maxRow = temp\\n\\n        return maxRow        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041453,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int check(vector<vector<int>>& matrix,unordered_set<int> s)\\n    {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bool flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(s.find(j)==s.end() and matrix[i][j]==1)\\n                {\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag==false)\\n            cnt++;\\n        }\\n\\n        cout<<cnt<<endl;\\n        return cnt;\\n    }\\n    void solve(vector<vector<int>>& matrix, int num,unordered_set<int> s,int i)\\n    {\\n        if(num==0)\\n        {\\n            int res=check(matrix,s);\\n            // cout<<res<<\" \";\\n            ans=max(ans,res);\\n            return;\\n        }\\n\\n        if(i==matrix[0].size())\\n        return;\\n\\n        unordered_set<int> curr1=s;\\n        unordered_set<int> curr2=s;\\n\\n        curr1.insert(i);\\n        solve(matrix,num-1,curr1,i+1);\\n        solve(matrix,num,curr2,i+1);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int num) {\\n        unordered_set<int> s;\\n        solve(matrix,num,s,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int check(vector<vector<int>>& matrix,unordered_set<int> s)\\n    {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bool flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(s.find(j)==s.end() and matrix[i][j]==1)\\n                {\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag==false)\\n            cnt++;\\n        }\\n\\n        cout<<cnt<<endl;\\n        return cnt;\\n    }\\n    void solve(vector<vector<int>>& matrix, int num,unordered_set<int> s,int i)\\n    {\\n        if(num==0)\\n        {\\n            int res=check(matrix,s);\\n            // cout<<res<<\" \";\\n            ans=max(ans,res);\\n            return;\\n        }\\n\\n        if(i==matrix[0].size())\\n        return;\\n\\n        unordered_set<int> curr1=s;\\n        unordered_set<int> curr2=s;\\n\\n        curr1.insert(i);\\n        solve(matrix,num-1,curr1,i+1);\\n        solve(matrix,num,curr2,i+1);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int num) {\\n        unordered_set<int> s;\\n        solve(matrix,num,s,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2951113,
                "title": "brute-force-solution-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int check(vector<vector<int>>& m,unordered_set<int>v){\\n        int c=m.size();\\n        unordered_set<int>s;\\n        for(int i=0;i<m[0].size();i++){\\n            if(v.find(i)==v.end()){\\n                for(int j=0;j<m.size();j++){\\n                    if(s.find(j)==s.end()){\\n                        \\n                    if(m[j][i]==1){\\n                        c--;\\n                        s.insert(j);\\n                    }\\n                    }\\n                    if(c==0) return c;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n    void sub(vector<vector<int>>& m, int n,unordered_set<int>v,int i){\\n        if(v.size()==n){\\n            int p=check(m,v);\\n            ans=max(p,ans);\\n            return ;\\n        }\\n        for(int j=i;j<m[0].size();j++){\\n            v.insert(j);\\n            sub(m,n,v,j+1);\\n            v.erase(j);\\n        }\\n    }\\n    int maximumRows(vector<vector<int>>& m, int n) {\\n        unordered_set<int>v;\\n        sub(m,n,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int check(vector<vector<int>>& m,unordered_set<int>v){\\n        int c=m.size();\\n        unordered_set<int>s;\\n        for(int i=0;i<m[0].size();i++){\\n            if(v.find(i)==v.end()){\\n                for(int j=0;j<m.size();j++){\\n                    if(s.find(j)==s.end()){\\n                        \\n                    if(m[j][i]==1){\\n                        c--;\\n                        s.insert(j);\\n                    }\\n                    }\\n                    if(c==0) return c;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n    void sub(vector<vector<int>>& m, int n,unordered_set<int>v,int i){\\n        if(v.size()==n){\\n            int p=check(m,v);\\n            ans=max(p,ans);\\n            return ;\\n        }\\n        for(int j=i;j<m[0].size();j++){\\n            v.insert(j);\\n            sub(m,n,v,j+1);\\n            v.erase(j);\\n        }\\n    }\\n    int maximumRows(vector<vector<int>>& m, int n) {\\n        unordered_set<int>v;\\n        sub(m,n,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928508,
                "title": "easy-c-code-recursion-backtracking-visited-vector-solution",
                "content": "\\tvoid solve(vector<vector<int>>& mat,int col,int ind,int cur,vector<int> &vis,int &ans){\\n\\t\\t\\tif(ind == mat[0].size()){\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\tfor(int i=0;i<mat.size();i++){\\n\\t\\t\\t\\t\\tbool flag = true;\\n\\t\\t\\t\\t\\tfor(int j=0;j<mat[0].size();j++){\\n\\t\\t\\t\\t\\t\\tif(mat[i][j]==1 && !vis[j]){   // opted columns doesn\\'t cover all 1\\'s in row.\\n\\t\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;  // cut the loop because it doesn\\'t cover Ones(1\\'s)\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(flag) cnt++; (it remained true means it covers all 1\\'s in that row. So increment count of rows)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans,cnt);         // maximising answer\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(cur < col) {\\n\\t\\t\\t\\tvis[ind]=true;          // taken columns are marked here visited.\\n\\t\\t\\t\\tsolve(mat,col,ind+1,cur+1,vis,ans);      // take the column recursion call\\n\\t\\t\\t\\tvis[ind]=false;   // BackTrack\\n\\t\\t\\t}\\n\\t\\t\\tsolve(mat,col,ind+1,cur,vis,ans);   // not_take column recursion call\\n\\t\\t}\\n\\t\\tint maximumRows(vector<vector<int>>& mat, int col) {\\n\\t\\t\\tvector<int>vis(mat[0].size(),0);\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tsolve(mat,col,0,0,vis,ans);    \\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "\\tvoid solve(vector<vector<int>>& mat,int col,int ind,int cur,vector<int> &vis,int &ans){\\n\\t\\t\\tif(ind == mat[0].size()){\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\tfor(int i=0;i<mat.size();i++){\\n\\t\\t\\t\\t\\tbool flag = true;\\n\\t\\t\\t\\t\\tfor(int j=0;j<mat[0].size();j++){\\n\\t\\t\\t\\t\\t\\tif(mat[i][j]==1 && !vis[j]){   // opted columns doesn\\'t cover all 1\\'s in row.\\n\\t\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;  // cut the loop because it doesn\\'t cover Ones(1\\'s)\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(flag) cnt++; (it remained true means it covers all 1\\'s in that row. So increment count of rows)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans,cnt);         // maximising answer\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(cur < col) {\\n\\t\\t\\t\\tvis[ind]=true;          // taken columns are marked here visited.\\n\\t\\t\\t\\tsolve(mat,col,ind+1,cur+1,vis,ans);      // take the column recursion call\\n\\t\\t\\t\\tvis[ind]=false;   // BackTrack\\n\\t\\t\\t}\\n\\t\\t\\tsolve(mat,col,ind+1,cur,vis,ans);   // not_take column recursion call\\n\\t\\t}\\n\\t\\tint maximumRows(vector<vector<int>>& mat, int col) {\\n\\t\\t\\tvector<int>vis(mat[0].size(),0);\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tsolve(mat,col,0,0,vis,ans);    \\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2865262,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInorder to find all possible combination of column can be easily done using backtracking intuition.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt first we find all possible combination and then proceed with row specified operations. mark the current column\\'s 1\\'s and reduce the number of cols you have and move onwards to other columns.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void help(vector<vector<int>>mat, int cols, int i){\\n        if(cols == 0){\\n            int c = 0;\\n            for(int i = 0; i<mat.size(); i++){\\n                bool f = 1;\\n                for(int j = 0; j<mat[0].size(); j++){\\n                    if(mat[i][j] == 1){\\n                        f = 0;\\n                    }\\n                }\\n                if(f)c++;\\n            }\\n            ans = max(ans, c);\\n            return;\\n        }\\n        if(i == mat[0].size())return;\\n        \\n        help(mat, cols, i+1);\\n        for(int j = 0; j<mat.size(); j++)\\n            mat[j][i] = 0;\\n        help(mat, cols-1, i+1);\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        ans = 0; \\n        help(mat, cols, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void help(vector<vector<int>>mat, int cols, int i){\\n        if(cols == 0){\\n            int c = 0;\\n            for(int i = 0; i<mat.size(); i++){\\n                bool f = 1;\\n                for(int j = 0; j<mat[0].size(); j++){\\n                    if(mat[i][j] == 1){\\n                        f = 0;\\n                    }\\n                }\\n                if(f)c++;\\n            }\\n            ans = max(ans, c);\\n            return;\\n        }\\n        if(i == mat[0].size())return;\\n        \\n        help(mat, cols, i+1);\\n        for(int j = 0; j<mat.size(); j++)\\n            mat[j][i] = 0;\\n        help(mat, cols-1, i+1);\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        ans = 0; \\n        help(mat, cols, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836828,
                "title": "backtracking-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void f(vector<vector<int>>& mat, int num,int c, vector<int> v, int m, int n){\\n        if(c==n){\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            bool flag=true;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    if(!v[j]) flag=false;\\n                }\\n            }\\n            if(flag) cnt++;\\n        }\\n        ans=max(ans, cnt);\\n        return;\\n        }\\n        if(num>0){\\n            v[c]=1;\\n            f(mat, num-1, c+1, v, m, n);\\n            v[c]=0;\\n        }\\n        f(mat, num, c+1, v, m, n);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        \\n        int m=matrix.size(), n=matrix[0].size();\\n        vector<int> v(n, 0);\\n        f(matrix, numSelect,0, v, m, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void f(vector<vector<int>>& mat, int num,int c, vector<int> v, int m, int n){\\n        if(c==n){\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            bool flag=true;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    if(!v[j]) flag=false;\\n                }\\n            }\\n            if(flag) cnt++;\\n        }\\n        ans=max(ans, cnt);\\n        return;\\n        }\\n        if(num>0){\\n            v[c]=1;\\n            f(mat, num-1, c+1, v, m, n);\\n            v[c]=0;\\n        }\\n        f(mat, num, c+1, v, m, n);\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        \\n        int m=matrix.size(), n=matrix[0].size();\\n        vector<int> v(n, 0);\\n        f(matrix, numSelect,0, v, m, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805204,
                "title": "golang-brute-force-bit-mask-solution",
                "content": "```go\\nfunc maximumRows(matrix [][]int, numSelect int) int {\\n\\tif numSelect >= len(matrix[0]) {\\n\\t\\treturn len(matrix)\\n\\t}\\n\\trowValues := make([]int, 0, len(matrix))\\n\\tfor _, row := range matrix {\\n\\t\\tcur := 0\\n\\t\\tfor _, val := range row {\\n\\t\\t\\tcur = (cur << 1) + val\\n\\t\\t}\\n\\t\\trowValues = append(rowValues, cur)\\n\\t}\\n\\tmaxRows := 0\\n\\tfor i := 0; i < 4096; i++ {\\n\\t\\tcount1 := countOf1(i)\\n\\t\\tcount0 := 12 - count1\\n\\t\\tif count0 > numSelect {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcostRows := 0\\n\\t\\tfor _, val := range rowValues {\\n\\t\\t\\tif val & i == 0 {\\n\\t\\t\\t\\tcostRows++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif costRows > maxRows {\\n\\t\\t\\tmaxRows = costRows\\n\\t\\t}\\n\\t}\\n\\treturn maxRows\\n}\\n\\nfunc countOf1(num int) int {\\n\\tcount := 0\\n\\tfor num > 0 {\\n\\t\\tif num&0x1 == 1 {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t\\tnum >>= 1\\n\\t}\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bitmask"
                ],
                "code": "```go\\nfunc maximumRows(matrix [][]int, numSelect int) int {\\n\\tif numSelect >= len(matrix[0]) {\\n\\t\\treturn len(matrix)\\n\\t}\\n\\trowValues := make([]int, 0, len(matrix))\\n\\tfor _, row := range matrix {\\n\\t\\tcur := 0\\n\\t\\tfor _, val := range row {\\n\\t\\t\\tcur = (cur << 1) + val\\n\\t\\t}\\n\\t\\trowValues = append(rowValues, cur)\\n\\t}\\n\\tmaxRows := 0\\n\\tfor i := 0; i < 4096; i++ {\\n\\t\\tcount1 := countOf1(i)\\n\\t\\tcount0 := 12 - count1\\n\\t\\tif count0 > numSelect {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcostRows := 0\\n\\t\\tfor _, val := range rowValues {\\n\\t\\t\\tif val & i == 0 {\\n\\t\\t\\t\\tcostRows++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif costRows > maxRows {\\n\\t\\t\\tmaxRows = costRows\\n\\t\\t}\\n\\t}\\n\\treturn maxRows\\n}\\n\\nfunc countOf1(num int) int {\\n\\tcount := 0\\n\\tfor num > 0 {\\n\\t\\tif num&0x1 == 1 {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t\\tnum >>= 1\\n\\t}\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2802792,
                "title": "c-simple-bitmasking-and-dp-solution",
                "content": "```\\n/*\\n1) In this question, we can take the decision of including any particular row in our answer.\\n2) So if we decide to include any particular row in our answer then we have to include all \\nthat columns in our answer which is set in that row.\\n\\nsuppose the row is {0, 1, 0, 1} and we decide to include this row in our answer, then we have\\nto include rows c2 and c4 into the answer set.\\n\\n3) So we can represent any row as a particular number representing its bits as row value\\nFor eg : Suppose our row is {1, 0, 1, 1}\\nSo we can represent this row as value 11 whose bits are 1101\\n\\n4) So every row can be represented as an integer and after converting every row in its\\ncorresponding integer, we are left only with the \\'n\\' integers.\\n\\n5) Also suppose we want to include two rows into our answers.\\neg : {1, 0, 0, 0, 1} and {0, 1, 0, 0, 1}\\n\\nso we should have columns c1, c2 and c5 in our answer set which is basically the BITWISE OR\\nof the integers of the two rows ---> 10001 OR 01001 = 11001\\n\\nAnd also while doing this bitwise OR we must see that the total bits set into the result \\nshould not exceed the value of \\'k\\'.\\n\\nSuppose in the above eg our value of k is 2 and the after doing OR operation we got 2 bits\\nset in our answer, so we cannot perform that operation i.e. we cannot include both rows \\nsimultaneouly in our answer.\\n\\nAlso the selection of these rows can be done using the recursive way which can be memoized \\nto have an optmized solution.(We have two choices at every row --- we can include it in our\\nanswer or we cannot include it.)\\n\\nThe code for the same is given below.\\n*/\\n\\nclass Solution {\\npublic:\\n    int setBits(int n){\\n        int ans=0;\\n        while(n){\\n            ans=ans+(n&1);\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n    \\n    int recursion(int i,int k,int numSelect,vector<int> &res,vector<vector<int>> &dp){\\n        if(i==res.size()){\\n            return 0;\\n        }\\n        else if(dp[i][k]!=-1){\\n            return dp[i][k];\\n        }\\n        int bits=setBits(k|res[i]);\\n        if(bits<=numSelect){\\n            return dp[i][k]=max(\\n                1+recursion(i+1,k|res[i],numSelect,res,dp),\\n                recursion(i+1,k,numSelect,res,dp)\\n            );\\n        }\\n        else{\\n            return dp[i][k]=recursion(i+1,k,numSelect,res,dp);\\n        }\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        vector<int> res;\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            int tmp=0;\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]){\\n                    int oring=(1<<j);\\n                    tmp=tmp|oring;\\n                }\\n            }\\n            res.push_back(tmp);\\n        }\\n        vector<vector<int>> dp(matrix.size(),vector<int>(4100,-1));\\n        \\n        int ans=recursion(0,0,numSelect,res,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n1) In this question, we can take the decision of including any particular row in our answer.\\n2) So if we decide to include any particular row in our answer then we have to include all \\nthat columns in our answer which is set in that row.\\n\\nsuppose the row is {0, 1, 0, 1} and we decide to include this row in our answer, then we have\\nto include rows c2 and c4 into the answer set.\\n\\n3) So we can represent any row as a particular number representing its bits as row value\\nFor eg : Suppose our row is {1, 0, 1, 1}\\nSo we can represent this row as value 11 whose bits are 1101\\n\\n4) So every row can be represented as an integer and after converting every row in its\\ncorresponding integer, we are left only with the \\'n\\' integers.\\n\\n5) Also suppose we want to include two rows into our answers.\\neg : {1, 0, 0, 0, 1} and {0, 1, 0, 0, 1}\\n\\nso we should have columns c1, c2 and c5 in our answer set which is basically the BITWISE OR\\nof the integers of the two rows ---> 10001 OR 01001 = 11001\\n\\nAnd also while doing this bitwise OR we must see that the total bits set into the result \\nshould not exceed the value of \\'k\\'.\\n\\nSuppose in the above eg our value of k is 2 and the after doing OR operation we got 2 bits\\nset in our answer, so we cannot perform that operation i.e. we cannot include both rows \\nsimultaneouly in our answer.\\n\\nAlso the selection of these rows can be done using the recursive way which can be memoized \\nto have an optmized solution.(We have two choices at every row --- we can include it in our\\nanswer or we cannot include it.)\\n\\nThe code for the same is given below.\\n*/\\n\\nclass Solution {\\npublic:\\n    int setBits(int n){\\n        int ans=0;\\n        while(n){\\n            ans=ans+(n&1);\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n    \\n    int recursion(int i,int k,int numSelect,vector<int> &res,vector<vector<int>> &dp){\\n        if(i==res.size()){\\n            return 0;\\n        }\\n        else if(dp[i][k]!=-1){\\n            return dp[i][k];\\n        }\\n        int bits=setBits(k|res[i]);\\n        if(bits<=numSelect){\\n            return dp[i][k]=max(\\n                1+recursion(i+1,k|res[i],numSelect,res,dp),\\n                recursion(i+1,k,numSelect,res,dp)\\n            );\\n        }\\n        else{\\n            return dp[i][k]=recursion(i+1,k,numSelect,res,dp);\\n        }\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        vector<int> res;\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            int tmp=0;\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]){\\n                    int oring=(1<<j);\\n                    tmp=tmp|oring;\\n                }\\n            }\\n            res.push_back(tmp);\\n        }\\n        vector<vector<int>> dp(matrix.size(),vector<int>(4100,-1));\\n        \\n        int ans=recursion(0,0,numSelect,res,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780750,
                "title": "javascript-enumeration-w-bitmasks",
                "content": "**Solution: Enumeration w/ Bitmasks**\\n\\nEnumerate every combination of selected columns using bitmasks (`1` to `2^n`).\\n  For each combination, count the number of rows where every `matrix[row][col] = 1` is covered by the current selected columns.\\n\\nSmall optimization: We don\\'t need to consider cells with value of `0`, so for each row, we can store the columns where `matrix[row][col] = 1`. This way, we don\\'t have to unnecessarily go through every cell.\\n\\n`m = number of rows`, `n = number of columns`\\nTime Complexity: `O(2^n * mn)` 135ms\\nSpace Complexity: `O(mn)` 44.8MB\\n```\\nvar maximumRows = function(matrix, numSelect) {\\n  let m = matrix.length, n = matrix[0].length, ones = Array(m).fill(0).map(() => []);\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (matrix[i][j] === 1) {\\n        ones[i].push(j); // store columns where matrix[row][col] = 1 \\n      }\\n    }\\n  }\\n  \\n  let ans = 0;\\n  for (let mask = 1; mask < (1 << n); mask++) {\\n    if (countOnes(mask) !== numSelect) continue; // we need to select exactly numSelect columns\\n    let rowsCovered = 0;\\n    for (let row = 0; row < m; row++) {\\n      let isCovered = true;\\n      for (let one of ones[row]) {\\n        let columnIsPresent = (mask >> one) & 1;\\n        if (!columnIsPresent) { // found a matrix[row][col] = 1 where col is not present in s\\n          isCovered = false;\\n          break;\\n        }\\n      }\\n      rowsCovered += isCovered ? 1 : 0;\\n    }\\n    ans = Math.max(ans, rowsCovered);\\n  }\\n  return ans;\\n};\\n\\nfunction countOnes(num) {\\n  let ones = 0;\\n  while (num > 0) {\\n    ones += (num & 1);\\n    num >>= 1;\\n  }\\n  return ones;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumRows = function(matrix, numSelect) {\\n  let m = matrix.length, n = matrix[0].length, ones = Array(m).fill(0).map(() => []);\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (matrix[i][j] === 1) {\\n        ones[i].push(j); // store columns where matrix[row][col] = 1 \\n      }\\n    }\\n  }\\n  \\n  let ans = 0;\\n  for (let mask = 1; mask < (1 << n); mask++) {\\n    if (countOnes(mask) !== numSelect) continue; // we need to select exactly numSelect columns\\n    let rowsCovered = 0;\\n    for (let row = 0; row < m; row++) {\\n      let isCovered = true;\\n      for (let one of ones[row]) {\\n        let columnIsPresent = (mask >> one) & 1;\\n        if (!columnIsPresent) { // found a matrix[row][col] = 1 where col is not present in s\\n          isCovered = false;\\n          break;\\n        }\\n      }\\n      rowsCovered += isCovered ? 1 : 0;\\n    }\\n    ans = Math.max(ans, rowsCovered);\\n  }\\n  return ans;\\n};\\n\\nfunction countOnes(num) {\\n  let ones = 0;\\n  while (num > 0) {\\n    ones += (num & 1);\\n    num >>= 1;\\n  }\\n  return ones;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2749799,
                "title": "simple-and-concise-java-solution-recursion-backtracking",
                "content": "```\\n// if you found my solution uusefull please upvote it\\nclass Solution \\n{\\n    public int ans=0;\\n    public void fun(int i,int[][] grid,int max,boolean[] vis)\\n    {\\n        if(i==grid[0].length)\\n        {\\n            int cnt=0;\\n            for(int row=0;row<grid.length;row++)\\n            {\\n                boolean flag=true;\\n                for(int col=0;col<grid[0].length;col++)\\n                {\\n                    if(grid[row][col]==1)\\n                    {\\n                        if(!vis[col])\\n                        {\\n                            flag=false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(flag)  cnt++;\\n            }\\n            ans=Math.max(ans,cnt);\\n            return ;\\n        }\\n        vis[i]=true;\\n        if(max>0) fun(i+1,grid,max-1,vis);\\n        vis[i]=false;\\n        fun(i+1,grid,max,vis);\\n    }\\n    public int maximumRows(int[][] matrix, int numSelect) \\n    {\\n        fun(0,matrix,numSelect,new boolean[matrix[0].length]);\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution \\n{\\n    public int ans=0;\\n    public void fun(int i,int[][] grid,int max,boolean[] vis)\\n    {\\n        if(i==grid[0].length)\\n        {\\n            int cnt=0;\\n            for(int row=0;row<grid.length;row++)\\n            {\\n                boolean flag=true;\\n                for(int col=0;col<grid[0].length;col++)\\n                {\\n                    if(grid[row][col]==1)\\n                    {\\n                        if(!vis[col])\\n                        {\\n                            flag=false;\\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2741153,
                "title": "c-code",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool C[15];\\n    bool rc[15];\\n    int rccnt = 0;\\n    int res = 0;\\n    int rl, cl;\\n    void init_rc(vector<vector<int>>& M) {\\n        for (int i = 0; i < rl; i++) {\\n            int j = 0;\\n            for (; j < cl; j++) {\\n                if (M[i][j] == 1)\\n                    break;\\n            }\\n            if (j >= cl) {\\n                rccnt++;\\n                rc[i] = false;\\n            }\\n        }\\n    }\\n    int setC(int c) {\\n        memset(C, false, sizeof(C));\\n        int idx = 0;\\n        int cnt = 0;\\n        while (c > 0) {\\n            if ((c & 1) == 1) {\\n                C[idx] = true;\\n                cnt++;\\n            }\\n            c >>= 1;\\n            idx++;\\n        }\\n        return cnt;\\n    }\\n    int cntR(vector<vector<int>>& M) {\\n        int cnt = 0;\\n        for (int i = 0; i < rl; i++) {\\n            if (rc[i]) {\\n                int j = 0;\\n                int f = true;\\n                for (; j < cl; j++) {\\n                    if (M[i][j] == 1 && !C[j]) {\\n                        f = false;\\n                        break;\\n                    }\\n                }\\n                if (f) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        memset(rc, true, sizeof(rc));\\n        rl = matrix.size();\\n        cl = matrix[0].size();\\n        init_rc(matrix);\\n        int mm = pow(2, cl);\\n        for (int m = 0; m < mm; m++) {\\n            if (setC(m) == numSelect) {\\n                res = max(res, (rccnt + cntR(matrix)));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool C[15];\\n    bool rc[15];\\n    int rccnt = 0;\\n    int res = 0;\\n    int rl, cl;\\n    void init_rc(vector<vector<int>>& M) {\\n        for (int i = 0; i < rl; i++) {\\n            int j = 0;\\n            for (; j < cl; j++) {\\n                if (M[i][j] == 1)\\n                    break;\\n            }\\n            if (j >= cl) {\\n                rccnt++;\\n                rc[i] = false;\\n            }\\n        }\\n    }\\n    int setC(int c) {\\n        memset(C, false, sizeof(C));\\n        int idx = 0;\\n        int cnt = 0;\\n        while (c > 0) {\\n            if ((c & 1) == 1) {\\n                C[idx] = true;\\n                cnt++;\\n            }\\n            c >>= 1;\\n            idx++;\\n        }\\n        return cnt;\\n    }\\n    int cntR(vector<vector<int>>& M) {\\n        int cnt = 0;\\n        for (int i = 0; i < rl; i++) {\\n            if (rc[i]) {\\n                int j = 0;\\n                int f = true;\\n                for (; j < cl; j++) {\\n                    if (M[i][j] == 1 && !C[j]) {\\n                        f = false;\\n                        break;\\n                    }\\n                }\\n                if (f) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        memset(rc, true, sizeof(rc));\\n        rl = matrix.size();\\n        cl = matrix[0].size();\\n        init_rc(matrix);\\n        int mm = pow(2, cl);\\n        for (int m = 0; m < mm; m++) {\\n            if (setC(m) == numSelect) {\\n                res = max(res, (rccnt + cntR(matrix)));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721433,
                "title": "java-backtracking-bit-work",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    public int maximumRows(int[][] m, int n) {\\n        int[] is = new int[m.length];\\n        for(int i=0; i<m.length; i++){\\n            for(int j=0; j<m[0].length; j++){\\n                if(m[i][j]==1)is[i]+=1<<j;\\n            }\\n        }\\n        for(int a=0; a<=m[0].length-n; a++){\\n            dfs(is, 0, a, n, m[0].length);\\n        }\\n        return max;\\n    }\\n    private void dfs(int[] is, int val, int cur, int step, int len){\\n        int cnt=0;\\n        val += 1<<cur; step--;\\n        if(step==0){\\n            for(int x:is){\\n                if((x|val)==val) cnt++;\\n            }\\n            if(max<cnt)max=cnt;\\n            return;\\n        }\\n        for(int i=cur+1; i<=len-step; i++){\\n            dfs(is, val, i, step, len);\\n        }\\n        val -= 1<<cur;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int maximumRows(int[][] m, int n) {\\n        int[] is = new int[m.length];\\n        for(int i=0; i<m.length; i++){\\n            for(int j=0; j<m[0].length; j++){\\n                if(m[i][j]==1)is[i]+=1<<j;\\n            }\\n        }\\n        for(int a=0; a<=m[0].length-n; a++){\\n            dfs(is, 0, a, n, m[0].length);\\n        }\\n        return max;\\n    }\\n    private void dfs(int[] is, int val, int cur, int step, int len){\\n        int cnt=0;\\n        val += 1<<cur; step--;\\n        if(step==0){\\n            for(int x:is){\\n                if((x|val)==val) cnt++;\\n            }\\n            if(max<cnt)max=cnt;\\n            return;\\n        }\\n        for(int i=cur+1; i<=len-step; i++){\\n            dfs(is, val, i, step, len);\\n        }\\n        val -= 1<<cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717656,
                "title": "python3-try-only-interesting-rows-and-columns-44-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI first thought about whether this can be done in any other way but to check literally any combination of numSelect columns. I couldn\\'t figure out a cleverer way so I decided to at least reduce the numbers of columns and rows to check.\\n\\nI came up with two reductions:\\n1) Check for interesting rows. These are either rows with all zeros, which can be added to the final result immediately, or rows that have equal to or less than numSelect ones. Rows with more ones can never be fully selected.\\n2) All columns with no ones at all are not interesting and can therefore be skipped. I.e. all zero columns will not be part of the brute force. There is ONE! additional condition: We only check rows in these columns which are identified as interesting and do not care about whether a column has a one in an uninteresting row.\\n\\nIn order to quickly check, whether we hit all ones in a row, I also made a set of indices for each interesting row and saved it.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we go through all rows and save the interesting ones including their sets of indices.\\n\\nAfter that we go through every column and check the interesting rows for ones. If there are no ones in the interesting rows and this specific column, we skip it.\\n\\nThen we can reduce the numSelect parameter (amount of columns to choose), if there are less interesting columns.\\n\\nAfter that we go through all the combinations of columns and use the indices set per row for a quick check, whether we hit all ones.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(min(numSelect,interesting_rows)!* min(interestingRows, M) * min(numSelect,interesting_rows)), as we need to try all different combinations. M is the number of rows.\\n\\nFactors explained:\\nmin(numSelect,interesting_rows)! : amount of combinations\\n\\nmin(interestingRows, M): We need to check all rows for each combination\\n\\nmin(numSelect,interesting_rows) : We need to check whether we hit all ones\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWorst-Case: O(M+N) as we save all interesting rows and columns.\\n# Code\\n```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n\\n        # we first need to count the rows, that have all zeros and append\\n        # rows that have numSelect ones or less, as we can ignore the others\\n        result = 0\\n        interesting_rows = []\\n        for idx, row in enumerate(matrix):\\n\\n            # make a set of all the ones\\n            ones = set(cx for cx, ele in enumerate(row) if ele)\\n\\n            # calculate the sum of the row\\n            summed = len(ones)\\n\\n            # check whether it is zero\\n            if not summed:\\n                print(\\'asdasd\\')\\n                result += 1\\n            elif summed <= numSelect:\\n                interesting_rows.append((idx, ones))\\n        \\n        # now go over all columns an check which of those are interesting\\n        interesting_columns = []\\n        for cx in range(len(matrix[0])):\\n\\n            # check only the interesting rows in this column\\n            if any(matrix[rx][cx] for rx, _ in interesting_rows):\\n                interesting_columns.append(cx)\\n\\n        # update the numSelect (as we might have less interesting colums)\\n        # than we can select\\n        numSelect = min(len(interesting_columns), numSelect)\\n        \\n        # now do all the combinations and save the max result\\n        max_result = result\\n        for combi in combinations(interesting_columns, numSelect):\\n\\n            # temporary result\\n            tmp = result\\n\\n            # go over all interesting rows and check whether\\n            # they are completed\\n            for row, ones in interesting_rows:\\n\\n                # subtract the combi from the ones in row set\\n                if len(ones.difference(combi)) == 0:\\n                    tmp += 1\\n            \\n            # check whether we reached new high\\n            max_result = max(max_result, tmp)\\n        \\n        return max_result\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n\\n        # we first need to count the rows, that have all zeros and append\\n        # rows that have numSelect ones or less, as we can ignore the others\\n        result = 0\\n        interesting_rows = []\\n        for idx, row in enumerate(matrix):\\n\\n            # make a set of all the ones\\n            ones = set(cx for cx, ele in enumerate(row) if ele)\\n\\n            # calculate the sum of the row\\n            summed = len(ones)\\n\\n            # check whether it is zero\\n            if not summed:\\n                print(\\'asdasd\\')\\n                result += 1\\n            elif summed <= numSelect:\\n                interesting_rows.append((idx, ones))\\n        \\n        # now go over all columns an check which of those are interesting\\n        interesting_columns = []\\n        for cx in range(len(matrix[0])):\\n\\n            # check only the interesting rows in this column\\n            if any(matrix[rx][cx] for rx, _ in interesting_rows):\\n                interesting_columns.append(cx)\\n\\n        # update the numSelect (as we might have less interesting colums)\\n        # than we can select\\n        numSelect = min(len(interesting_columns), numSelect)\\n        \\n        # now do all the combinations and save the max result\\n        max_result = result\\n        for combi in combinations(interesting_columns, numSelect):\\n\\n            # temporary result\\n            tmp = result\\n\\n            # go over all interesting rows and check whether\\n            # they are completed\\n            for row, ones in interesting_rows:\\n\\n                # subtract the combi from the ones in row set\\n                if len(ones.difference(combi)) == 0:\\n                    tmp += 1\\n            \\n            # check whether we reached new high\\n            max_result = max(max_result, tmp)\\n        \\n        return max_result\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707747,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    \\n    public int dfs( int col, int[][] matrix, int m, int n, int leftOver, int columns_added )\\n    {\\n\\t\\t// leftOver : number of columns selected\\n\\t\\t// columns_added : As constraint is upto 12 columns, so we can use bit masking, e.g., 10011 means column 0, 1, 4 is selected.\\n        if( leftOver == 0 )\\n        {\\n\\t\\t\\t// Find all matrix[r][c] which contains \"1\" and whose column number is not selected or set_bit is not on in column_added.\\n\\t\\t\\t// Add that faulty row to set.\\n            HashSet<Integer> set = new HashSet<>();\\n            for( int r = 0; r < m; r++ )\\n            {\\n                for( int c = 0; c < n; c++ )\\n                {\\n                    if( matrix[r][c] == 1 && ( columns_added & ( 1 << c ) ) == 0 )\\n                    {\\n                        set.add( r );\\n                    }\\n                }\\n            }\\n            return m - set.size();\\n        }\\n\\n        if( col == matrix[0].length )\\n        {\\n            return 0;\\n        }\\n        \\n        // Two options : select this column or not select it.\\n        return Math.max( dfs( col+1, matrix, m, n, leftOver, columns_added),\\n                dfs( col+1, matrix, m, n, leftOver-1, columns_added | ( 1 << col ) ) );\\n    }\\n\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int ans = 0;\\n        \\n        for( int i = 0; i <= n - numSelect; i++ )\\n        {\\n            ans = Math.max( ans, dfs( i+1, matrix, m, n, numSelect - 1, 1 << i ) );\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int dfs( int col, int[][] matrix, int m, int n, int leftOver, int columns_added )\\n    {\\n\\t\\t// leftOver : number of columns selected\\n\\t\\t// columns_added : As constraint is upto 12 columns, so we can use bit masking, e.g., 10011 means column 0, 1, 4 is selected.\\n        if( leftOver == 0 )\\n        {\\n\\t\\t\\t// Find all matrix[r][c] which contains \"1\" and whose column number is not selected or set_bit is not on in column_added.\\n\\t\\t\\t// Add that faulty row to set.\\n            HashSet<Integer> set = new HashSet<>();\\n            for( int r = 0; r < m; r++ )\\n            {\\n                for( int c = 0; c < n; c++ )\\n                {\\n                    if( matrix[r][c] == 1 && ( columns_added & ( 1 << c ) ) == 0 )\\n                    {\\n                        set.add( r );\\n                    }\\n                }\\n            }\\n            return m - set.size();\\n        }\\n\\n        if( col == matrix[0].length )\\n        {\\n            return 0;\\n        }\\n        \\n        // Two options : select this column or not select it.\\n        return Math.max( dfs( col+1, matrix, m, n, leftOver, columns_added),\\n                dfs( col+1, matrix, m, n, leftOver-1, columns_added | ( 1 << col ) ) );\\n    }\\n\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int ans = 0;\\n        \\n        for( int i = 0; i <= n - numSelect; i++ )\\n        {\\n            ans = Math.max( ans, dfs( i+1, matrix, m, n, numSelect - 1, 1 << i ) );\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695825,
                "title": "max-rows-covered-by-cols-easiest-recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    // this function returns the number of rows covers by the selected columns\\n    int valid(vector<int> &colm, vector<vector<int>> &mat){\\n        int res = 0;\\n        unordered_map<int, int> mp;\\n        for(auto it : colm){\\n            mp[it]++;\\n        }\\n        for(int i = 0; i<mat.size(); i++){\\n            bool f =  true;\\n            for(int j = 0; j<mat[0].size(); j++){\\n                if(mat[i][j] == 1){\\n                    if( !mp[j]){\\n                        f =  false;\\n                        break;\\n                    }\\n                }\\n            }\\n             if(f)res++;\\n        }\\n        return res;\\n    }\\n    void solve(vector<int> &colm, vector<vector<int>> & mat, int &ans, int cols, int ind){\\n        if(cols == 0){\\n            // if you selected numSelect columns then check how many row these cols cover\\n            ans = max(valid(colm, mat), ans);\\n            return; \\n        }\\n        for(int i = ind; i<mat[0].size(); i++){ // store the cols in a vector \\n            colm.push_back(i);\\n            solve(colm, mat, ans, cols-1, i+1);\\n            colm.pop_back();\\n        }\\n        \\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n      int ans = 0 ;\\n      vector<int> colm;\\n      \\n      solve(colm, mat, ans, cols, 0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // this function returns the number of rows covers by the selected columns\\n    int valid(vector<int> &colm, vector<vector<int>> &mat){\\n        int res = 0;\\n        unordered_map<int, int> mp;\\n        for(auto it : colm){\\n            mp[it]++;\\n        }\\n        for(int i = 0; i<mat.size(); i++){\\n            bool f =  true;\\n            for(int j = 0; j<mat[0].size(); j++){\\n                if(mat[i][j] == 1){\\n                    if( !mp[j]){\\n                        f =  false;\\n                        break;\\n                    }\\n                }\\n            }\\n             if(f)res++;\\n        }\\n        return res;\\n    }\\n    void solve(vector<int> &colm, vector<vector<int>> & mat, int &ans, int cols, int ind){\\n        if(cols == 0){\\n            // if you selected numSelect columns then check how many row these cols cover\\n            ans = max(valid(colm, mat), ans);\\n            return; \\n        }\\n        for(int i = ind; i<mat[0].size(); i++){ // store the cols in a vector \\n            colm.push_back(i);\\n            solve(colm, mat, ans, cols-1, i+1);\\n            colm.pop_back();\\n        }\\n        \\n        \\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n      int ans = 0 ;\\n      vector<int> colm;\\n      \\n      solve(colm, mat, ans, cols, 0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681645,
                "title": "clear-python-4-lines-combinations",
                "content": "```python\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        m, n, ans = len(mat), len(mat[0]), -inf\\n        for comb in combinations((num for num in range(n)), n-cols):\\n            ans = max(ans, sum(all(mat[r][c] == 0 for c in comb) for r in range(m)))\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        m, n, ans = len(mat), len(mat[0]), -inf\\n        for comb in combinations((num for num in range(n)), n-cols):\\n            ans = max(ans, sum(all(mat[r][c] == 0 for c in comb) for r in range(m)))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671690,
                "title": "dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        vector<vector<int>> dp(1 << col, vector<int> (numSelect + 1, -1));\\n        \\n        auto count = [&](int idx) {\\n            int res = 0;\\n            \\n            for(int r = 0; r < row; r++) {\\n                int cnt = 0;\\n                \\n                for(int c = 0; c < col; c++) {\\n                    if(idx & (1 << c) || !matrix[r][c]) continue;\\n                    else { cnt++; break; }\\n                }\\n                \\n                res += !cnt;\\n            }\\n            \\n            return res;\\n        };\\n        \\n        function<int(int, int)> dfs = [&](int idx, int choice) {\\n            if(dp[idx][choice] != -1) return dp[idx][choice];\\n            if(!choice) return dp[idx][choice] = count(idx);\\n            \\n            for(int i = 0; i < col; i++) {\\n                if(idx & (1 << i)) continue;\\n                \\n                int nextIdx = idx + (1 << i);\\n                dp[idx][choice] = max(dp[idx][choice], dfs(nextIdx, choice - 1));\\n            } \\n            \\n            return dp[idx][choice];\\n        };\\n        \\n        return dfs(0, numSelect);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        vector<vector<int>> dp(1 << col, vector<int> (numSelect + 1, -1));\\n        \\n        auto count = [&](int idx) {\\n            int res = 0;\\n            \\n            for(int r = 0; r < row; r++) {\\n                int cnt = 0;\\n                \\n                for(int c = 0; c < col; c++) {\\n                    if(idx & (1 << c) || !matrix[r][c]) continue;\\n                    else { cnt++; break; }\\n                }\\n                \\n                res += !cnt;\\n            }\\n            \\n            return res;\\n        };\\n        \\n        function<int(int, int)> dfs = [&](int idx, int choice) {\\n            if(dp[idx][choice] != -1) return dp[idx][choice];\\n            if(!choice) return dp[idx][choice] = count(idx);\\n            \\n            for(int i = 0; i < col; i++) {\\n                if(idx & (1 << i)) continue;\\n                \\n                int nextIdx = idx + (1 << i);\\n                dp[idx][choice] = max(dp[idx][choice], dfs(nextIdx, choice - 1));\\n            } \\n            \\n            return dp[idx][choice];\\n        };\\n        \\n        return dfs(0, numSelect);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669856,
                "title": "python-super-clean-solution",
                "content": "```\\ndef maximumRows(self, mat: List[List[int]], k: int) -> int:\\n\\tm, n, ans = len(mat), len(mat[0]), 0\\n\\trow = [sum(r) for r in mat]   \\n\\tfor comb in combinations(range(n), k):\\n\\t\\tcur = 0\\n\\t\\tfor i in range(m):\\n\\t\\t\\tif row[i]==0 or sum(mat[i][j] for j in comb)==row[i]:\\n\\t\\t\\t\\tcur += 1\\n\\t\\tans = max(cur, ans)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumRows(self, mat: List[List[int]], k: int) -> int:\\n\\tm, n, ans = len(mat), len(mat[0]), 0\\n\\trow = [sum(r) for r in mat]   \\n\\tfor comb in combinations(range(n), k):\\n\\t\\tcur = 0\\n\\t\\tfor i in range(m):\\n\\t\\t\\tif row[i]==0 or sum(mat[i][j] for j in comb)==row[i]:\\n\\t\\t\\t\\tcur += 1\\n\\t\\tans = max(cur, ans)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2627197,
                "title": "maximum-rows-covered-by-columns-c-backtracking",
                "content": "I recommend you to take a pen & paper to see what\\'s happening and understand much better. This is a very good question.\\n```\\nclass Solution {\\npublic:\\n    int n, ans=0;\\n    vector<int> row_sums;\\n    \\n    int sumOfRow(vector<int> &vec){\\n        int res=0;\\n        for(auto a:vec) res+=a;\\n        return res;\\n    }\\n    \\n    int isPossible(vector<int> &a, vector<int> &b){\\n        int res=0;\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) res++;\\n            else continue;\\n        }\\n        return res;\\n    }\\n    \\n    void helper(vector<vector<int>>& matrix, int c, int count, vector<int> c_sums){\\n        if(c==matrix[0].size()){\\n            if(count==n){\\n                int temp=isPossible(c_sums, row_sums);\\n                if(temp)\\n                    ans=max(ans, temp);\\n            }\\n            return;\\n        }\\n        \\n        helper(matrix, c+1, count, c_sums);\\n        \\n        for(int i=0; i<matrix.size(); i++){\\n            c_sums[i]+=matrix[i][c];\\n        }\\n        helper(matrix, c+1, count+1, c_sums);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        n=numSelect;\\n        for(auto a:matrix){\\n            row_sums.push_back(sumOfRow(a));\\n        }\\n        \\n        vector<int> c_sums(matrix.size(), 0);\\n        helper(matrix, 0, 0, c_sums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, ans=0;\\n    vector<int> row_sums;\\n    \\n    int sumOfRow(vector<int> &vec){\\n        int res=0;\\n        for(auto a:vec) res+=a;\\n        return res;\\n    }\\n    \\n    int isPossible(vector<int> &a, vector<int> &b){\\n        int res=0;\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) res++;\\n            else continue;\\n        }\\n        return res;\\n    }\\n    \\n    void helper(vector<vector<int>>& matrix, int c, int count, vector<int> c_sums){\\n        if(c==matrix[0].size()){\\n            if(count==n){\\n                int temp=isPossible(c_sums, row_sums);\\n                if(temp)\\n                    ans=max(ans, temp);\\n            }\\n            return;\\n        }\\n        \\n        helper(matrix, c+1, count, c_sums);\\n        \\n        for(int i=0; i<matrix.size(); i++){\\n            c_sums[i]+=matrix[i][c];\\n        }\\n        helper(matrix, c+1, count+1, c_sums);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        n=numSelect;\\n        for(auto a:matrix){\\n            row_sums.push_back(sumOfRow(a));\\n        }\\n        \\n        vector<int> c_sums(matrix.size(), 0);\\n        helper(matrix, 0, 0, c_sums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626538,
                "title": "java-using-recursion-easy",
                "content": "```\\nclass Solution {\\n    int ans = Integer.MIN_VALUE;\\n    public int maximumRows(int[][] mat, int cols) {\\n    boolean[] visited = new boolean[mat[0].length];\\n    Arrays.fill(visited,false);\\n    returnMaxRows(mat,cols,0,visited,0);\\n    return ans;    \\n    }\\n    \\n    public void returnMaxRows(int[][] mat, int cols, int index, boolean[] visited,int count) {\\n        \\n        if(index == mat[0].length) {\\n            int result = 0;\\n            for(int i = 0; i < mat.length; i++) {\\n                result+=1;\\n                for(int j = 0; j < mat[i].length; j++) {\\n                    if(mat[i][j] != 0) {\\n                        if(visited[j] == false) {\\n                            result--;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            ans = Math.max(ans,result);\\n            return;\\n        }\\n        \\n        \\n        //pick\\n        if(count < cols) {\\n            visited[index] =true;\\n            returnMaxRows(mat,cols,index+1,visited,count+1);\\n            visited[index] = false;\\n        }\\n        //not pick\\n        returnMaxRows(mat,cols,index+1,visited,count);\\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int ans = Integer.MIN_VALUE;\\n    public int maximumRows(int[][] mat, int cols) {\\n    boolean[] visited = new boolean[mat[0].length];\\n    Arrays.fill(visited,false);\\n    returnMaxRows(mat,cols,0,visited,0);\\n    return ans;    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2624665,
                "title": "my-best-96-tests-passed",
                "content": "passed 96 tests but i need to see what is wrong with this one \\n[[1,0,1,0,0,0,0,0],[0,0,0,1,1,0,0,1],[0,0,1,1,1,1,1,1],[0,1,0,0,1,1,0,1],[0,1,0,0,1,0,0,0]]\\n5\\n\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} numSelect\\n * @return {number}\\n */\\nvar maximumRows = function(matrix, numSelect) {\\n    var maxs = []\\n    \\n    for(var i=0;i<matrix[0].length;i++)\\n    {\\n       var sum = 0\\n       for(var j=0;j<matrix.length;j++)\\n        {\\n            sum+=matrix[j][i]\\n        }\\n        maxs.push(sum)\\n    }\\n    \\n    console.log(maxs)\\n    \\n    var s = []\\n    var n = numSelect;\\n    while(n--)\\n    {\\n        var maxVal = 0\\n        var max = 0\\n        for(var i=0;i<maxs.length;i++)\\n        {\\n            if(maxVal<maxs[i] && !s.includes(i))\\n               {\\n                    max = i\\n                    maxVal = maxs[max]\\n               }\\n        }\\n        if(!s.includes(i))\\n        {\\n            s.push(max)\\n        }\\n        \\n    }\\n    \\n    console.log(s)\\n    \\n    var res = matrix.length;\\n    for(var i=0;i<matrix.length;i++)\\n    {\\n       for(var j=0;j<matrix[i].length;j++)\\n        {\\n            if(matrix[i][j] == 1)\\n             {\\n                if(!s.includes(j))\\n                {\\n                    /*console.log(i+\\'=>\\'+j+\" not in \")\\n                    console.log(s)*/\\n                    res--;\\n                    break;\\n                }\\n             }\\n        }\\n    }\\n    return res;\\n    \\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} numSelect\\n * @return {number}\\n */\\nvar maximumRows = function(matrix, numSelect) {\\n    var maxs = []\\n    \\n    for(var i=0;i<matrix[0].length;i++)\\n    {\\n       var sum = 0\\n       for(var j=0;j<matrix.length;j++)\\n        {\\n            sum+=matrix[j][i]\\n        }\\n        maxs.push(sum)\\n    }\\n    \\n    console.log(maxs)\\n    \\n    var s = []\\n    var n = numSelect;\\n    while(n--)\\n    {\\n        var maxVal = 0\\n        var max = 0\\n        for(var i=0;i<maxs.length;i++)\\n        {\\n            if(maxVal<maxs[i] && !s.includes(i))\\n               {\\n                    max = i\\n                    maxVal = maxs[max]\\n               }\\n        }\\n        if(!s.includes(i))\\n        {\\n            s.push(max)\\n        }\\n        \\n    }\\n    \\n    console.log(s)\\n    \\n    var res = matrix.length;\\n    for(var i=0;i<matrix.length;i++)\\n    {\\n       for(var j=0;j<matrix[i].length;j++)\\n        {\\n            if(matrix[i][j] == 1)\\n             {\\n                if(!s.includes(j))\\n                {\\n                    /*console.log(i+\\'=>\\'+j+\" not in \")\\n                    console.log(s)*/\\n                    res--;\\n                    break;\\n                }\\n             }\\n        }\\n    }\\n    return res;\\n    \\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2622168,
                "title": "java-brute-force-backtracking",
                "content": "```\\n\\tclass Solution {\\n        private int max;\\n        private int m;\\n\\n        public int maximumRows(int[][] matrix, int numSelect) {\\n            /*\\n            Row is covered:\\n            1. matrix[row][col] == 1, col in rowSet {0, 2}\\n            2. row doesn\\'t contain 1\\n            */\\n            if (matrix == null || matrix.length == 0) return 0;\\n\\n            m = matrix[0].length;\\n            max = 0;\\n\\n            backtrack(matrix, new HashSet<>(), numSelect, 0);\\n\\n            return max;\\n        }\\n\\n        private void backtrack(int[][] matrix, Set<Integer> temp, int numSelect, int start) {\\n            if (numSelect == 0) {\\n                max = Math.max(max, countCoverRows(matrix, temp));\\n                return;\\n            }\\n            for (int i = start; i < m; i++) {\\n                temp.add(i);\\n                backtrack(matrix, temp, numSelect - 1, i + 1);\\n                temp.remove(i);\\n            }\\n        }\\n\\n        private int countCoverRows(int[][] matrix, Set<Integer> temp) {\\n            int counter = 0;\\n            for (int[] row : matrix) {\\n                if (isAllCellsWithOneInSet(row, temp)) {\\n                    counter++;\\n                } else if (isNoOneRow(row)) {\\n                    counter++;\\n                }\\n            }\\n            return counter;\\n        }\\n\\n        private boolean isAllCellsWithOneInSet(int[] array, Set<Integer> temp) {\\n            for (int i = 0; i < m; i++) {\\n                if (array[i] == 1 && !temp.contains(i)) return false;\\n            }\\n            return true;\\n        }\\n\\n        private boolean isNoOneRow(int[] array) {\\n            for (int cell : array) {\\n                if (cell == 1) return false;\\n            }\\n            return true;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n\\tclass Solution {\\n        private int max;\\n        private int m;\\n\\n        public int maximumRows(int[][] matrix, int numSelect) {\\n            /*\\n            Row is covered:\\n            1. matrix[row][col] == 1, col in rowSet {0, 2}\\n            2. row doesn\\'t contain 1\\n            */\\n            if (matrix == null || matrix.length == 0) return 0;\\n\\n            m = matrix[0].length;\\n            max = 0;\\n\\n            backtrack(matrix, new HashSet<>(), numSelect, 0);\\n\\n            return max;\\n        }\\n\\n        private void backtrack(int[][] matrix, Set<Integer> temp, int numSelect, int start) {\\n            if (numSelect == 0) {\\n                max = Math.max(max, countCoverRows(matrix, temp));\\n                return;\\n            }\\n            for (int i = start; i < m; i++) {\\n                temp.add(i);\\n                backtrack(matrix, temp, numSelect - 1, i + 1);\\n                temp.remove(i);\\n            }\\n        }\\n\\n        private int countCoverRows(int[][] matrix, Set<Integer> temp) {\\n            int counter = 0;\\n            for (int[] row : matrix) {\\n                if (isAllCellsWithOneInSet(row, temp)) {\\n                    counter++;\\n                } else if (isNoOneRow(row)) {\\n                    counter++;\\n                }\\n            }\\n            return counter;\\n        }\\n\\n        private boolean isAllCellsWithOneInSet(int[] array, Set<Integer> temp) {\\n            for (int i = 0; i < m; i++) {\\n                if (array[i] == 1 && !temp.contains(i)) return false;\\n            }\\n            return true;\\n        }\\n\\n        private boolean isNoOneRow(int[] array) {\\n            for (int cell : array) {\\n                if (cell == 1) return false;\\n            }\\n            return true;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612831,
                "title": "simple-dynamic-programming",
                "content": "convert each row of zero on into a interger (using bit masking)\\nnow each column have a option whether to select it or not\\nhelper calculate the number of row that have been covered by our selection\\n```\\nclass Solution {\\npublic:\\n    int dp[5000];\\n    int helper(vector<int>&row,vector<int>&org)\\n    {\\n        int n=row.size();\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!(row[i]&org[i]))\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int solver(int i,int m,int n,vector<int>&row,vector<int>&org,int count,int  mask)\\n    {\\n        \\n        if(count==0 || i==m)\\n            return helper(row,org);\\n        \\n        if(dp[mask]!=-1)\\n            return dp[mask];\\n        \\n        int ans=0;\\n        \\n        ans=max(ans,solver(i+1,m,n,row,org,count,mask));\\n        \\n        for(int j=0;j<n;j++)\\n            row[j]^=(1<<i);\\n        \\n        \\n        ans=max(ans,solver(i+1,m,n,row,org,count-1,mask|(1<<i)));\\n        \\n        for(int j=0;j<n;j++)\\n            row[j]^=(1<<i);\\n        \\n            \\n        return dp[mask]=ans;\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        vector<int>row;\\n        vector<int>org;\\n\\t\\t\\n        //convert each row of zero on into a interger (using bit masking)\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n            int bit=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j])\\n                    bit|=(1<<j);\\n            }\\n            row.push_back(bit);\\n            org.push_back(bit);\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return solver(0,m,n,row,org,cols,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[5000];\\n    int helper(vector<int>&row,vector<int>&org)\\n    {\\n        int n=row.size();\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!(row[i]&org[i]))\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int solver(int i,int m,int n,vector<int>&row,vector<int>&org,int count,int  mask)\\n    {\\n        \\n        if(count==0 || i==m)\\n            return helper(row,org);\\n        \\n        if(dp[mask]!=-1)\\n            return dp[mask];\\n        \\n        int ans=0;\\n        \\n        ans=max(ans,solver(i+1,m,n,row,org,count,mask));\\n        \\n        for(int j=0;j<n;j++)\\n            row[j]^=(1<<i);\\n        \\n        \\n        ans=max(ans,solver(i+1,m,n,row,org,count-1,mask|(1<<i)));\\n        \\n        for(int j=0;j<n;j++)\\n            row[j]^=(1<<i);\\n        \\n            \\n        return dp[mask]=ans;\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        vector<int>row;\\n        vector<int>org;\\n\\t\\t\\n        //convert each row of zero on into a interger (using bit masking)\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n            int bit=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j])\\n                    bit|=(1<<j);\\n            }\\n            row.push_back(bit);\\n            org.push_back(bit);\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return solver(0,m,n,row,org,cols,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603039,
                "title": "python-cache",
                "content": "```\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        @cache\\n        def bt(k,bm):\\n            if k==0:\\n                v=len(matrix)\\n                for ri in range(len(matrix)):\\n                    for ci in range(len(matrix[0])):\\n                        kk=1<<ci\\n                        if kk&bm!=0:continue\\n                    \\n                        if matrix[ri][ci]==1:\\n                            v-=1\\n                            break\\n                return v\\n            v=0\\n            for ci in range(len(matrix[0])):\\n                kk=1<<ci\\n                if kk&bm!=0:continue\\n                v=max(v,bt(k-1,bm|kk))\\n            return v\\n\\n        return bt(numSelect,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        @cache\\n        def bt(k,bm):\\n            if k==0:\\n                v=len(matrix)\\n                for ri in range(len(matrix)):\\n                    for ci in range(len(matrix[0])):\\n                        kk=1<<ci\\n                        if kk&bm!=0:continue\\n                    \\n                        if matrix[ri][ci]==1:\\n                            v-=1\\n                            break\\n                return v\\n            v=0\\n            for ci in range(len(matrix[0])):\\n                kk=1<<ci\\n                if kk&bm!=0:continue\\n                v=max(v,bt(k-1,bm|kk))\\n            return v\\n\\n        return bt(numSelect,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583313,
                "title": "backtracking-without-bitwise-operations",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;    \\n    int findRows(vector<vector<int>> &B){\\n        int numOfRows = 0;\\n        int n = B.size();\\n        int m = B[0].size();\\n        for(int i=0;i<n;i++){\\n            if(ZeroSum(B,i,n,m)){\\n                numOfRows++;\\n            }\\n        }\\n        return numOfRows;\\n    }\\n    \\n    bool ZeroSum(vector<vector<int>> &B,int row,int n,int m){\\n        for(int col=0;col<m;col++){\\n            if(B[row][col] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void f(vector<vector<int>> &B,int j,int k,int m,unordered_map<int,vector<int>> &myMap){\\n        //base case\\n        if(k == 0){\\n            ans = max(ans,findRows(B));\\n            return;\\n        }\\n        if(j == m){\\n            return;\\n        }\\n        //recursive case\\n        //exclude\\n        f(B,j+1,k,m,myMap);\\n        //include\\n        for(auto a:myMap[j]){\\n            B[a][j] = 0;\\n        }\\n        f(B,j+1,k-1,m,myMap);\\n        for(auto a:myMap[j]){\\n            B[a][j] = 1;\\n        }\\n    }\\n    int maximumRows(vector<vector<int>>& A, int k) {\\n        int n = A.size();\\n        int m = A[0].size();\\n        unordered_map<int,vector<int>> myMap;\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i<n;i++){\\n                if(A[i][j] == 1){\\n                    myMap[j].push_back(i);\\n                }\\n            }\\n        }\\n        vector<vector<int>> B(n,vector<int>(m));\\n        B = A;\\n        f(B,0,k,m,myMap);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int ans = 0;    \\n    int findRows(vector<vector<int>> &B){\\n        int numOfRows = 0;\\n        int n = B.size();\\n        int m = B[0].size();\\n        for(int i=0;i<n;i++){\\n            if(ZeroSum(B,i,n,m)){\\n                numOfRows++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2579989,
                "title": "simple-java-backtracking",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    int C = 0;\\n    Map<Integer, Set<Integer>> map = new HashMap<>();\\n    \\n    public int maximumRows(int[][] M, int numSelect) {\\n        C = M[0].length;\\n        for(int r = 0; r < M.length; ++r) {\\n            map.put(r, new HashSet<>());\\n            for(int c=0; c < M[0].length; ++c) {\\n                if(M[r][c] == 0) continue;\\n                map.get(r).add(c);\\n            }\\n        }\\n\\n        backtrack(0, numSelect, new HashSet<>());\\n        return max;\\n    }\\n\\n    void backtrack(int col, int k, Set<Integer> current) {\\n        if(current.size() == k || max == map.size()) {\\n            int cur = coverage(current);\\n            max = Math.max(max, cur);\\n        } else {\\n            for(int c=col; c < C; ++c) {\\n                current.add(c);\\n                backtrack(c+1, k, current);\\n                current.remove(c);\\n            }\\n        }\\n    }\\n\\n    int coverage(Set<Integer> current) {\\n        int cnt = map.size();\\n        for(int r = 0; r < map.size() && cnt > max; ++r) {\\n            Set<Integer> cols = map.get(r);\\n            if(cols.size() > current.size()) {\\n                --cnt;\\n                continue;\\n            }\\n            \\n            for(int c : cols) {\\n                if(!current.contains(c)) {\\n                    --cnt;\\n                    break;\\n                }\\n            }\\n        } \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    int C = 0;\\n    Map<Integer, Set<Integer>> map = new HashMap<>();\\n    \\n    public int maximumRows(int[][] M, int numSelect) {\\n        C = M[0].length;\\n        for(int r = 0; r < M.length; ++r) {\\n            map.put(r, new HashSet<>());\\n            for(int c=0; c < M[0].length; ++c) {\\n                if(M[r][c] == 0) continue;\\n                map.get(r).add(c);\\n            }\\n        }\\n\\n        backtrack(0, numSelect, new HashSet<>());\\n        return max;\\n    }\\n\\n    void backtrack(int col, int k, Set<Integer> current) {\\n        if(current.size() == k || max == map.size()) {\\n            int cur = coverage(current);\\n            max = Math.max(max, cur);\\n        } else {\\n            for(int c=col; c < C; ++c) {\\n                current.add(c);\\n                backtrack(c+1, k, current);\\n                current.remove(c);\\n            }\\n        }\\n    }\\n\\n    int coverage(Set<Integer> current) {\\n        int cnt = map.size();\\n        for(int r = 0; r < map.size() && cnt > max; ++r) {\\n            Set<Integer> cols = map.get(r);\\n            if(cols.size() > current.size()) {\\n                --cnt;\\n                continue;\\n            }\\n            \\n            for(int c : cols) {\\n                if(!current.contains(c)) {\\n                    --cnt;\\n                    break;\\n                }\\n            }\\n        } \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577158,
                "title": "java-faster-than-100-1ms",
                "content": "```\\nclass Solution {\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        return helper(matrix, 0, numSelect);\\n    }\\n    \\n    private int helper(int[][] matrix, int col, int num){\\n        if(col > matrix[0].length) return 0;\\n        if(num == 0) return calculateRows(matrix);\\n        int max = 0;\\n        for(int i = col; i <= matrix[0].length - num; i++){\\n            int[] temp = setZero(matrix, i);\\n            max = Math.max(max, helper(matrix, i + 1, num - 1));\\n            resetZero(matrix, i, temp);\\n        }\\n        return max;\\n    }\\n    \\n    private int[] setZero(int[][] arr, int col){\\n        int[] temp = new int[arr.length];\\n        for(int i = 0; i < arr.length; i++){\\n            temp[i] = arr[i][col];\\n            arr[i][col] = 0;\\n        }\\n        return temp;\\n    }\\n    \\n    private void resetZero(int[][] arr, int col, int[] temp){\\n        for(int i = 0; i < arr.length; i++){\\n            arr[i][col] = temp[i];\\n        }\\n    }\\n    \\n    private int calculateRows(int[][] arr){\\n        int count = arr.length;\\n        for(int[] row : arr){\\n            for(int i = 0; i < row.length; i++){\\n                if(row[i] == 1) {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        return helper(matrix, 0, numSelect);\\n    }\\n    \\n    private int helper(int[][] matrix, int col, int num){\\n        if(col > matrix[0].length) return 0;\\n        if(num == 0) return calculateRows(matrix);\\n        int max = 0;\\n        for(int i = col; i <= matrix[0].length - num; i++){\\n            int[] temp = setZero(matrix, i);\\n            max = Math.max(max, helper(matrix, i + 1, num - 1));\\n            resetZero(matrix, i, temp);\\n        }\\n        return max;\\n    }\\n    \\n    private int[] setZero(int[][] arr, int col){\\n        int[] temp = new int[arr.length];\\n        for(int i = 0; i < arr.length; i++){\\n            temp[i] = arr[i][col];\\n            arr[i][col] = 0;\\n        }\\n        return temp;\\n    }\\n    \\n    private void resetZero(int[][] arr, int col, int[] temp){\\n        for(int i = 0; i < arr.length; i++){\\n            arr[i][col] = temp[i];\\n        }\\n    }\\n    \\n    private int calculateRows(int[][] arr){\\n        int count = arr.length;\\n        for(int[] row : arr){\\n            for(int i = 0; i < row.length; i++){\\n                if(row[i] == 1) {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566226,
                "title": "combinations-and-issubset-77-speed",
                "content": "![image](https://assets.leetcode.com/users/images/8171d85f-39ee-4c54-adf6-390d2df8c7d4_1662979932.8895636.png)\\n```\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        ans = 0\\n        m_ones = [{i for i, v in enumerate(row) if v} for row in matrix]\\n        for comb in combinations(range(len(matrix[0])), numSelect):\\n            set_comb = set(comb)\\n            ans = max(ans, sum(s.issubset(set_comb) for s in m_ones))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\\n        ans = 0\\n        m_ones = [{i for i, v in enumerate(row) if v} for row in matrix]\\n        for comb in combinations(range(len(matrix[0])), numSelect):\\n            set_comb = set(comb)\\n            ans = max(ans, sum(s.issubset(set_comb) for s in m_ones))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563739,
                "title": "how-is-it-in-the-medium-category",
                "content": "Like seiously, after wasting a day and a half pondering upon a consize and effective approach, this problem turns out to be a basic bruteforce backtracking problem!!!\\nTotally annoying",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2559959,
                "title": "java-backtracking",
                "content": "\\tclass Solution {\\n\\t\\tint max=0;\\n\\t\\tpublic int maximumRows(int[][] matrix, int numSelect) {\\n\\t\\t\\thelper(matrix,0,numSelect);\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\t\\tHashSet<Integer> set=new HashSet<>();\\n\\t\\tpublic int helper(int [][]matrix,int col,int num)\\n\\t\\t{\\n\\t\\t\\tif(col==matrix[0].length || num==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmax=Math.max(max,toCount(matrix));\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint pick=0,notPick=0;\\n\\t\\t   set.add(col);\\n\\t\\t\\tpick=helper(matrix,col+1,num-1);\\n\\t\\t\\tset.remove(col);\\n\\t\\t\\tnotPick=helper(matrix,col+1,num);\\n\\t\\t\\treturn Math.max(pick,notPick);\\n\\t\\t}\\n\\t\\tpublic int toCount(int[][]matrix)\\n\\t\\t{\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<matrix.length;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint zero=0;\\n\\t\\t\\t\\tfor(int j=0;j<matrix[0].length;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0 || set.contains(j))\\n\\t\\t\\t\\t\\t\\tzero++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(zero==matrix[0].length)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\tint max=0;\\n\\t\\tpublic int maximumRows(int[][] matrix, int numSelect) {\\n\\t\\t\\thelper(matrix,0,numSelect);\\n\\t\\t\\treturn max;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2559734,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void backtrack(vector<int> &row,  int index, vector<vector<int>>& matrix, int numSelect, int &result){\\n        if(index == matrix[0].size() && numSelect != 0)\\n            return;\\n        if(numSelect == 0){\\n            int count = 0;\\n            for(auto v: row)\\n                if(v == 0)\\n                    count++;\\n            result = max(result, count);\\n            return;\\n        }\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        backtrack(row, index + 1, matrix, numSelect, result);\\n        for(int i=0;i<n;i++)\\n            row[i] -= matrix[i][index];\\n        backtrack(row, index + 1, matrix, numSelect - 1, result);\\n        for(int i=0;i<n;i++)\\n            row[i] += matrix[i][index];\\n        \\n        \\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<int> row(n,0);\\n        for(int i=0;i<n;i++)\\n            for(auto v: matrix[i])\\n                row[i]+=v;\\n        int result = INT_MIN;\\n        backtrack(row,0, matrix, numSelect, result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(vector<int> &row,  int index, vector<vector<int>>& matrix, int numSelect, int &result){\\n        if(index == matrix[0].size() && numSelect != 0)\\n            return;\\n        if(numSelect == 0){\\n            int count = 0;\\n            for(auto v: row)\\n                if(v == 0)\\n                    count++;\\n            result = max(result, count);\\n            return;\\n        }\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        backtrack(row, index + 1, matrix, numSelect, result);\\n        for(int i=0;i<n;i++)\\n            row[i] -= matrix[i][index];\\n        backtrack(row, index + 1, matrix, numSelect - 1, result);\\n        for(int i=0;i<n;i++)\\n            row[i] += matrix[i][index];\\n        \\n        \\n    }\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<int> row(n,0);\\n        for(int i=0;i<n;i++)\\n            for(auto v: matrix[i])\\n                row[i]+=v;\\n        int result = INT_MIN;\\n        backtrack(row,0, matrix, numSelect, result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558857,
                "title": "java-no-bitmasking-only-recursion",
                "content": "```\\nclass Solution {\\n\\n    //Author: Anand\\n    int max = Integer.MIN_VALUE;\\n    List<List<Integer>> onePos = new ArrayList<>();\\n    Set<String> colP = new HashSet<>();\\n\\n    public int maximumRows(int[][] mat, int cols) {\\n\\n        int m = mat.length;\\n        int n = mat[0].length;\\n\\n        for (int i = 0; i < m; i++) {\\n            onePos.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1) onePos.get(i).add(j);\\n            }\\n        }\\n\\n        chooseCol(m, n, cols, mat, new HashSet<>(), 0);\\n        return max;\\n    }\\n\\n    private void chooseCol(int m, int n, int cols, int[][] mat, HashSet<Integer> colTaken, int x) {\\n\\n        if (cols == 0) {\\n            if (!colP.contains(colTaken.toString())) {\\n                max = Math.max(max, selectRows(colTaken, mat));\\n                colP.add(colTaken.toString());\\n            }\\n            return;\\n        }\\n\\n\\n        for (int i = x; i < n; i++) {\\n            if (colTaken.contains(i)) continue;\\n            // take\\n            colTaken.add(i);\\n            chooseCol(m, n, cols - 1, mat, colTaken, x + 1);\\n            // not take\\n            colTaken.remove(i);\\n        }\\n    }\\n    \\n    \\n    private int selectRows(HashSet<Integer> colTaken, int[][] mat) {\\n\\n        int cnt = 0;\\n        for (List<Integer> rows : onePos) {\\n\\n            boolean present = true;\\n            for (int pos : rows) {\\n                if (!colTaken.contains(pos)) {\\n                    present = false;\\n                    break;\\n                }\\n            }\\n\\n            if (present) cnt++;\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    //Author: Anand\\n    int max = Integer.MIN_VALUE;\\n    List<List<Integer>> onePos = new ArrayList<>();\\n    Set<String> colP = new HashSet<>();\\n\\n    public int maximumRows(int[][] mat, int cols) {\\n\\n        int m = mat.length;\\n        int n = mat[0].length;\\n\\n        for (int i = 0; i < m; i++) {\\n            onePos.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1) onePos.get(i).add(j);\\n            }\\n        }\\n\\n        chooseCol(m, n, cols, mat, new HashSet<>(), 0);\\n        return max;\\n    }\\n\\n    private void chooseCol(int m, int n, int cols, int[][] mat, HashSet<Integer> colTaken, int x) {\\n\\n        if (cols == 0) {\\n            if (!colP.contains(colTaken.toString())) {\\n                max = Math.max(max, selectRows(colTaken, mat));\\n                colP.add(colTaken.toString());\\n            }\\n            return;\\n        }\\n\\n\\n        for (int i = x; i < n; i++) {\\n            if (colTaken.contains(i)) continue;\\n            // take\\n            colTaken.add(i);\\n            chooseCol(m, n, cols - 1, mat, colTaken, x + 1);\\n            // not take\\n            colTaken.remove(i);\\n        }\\n    }\\n    \\n    \\n    private int selectRows(HashSet<Integer> colTaken, int[][] mat) {\\n\\n        int cnt = 0;\\n        for (List<Integer> rows : onePos) {\\n\\n            boolean present = true;\\n            for (int pos : rows) {\\n                if (!colTaken.contains(pos)) {\\n                    present = false;\\n                    break;\\n                }\\n            }\\n\\n            if (present) cnt++;\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557176,
                "title": "typescript-dfs-solution-with-picture-illustration",
                "content": "# 1. understanding about the problem\\n<img src=\"https://t25658159.p.clickup-attachments.com/t25658159/2f48dba5-c676-40a4-a8cb-bc918e81079d/2397-1.PNG\" width=80% />\\n\\n# 2. dfs\\nThough it may easily get TLE with some special cases, but it is the most straightforward solution.\\n\\n**Typescript**\\n```ts\\nfunction maximumRows(matrix: number[][], numSelect: number): number {\\n  const m = matrix.length;\\n  const n = matrix[0].length;\\n  const masks: number[] = []; // someting like [1010, 1100, ...]\\n  // turn each column into binary representation\\n  for (let j = 0; j < n; j++) {\\n    let val = 0;\\n    for (let i = 0; i < m; i++) {\\n      val |= (matrix[i][j] << i);\\n    }\\n    masks.push(val);\\n  }\\n  return dfs(masks, m, n, numSelect, 0, 0, 0);\\n};\\n\\nfunction dfs(masks: number[], m: number, n: number, numSelect: number, alreadySelected: number, startCol: number, selectedCols: number) {\\n  if (alreadySelected === numSelect) {\\n    // calculate how many rows are covered by currently selected columns\\n    let covered = 0;\\n    for (let i = 0; i < n; i++) {\\n      // column i is not selected\\n      if ((selectedCols >> i & 1) === 0) {\\n        covered |= masks[i];\\n      }\\n    }\\n    // get how many 0s are there in covered\\n    let zeroCount = 0;\\n    for (let i = 0; i < m; i++) {\\n      if ((covered & 1) === 0) {\\n        zeroCount++;\\n      }\\n      covered = covered >> 1;\\n    }\\n    return zeroCount;\\n  }\\n\\n  if (startCol === n) {\\n    return 0;\\n  }\\n\\n  // select\\n  const ans1 = dfs(masks, m, n, numSelect, alreadySelected + 1, startCol + 1, selectedCols | (1 << startCol));\\n\\n  // don\\'t select\\n  const ans2 = dfs(masks, m, n, numSelect, alreadySelected, startCol + 1, selectedCols);\\n\\n  return Math.max(ans1, ans2);\\n}\\n```\\n\\n# 3. Is there a better solution out there?\\nAfter a few hours struggle, I couldn\\'t find more efficient solution with my dummy IQ.",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```ts\\nfunction maximumRows(matrix: number[][], numSelect: number): number {\\n  const m = matrix.length;\\n  const n = matrix[0].length;\\n  const masks: number[] = []; // someting like [1010, 1100, ...]\\n  // turn each column into binary representation\\n  for (let j = 0; j < n; j++) {\\n    let val = 0;\\n    for (let i = 0; i < m; i++) {\\n      val |= (matrix[i][j] << i);\\n    }\\n    masks.push(val);\\n  }\\n  return dfs(masks, m, n, numSelect, 0, 0, 0);\\n};\\n\\nfunction dfs(masks: number[], m: number, n: number, numSelect: number, alreadySelected: number, startCol: number, selectedCols: number) {\\n  if (alreadySelected === numSelect) {\\n    // calculate how many rows are covered by currently selected columns\\n    let covered = 0;\\n    for (let i = 0; i < n; i++) {\\n      // column i is not selected\\n      if ((selectedCols >> i & 1) === 0) {\\n        covered |= masks[i];\\n      }\\n    }\\n    // get how many 0s are there in covered\\n    let zeroCount = 0;\\n    for (let i = 0; i < m; i++) {\\n      if ((covered & 1) === 0) {\\n        zeroCount++;\\n      }\\n      covered = covered >> 1;\\n    }\\n    return zeroCount;\\n  }\\n\\n  if (startCol === n) {\\n    return 0;\\n  }\\n\\n  // select\\n  const ans1 = dfs(masks, m, n, numSelect, alreadySelected + 1, startCol + 1, selectedCols | (1 << startCol));\\n\\n  // don\\'t select\\n  const ans2 = dfs(masks, m, n, numSelect, alreadySelected, startCol + 1, selectedCols);\\n\\n  return Math.max(ans1, ans2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557118,
                "title": "easiest-solution-in-java-using-backtracking",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    \\n    void  count(int[][] mat, List<Integer> selectedCol){\\n        int c = 0;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int x : selectedCol)  set.add(x);\\n        \\n        for(int i = 0; i<mat.length; i++){\\n\\n           boolean flag = true;\\n            for(int j = 0; j < mat[0].length; j++){\\n                \\n                if(mat[i][j] == 1 && !set.contains(j)){\\n                    flag = false;\\n                    break;\\n                }\\n                \\n            }\\n            \\n            if(flag) c++;\\n         \\n        }\\n        \\n    res = Math.max(res, c);\\n        \\n    }\\n    \\n    void find(int[][] mat, int m, int index, int num, List<Integer> selectedColumn){\\n        if(selectedColumn.size() > num)  return ;\\n        \\n        if(selectedColumn.size() == num){\\n            count(mat, selectedColumn);\\n            return ;\\n        }\\n        \\n        for(int i = index; i<m;i++){\\n            selectedColumn.add(i);\\n            find(mat,m,i+1,num, selectedColumn);\\n            selectedColumn.remove(selectedColumn.size()-1);\\n            \\n        }\\n        \\n        return ;\\n        \\n    }\\n    \\n    public int maximumRows(int[][] mat, int num) {\\n        \\n        int rowSize = mat.length;\\n        int colSize = mat[0].length;\\n        \\n        find(mat,colSize,  0, num, new ArrayList<>());\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    \\n    void  count(int[][] mat, List<Integer> selectedCol){\\n        int c = 0;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int x : selectedCol)  set.add(x);\\n        \\n        for(int i = 0; i<mat.length; i++){\\n\\n           boolean flag = true;\\n            for(int j = 0; j < mat[0].length; j++){\\n                \\n                if(mat[i][j] == 1 && !set.contains(j)){\\n                    flag = false;\\n                    break;\\n                }\\n                \\n            }\\n            \\n            if(flag) c++;\\n         \\n        }\\n        \\n    res = Math.max(res, c);\\n        \\n    }\\n    \\n    void find(int[][] mat, int m, int index, int num, List<Integer> selectedColumn){\\n        if(selectedColumn.size() > num)  return ;\\n        \\n        if(selectedColumn.size() == num){\\n            count(mat, selectedColumn);\\n            return ;\\n        }\\n        \\n        for(int i = index; i<m;i++){\\n            selectedColumn.add(i);\\n            find(mat,m,i+1,num, selectedColumn);\\n            selectedColumn.remove(selectedColumn.size()-1);\\n            \\n        }\\n        \\n        return ;\\n        \\n    }\\n    \\n    public int maximumRows(int[][] mat, int num) {\\n        \\n        int rowSize = mat.length;\\n        int colSize = mat[0].length;\\n        \\n        find(mat,colSize,  0, num, new ArrayList<>());\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556994,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    static int max;\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        int m = matrix[0].length;\\n        int[] cols = new int[m];\\n        \\n        max = Integer.MIN_VALUE;\\n        \\n        selection(cols, 0, numSelect, 0, matrix);\\n        \\n        return max;\\n    }\\n    public int checkResult(int[] cols, int[][] matrix, int numSelect){\\n        \\n        int res = 0;\\n        for(int i = 0;i<matrix.length;i++){\\n            int cnt = 0;\\n            for(int j = 0;j<matrix[0].length;j++){\\n                if(matrix[i][j] == 1 && cols[j] == 0){\\n                    cnt++;\\n                }\\n            }\\n            \\n            if(cnt == 0){\\n                res++;\\n            }\\n        }\\n        \\n       return res;\\n    }\\n    \\n    public void selection(int[] cols, int curr, int numSelect, int idx, int[][] matrix){\\n        if(idx == cols.length){\\n            if(curr == numSelect){\\n               int ans = checkResult(cols, matrix, numSelect);\\n                max = Math.max(ans, max);\\n            }\\n            \\n            return;\\n        }\\n        \\n        \\n        cols[idx] = 1;\\n        selection(cols, curr + 1, numSelect, idx+1, matrix);\\n        cols[idx] = 0;\\n        selection(cols, curr, numSelect, idx+1, matrix);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    static int max;\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        int m = matrix[0].length;\\n        int[] cols = new int[m];\\n        \\n        max = Integer.MIN_VALUE;\\n        \\n        selection(cols, 0, numSelect, 0, matrix);\\n        \\n        return max;\\n    }\\n    public int checkResult(int[] cols, int[][] matrix, int numSelect){\\n        \\n        int res = 0;\\n        for(int i = 0;i<matrix.length;i++){\\n            int cnt = 0;\\n            for(int j = 0;j<matrix[0].length;j++){\\n                if(matrix[i][j] == 1 && cols[j] == 0){\\n                    cnt++;\\n                }\\n            }\\n            \\n            if(cnt == 0){\\n                res++;\\n            }\\n        }\\n        \\n       return res;\\n    }\\n    \\n    public void selection(int[] cols, int curr, int numSelect, int idx, int[][] matrix){\\n        if(idx == cols.length){\\n            if(curr == numSelect){\\n               int ans = checkResult(cols, matrix, numSelect);\\n                max = Math.max(ans, max);\\n            }\\n            \\n            return;\\n        }\\n        \\n        \\n        cols[idx] = 1;\\n        selection(cols, curr + 1, numSelect, idx+1, matrix);\\n        cols[idx] = 0;\\n        selection(cols, curr, numSelect, idx+1, matrix);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551697,
                "title": "c-dfs",
                "content": "```\\nclass Solution \\n{\\n    int m;\\n    int n;\\n    vector<bool> selected;\\n    int ans = 0;\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) \\n    {\\n        m = matrix.size();\\n        n = matrix[0].size();\\n        \\n        selected.resize(n);\\n        dfs(matrix, numSelect, 0);\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>>& mat, int cnt, int cur)\\n    {\\n        if (cnt == 0)\\n        {\\n            int rows = 0;\\n            for (int i = 0; i < m; ++i)\\n            {\\n                bool covered = true;\\n                for (int j = 0; j < n; ++j)\\n                {\\n                    if (mat[i][j] == 1 && !selected[j])\\n                    {\\n                        covered = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if (covered)\\n                {\\n                    ++rows;\\n                }\\n            }\\n            \\n            ans = max(ans, rows);\\n            return;\\n        }\\n        \\n        for (int k = cur; k < n; ++k)\\n        {\\n            selected[k] = true;\\n            dfs(mat, cnt - 1, k + 1);\\n            selected[k] = false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    int m;\\n    int n;\\n    vector<bool> selected;\\n    int ans = 0;\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) \\n    {\\n        m = matrix.size();\\n        n = matrix[0].size();\\n        \\n        selected.resize(n);\\n        dfs(matrix, numSelect, 0);\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>>& mat, int cnt, int cur)\\n    {\\n        if (cnt == 0)\\n        {\\n            int rows = 0;\\n            for (int i = 0; i < m; ++i)\\n            {\\n                bool covered = true;\\n                for (int j = 0; j < n; ++j)\\n                {\\n                    if (mat[i][j] == 1 && !selected[j])\\n                    {\\n                        covered = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if (covered)\\n                {\\n                    ++rows;\\n                }\\n            }\\n            \\n            ans = max(ans, rows);\\n            return;\\n        }\\n        \\n        for (int k = cur; k < n; ++k)\\n        {\\n            selected[k] = true;\\n            dfs(mat, cnt - 1, k + 1);\\n            selected[k] = false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551092,
                "title": "bitmasking-backtracking",
                "content": "```\\nint ans;\\n    void helper2(int mask,vector<vector<int>>&mat){ // Calculating no of rows covered for each column combination\\n        int res = 0;\\n        for(int i = 0;i<mat.size();i++){\\n            bool flag = 1,flag2 = 1;// flag for row with all 0 values, flag2 for checking whether all 1 in row are covered in selected columns\\n            for(int j = 0;j<mat[0].size();j++){\\n                if(mat[i][j]){\\n                    flag = 0;\\n                    if(!(mask & (1<<j))){\\n                        flag2 = 0;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag || flag2) res++;\\n        }\\n        ans = max(ans,res);\\n    }\\n    \\n    void helper(int k,int idx,int mask,vector<vector<int>>&m){ // used for generating all column combination\\n        if(k==0){\\n            helper2(mask,m);\\n            return;\\n        }\\n        for(int i = idx+1;i<m[0].size();i++){\\n            helper(k-1,i,mask|(1<<i),m);\\n        }\\n    }\\n    \\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        ans = 0;\\n        helper(numSelect,-1,0,matrix);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint ans;\\n    void helper2(int mask,vector<vector<int>>&mat){ // Calculating no of rows covered for each column combination\\n        int res = 0;\\n        for(int i = 0;i<mat.size();i++){\\n            bool flag = 1,flag2 = 1;// flag for row with all 0 values, flag2 for checking whether all 1 in row are covered in selected columns\\n            for(int j = 0;j<mat[0].size();j++){\\n                if(mat[i][j]){\\n                    flag = 0;\\n                    if(!(mask & (1<<j))){\\n                        flag2 = 0;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag || flag2) res++;\\n        }\\n        ans = max(ans,res);\\n    }\\n    \\n    void helper(int k,int idx,int mask,vector<vector<int>>&m){ // used for generating all column combination\\n        if(k==0){\\n            helper2(mask,m);\\n            return;\\n        }\\n        for(int i = idx+1;i<m[0].size();i++){\\n            helper(k-1,i,mask|(1<<i),m);\\n        }\\n    }\\n    \\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        ans = 0;\\n        helper(numSelect,-1,0,matrix);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549993,
                "title": "c-easy-backtracking-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int> &vis,vector<vector<int>>& matrix,int r,int c){\\n        int ans=0;\\n        for(int i=0;i<r;i++){\\n            bool f=true;\\n            for(int j=0;j<c;j++){\\n                if(matrix[i][j]==1 && vis[j]==-1){\\n                    f=false;\\n                    break;\\n                }\\n            }\\n            if(f==true)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(vector<vector<int>>& matrix,int r,int c,int k,int &ans,int col,int kcnt,vector<int> &vis){\\n       \\n        if(kcnt==0){\\n            ans=max(ans,check(vis,matrix,r,c));\\n            return;\\n        }\\n          if(col==c)\\n            return;\\n        vis[col]=1;\\n        solve(matrix,r,c,k,ans,col+1,kcnt-1,vis);\\n        vis[col]=-1;\\n        solve(matrix,r,c,k,ans,col+1,kcnt,vis);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& matrix, int k) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        vector<int>vis(c,-1);\\n        int ans=0;\\n        solve(matrix,r,c,k,ans,0,k,vis);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int> &vis,vector<vector<int>>& matrix,int r,int c){\\n        int ans=0;\\n        for(int i=0;i<r;i++){\\n            bool f=true;\\n            for(int j=0;j<c;j++){\\n                if(matrix[i][j]==1 && vis[j]==-1){\\n                    f=false;\\n                    break;\\n                }\\n            }\\n            if(f==true)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(vector<vector<int>>& matrix,int r,int c,int k,int &ans,int col,int kcnt,vector<int> &vis){\\n       \\n        if(kcnt==0){\\n            ans=max(ans,check(vis,matrix,r,c));\\n            return;\\n        }\\n          if(col==c)\\n            return;\\n        vis[col]=1;\\n        solve(matrix,r,c,k,ans,col+1,kcnt-1,vis);\\n        vis[col]=-1;\\n        solve(matrix,r,c,k,ans,col+1,kcnt,vis);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& matrix, int k) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        vector<int>vis(c,-1);\\n        int ans=0;\\n        solve(matrix,r,c,k,ans,0,k,vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548935,
                "title": "python-bit-masking-combinations-38-ms-faster-than-99-o-n-2-m-cols",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        n = len(mat[0])\\n        if cols == n:\\n            return len(mat)\\n\\n        # O(m * n)\\n        rowNumberify = []\\n        for row in mat:\\n            rowNumberify.append(0)\\n            for x in row:\\n                rowNumberify[-1] <<= 1\\n                rowNumberify[-1] += x\\n\\n        m = 0\\n        # O((n! / cols! / (n - cols)!) * (m + cols))\\n        # here for detail:\\n        # https://docs.python.org/3/library/itertools.html#itertools.combinations\\n        for c in combinations([1 << i for i in range(n)], cols):\\n            contextMask = sum(c)\\n            __ = sum([1 for x in rowNumberify if ((x | contextMask) ^ contextMask) == 0])\\n            m = max(m, __)\\n\\n        return m\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def maximumRows(self, mat: List[List[int]], cols: int) -> int:\\n        n = len(mat[0])\\n        if cols == n:\\n            return len(mat)\\n\\n        # O(m * n)\\n        rowNumberify = []\\n        for row in mat:\\n            rowNumberify.append(0)\\n            for x in row:\\n                rowNumberify[-1] <<= 1\\n                rowNumberify[-1] += x\\n\\n        m = 0\\n        # O((n! / cols! / (n - cols)!) * (m + cols))\\n        # here for detail:\\n        # https://docs.python.org/3/library/itertools.html#itertools.combinations\\n        for c in combinations([1 << i for i in range(n)], cols):\\n            contextMask = sum(c)\\n            __ = sum([1 for x in rowNumberify if ((x | contextMask) ^ contextMask) == 0])\\n            m = max(m, __)\\n\\n        return m\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546985,
                "title": "maximum-rows-covered-by-columns-simple-backtracking-approach-c",
                "content": "```\\n```\\nclass Solution {\\npublic:\\n    \\n    void pickColumns(vector<vector<int>>& mat,int cols,int used,int index,vector<bool>&visited,int&ans)\\n    {\\n        if(index==mat[0].size())\\n        {\\n            int count=0;\\n            for(int i=0;i<mat.size();i++)\\n            {\\n                bool flag=true;\\n                for(int j=0;j<mat[0].size();j++)\\n                {\\n                    if(mat[i][j]==1)\\n                    {\\n                        if(visited[j]==false)\\n                        {\\n                            flag=false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(flag)\\n                {\\n                    count++;\\n                }\\n            }\\n            ans=max(ans,count);\\n            return;\\n        }\\n        \\n        \\n        if(used<cols)\\n        {\\n            visited[index]=true;\\n            pickColumns(mat,cols,used+1,index+1,visited,ans);\\n            visited[index]=false;\\n        }\\n        pickColumns(mat,cols,used,index+1,visited,ans);\\n        \\n    }\\n    \\n    \\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        vector<bool>visited(matrix[0].size(),false); int ans=0,used=0;\\n        pickColumns(matrix,numSelect,used,0,visited,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2541570,
                "title": "simple-java-solution-with-explanation-bit-masking-and-iteration",
                "content": "```\\nclass Solution {\\n    List<Integer> combinations = new ArrayList<>();\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        // generate permutations using bit masking \\n\\t\\t// eg: select cols 0 and 2 of 3 cols would be = 101 in base 2 or 5 in base 10\\n        // max possible permutations from given constraints = choose 6 of 12 cols = 12 C 6 < 10^3 \\n        generatePermutations(matrix[0].length, numSelect, 0, 0, 0);\\n        \\n        int max = 0;\\n        // for each combination, find the max number of rows covered\\n        for (int combination : combinations) {\\n            max = Math.max(max, getMaxRowsCovered(combination, matrix));\\n        }\\n        return max;\\n    }\\n    \\n    int getMaxRowsCovered(int combination, int[][] matrix) {\\n        int[] selection = new int[matrix[0].length];\\n        // convert bit mask to column selection\\n        // eg: 5 in base 10 = 101 in base 2 = cols 0 and 2 are selected\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            selection[i] = ((combination & (1 << i)) != 0) ? 1 : 0;\\n        }\\n        \\n        int rowCount = 0;\\n        // check every row for this column selection, if it is covered and update count\\n        for (int i = 0; i < matrix.length; i++) {\\n            rowCount += isRowCovered(matrix, selection, i) ? 1 : 0;\\n        }\\n        return rowCount;\\n    }\\n    \\n    boolean isRowCovered(int[][] matrix, int[] selection, int row) {\\n        boolean allZero = true;\\n        boolean allSelected = true;\\n        // check if current row is covered by given constraint\\n        for (int col = 0; col < matrix[0].length; col++) {\\n            if (matrix[row][col] != 0) allZero = false;\\n            if (matrix[row][col] == 1 && selection[col] != 1) allSelected = false;\\n        }\\n        return allZero || allSelected;\\n    }\\n    \\n    void generatePermutations(int length, int choose, int index, int count, int binaryVal) {\\n        if (count == choose) {\\n            // if we have selected the required number of columns\\n            combinations.add(binaryVal);\\n            return;\\n        } else if (index >= length) {\\n            // if we have processed all columns\\n            return;\\n        } else {\\n            // if we choose the current coolumn\\n            int take = binaryVal | 1 << (index);\\n            generatePermutations(length, choose, index + 1, count + 1, take);\\n            // id we don\\'t choose the current column\\n            int leave = binaryVal;\\n            generatePermutations(length, choose, index + 1, count, leave);    \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> combinations = new ArrayList<>();\\n    public int maximumRows(int[][] matrix, int numSelect) {\\n        // generate permutations using bit masking \\n\\t\\t// eg: select cols 0 and 2 of 3 cols would be = 101 in base 2 or 5 in base 10\\n        // max possible permutations from given constraints = choose 6 of 12 cols = 12 C 6 < 10^3 \\n        generatePermutations(matrix[0].length, numSelect, 0, 0, 0);\\n        \\n        int max = 0;\\n        // for each combination, find the max number of rows covered\\n        for (int combination : combinations) {\\n            max = Math.max(max, getMaxRowsCovered(combination, matrix));\\n        }\\n        return max;\\n    }\\n    \\n    int getMaxRowsCovered(int combination, int[][] matrix) {\\n        int[] selection = new int[matrix[0].length];\\n        // convert bit mask to column selection\\n        // eg: 5 in base 10 = 101 in base 2 = cols 0 and 2 are selected\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            selection[i] = ((combination & (1 << i)) != 0) ? 1 : 0;\\n        }\\n        \\n        int rowCount = 0;\\n        // check every row for this column selection, if it is covered and update count\\n        for (int i = 0; i < matrix.length; i++) {\\n            rowCount += isRowCovered(matrix, selection, i) ? 1 : 0;\\n        }\\n        return rowCount;\\n    }\\n    \\n    boolean isRowCovered(int[][] matrix, int[] selection, int row) {\\n        boolean allZero = true;\\n        boolean allSelected = true;\\n        // check if current row is covered by given constraint\\n        for (int col = 0; col < matrix[0].length; col++) {\\n            if (matrix[row][col] != 0) allZero = false;\\n            if (matrix[row][col] == 1 && selection[col] != 1) allSelected = false;\\n        }\\n        return allZero || allSelected;\\n    }\\n    \\n    void generatePermutations(int length, int choose, int index, int count, int binaryVal) {\\n        if (count == choose) {\\n            // if we have selected the required number of columns\\n            combinations.add(binaryVal);\\n            return;\\n        } else if (index >= length) {\\n            // if we have processed all columns\\n            return;\\n        } else {\\n            // if we choose the current coolumn\\n            int take = binaryVal | 1 << (index);\\n            generatePermutations(length, choose, index + 1, count + 1, take);\\n            // id we don\\'t choose the current column\\n            int leave = binaryVal;\\n            generatePermutations(length, choose, index + 1, count, leave);    \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541513,
                "title": "bitmasking-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n      int m=mat.size();\\n      int n=mat[0].size();\\n      \\n      vector<int>nums;\\n      for(int i=0;i<m;i++)\\n      {\\n        int x=0,p=0;\\n        for(int j=n-1;j>=0;j--)\\n        {\\n          if(mat[i][j]==1)\\n          {\\n            x+=pow(2,p);\\n          }\\n          p++;\\n        }\\n        nums.push_back(x);\\n      }\\n      int maxi=INT_MIN;\\n      for(int i=0;i<(1<<n);i++)\\n      {\\n        int ans=0;\\n        if(__builtin_popcount(i)==cols)\\n        {\\n          for(int x:nums)\\n          {\\n            if((x|i)==i)ans++;\\n          }\\n        }\\n        maxi=max(maxi,ans);\\n      }\\n      return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n      int m=mat.size();\\n      int n=mat[0].size();\\n      \\n      vector<int>nums;\\n      for(int i=0;i<m;i++)\\n      {\\n        int x=0,p=0;\\n        for(int j=n-1;j>=0;j--)\\n        {\\n          if(mat[i][j]==1)\\n          {\\n            x+=pow(2,p);\\n          }\\n          p++;\\n        }\\n        nums.push_back(x);\\n      }\\n      int maxi=INT_MIN;\\n      for(int i=0;i<(1<<n);i++)\\n      {\\n        int ans=0;\\n        if(__builtin_popcount(i)==cols)\\n        {\\n          for(int x:nums)\\n          {\\n            if((x|i)==i)ans++;\\n          }\\n        }\\n        maxi=max(maxi,ans);\\n      }\\n      return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540361,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int rowCount = matrix.size(), colCount = matrix[0].size();\\n        \\n        //base case if we can take all the columns \\n        if(numSelect >= colCount) return rowCount;\\n    \\n        \\n        vector<int> rows(rowCount);\\n        \\n        //convert all row to number\\n        for(int i = 0; i < rowCount; i++){\\n            int num = 0;\\n            //store the values of column and row\\n            for(int j = colCount-1, base = 0; j >= 0; j--, base++){\\n                num += matrix[i][j] * pow(2,base);\\n            }\\n            rows[i] = num;\\n        }\\n        \\n\\n        \\n        return dfs(rows,0,0,numSelect);\\n        \\n    }\\n    \\n    int dfs(vector<int>& rows,int row,int mask,int numSelect){\\n        int n = rows.size();\\n        \\n        if(row >= n) return 0;\\n        \\n    \\n        //if the current row is zero then no check require just add it\\n        if(rows[row] == 0) return 1 + dfs(rows,row+1,mask,numSelect);\\n        \\n        int res = 0;\\n        \\n         //if we don\\'t add the current row\\n        res = max(res , dfs(rows,row+1,mask,numSelect));\\n        \\n        \\n        //if we add the current row \\n        mask = mask | rows[row];\\n        \\n        //if thats dosn\\'t break max col select constraints\\n        if(__builtin_popcount(mask) <= numSelect)\\n            res = max(res, 1 + dfs(rows,row+1,mask,numSelect));\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\\n        int rowCount = matrix.size(), colCount = matrix[0].size();\\n        \\n        //base case if we can take all the columns \\n        if(numSelect >= colCount) return rowCount;\\n    \\n        \\n        vector<int> rows(rowCount);\\n        \\n        //convert all row to number\\n        for(int i = 0; i < rowCount; i++){\\n            int num = 0;\\n            //store the values of column and row\\n            for(int j = colCount-1, base = 0; j >= 0; j--, base++){\\n                num += matrix[i][j] * pow(2,base);\\n            }\\n            rows[i] = num;\\n        }\\n        \\n\\n        \\n        return dfs(rows,0,0,numSelect);\\n        \\n    }\\n    \\n    int dfs(vector<int>& rows,int row,int mask,int numSelect){\\n        int n = rows.size();\\n        \\n        if(row >= n) return 0;\\n        \\n    \\n        //if the current row is zero then no check require just add it\\n        if(rows[row] == 0) return 1 + dfs(rows,row+1,mask,numSelect);\\n        \\n        int res = 0;\\n        \\n         //if we don\\'t add the current row\\n        res = max(res , dfs(rows,row+1,mask,numSelect));\\n        \\n        \\n        //if we add the current row \\n        mask = mask | rows[row];\\n        \\n        //if thats dosn\\'t break max col select constraints\\n        if(__builtin_popcount(mask) <= numSelect)\\n            res = max(res, 1 + dfs(rows,row+1,mask,numSelect));\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538451,
                "title": "standard-backtracking-solution",
                "content": "```\\n   //2397. Maximum Rows Covered by Columns\\n    \\n    // global var to store our ans\\n    int ans=0;\\n\\n    public int maximumRows(int[][] mat, int cols) {\\n        \\n        fn( mat,mat.length, mat[0].length,0,cols);\\n        \\n        return ans;\\n    }\\n\\n    void fn( int[][] mat, int n, int m, int i, int cols){\\n        \\n        // if we are out of columns to select or no more columns to select then we check if we have found a new ans and return\\n        if( cols==0 || i==m){\\n            ans= Math.max( ans, countRows(mat, n, m));\\n        }\\n        else{\\n\\n            // either u don\\'t include the column or u include the column\\n            \\n            // u don\\'t include the current column\\n            fn( mat, n, m,i+1,cols);\\n            \\n            // include the current column\\n            \\n            // create a copy of the matrix\\n            int[][] temp= new int[n][m];\\n            \\n             for( int ii=0; ii<n; ii++){\\n            for( int jj=0; jj<m;jj++){\\n                temp[ii][jj]= mat[ii][jj];\\n                }\\n            }\\n        \\n            // put all the elements in the cur column as 0 of the copy\\n            for( int k=0; k<n; k++){\\n                temp[k][i]=0;\\n            }\\n\\n            fn(temp, n, m,i+1, cols-1);\\n\\n        }\\n    }\\n\\n    // count the number of covered rows\\n    int countRows( int[][] mat, int n, int m){\\n\\n        int rows= 0;\\n\\n        for( int i=0; i<n; i++){\\n\\n            boolean ones=false;\\n            for( int j=0; j<m;j++){\\n                if( mat[i][j]==1){\\n                    ones=true;\\n                    break;\\n                }\\n            }\\n            if( ones==false) rows++;\\n        }\\n        return rows;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   //2397. Maximum Rows Covered by Columns\\n    \\n    // global var to store our ans\\n    int ans=0;\\n\\n    public int maximumRows(int[][] mat, int cols) {\\n        \\n        fn( mat,mat.length, mat[0].length,0,cols);\\n        \\n        return ans;\\n    }\\n\\n    void fn( int[][] mat, int n, int m, int i, int cols){\\n        \\n        // if we are out of columns to select or no more columns to select then we check if we have found a new ans and return\\n        if( cols==0 || i==m){\\n            ans= Math.max( ans, countRows(mat, n, m));\\n        }\\n        else{\\n\\n            // either u don\\'t include the column or u include the column\\n            \\n            // u don\\'t include the current column\\n            fn( mat, n, m,i+1,cols);\\n            \\n            // include the current column\\n            \\n            // create a copy of the matrix\\n            int[][] temp= new int[n][m];\\n            \\n             for( int ii=0; ii<n; ii++){\\n            for( int jj=0; jj<m;jj++){\\n                temp[ii][jj]= mat[ii][jj];\\n                }\\n            }\\n        \\n            // put all the elements in the cur column as 0 of the copy\\n            for( int k=0; k<n; k++){\\n                temp[k][i]=0;\\n            }\\n\\n            fn(temp, n, m,i+1, cols-1);\\n\\n        }\\n    }\\n\\n    // count the number of covered rows\\n    int countRows( int[][] mat, int n, int m){\\n\\n        int rows= 0;\\n\\n        for( int i=0; i<n; i++){\\n\\n            boolean ones=false;\\n            for( int j=0; j<m;j++){\\n                if( mat[i][j]==1){\\n                    ones=true;\\n                    break;\\n                }\\n            }\\n            if( ones==false) rows++;\\n        }\\n        return rows;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2536376,
                "title": "0ms-simple-bitmasking-solution-cpp-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols){\\n        int ans=0;        \\n        int m=size(mat),n=size(mat[0]);\\n\\t\\t//vector for storing bitmasks of every row\\n        vector<int> v(m);\\n\\t\\t//iterating through the matrix to create bitmasks\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                v[i]<<=1,v[i]|=mat[i][j];\\n\\t\\t//Iterating through possible set of columns to cover\\n        for(int i=1;i<(1<<n);i++){\\n\\t\\t\\t//counting bits in current set so that only max coverage sets are checked\\n            if(__builtin_popcount(i)!=cols)continue;\\n\\t\\t\\t//counting number of rows covered\\n            int cur=0;\\n            for(auto r:v){\\n\\t\\t\\t\\t//If current set is covering this column resultant \"&\" will be equal to our row bitmask\\n\\t\\t\\t\\tif((r&i)==r)cur++;\\n\\t\\t\\t}\\n            ans=max(cur,ans);\\n        }\\n        return ans;\\n    }\\n}; \\n```\\n\\nPls upvote if this helped to understand :).\\nAlso I am sorry for any mistakes, I am just starting to post rn.",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols){\\n        int ans=0;        \\n        int m=size(mat),n=size(mat[0]);\\n\\t\\t//vector for storing bitmasks of every row\\n        vector<int> v(m);\\n\\t\\t//iterating through the matrix to create bitmasks\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                v[i]<<=1,v[i]|=mat[i][j];\\n\\t\\t//Iterating through possible set of columns to cover\\n        for(int i=1;i<(1<<n);i++){\\n\\t\\t\\t//counting bits in current set so that only max coverage sets are checked\\n            if(__builtin_popcount(i)!=cols)continue;\\n\\t\\t\\t//counting number of rows covered\\n            int cur=0;\\n            for(auto r:v){\\n\\t\\t\\t\\t//If current set is covering this column resultant \"&\" will be equal to our row bitmask\\n\\t\\t\\t\\tif((r&i)==r)cur++;\\n\\t\\t\\t}\\n            ans=max(cur,ans);\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536041,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    int ans=0;\\n    public int maximumRows(int[][] mat, int cols) {\\n        solver(mat,cols,0);\\n        return ans;\\n    }\\n    private int solver(int [][]  mat,int cols,int i){\\n        if(cols==0 || i==mat[0].length){\\n            int c=cover(mat);\\n            ans=Math.max(ans,c);\\n            return c;\\n        }\\n        // not choosing the present column\\n        int x=solver(mat,cols,i+1);\\n        // selecting the present column \\n        int [][] cmat=new int[mat.length][mat[0].length];\\n        for(int k=0;k<cmat.length;k++){\\n            for(int j=0;j<cmat[0].length;j++){\\n                cmat[k][j]=mat[k][j];\\n            }\\n        }\\n        for(int j=0;j<cmat.length;j++){\\n            cmat[j][i]=0;\\n        }\\n        int y=solver(cmat,cols-1,i+1);\\n        return Math.max(x,y);\\n    }\\n    private int cover(int [][] mat){\\n        int count=0;\\n        for(int i=0;i<mat.length;i++){\\n            boolean flag=true;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]!=0){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag==true) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int maximumRows(int[][] mat, int cols) {\\n        solver(mat,cols,0);\\n        return ans;\\n    }\\n    private int solver(int [][]  mat,int cols,int i){\\n        if(cols==0 || i==mat[0].length){\\n            int c=cover(mat);\\n            ans=Math.max(ans,c);\\n            return c;\\n        }\\n        // not choosing the present column\\n        int x=solver(mat,cols,i+1);\\n        // selecting the present column \\n        int [][] cmat=new int[mat.length][mat[0].length];\\n        for(int k=0;k<cmat.length;k++){\\n            for(int j=0;j<cmat[0].length;j++){\\n                cmat[k][j]=mat[k][j];\\n            }\\n        }\\n        for(int j=0;j<cmat.length;j++){\\n            cmat[j][i]=0;\\n        }\\n        int y=solver(cmat,cols-1,i+1);\\n        return Math.max(x,y);\\n    }\\n    private int cover(int [][] mat){\\n        int count=0;\\n        for(int i=0;i<mat.length;i++){\\n            boolean flag=true;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]!=0){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag==true) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535505,
                "title": "short-non-bitmask-javascript-solution-with-comments",
                "content": "I dunno how to make a bit-mask so I just wrote a function to generate the permutations instead. same deal just slower\\n```\\nvar maximumRows = function(mat, cols) {\\n    const permsArr = []\\n    const perms = (i, arr) =>{\\n        if(arr.length === cols){\\n            permsArr.push(arr)\\n            return\\n        }\\n       for(let j = i; j < mat[0].length; j++){\\n           perms(j+1, [...arr, j])\\n       }\\n    }\\n    perms(0, [])// generate all the possible differnt col combinations of length cols\\n\\n    \\n    //for each of the permuations, generate the number of rows where all the 1\\'s are included in the selected columbs\\n    let max = 0\\n    for(const arr of permsArr){\\n        const count = mat.reduce((acc, row) => \\n            acc + row.every((el, i) => !el || arr.includes(i))\\n        , 0)\\n        if(count > max) max = count // set the max amount of fully included rows\\n    }\\n    return max",
                "solutionTags": [],
                "code": "I dunno how to make a bit-mask so I just wrote a function to generate the permutations instead. same deal just slower\\n```\\nvar maximumRows = function(mat, cols) {\\n    const permsArr = []\\n    const perms = (i, arr) =>{\\n        if(arr.length === cols){\\n            permsArr.push(arr)\\n            return\\n        }\\n       for(let j = i; j < mat[0].length; j++){\\n           perms(j+1, [...arr, j])\\n       }\\n    }\\n    perms(0, [])// generate all the possible differnt col combinations of length cols\\n\\n    \\n    //for each of the permuations, generate the number of rows where all the 1\\'s are included in the selected columbs\\n    let max = 0\\n    for(const arr of permsArr){\\n        const count = mat.reduce((acc, row) => \\n            acc + row.every((el, i) => !el || arr.includes(i))\\n        , 0)\\n        if(count > max) max = count // set the max amount of fully included rows\\n    }\\n    return max",
                "codeTag": "Unknown"
            },
            {
                "id": 2535331,
                "title": "java-backtrack-recursion-easy",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int maximumRows(int[][] mat, int cols) {\\n        \\n    \\n        int c = mat[0].length;\\n        for(int i =0; i < c; i++){\\n            helper(mat,cols,i);\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    private void helper(int[][] mat,int cols,int curr){\\n        \\n        int r = mat.length;\\n        int c = mat[0].length;\\n        \\n        if(cols == 0)return;\\n        \\n        if(curr >= c)return;\\n        \\n        int[] temp = new int[r];\\n        for(int i = 0; i < r; i++){\\n            temp[i] = mat[i][curr];\\n            mat[i][curr] = 0;\\n        }\\n        int count = 0;\\n        for(int i = 0; i < r; i++){\\n            boolean got = true;\\n            for(int j = 0; j < c; j++){\\n                if(mat[i][j] == 1){\\n                    got = false;\\n                    break;\\n                }\\n            }\\n            if(got)count++;\\n        }\\n        ans = Math.max(ans,count);\\n        \\n        for(int i = curr+1; i < c; i++){\\n            helper(mat,cols-1,i);\\n        }\\n        \\n        for(int i = 0; i < r; i++){\\n            mat[i][curr] = temp[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int maximumRows(int[][] mat, int cols) {\\n        \\n    \\n        int c = mat[0].length;\\n        for(int i =0; i < c; i++){\\n            helper(mat,cols,i);\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    private void helper(int[][] mat,int cols,int curr){\\n        \\n        int r = mat.length;\\n        int c = mat[0].length;\\n        \\n        if(cols == 0)return;\\n        \\n        if(curr >= c)return;\\n        \\n        int[] temp = new int[r];\\n        for(int i = 0; i < r; i++){\\n            temp[i] = mat[i][curr];\\n            mat[i][curr] = 0;\\n        }\\n        int count = 0;\\n        for(int i = 0; i < r; i++){\\n            boolean got = true;\\n            for(int j = 0; j < c; j++){\\n                if(mat[i][j] == 1){\\n                    got = false;\\n                    break;\\n                }\\n            }\\n            if(got)count++;\\n        }\\n        ans = Math.max(ans,count);\\n        \\n        for(int i = curr+1; i < c; i++){\\n            helper(mat,cols-1,i);\\n        }\\n        \\n        for(int i = 0; i < r; i++){\\n            mat[i][curr] = temp[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535322,
                "title": "c-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) \\n    {\\n        int m=mat.size(),n=mat[0].size();\\n        int ans=0;\\n        for(int i=1;i<(1<<n);i++)\\n        {\\n            vector<int>have(n,0);\\n            for(int j=0;j<n;j++)have[j]=((i>>j)&1);\\n            int cnt=0;\\n            for(auto &x:have)cnt+=x;\\n            if(cnt!=cols)continue;\\n            int cur=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                bool valid=true;\\n                for(int k=0;k<n;k++)\\n                    if((mat[j][k]==1)&&(have[k]!=1))\\n                        valid=false;\\n                cur+=valid;\\n            }\\n            ans=max(ans,cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRows(vector<vector<int>>& mat, int cols) \\n    {\\n        int m=mat.size(),n=mat[0].size();\\n        int ans=0;\\n        for(int i=1;i<(1<<n);i++)\\n        {\\n            vector<int>have(n,0);\\n            for(int j=0;j<n;j++)have[j]=((i>>j)&1);\\n            int cnt=0;\\n            for(auto &x:have)cnt+=x;\\n            if(cnt!=cols)continue;\\n            int cur=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                bool valid=true;\\n                for(int k=0;k<n;k++)\\n                    if((mat[j][k]==1)&&(have[k]!=1))\\n                        valid=false;\\n                cur+=valid;\\n            }\\n            ans=max(ans,cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535010,
                "title": "check-all-possible-combinations",
                "content": "The Intuition behind the problem after seeing the constraints is doing simple brute force.\\n\\nGenerate all the subsequences of the given length cols.\\n\\nCheck all the subsequences and calculate the maximum.\\n\\nSharing my 100% faster solution.  :)\\n\\n![image](https://assets.leetcode.com/users/images/c78ff3a6-1aca-48e7-8a61-cf9f48bcce2a_1662387196.4771898.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(int i , int n , int cols , vector<int> &a , vector<vector<int>> &subsequences){\\n        if(i == n){\\n            if(a.size() == cols){\\n                subsequences.push_back(a);\\n            }\\n            return;\\n        }\\n        a.push_back(i);\\n        solve(i + 1 , n , cols , a , subsequences);\\n        a.pop_back();\\n        solve(i + 1 , n , cols , a , subsequences);\\n    }\\n    int rows_covered(vector<vector<int>> &v , vector<int> &idxs){\\n        int ans{};\\n        unordered_map<int , int> m;\\n        for(auto x : idxs)\\n            ++m[x];\\n        for(int i{}; i < v.size(); ++i){\\n            bool f{1};\\n            for(int j{}; j < v[0].size(); ++j){\\n                if(v[i][j] == 1 and m.find(j) == m.end()){\\n                    f = 0;\\n                    break;\\n                }\\n            }\\n            if(f)\\n                ++ans;\\n        }\\n        return ans;\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int ans{};\\n        vector<int> a;\\n        vector<vector<int>> subsequences;\\n        solve(0 , mat[0].size() , cols , a , subsequences);\\n        for(auto v : subsequences){\\n            ans = max(ans , rows_covered(mat , v));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nDo UPVOTE !!! if it helps you :)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i , int n , int cols , vector<int> &a , vector<vector<int>> &subsequences){\\n        if(i == n){\\n            if(a.size() == cols){\\n                subsequences.push_back(a);\\n            }\\n            return;\\n        }\\n        a.push_back(i);\\n        solve(i + 1 , n , cols , a , subsequences);\\n        a.pop_back();\\n        solve(i + 1 , n , cols , a , subsequences);\\n    }\\n    int rows_covered(vector<vector<int>> &v , vector<int> &idxs){\\n        int ans{};\\n        unordered_map<int , int> m;\\n        for(auto x : idxs)\\n            ++m[x];\\n        for(int i{}; i < v.size(); ++i){\\n            bool f{1};\\n            for(int j{}; j < v[0].size(); ++j){\\n                if(v[i][j] == 1 and m.find(j) == m.end()){\\n                    f = 0;\\n                    break;\\n                }\\n            }\\n            if(f)\\n                ++ans;\\n        }\\n        return ans;\\n    }\\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        int ans{};\\n        vector<int> a;\\n        vector<vector<int>> subsequences;\\n        solve(0 , mat[0].size() , cols , a , subsequences);\\n        for(auto v : subsequences){\\n            ans = max(ans , rows_covered(mat , v));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1656998,
                "content": [
                    {
                        "username": "Alex_Gr",
                        "content": "*Reads the description*... Wait... what??"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "0icy",
                        "content": "*Reads the description...* Wait... what??"
                    },
                    {
                        "username": "joshiishaan",
                        "content": "Reads the description... Wait... what??\\nReads the discussions... \"Wait... what??\"\\n\\n"
                    },
                    {
                        "username": "ALZ113",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "Isha307",
                        "content": "Worst description ever :ded:"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "yakode",
                        "content": "If all \\'1\\' in a row is chosen, the row is covered.\\nWe can choose numSelect columns."
                    }
                ]
            },
            {
                "id": 1889573,
                "content": [
                    {
                        "username": "Alex_Gr",
                        "content": "*Reads the description*... Wait... what??"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "0icy",
                        "content": "*Reads the description...* Wait... what??"
                    },
                    {
                        "username": "joshiishaan",
                        "content": "Reads the description... Wait... what??\\nReads the discussions... \"Wait... what??\"\\n\\n"
                    },
                    {
                        "username": "ALZ113",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "Isha307",
                        "content": "Worst description ever :ded:"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "yakode",
                        "content": "If all \\'1\\' in a row is chosen, the row is covered.\\nWe can choose numSelect columns."
                    }
                ]
            },
            {
                "id": 1769165,
                "content": [
                    {
                        "username": "Alex_Gr",
                        "content": "*Reads the description*... Wait... what??"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "0icy",
                        "content": "*Reads the description...* Wait... what??"
                    },
                    {
                        "username": "joshiishaan",
                        "content": "Reads the description... Wait... what??\\nReads the discussions... \"Wait... what??\"\\n\\n"
                    },
                    {
                        "username": "ALZ113",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "Isha307",
                        "content": "Worst description ever :ded:"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "yakode",
                        "content": "If all \\'1\\' in a row is chosen, the row is covered.\\nWe can choose numSelect columns."
                    }
                ]
            },
            {
                "id": 2008030,
                "content": [
                    {
                        "username": "Alex_Gr",
                        "content": "*Reads the description*... Wait... what??"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "0icy",
                        "content": "*Reads the description...* Wait... what??"
                    },
                    {
                        "username": "joshiishaan",
                        "content": "Reads the description... Wait... what??\\nReads the discussions... \"Wait... what??\"\\n\\n"
                    },
                    {
                        "username": "ALZ113",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "Isha307",
                        "content": "Worst description ever :ded:"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "yakode",
                        "content": "If all \\'1\\' in a row is chosen, the row is covered.\\nWe can choose numSelect columns."
                    }
                ]
            },
            {
                "id": 1974372,
                "content": [
                    {
                        "username": "Alex_Gr",
                        "content": "*Reads the description*... Wait... what??"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "0icy",
                        "content": "*Reads the description...* Wait... what??"
                    },
                    {
                        "username": "joshiishaan",
                        "content": "Reads the description... Wait... what??\\nReads the discussions... \"Wait... what??\"\\n\\n"
                    },
                    {
                        "username": "ALZ113",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "Isha307",
                        "content": "Worst description ever :ded:"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "yakode",
                        "content": "If all \\'1\\' in a row is chosen, the row is covered.\\nWe can choose numSelect columns."
                    }
                ]
            },
            {
                "id": 2040144,
                "content": [
                    {
                        "username": "Alex_Gr",
                        "content": "*Reads the description*... Wait... what??"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "0icy",
                        "content": "*Reads the description...* Wait... what??"
                    },
                    {
                        "username": "joshiishaan",
                        "content": "Reads the description... Wait... what??\\nReads the discussions... \"Wait... what??\"\\n\\n"
                    },
                    {
                        "username": "ALZ113",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "Isha307",
                        "content": "Worst description ever :ded:"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "yakode",
                        "content": "If all \\'1\\' in a row is chosen, the row is covered.\\nWe can choose numSelect columns."
                    }
                ]
            },
            {
                "id": 2034197,
                "content": [
                    {
                        "username": "Alex_Gr",
                        "content": "*Reads the description*... Wait... what??"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "0icy",
                        "content": "*Reads the description...* Wait... what??"
                    },
                    {
                        "username": "joshiishaan",
                        "content": "Reads the description... Wait... what??\\nReads the discussions... \"Wait... what??\"\\n\\n"
                    },
                    {
                        "username": "ALZ113",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "Isha307",
                        "content": "Worst description ever :ded:"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "yakode",
                        "content": "If all \\'1\\' in a row is chosen, the row is covered.\\nWe can choose numSelect columns."
                    }
                ]
            },
            {
                "id": 1981650,
                "content": [
                    {
                        "username": "Alex_Gr",
                        "content": "*Reads the description*... Wait... what??"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "0icy",
                        "content": "*Reads the description...* Wait... what??"
                    },
                    {
                        "username": "joshiishaan",
                        "content": "Reads the description... Wait... what??\\nReads the discussions... \"Wait... what??\"\\n\\n"
                    },
                    {
                        "username": "ALZ113",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "Isha307",
                        "content": "Worst description ever :ded:"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Reads the description... Wait... what??"
                    },
                    {
                        "username": "yakode",
                        "content": "If all \\'1\\' in a row is chosen, the row is covered.\\nWe can choose numSelect columns."
                    }
                ]
            }
        ]
    }
]