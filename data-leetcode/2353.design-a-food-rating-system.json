[
    {
        "title": "Equal Row and Column Pairs",
        "question_content": "Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.\nA row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).\n&nbsp;\nExample 1:\n\nInput: grid = [[3,2,1],[1,7,6],[2,7,7]]\nOutput: 1\nExplanation: There is 1 equal row and column pair:\n- (Row 2, Column 1): [2,7,7]\n\nExample 2:\n\nInput: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]\nOutput: 3\nExplanation: There are 3 equal row and column pairs:\n- (Row 0, Column 0): [3,1,2,2]\n- (Row 2, Column 2): [2,4,2,2]\n- (Row 3, Column 2): [2,4,2,2]\n\n&nbsp;\nConstraints:\n\n\tn == grid.length == grid[i].length\n\t1 <= n <= 200\n\t1 <= grid[i][j] <= 105",
        "solutions": [
            {
                "id": 2324872,
                "title": "100-fast-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        // Number to store the count of equal pairs.\\n        int ans = 0;\\n        map<vector<int>, int> mp;\\n        // Storing each row int he map\\n        for (int i = 0; i < grid.size(); i++)\\n            mp[grid[i]]++;\\n        \\n        for (int i = 0; i < grid[0].size(); i++)\\n        {\\n            vector<int> v;\\n            // extracting column in a vector.\\n            for (int j = 0; j < grid.size(); j++)\\n                v.push_back(grid[j][i]);\\n            // Add the number of times that column appeared as a row.\\n            ans += mp[v];\\n        }\\n        // Return the number of count\\n        return ans;\\n    }\\n};\\n```\\nHope you like it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        // Number to store the count of equal pairs.\\n        int ans = 0;\\n        map<vector<int>, int> mp;\\n        // Storing each row int he map\\n        for (int i = 0; i < grid.size(); i++)\\n            mp[grid[i]]++;\\n        \\n        for (int i = 0; i < grid[0].size(); i++)\\n        {\\n            vector<int> v;\\n            // extracting column in a vector.\\n            for (int j = 0; j < grid.size(); j++)\\n                v.push_back(grid[j][i]);\\n            // Add the number of times that column appeared as a row.\\n            ans += mp[v];\\n        }\\n        // Return the number of count\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324688,
                "title": "cubic-432-vs-three-map-95-vs-trie-137",
                "content": "`n` is small, so a Cubic solution should do for the contest.\\n\\nLater, I solved this problem using the Trie and Tree Map approaches, which are Quadratic.\\n\\n#### Cubic (432 ms)\\n**C++**\\n```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    for (int i = 0; i < n; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int k = 0;\\n            while (k < n && g[i][k] == g[k][j])\\n                ++k;\\n            res += k == n;\\n        }\\n    return res;\\n}\\n```\\n\\n#### Three Map (95 ms)\\nNote that we need to use a three map (ordered map) instead of hash map. For a vector, the three map stops matching when bumps into a discrepancy, while hash map process all elements first to compute a hash.\\n\\nNote how we optimize the memory usage here. To check if a row exists in map, we are using existing rows. That way, we do not build an entire vector only to find out we have a mismatch on the first element.\\n\\n**C++**\\n```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    map<vector<int>, int> m;\\n    for (int j = 0; j < n; ++j) {\\n        vector<int> col;\\n        for (int i = 0; i < n; ++i)\\n            col.push_back(g[i][j]);\\n        auto it = m.find(col);\\n        if (it == end(m))\\n            m.emplace(move(col), 1);\\n        else\\n            ++it->second;\\n    }\\n    for (const auto &row : g)\\n        res += m[row];\\n    return res;\\n}\\n```\\n\\n#### Trie (137 ms)\\nThis is similar to the Three Map solution above, but here we build it ourselves.\\n\\nFirst, we populate Trie for columns, and then count matching rows.\\n\\n**C++**\\n```cpp\\nstruct Trie {\\n    unordered_map<int, Trie*> m;\\n    int cnt = 0;\\n    int insert(vector<vector<int>>& g, int i, int j, bool row) {\\n        auto node = this;\\n        for (; max(i, j) < g.size(); i += row, j += !row) {\\n            auto it = node->m.find(g[i][j]);\\n            if (it == end(node->m)) {\\n                if (row)\\n                    return 0; // no match.\\n                it = node->m.insert({g[i][j], new Trie()}).first;\\n            }\\n            node = it->second;\\n        }\\n        return node->cnt += !row;\\n    }\\n};\\nint equalPairs(vector<vector<int>>& g) {\\n    Trie t;\\n    int res = 0;\\n    for (int i = 0; i < g.size(); ++i)\\n        t.insert(g, i, 0, false);\\n    for (int j = 0; j < g.size(); ++j)\\n        res += t.insert(g, 0, j, true);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    for (int i = 0; i < n; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int k = 0;\\n            while (k < n && g[i][k] == g[k][j])\\n                ++k;\\n            res += k == n;\\n        }\\n    return res;\\n}\\n```\n```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    map<vector<int>, int> m;\\n    for (int j = 0; j < n; ++j) {\\n        vector<int> col;\\n        for (int i = 0; i < n; ++i)\\n            col.push_back(g[i][j]);\\n        auto it = m.find(col);\\n        if (it == end(m))\\n            m.emplace(move(col), 1);\\n        else\\n            ++it->second;\\n    }\\n    for (const auto &row : g)\\n        res += m[row];\\n    return res;\\n}\\n```\n```cpp\\nstruct Trie {\\n    unordered_map<int, Trie*> m;\\n    int cnt = 0;\\n    int insert(vector<vector<int>>& g, int i, int j, bool row) {\\n        auto node = this;\\n        for (; max(i, j) < g.size(); i += row, j += !row) {\\n            auto it = node->m.find(g[i][j]);\\n            if (it == end(node->m)) {\\n                if (row)\\n                    return 0; // no match.\\n                it = node->m.insert({g[i][j], new Trie()}).first;\\n            }\\n            node = it->second;\\n        }\\n        return node->cnt += !row;\\n    }\\n};\\nint equalPairs(vector<vector<int>>& g) {\\n    Trie t;\\n    int res = 0;\\n    for (int i = 0; i < g.size(); ++i)\\n        t.insert(g, i, 0, false);\\n    for (int j = 0; j < g.size(); ++j)\\n        res += t.insert(g, 0, j, true);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3630812,
                "title": "java-c-python-easy-to-understand",
                "content": "# Guys Please Vote up )):\\nTo solve this problem, we can iterate through each row and column of the grid and check if they contain the same elements in the same order. If they do, we increment a counter. Finally, we return the value of the counter.\\n\\n# Approach\\nHere\\'s the approach to solve the problem:\\n\\n    Initialize a variable count to 0 to keep track of the number of equal row-column pairs.\\n    Iterate through each row ri from 0 to n-1:\\n    a. Iterate through each column cj from 0 to n-1:\\n    i. Check if the row ri and column cj are equal by comparing the corresponding elements.\\n    ii. If they are equal, increment the count variable by 1.\\n    Return the value of count.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(n^3) because we have three nested loops: one for iterating through rows, one for iterating through columns, and one for comparing the elements. \\n\\n- Space complexity:\\nThe space complexity is O(1) since we are using a constant amount of extra space.\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int pair=0;\\n        int temp=0;\\n        int row=0;\\n        while(temp<=grid.length-1)\\n        {\\n            HashMap<Integer,Integer> map=new HashMap<>();\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                map.put(j,grid[row][j]);\\n            }\\n            for(int i=0;i<grid.length;i++)\\n            {\\n                int curr=0;\\n                for(int k=0;k<grid.length;k++)\\n                {\\n                    if(map.get(k)!=grid[k][i])\\n                    {\\n                        curr=0;\\n                        break;\\n                    }\\n                    else\\n                        curr=1;\\n                }\\n                pair+=curr;\\n            }\\n            row++;\\n            temp++;\\n        }\\n        return pair;\\n    }\\n}\\n```\\n# C++ Code\\n```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Python3 Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int pair=0;\\n        int temp=0;\\n        int row=0;\\n        while(temp<=grid.length-1)\\n        {\\n            HashMap<Integer,Integer> map=new HashMap<>();\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                map.put(j,grid[row][j]);\\n            }\\n            for(int i=0;i<grid.length;i++)\\n            {\\n                int curr=0;\\n                for(int k=0;k<grid.length;k++)\\n                {\\n                    if(map.get(k)!=grid[k][i])\\n                    {\\n                        curr=0;\\n                        break;\\n                    }\\n                    else\\n                        curr=1;\\n                }\\n                pair+=curr;\\n            }\\n            row++;\\n            temp++;\\n        }\\n        return pair;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328910,
                "title": "python3-3-lines-transpose-ctr-w-explanation-t-m-97-100",
                "content": "\\nConsider this grid for an example:\\n```\\n           grid = [[1,2,1,9]\\n                   [2,8,9,2]\\n                   [1,2,1,9]\\n                   [9,2,6,3]]\\n```    \\nHere\\'s the plan:\\n- Determine`tpse`, the transpose of`grid`(using`zip(*grid)`):\\n```\\n           tspe = [[1,2,1,9] \\n                   [2,8,2,2]\\n                   [1,9,1,6]\\n                   [9,2,9,3]]\\n```\\n- The problem now is to determine the pairs of identical rows, one row in `tpse`and the other in` grid`. We hash`grid`and`tspe`:\\n```\\n          Counter(tuple(grid)):\\n               {(1,2,1,9): 2, (2,8,9,2): 1, (9,2,6,3): 1}\\n \\n           Counter(zip(*grid)):\\n            {(1,2,1,9): 1, (2,8,2,2): 1, (1,9,1,6): 1, (9,2,9,3): 1}\\n```            \\n   \\u2022 Finally, we determine the number of pairs:\\n```\\n       (1,2,1,9): 2 and (1,2,1,9): 1    => 2x1 = 2\\n```\\nHere\\'s the code:\\n```\\nclass Solution:                                \\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        tpse = Counter(zip(*grid))                  # <-- determine the transpose\\n                                                    #     and hash the rows\\n\\n        grid = Counter(map(tuple,grid))             # <-- hash the rows of grid. (Note the tuple-map, so\\n                                                    #     we can compare apples w/ apples in next step.)\\n\\n        return  sum(tpse[t]*grid[t] for t in tpse)  # <-- compute the number of identical pairs\\n```\\n[https://leetcode.com/problems/equal-row-and-column-pairs/submissions/939711156/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*), in which *N* ~ `len(grid)`.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n           grid = [[1,2,1,9]\\n                   [2,8,9,2]\\n                   [1,2,1,9]\\n                   [9,2,6,3]]\\n```\n```\\n           tspe = [[1,2,1,9] \\n                   [2,8,2,2]\\n                   [1,9,1,6]\\n                   [9,2,9,3]]\\n```\n```\\n          Counter(tuple(grid)):\\n               {(1,2,1,9): 2, (2,8,9,2): 1, (9,2,6,3): 1}\\n \\n           Counter(zip(*grid)):\\n            {(1,2,1,9): 1, (2,8,2,2): 1, (1,9,1,6): 1, (9,2,9,3): 1}\\n```\n```\\n       (1,2,1,9): 2 and (1,2,1,9): 1    => 2x1 = 2\\n```\n```\\nclass Solution:                                \\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        tpse = Counter(zip(*grid))                  # <-- determine the transpose\\n                                                    #     and hash the rows\\n\\n        grid = Counter(map(tuple,grid))             # <-- hash the rows of grid. (Note the tuple-map, so\\n                                                    #     we can compare apples w/ apples in next step.)\\n\\n        return  sum(tpse[t]*grid[t] for t in tpse)  # <-- compute the number of identical pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324750,
                "title": "java-python-3-o-n-2-codes-w-brief-explanation-and-analysis",
                "content": "Count row hash values then traverse col hash values to count the required pairs.\\n\\n----\\n\\nConvert rows and cols into strings, then use them as hash values.\\n\\nNote: \\n`cnt.merge(Arrays.toString(row), 1, Integer::sum);` is same as \\n```java\\nString key = Arrays.toString(row);\\ncnt.put(key, 1 + cnt.getOrDefault(key, 0));\\n```\\n\\n`Arrays.toString(row)/value` is `key/value` binding of HashMap `cnt`;\\n\\n`Integer::sum` here means that the method `sum` of `Integer` is used to increase by `1` the `value` corresponding to `key`: `Arrays.toString(row)`. The default `value` is `0` in case the `key` is absent.\\n\\n```java\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> cnt = new HashMap<>();\\n        for (int[] row : grid) {\\n            cnt.merge(Arrays.toString(row), 1, Integer::sum);\\n        }\\n        int pairs = 0;\\n        for (int c = 0, n = grid.length; c < n; ++c) {\\n            int[] col = new int[n];\\n            for (int r = 0; r < n; ++r) {\\n                col[r] = grid[r][c];\\n            }\\n            pairs += cnt.getOrDefault(Arrays.toString(col), 0);\\n        }\\n        return pairs;\\n    }\\n```\\n\\n----\\n\\nConvert the rows and cols into tuples, then use them as hash values.\\n\\n```python\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        pairs = 0\\n        cnt = Counter(tuple(row) for row in grid)\\n        for tpl in zip(*grid):\\n            pairs += cnt[tpl]\\n        return pairs\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n ^ 2)`, where `n = grid.length`.\\n\\n----\\n\\n**Q & A**\\n\\nQ: Can someone explain why do we need to convert it to tuple in python code ?\\nA: List is unhashable! can\\'t use as Key in dict and can\\'t store in set as value.\\nso... we need to convert it to tuple. -- Credit to **@I_and_Me**.\\n\\n**End of Q & A**",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\nString key = Arrays.toString(row);\\ncnt.put(key, 1 + cnt.getOrDefault(key, 0));\\n```\n```java\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> cnt = new HashMap<>();\\n        for (int[] row : grid) {\\n            cnt.merge(Arrays.toString(row), 1, Integer::sum);\\n        }\\n        int pairs = 0;\\n        for (int c = 0, n = grid.length; c < n; ++c) {\\n            int[] col = new int[n];\\n            for (int r = 0; r < n; ++r) {\\n                col[r] = grid[r][c];\\n            }\\n            pairs += cnt.getOrDefault(Arrays.toString(col), 0);\\n        }\\n        return pairs;\\n    }\\n```\n```python\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        pairs = 0\\n        cnt = Counter(tuple(row) for row in grid)\\n        for tpl in zip(*grid):\\n            pairs += cnt[tpl]\\n        return pairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3631209,
                "title": "c-easy-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int r=0;\\n        vector<vector<int>>c=v;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(v[i][j],v[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(v[i]==c[j])r++;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/d3301764-7132-4285-9a92-9f6415c050da_1686626781.0602562.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int r=0;\\n        vector<vector<int>>c=v;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(v[i][j],v[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(v[i]==c[j])r++;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325191,
                "title": "java-two-pass-clean-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] g) {\\n\\t\\tint n = g.length;\\n        int res = 0;\\n\\t\\t//convert the numbers in each row to a single string\\n        Map<String, Integer> sToFreq = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int j = 0; j < n; j++) { \\n                sb.append(g[i][j]);\\n                sb.append(\"+\");\\n            }\\n            String s = sb.toString();\\n            sToFreq.put(s, sToFreq.getOrDefault(s, 0) + 1);\\n        }\\n        \\n\\t\\t//convert the numbers in each col to string and find the matches\\n        for (int j = 0; j < n; j++) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 0; i < n; i++) { \\n                sb.append(g[i][j]);\\n                sb.append(\"+\");\\n            }\\n            String s = sb.toString();\\n            if (sToFreq.containsKey(s)) {\\n                res += sToFreq.get(s);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int equalPairs(int[][] g) {\\n\\t\\tint n = g.length;\\n        int res = 0;\\n\\t\\t//convert the numbers in each row to a single string\\n        Map<String, Integer> sToFreq = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int j = 0; j < n; j++) { \\n                sb.append(g[i][j]);\\n                sb.append(\"+\");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3630977,
                "title": "c-map-fast-solution-w-explanation",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^2*logn)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> counter;\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for (vector<int> row : grid) {\\n            counter[row] += 1;\\n        }\\n        for (int i = 0; i < row; i++) {\\n            vector<int> column_list = {};\\n            for (int j = 0; j < col; j++) {\\n                column_list.push_back(grid[j][i]);\\n            }\\n            ans += counter[column_list];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![ex1.jpg](https://assets.leetcode.com/users/images/41456c5f-1cde-4366-a7f6-74aec6f0f623_1686620000.3283463.jpeg)\\n# Step by Step\\n```\\nmap<vector<int>, int> counter;\\nfor (vector<int> row : grid) {\\n    counter[row] += 1;\\n}\\n```\\n- We use this to hold the value of each row as a key. To see if a column list is equal to the row key. Since we are comparing rows to columns only one needs to be the key\\n- Example of this for loop\\n    - counter[{3,2,1}] = 1;\\n    - counter[{1,7,6}] = 1;\\n    - counter[{2,7,7}] = 1;\\n\\n```        \\nfor (int i = 0; i < row; i++) {\\n    vector<int> column_list = {};\\n    for (int j = 0; j < col; j++) {\\n        column_list.push_back(grid[j][i]);\\n    }\\n    ans += counter[column_list];\\n}\\n```\\n- This is getting each list of column values. Since we do not have an array list of column values like row values, we need to create the list ourselves.\\n- Example\\n    - column_list = {3,1,2};\\n    - column_list = {2,7,7};\\n    - column_list = {1,6,7};\\n```\\nans += counter[column_list];\\n```\\n- Now take the values we just got and see if it matches the row keys we created.\\n- Example\\n    - counter[{3,1,2}] = 0;\\n    - counter[{2,7,7}] = 1;\\n    - counter[{1,6,7}] = 0;\\n- ans = 1\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> counter;\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for (vector<int> row : grid) {\\n            counter[row] += 1;\\n        }\\n        for (int i = 0; i < row; i++) {\\n            vector<int> column_list = {};\\n            for (int j = 0; j < col; j++) {\\n                column_list.push_back(grid[j][i]);\\n            }\\n            ans += counter[column_list];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nmap<vector<int>, int> counter;\\nfor (vector<int> row : grid) {\\n    counter[row] += 1;\\n}\\n```\n```        \\nfor (int i = 0; i < row; i++) {\\n    vector<int> column_list = {};\\n    for (int j = 0; j < col; j++) {\\n        column_list.push_back(grid[j][i]);\\n    }\\n    ans += counter[column_list];\\n}\\n```\n```\\nans += counter[column_list];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781858,
                "title": "c-5-or-so-different-approaches-fast-54ms-100",
                "content": "<!---\\nTitle: C++ || a few different approaches with some variants || fast (54ms, 100%)\\nProblem: 2352\\nURL: \\n-->\\n\\nI had quite some fun solving this problem in a few different ways and trying some variants for different approaches. Please let me know if you have another idea or a suggestion for one of the approaches below.\\n\\n**TODO(heder): The complexity analysis isn\\'t complete for all of the approaches below.**\\n# Approach 1: nested loops (490ms)\\n\\nThe first approach is to just check each row against each column, which leads to $$O(n^3)$$ runtime.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t r = 0; r < n; ++r) {\\n            for (size_t c = 0; c < n; ++c) {\\n                bool equal = true;\\n                for (size_t i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        equal = false;\\n                        break;\\n                    }\\n                }\\n                ans += equal;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n@harsh_negi_07 posted a [neat variant of this idea](https://leetcode.com/problems/equal-row-and-column-pairs/discuss/2781858/c-5-or-so-different-approaches-fast-54ms-100) which is creating the column vectors and then just using ```std::count``` to compare against the rows of the ```grid```.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            ans += count(begin(grid), end(grid), column);\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n^3)$$\\n  * Space Complexity: $$O(1)$$\\n\\n\\n# Approach 2: map of vectors (82ms)\\n\\nFirst we count the frequency of each row vector. Then we build a column vector and check in map how many matching row vectors we have got.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\nInstead of\\n\\n```cpp\\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n```\\n\\nwe could just do\\n\\n```cpp\\n            ans += m[column];\\n```\\n\\nwhich would be more compact code, however we would inserting the column vectors into the map as well which is unnecessary.\\n\\n**Complexity Analysis**\\n  * Time Complexity: TODO(heder): I need to think about this a bit more. We are inserting $$n$$ vectors into map and then we are looking up $$n$$ vectors in this map, but how expensive are these inserts and lookups?\\n  * Space Complexity: $$O(n^2)$$ for the map of vectors. We have up to $$n$$ row vectors and each of them is $$n$$ long. The column vector requires only $$n$$ space.\\n\\n\\n# Approach 3: hash map of std::string_view (54ms, 100%)\\n\\nFor approach 2 you are maybe wondering: Could we use ```std::unordered_map``` instead of  ```std::map```? Well, not out of the box, because the STL doesn\\'t define a hash function for a ```vector<int>```. Now what? One way to work around this is to treat the underlying raw data as the content of a ```std::string_view```. For ```std::string_view``` the STL defines a hash function. A ```std::vector``` guarantees that the underlying storage is contiguous so only the necessary ```reinterpret_cast<>``` makes it a big ugly, but other than that this should all be safe and sound and it\\'s fast.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        const size_t bytes = n * sizeof(int);\\n        unordered_map<string_view, int> m;\\n        for (const vector<int>& row : grid)\\n            ++m[string_view(reinterpret_cast<const char *>(row.data()), bytes)];\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(string_view(reinterpret_cast<const char *>(column.data()), bytes));\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: TODO(heder): Think about this some more. $$O(n^2)$$ because we need to compute the hash for all rows and each of them is $$O(n)$$ long. The insert into the hash map should be $$O(1)$$, but if we have a hash collision we need to compare up to $$n$$ integers. Similar for the columns.\\n  * Space Complexity: $$O(n)$$ for the hash map. This isn\\'t $$O(n^2)$$ as we are only allocating a few bytes per row for the ```string_view```.\\n\\n\\n# Approach 4: hash map of vector with custom hash function (70ms)\\n\\nAnother approach to use a ```std::unordered_map``` here is to provide a custom hash function for ```std::vector<int>```. With the following setup code:\\n\\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n\\ntemplate<class T>\\nstruct std::hash<const vector<T>>\\n{\\n    std::size_t operator()(const vector<T>& v) const noexcept\\n    {\\n        std::size_t hash = size(v);\\n        for (const T& a : v) hash_combine(hash, a);\\n        return hash;\\n    }\\n};\\n```\\n\\nWe can use the same code for approach 2, but using ```std::unordered_map``` instead of ```std::map```.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        unordered_map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\n### Approach 5: only compute hashes (not 100% correct) (70ms)\\n\\n**WARNING:** This approach passes all test cases, but is not 100% correct as it doesn\\'t handle hash collisions.\\n\\nWe use the same ```hash_combine``` from the boost library:\\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n```\\n\\n... and then:\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        // NB. This approach is not 100% correct, as it doesn\\'t handle hash collisions.\\n        const size_t n = size(grid);\\n        unordered_map<size_t, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) {\\n            size_t hash = 0;\\n            for (int a : row) hash_combine(hash, a);\\n            ++m[hash];\\n        }\\n        int ans = 0;\\n        // Compute the hash for the column vector.\\n        for (size_t c = 0; c < n; ++c) {\\n            size_t hash = 0;\\n            for (size_t r = 0; r < n; ++r)\\n                hash_combine(hash, grid[r][c]);\\n            \\n            auto it = m.find(hash);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\nIt\\'s basically the same as approach 3.\\n\\n# Approach 6: trie\\n\\nI saw a solution using a trie instead of a (hash) map. Time permitting I\\'ll give that a trie^Wtry too.\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t r = 0; r < n; ++r) {\\n            for (size_t c = 0; c < n; ++c) {\\n                bool equal = true;\\n                for (size_t i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        equal = false;\\n                        break;\\n                    }\\n                }\\n                ans += equal;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```std::count```\n```grid```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            ans += count(begin(grid), end(grid), column);\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n```\n```cpp\\n            ans += m[column];\\n```\n```std::unordered_map```\n```std::map```\n```vector<int>```\n```std::string_view```\n```std::string_view```\n```std::vector```\n```reinterpret_cast<>```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        const size_t bytes = n * sizeof(int);\\n        unordered_map<string_view, int> m;\\n        for (const vector<int>& row : grid)\\n            ++m[string_view(reinterpret_cast<const char *>(row.data()), bytes)];\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(string_view(reinterpret_cast<const char *>(column.data()), bytes));\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\n```string_view```\n```std::unordered_map```\n```std::vector<int>```\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n\\ntemplate<class T>\\nstruct std::hash<const vector<T>>\\n{\\n    std::size_t operator()(const vector<T>& v) const noexcept\\n    {\\n        std::size_t hash = size(v);\\n        for (const T& a : v) hash_combine(hash, a);\\n        return hash;\\n    }\\n};\\n```\n```std::unordered_map```\n```std::map```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        unordered_map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\n```hash_combine```\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        // NB. This approach is not 100% correct, as it doesn\\'t handle hash collisions.\\n        const size_t n = size(grid);\\n        unordered_map<size_t, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) {\\n            size_t hash = 0;\\n            for (int a : row) hash_combine(hash, a);\\n            ++m[hash];\\n        }\\n        int ans = 0;\\n        // Compute the hash for the column vector.\\n        for (size_t c = 0; c < n; ++c) {\\n            size_t hash = 0;\\n            for (size_t r = 0; r < n; ++r)\\n                hash_combine(hash, grid[r][c]);\\n            \\n            auto it = m.find(hash);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324850,
                "title": "cpp-easy-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size(),ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                bool flag=true;\\n                for(int k=0;k<n;k++){\\n                    if(v[i][k]!=v[k][j]){\\n                        flag=false;break;\\n                    }\\n                }\\n                ans+=flag;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size(),ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                bool flag=true;\\n                for(int k=0;k<n;k++){\\n                    if(v[i][k]!=v[k][j]){\\n                        flag=false;break;\\n                    }\\n                }\\n                ans+=flag;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324751,
                "title": "find-pairs-using-hashing-o-n-2-solution",
                "content": "**Similar Question** - [1814. Count Nice Pairs in an Array](https://leetcode.com/contest/biweekly-contest-49/problems/count-nice-pairs-in-an-array/)\\n\\nCollect the order in form of string in the map for every rows.\\nThen simply traverse every column, and count how many are there in map having same string configuration as current {That many pairs will be made}\\n# C++    \\n\\tint equalPairs(vector<vector<int>>& a) {\\n        int n= a.size(), res=0;\\n        unordered_map<string,int> mp;\\n\\t\\t //put in the map\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[i][j]) +\" \";\\n            mp[config]++;\\n        }\\n        //collect pairs\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[j][i]) +\" \";\\n            res+= mp[config];\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Similar Question** - [1814. Count Nice Pairs in an Array](https://leetcode.com/contest/biweekly-contest-49/problems/count-nice-pairs-in-an-array/)\\n\\nCollect the order in form of string in the map for every rows.\\nThen simply traverse every column, and count how many are there in map having same string configuration as current {That many pairs will be made}\\n# C++    \\n\\tint equalPairs(vector<vector<int>>& a) {\\n        int n= a.size(), res=0;\\n        unordered_map<string,int> mp;\\n\\t\\t //put in the map\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[i][j]) +\" \";\\n            mp[config]++;\\n        }\\n        //collect pairs\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[j][i]) +\" \";\\n            res+= mp[config];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3630895,
                "title": "beat-100-o-n-2-o-n-optimal-solution-art-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn my previous [solution](https://leetcode.com/problems/equal-row-and-column-pairs/solutions/3564106/beat-100-o-n-2-optimal-solution-true-hash-map/) I explained the basic way for solving this problem. However we needed to copy `vector`s around and that is very expensive. In this solution we are going to use a C++ technique to avoid the copying.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe define a data type `RowOrColumn` that only takes reference to the actual data, not copying them. We then define our own equality operator and hash for it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\nWe no longer copies the data so the extra space needed is only $N$ rather than $N^2$.\\n\\n# Code\\n```\\n\\nstruct RowOrColumn {\\n  const vector<vector<int>>& grid;\\n  const bool is_row;\\n  const int offset;\\n\\n  // This data behaves as if it is a vector for reading.\\n  int operator[](int index) const {\\n    return is_row ? grid[offset][index] : grid[index][offset];\\n  }\\n\\n  bool operator==(const RowOrColumn& other) const {\\n    // We skip the size equality since here it\\'s always the same.\\n    for (int i = 0; i < size(); ++i) {\\n      if ((*this)[i] != other[i]) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  int size() const {\\n    return grid.size();  // Row and column size should be the same.\\n  }\\n};\\n\\nstruct RangeHash {\\n  int operator()(const RowOrColumn& v) const {\\n    uint hash = 0;\\n    for(int i = 0; i < v.size(); ++i) {\\n        hash ^= v[i] + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<RowOrColumn, int, RangeHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      ++counts[RowOrColumn{.grid = grid, .is_row = false, .offset = c}];\\n    }\\n    int answer = 0;\\n    for (int r = 0; r < N; ++r) {\\n      answer += counts[RowOrColumn{.grid = grid, .is_row = true, .offset = r}];\\n    }\\n    return answer;\\n  }\\n};\\n```\\n\\n# Appendix: About the Hash Function.\\nIt is basically copied from the [boost `hash_combine`](https://www.boost.org/doc/libs/1_82_0/libs/container_hash/doc/html/hash.html#notes_hash_combine)\\n\\nIf you are wondering where this magic number `0x9e3779b9` comes from? It comes from the golden ratio:\\n$$\\n\\\\phi = \\\\frac{1 + \\\\sqrt{5}}{2} \\\\\\\\\\n\\\\frac{2^{32}}{\\\\phi} = \\\\text{0x9e3779b9}\\n$$",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n\\nstruct RowOrColumn {\\n  const vector<vector<int>>& grid;\\n  const bool is_row;\\n  const int offset;\\n\\n  // This data behaves as if it is a vector for reading.\\n  int operator[](int index) const {\\n    return is_row ? grid[offset][index] : grid[index][offset];\\n  }\\n\\n  bool operator==(const RowOrColumn& other) const {\\n    // We skip the size equality since here it\\'s always the same.\\n    for (int i = 0; i < size(); ++i) {\\n      if ((*this)[i] != other[i]) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  int size() const {\\n    return grid.size();  // Row and column size should be the same.\\n  }\\n};\\n\\nstruct RangeHash {\\n  int operator()(const RowOrColumn& v) const {\\n    uint hash = 0;\\n    for(int i = 0; i < v.size(); ++i) {\\n        hash ^= v[i] + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<RowOrColumn, int, RangeHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      ++counts[RowOrColumn{.grid = grid, .is_row = false, .offset = c}];\\n    }\\n    int answer = 0;\\n    for (int r = 0; r < N; ++r) {\\n      answer += counts[RowOrColumn{.grid = grid, .is_row = true, .offset = r}];\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324649,
                "title": "java-hashmap",
                "content": "**Code:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n\\t\\tHashMap<String, Integer> y = new HashMap<>();\\n\\t\\t\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb1 = new StringBuilder(), sb2 = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb1.append(grid[i][j]);\\n                sb2.append(grid[j][i]);\\n                sb1.append(\\',\\'); sb2.append(\\',\\');\\n            }\\n            String curr1 = sb1.toString(), curr2 = sb2.toString();\\n            x.put(curr1, x.getOrDefault(curr1, 0)+1);\\n            y.put(curr2, y.getOrDefault(curr2, 0)+1);\\n        }\\n        \\n        for(String str : x.keySet())\\n            if(y.containsKey(str))\\n                res += x.get(str)*y.get(str);\\n        return res;\\n    }\\n\\t\\n**Single Map, two loops:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[i][j]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            x.put(curr, x.getOrDefault(curr, 0) +1);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            if(x.containsKey(curr))\\n                res += x.get(curr);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Code:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n\\t\\tHashMap<String, Integer> y = new HashMap<>();\\n\\t\\t\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb1 = new StringBuilder(), sb2 = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb1.append(grid[i][j]);\\n                sb2.append(grid[j][i]);\\n                sb1.append(\\',\\'); sb2.append(\\',\\');\\n            }\\n            String curr1 = sb1.toString(), curr2 = sb2.toString();\\n            x.put(curr1, x.getOrDefault(curr1, 0)+1);\\n            y.put(curr2, y.getOrDefault(curr2, 0)+1);\\n        }\\n        \\n        for(String str : x.keySet())\\n            if(y.containsKey(str))\\n                res += x.get(str)*y.get(str);\\n        return res;\\n    }\\n\\t\\n**Single Map, two loops:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[i][j]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            x.put(curr, x.getOrDefault(curr, 0) +1);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            if(x.containsKey(curr))\\n                res += x.get(curr);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3035336,
                "title": "easy-concise-javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const rows = grid.map(arr => arr.join())\\n    const columns = grid[0].map((col, i) => grid.map(row => row[i]).join())\\n    let count = 0\\n    for (let row of rows) {\\n        for (let column of columns) {\\n            if (row === column) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const rows = grid.map(arr => arr.join())\\n    const columns = grid[0].map((col, i) => grid.map(row => row[i]).join())\\n    let count = 0\\n    for (let row of rows) {\\n        for (let column of columns) {\\n            if (row === column) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3631869,
                "title": "c-easy-explanation-maps",
                "content": "# Approach\\nStoring Rows as KEY in Hashmaps\\nChecking through each Column to find Similar rows \\nIf found add the Freq of Row\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // Taking rows as key and storing it\\'s frequency\\n        for(int i =0; i<m; i++){\\n            mp[grid[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        // Checking Columns with already present Rows\\n        for(int j = 0; j<n; j++){\\n            vector<int> col;\\n            for(int i = 0; i<m; i++){\\n                col.push_back(grid[i][j]);\\n            }\\n\\n            if(mp[col]>0) ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // Taking rows as key and storing it\\'s frequency\\n        for(int i =0; i<m; i++){\\n            mp[grid[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        // Checking Columns with already present Rows\\n        for(int j = 0; j<n; j++){\\n            vector<int> col;\\n            for(int i = 0; i<m; i++){\\n                col.push_back(grid[i][j]);\\n            }\\n\\n            if(mp[col]>0) ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325190,
                "title": "count-the-array-column-wise-c-easiest-solution",
                "content": "***Find the transpose of matrix and count the number of equal arrays***\\n***Given Matrix Grid is Treated as Row-Wise***\\n***Transpose Matrix T is treated as Colmun-Wise***\\n\\n***Example***\\n***Grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]***\\nRow-wise (same as Given)\\n3  1  2  2 \\n1  4  4  5 \\n2  4  2  2 \\n2  4  2  2\\n\\nColumn-wise (Transpose of matrix , For explaination)\\n3  1  2  2 \\n1  4  4  4 \\n2  4  2  2 \\n2  5  2  2  \\n\\n***Iterate in Grid and make a array COLUMN-WISE of grid in each iteration***\\n\\n***1st iteration we get -> 3 1 2 2***\\nCount its occurrences in Grid -> 1\\n***2nd iteration we get -> 1 4 4 4***\\ncount its occurrences in Grid -> 0\\n***3rd iteration we get ->2 4 2 2***\\ncount its occurrences in Grid -> 2\\n***4th iteration we get ->2 5 2 2***\\ncount its occurrences in Grid -> 0\\n\\n***Final Answer = 3***\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for (int i = 0; i < grid.size(); i++) {\\n            vector<int> T;\\n            for (int j = 0; j < grid.size(); j++) {\\n                T.push_back(grid[j][i]);\\n            }\\n            ans += count(begin(grid), end(grid), T);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for (int i = 0; i < grid.size(); i++) {\\n            vector<int> T;\\n            for (int j = 0; j < grid.size(); j++) {\\n                T.push_back(grid[j][i]);\\n            }\\n            ans += count(begin(grid), end(grid), T);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630850,
                "title": "hash-table-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem, we are given a `0-indexed` `n x n` integer matrix grid, we want to `return the number of pairs (ri, cj)` such that `row ri` and `column cj` are `equal`.\\n\\n### Explanation\\n\\nThis problem basically wants us to traverse through the matrix and check which row and columns contains the same pair values and then increment our counter once found.\\n\\nTo do that, we can traverse through our matrix row and use `hash table` to first store the frequencies of each row, converting each row into string representation to create unique keys using `tuple` or `JSON.stringify()` to make it hashable\\n\\nWe then traverse over each column of our matrix, and for each column, we create a string representation by extracting the elements from that current column using `lists`.\\n\\nAfter extracting the current column, we now check if it exists in our hash table. If so, we increment count by its frequency\\n\\nBy using `hash table`, all we need to do is iterate over each row and column once\\n\\n\\n# Code\\n\\n**Python**\\n\\n```   \\ndef equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        count = 0\\n        rows = {}\\n\\n        for r in range(n):\\n            row = tuple(grid[r])\\n            rows[row]= 1 + rows.get(row, 0)\\n        \\n        for c in range(n):\\n            col = tuple(grid[i][c] for i in range(n))\\n            count += rows.get(col, 0)\\n            \\n        return count``\\n\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n\\n    const n = grid.length\\n    let count = 0\\n    const rows = new Map()\\n\\n    for(let r = 0; r < n; r++){\\n        const row = JSON.stringify(grid[r])\\n        rows.set(row, 1 + (rows.get(row) || 0))\\n    }\\n\\n    for(let c = 0; c < n; c++){\\n        const col = JSON.stringify(grid.map(row => row[c]))\\n        count += (rows.get(col) || 0)\\n    }\\n    \\n    return count\\n};\\n```\\n### Time Complexity: `O(n^2)`\\n### Space Complexity: `O(n^2)`\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```   \\ndef equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        count = 0\\n        rows = {}\\n\\n        for r in range(n):\\n            row = tuple(grid[r])\\n            rows[row]= 1 + rows.get(row, 0)\\n        \\n        for c in range(n):\\n            col = tuple(grid[i][c] for i in range(n))\\n            count += rows.get(col, 0)\\n            \\n        return count``\\n\\n```\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n\\n    const n = grid.length\\n    let count = 0\\n    const rows = new Map()\\n\\n    for(let r = 0; r < n; r++){\\n        const row = JSON.stringify(grid[r])\\n        rows.set(row, 1 + (rows.get(row) || 0))\\n    }\\n\\n    for(let c = 0; c < n; c++){\\n        const col = JSON.stringify(grid.map(row => row[c]))\\n        count += (rows.get(col) || 0)\\n    }\\n    \\n    return count\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2325049,
                "title": "dont-think-too-much",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int row = grid.length;\\n        int col = grid.length;\\n        for(int i = 0; i < row; i++){\\n            String res = \"\";\\n            for(int j = 0; j < col; j++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            map.put(res, map.getOrDefault(res, 0) + 1);\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < col; j++){\\n            String res = \"\";\\n            for(int i = 0; i < row; i++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            cnt += map.getOrDefault(res, 0);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int row = grid.length;\\n        int col = grid.length;\\n        for(int i = 0; i < row; i++){\\n            String res = \"\";\\n            for(int j = 0; j < col; j++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            map.put(res, map.getOrDefault(res, 0) + 1);\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < col; j++){\\n            String res = \"\";\\n            for(int i = 0; i < row; i++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            cnt += map.getOrDefault(res, 0);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633511,
                "title": "simple-java-solution-hashmap-easy-to-understand-3-ms-beats-99",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length,c = 0;\\n        HashMap<Long,Integer> h = new  HashMap<Long,Integer>();\\n        for(int i=0;i<n;i++){\\n            long t1 = 0;\\n            for(int j=0;j<n;j++) t1 = t1 * 10 + grid[i][j];\\n            h.put(t1,h.getOrDefault(t1,0) + 1);\\n        }\\n        for(int i=0;i<n;i++){\\n            long t2 = 0;\\n            for(int j=0;j<n;j++) t2 = t2 * 10 + grid[j][i];\\n            c += h.getOrDefault(t2,0);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length,c = 0;\\n        HashMap<Long,Integer> h = new  HashMap<Long,Integer>();\\n        for(int i=0;i<n;i++){\\n            long t1 = 0;\\n            for(int j=0;j<n;j++) t1 = t1 * 10 + grid[i][j];\\n            h.put(t1,h.getOrDefault(t1,0) + 1);\\n        }\\n        for(int i=0;i<n;i++){\\n            long t2 = 0;\\n            for(int j=0;j<n;j++) t2 = t2 * 10 + grid[j][i];\\n            c += h.getOrDefault(t2,0);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631261,
                "title": "best-c-solution-map-fully-optimized-possible-solution",
                "content": "# Approach\\n- The function initializes an integer variable \"ans\" to zero and a map called \"mp\" with vector<int> as its key and integer as its value.\\n\\n- The first for loop iterates through the rows of the \"grid\" and increments the value of the corresponding key in the map \"mp\" by 1.\\n\\n- The second for loop iterates through the columns of the \"grid\". For each column, it creates a new vector called \"v\" and fills it with the values of that column. It then adds the value of the corresponding key in the map \"mp\" to the variable \"ans\".\\n\\n- Finally, the function returns the value of \"ans\".\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/18f3e1d4-778b-4148-bac1-580b6a4b2f6c_1686627741.015125.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Matrix",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324718,
                "title": "c-simple-solution",
                "content": "**Approach-1:** Compare each row with every column \\n**TC: O(N^3) SC: O(1)**\\n```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        int n=grid.size();\\n         \\n        for(int i=0; i<n; i++) //for row\\n        {\\n            for(int j=0; j<n; j++) //for column\\n            {\\n                for(int k=0; k<n; k++) //for comparing each row with every column\\n                {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    if(k==n-1) count++; //if row is totally equal to the column we increase the count\\n   \\n               }\\n            } \\n            \\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Approach-2:** Store row and its occurences in a hashmap. Then, store column in a vector and check whether that column is in the hashmap, if it is increase the count by its occurrences.\\n\\n**TC: O(N^2) SC: O(N^2)**\\n```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        map<vector<int> , int> mp;\\n        int n=grid.size();\\n        \\n        for(auto it:grid) //storing rows\\n            mp[it]++;\\n              \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++) \\n            {\\n                temp.push_back(grid[j][i]); //storing column\\n                \\n                if(mp[temp]) count += mp[temp]; //if row is totally equal to the column we increase the count\\n\\n           }\\n        } \\n           \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        int n=grid.size();\\n         \\n        for(int i=0; i<n; i++) //for row\\n        {\\n            for(int j=0; j<n; j++) //for column\\n            {\\n                for(int k=0; k<n; k++) //for comparing each row with every column\\n                {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    if(k==n-1) count++; //if row is totally equal to the column we increase the count\\n   \\n               }\\n            } \\n            \\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        map<vector<int> , int> mp;\\n        int n=grid.size();\\n        \\n        for(auto it:grid) //storing rows\\n            mp[it]++;\\n              \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++) \\n            {\\n                temp.push_back(grid[j][i]); //storing column\\n                \\n                if(mp[temp]) count += mp[temp]; //if row is totally equal to the column we increase the count\\n\\n           }\\n        } \\n           \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631860,
                "title": "c-easy-explanation-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCertainly! Here\\'s the intuition behind my code in simpler terms:\\n\\n1. The code counts the occurrences of rows and columns in a grid using two maps: `pq` for rows and `col` for columns.\\n\\n2. It iterates over each row and increments its count in the `pq` map.\\n\\n3. It extracts the values of each column and stores them in the `col` map, incrementing their count.\\n\\n4. Then, it iterates over the rows and checks if the corresponding column exists in the `col` map.\\n\\n5. If a matching column is found, it calculates the count of equal pairs by multiplying the counts of the row and column.\\n\\n6. It adds this count to the total count of equal pairs.\\n\\n7. Finally, it returns the total count of equal pairs.\\n\\nThe code efficiently counts the occurrences of rows and columns and determines the count of equal pairs by comparing the maps.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> pq;  // Map to count occurrences of each row\\n        int n=grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            pq[grid[i]]++;  // Count occurrences of each row\\n        }\\n        \\n        map<vector<int>,int> col;  // Map to count occurrences of each column\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp.push_back(grid[j][i]);  // Extracting column values and storing them in a vector\\n            }\\n            \\n            col[temp]++;  // Count occurrences of each column\\n        }\\n        \\n        int count=0;\\n        for(auto &i:pq)\\n        {\\n            if(col.find(i.first)!=col.end())  // Check if the column exists in the map\\n            {\\n                count += (i.second)* col[i.first];  // Calculate the count of equal pairs\\n            }\\n        }\\n        return count;  // Return the count of equal pairs\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> pq;  // Map to count occurrences of each row\\n        int n=grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            pq[grid[i]]++;  // Count occurrences of each row\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3630920,
                "title": "hashmap-solution-video-java-c-python",
                "content": "# Brute force and arriving at hashMap\\n1. Brute force: we can go through each row and column of the grid and see if they have the same elements in the same order. If they do, we increase the count. \\nThe problem with this approach is we will be checking twice for column with same values: eg 2, 5, 2, 2 occurs 2 times and we will be rechecking this. This can be avoided using a hashMap to store the row.\\n\\nStore each row as key in the hashMap i.e array 1,2,2,1 will be key and the value will be the count of 1,2,2,1 in rows\\n\\nIterate through the columns and increment the count by value if its Present in the hashMap.\\n\\n\\n# Appoach.\\n1. Create hashMap <String, Integer> hashMap.\\nwhy String?? As array hash is based on reference we convert it to string and store.\\n2. For each row in grid. convert row to String and store in hashMap. increase count if already existing.\\n3. For every column convert the col to String and check if present in hashMap, incerase the ans by value in hashMap.\\n4. return count\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pcH-Ym3EWLU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> hashMap = new HashMap<String, Integer>();\\n        for(int [] row: grid){\\n            String rowStr = Arrays.toString(row);\\n            hashMap.put(rowStr, hashMap.getOrDefault(rowStr,0)+1);\\n        }\\n        \\n        int count = 0;\\n        for(int j = 0;j<n;j++){\\n            int [] col = new int[n];\\n            for(int i = 0;i<n;i++){\\n                col[i] = grid[i][j];\\n            }\\n            count+=hashMap.getOrDefault(Arrays.toString(col),0);\\n        }\\n        return count;\\n    }\\n}\\n```\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(std::vector<std::vector<int>>& grid) {\\n        int n = grid.size();\\n        std::unordered_map<std::string, int> hashMap;\\n        \\n        for (std::vector<int>& row : grid) {\\n            std::string rowStr = vectorToString(row);\\n            hashMap[rowStr]++;\\n        }\\n        \\n        int count = 0;\\n        for (int j = 0; j < n; j++) {\\n            std::vector<int> col(n);\\n            for (int i = 0; i < n; i++) {\\n                col[i] = grid[i][j];\\n            }\\n            std::string colStr = vectorToString(col);\\n            count += hashMap[colStr];\\n        }\\n        \\n        return count;\\n    }\\n    \\nprivate:\\n    std::string vectorToString(std::vector<int>& vec) {\\n        std::string str;\\n        str += \\'[\\';\\n        for (int i = 0; i < vec.size(); i++) {\\n            if (i > 0) {\\n                str += \\',\\';\\n            }\\n            str += std::to_string(vec[i]);\\n        }\\n        str += \\']\\';\\n        return str;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        hashMap = defaultdict(int)\\n        \\n        for row in grid:\\n            rowStr = str(row)\\n            hashMap[rowStr] += 1\\n        \\n        count = 0\\n        for j in range(n):\\n            col = [grid[i][j] for i in range(n)]\\n            colStr = str(col)\\n            count += hashMap[colStr]\\n        \\n        return count\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> hashMap = new HashMap<String, Integer>();\\n        for(int [] row: grid){\\n            String rowStr = Arrays.toString(row);\\n            hashMap.put(rowStr, hashMap.getOrDefault(rowStr,0)+1);\\n        }\\n        \\n        int count = 0;\\n        for(int j = 0;j<n;j++){\\n            int [] col = new int[n];\\n            for(int i = 0;i<n;i++){\\n                col[i] = grid[i][j];\\n            }\\n            count+=hashMap.getOrDefault(Arrays.toString(col),0);\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(std::vector<std::vector<int>>& grid) {\\n        int n = grid.size();\\n        std::unordered_map<std::string, int> hashMap;\\n        \\n        for (std::vector<int>& row : grid) {\\n            std::string rowStr = vectorToString(row);\\n            hashMap[rowStr]++;\\n        }\\n        \\n        int count = 0;\\n        for (int j = 0; j < n; j++) {\\n            std::vector<int> col(n);\\n            for (int i = 0; i < n; i++) {\\n                col[i] = grid[i][j];\\n            }\\n            std::string colStr = vectorToString(col);\\n            count += hashMap[colStr];\\n        }\\n        \\n        return count;\\n    }\\n    \\nprivate:\\n    std::string vectorToString(std::vector<int>& vec) {\\n        std::string str;\\n        str += \\'[\\';\\n        for (int i = 0; i < vec.size(); i++) {\\n            if (i > 0) {\\n                str += \\',\\';\\n            }\\n            str += std::to_string(vec[i]);\\n        }\\n        str += \\']\\';\\n        return str;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        hashMap = defaultdict(int)\\n        \\n        for row in grid:\\n            rowStr = str(row)\\n            hashMap[rowStr] += 1\\n        \\n        count = 0\\n        for j in range(n):\\n            col = [grid[i][j] for i in range(n)]\\n            colStr = str(col)\\n            count += hashMap[colStr]\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342273,
                "title": "java-simple-solution-100-fast",
                "content": "I have seen many solutions using hashmap, but we can easily solve this question without complex approach.\\n1) Transpose the matrix\\n2) Iterate through grid, and check for matching cols.\\n\\nTC : `O( N x N) `\\nSpace : `O( N x N) `\\n\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] transpose = new int[m][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                //Transpose of matrix\\n                transpose[j][i] = grid[i][j];\\n            }\\n        }\\n        int ans = 0;\\n        for(int[] row : grid){\\n            for(int[] col : transpose){\\n                //Check for equality\\n                if(Arrays.equals(row, col)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] transpose = new int[m][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                //Transpose of matrix\\n                transpose[j][i] = grid[i][j];\\n            }\\n        }\\n        int ans = 0;\\n        for(int[] row : grid){\\n            for(int[] col : transpose){\\n                //Check for equality\\n                if(Arrays.equals(row, col)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325162,
                "title": "python-2-line-solution",
                "content": "# **Explanation**\\nFirst, Counts all columns frequency.\\nSedcone, iterate rows and accumulate the number of same.\\n<br>\\n\\n# **Complexity**\\nTime `O(n * n)`\\nSpace `O(n * n)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def equalPairs(self, A):\\n        count = Counter(zip(*A))\\n        return sum(count[tuple(r)] for r in A)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def equalPairs(self, A):\\n        count = Counter(zip(*A))\\n        return sum(count[tuple(r)] for r in A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3631774,
                "title": "c-easy-solution-hash-table",
                "content": "# Intuition\\nWe need to count the pairs of same rows and columns. We can make use of map.\\n\\n# Approach\\nLet us initialise map of vector to int which stores the frequency of a row vector.\\n**map<vector<int>,int>mppr**\\n\\nFirst for every row store the frequency of the row vector.\\n\\nNow for every column vector add the frequency of that vector to ans from mppr.\\n\\nFinally return ans.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2logn)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mppr;\\n        int ans = 0;\\n        int n = grid.size();\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n            mppr[temp]++;\\n        }\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans+=mppr[temp];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mppr;\\n        int ans = 0;\\n        int n = grid.size();\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n            mppr[temp]++;\\n        }\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans+=mppr[temp];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537821,
                "title": "c-trie-try-new-approach-easy",
                "content": "---\\n\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---\\n# Code\\n```\\nclass Trie {\\npublic:\\n    int endCount = 0;\\n    map<int, Trie*> mp;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        Trie* orig_trie = new Trie();\\n        int n = grid.size();\\n\\n        // Add rows of the matrix in the trie\\n        for(int i = 0; i<n; i++){\\n            Trie* temp_trie = orig_trie;\\n            for(int j = 0; j<n; j++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    temp_trie->mp[grid[i][j]] = new Trie();\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            temp_trie->endCount += 1;\\n        }\\n\\n        int ans = 0;\\n        // Traverse all the columns of the matrix in the trie\\n        for(int j = 0; j<n; j++){\\n            Trie* temp_trie = orig_trie;\\n            for(int i = 0; i<n; i++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    break;\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            ans += temp_trie->endCount;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n---\\n\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "Trie",
                    "Matrix"
                ],
                "code": "```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\n```\\nclass Trie {\\npublic:\\n    int endCount = 0;\\n    map<int, Trie*> mp;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        Trie* orig_trie = new Trie();\\n        int n = grid.size();\\n\\n        // Add rows of the matrix in the trie\\n        for(int i = 0; i<n; i++){\\n            Trie* temp_trie = orig_trie;\\n            for(int j = 0; j<n; j++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    temp_trie->mp[grid[i][j]] = new Trie();\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            temp_trie->endCount += 1;\\n        }\\n\\n        int ans = 0;\\n        // Traverse all the columns of the matrix in the trie\\n        for(int j = 0; j<n; j++){\\n            Trie* temp_trie = orig_trie;\\n            for(int i = 0; i<n; i++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    break;\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            ans += temp_trie->endCount;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448832,
                "title": "python-simple-clean-code-3-solutions",
                "content": "# Code\\n\\n## Using Numpy - having bad TC\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        grid = np.array(grid)\\n        cnt = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if all( [ a == b for a, b in zip( grid[i], grid[:,j] ) ] ):\\n                    cnt+=1\\n        return cnt\\n```\\n\\n## using Dictionary - Better TC\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n```\\n\\n## Best of 3\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[tuple(row)] += 1\\n        \\n        for col in zip(*grid):\\n            cnt += m[tuple(col)]\\n            \\n        return cnt\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        grid = np.array(grid)\\n        cnt = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if all( [ a == b for a, b in zip( grid[i], grid[:,j] ) ] ):\\n                    cnt+=1\\n        return cnt\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[tuple(row)] += 1\\n        \\n        for col in zip(*grid):\\n            cnt += m[tuple(col)]\\n            \\n        return cnt\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643204,
                "title": "python-elegant-short-o-n-3-vs-o-n-2-hashing",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^3)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        pairs = 0\\n\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    if grid[i][k] != grid[k][j]:\\n                        break\\n                else:\\n                    pairs += 1\\n\\n        return pairs\\n```\\n\\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^2)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mp = defaultdict(int)\\n\\n        for col in zip(*grid):\\n            mp[self.serialize(col)] += 1\\n\\n        return sum(mp[self.serialize(row)] for row in grid)\\n\\n    @staticmethod\\n    def serialize(nums: Generator) -> str:\\n        return \\',\\'.join(map(str, nums))\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^3)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        pairs = 0\\n\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    if grid[i][k] != grid[k][j]:\\n                        break\\n                else:\\n                    pairs += 1\\n\\n        return pairs\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^2)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mp = defaultdict(int)\\n\\n        for col in zip(*grid):\\n            mp[self.serialize(col)] += 1\\n\\n        return sum(mp[self.serialize(row)] for row in grid)\\n\\n    @staticmethod\\n    def serialize(nums: Generator) -> str:\\n        return \\',\\'.join(map(str, nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324846,
                "title": "easy-solution-using-transpose-of-the-matrix",
                "content": "```\\n\\tpublic int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n\\tpublic int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2324684,
                "title": "c-simple-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int cnt = 0;\\n        int n = grid.size();\\n        \\n        for(int i=0;i<n;i++)           // over row\\n        {\\n            for(int j=0;j<n;j++)       // over col\\n            {\\n                for(int k=0;k<n;k++)\\n                {\\n                    // cheking the gird(row,col) == grid(col,row)\\n                    if(grid[i][k]!=grid[k][j])\\n                        break;\\n                    \\n                    // if we have all value same in col & row then increase the count by 1\\n                    if(k==n-1)\\n                        cnt++;\\n                }\\n            }   \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int cnt = 0;\\n        int n = grid.size();\\n        \\n        for(int i=0;i<n;i++)           // over row\\n        {\\n            for(int j=0;j<n;j++)       // over col\\n            {\\n                for(int k=0;k<n;k++)\\n                {\\n                    // cheking the gird(row,col) == grid(col,row)\\n                    if(grid[i][k]!=grid[k][j])\\n                        break;\\n                    \\n                    // if we have all value same in col & row then increase the count by 1\\n                    if(k==n-1)\\n                        cnt++;\\n                }\\n            }   \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633109,
                "title": "easiest-faang-method-ever",
                "content": "# Intuition\\nTo count the number of pairs (ri, cj) such that row ri and column cj are equal, we need to iterate over each row and column pair and check if they contain the same elements in the same order. If they do, we increment a counter.\\n# Approach\\n\\n1. Initialize a variable `count` to 0 to keep track of the number of equal row-column pairs.\\n2. Iterate over each row `ri` in the range [0, n), where `len` is the size of the grid.\\n    - Inside the outer loop, iterate over each column `cj` in the range [0, len).\\n        - Inside the inner loop, check if the row `ri` and column `cj` in the grid are equal by comparing the elements of the corresponding row and column.\\n        - If the row and column are equal, increment the `count` variable.\\n3. After the loops finish, return the value of `count` as the result.\\n\\n# Complexity\\n- Time complexity:\\n\\nThe solution uses three nested loops: one for iterating over the rows, one for iterating over the columns, and one for comparing the elements of the row and column. The time complexity is \\'**O(n^3)**\\', where n is the size of the grid. In the worst case, when n is large, the time complexity can be considered cubic.\\n\\n- Space complexity:\\n\\nThe solution uses a constant amount of extra space for variables. Hence, the space complexity is **\\'O(1)\\'**.\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        int count = 0;\\n\\n        for (int ri = 0; ri < len; ri++) {\\n            for (int cj = 0; cj < len; cj++) {\\n                boolean isEqual = true;\\n\\n                for (int i = 0; i < len; i++) {\\n                    if (grid[ri][i] != grid[i][cj]) {\\n                        isEqual = false;\\n                        break;\\n                    }\\n                }\\n\\n                if (isEqual) count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        int count = 0;\\n\\n        for (int ri = 0; ri < len; ri++) {\\n            for (int cj = 0; cj < len; cj++) {\\n                boolean isEqual = true;\\n\\n                for (int i = 0; i < len; i++) {\\n                    if (grid[ri][i] != grid[i][cj]) {\\n                        isEqual = false;\\n                        break;\\n                    }\\n                }\\n\\n                if (isEqual) count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632741,
                "title": "c-solution-with-explanatory-comments-o-n-2",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n   string Mapfun(vector<int>&nums){\\n       string temp = \"\";\\n       for(auto it:nums){\\n           temp += to_string(it) + \"$\";\\n          //adding \"$\" between each number to make it unique string\\n          //for Ex- nums = [11,1] and nums= [1,11] will be identical if we will not seprate them with \"$\"\\n       } \\n       return temp;\\n   }\\n    int equalPairs(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n = grid.size();\\n      unordered_map<string,int>mp;\\n    \\n     //mapping with the help of Map function which convert rows in unique strings\\n      for(int i=0;i<n;i++){\\n          mp[Mapfun(grid[i])]++;\\n      } \\n       \\n       for(int i=0;i<n;i++){\\n           string search = \"\";\\n           for(int j=0;j<n;j++){\\n               //also converting coulumn same as row\\n               search += to_string(grid[j][i]) + \"$\";\\n               //note that we used grid[j][i] to traverse in coulumn\\n           }\\n          //just search in map if it is present then add the corresponding value in ans\\n          ans += mp[search];\\n       }\\n      return ans;\\n    }\\n};\\n```\\n**Please Upvote if helpful**",
                "solutionTags": [
                    "C++",
                    "String",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string Mapfun(vector<int>&nums){\\n       string temp = \"\";\\n       for(auto it:nums){\\n           temp += to_string(it) + \"$\";\\n          //adding \"$\" between each number to make it unique string\\n          //for Ex- nums = [11,1] and nums= [1,11] will be identical if we will not seprate them with \"$\"\\n       } \\n       return temp;\\n   }\\n    int equalPairs(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n = grid.size();\\n      unordered_map<string,int>mp;\\n    \\n     //mapping with the help of Map function which convert rows in unique strings\\n      for(int i=0;i<n;i++){\\n          mp[Mapfun(grid[i])]++;\\n      } \\n       \\n       for(int i=0;i<n;i++){\\n           string search = \"\";\\n           for(int j=0;j<n;j++){\\n               //also converting coulumn same as row\\n               search += to_string(grid[j][i]) + \"$\";\\n               //note that we used grid[j][i] to traverse in coulumn\\n           }\\n          //just search in map if it is present then add the corresponding value in ans\\n          ans += mp[search];\\n       }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630904,
                "title": "w-explanation-c-solutions-using-unordered-map-with-own-hashes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn C++, it is hard to use unordered_map for arrays as keys.\\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\\n\\nIn second solution, we build own hash and unordered_map over vector<int> is applicable.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;  // Variable to store the size of the grid\\n    unordered_map<string, int> Hash;  // Hash map to store the frequency of each string representation of a vector\\n\\n    // Function to convert a vector of integers to a string representation\\n    string to_str(const vector<int>& nums){\\n        string s=\"(\";  // Initialize the string with an opening parenthesis\\n        for(int x:nums)\\n            s+=to_string(x)+\",\";  // Append each integer to the string followed by a comma\\n        return s;  // Return the resulting string\\n    } \\n\\n    // Function to calculate the number of equal pairs in the grid\\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();  // Set the size of the grid\\n\\n        // Loop through each vector in the grid\\n        for(const vector<int>& nums: grid){\\n            string s=to_str(nums);  // Convert the vector to a string representation\\n            if (Hash.count(s)==0)\\n                Hash[s]=1;  // If the string representation is not present in the hash map, add it with a frequency of 1\\n            else\\n                Hash[s]++;  // If the string representation is already present, increment its frequency\\n        }\\n\\n        int ans=0;  // Initialize the answer variable\\n\\n        // Loop through each column in the grid\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);  // Initialize a vector to store the elements of the current column\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];  // Store the elements of the column in the vector\\n            }\\n            string s=to_str(col);  // Convert the vector to a string representation\\n\\n            // Check if the string representation exists in the hash map and add its frequency to the answer\\n            if (Hash.count(s)>0)\\n                ans+=Hash[s];       \\n        }\\n\\n        return ans;  // Return the final answer\\n    }\\n};\\n\\n```\\n# Use Own Hash to use unordered_map over arrays, and faster\\nRuntime 99 ms Beats 85.41%\\n```\\nclass Solution {\\n//Build own Hash and own unordered_map<vector<int>, int> as hash table\\npublic:\\n    struct MyHash\\n    {\\n        size_t operator()(const vector<int>& nums) const\\n        {\\n            size_t digest=0;\\n            for (int x: nums)\\n                digest^=hash<int>{}(x);\\n            return digest; \\n        }\\n    };\\n    int n;\\n    unordered_map<vector<int>, int, MyHash> Hash;\\n    \\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        for(const vector<int>& nums: grid){\\n            if (Hash.count(nums)==0) Hash[nums]=1;\\n            else \\n                Hash[nums]++;\\n        }\\n        int ans=0;\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];\\n            }\\n            if (Hash.count(col)>0)\\n                ans+=Hash[col];       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;  // Variable to store the size of the grid\\n    unordered_map<string, int> Hash;  // Hash map to store the frequency of each string representation of a vector\\n\\n    // Function to convert a vector of integers to a string representation\\n    string to_str(const vector<int>& nums){\\n        string s=\"(\";  // Initialize the string with an opening parenthesis\\n        for(int x:nums)\\n            s+=to_string(x)+\",\";  // Append each integer to the string followed by a comma\\n        return s;  // Return the resulting string\\n    } \\n\\n    // Function to calculate the number of equal pairs in the grid\\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();  // Set the size of the grid\\n\\n        // Loop through each vector in the grid\\n        for(const vector<int>& nums: grid){\\n            string s=to_str(nums);  // Convert the vector to a string representation\\n            if (Hash.count(s)==0)\\n                Hash[s]=1;  // If the string representation is not present in the hash map, add it with a frequency of 1\\n            else\\n                Hash[s]++;  // If the string representation is already present, increment its frequency\\n        }\\n\\n        int ans=0;  // Initialize the answer variable\\n\\n        // Loop through each column in the grid\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);  // Initialize a vector to store the elements of the current column\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];  // Store the elements of the column in the vector\\n            }\\n            string s=to_str(col);  // Convert the vector to a string representation\\n\\n            // Check if the string representation exists in the hash map and add its frequency to the answer\\n            if (Hash.count(s)>0)\\n                ans+=Hash[s];       \\n        }\\n\\n        return ans;  // Return the final answer\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n//Build own Hash and own unordered_map<vector<int>, int> as hash table\\npublic:\\n    struct MyHash\\n    {\\n        size_t operator()(const vector<int>& nums) const\\n        {\\n            size_t digest=0;\\n            for (int x: nums)\\n                digest^=hash<int>{}(x);\\n            return digest; \\n        }\\n    };\\n    int n;\\n    unordered_map<vector<int>, int, MyHash> Hash;\\n    \\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        for(const vector<int>& nums: grid){\\n            if (Hash.count(nums)==0) Hash[nums]=1;\\n            else \\n                Hash[nums]++;\\n        }\\n        int ans=0;\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];\\n            }\\n            if (Hash.count(col)>0)\\n                ans+=Hash[col];       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630834,
                "title": "easy-clear-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        sumrow=[]\\n        sumcol=[]\\n        n=len(grid)\\n        for i in range(n):\\n            sumrow.append(sum(grid[i]))\\n            s=0\\n            for j in range(n):\\n                s+=grid[j][i]\\n            sumcol.append(s)\\n        \\n        res=0\\n        for i in range(n):\\n            for j in range(n):\\n                if sumrow[i]==sumcol[j]:\\n                    test=True\\n                    for k in range(n):\\n                        if grid[i][k]!=grid[k][j]:\\n                            test=False\\n                            break\\n                    if test:\\n                        res+=1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        sumrow=[]\\n        sumcol=[]\\n        n=len(grid)\\n        for i in range(n):\\n            sumrow.append(sum(grid[i]))\\n            s=0\\n            for j in range(n):\\n                s+=grid[j][i]\\n            sumcol.append(s)\\n        \\n        res=0\\n        for i in range(n):\\n            for j in range(n):\\n                if sumrow[i]==sumcol[j]:\\n                    test=True\\n                    for k in range(n):\\n                        if grid[i][k]!=grid[k][j]:\\n                            test=False\\n                            break\\n                    if test:\\n                        res+=1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630816,
                "title": "java-trie-beats-78-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Scan through one row at a time and construct a trie data structure using the values in sequence in the rows.\\n2. The leaf nodes in the trie must store the number of paths that follow the same set of nodes (i.e. the rows containing the exact same elements).\\n3. Now scan through one column at a time and try to traverse the trie using the sequence of values in each column.\\n4. We will either reach a leaf node in the trie, in which case we add the count in the leaf node to our final answer, or we won\\'t find a match at some point and have to break out of the trie traversal for each column.\\n5. Return the final answer which is the summation of the counts of all leaf nodes reached.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  class Node {\\n    Map<Integer, Node> next = new HashMap<>();\\n    int cnt;\\n  }\\n\\n  public int equalPairs(int[][] grid) {\\n    int n = grid.length, ans = 0;\\n    var root = new Node();\\n\\n    for (var row : grid) {\\n      var ptr = root;\\n\\n      for (var val : row) {\\n        if (ptr.next.containsKey(val))\\n          ptr = ptr.next.get(val);\\n        else {\\n          var newNode = new Node();\\n          ptr.next.put(val, newNode);\\n          ptr = newNode;\\n        }\\n      }\\n      ptr.cnt++;\\n    }\\n    for (var i=0; i<n; i++) {\\n      var ptr = root;\\n\\n      for (var j=0; j<n; j++) {\\n        if (ptr.next.containsKey(grid[j][i]))\\n          ptr = ptr.next.get(grid[j][i]);\\n        else break;\\n      }\\n      ans += ptr.cnt;\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Trie",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  class Node {\\n    Map<Integer, Node> next = new HashMap<>();\\n    int cnt;\\n  }\\n\\n  public int equalPairs(int[][] grid) {\\n    int n = grid.length, ans = 0;\\n    var root = new Node();\\n\\n    for (var row : grid) {\\n      var ptr = root;\\n\\n      for (var val : row) {\\n        if (ptr.next.containsKey(val))\\n          ptr = ptr.next.get(val);\\n        else {\\n          var newNode = new Node();\\n          ptr.next.put(val, newNode);\\n          ptr = newNode;\\n        }\\n      }\\n      ptr.cnt++;\\n    }\\n    for (var i=0; i<n; i++) {\\n      var ptr = root;\\n\\n      for (var j=0; j<n; j++) {\\n        if (ptr.next.containsKey(grid[j][i]))\\n          ptr = ptr.next.get(grid[j][i]);\\n        else break;\\n      }\\n      ans += ptr.cnt;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630779,
                "title": "daily-leetcoding-challenge-june-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/equal-row-and-column-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Map\n\n  \n**Approach 3:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/equal-row-and-column-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3502709,
                "title": "javascript-96-8-runtime-and-81-37-memory",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const columns = new Map();\\n    const rows = new Map();\\n    let rowNums, colNums, rowHash, colHash;\\n    let ans = 0;\\n\\n    for (let i = 0; i < grid.length; i++) {\\n        rowNums = [];\\n        colNums = [];\\n        \\n        for (let j = 0; j < grid[i].length; j++) {\\n            rowNums.push(grid[i][j]);\\n            colNums.push(grid[j][i]);\\n        }\\n\\n        rowHash = rowNums.join(\\',\\');\\n        colHash = colNums.join(\\',\\');\\n        \\n        rows.set(rowHash, (rows.get(rowHash) || 0) + 1);\\n        columns.set(colHash, (columns.get(colHash) || 0) + 1);\\n    }\\n\\n    for (const [row, value] of rows) {\\n        if (columns.has(row)) {\\n            ans += value * columns.get(row);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const columns = new Map();\\n    const rows = new Map();\\n    let rowNums, colNums, rowHash, colHash;\\n    let ans = 0;\\n\\n    for (let i = 0; i < grid.length; i++) {\\n        rowNums = [];\\n        colNums = [];\\n        \\n        for (let j = 0; j < grid[i].length; j++) {\\n            rowNums.push(grid[i][j]);\\n            colNums.push(grid[j][i]);\\n        }\\n\\n        rowHash = rowNums.join(\\',\\');\\n        colHash = colNums.join(\\',\\');\\n        \\n        rows.set(rowHash, (rows.get(rowHash) || 0) + 1);\\n        columns.set(colHash, (columns.get(colHash) || 0) + 1);\\n    }\\n\\n    for (const [row, value] of rows) {\\n        if (columns.has(row)) {\\n            ans += value * columns.get(row);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3814071,
                "title": "simple-solution-o-n-3-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int count=0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                boolean flag = true;\\n                for(int k=0;k<n;k++) {\\n                    if(grid[i][k] == grid[k][j]) {\\n                        continue;\\n                    }else{\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag == true) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int count=0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                boolean flag = true;\\n                for(int k=0;k<n;k++) {\\n                    if(grid[i][k] == grid[k][j]) {\\n                        continue;\\n                    }else{\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag == true) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642277,
                "title": "best-solution",
                "content": "# Approach\\nUsing Map\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = 0;\\n        map <vector<int>, int> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[grid[i]]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            vector <int> col;\\n            for (int j = 0; j < n; j++) {\\n                col.push_back(grid[j][i]);\\n            }\\n            if (mp.find(col) != mp.end())\\n                ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = 0;\\n        map <vector<int>, int> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[grid[i]]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            vector <int> col;\\n            for (int j = 0; j < n; j++) {\\n                col.push_back(grid[j][i]);\\n            }\\n            if (mp.find(col) != mp.end())\\n                ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634451,
                "title": "easy-optimal-solution-like-no-one-else-custom-rolling-hash-function-used-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhile I was reading this question, a few approaches immediately popped in my mind. The first was obviously the BRUTE force approach where you check ever element in every row and column but it takes a lot of time to do that. Now here, I remembered about the concept of Dynamic Programming where the ideology is to NOT repeat calculations. So that is how I thought of using HASH functions.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat you do here is... For every row, A hash value is computed using a rolling hash function (Here it is defined as hash()). The hash value depends on the ORDER of elements and their numeric value or \"weight\". Each row gets a unique hash value which can be regenerated by an array having same elements in the same order.\\n\\nNow, the problem is that the input grid[][] may have duplicate rows. So what I thought of was to keep a frequency count of the row in a hashmap where the key is the hash value computed.\\n\\nOnce the map is ready, we calculate the hash value for ALL columns which unfortunately takes O(n^2) because we first construct the array (Done only once, after that we just replace the values) to compute hash value for every column.\\n\\nIf a match is found, we then simply add the frequency to the result because the column matches with BOTH rows (which are identical)\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (O(k))\\n&emsp; *Where k is max(row, column)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    // Hash Function\\n    ll hash(vector<int> &vec){\\n        ll hash_so_far = 0;\\n        ll p = 31, m = 1e9 + 7;\\n        ll p_pow = 1;\\n        ll n = (ll)vec.size();\\n        for (long long i = 0; i < n; ++i) {\\n            hash_so_far = (hash_so_far + vec[i] * p_pow) % m;\\n            p_pow = (p_pow * p) % m;\\n        }\\n        return hash_so_far;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int res = 0;\\n        int row = grid.size();\\n        int column = grid[0].size();\\n        ll hashed_col;\\n\\n        unordered_map<ll, int> umap;\\n\\n        for(int i = 0 ; i < row ; i++){\\n            // Computing hash value\\n            umap[hash(grid[i])]++;\\n        }\\n        vector<int> col(row);\\n        for(int i = 0 ; i < column ; i++){\\n            for(int j = 0 ; j < row ; j++){\\n                col[j] = grid[j][i];\\n                // Generating column vector\\n            }\\n            // Hash value of column vector\\n            hashed_col = hash(col);\\n            if(umap.find(hashed_col) != umap.end()){\\n                res += umap.at(hashed_col);\\n                // Adding frequency of the hash value if match = true\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Rolling Hash",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    // Hash Function\\n    ll hash(vector<int> &vec){\\n        ll hash_so_far = 0;\\n        ll p = 31, m = 1e9 + 7;\\n        ll p_pow = 1;\\n        ll n = (ll)vec.size();\\n        for (long long i = 0; i < n; ++i) {\\n            hash_so_far = (hash_so_far + vec[i] * p_pow) % m;\\n            p_pow = (p_pow * p) % m;\\n        }\\n        return hash_so_far;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int res = 0;\\n        int row = grid.size();\\n        int column = grid[0].size();\\n        ll hashed_col;\\n\\n        unordered_map<ll, int> umap;\\n\\n        for(int i = 0 ; i < row ; i++){\\n            // Computing hash value\\n            umap[hash(grid[i])]++;\\n        }\\n        vector<int> col(row);\\n        for(int i = 0 ; i < column ; i++){\\n            for(int j = 0 ; j < row ; j++){\\n                col[j] = grid[j][i];\\n                // Generating column vector\\n            }\\n            // Hash value of column vector\\n            hashed_col = hash(col);\\n            if(umap.find(hashed_col) != umap.end()){\\n                res += umap.at(hashed_col);\\n                // Adding frequency of the hash value if match = true\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634405,
                "title": "c-o-n-2-transpose-method",
                "content": "# Intuition\\nFirstly tranpose the given matrix and then compare the rows of the given matrix and the transpose matrix.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n- Space complexity:O(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<vector<int>> t;\\n        int cnt=0;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            vector<int> a;\\n            for(int j=0; j<grid.size(); j++)\\n            {\\n                a.push_back(grid[j][i]);\\n            }\\n            t.push_back(a);\\n        }\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid.size(); j++)\\n            if(grid[i]==t[j]) \\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<vector<int>> t;\\n        int cnt=0;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            vector<int> a;\\n            for(int j=0; j<grid.size(); j++)\\n            {\\n                a.push_back(grid[j][i]);\\n            }\\n            t.push_back(a);\\n        }\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid.size(); j++)\\n            if(grid[i]==t[j]) \\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633733,
                "title": "c-easy-solution-using-hashmap",
                "content": "\\n\\n# Approach\\n->First traverse on the grid in row wise manner & keep on adding elements in the vector  after each row push it in map.\\n-> Then traverse again but this time in column wise manner & now try to find that column array in the map. \\n-> If you get it increase the count \\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       map<vector<int>,int >m;\\n       int n = grid.size();\\n       for(int i =0;i<n;i++){\\n           vector<int>temp;\\n           for(int j =0;j<n; j++){\\n            temp.push_back(grid[i][j]);\\n           }\\n           m[temp]++;\\n       }\\n      \\n       int cnt = 0;\\n        for(int j =0;j<n;j++){\\n          vector<int>temp;\\n           for(int i =0;i<n; i++){\\n               temp.push_back(grid[i][j]);\\n           }\\n           if(m.find(temp) != m.end()){\\n               cnt += m[temp];\\n           }\\n           }\\n           return cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       map<vector<int>,int >m;\\n       int n = grid.size();\\n       for(int i =0;i<n;i++){\\n           vector<int>temp;\\n           for(int j =0;j<n; j++){\\n            temp.push_back(grid[i][j]);\\n           }\\n           m[temp]++;\\n       }\\n      \\n       int cnt = 0;\\n        for(int j =0;j<n;j++){\\n          vector<int>temp;\\n           for(int i =0;i<n; i++){\\n               temp.push_back(grid[i][j]);\\n           }\\n           if(m.find(temp) != m.end()){\\n               cnt += m[temp];\\n           }\\n           }\\n           return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632398,
                "title": "detailed-python-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\"Please UP-VOTE Friends\"\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        #initilize the count as 0\\n        c=0\\n        for i in range(len(grid)):\\n            #Iterate the grid and take it from colum elements and make it as x\\n            x=[grid[j][i] for j in range(len(grid))]\\n            #if colum in grid then count\\n            if x in grid:\\n                #add to count how many times it would be occur in a grid\\n                c=c+grid.count(x)\\n        #Then return the total count\\n        return c\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        #initilize the count as 0\\n        c=0\\n        for i in range(len(grid)):\\n            #Iterate the grid and take it from colum elements and make it as x\\n            x=[grid[j][i] for j in range(len(grid))]\\n            #if colum in grid then count\\n            if x in grid:\\n                #add to count how many times it would be occur in a grid\\n                c=c+grid.count(x)\\n        #Then return the total count\\n        return c\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631592,
                "title": "python-shortest-1-liners-multiple-solutions-functional-programming",
                "content": "# Approach 1: Brute force\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 3)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\nwhere, `n * n is the dimensions of grid.`\\n\\n# Code\\n\\nMultiline:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        transpose = lambda matrix: list(map(list, zip(*matrix)))\\n        rows, cols = grid, transpose(grid)\\n        return sum(starmap(eq, product(rows, cols)))\\n\\n\\n```\\n\\n1-liner:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(starmap(eq, product(grid, list(map(list, zip(*grid))))))\\n\\n\\n```\\n\\n---\\n# Approach 1: Hashmap\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\nwhere, `n * n is the dimensions of grid.`\\n\\n# Code\\n\\nMultiline:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        rows = Counter(map(tuple, grid))\\n        return sum(rows[col] for col in zip(*grid))\\n\\n\\n```\\n\\n1-liner:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return (rows := Counter(map(tuple, grid))) and sum(rows[col] for col in zip(*grid))\\n\\n\\n```\\n\\nAnother 1-liner:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(itemgetter(*zip(*grid), 0)(Counter(map(tuple, grid))))\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        transpose = lambda matrix: list(map(list, zip(*matrix)))\\n        rows, cols = grid, transpose(grid)\\n        return sum(starmap(eq, product(rows, cols)))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(starmap(eq, product(grid, list(map(list, zip(*grid))))))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        rows = Counter(map(tuple, grid))\\n        return sum(rows[col] for col in zip(*grid))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return (rows := Counter(map(tuple, grid))) and sum(rows[col] for col in zip(*grid))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(itemgetter(*zip(*grid), 0)(Counter(map(tuple, grid))))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631483,
                "title": "easiest-python-solution-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem aims to count the number of equal pairs in the given grid. One way to approach this is to compare each row in the grid with the first row and check if they are equal.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Store the first row of the grid in the variable column_starts_with.\\n\\n2.Initialize an empty list called columns to store the columns of the grid.\\n\\n3.Iterate through each row in the grid.\\n\\n4.For each row, iterate through each element and append it to the corresponding column in the columns list using the enumerate function.\\n\\n5.After iterating through all the rows, the columns list contains the columns of the grid.\\n\\n6.Initialize a variable called equal_pairs to keep track of the count of equal pairs.\\n\\n7.Iterate through each row in the grid.\\n\\n8.For each row, iterate through each element in the column_starts_with list.\\n\\n9.Check if the first element of the row is equal to the element in the corresponding column.\\n\\n10.If the condition is met, compare the entire row with the column to determine if they are equal.\\n\\n11.If the row is equal to the column, increment the count of equal_pairs.\\nFinally, return the count of equal_pairs.\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        # Store the first row of the grid\\n        column_starts_with = grid[0]\\n\\n        # Initialize a list to store the columns of the grid\\n        columns = [[] for _ in column_starts_with]\\n        \\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the row and append it to the corresponding column\\n            for j, element in enumerate(row):\\n                columns[j].append(element)\\n        \\n        # Initialize a variable to count the equal pairs\\n        equal_pairs = 0\\n\\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the first row\\n            for j, element in enumerate(column_starts_with):\\n                # Check if the first element of the row is equal to the element in the corresponding column\\n                if row[0] == element:\\n                    # Check if the entire row is equal to the column\\n                    if row == columns[j]:\\n                        equal_pairs += 1\\n    \\n        return equal_pairs\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        # Store the first row of the grid\\n        column_starts_with = grid[0]\\n\\n        # Initialize a list to store the columns of the grid\\n        columns = [[] for _ in column_starts_with]\\n        \\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the row and append it to the corresponding column\\n            for j, element in enumerate(row):\\n                columns[j].append(element)\\n        \\n        # Initialize a variable to count the equal pairs\\n        equal_pairs = 0\\n\\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the first row\\n            for j, element in enumerate(column_starts_with):\\n                # Check if the first element of the row is equal to the element in the corresponding column\\n                if row[0] == element:\\n                    # Check if the entire row is equal to the column\\n                    if row == columns[j]:\\n                        equal_pairs += 1\\n    \\n        return equal_pairs\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631470,
                "title": "best-c-solution-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon analyzing the code, it appears that the `equalPairs` function takes a 2D grid represented by a vector of vectors (`grid`) as input. The function aims to count the number of equal pairs in the grid.\\n\\n\\nThis solution leverages a map to count the frequency of each vector in the grid, allowing us to efficiently find the number of equal pairs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve the problem, the approach followed by the given code is as follows:\\n\\n1. Initialize a variable `ans` to keep track of the count of equal pairs.\\n2. Create a `map` called `mp` to store the frequency of each vector in the `grid`.\\n3. Iterate over each row (`i`) in the `grid` using a for loop.\\n   - Inside the loop, access the current row of the `grid` and increment the frequency of that row\\'s vector in the `mp` map.\\n4. Iterate over each column (`j`) in the `grid` using a nested for loop.\\n   - Inside the nested loop, perform the following steps:\\n     - Create an empty vector `v` to store the values of the column.\\n     - Iterate over each row (`i`) in the `grid` using another for loop.\\n       - Inside this loop, access the value at column `j` of the current row and append it to the vector `v`.\\n     - After the inner loop ends, increment `ans` by the frequency of vector `v` in the `mp` map.\\n5. After both loops complete, return the final count `ans`.\\n\\nThe approach essentially counts the occurrences of each row vector in the `grid` using a map, and then counts the occurrences of each column vector by transposing the grid. Finally, it sums up the frequencies of equal pairs and returns the count.\\n\\n# Complexity\\n- Time complexity: O(M * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> where M and N are the dimensions of the grid.\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->where M and N are the dimensions of the grid. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/abf00482-9fde-4cf1-9911-a767b8732f15_1686631415.479188.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631290,
                "title": "java-solution-for-equal-row-and-column-pairs-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to iterate through each row of the grid and keep track of the frequency of each row using a map. Then, for each column, construct a temporary array by extracting the elements of the column. Convert this array to a string and check its frequency in the row frequency map. Add the frequency to the total count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the count variable to 0 and the size of the grid, n.\\n1. Create a map called rowCounter to keep track of the frequency of each row.\\n1. Iterate through each row of the grid:\\n- Convert the row array to a string using Arrays.toString().\\n- Increment the frequency of the row string in the rowCounter map.\\n4. Iterate through each column of the grid:\\n- Create a temporary array called colArray to store the elements of the column.\\n- Extract the elements of the column by iterating through the rows and accessing the corresponding element.\\n- Convert the colArray to a string using Arrays.toString().\\n- Retrieve the frequency of the column string from the rowCounter map using getOrDefault().\\n- Add the frequency to the count variable.\\n5. Return the count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n^2), where n is the size of the grid. The code iterates through each row and column of the grid once, and the operations performed within the loops are constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n^2). It uses additional space to store the rowCounter map, which can contain up to n^2 entries in the worst case.\\n\\n# Code\\n```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        int n = grid.length;\\n\\n        // Keep track of the frequency of each row.\\n        Map<String, Integer> rowCounter = new HashMap<>();\\n        for (int[] row : grid) \\n        {\\n            String rowString = Arrays.toString(row);\\n            rowCounter.put(rowString, 1 + rowCounter.getOrDefault(rowString, 0));\\n        }\\n\\n        // Add up the frequency of each column in the map.\\n        for (int c = 0; c < n; c++) \\n        {\\n            int[] colArray = new int[n];\\n            for (int r = 0; r < n; r++) \\n            {\\n                colArray[r] = grid[r][c];\\n            }\\n            count += rowCounter.getOrDefault(Arrays.toString(colArray), 0);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        int n = grid.length;\\n\\n        // Keep track of the frequency of each row.\\n        Map<String, Integer> rowCounter = new HashMap<>();\\n        for (int[] row : grid) \\n        {\\n            String rowString = Arrays.toString(row);\\n            rowCounter.put(rowString, 1 + rowCounter.getOrDefault(rowString, 0));\\n        }\\n\\n        // Add up the frequency of each column in the map.\\n        for (int c = 0; c < n; c++) \\n        {\\n            int[] colArray = new int[n];\\n            for (int r = 0; r < n; r++) \\n            {\\n                colArray[r] = grid[r][c];\\n            }\\n            count += rowCounter.getOrDefault(Arrays.toString(colArray), 0);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631059,
                "title": "simplest-python-solution-take-transpose-of-matrix",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        ans = 0\\n\\n        for row in grid:\\n            d[tuple(row)] += 1\\n\\n        for col in zip(*grid):\\n            ans += d[tuple(col)]\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        ans = 0\\n\\n        for row in grid:\\n            d[tuple(row)] += 1\\n\\n        for col in zip(*grid):\\n            ans += d[tuple(col)]\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630973,
                "title": "brute-force-m-3-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,k,n=grid.size(),ans=0;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                k = 0;\\n                while(k<n&&grid[i][k]==grid[k][j])k++;\\n                if(k>=n)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,k,n=grid.size(),ans=0;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                k = 0;\\n                while(k<n&&grid[i][k]==grid[k][j])k++;\\n                if(k>=n)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630899,
                "title": "o-n-3-o-n-2-solution-c",
                "content": "#Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0; i<n;i++){\\n            vector<int> temp;\\n            for(int j=0; j<n;j++){\\n                cout<<grid[j][i]<<\" \";\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n            cout<<endl;\\n        }\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==ans[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string str(vector<int> & row){\\n        string ans=\"\";\\n        for(int j:row){\\n            ans+=to_string(j)+\"#\";\\n        }\\n        return ans;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        map<string,int> mp;\\n        for(int i=0; i<n;i++){\\n            mp[str(grid[i])]++;\\n        }\\n        for(int i=0; i<n;i++){\\n            string ans=\"\";\\n            for(int j=0; j<n;j++){\\n                ans+=to_string(grid[j][i])+\"#\";\\n            }\\n            count+=mp[ans];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0; i<n;i++){\\n            vector<int> temp;\\n            for(int j=0; j<n;j++){\\n                cout<<grid[j][i]<<\" \";\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n            cout<<endl;\\n        }\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==ans[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string str(vector<int> & row){\\n        string ans=\"\";\\n        for(int j:row){\\n            ans+=to_string(j)+\"#\";\\n        }\\n        return ans;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        map<string,int> mp;\\n        for(int i=0; i<n;i++){\\n            mp[str(grid[i])]++;\\n        }\\n        for(int i=0; i<n;i++){\\n            string ans=\"\";\\n            for(int j=0; j<n;j++){\\n                ans+=to_string(grid[j][i])+\"#\";\\n            }\\n            count+=mp[ans];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2324784,
                "title": "just-do-what-it-says-easy-solution",
                "content": "Just do what the question asks.\\n\\nFor a single `row, col` position iterate the whole row and the whole column, and check whether the elements are equal and in the same order.\\n\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ans = 0\\n        \\n        for row in range(n):\\n            for col in range(n):\\n                has_found = True\\n                \\n                for i in range(n):\\n                    if grid[row][i] != grid[i][col]:\\n                        has_found = False\\n                        break\\n                    \\n                if has_found:\\n                    ans += 1\\n\\t\\t\\t\\t\\t\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ans = 0\\n        \\n        for row in range(n):\\n            for col in range(n):\\n                has_found = True\\n                \\n                for i in range(n):\\n                    if grid[row][i] != grid[i][col]:\\n                        has_found = False\\n                        break\\n                    \\n                if has_found:\\n                    ans += 1\\n\\t\\t\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784119,
                "title": "python-3-tuple-dict-and-transpose-matrix-using-zip-beats-97",
                "content": "```python3 []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        for row in grid:\\n            d[tuple(row)] += 1\\n        \\n        return sum(d[tuple(col)] for col in zip(*grid))        \\n```\\n![Screenshot 2023-07-18 at 20.06.44.png](https://assets.leetcode.com/users/images/3d8310a3-d6e3-4a22-8a43-0dec42ff4ee1_1689700226.718251.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        for row in grid:\\n            d[tuple(row)] += 1\\n        \\n        return sum(d[tuple(col)] for col in zip(*grid))        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634601,
                "title": "python-dictionary-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$, where n is the number of cells in the grid\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d1 = {}\\n        d2 = {}\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d1[tupled_row] = 1 + d1.get(tupled_row, 0)\\n\\n        grid = zip(*grid)\\n\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d2[tupled_row] = 1 + d2.get(tupled_row, 0)\\n\\n        res = 0\\n        for i in d1:\\n            if i in d2:\\n                res += d1[i]*d2[i]\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d1 = {}\\n        d2 = {}\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d1[tupled_row] = 1 + d1.get(tupled_row, 0)\\n\\n        grid = zip(*grid)\\n\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d2[tupled_row] = 1 + d2.get(tupled_row, 0)\\n\\n        res = 0\\n        for i in d1:\\n            if i in d2:\\n                res += d1[i]*d2[i]\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632254,
                "title": "c-java-beginner-friendly",
                "content": "# Intuition\\nJust move every rows in a map and count them then compare it with the cols,if they are equals then increase the result value\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If i did it in brute force approach then we have to take a row and compare it with all the columns (comparing done by element by element) so the total time complexity would be $$O(n^3)$$ (n*n for compare row and col and n * n *n to compare element by element)\\n2. But In optimal approach we store the row-wise value as a string format in a map,But we have to join the numbers by some special character like ($$#,$,@ etc$$) cause lets take a case a row-wise value is 2,2,1,0 and if i joined it without special char then the string would be like \"2211\" and suppose in col-wise the value is 22,1,1 and after joining without special chars the string would be like \"2211\",Now both the strings are same and it will increase our result,but thats not true. So thats why we put a special char between every number.\\n3. After apply the logic the strings look like this row-wise=\"2@2@1@1\" col-wise=\"22@1@1\" ,now both are not same.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:Brute force->$$O(n^3)$$\\n                  Optimal approach->$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ for storing the rows in a map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` c++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        unordered_map<string,int> map;\\n        for(vector<int> row:grid){\\n            string res=\"\";\\n            for(int ele:row){\\n                res+=to_string(ele);\\n                res+=\\'#\\';\\n            }\\n            map[res]++;\\n        }\\n        for(int j=0;j<grid[0].size();j++){\\n            string res=\"\"; \\n            for(int i=0;i<grid.size();i++){\\n                res+=to_string(grid[i][j]);\\n                res+=\\'#\\';\\n            }\\n            ans+=map[res];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> map=new HashMap<>();\\n        int ans=0;\\n        for(int []row:grid){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i:row){\\n                sb.append(i).append(\\'#\\');\\n            }\\n            map.put(sb.toString(),map.getOrDefault(sb.toString(),0)+1);\\n        }\\n        for(int j=0;j<grid[0].length;j++){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i=0;i<grid.length;i++){\\n                sb.append(grid[i][j]).append(\\'#\\');\\n            }\\n            ans+=map.getOrDefault(sb.toString(),0);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**If you enjoyed the solution \\uD83D\\uDE01, an upvote would be greatly appreciated! Your support motivates me to share more helpful solutions. Thank you!**",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "``` c++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        unordered_map<string,int> map;\\n        for(vector<int> row:grid){\\n            string res=\"\";\\n            for(int ele:row){\\n                res+=to_string(ele);\\n                res+=\\'#\\';\\n            }\\n            map[res]++;\\n        }\\n        for(int j=0;j<grid[0].size();j++){\\n            string res=\"\"; \\n            for(int i=0;i<grid.size();i++){\\n                res+=to_string(grid[i][j]);\\n                res+=\\'#\\';\\n            }\\n            ans+=map[res];\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> map=new HashMap<>();\\n        int ans=0;\\n        for(int []row:grid){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i:row){\\n                sb.append(i).append(\\'#\\');\\n            }\\n            map.put(sb.toString(),map.getOrDefault(sb.toString(),0)+1);\\n        }\\n        for(int j=0;j<grid[0].length;j++){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i=0;i<grid.length;i++){\\n                sb.append(grid[i][j]).append(\\'#\\');\\n            }\\n            ans+=map.getOrDefault(sb.toString(),0);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631695,
                "title": "no-map-no-trie-two-o-n-3-approach-c",
                "content": "# Intuition and Approach\\nWe are Simply creating a new vector<vector<string>> and then storing elements in it column-wise and rowWise\\nso now we have two vectors gc-gridColumnWise , gr-gridRowWise\\n\\nwe iterate through them and equate them to see if any pairs of vector is same in both of them\\n# Complexity\\n- Time complexity:O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code - Less than O(n^3)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        int n=g.size();\\n        vector<string> gc,gr;\\n\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[j][i]);\\n                s+=\"-\";\\n            }\\n            gc.push_back(s);\\n        }\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[i][j]);\\n                s+=\"-\";\\n            }\\n            gr.push_back(s);\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code - O(n^3)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& gr) {\\n        vector<vector<int>> gc;\\n        int n=gr.size();\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> v;\\n            for(int j=0;j<n;j++){\\n                v.push_back(gr[j][i]); // columnWise pushing\\n            }\\n            gc.push_back(v);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        int n=g.size();\\n        vector<string> gc,gr;\\n\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[j][i]);\\n                s+=\"-\";\\n            }\\n            gc.push_back(s);\\n        }\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[i][j]);\\n                s+=\"-\";\\n            }\\n            gr.push_back(s);\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& gr) {\\n        vector<vector<int>> gc;\\n        int n=gr.size();\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> v;\\n            for(int j=0;j<n;j++){\\n                v.push_back(gr[j][i]); // columnWise pushing\\n            }\\n            gc.push_back(v);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631010,
                "title": "easy-to-understand-c-solution-python-solution-fastest",
                "content": "# Approach : Map\\n<!-- Describe your approach to solving the problem. -->\\n# Code 1\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int ans=0;\\n        \\n        map<vector<int> ,int> mp;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            mp[grid[i]]++;\\n            \\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            vector<int> v;\\n            \\n            for(int j=0;j<grid.size();j++)\\n                v.push_back(grid[j][i]);\\n            \\n            ans+=mp[v];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n# Approach : Brute Force\\n<!-- Describe your approach to solving the problem. -->\\n# Code 2\\n```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i]==ans[j])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# Approach : Simple Comparison { Python}\\n<!-- Describe your approach to solving the problem. -->\\n# Code 3\\n```\\n\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        ans = 0 \\n        for j in range(len(grid)):\\n            column = []\\n            for row in grid:\\n                column.append(row[j])\\n            ans+= grid.count(column) # count how many rows equal to this column\\n            \\n        return ans \\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Hash Table",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int ans=0;\\n        \\n        map<vector<int> ,int> mp;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            mp[grid[i]]++;\\n            \\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            vector<int> v;\\n            \\n            for(int j=0;j<grid.size();j++)\\n                v.push_back(grid[j][i]);\\n            \\n            ans+=mp[v];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i]==ans[j])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\n\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        ans = 0 \\n        for j in range(len(grid)):\\n            column = []\\n            for row in grid:\\n                column.append(row[j])\\n            ans+= grid.count(column) # count how many rows equal to this column\\n            \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564106,
                "title": "beat-100-o-n-2-optimal-solution-true-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use hash map for most problems of *finding the number of pairs*.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe tricky part here is that we are dealing with rows and column. The rows are already `vector<int>`. We can dump columns into `vector<int>` as well and use a custom hash function for it.\\n\\n**DO NOT USE `std::map` FOR HASH MAP USAGE CASES**\\n`std::map` is both suboptimal in big O and practically quite slow.\\n\\n# Better Solution\\nI added another [solution](https://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/) that is an improved version of this one by not copying any data.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n# Code\\n```\\nstruct VectorHash {\\n  int operator()(const vector<int> &v) const {\\n    uint hash = v.size();\\n    for(int x : v) {\\n        hash ^= x + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<vector<int>, int, VectorHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      vector<int> key(N);\\n      for (int r = 0; r < N; ++r) {\\n        key[r] = grid[r][c];\\n      }\\n      ++counts[key];\\n    }\\n    int answer = 0;\\n    for (const vector<int>& row : grid) {\\n      answer += counts[row];\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nstruct VectorHash {\\n  int operator()(const vector<int> &v) const {\\n    uint hash = v.size();\\n    for(int x : v) {\\n        hash ^= x + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<vector<int>, int, VectorHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      vector<int> key(N);\\n      for (int r = 0; r < N; ++r) {\\n        key[r] = grid[r][c];\\n      }\\n      ++counts[key];\\n    }\\n    int answer = 0;\\n    for (const vector<int>& row : grid) {\\n      answer += counts[row];\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473341,
                "title": "easy-solution-using-2-maps",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint equalPairs(vector<vector<int>>& grid) {\\n\\t\\t\\tmap<vector<int>,int> row;\\n\\t\\t\\tmap<vector<int>,int> col;\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tvector<int> data;\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t\\tdata.push_back(grid[i][j]);\\n\\t\\t\\t\\trow[data]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tvector<int> data;\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t\\tdata.push_back(grid[j][i]);\\n\\t\\t\\t\\tcol[data]++;\\n\\t\\t\\t}\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor(auto x: row){\\n\\t\\t\\t\\tif(col.find(x.first)!=col.end())\\n\\t\\t\\t\\t\\tres+=(x.second*col[x.first]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint equalPairs(vector<vector<int>>& grid) {\\n\\t\\t\\tmap<vector<int>,int> row;\\n\\t\\t\\tmap<vector<int>,int> col;\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tvector<int> data;\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t\\tdata.push_back(grid[i][j]);\\n\\t\\t\\t\\trow[data]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2344176,
                "title": "c-easy-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n          mp[grid[i]]++;  \\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        { \\n            vector<int>chk;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n            chk.push_back(grid[j][i]);\\n            ans+=mp[chk];\\n            }\\n        }\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n          mp[grid[i]]++;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2324818,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int EqualPairs(int[][] grid)\\n    {\\n        var count = 0;\\n        var dic = new Dictionary<string, int>();\\n        \\n        var n = grid.Length;\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Empty;\\n            for (var j = 0; j < n; j++)\\n                s += Convert.ToString(grid[j][i]) + \",\";\\n\\n            if (dic.ContainsKey(s))\\n                dic[s] += 1;\\n            else\\n                dic.Add(s, 1);\\n        }\\n        \\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Join(\",\", grid[i].Select(j => j.ToString()).ToArray()) + \",\";\\n            count += dic.ContainsKey(s) ? dic[s] : 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int EqualPairs(int[][] grid)\\n    {\\n        var count = 0;\\n        var dic = new Dictionary<string, int>();\\n        \\n        var n = grid.Length;\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Empty;\\n            for (var j = 0; j < n; j++)\\n                s += Convert.ToString(grid[j][i]) + \",\";\\n\\n            if (dic.ContainsKey(s))\\n                dic[s] += 1;\\n            else\\n                dic.Add(s, 1);\\n        }\\n        \\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Join(\",\", grid[i].Select(j => j.ToString()).ToArray()) + \",\";\\n            count += dic.ContainsKey(s) ? dic[s] : 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324772,
                "title": "python3-freq-table-o-n-2",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/d61cd3ed09bbf59fd619802a6e861a516ec17094) for solutions of weekly 303. \\n\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        freq = Counter(tuple(row) for row in grid)\\n        return sum(freq[tuple(col)] for col in zip(*grid))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        freq = Counter(tuple(row) for row in grid)\\n        return sum(freq[tuple(col)] for col in zip(*grid))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324671,
                "title": "c-equal-row-and-column-pairs-easy-solution",
                "content": "```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(); // grid size \\n        \\n        int ans = 0; // final answer \\n        \\n        for (int i = 0; i < n; i++){\\n            // ith row \\n            for (int j = 0; j < n; j++){\\n                // jth column \\n                int count = 0; \\n                \\n                for (int k = 0; k < n; k++){\\n                    if (grid[i][k] == grid[k][j]) count++;\\n                }\\n                \\n                // check if row and column are equal \\n                if (count == n) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(); // grid size \\n        \\n        int ans = 0; // final answer \\n        \\n        for (int i = 0; i < n; i++){\\n            // ith row \\n            for (int j = 0; j < n; j++){\\n                // jth column \\n                int count = 0; \\n                \\n                for (int k = 0; k < n; k++){\\n                    if (grid[i][k] == grid[k][j]) count++;\\n                }\\n                \\n                // check if row and column are equal \\n                if (count == n) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731477,
                "title": "java-easy-solution-using-hashmap-and-string-patterns",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> map1 = new HashMap<>();\\n        HashMap<String, Integer> map2 = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[i][j]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map1.put(str, map1.getOrDefault(str, 0) + 1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[j][i]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map2.put(str, map2.getOrDefault(str, 0) + 1);\\n        }\\n        int ans = 0;\\n        for(String s : map1.keySet()) {\\n            if(map2.containsKey(s)) {\\n                ans += map1.get(s) * map2.get(s);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> map1 = new HashMap<>();\\n        HashMap<String, Integer> map2 = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[i][j]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map1.put(str, map1.getOrDefault(str, 0) + 1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[j][i]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map2.put(str, map2.getOrDefault(str, 0) + 1);\\n        }\\n        int ans = 0;\\n        for(String s : map1.keySet()) {\\n            if(map2.containsKey(s)) {\\n                ans += map1.get(s) * map2.get(s);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636433,
                "title": "simple-easy-approach-with-beats-52-42-in-runtime-and-95-31-in-memory",
                "content": "# Intuition\\nVery simple logic I followed, go ahead with the checking untill you got diffrent numbers.\\n\\n# Approach\\n1. Take two pointers for the row and column [ ex: `r`& `c` ]\\n2. Start a while loop for untill your pointer for row and column touches the length of the grid means `n`.\\n3. Take another two pointers for itreating the rows and cols [ ex: `i` & `j` ]\\n4. Check `grid[r][i] === grid[j][c]`, untill it dismatch, go ahead and if you find that your `i` & `j` reaches `n` means grid\\'s length then `increment/++` the count of the equal Row and Cols\\n5. After this, just do `column++ / c++`. And If you reach in the last column then restart the column number from 0 like `c=0` and increase the value of the row `row++ / r++`\\n6. Now you\\'ve the no of equal rows and cols, just return it outside of your loops;\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n![Beats.PNG](https://assets.leetcode.com/users/images/e3ea9158-de0d-4065-94ce-3b81c9ca9ba5_1686729479.15648.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function (grid) {\\n    const n = grid.length;\\n    let equalCount = 0;\\n    let r = 0, c = 0;\\n    while (r < n && c < n) {\\n        let i = 0, j = 0;\\n        while (grid[r][i] === grid[j][c]) {\\n            i++;\\n            j++;\\n            if (i === n && j === n) {\\n                equalCount++;\\n                break;\\n            }\\n        }\\n        c++;\\n        if(c === n){\\n            c = 0;\\n            r++;\\n        }\\n    }\\n    return equalCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function (grid) {\\n    const n = grid.length;\\n    let equalCount = 0;\\n    let r = 0, c = 0;\\n    while (r < n && c < n) {\\n        let i = 0, j = 0;\\n        while (grid[r][i] === grid[j][c]) {\\n            i++;\\n            j++;\\n            if (i === n && j === n) {\\n                equalCount++;\\n                break;\\n            }\\n        }\\n        c++;\\n        if(c === n){\\n            c = 0;\\n            r++;\\n        }\\n    }\\n    return equalCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3634899,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0, n = grid.size();\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int fl = 1;\\n                for (int i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        fl = 0;\\n                        break;\\n                    }\\n                }\\n                ans += fl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0, n = grid.size();\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int fl = 1;\\n                for (int i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        fl = 0;\\n                        break;\\n                    }\\n                }\\n                ans += fl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634864,
                "title": "c-u16string-hashing-vs-trie-100-time-58ms-85-space-24-1mb",
                "content": "My first intuition was that it would be rather easy to hash each row, count the frequency of each hash and then do the for each column, adding the frequency previously found to the result for each match.\\n\\nIn order to do so, a normal `string` would not cut it, since `char`s go with `7` bits and cut out the rest, so we will get tons of collisions from that. But with `16` bits, we can cover almost completely the full range (to go up to `10e5` we would have needed `17`, but with `16` we do well enough to avoid any collisions with all the test cases, although you might argue that a few such cases might be created to let us slip with this approach).\\n\\nWe will start `using` `u16String` as our `hashType`, then declaring our usual support variables:\\n* `hashFreq` will map hashes to their respective frequence;\\n* `res` is our usual accumulator variable, initially set to `0`;\\n* `len` will store the size of the provided `grid`;\\n* `tmp` is our helper string, preset to be `len` characters.\\n\\nWe will start parsing the rows first and for each `row` in `grid`, we will:\\n* declare our writer pointer `w` with initial value of `0`;\\n* loop through each value `c` in `row` and:\\n    * write it in `tmp[w]`;\\n    * advance `w` by `1`, ready to write in the next cell;\\n* increase `hashFreq[tmp]` by `1`.\\n\\nWith our hashes so computed for each row, time to do the same for each column `x` in grid and we will:\\n* loop through each row `y` in `grid` and write `grid[y][c]` in `tmp[y]`;\\n* assign the result of `hashFreq.find(tmp)` to `it`;\\n* if we ever found such a value (ie: `it != end(hashFreq)`), we will then increase `res` by that value (ie: `it->second`).\\n\\nOnce done, we can finally `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```cpp\\nusing hashType = u16string;\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        unordered_map<hashType, int> hashFreq;\\n        int res = 0, len = grid.size();\\n        hashType tmp(len, \\'*\\');\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating the row hash\\n            int w = 0;\\n            for (int c: row) tmp[w++] = c;\\n            // storing the hash\\n            hashFreq[tmp]++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // creating the column hash\\n            for (int y = 0; y < len; y++) tmp[y] = grid[y][x];\\n            // checking if we found the same hash before\\n            auto it = hashFreq.find(tmp);\\n            if (it != end(hashFreq)) res += it->second;\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Brag\\n![image.png](https://assets.leetcode.com/users/images/30054297-a35b-49b2-8dc1-25591b39578a_1686687724.9152997.png)\\n\\n\\nNext I tried my other idea, a `Trie` approach, since this again goes well when you need to check your matches in a given dictionary and in a way I was doing that with my string hashing, but could have been done MAYBE better with something like this DS.\\n\\nIn this approach we will create a `Trie` `struct` which will just have two properties:\\n* `matches`, initially set to `0`, will store all the matches we have for a given chain (it will be increased only for the end-of-chain nodes);\\n* `children` is a set of `bucketSize` pointers we will use to connect each node to its descendents on a chain.\\n\\nIn our main function we will proceed similarly to the previous approach, declaring a first `Trie` node `root` and a `Trie` pointer `curr` instead of `tmp`.\\n\\nFor the rows we will then proceed for each character `row` and:\\n* `reset` `curr` to be `root`;\\n* for each value `c`, we will:\\n    * try to get its modulo `bucketSize` by consistently subtracting it `while` `c >= bucketSize` (see the third solution here for my thoughts on actually using `%`);\\n    * check if we do not have `curr->children[c]` and if so, we will create it as a new `Trie` node;\\n    * advance `curr` to be `curr->children[c]`;\\n* finally, having reached the last node of this chain, we will increase `curr->matches` by `1`.\\n\\nAgain, we will proceed specularly for each column, getting `grid[y][x]` as `c` and with two sole differences:\\n* whenever we do not find a node to advance next (ie: `curr->children[c] == NULL`) we will `break`;\\n* at the end of each inner loop, we will increase `res` by `curr->matches` (which is going to be `0` every time we hit `break` before reaching the end of a previously created chain).\\n\\nTweaking `bucketSize` has a MASSIVE effect on performance and turns out using a small enough number (initially I tried `1337`, but quickly run out of memory; it was slow but working with `137` and rather fast for other significantly smaller values, while still burning way more memory than the string hashing approach):\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n- \\n```cpp\\nconstexpr int bucketSize = 27;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAs a proof of how expensive is to compute a modulo, this alternative version while I don\\'t just use repeated subtraction to reduce all the numbers above `bucketSize` ran actually a bit slower after several tests (I am sure it would be the opposite with `grid` being populated with larger numbers, but that is really telling):\\n\\n```cpp\\nconstexpr int bucketSize = 19;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                c %= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                c %= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNeedless to say, I wanted to try also with a hashmap for `children`; boring, and way slower and more inefficient than expected:\\n\\n```cpp\\nstruct Trie {\\n    int matches = 0;\\n    unordered_map<int, Trie*> children;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) children[c] = new Trie();\\n                curr = children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) break;\\n                curr = children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Trie",
                    "Hash Function"
                ],
                "code": "```cpp\\nusing hashType = u16string;\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        unordered_map<hashType, int> hashFreq;\\n        int res = 0, len = grid.size();\\n        hashType tmp(len, \\'*\\');\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating the row hash\\n            int w = 0;\\n            for (int c: row) tmp[w++] = c;\\n            // storing the hash\\n            hashFreq[tmp]++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // creating the column hash\\n            for (int y = 0; y < len; y++) tmp[y] = grid[y][x];\\n            // checking if we found the same hash before\\n            auto it = hashFreq.find(tmp);\\n            if (it != end(hashFreq)) res += it->second;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int bucketSize = 27;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int bucketSize = 19;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                c %= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                c %= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nstruct Trie {\\n    int matches = 0;\\n    unordered_map<int, Trie*> children;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) children[c] = new Trie();\\n                curr = children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) break;\\n                curr = children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633184,
                "title": "easy-java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                s.append(grid[i][j]);\\n                s.append(\"+\");\\n            }\\n            String ss = s.toString();\\n            map.put(ss, map.getOrDefault(ss, 0) + 1);\\n        }\\n        int c = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\"+\");\\n            }\\n            String ss = sb.toString();\\n            if(map.containsKey(ss)){\\n                c += map.get(ss);\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                s.append(grid[i][j]);\\n                s.append(\"+\");\\n            }\\n            String ss = s.toString();\\n            map.put(ss, map.getOrDefault(ss, 0) + 1);\\n        }\\n        int c = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\"+\");\\n            }\\n            String ss = sb.toString();\\n            if(map.containsKey(ss)){\\n                c += map.get(ss);\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632259,
                "title": "simple-and-explained-solution",
                "content": "\\n\\n# Approach\\n1. Initialize a variable count to keep track of the number of equal pairs.\\n2. Iterate over each row in the grid.\\n3. For each row, iterate over each column in the grid.\\n4. Compare the current row with the corresponding column using the getColumn helper function.\\n5. If the row and column are equal (i.e., they contain the same elements in the same order), increment the count variable.\\n6. After iterating over all rows and columns, return the final value of count.\\n\\nThe getColumn helper function extracts the elements from a specific column in the grid and returns them as a separate vector. It loops over each row and retrieves the element at the specified column index, constructing a vector representing the column.\\n\\nBy comparing each row with each corresponding column, the solution correctly counts the number of pairs where a row and column are equal.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int count = 0;\\n\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (grid[row] == getColumn(grid, col))\\n                    count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\nprivate:\\n    vector<int> getColumn(const vector<vector<int>>& grid, int col) {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++) {\\n            column.push_back(grid[i][col]);\\n        }\\n        return column;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int count = 0;\\n\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (grid[row] == getColumn(grid, col))\\n                    count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\nprivate:\\n    vector<int> getColumn(const vector<vector<int>>& grid, int col) {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++) {\\n            column.push_back(grid[i][col]);\\n        }\\n        return column;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631921,
                "title": "java-python-most-easy-approach-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thoughts of solving this problem was to mantain a data structure to store the value vertically and then compare it horizontally\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMap data structure is used to store the value of array in form of String along with their counts i.e. how many times they occur vertically. Then same approach is used while traversing horizontally and after each iteration value of String is fetched from map and added to count.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String,Integer> map=new HashMap<>();\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for( int j=0;j<m;j++){\\n            String s=\"\";\\n            for(int i=0;i<n;i++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            map.put(s,map.getOrDefault(s,0)+1);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            String s=\"\";\\n            for(int j=0;j<m;j++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            System.out.println(s);\\n            if(map.containsKey(s)==true){\\n                System.out.println(s+\" \"+map.get(s));\\n                cnt+=map.get(s);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        map = {}\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        for j in range(m):\\n            s = \"\"\\n            for i in range(n):\\n                s += str(grid[i][j]) + \",\"\\n            map[s] = map.get(s, 0) + 1\\n        \\n        cnt = 0\\n        for i in range(n):\\n            s = \"\"\\n            for j in range(m):\\n                s += str(grid[i][j]) + \",\"\\n            if s in map:\\n                cnt += map[s]\\n        \\n        return cnt\\n\\n```\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Array",
                    "Hash Table"
                ],
                "code": "```java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String,Integer> map=new HashMap<>();\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for( int j=0;j<m;j++){\\n            String s=\"\";\\n            for(int i=0;i<n;i++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            map.put(s,map.getOrDefault(s,0)+1);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            String s=\"\";\\n            for(int j=0;j<m;j++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            System.out.println(s);\\n            if(map.containsKey(s)==true){\\n                System.out.println(s+\" \"+map.get(s));\\n                cnt+=map.get(s);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        map = {}\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        for j in range(m):\\n            s = \"\"\\n            for i in range(n):\\n                s += str(grid[i][j]) + \",\"\\n            map[s] = map.get(s, 0) + 1\\n        \\n        cnt = 0\\n        for i in range(n):\\n            s = \"\"\\n            for j in range(m):\\n                s += str(grid[i][j]) + \",\"\\n            if s in map:\\n                cnt += map[s]\\n        \\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631670,
                "title": "doubt-regarding-hashmap-solution",
                "content": "Hi, I have attached the reference solution below (Not written by me)\\nWhen we store a vector (or vector converted to string), it\\'s complexity shouldn\\'t be O(N), but the official solution says it\\'s O(1), as they have considered the TC to be O(N^2)- O(N) [Row]* O(N) [Column]* O(1) inserting into map. \\n\\nIn my opinion, it\\'s complexity should be O(N^3) as inserting a string(or vector) into map also takes the size of string(or vector) complexity i.e O(S.size() ==n(in this case), so TC should be O(N^3).\\n\\nCorrect me if I am wrong, thanks!\\n\\n```\\nint equalPairs(vector<vector<int>> &grid)\\n        {\\n            int ans = 0, n = grid.size();\\n            map<vector<int>, int> mp;\\n            for (auto row: grid)\\n                ++mp[row];\\n\\n            for (int i = 0; i < n; ++i)\\n            {\\n                vector<int> v(n);\\n                for (int j = 0; j < n; ++j)\\n                    v[j] = grid[j][i];\\n                \\n                if (mp.find(v) != mp.end())\\n                    ans += mp[v];\\n            }\\n\\n            return ans;\\n        }",
                "solutionTags": [
                    "C"
                ],
                "code": "Hi, I have attached the reference solution below (Not written by me)\\nWhen we store a vector (or vector converted to string), it\\'s complexity shouldn\\'t be O(N), but the official solution says it\\'s O(1), as they have considered the TC to be O(N^2)- O(N) [Row]* O(N) [Column]* O(1) inserting into map. \\n\\nIn my opinion, it\\'s complexity should be O(N^3) as inserting a string(or vector) into map also takes the size of string(or vector) complexity i.e O(S.size() ==n(in this case), so TC should be O(N^3).\\n\\nCorrect me if I am wrong, thanks!\\n\\n```\\nint equalPairs(vector<vector<int>> &grid)\\n        {\\n            int ans = 0, n = grid.size();\\n            map<vector<int>, int> mp;\\n            for (auto row: grid)\\n                ++mp[row];\\n\\n            for (int i = 0; i < n; ++i)\\n            {\\n                vector<int> v(n);\\n                for (int j = 0; j < n; ++j)\\n                    v[j] = grid[j][i];\\n                \\n                if (mp.find(v) != mp.end())\\n                    ans += mp[v];\\n            }\\n\\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3631552,
                "title": "clean-java-solution",
                "content": "\\n# Approach\\nLoop on each row, col index; then compare each element in the row with the col. \\nEx(grid[row][i] == grid[i][column])\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^3)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        for(int i =0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++)\\n                if (checkIfEqual(i,j,grid)) count++;    \\n        return count;\\n    }\\n\\n    public boolean checkIfEqual(int m, int n,int[][] grid){\\n        for(int i = 0;i<grid.length;i++)\\n            if(grid[m][i]!=grid[i][n]) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        for(int i =0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++)\\n                if (checkIfEqual(i,j,grid)) count++;    \\n        return count;\\n    }\\n\\n    public boolean checkIfEqual(int m, int n,int[][] grid){\\n        for(int i = 0;i<grid.length;i++)\\n            if(grid[m][i]!=grid[i][n]) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631299,
                "title": "finding-the-transpose",
                "content": "### Find the transpose of given grid and solve by comparing each row of grid with each col of the transpose of that grid matrix.\\n---\\n# Python Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        matrix = []\\n        for i in range(n):\\n            rows = []\\n            for j in range(n):\\n                rows.append(grid[j][i])\\n            matrix.append(rows)\\n        count = 0\\n        for i in grid:\\n            for k in matrix:\\n                if i == k:\\n                    count+=1\\n        return count\\n        \\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.\\uD83D\\uDC4D*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        matrix = []\\n        for i in range(n):\\n            rows = []\\n            for j in range(n):\\n                rows.append(grid[j][i])\\n            matrix.append(rows)\\n        count = 0\\n        for i in grid:\\n            for k in matrix:\\n                if i == k:\\n                    count+=1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631034,
                "title": "c-fast-code-88-beat-most-optimal-approach-o-n-2-updated-97-beat-correct-solution",
                "content": "We have to compare rows and arrays, instead of comparing element by element can we do it in O(1) operation?\\nHere in this approach i have used a pair that uniquely identifies each array, the first value of pair is the addition of each value multiplied by its index and the second value is sum of the array.\\nComparing based on this value, we can find the ans in N^2 time instead of N^3 time.\\n(88% beat code)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[i][j];\\n                val += grid[i][j]*j;\\n            }\\n            mp[{val,s}]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[j][i];\\n                val += grid[j][i]*j;\\n            }\\n            if(mp.count({val,s})) ans+=mp[{val,s}];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(N*(log N + N)) = O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Updated:\\nThis approach fails for some test cases that are not present in the leetcode test cases, for ex  [[2,3,4],[6,1,7],[8,5,9]]\\nThanks to @yjian012 for the correction.\\nSo, the correct approach would be use whole vector as key. The code for the same is below (97% beat)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<vector<int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> x;\\n            for(int j=0;j<n;j++){\\n                x.push_back(grid[j][i]);\\n            }\\n            if(mp.count(x)) ans+=mp[x];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[i][j];\\n                val += grid[i][j]*j;\\n            }\\n            mp[{val,s}]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[j][i];\\n                val += grid[j][i]*j;\\n            }\\n            if(mp.count({val,s})) ans+=mp[{val,s}];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<vector<int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> x;\\n            for(int j=0;j<n;j++){\\n                x.push_back(grid[j][i]);\\n            }\\n            if(mp.count(x)) ans+=mp[x];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631004,
                "title": "2-liner-beats-93-simple-python-code-using-zip",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`zip` will allow us to easily convert the grid into an iterable column\\n\\nWe simply use tuples to store the rows into the hash map and we then check the column tuples against the row hash map and count the number of matches.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$\\n When we construct the initial `rows` hashmap it is $O(n^2)$ since we go through each row and to construct each tuple $O(n)$(? im not sure)\\n\\nLikewise it is $O(n^2)$ for when we are checking and also the time complexity of `zip` (If all the tuple conversion time complexity is $O(n)$)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDepends on the implementation of the hash map\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = defaultdict(int)\\n\\n        for row in grid:\\n            rows[tuple(row)] += 1\\n        \\n        match = 0\\n        for col in zip(*grid):\\n            if col in rows:\\n                match += rows[col]\\n        \\n        return match\\n```\\n\\n## 2 Liner\\nUsing `Counter` as well as list comprehension we can get a significantly shorter piece of code that can run fast\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = Counter([tuple(row) for row in grid])\\n        return sum([rows[col] for col in zip(*grid)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = defaultdict(int)\\n\\n        for row in grid:\\n            rows[tuple(row)] += 1\\n        \\n        match = 0\\n        for col in zip(*grid):\\n            if col in rows:\\n                match += rows[col]\\n        \\n        return match\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = Counter([tuple(row) for row in grid])\\n        return sum([rows[col] for col in zip(*grid)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630966,
                "title": "rust-elixir-hash-map-solution",
                "content": "Elixir\\'s code is very simple for doing this kind of operations.\\n# Code\\n```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut hash = HashMap::<&[i32], i32>::new();\\n        for row in grid.iter() {\\n            *hash.entry(row).or_insert(0) += 1;\\n        }\\n        let mut ans = 0;\\n        let mut v = vec![0; grid.len()];\\n        for j in 0..grid.len() {\\n            for i in 0..grid.len() {\\n                v[i] = grid[i][j];\\n            }\\n            if let Some(&x) = hash.get(&v[..]) {\\n                ans += x;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\\n```Elixir []\\ndefmodule Solution do\\n  @spec equal_pairs(grid :: [[integer]]) :: integer\\n  def equal_pairs(grid) do\\n    Enum.frequencies(grid)\\n    |> then(fn map ->\\n      Enum.zip_with(grid, &(&1))\\n      |> Enum.map(&(Map.get(map, &1, 0)))\\n    end)\\n    |> Enum.sum()\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Hash Table"
                ],
                "code": "```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut hash = HashMap::<&[i32], i32>::new();\\n        for row in grid.iter() {\\n            *hash.entry(row).or_insert(0) += 1;\\n        }\\n        let mut ans = 0;\\n        let mut v = vec![0; grid.len()];\\n        for j in 0..grid.len() {\\n            for i in 0..grid.len() {\\n                v[i] = grid[i][j];\\n            }\\n            if let Some(&x) = hash.get(&v[..]) {\\n                ans += x;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\n```Elixir []\\ndefmodule Solution do\\n  @spec equal_pairs(grid :: [[integer]]) :: integer\\n  def equal_pairs(grid) do\\n    Enum.frequencies(grid)\\n    |> then(fn map ->\\n      Enum.zip_with(grid, &(&1))\\n      |> Enum.map(&(Map.get(map, &1, 0)))\\n    end)\\n    |> Enum.sum()\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3630965,
                "title": "c-best-solution-2-approach-easy-to-understand",
                "content": "\\n# Approach\\nBrute force\\n\\n# Code\\n```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vvi row, col;\\n        for(auto it : grid) row.push_back(it);\\n        for(int i=0; i<n; i++)  {\\n            vi temp;\\n            for(int j=0; j<n; j++)  \\n                temp.push_back(grid[j][i]);\\n            col.push_back(temp);\\n        }\\n\\n        int cnt = 0;\\n        for(auto it : row) for(auto x : col)\\n            if(x == it) cnt++;\\n\\n        return cnt;\\n    }\\n};\\n```\\n\\n# Approach\\nNo extra Space two pointer\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), cnt = 0;\\n        for(int i=0; i<n; i++)  {\\n            for(int j=0; j<n; j++)  {\\n                int k = 0;\\n                while(k < n)    {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    k++;\\n                }\\n                if(k == n)  cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vvi row, col;\\n        for(auto it : grid) row.push_back(it);\\n        for(int i=0; i<n; i++)  {\\n            vi temp;\\n            for(int j=0; j<n; j++)  \\n                temp.push_back(grid[j][i]);\\n            col.push_back(temp);\\n        }\\n\\n        int cnt = 0;\\n        for(auto it : row) for(auto x : col)\\n            if(x == it) cnt++;\\n\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), cnt = 0;\\n        for(int i=0; i<n; i++)  {\\n            for(int j=0; j<n; j++)  {\\n                int k = 0;\\n                while(k < n)    {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    k++;\\n                }\\n                if(k == n)  cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630907,
                "title": "c-easy-implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), res = 0;\\n        for (int i = 0; i < n; i += 1)\\n            for (int j = 0; j < n; j += 1) {\\n                int ok = 1;\\n                for (int k = 0; k < n and ok; k += 1)\\n                    ok = grid[i][k] == grid[k][j];\\n                res += ok;\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), res = 0;\\n        for (int i = 0; i < n; i += 1)\\n            for (int j = 0; j < n; j += 1) {\\n                int ok = 1;\\n                for (int k = 0; k < n and ok; k += 1)\\n                    ok = grid[i][k] == grid[k][j];\\n                res += ok;\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630785,
                "title": "short-ruby-solution-with-explanation",
                "content": "# Intuition\\nCount how often each row appears.  Total the number of rows matching each column.\\n\\n# Approach\\n1. Create a hash where rows are keys and their frequencies are values.  (We\\'re using a hash instead of a set because a row can appear multiple times.)\\n2. Initialize total to 0.\\n3. Transpose the grid to iterate through the columns.  For each column, add the number of matching rows to total.\\n4. Return the total.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\ndef equal_pairs(grid)\\n    rows = grid.tally\\n    total = 0\\n\\n    grid.transpose.each do |col|\\n        total += rows[col] if rows[col]\\n    end\\n\\n    total\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef equal_pairs(grid)\\n    rows = grid.tally\\n    total = 0\\n\\n    grid.transpose.each do |col|\\n        total += rows[col] if rows[col]\\n    end\\n\\n    total\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3586137,
                "title": "golang-map-solution-without-using-strings-conversion-fast-and-memory-effective",
                "content": "# Intuition\\nTo find number of pairs it is enough to count all variants for rows, and then compare it with columns\\n# Approach\\nTo faster comparison we use golang map. We can not use slice as key, so replace it with array $[200]int$ ( other variant is to convert slice in some string). We add every row in map, and then we run through all columns and look for it in map.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ to build all columns\\n\\n- Space complexity:\\n $$O(n)$$ - we use map with mostly $n$ different keys\\n\\n# Code\\n```\\nfunc equalPairs(grid [][]int) int {\\n    n:=len(grid)\\n    m:=make( map[[200]int]int)\\n    arr:=[200]int{}\\n    for i:=0;i<n;i++{\\n        copy(arr[:],grid[i])\\n        m[arr]++\\n    }\\n    res:=0\\n\\n    for i:=0;i<n;i++{\\n        arr = [200]int{}\\n        for j:=0;j<n;j++{ // copy column to arr\\n            arr[j]=grid[j][i]\\n        }\\n        if v,ok:=m[arr];ok{\\n            res+=v\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nfunc equalPairs(grid [][]int) int {\\n    n:=len(grid)\\n    m:=make( map[[200]int]int)\\n    arr:=[200]int{}\\n    for i:=0;i<n;i++{\\n        copy(arr[:],grid[i])\\n        m[arr]++\\n    }\\n    res:=0\\n\\n    for i:=0;i<n;i++{\\n        arr = [200]int{}\\n        for j:=0;j<n;j++{ // copy column to arr\\n            arr[j]=grid[j][i]\\n        }\\n        if v,ok:=m[arr];ok{\\n            res+=v\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552258,
                "title": "golang-trie",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\ntype Trie struct {\\n    Count int\\n    Children map[int]*Trie\\n}\\n\\nfunc equalPairs(grid [][]int) int {\\n    root := &Trie{Children: make(map[int]*Trie)}\\n\\n    m := len(grid)\\n    n := len(grid[0])\\n\\n    // O(n) * O(m)\\n    for c := 0; c < n; c++ {\\n        insert(root, c, m, grid)\\n    }\\n\\n    count := 0\\n    // O(m) * O(n)\\n    for r := 0; r < m; r++ {\\n        count += search(root, r, n, grid)\\n    }\\n\\n    return count\\n}\\n\\n// O(m)\\nfunc insert(node *Trie, c, m int, grid [][]int) {\\n    for r := 0; r < m; r++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            node.Children[idx] = &Trie{Children: make(map[int]*Trie)}\\n        }\\n        node = node.Children[idx]\\n    }\\n    node.Count++\\n}\\n\\n// O(n)\\nfunc search(node *Trie, r, n int, grid [][]int) int {\\n    for c := 0; c < n; c++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            return 0\\n        }\\n        node = node.Children[idx]\\n    }\\n    return node.Count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Trie struct {\\n    Count int\\n    Children map[int]*Trie\\n}\\n\\nfunc equalPairs(grid [][]int) int {\\n    root := &Trie{Children: make(map[int]*Trie)}\\n\\n    m := len(grid)\\n    n := len(grid[0])\\n\\n    // O(n) * O(m)\\n    for c := 0; c < n; c++ {\\n        insert(root, c, m, grid)\\n    }\\n\\n    count := 0\\n    // O(m) * O(n)\\n    for r := 0; r < m; r++ {\\n        count += search(root, r, n, grid)\\n    }\\n\\n    return count\\n}\\n\\n// O(m)\\nfunc insert(node *Trie, c, m int, grid [][]int) {\\n    for r := 0; r < m; r++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            node.Children[idx] = &Trie{Children: make(map[int]*Trie)}\\n        }\\n        node = node.Children[idx]\\n    }\\n    node.Count++\\n}\\n\\n// O(n)\\nfunc search(node *Trie, r, n int, grid [][]int) int {\\n    for c := 0; c < n; c++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            return 0\\n        }\\n        node = node.Children[idx]\\n    }\\n    return node.Count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497467,
                "title": "c-easy-approach-brut-force-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,c=0,n=grid.size();\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                int k=0;\\n                while(k!=n && grid[i][k]==grid[k][j])\\n                {\\n                    k++;\\n                }\\n                if(k==n)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,c=0,n=grid.size();\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                int k=0;\\n                while(k!=n && grid[i][k]==grid[k][j])\\n                {\\n                    k++;\\n                }\\n                if(k==n)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420644,
                "title": "python3",
                "content": "![image.png](https://assets.leetcode.com/users/images/11c9dc60-d43c-47a3-98f7-2bbb206ba35f_1681579473.8935993.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count=0\\n        lst=[]\\n        for i in zip(*grid):\\n            lst.append(list(i))\\n        for i in range(len(lst)):\\n            for j in grid:\\n                if lst[i]==j:\\n                    count+=1\\n                else:\\n                    count+=0\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count=0\\n        lst=[]\\n        for i in zip(*grid):\\n            lst.append(list(i))\\n        for i in range(len(lst)):\\n            for j in grid:\\n                if lst[i]==j:\\n                    count+=1\\n                else:\\n                    count+=0\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282176,
                "title": "c-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, vector<int>> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]].push_back(i);\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col].size();\\n        }\\n        return sum;\\n\\n    }\\n};\\n```\\n\\nOr\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]]++;\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, vector<int>> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]].push_back(i);\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col].size();\\n        }\\n        return sum;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]]++;\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264514,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int > m ; \\n        int res = 0 ; \\n        for(int i = 0; i<grid.size();i++)\\n        {\\n            vector<int> curr ; \\n            for(int j = 0; j<grid.size();j++){\\n\\n            curr.push_back(grid[i][j]);\\n            }\\n           \\n           m[curr]++;\\n        }\\n        \\n     \\n        cout<<endl;\\n        for(int j = 0 ; j<grid.size();j++)\\n        {\\n            vector<int> temp; \\n            for(int i = 0 ; i< grid.size();i++)\\n            temp.push_back(grid[i][j]);\\n            \\n            if(m.find(temp)!=m.end())\\n            res += m[temp];\\n        }\\n        \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int > m ; \\n        int res = 0 ; \\n        for(int i = 0; i<grid.size();i++)\\n        {\\n            vector<int> curr ; \\n            for(int j = 0; j<grid.size();j++){\\n\\n            curr.push_back(grid[i][j]);\\n            }\\n           \\n           m[curr]++;\\n        }\\n        \\n     \\n        cout<<endl;\\n        for(int j = 0 ; j<grid.size();j++)\\n        {\\n            vector<int> temp; \\n            for(int i = 0 ; i< grid.size();i++)\\n            temp.push_back(grid[i][j]);\\n            \\n            if(m.find(temp)!=m.end())\\n            res += m[temp];\\n        }\\n        \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3239054,
                "title": "c-simple-clear-concise-easy-to-understand-single-hashmap-matrix-code-quality",
                "content": "\\n# Code\\n**Bruteforce:-**\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<string, int> rowmap;\\n        map<string, int> colmap;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int ans = 0;\\n        for (int i=0; i<row; i++) {\\n            string rows;\\n            string cols;\\n            for (int j=0; j<col; j++) {\\n                rows += to_string(grid[i][j]) + \"-\";\\n                cols += to_string(grid[j][i]) + \"-\";\\n            }\\n            rowmap[rows]++;\\n            colmap[cols]++;\\n        }\\n        for (auto &it:rowmap) {\\n            if (colmap.find(it.first) != colmap.end()) {\\n                ans += (it.second * colmap[it.first]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Optimized:-**\\n```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>, Integer> hashmap = new HashMap<>();\\n        int n = grid.length, ans = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> c = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                c.add(j, grid[i][j]);\\n            }\\n            hashmap.put(c, hashmap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> curr = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                curr.add(j, grid[j][i]);\\n            }\\n            ans += hashmap.getOrDefault(curr, 0);\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        hashmap = defaultdict(int)\\n        n, ans = len(grid), 0\\n\\n        for i in range(n):\\n            hashmap[str(grid[i])] += 1\\n        \\n        for i in range(n):\\n            curr = []\\n            for j in range(n):\\n                curr.append(grid[j][i])\\n            ans += hashmap[str(curr)]\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<string, int> rowmap;\\n        map<string, int> colmap;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int ans = 0;\\n        for (int i=0; i<row; i++) {\\n            string rows;\\n            string cols;\\n            for (int j=0; j<col; j++) {\\n                rows += to_string(grid[i][j]) + \"-\";\\n                cols += to_string(grid[j][i]) + \"-\";\\n            }\\n            rowmap[rows]++;\\n            colmap[cols]++;\\n        }\\n        for (auto &it:rowmap) {\\n            if (colmap.find(it.first) != colmap.end()) {\\n                ans += (it.second * colmap[it.first]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>, Integer> hashmap = new HashMap<>();\\n        int n = grid.length, ans = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> c = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                c.add(j, grid[i][j]);\\n            }\\n            hashmap.put(c, hashmap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> curr = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                curr.add(j, grid[j][i]);\\n            }\\n            ans += hashmap.getOrDefault(curr, 0);\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        hashmap = defaultdict(int)\\n        n, ans = len(grid), 0\\n\\n        for i in range(n):\\n            hashmap[str(grid[i])] += 1\\n        \\n        for i in range(n):\\n            curr = []\\n            for j in range(n):\\n                curr.append(grid[j][i])\\n            ans += hashmap[str(curr)]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169755,
                "title": "javascript-solution-with-hashmap",
                "content": "### Want to say thank you if you give me a thumbs up\\n###### this solution is $$O(n^2)$$ time and space, if I found more better solution I\\'ll come back and update it.\\n# Intuition\\n1. Question to find row has same value with column\\n2. We can use each row join as key, then  column join as value to check has same value with row\\n3. Here have issues\\n    >* **What if a row shows in 2 or more times**\\n     -> answer we set value as an array store two value [rowShowTime - 1, columnMetcahRowTimes]\\n    >* **What if we have [11,1] [1,11] when join they are all equal to 111 but 11,1 != 1,11**\\n    -> answer we join with \\',\\' so  [11,1] [1,11] will became \"11,1\" and \"1,11\"\\n\\n4. Then we just return result += hashMap.value(value[0] * value[1]) why * not +, because the value[0] is show times\\n\\n# Approach\\nHere we use hashMap\\n1. initial hashMap, then loop through grid assign to hashMap key as row.join(\\',\\') value = [0,0] if that key already exist value[0] += 1\\n2. loop through grid i = 0; i < grid[0].length; i++, because its grid, so each subarray has same length (we want each the column += eachRow[j][i] to get column sum).\\n    * let column = [] //use array not string because in js string is immutable, evertime string += 1 need to create a new string.\\n    * while loop j < grid.length //idea is to loop vertically which is column\\n        * column.push(eachRow[j][i]) \\n        * j++\\n        * column = column.join(\\',\\')\\n        * check if hashMap has value then value += 1 else continue\\n\\n3. finally we just have to loop through hashMap value\\n    * result += value[0] * value[1]\\n4. return result\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    let hashMap = new Map()\\n    for(let i = 0; i < grid.length; i++){\\n        let rowRef = grid[i].join(\\',\\')\\n        if(!hashMap.has(rowRef)){\\n            hashMap.set(rowRef, [1, 0])\\n        }else{\\n            hashMap.get(rowRef)[0] = hashMap.get(rowRef)[0] + 1\\n        }\\n    }\\n\\n        \\n\\n    for(let i = 0; i < grid[0].length; i++){\\n        let column = []\\n        let j = 0\\n\\n        while(j < grid.length){\\n            column.push(grid[j][i])\\n            j++\\n        }\\n\\n        let columnRef = column.join(\\',\\')\\n        console.log(columnRef)\\n\\n        if(hashMap.has(columnRef)){ //not use get becaue when get value == 0, 0 is false false won\\'t go in condation\\n            hashMap.get(columnRef)[1] = hashMap.get(columnRef)[1] + 1\\n        }\\n    }\\n\\n    let result = 0\\n    for(const value of hashMap.values()){\\n        result += (value[0] * value[1])\\n    }\\n\\n    return result\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    let hashMap = new Map()\\n    for(let i = 0; i < grid.length; i++){\\n        let rowRef = grid[i].join(\\',\\')\\n        if(!hashMap.has(rowRef)){\\n            hashMap.set(rowRef, [1, 0])\\n        }else{\\n            hashMap.get(rowRef)[0] = hashMap.get(rowRef)[0] + 1\\n        }\\n    }\\n\\n        \\n\\n    for(let i = 0; i < grid[0].length; i++){\\n        let column = []\\n        let j = 0\\n\\n        while(j < grid.length){\\n            column.push(grid[j][i])\\n            j++\\n        }\\n\\n        let columnRef = column.join(\\',\\')\\n        console.log(columnRef)\\n\\n        if(hashMap.has(columnRef)){ //not use get becaue when get value == 0, 0 is false false won\\'t go in condation\\n            hashMap.get(columnRef)[1] = hashMap.get(columnRef)[1] + 1\\n        }\\n    }\\n\\n    let result = 0\\n    for(const value of hashMap.values()){\\n        result += (value[0] * value[1])\\n    }\\n\\n    return result\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900905,
                "title": "java-2-hashmaps-clean-and-simple",
                "content": "# Please Upvote :D\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/51265fcd-5172-4e47-a6ae-2fb7c55b8eb0_1670755996.5962312.png)\\n\\n---\\n\\n``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n\\n        Map<String, Integer> rows = new HashMap<>();\\n        Map<String, Integer> cols = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder r = new StringBuilder();\\n            StringBuilder c = new StringBuilder();\\n\\n            for (int j = 0; j < n; j++) {\\n                r.append(grid[i][j]).append(\\' \\');\\n                c.append(grid[j][i]).append(\\' \\');\\n            }\\n\\n            rows.put(r.toString(), rows.getOrDefault(r.toString(), 0) + 1);\\n            cols.put(c.toString(), cols.getOrDefault(c.toString(), 0) + 1);\\n        }\\n\\n        int count = 0;\\n\\n        for (String s : rows.keySet()) {\\n            if (cols.containsKey(s)) {\\n                count += rows.get(s) * cols.get(s);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 2) + O(n) ~ O(n ^ 2)\\n// SC: O(n + n) ~ O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n\\n        Map<String, Integer> rows = new HashMap<>();\\n        Map<String, Integer> cols = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder r = new StringBuilder();\\n            StringBuilder c = new StringBuilder();\\n\\n            for (int j = 0; j < n; j++) {\\n                r.append(grid[i][j]).append(\\' \\');\\n                c.append(grid[j][i]).append(\\' \\');\\n            }\\n\\n            rows.put(r.toString(), rows.getOrDefault(r.toString(), 0) + 1);\\n            cols.put(c.toString(), cols.getOrDefault(c.toString(), 0) + 1);\\n        }\\n\\n        int count = 0;\\n\\n        for (String s : rows.keySet()) {\\n            if (cols.containsKey(s)) {\\n                count += rows.get(s) * cols.get(s);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 2) + O(n) ~ O(n ^ 2)\\n// SC: O(n + n) ~ O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773068,
                "title": "c-easy-to-understand-10-faster-than-most-voted",
                "content": "#  **Please upvote if it helps!!\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> mp;\\n        int count=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n           mp[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> vec;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                vec.push_back(grid[j][i]);\\n            }\\n            if(mp.find(vec)!=mp.end() )\\n            {\\n                count+=mp[vec];\\n            }\\n        }\\n        \\n     \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> mp;\\n        int count=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n           mp[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> vec;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                vec.push_back(grid[j][i]);\\n            }\\n            if(mp.find(vec)!=mp.end() )\\n            {\\n                count+=mp[vec];\\n            }\\n        }\\n        \\n     \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444509,
                "title": "c-using-map-easy-to-understand",
                "content": "```\\nclass Solution {\\n    // Row\\n    vector<int> get_row(int i, vector<vector<int>>& v){\\n        return v[i];\\n    }\\n    // Cloumn\\n    vector<int> get_col(int j, vector<vector<int>>& v){\\n        vector<int> u;\\n        int l = v.size();\\n        for(int i=0; i<l; ++i){\\n            u.push_back(v[i][j]);\\n        }\\n        return u;\\n    }\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> m;\\n        int l = grid.size();\\n        for(int i=0; i<l; ++i){\\n            vector<int> v = get_row(i,grid);\\n            m[v]++;\\n        }\\n        int c=0;\\n        for(int j=0; j<l; ++j){\\n            vector<int> v = get_col(j,grid);\\n            if(m.find(v) != m.end()) c += m[v];\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    // Row\\n    vector<int> get_row(int i, vector<vector<int>>& v){\\n        return v[i];\\n    }\\n    // Cloumn\\n    vector<int> get_col(int j, vector<vector<int>>& v){\\n        vector<int> u;\\n        int l = v.size();\\n        for(int i=0; i<l; ++i){\\n            u.push_back(v[i][j]);\\n        }\\n        return u;\\n    }\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> m;\\n        int l = grid.size();\\n        for(int i=0; i<l; ++i){\\n            vector<int> v = get_row(i,grid);\\n            m[v]++;\\n        }\\n        int c=0;\\n        for(int j=0; j<l; ++j){\\n            vector<int> v = get_col(j,grid);\\n            if(m.find(v) != m.end()) c += m[v];\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403516,
                "title": "c-rust-c-rolling-hash-o-n-2-time-o-n-space",
                "content": "##### C++\\n\\n```c++\\nconst int base = 5119;\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    vector<long long> row_hash(n);\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * base + grid[i][j]) % mod;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * base + grid[i][j]) % mod;\\n\\n      for (int i = 0; i < n; i++) res += int(row_hash[i] == h);\\n    }\\n\\n    return res;\\n  }\\n};\\n```\\n\\n---\\n\\n##### Rust\\n```rust\\nconst BASE: i64 = 5119;\\nconst MOD: i64 = 1000000007;\\n\\nimpl Solution {\\n  pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n    let n = grid.len();\\n    let mut row_hash: Vec<i64> = vec![0; n];\\n\\n    let mut res = 0;\\n\\n    // rows\\n    for i in 0..n {\\n      let mut h: i64 = 0;\\n      for j in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for j in 0..n {\\n      let mut h: i64 = 0;\\n      for i in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n\\n      for i in 0..n {\\n        if row_hash[i] == h { res += 1; }\\n      }\\n    }\\n\\n    return res;\\n  }\\n}\\n```\\n\\n---\\n\\n##### C#\\n```cs\\npublic class Solution {\\n  const int BASE = 5119;\\n  const int MOD = 1000000007;\\n\\n  public int EqualPairs(int[][] grid) {\\n    int n = grid.Length;\\n    long[] row_hash = new long[n];\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * BASE + grid[i][j]) % MOD;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * BASE + grid[i][j]) % MOD;\\n\\n      for (int i = 0; i < n; i++) res += row_hash[i] == h ? 1 : 0;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "C#",
                    "Rolling Hash"
                ],
                "code": "```c++\\nconst int base = 5119;\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    vector<long long> row_hash(n);\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * base + grid[i][j]) % mod;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * base + grid[i][j]) % mod;\\n\\n      for (int i = 0; i < n; i++) res += int(row_hash[i] == h);\\n    }\\n\\n    return res;\\n  }\\n};\\n```\n```rust\\nconst BASE: i64 = 5119;\\nconst MOD: i64 = 1000000007;\\n\\nimpl Solution {\\n  pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n    let n = grid.len();\\n    let mut row_hash: Vec<i64> = vec![0; n];\\n\\n    let mut res = 0;\\n\\n    // rows\\n    for i in 0..n {\\n      let mut h: i64 = 0;\\n      for j in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for j in 0..n {\\n      let mut h: i64 = 0;\\n      for i in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n\\n      for i in 0..n {\\n        if row_hash[i] == h { res += 1; }\\n      }\\n    }\\n\\n    return res;\\n  }\\n}\\n```\n```cs\\npublic class Solution {\\n  const int BASE = 5119;\\n  const int MOD = 1000000007;\\n\\n  public int EqualPairs(int[][] grid) {\\n    int n = grid.Length;\\n    long[] row_hash = new long[n];\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * BASE + grid[i][j]) % MOD;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * BASE + grid[i][j]) % MOD;\\n\\n      for (int i = 0; i < n; i++) res += row_hash[i] == h ? 1 : 0;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356230,
                "title": "c-easy-solution",
                "content": "**Pls upvote if it\\'s helpful**\\n```\\nint equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int>mp ;\\n        int res=0 ;\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n            vector<int>ds ;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                ds.push_back(grid[i][j])  ;\\n            }\\n            mp[ds]++ ;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int>ds;\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                ds.push_back(grid[i][j]) ;\\n            }\\n            if(mp.find(ds)!=mp.end())\\n                res+=mp[ds] ;\\n        }\\n        return res ;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nint equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int>mp ;\\n        int res=0 ;\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n            vector<int>ds ;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                ds.push_back(grid[i][j])  ;\\n            }\\n            mp[ds]++ ;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int>ds;\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                ds.push_back(grid[i][j]) ;\\n            }\\n            if(mp.find(ds)!=mp.end())\\n                res+=mp[ds] ;\\n        }\\n        return res ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2352684,
                "title": "python-radix-sort-solution-explained-o-n-2",
                "content": "## Radix Sort\\n(skip this section if you\\'re already familiar with radix sort)\\n\\nRadix sort is a sorting algorithm which works by bucket sorting the items in the list based on a specific *bit* in the item and then recombining the buckets. This iteration is repeated for each *bit* in the data (I use the term *bit* loosely since it could also be a character in a string, or a base 10 digit, or really any other piece of serialized information in the item). Here is an example of radix sort being used to sort a list of words:\\n\\nwords = [horse, apple, heard, candy, pitch, think, women, rules]\\n\\n1. Bucket Sort by 5th/Last Letter\\nbuckets = {d: [heard], e: [horse, apple], h: [pitch], k: [think], n: [women], s: [rules], y: [candy]}\\nwords = [heard, horse, apple, pitch, think, women, rules, candy]\\n(Note how horse is in front of apple because it appeared first in the original word list. The order of words being preserved in each step is key to the success of this algorithm)\\n\\n2. Bucket Sort by 4th Letter\\nbuckets = {c: [pitch], d: [candy], e: [women, rules], l: [apple], n: [think], r: [heard], s: [horse]}\\n[pitch, candy, women, rules, apple, think, heard, horse]\\n\\n3. Bucket Sort by 3rd Letter\\nbuckets = {n: [candy], p: [apple], l: [rules], m: [women], n: [think], r: [heard], s: [horse], t: [pitch]}\\nwords = [candy, apple, rules, women, think, heard, horse, pitch]\\n\\n4. Bucket Sort by 2nd Letter\\nbuckets = {a: [candy], e: [heard], h: [think], i: [pitch], o: [women, horse], p: [apple], u: [rules]}\\nwords = [candy, heard, think, pitch, women, horse, apple, rules]\\n\\n5. Bucket Sort by 1st Letter\\nbuckets = {a: [apple], c: [candy], h: [heard, horse], p: [pitch], r: [rules], t: [think], w: [women]}\\nwords = [apple, candy, heard, horse, pitch, rules, think, women]\\n\\nRadix sort runs in quasilinear time (O(k\\\\*n) where k is the max number of *bits* in any of the items being sorted). Because it is not comparison-based, it is not limited by the O(nlogn), but in practice this rarely leads to real-world performance improvements over algorithms like quicksort and merge sort. That being said, it has found real-world uses sorting physical objects (like index cards), where comparison sorting and long-range swaps are more difficult to implement.\\n\\nThe auxillary space required by the radix sort algorithm is O(n) because it needs to allocate enough space in the buckets to hold all the items being sorted.\\n\\n## The Algorithm\\nTo solve this problem I modified the radix sort algorithm by never re-combining the groups (instead, each existing group gets split into new groups where all items in the group are equal). I also pruned any groups which only had 1 item in them, since single item groups can never create pairs down the road. To keep the rows and colums separated the list of states included a bit to mark if an item was a row (0) or a column (1).\\n\\n### Example 1\\n\\ngrid = [\\n\\t[3, 2, 1],\\n    [1, 7, 6],\\n    [2, 7, 7]\\n]\\n\\n#### Initial Positions:\\n* rows: [(0, 0), (1, 0), (2, 0)] - these point to the start of each row\\n* columns: [(0, 0), (0, 1), (0, 2)] - these point to the start of each column\\n* positions: [(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)] - note how the first element in each tuple denotes if it\\'s a row or column\\n* buckets = [positions] = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)]]\\n\\n#### Iterations:\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2)]]\\n\\t* Keys = [[3, 1, 2, 3, 2, 1]]\\n\\t* Groups by Key = \\n\\t\\t3: [(0, 0, 0), (1, 0, 0)] - 1 potential pairs\\n\\t\\t2: [(0, 2, 0), (1, 0, 1)] - 1 potential pairs\\n\\t\\t1: [(0, 1, 0), (1, 0, 2)] - 1 potential pairs\\n\\t* Next States by Key = \\n\\t\\t3: [(0, 0, 1), (1, 1, 0)]\\n\\t\\t2: [(0, 2, 1), (1, 1, 1)]\\n\\t\\t1: [(0, 1, 1), (1, 1, 2)]\\n\\t* New Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\t* Keys = [[2, 1], [7, 7], [7, 6]]\\n\\t* First Bucket by Key = \\n\\t\\t2: [(0, 0, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t1: [(1, 1, 0)] - 0 potential pairs -> prune when computing next states\\n\\t* Second Bucket by Key = \\n\\t\\t7: [(0, 2, 1), (1, 1, 1)] - 1 potential pair\\n\\t* Third Bucket by Key = \\n\\t\\t7: [(0, 1, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t6: [(1, 1, 2)] - 0 potential pairs -> prune when computing next states\\n\\t* Next States by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n3. Initial Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\t* Keys = [[7, 7]]\\n\\t* First Bucket by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)] - 1 potential pair\\n\\t* Next States by Key (unnecessary at this step) = \\n\\t\\t7: [(0, 2, 3), (1, 3, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n#### Count Pairs\\nThere is only 1 remainig bucket, and in that bucket there are 2 items: 1 row, and 1 column. To compute the number of pairs this bucket creates we multiply the number of rows by the number of columns: pairs = 1\\\\*1 = 1. Since there are no other remaining buckets, the result is 1.\\n\\n### Example 2\\n\\ngrid = [\\n\\t[3, 1, 2, 2]\\n\\t[1, 4, 4, 5]\\n\\t[2, 4, 2, 2]\\n\\t[2, 4, 2, 2]\\n]\\n\\n#### Iterations\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (0, 3, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2), (1, 0, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t3 : [(0, 0, 1), (1, 1, 0)] - 1 potential pair - current path: 3\\n\\t\\t1 : [(0, 1, 1), (1, 1, 1)] - 1 potential pair - current path: 1\\n\\t\\t2 : [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)] - 4 potential pairs\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 1, 1), (1, 1, 1)], [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t1 : [(0, 0, 2), (1, 2, 0)] - 1 potential pair - current path: 3-1\\n\\t* Bucket 2:\\n\\t\\t4 : [(0, 1, 2), (1, 2, 1)] - 1 potential pair - current path: 1-4\\n\\t* Bucket 3:\\n\\t\\t4 : [(0, 2, 2), (0, 3, 2), (1, 2, 2)] - 2 potential pairs - current path: 2-4\\n\\t\\t5 : [(1, 2, 3)] - 0 potential pairs - current path: 2-5 - prune from next iteration\\n3. Initial Buckets = [[(0, 0, 2), (1, 2, 0)], [(0, 1, 2), (1, 2, 1)], [(0, 2, 2), (0, 3, 2), (1, 2, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1: \\n\\t\\t2 : [(0, 0, 3), (1, 3, 0)] - 1 potential pair - current path: 3-1-2\\n\\t* Bucket 2: \\n\\t\\t4 : [(0, 1, 3), (1, 3, 1)] - 1 potential pair - current path: 1-4-4\\n\\t* Bucket 3: \\n\\t\\t2 : [(0, 2, 3), (0, 3, 3), (1, 3, 2)] - 2 potential pairs - current path: 2-4-2\\n4. Initial Buckets = [[(0, 0, 3), (1, 3, 0)], [(0, 1, 3), (1, 3, 1)], [(0, 2, 3), (0, 3, 3), (1, 3, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t2 : [(0, 0, 4), (1, 4, 0)] - 1 potential pair - current path: 3-1-2-2\\n\\t* Bucket 2:\\n\\t\\t5 : [(0, 1, 4)] - 0 potential pairs - current path: 1-4-4-5 - prune from final bucket list\\n\\t\\t4 : [(1, 4, 1)] - 0 potential pairs - current path: 1-4-4-4 - prune from final bucket list\\n\\t* Bucket 3:\\n\\t\\t2 : [(0, 2, 4), (0, 3, 4), (1, 4, 2)] - 2 potential pairs - current path: 2-4-2-2\\n\\n#### Count Pairs\\nThe final bucket list is: [[(0, 0, 4), (1, 4, 0)], [(0, 2, 4), (0, 3, 4), (1, 4, 2)]]\\n* Bucket 1: 1 row, 1 column -> pairs contributed: 1\\\\*1 = 1\\n* Bucket 2: 2 rows, 1 column -> paris contributed: 2\\\\*1 = 2\\nFrom this we know the total number of pairs found is 1 + 2 = 3\\n\\n### Code\\nFirst Run Performance: 609 ms/19 MB\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Radix Sort the Row/Column Indecies (maintaining the Separate buckets) - O(n^2)\\n\\t\\t\\t# positions are stored as a tuple containing: (direction, row index, column index)\\n\\t\\t\\tpositions = [(0, i, 0) for i in range(n)] # all starting row positions\\n\\t\\t\\tpositions.extend((1, 0, j) for j in range(n)) # all starting column positions\\n\\t\\t\\toldBuckets = [positions]\\n\\t\\t\\tfor k in range(n):\\n\\t\\t\\t\\t# Split the Current Buckets Into New Buckets\\n\\t\\t\\t\\tbuckets = []\\n\\t\\t\\t\\tfor bucket in oldBuckets:\\n\\t\\t\\t\\t\\t# Split the Current Bucket Into New Buckets\\n\\t\\t\\t\\t\\tbucketMap = defaultdict(list)\\n\\t\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t\\t# Add the Next Position to its Respective Bucket Based on the Current Position\\n\\t\\t\\t\\t\\t\\tbucketMap[grid[i][j]].append((d, i + d, j + 1 - d))\\n\\n\\t\\t\\t\\t\\t# Add the New Buckets to the List of Buckets (pruning buckets with no pairs) - O(n)\\n\\t\\t\\t\\t\\tbuckets.extend(x for x in bucketMap.values() if len(x) > 1)\\n\\n\\t\\t\\t\\t# Update the Buckets\\n\\t\\t\\t\\toldBuckets = buckets\\n\\n\\t\\t\\t# Count the Number of Rows/Columns in Each Bucket - O(n)\\n\\t\\t\\tpairs = 0\\n\\t\\t\\tfor bucket in buckets:\\n\\t\\t\\t\\t# Count the Number of Rows/Columns in the Current Bucket\\n\\t\\t\\t\\trows = 0\\n\\t\\t\\t\\tcols = 0\\n\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t# Check if the Position is From a Column or a Row\\n\\t\\t\\t\\t\\tif d:\\n\\t\\t\\t\\t\\t\\tcols += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\trows += 1\\n\\n\\t\\t\\t\\t# Count the Number of Pairs That Contributes\\n\\t\\t\\t\\tpairs += rows * cols\\n\\n\\t\\t\\t# Return the Total Number of Pairs\\n\\t\\t\\treturn pairs\\n\\'\\'\\'\\n\\n## Notes\\nThis solution could actuall be slightly improved if the rows/columns are kept separated from the start as this would eliminate the need for the final pass where the number of pairs is computed. But the time saved from this is small since it only contributes O(n) to the overall time complexity, while the time complexity for the whole algorith is O(n^2). The bigger way this could help the performance though is by more agressive pruning during the radix sort.\\n\\nThere are 2 instances in this algorithm where nested loops only contribute a factor of O(n) to their respective section in the code: \"for bucket in oldBuckets\"/\"for d, i, j in bucket\", and \"for bucket in buckets\"/\"for d, i, j in bucket\". In both of these instances, the total number of positions in all buckets is at most 2\\\\*n since the total number of starting positions is 2\\\\*n (i.e. sum(len(bucket) for bucket in buckets) = # remaining positions <= # starting positions = 2\\\\*n). The radix sort section of the algorithm has an additional factor of O(n) from the \"for k in range(n)\", so its time complexity is O(n^2), while the pair counting section just has a time complexity of O(n). Together these give an overal time complexity of O(n^2). Furthermore, since the number of positions is O(n), the space complexity for the algorithm is O(n) as *positions*, *oldBuckets*, *buckets*, and *bucketMap* each store all the remaining posiitons once, meaning that they each use O(n) space.\\n\\n# Hashmap Solution\\nAs fun as the radix sort solution is, this much simpler solution using hashmaps achieves the same time/space complexity, and similar real-world performance. So you should all really use something like this:\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Hash the Rows - O(n^2)\\n\\t\\t\\tcounts = Counter(map(tuple, grid))\\n\\n\\t\\t\\t# Hash the Columns and Count the Pairs - O(n^2)\\n\\t\\t\\treturn sum(counts[tuple(grid[i][j] for i in range(n))] for j in range(n))\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "## Radix Sort\\n(skip this section if you\\'re already familiar with radix sort)\\n\\nRadix sort is a sorting algorithm which works by bucket sorting the items in the list based on a specific *bit* in the item and then recombining the buckets. This iteration is repeated for each *bit* in the data (I use the term *bit* loosely since it could also be a character in a string, or a base 10 digit, or really any other piece of serialized information in the item). Here is an example of radix sort being used to sort a list of words:\\n\\nwords = [horse, apple, heard, candy, pitch, think, women, rules]\\n\\n1. Bucket Sort by 5th/Last Letter\\nbuckets = {d: [heard], e: [horse, apple], h: [pitch], k: [think], n: [women], s: [rules], y: [candy]}\\nwords = [heard, horse, apple, pitch, think, women, rules, candy]\\n(Note how horse is in front of apple because it appeared first in the original word list. The order of words being preserved in each step is key to the success of this algorithm)\\n\\n2. Bucket Sort by 4th Letter\\nbuckets = {c: [pitch], d: [candy], e: [women, rules], l: [apple], n: [think], r: [heard], s: [horse]}\\n[pitch, candy, women, rules, apple, think, heard, horse]\\n\\n3. Bucket Sort by 3rd Letter\\nbuckets = {n: [candy], p: [apple], l: [rules], m: [women], n: [think], r: [heard], s: [horse], t: [pitch]}\\nwords = [candy, apple, rules, women, think, heard, horse, pitch]\\n\\n4. Bucket Sort by 2nd Letter\\nbuckets = {a: [candy], e: [heard], h: [think], i: [pitch], o: [women, horse], p: [apple], u: [rules]}\\nwords = [candy, heard, think, pitch, women, horse, apple, rules]\\n\\n5. Bucket Sort by 1st Letter\\nbuckets = {a: [apple], c: [candy], h: [heard, horse], p: [pitch], r: [rules], t: [think], w: [women]}\\nwords = [apple, candy, heard, horse, pitch, rules, think, women]\\n\\nRadix sort runs in quasilinear time (O(k\\\\*n) where k is the max number of *bits* in any of the items being sorted). Because it is not comparison-based, it is not limited by the O(nlogn), but in practice this rarely leads to real-world performance improvements over algorithms like quicksort and merge sort. That being said, it has found real-world uses sorting physical objects (like index cards), where comparison sorting and long-range swaps are more difficult to implement.\\n\\nThe auxillary space required by the radix sort algorithm is O(n) because it needs to allocate enough space in the buckets to hold all the items being sorted.\\n\\n## The Algorithm\\nTo solve this problem I modified the radix sort algorithm by never re-combining the groups (instead, each existing group gets split into new groups where all items in the group are equal). I also pruned any groups which only had 1 item in them, since single item groups can never create pairs down the road. To keep the rows and colums separated the list of states included a bit to mark if an item was a row (0) or a column (1).\\n\\n### Example 1\\n\\ngrid = [\\n\\t[3, 2, 1],\\n    [1, 7, 6],\\n    [2, 7, 7]\\n]\\n\\n#### Initial Positions:\\n* rows: [(0, 0), (1, 0), (2, 0)] - these point to the start of each row\\n* columns: [(0, 0), (0, 1), (0, 2)] - these point to the start of each column\\n* positions: [(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)] - note how the first element in each tuple denotes if it\\'s a row or column\\n* buckets = [positions] = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)]]\\n\\n#### Iterations:\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2)]]\\n\\t* Keys = [[3, 1, 2, 3, 2, 1]]\\n\\t* Groups by Key = \\n\\t\\t3: [(0, 0, 0), (1, 0, 0)] - 1 potential pairs\\n\\t\\t2: [(0, 2, 0), (1, 0, 1)] - 1 potential pairs\\n\\t\\t1: [(0, 1, 0), (1, 0, 2)] - 1 potential pairs\\n\\t* Next States by Key = \\n\\t\\t3: [(0, 0, 1), (1, 1, 0)]\\n\\t\\t2: [(0, 2, 1), (1, 1, 1)]\\n\\t\\t1: [(0, 1, 1), (1, 1, 2)]\\n\\t* New Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\t* Keys = [[2, 1], [7, 7], [7, 6]]\\n\\t* First Bucket by Key = \\n\\t\\t2: [(0, 0, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t1: [(1, 1, 0)] - 0 potential pairs -> prune when computing next states\\n\\t* Second Bucket by Key = \\n\\t\\t7: [(0, 2, 1), (1, 1, 1)] - 1 potential pair\\n\\t* Third Bucket by Key = \\n\\t\\t7: [(0, 1, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t6: [(1, 1, 2)] - 0 potential pairs -> prune when computing next states\\n\\t* Next States by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n3. Initial Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\t* Keys = [[7, 7]]\\n\\t* First Bucket by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)] - 1 potential pair\\n\\t* Next States by Key (unnecessary at this step) = \\n\\t\\t7: [(0, 2, 3), (1, 3, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n#### Count Pairs\\nThere is only 1 remainig bucket, and in that bucket there are 2 items: 1 row, and 1 column. To compute the number of pairs this bucket creates we multiply the number of rows by the number of columns: pairs = 1\\\\*1 = 1. Since there are no other remaining buckets, the result is 1.\\n\\n### Example 2\\n\\ngrid = [\\n\\t[3, 1, 2, 2]\\n\\t[1, 4, 4, 5]\\n\\t[2, 4, 2, 2]\\n\\t[2, 4, 2, 2]\\n]\\n\\n#### Iterations\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (0, 3, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2), (1, 0, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t3 : [(0, 0, 1), (1, 1, 0)] - 1 potential pair - current path: 3\\n\\t\\t1 : [(0, 1, 1), (1, 1, 1)] - 1 potential pair - current path: 1\\n\\t\\t2 : [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)] - 4 potential pairs\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 1, 1), (1, 1, 1)], [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t1 : [(0, 0, 2), (1, 2, 0)] - 1 potential pair - current path: 3-1\\n\\t* Bucket 2:\\n\\t\\t4 : [(0, 1, 2), (1, 2, 1)] - 1 potential pair - current path: 1-4\\n\\t* Bucket 3:\\n\\t\\t4 : [(0, 2, 2), (0, 3, 2), (1, 2, 2)] - 2 potential pairs - current path: 2-4\\n\\t\\t5 : [(1, 2, 3)] - 0 potential pairs - current path: 2-5 - prune from next iteration\\n3. Initial Buckets = [[(0, 0, 2), (1, 2, 0)], [(0, 1, 2), (1, 2, 1)], [(0, 2, 2), (0, 3, 2), (1, 2, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1: \\n\\t\\t2 : [(0, 0, 3), (1, 3, 0)] - 1 potential pair - current path: 3-1-2\\n\\t* Bucket 2: \\n\\t\\t4 : [(0, 1, 3), (1, 3, 1)] - 1 potential pair - current path: 1-4-4\\n\\t* Bucket 3: \\n\\t\\t2 : [(0, 2, 3), (0, 3, 3), (1, 3, 2)] - 2 potential pairs - current path: 2-4-2\\n4. Initial Buckets = [[(0, 0, 3), (1, 3, 0)], [(0, 1, 3), (1, 3, 1)], [(0, 2, 3), (0, 3, 3), (1, 3, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t2 : [(0, 0, 4), (1, 4, 0)] - 1 potential pair - current path: 3-1-2-2\\n\\t* Bucket 2:\\n\\t\\t5 : [(0, 1, 4)] - 0 potential pairs - current path: 1-4-4-5 - prune from final bucket list\\n\\t\\t4 : [(1, 4, 1)] - 0 potential pairs - current path: 1-4-4-4 - prune from final bucket list\\n\\t* Bucket 3:\\n\\t\\t2 : [(0, 2, 4), (0, 3, 4), (1, 4, 2)] - 2 potential pairs - current path: 2-4-2-2\\n\\n#### Count Pairs\\nThe final bucket list is: [[(0, 0, 4), (1, 4, 0)], [(0, 2, 4), (0, 3, 4), (1, 4, 2)]]\\n* Bucket 1: 1 row, 1 column -> pairs contributed: 1\\\\*1 = 1\\n* Bucket 2: 2 rows, 1 column -> paris contributed: 2\\\\*1 = 2\\nFrom this we know the total number of pairs found is 1 + 2 = 3\\n\\n### Code\\nFirst Run Performance: 609 ms/19 MB\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Radix Sort the Row/Column Indecies (maintaining the Separate buckets) - O(n^2)\\n\\t\\t\\t# positions are stored as a tuple containing: (direction, row index, column index)\\n\\t\\t\\tpositions = [(0, i, 0) for i in range(n)] # all starting row positions\\n\\t\\t\\tpositions.extend((1, 0, j) for j in range(n)) # all starting column positions\\n\\t\\t\\toldBuckets = [positions]\\n\\t\\t\\tfor k in range(n):\\n\\t\\t\\t\\t# Split the Current Buckets Into New Buckets\\n\\t\\t\\t\\tbuckets = []\\n\\t\\t\\t\\tfor bucket in oldBuckets:\\n\\t\\t\\t\\t\\t# Split the Current Bucket Into New Buckets\\n\\t\\t\\t\\t\\tbucketMap = defaultdict(list)\\n\\t\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t\\t# Add the Next Position to its Respective Bucket Based on the Current Position\\n\\t\\t\\t\\t\\t\\tbucketMap[grid[i][j]].append((d, i + d, j + 1 - d))\\n\\n\\t\\t\\t\\t\\t# Add the New Buckets to the List of Buckets (pruning buckets with no pairs) - O(n)\\n\\t\\t\\t\\t\\tbuckets.extend(x for x in bucketMap.values() if len(x) > 1)\\n\\n\\t\\t\\t\\t# Update the Buckets\\n\\t\\t\\t\\toldBuckets = buckets\\n\\n\\t\\t\\t# Count the Number of Rows/Columns in Each Bucket - O(n)\\n\\t\\t\\tpairs = 0\\n\\t\\t\\tfor bucket in buckets:\\n\\t\\t\\t\\t# Count the Number of Rows/Columns in the Current Bucket\\n\\t\\t\\t\\trows = 0\\n\\t\\t\\t\\tcols = 0\\n\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t# Check if the Position is From a Column or a Row\\n\\t\\t\\t\\t\\tif d:\\n\\t\\t\\t\\t\\t\\tcols += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\trows += 1\\n\\n\\t\\t\\t\\t# Count the Number of Pairs That Contributes\\n\\t\\t\\t\\tpairs += rows * cols\\n\\n\\t\\t\\t# Return the Total Number of Pairs\\n\\t\\t\\treturn pairs\\n\\'\\'\\'\\n\\n## Notes\\nThis solution could actuall be slightly improved if the rows/columns are kept separated from the start as this would eliminate the need for the final pass where the number of pairs is computed. But the time saved from this is small since it only contributes O(n) to the overall time complexity, while the time complexity for the whole algorith is O(n^2). The bigger way this could help the performance though is by more agressive pruning during the radix sort.\\n\\nThere are 2 instances in this algorithm where nested loops only contribute a factor of O(n) to their respective section in the code: \"for bucket in oldBuckets\"/\"for d, i, j in bucket\", and \"for bucket in buckets\"/\"for d, i, j in bucket\". In both of these instances, the total number of positions in all buckets is at most 2\\\\*n since the total number of starting positions is 2\\\\*n (i.e. sum(len(bucket) for bucket in buckets) = # remaining positions <= # starting positions = 2\\\\*n). The radix sort section of the algorithm has an additional factor of O(n) from the \"for k in range(n)\", so its time complexity is O(n^2), while the pair counting section just has a time complexity of O(n). Together these give an overal time complexity of O(n^2). Furthermore, since the number of positions is O(n), the space complexity for the algorithm is O(n) as *positions*, *oldBuckets*, *buckets*, and *bucketMap* each store all the remaining posiitons once, meaning that they each use O(n) space.\\n\\n# Hashmap Solution\\nAs fun as the radix sort solution is, this much simpler solution using hashmaps achieves the same time/space complexity, and similar real-world performance. So you should all really use something like this:\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Hash the Rows - O(n^2)\\n\\t\\t\\tcounts = Counter(map(tuple, grid))\\n\\n\\t\\t\\t# Hash the Columns and Count the Pairs - O(n^2)\\n\\t\\t\\treturn sum(counts[tuple(grid[i][j] for i in range(n))] for j in range(n))\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2352409,
                "title": "c-easy-solution-please-upvote",
                "content": "//STORE EACH ROW  AND ITS COUNT  THEN MATCH WITH EACH COLUMN \\n// FOR MATCHING ROW COL  , INCREMENT ANS = ANS + NO OF TIMES( ROW)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> s;\\n        int res=0;\\n        for(int i =0;i<grid.size();i++)\\n        {\\n            if(s.find(grid[i])==s.end())\\n            {\\n               s.insert ({grid[i],1});\\n            }\\n            else\\n            {\\n              s[grid[i]]++;  \\n            }\\n        }\\n        for(int i =0;i<grid.size();i++)\\n        {\\n            vector<int> temp;\\n            for(int j =0;j<grid.size();j++)\\n            {\\n                 temp.push_back(grid[j][i]);\\n                \\n            }\\n            if(s.find(temp)!=s.end())\\n            {\\n                res= res+s[temp];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> s;\\n        int res=0;\\n        for(int i =0;i<grid.size();i++)\\n        {\\n            if(s.find(grid[i])==s.end())\\n            {\\n               s.insert ({grid[i],1}",
                "codeTag": "Java"
            },
            {
                "id": 2344208,
                "title": "rust-hashmap-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut map = HashMap::new();\\n        for row in &grid {            \\n            *map.entry(row).or_insert(0) += 1;\\n        }\\n\\n        let mut ans = 0;\\n        for j in 0..grid[0].len() {\\n            let mut v = Vec::new();\\n            for i in 0..grid.len() {\\n                v.push(grid[i][j])\\n            }\\n            ans += map.get(&v).unwrap_or(&0);\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut map = HashMap::new();\\n        for row in &grid {            \\n            *map.entry(row).or_insert(0) += 1;\\n        }\\n\\n        let mut ans = 0;\\n        for j in 0..grid[0].len() {\\n            let mut v = Vec::new();\\n            for i in 0..grid.len() {\\n                v.push(grid[i][j])\\n            }\\n            ans += map.get(&v).unwrap_or(&0);\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2339230,
                "title": "rust-hashmap",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl2/lc2352)\\n\\n<b>Problem List</b>\\n#HashMap - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/map/hashmap)\\n#CountOccurrences - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_topic/count_occurrences.txt)\\n#MatrixManipulation - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/array/by_topic/manipulation/matrix)\\n#Trie - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/tree/by_data_structure/trie.txt)\\n\\n```\\nuse std::collections::HashMap;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/equal-row-and-column-pairs/\\n/// Time Complexity:    O(`len_rs` * `len_cs`)\\n/// Space Complexity:   O(`len_rs` * `len_cs`)\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let row_to_freq: HashMap<&Vec<i32>, u8> = {\\n            let mut map: HashMap<&Vec<i32>, u8> = HashMap::with_capacity(len_rs);\\n            for row in &grid {\\n                *map.entry(row).or_default() += 1;\\n            }\\n            map\\n        };\\n        let mut cnt: i32 = 0;\\n        for c in 0..len_cs {\\n            let mut col: Vec<i32> = Vec::with_capacity(len_cs);\\n            for r in 0..len_rs {\\n                col.push(grid[r][c]);\\n            }\\n            if let Some(&freq) = row_to_freq.get(&col) {\\n                cnt += freq as i32;\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/equal-row-and-column-pairs/\\n/// Time Complexity:    O(`len_rs` * `len_cs`)\\n/// Space Complexity:   O(`len_rs` * `len_cs`)\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let row_to_freq: HashMap<&Vec<i32>, u8> = {\\n            let mut map: HashMap<&Vec<i32>, u8> = HashMap::with_capacity(len_rs);\\n            for row in &grid {\\n                *map.entry(row).or_default() += 1;\\n            }\\n            map\\n        };\\n        let mut cnt: i32 = 0;\\n        for c in 0..len_cs {\\n            let mut col: Vec<i32> = Vec::with_capacity(len_cs);\\n            for r in 0..len_rs {\\n                col.push(grid[r][c]);\\n            }\\n            if let Some(&freq) = row_to_freq.get(&col) {\\n                cnt += freq as i32;\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2336822,
                "title": "faster-than-80-java-solution-using-hashmap-stringbuilder",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> hmap = new HashMap<>();\\n        for(int arr[]:grid)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                sb.append(arr[i]);\\n                sb.append(\" \");\\n            }\\n            String dummy = sb.toString();\\n            hmap.put(dummy,hmap.getOrDefault(dummy,0)+1);\\n        }\\n        int c=0;\\n        for(int j=0;j<grid[0].length;j++)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<grid.length;i++)\\n            {\\n                sb.append(grid[i][j]);\\n                sb.append(\" \");\\n            }\\n            String dummy = sb.toString();\\n            if(hmap.get(dummy)!=null)\\n            {\\n                c+=hmap.get(dummy);\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> hmap = new HashMap<>();\\n        for(int arr[]:grid)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                sb.append(arr[i]);\\n                sb.append(\" \");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2327741,
                "title": "i-love-this-solution-o-n-3",
                "content": "\\t public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "\\t public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2326298,
                "title": "c-easy-map-with-approach",
                "content": "```\\nint equalPairs(vector<vector<int>>& grid) \\n    {\\n        int c=0;\\n        map<vector<int>,int> m;\\n\\t\\t//We store each vector of grid in map\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            m[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> temp;\\n\\t\\t\\t//Now we traverse vertically and store elements in a vector\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n\\t\\t\\t//Check if the temp vector is present in map, if present we increment our count\\n            c+=m[temp];\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint equalPairs(vector<vector<int>>& grid) \\n    {\\n        int c=0;\\n        map<vector<int>,int> m;\\n\\t\\t//We store each vector of grid in map\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            m[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> temp;\\n\\t\\t\\t//Now we traverse vertically and store elements in a vector\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n\\t\\t\\t//Check if the temp vector is present in map, if present we increment our count\\n            c+=m[temp];\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326136,
                "title": "java-hashmap-easy",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>,Integer> m = new HashMap<>();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            List<Integer> l =new ArrayList<>();\\n            for(int j=0;j<grid.length;j++){\\n                l.add(grid[i][j]);\\n            }\\n               m.put(l,m.getOrDefault(l,0)+1);\\n        }\\n        int count=0;\\n        \\n        for(int j=0;j<grid.length;j++){\\n            List<Integer> l = new ArrayList<>();\\n            for(int i=0;i<grid.length;i++){\\n                l.add(grid[i][j]);\\n            }\\n            \\n            if(m.containsKey(l)) count+=m.get(l);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>,Integer> m = new HashMap<>();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            List<Integer> l =new ArrayList<>();\\n            for(int j=0;j<grid.length;j++){\\n                l.add(grid[i][j]);\\n            }\\n               m.put(l,m.getOrDefault(l,0)+1);\\n        }\\n        int count=0;\\n        \\n        for(int j=0;j<grid.length;j++){\\n            List<Integer> l = new ArrayList<>();\\n            for(int i=0;i<grid.length;i++){\\n                l.add(grid[i][j]);\\n            }\\n            \\n            if(m.containsKey(l)) count+=m.get(l);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325221,
                "title": "typescript-hashmap",
                "content": "\\n```ts\\nfunction equalPairs(grid: number[][]): number {\\n  const rowMap = new Map<string, number>()\\n  for (let row of grid) {\\n    const key = row.join(\",\")\\n    rowMap.set(key, (rowMap.get(key) || 0) + 1)\\n  }\\n  \\n  let res = 0\\n  for (let c = 0; c < grid.length; c++) {\\n    const column = []\\n    for (let r = 0; r < grid[0].length; r++) {\\n      column.push(grid[r][c])\\n    }\\n    const columnKey = column.join(\",\")\\n    if (rowMap.has(columnKey)) {\\n      res += rowMap.get(columnKey)\\n    }\\n  }\\n  \\n  return res\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction equalPairs(grid: number[][]): number {\\n  const rowMap = new Map<string, number>()\\n  for (let row of grid) {\\n    const key = row.join(\",\")\\n    rowMap.set(key, (rowMap.get(key) || 0) + 1)\\n  }\\n  \\n  let res = 0\\n  for (let c = 0; c < grid.length; c++) {\\n    const column = []\\n    for (let r = 0; r < grid[0].length; r++) {\\n      column.push(grid[r][c])\\n    }\\n    const columnKey = column.join(\",\")\\n    if (rowMap.has(columnKey)) {\\n      res += rowMap.get(columnKey)\\n    }\\n  }\\n  \\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325047,
                "title": "c-easy-hashmap-o-n-2-solution-o-n-space",
                "content": "**Logic**\\nStore every rows in hashmap as a string of number separted by underscore, For an example if row contain following [2,44,5,9] then key of hashmap will be \"2_44_5_9_\"\\n\\nNow iterate over each column and convert them to string in same way and add check if key is in map then add key -> value to ans .\\n\\n```\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    unordered_map<string, int> mp;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n\\n    for (int i = 0; i < m; i++) {\\n      string s = \"\";\\n      for (int j = 0; j < n; j++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      mp[s] += 1;\\n    }\\n    int ans = 0;\\n    for (int j = 0; j < n; j++) {\\n      string s = \"\";\\n      for (int i = 0; i < m; i++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      ans += mp[s];\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    unordered_map<string, int> mp;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n\\n    for (int i = 0; i < m; i++) {\\n      string s = \"\";\\n      for (int j = 0; j < n; j++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      mp[s] += 1;\\n    }\\n    int ans = 0;\\n    for (int j = 0; j < n; j++) {\\n      string s = \"\";\\n      for (int i = 0; i < m; i++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      ans += mp[s];\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324873,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        HashMap<String, Integer> map = new HashMap();\\n        \\n        for(int i[] : grid){\\n            map.put(Arrays.toString(i), map.getOrDefault(Arrays.toString(i),0) + 1);\\n        }\\n        \\n       int count = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            int arr[] = new int[grid.length];\\n            for(int j = 0; j < grid.length; j++){\\n                arr[j] = grid[j][i];\\n            }\\n            count += map.getOrDefault(Arrays.toString(arr),0);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        HashMap<String, Integer> map = new HashMap();\\n        \\n        for(int i[] : grid){\\n            map.put(Arrays.toString(i), map.getOrDefault(Arrays.toString(i),0) + 1);\\n        }\\n        \\n       int count = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            int arr[] = new int[grid.length];\\n            for(int j = 0; j < grid.length; j++){\\n                arr[j] = grid[j][i];\\n            }\\n            count += map.getOrDefault(Arrays.toString(arr),0);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324832,
                "title": "javascript-solution",
                "content": "```\\nvar equalPairs = function(grid) {\\n    \\n    const map = new Map();\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[i][j] + \\' \\';\\n        }\\n        let c = map.has(str)?map.get(str): 0;\\n        map.set(str,++c);\\n    }\\n    \\n    //console.log(map);\\n    let ans = 0;\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[j][i] + \\' \\';\\n        }\\n        if(map.has(str))\\n            ans += map.get(str);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar equalPairs = function(grid) {\\n    \\n    const map = new Map();\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[i][j] + \\' \\';\\n        }\\n        let c = map.has(str)?map.get(str): 0;\\n        map.set(str,++c);\\n    }\\n    \\n    //console.log(map);\\n    let ans = 0;\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[j][i] + \\' \\';\\n        }\\n        if(map.has(str))\\n            ans += map.get(str);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324686,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)                  //Traverse for every row.\\n        {\\n            for(int j=0;j<n;j++)              // Traverse each row for every column.\\n            {\\n                int count=0;\\n                for(int k=0;k<n;k++)          // kth element of every row will be compared to kth element of every column.\\n                {\\n                    if(grid[i][k]==grid[k][j]){        \\n                        count++;\\n                    }\\n                    else\\n                    {\\n                        break;                // If an unequal element is found check for next column.\\n                    }\\n                    \\n                    if(count==n)              // If all the elements of that row and column are equal increase the answer.\\n                        ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)                  //Traverse for every row.\\n        {\\n            for(int j=0;j<n;j++)              // Traverse each row for every column.\\n            {\\n                int count=0;\\n                for(int k=0;k<n;k++)          // kth element of every row will be compared to kth element of every column.\\n                {\\n                    if(grid[i][k]==grid[k][j]){        \\n                        count++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 4031071,
                "title": "java-easy-to-understand-97-faster",
                "content": "# Complexity\\n- Time complexity: \\n1st Code - O(n^2)\\n2nd Code - O(n^3)\\n\\n\\n# Code\\n- Space complexity: O(n^2)\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int ans=0;\\n        int[][] transpose = new int[n][n];\\n        for(int i=0; i<n; i++){\\n            for(int y=0; y<n; y++){\\n                transpose[i][y]=grid[y][i];\\n            }\\n        }\\n        for(int[] row:grid){\\n            for(int[] column:transpose){\\n                if(Arrays.equals(row, column)){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n- Space Complexity = O(1)\\n```\\nclass Solution {\\n    public boolean check(int[][] grid, int row, int column){\\n        int n=grid.length;\\n        for(int i=0; i<n; i++){\\n            if(grid[i][row]!=grid[column][i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int equalPairs(int[][] grid) {\\n        int ans=0;\\n        int n=grid.length;\\n        for(int i=0; i<n; i++){\\n            for(int y=0; y<n; y++){\\n                if(grid[0][i]==grid[y][0]){\\n                    if(check(grid, i, y)){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int ans=0;\\n        int[][] transpose = new int[n][n];\\n        for(int i=0; i<n; i++){\\n            for(int y=0; y<n; y++){\\n                transpose[i][y]=grid[y][i];\\n            }\\n        }\\n        for(int[] row:grid){\\n            for(int[] column:transpose){\\n                if(Arrays.equals(row, column)){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024091,
                "title": "c-using-map-easy-and-straightforward-code",
                "content": "```\\n int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mp;\\n        int n = grid.size();\\n        \\n        vector<int>vc;\\n        for(auto i : grid){\\n            vc.clear();\\n            for(auto j : i){\\n                vc.push_back(j);\\n            }\\n            mp[vc]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            vc.clear();\\n            for(int j = 0; j<n; j++){\\n                vc.push_back(grid[j][i]);\\n            }\\n            ans+=mp[vc];\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nTime : O(N^2)\\nSpace : O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\n int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mp;\\n        int n = grid.size();\\n        \\n        vector<int>vc;\\n        for(auto i : grid){\\n            vc.clear();\\n            for(auto j : i){\\n                vc.push_back(j);\\n            }\\n            mp[vc]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            vc.clear();\\n            for(int j = 0; j<n; j++){\\n                vc.push_back(grid[j][i]);\\n            }\\n            ans+=mp[vc];\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924219,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int result = 0;\\n\\n        // row, freq\\n        map<vector<int>, int> row; \\n        for (int i = 0; i < grid.size(); i++) {\\n            row[grid[i]]++;\\n        }\\n\\n        vector<int> col(grid.size());\\n\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            for (int i = 0; i < grid.size(); i++)\\n                col[i] = grid[i][j];\\n            \\n            if (row.find(col) != row.end())\\n                result += row[col];\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int result = 0;\\n\\n        // row, freq\\n        map<vector<int>, int> row; \\n        for (int i = 0; i < grid.size(); i++) {\\n            row[grid[i]]++;\\n        }\\n\\n        vector<int> col(grid.size());\\n\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            for (int i = 0; i < grid.size(); i++)\\n                col[i] = grid[i][j];\\n            \\n            if (row.find(col) != row.end())\\n                result += row[col];\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826240,
                "title": "c-beats-99-34-runtime-set-unordered-map",
                "content": "# Intuition\\nUse a set to keep track of duplicate rows and use an unordered map to keep track of each multiple duplicate rows\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        set<vector<int>> res;\\n        unordered_map<int, vector<int>> dupe;\\n\\n        for(int i = 0; i < grid.size(); ++i){\\n            if(res.find(grid[i]) != res.end()) {\\n                dupe[i] = grid[i];\\n                // if the row already exists, then in case of a     duplicate, it has to be counted multiple times\\n            } \\n            res.insert(grid[i]);\\n        }\\n        for(int i = 0; i < grid.size(); ++i){\\n            vector<int> temp;\\n            for(int j = 0; j <  grid.size(); ++j){\\n                temp.push_back(grid[j][i]);\\n            }\\n            if(res.find(temp) != res.end()) {\\n                for(auto& it: dupe){\\n                //  itterate through dupe unordered_map to add duplicate rows\\n                    if(it.second == temp){\\n                        ++count;\\n                    }\\n                }\\n                ++count;\\n                cout << i << \" \";\\n            } \\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        set<vector<int>> res;\\n        unordered_map<int, vector<int>> dupe;\\n\\n        for(int i = 0; i < grid.size(); ++i){\\n            if(res.find(grid[i]) != res.end()) {\\n                dupe[i] = grid[i];\\n                // if the row already exists, then in case of a     duplicate, it has to be counted multiple times\\n            } \\n            res.insert(grid[i]);\\n        }\\n        for(int i = 0; i < grid.size(); ++i){\\n            vector<int> temp;\\n            for(int j = 0; j <  grid.size(); ++j){\\n                temp.push_back(grid[j][i]);\\n            }\\n            if(res.find(temp) != res.end()) {\\n                for(auto& it: dupe){\\n                //  itterate through dupe unordered_map to add duplicate rows\\n                    if(it.second == temp){\\n                        ++count;\\n                    }\\n                }\\n                ++count;\\n                cout << i << \" \";\\n            } \\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3724518,
                "title": "easy-java-solution-clean-code-easy-understanding",
                "content": "# Intuition\\nTo solve this problem, we need to compare each row with each column. However, doing this directly would be inefficient. An idea is to convert rows and columns to strings (with a separator for each element) and store them in two separate hashmaps, counting the frequency of each unique row and column. Then, we iterate through the keys in the hashmap for rows, and for each row that is also a column (i.e., exists in the hashmap for columns), we multiply their counts from both hashmaps, which gives the number of pairs (ri, cj) where row ri and column cj are equal.\\n\\n\\n# Approach\\n1. Initialize two hashmaps, rowMap and colMap.\\n2. Iterate over the matrix to populate rowMap and colMap with the counts of unique rows and columns, respectively. For each row or column, we create a string representation (with a separator to handle multi-digit integers correctly) and increment the corresponding count in the appropriate hashmap.\\n3. Initialize a variable count to store the total number of pairs (ri, cj) where row ri and column cj are equal.\\n4. Iterate over the keys in rowMap. For each key that also exists in colMap, add the product of their counts in both hashmaps to count.\\n5. Return count as the total number of pairs (ri, cj) where row ri and column cj are equal.\\n\\n# Complexity\\n**Time complexity:** The time complexity is O(n^2) because we have to iterate through the matrix to populate rowMap and colMap, which takes O(n^2) time. We then iterate through the keys in rowMap (in the worst case, there are n keys), and for each key, we check its existence in colMap and retrieve the count, which takes O(1) time. So the total time complexity is O(n^2) + O(n) = O(n^2).\\n**Space complexity:** The space complexity is O(n^2) because in the worst case, if all rows and columns are unique, we store n keys in both rowMap and colMap, and each key is a string representation of a row or a column, which has length n. So the total space complexity is O(n^2) + O(n^2) = O(n^2).\\n\\nUpvote if you like the solution and explaination! \\uD83D\\uDC4D\\u2764\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        Map<String, Integer> rowMap = new HashMap<>();\\n        Map<String, Integer> colMap = new HashMap<>();\\n\\n        for(int i = 0; i < len; i++) {\\n            String row = \"\";\\n            String col = \"\";\\n            for(int j = 0; j < len; j++) {\\n                row += grid[i][j] + \",\";\\n                col += grid[j][i] + \",\";\\n            }\\n            rowMap.put(row, rowMap.getOrDefault(row, 0) + 1);\\n            colMap.put(col, colMap.getOrDefault(col, 0) + 1);\\n        }\\n\\n        int count = 0;\\n        for(String s: rowMap.keySet()) {\\n            if(colMap.containsKey(s)) {\\n                count += rowMap.get(s) * colMap.get(s);;\\n            } \\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        Map<String, Integer> rowMap = new HashMap<>();\\n        Map<String, Integer> colMap = new HashMap<>();\\n\\n        for(int i = 0; i < len; i++) {\\n            String row = \"\";\\n            String col = \"\";\\n            for(int j = 0; j < len; j++) {\\n                row += grid[i][j] + \",\";\\n                col += grid[j][i] + \",\";\\n            }\\n            rowMap.put(row, rowMap.getOrDefault(row, 0) + 1);\\n            colMap.put(col, colMap.getOrDefault(col, 0) + 1);\\n        }\\n\\n        int count = 0;\\n        for(String s: rowMap.keySet()) {\\n            if(colMap.containsKey(s)) {\\n                count += rowMap.get(s) * colMap.get(s);;\\n            } \\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670344,
                "title": "c-hashing-maps",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> mp;\\n        int n= grid.size();\\n        for (auto vec: grid){\\n            mp[vec]++;\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            vector<int> req;\\n            for (int j=0; j<n; j++)req.push_back(grid[j][i]);\\n            ans+= mp[req];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> mp;\\n        int n= grid.size();\\n        for (auto vec: grid){\\n            mp[vec]++;\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            vector<int> req;\\n            for (int j=0; j<n; j++)req.push_back(grid[j][i]);\\n            ans+= mp[req];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659438,
                "title": "super-fast-and-simple-javascript-solution-beats-99-8",
                "content": "```js\\nconst equalPairs = (grid) => {\\n    \\n    rowMap = {};\\n    let count = 0;\\n\\n    // create stringified map of every row\\n    for (let r = 0; r < grid.length; r++) {\\n        const key = JSON.stringify(grid[r]);\\n        rowMap[key] = (rowMap[key] || 0) + 1;\\n    }\\n\\n    // count number of rows that are equal to cols\\n    for (let r = 0; r < grid.length; r++) {\\n        const col = [];\\n        for (let c = 0; c < grid[0].length; c++) {\\n            col.push(grid[c][r]);\\n        }\\n        const key = JSON.stringify(col);\\n        if (key in rowMap) count += rowMap[key];\\n    }\\n\\n    return count;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```js\\nconst equalPairs = (grid) => {\\n    \\n    rowMap = {};\\n    let count = 0;\\n\\n    // create stringified map of every row\\n    for (let r = 0; r < grid.length; r++) {\\n        const key = JSON.stringify(grid[r]);\\n        rowMap[key] = (rowMap[key] || 0) + 1;\\n    }\\n\\n    // count number of rows that are equal to cols\\n    for (let r = 0; r < grid.length; r++) {\\n        const col = [];\\n        for (let c = 0; c < grid[0].length; c++) {\\n            col.push(grid[c][r]);\\n        }\\n        const key = JSON.stringify(col);\\n        if (key in rowMap) count += rowMap[key];\\n    }\\n\\n    return count;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3636603,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int ans=0;\\n        // iterate rows\\n        for(int row=0; row<grid.Length; row++){\\n            // for each row iterate columns to find matches\\n            // this for loop iterate columns\\n            for(int col=0;col<grid.Length;col++){\\n                ans++;\\n                // now compare each col to the current row\\n                for(int i=0;i<grid.Length;i++){\\n                    if(grid[row][i]!=grid[i][col]){\\n                        ans--;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int ans=0;\\n        // iterate rows\\n        for(int row=0; row<grid.Length; row++){\\n            // for each row iterate columns to find matches\\n            // this for loop iterate columns\\n            for(int col=0;col<grid.Length;col++){\\n                ans++;\\n                // now compare each col to the current row\\n                for(int i=0;i<grid.Length;i++){\\n                    if(grid[row][i]!=grid[i][col]){\\n                        ans--;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636373,
                "title": "c-brute-force-easy-understanding",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a `temp` matrix & copy `grid` into it \\n2. **Rotate the temp matrix** \\n3. *Compare the rows* of both the matrices now\\n4. If row of grid & temp matrix is same then *increase the count* \\n5. **Return count** in the end\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() ;\\n        int cnt = 0 ;\\n        vector<vector<int>> temp = grid ;\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = i ; j < n ; j ++)\\n            {\\n                swap(temp[i][j], temp[j][i]) ;              \\n            }\\n        }\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = 0 ; j < n ; j ++)\\n            {\\n                if (grid[i] == temp[j])\\n                {\\n                    cnt ++ ;\\n                }\\n            }\\n        }\\n        return cnt ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/34f022a6-57c6-486e-aea8-7a98397b0fd3_1686728313.9694998.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() ;\\n        int cnt = 0 ;\\n        vector<vector<int>> temp = grid ;\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = i ; j < n ; j ++)\\n            {\\n                swap(temp[i][j], temp[j][i]) ;              \\n            }\\n        }\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = 0 ; j < n ; j ++)\\n            {\\n                if (grid[i] == temp[j])\\n                {\\n                    cnt ++ ;\\n                }\\n            }\\n        }\\n        return cnt ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636026,
                "title": "sipmle-python-solution-100-faster-then-you",
                "content": "# Intuition\\nI like rotate matrix :) \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        upvote_please = 0      \\n        d = {}\\n        for rot in tuple(zip(*grid)):\\n            if rot not in d:\\n                d[rot]=1\\n            else:\\n                d[rot]+=1\\n        for gr in grid:\\n            if tuple(gr) in d:\\n                upvote_please+=d[tuple(gr)]\\n        return upvote_please\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        upvote_please = 0      \\n        d = {}\\n        for rot in tuple(zip(*grid)):\\n            if rot not in d:\\n                d[rot]=1\\n            else:\\n                d[rot]+=1\\n        for gr in grid:\\n            if tuple(gr) in d:\\n                upvote_please+=d[tuple(gr)]\\n        return upvote_please\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634590,
                "title": "java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompare every element with every element\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> Compare every row with every column.**Bold**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n    /*This function compares the row with all the existing columns\\n    and returns the number of common column with the input row*/\\n    static int compare(int[][] grid, int[] ar,int n){\\n        boolean flag = true;\\n        int k=0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(ar[k++] != grid[j][i]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) ans++;\\n            else flag = true;\\n            k=0;\\n        }\\n        return ans;\\n    }\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int ans = 0;\\n        /*This just iterates through every row and uses the \\n        compare function to add the result into the global result */\\n        for(int i=0;i<n;i++){\\n            int[] row = grid[i];\\n            ans += compare(grid,row,n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    /*This function compares the row with all the existing columns\\n    and returns the number of common column with the input row*/\\n    static int compare(int[][] grid, int[] ar,int n){\\n        boolean flag = true;\\n        int k=0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(ar[k++] != grid[j][i]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) ans++;\\n            else flag = true;\\n            k=0;\\n        }\\n        return ans;\\n    }\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int ans = 0;\\n        /*This just iterates through every row and uses the \\n        compare function to add the result into the global result */\\n        for(int i=0;i<n;i++){\\n            int[] row = grid[i];\\n            ans += compare(grid,row,n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634484,
                "title": "easiest-c-code-with-o-n-2-complexity-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is quiet simple first we copy the original matrix then transpose the original matrix after transpose row become column and column become row now we will check the row of transpose and copied matrix using loop if rows of both the matrix are same then we will do cnt++ and then return cnt\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int cnt=0;\\n        vector<vector<int>>c=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(grid[i][j],grid[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==c[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nPlease Upvote :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int cnt=0;\\n        vector<vector<int>>c=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(grid[i][j],grid[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==c[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634482,
                "title": "c-easy-and-readable-solution-less-than-84",
                "content": "![image.png](https://assets.leetcode.com/users/images/f46f1a9c-4a0d-4880-9711-3d55b82b3c76_1686679900.7108681.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int EqualPairs(int[][] g) {\\n        int ans = 0;\\n        for (int i = 0; i < g.Length; i++)\\n            for (int j = 0; j < g.Length; j++)\\n            {\\n                int check = 0;\\n                for (int k = 0; k < g.Length; k++)\\n                    if (g[i][k] == g[k][j])\\n                        check++;\\n                if (check == g.Length)\\n                    ans++;\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] g) {\\n        int ans = 0;\\n        for (int i = 0; i < g.Length; i++)\\n            for (int j = 0; j < g.Length; j++)\\n            {\\n                int check = 0;\\n                for (int k = 0; k < g.Length; k++)\\n                    if (g[i][k] == g[k][j])\\n                        check++;\\n                if (check == g.Length)\\n                    ans++;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634454,
                "title": "easy-to-understand-c-code-complete-explanation-o-n-2-time-complexity-hashmap",
                "content": "# Intuition\\nWe will use mashmap for this problem.\\nconvert every row of the matrix into a string and store it as a key value in an **unordered** map.\\nincrement value of map corresponding to key value each time you find a string in each row.\\nNow iterate over each columns and similarly convert it into string and add the corresponding value found in rowmap to the answer,\\nreturn the result.\\n\\nKindly upvote if you like the solution.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string mapstr(vector<int>& row){\\n        string str = \"\";\\n        for(auto it : row){\\n           str+=to_string(it);\\n           str+=\"#\";\\n        }\\n        return str;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string,int>m;\\n\\n        for(vector<int> row : grid){\\n            m[mapstr(row)]++;\\n        }\\n        int result = 0;\\n\\n        for(int j = 0 ; j < grid[0].size() ; j++){\\n            string finder = \"\";\\n            for(int i = 0 ; i < grid.size() ; i++){\\n                finder+=to_string(grid[i][j]);\\n                finder+=\"#\";\\n            }\\n            result+=m[finder];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mapstr(vector<int>& row){\\n        string str = \"\";\\n        for(auto it : row){\\n           str+=to_string(it);\\n           str+=\"#\";\\n        }\\n        return str;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string,int>m;\\n\\n        for(vector<int> row : grid){\\n            m[mapstr(row)]++;\\n        }\\n        int result = 0;\\n\\n        for(int j = 0 ; j < grid[0].size() ; j++){\\n            string finder = \"\";\\n            for(int i = 0 ; i < grid.size() ; i++){\\n                finder+=to_string(grid[i][j]);\\n                finder+=\"#\";\\n            }\\n            result+=m[finder];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634370,
                "title": "c-using-hashmaps",
                "content": "First we will create a map of rows being the key.Then we will create a vector of columns and check if the vector is presented in the map. If yes we will add it to count.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        map<vector<int>, int> um;\\n        // creating a map of row\\n        for(int i=0;i<n;i++){\\n            um[grid[i]]++;\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            vector<int> vec;\\n            // creating a vector of columns\\n            for(int j=0;j<n;j++){\\n                vec.push_back(grid[j][i]);\\n            }\\n            // adding the corresponding value of keys into count; \\n            count+=um[vec];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        map<vector<int>, int> um;\\n        // creating a map of row\\n        for(int i=0;i<n;i++){\\n            um[grid[i]]++;\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            vector<int> vec;\\n            // creating a vector of columns\\n            for(int j=0;j<n;j++){\\n                vec.push_back(grid[j][i]);\\n            }\\n            // adding the corresponding value of keys into count; \\n            count+=um[vec];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634366,
                "title": "daily-challenge-6-13-2023-python3-easy-solution",
                "content": "# Intuition\\nTo approach this, simply make a rotated grid and compare each rows see if they are duplicate. \\nRuntime 496 ms Beats 72.9%\\nMemory 21.3 MB Beats 82.96%\\n\\n# Approach\\n1.  Using zip() to make a rotation grid.\\n    rotatedgrid = list(zip(*grid)):\\n    [3,2,1]->[3,1,2]\\n    [1,7,6]->[2,7,7]\\n    [2,7,7]->[1,6,7]\\n\\n2.  Store each row as Tuple in a dictionary.\\n    In case there are duplicate rows in grid, save tuple(row) as key and counts as value in dictionary.\\n\\n3.  Loop \"rotatedgrid\" check if row is in the dictionary, add the value to answer.\\n(value means how many times it duplicate with origin  rows)\\n\\n# Complexity\\n- Time complexity:\\nO(n * m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        gridset = defaultdict(int)\\n        rotatedgrid = list(zip(*grid))\\n        ans = 0\\n        for row in grid :\\n            gridset[tuple(row)] += 1\\n        for column in rotatedgrid :\\n            if column in gridset :\\n                ans += gridset[tuple(column)]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        gridset = defaultdict(int)\\n        rotatedgrid = list(zip(*grid))\\n        ans = 0\\n        for row in grid :\\n            gridset[tuple(row)] += 1\\n        for column in rotatedgrid :\\n            if column in gridset :\\n                ans += gridset[tuple(column)]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634327,
                "title": "magical-solution-using-string-and",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<string>v2;\\n        vector<string>v1;\\n        int n= grid[0].size();\\n        int c=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n          string v3=\"\";\\n          string v4=\"\";\\n          for(int j=0;j<n;j++)\\n          {\\n             v3=v3+\",\"+to_string(grid[i][j]);\\n             v4=v4+\",\"+to_string(grid[j][i]);\\n          }\\n          v1.push_back(v3);\\n          v2.push_back(v4);\\n          \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v1[i]==v2[j])\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<string>v2;\\n        vector<string>v1;\\n        int n= grid[0].size();\\n        int c=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n          string v3=\"\";\\n          string v4=\"\";\\n          for(int j=0;j<n;j++)\\n          {\\n             v3=v3+\",\"+to_string(grid[i][j]);\\n             v4=v4+\",\"+to_string(grid[j][i]);\\n          }\\n          v1.push_back(v3);\\n          v2.push_back(v4);\\n          \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v1[i]==v2[j])\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634271,
                "title": "easy-code-no-complication",
                "content": "just simply run loops to put all the rows as String in hashMap\\nthen check if columns exist in hashMap or not\\n\\nas easy as that\\n\\ndo not know why people are over-complicating this question\\n\\nthe code should be self explanatory\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        return util1(grid);\\n    }\\n    public int util1(int[][] grid) {\\n        HashMap<String, Integer> hm = new HashMap<>();\\n        for (int[] arr : grid) {\\n            String toAdd = \"\";\\n            for (int i : arr) {\\n                toAdd = toAdd + \" \" + i;\\n            }\\n            int toPut = 1;\\n            if (hm.containsKey(toAdd)) {\\n                toPut = hm.get(toAdd) + 1;\\n            }\\n            hm.put(toAdd, toPut);\\n        }\\n        int ans = 0;\\n        for (int j = 0; j < grid[0].length; j++) {\\n            String toCheck = \"\";\\n            for (int i = 0; i < grid.length; i++) {\\n                toCheck = toCheck + \" \" + grid[i][j];\\n            }\\n            if (hm.containsKey(toCheck)) {\\n                ans += hm.get(toCheck);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        return util1(grid);\\n    }\\n    public int util1(int[][] grid) {\\n        HashMap<String, Integer> hm = new HashMap<>();\\n        for (int[] arr : grid) {\\n            String toAdd = \"\";\\n            for (int i : arr) {\\n                toAdd = toAdd + \" \" + i;\\n            }\\n            int toPut = 1;\\n            if (hm.containsKey(toAdd)) {\\n                toPut = hm.get(toAdd) + 1;\\n            }\\n            hm.put(toAdd, toPut);\\n        }\\n        int ans = 0;\\n        for (int j = 0; j < grid[0].length; j++) {\\n            String toCheck = \"\";\\n            for (int i = 0; i < grid.length; i++) {\\n                toCheck = toCheck + \" \" + grid[i][j];\\n            }\\n            if (hm.containsKey(toCheck)) {\\n                ans += hm.get(toCheck);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634066,
                "title": "easy-solution-3-loop-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int result = 0;\\n        int len = grid.Length;\\n\\n        for(int i=0; i<len; i++){\\n            for(int j=0; j<len; j++){\\n                int checker = 0;\\n                for(int z = 0; z<len; z++){\\n                    if(grid[i][z] == grid[z][j]){\\n                        checker++;\\n                    }\\n                }\\n                if(checker == len){\\n                    result++;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int result = 0;\\n        int len = grid.Length;\\n\\n        for(int i=0; i<len; i++){\\n            for(int j=0; j<len; j++){\\n                int checker = 0;\\n                for(int z = 0; z<len; z++){\\n                    if(grid[i][z] == grid[z][j]){\\n                        checker++;\\n                    }\\n                }\\n                if(checker == len){\\n                    result++;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633822,
                "title": "c-solution-using-ordered-map-of-vector-and-int",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n       map<vector<int>,int> mp;\\n\\n       int res=0;\\n\\n       int row=grid.size();\\n       int col=grid[0].size();\\n\\n       for(int i=0;i<row;i++){\\n           mp[grid[i]]++;\\n       }\\n\\n       for(int i=0;i<col;i++){\\n\\n           vector<int> temp;\\n\\n           for(int j=0;j<row;j++){\\n               temp.push_back(grid[j][i]);\\n           }\\n\\n           res+=mp[temp];\\n       }\\n    \\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n       map<vector<int>,int> mp;\\n\\n       int res=0;\\n\\n       int row=grid.size();\\n       int col=grid[0].size();\\n\\n       for(int i=0;i<row;i++){\\n           mp[grid[i]]++;\\n       }\\n\\n       for(int i=0;i<col;i++){\\n\\n           vector<int> temp;\\n\\n           for(int j=0;j<row;j++){\\n               temp.push_back(grid[j][i]);\\n           }\\n\\n           res+=mp[temp];\\n       }\\n    \\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633794,
                "title": "c-super-cool-easy-to-grasp-self-explanatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        map<vector<int>,int> mp;\\n        for(int i=0; i<n; i++){\\n            mp[grid[i]]++;\\n        }\\n        int count = 0;\\n        for(int c=0; c<n; c++){\\n            vector<int> temp;\\n            for(int r=0; r<n; r++){\\n                temp.push_back(grid[r][c]);\\n            }\\n            if(mp.find(temp) != mp.end()) count += mp[temp];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        map<vector<int>,int> mp;\\n        for(int i=0; i<n; i++){\\n            mp[grid[i]]++;\\n        }\\n        int count = 0;\\n        for(int c=0; c<n; c++){\\n            vector<int> temp;\\n            for(int r=0; r<n; r++){\\n                temp.push_back(grid[r][c]);\\n            }\\n            if(mp.find(temp) != mp.end()) count += mp[temp];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633741,
                "title": "hashmap-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string, int> m;\\n        int n=grid.size();\\n        int count=0;\\n        string s1=\"\";\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[i][j]);\\n                s1+=\\'.\\';\\n            }\\n            m[s1]++;\\n            s1=\"\";\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[j][i]);\\n                s1+=\\'.\\';\\n            }\\n            count+=m[s1];\\n            s1=\"\";\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string, int> m;\\n        int n=grid.size();\\n        int count=0;\\n        string s1=\"\";\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[i][j]);\\n                s1+=\\'.\\';\\n            }\\n            m[s1]++;\\n            s1=\"\";\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[j][i]);\\n                s1+=\\'.\\';\\n            }\\n            count+=m[s1];\\n            s1=\"\";\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633546,
                "title": "beginner-friendly-easy-to-understand-solution-c-o-n-2",
                "content": "# Intuition\\nThis solution is only for understanding better. Just you need to know about vectors in STL C++.\\n\\n# Approach\\nWe are aldready having row vectors in grid, so take column vectors in another 2D array type, and compare both of them. If found similar, increase the answer by 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2). As this is Beginner friendly, it takes O(n^2) time to solve the problem \\n\\n- Space complexity:\\nO(n^2). It takes one 2D vector, to store. So O(n^2) space complexity.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int ct = 0;\\n\\n        vector<vector<int>>coli;\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                v.push_back(grid[j][i]);\\n            }\\n            coli.push_back(v);\\n            v.clear();\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(coli[i]==grid[j]) ct += 1;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int ct = 0;\\n\\n        vector<vector<int>>coli;\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                v.push_back(grid[j][i]);\\n            }\\n            coli.push_back(v);\\n            v.clear();\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(coli[i]==grid[j]) ct += 1;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633465,
                "title": "python-solution",
                "content": "# Intuition\\nFirstly, one would need to check that for each row, how many of the same amount of columns are there. However this solution takes too long due to us having to reiterate each row/col multiple times. \\n\\n# Approach\\nTherefore, it may be better to use a hashmap or dictionary in python to store the rows and columns. This way, since the access time is O(1) and there is no need to reiterate the same problem multiple times. For each possible rows and columns in a grid, we would then store the number of times it appears.\\nAfter computing every row and column, we would then take the multiplication of the number of rows with the number of columns to find all equal row/cols pair and add it to our final answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rowdict={}\\n        for i in grid:\\n            if tuple(i) not in rowdict:\\n                rowdict[tuple(i)]=1\\n            else:\\n                rowdict[tuple(i)]+=1\\n        coldict={}\\n        for j in range(len(grid[0])):\\n            temp=[]\\n            for i in range(len(grid)):\\n                temp.append(grid[i][j])\\n            if tuple(temp) not in coldict:\\n                coldict[tuple(temp)]=1\\n            else:\\n                coldict[tuple(temp)]+=1\\n        ans=0\\n        print(rowdict)\\n        print(coldict)\\n        for key,value in rowdict.items():\\n            if key in coldict:\\n                ans=ans+(value*coldict[key])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rowdict={}\\n        for i in grid:\\n            if tuple(i) not in rowdict:\\n                rowdict[tuple(i)]=1\\n            else:\\n                rowdict[tuple(i)]+=1\\n        coldict={}\\n        for j in range(len(grid[0])):\\n            temp=[]\\n            for i in range(len(grid)):\\n                temp.append(grid[i][j])\\n            if tuple(temp) not in coldict:\\n                coldict[tuple(temp)]=1\\n            else:\\n                coldict[tuple(temp)]+=1\\n        ans=0\\n        print(rowdict)\\n        print(coldict)\\n        for key,value in rowdict.items():\\n            if key in coldict:\\n                ans=ans+(value*coldict[key])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633430,
                "title": "python-beats-100-optimised-solution",
                "content": "# Intuition\\nThe code counts the number of equal pairs of subgrids in a given grid. It uses a dictionary to store the frequency of encountered subgrids and iterates through the grid to construct and compare subgrids, incrementing the count when equal pairs are found.\\n\\n# Approach\\n1. Initialize an empty dictionary dic to store the frequency of subgrids and a variable count to keep track of the number of equal pairs.\\n\\n2. Iterate through each row i in the grid list:\\na. Convert the current row i to a string representation using str(i).\\nb. Use the get() method of the dictionary dic to retrieve the frequency of the current row. If the row is not present in the dictionary, it returns 0, to which 1 is added. Then, update the dictionary with the new frequency.\\n\\n3. Iterate over a range from 0 to the length of the grid list:\\na. Initialize an empty list temp_lst to store the current column\\'s elements.\\nb. Iterate over a range from 0 to the length of the grid list:\\n-Append the j-th element of the grid list\\'s j-th row to the temp_lst.\\nc. Convert the temp_lst to a string representation using str(temp_lst).\\nd. Use the get() method of the dictionary dic to retrieve the frequency of the current column. If the column is not present in the dictionary, it returns 0.\\ne. Add the obtained frequency to the count variable.\\nReturn the final value of the count variable, which represents the number of equal pairs of subgrids in the grid.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        dic = {}\\n        count = 0\\n        for i in grid:\\n            dic.update({str(i) : dic.get(str(i),0)+1})\\n        \\n        for i in range(len(grid)):\\n            temp_lst = []\\n            for j in range(len(grid)):\\n                temp_lst.append(grid[j][i])\\n            count += dic.get(str(temp_lst),0)\\n        return count\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        dic = {}\\n        count = 0\\n        for i in grid:\\n            dic.update({str(i) : dic.get(str(i),0)+1})\\n        \\n        for i in range(len(grid)):\\n            temp_lst = []\\n            for j in range(len(grid)):\\n                temp_lst.append(grid[j][i])\\n            count += dic.get(str(temp_lst),0)\\n        return count\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633420,
                "title": "c-easiest-and-simplest-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n\\n        int cnt = 0;\\n        int n = grid.size();\\n        map<vector<int>, int> mp;\\n\\n        for(int i=0; i<n; i++) {\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int j=0; j<n; j++) {\\n            vector<int> temp;\\n            for(int i=0; i<n; i++) {\\n                temp.push_back(grid[i][j]);\\n            }\\n            if(mp[temp]) cnt += mp[temp];\\n        }\\n\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n\\n        int cnt = 0;\\n        int n = grid.size();\\n        map<vector<int>, int> mp;\\n\\n        for(int i=0; i<n; i++) {\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int j=0; j<n; j++) {\\n            vector<int> temp;\\n            for(int i=0; i<n; i++) {\\n                temp.push_back(grid[i][j]);\\n            }\\n            if(mp[temp]) cnt += mp[temp];\\n        }\\n\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633270,
                "title": "java-beginner-friendly-for-while-loops-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni -> Iterator for the rows(ex: 0,1,2).\\nj-> Iterator for columns..resets to 0 when reaches n( ex:0,1,2 (reaches n so 0,1,2...until i reaches n) ) //Basically we compare a row with each column.\\nk->Iterates through the elements. If not equal breaks. Else if k==n which implies all elements were equal so we increment final ans c. then go to next column j++;\\nif(j reaches n) -> we go to next row and compare with all columns by reseting j to 0;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int i=0,j=0,k,c=0;\\n        while(i<n)\\n        { int v=0;\\n           if(j==n)\\n           { j=0;i++;}\\n           if(i==n)\\n           return c;\\n           for(k=0;k<n;k++)\\n           {\\n               if(grid[k][i]!=grid[j][k])\\n               break;\\n                //System.out.println(grid[k][i]+\" \"+grid[j][k]);\\n           }\\n           //System.out.println(i+\" \"+j);\\n           if(k==n)\\n           c++;\\n           j++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int i=0,j=0,k,c=0;\\n        while(i<n)\\n        { int v=0;\\n           if(j==n)\\n           { j=0;i++;}\\n           if(i==n)\\n           return c;\\n           for(k=0;k<n;k++)\\n           {\\n               if(grid[k][i]!=grid[j][k])\\n               break;\\n                //System.out.println(grid[k][i]+\" \"+grid[j][k]);\\n           }\\n           //System.out.println(i+\" \"+j);\\n           if(k==n)\\n           c++;\\n           j++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633208,
                "title": "c-o-n-2-tc-and-o-n-sc",
                "content": "```\\n#define ll long long \\n#define m 1000000007\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        map<ll,ll> r;\\n        map<ll,ll> c;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int j=0;j<g.size();j++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            c[h]++;\\n        }\\n        for(int j=0;j<g.size();j++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int i=0;i<g.size();i++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            r[h]++;\\n        }\\n        ll ans=0;\\n        for(auto& i:r)\\n        {\\n            ans=ans+i.second*c[i.first];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\n#define ll long long \\n#define m 1000000007\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        map<ll,ll> r;\\n        map<ll,ll> c;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int j=0;j<g.size();j++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            c[h]++;\\n        }\\n        for(int j=0;j<g.size();j++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int i=0;i<g.size();i++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            r[h]++;\\n        }\\n        ll ans=0;\\n        for(auto& i:r)\\n        {\\n            ans=ans+i.second*c[i.first];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633198,
                "title": "java-solution-o-2-n-2-o-n-using-hashmap",
                "content": "# Intuition\\ni thought we can simply go through each row and store the numbers as a string in a HashMap with their frequency. And then we can traverse through each column and store the number of column in a string to compare it with the HashMap elements after each column iteration ends.\\n\\n# Approach\\n1- I created a HashMap to Store each row elements as a String with their frequencies. \\n2- I started with row wise traversal where i used a StringBuilder to easily concatenate the values as a String.\\n**The reason i used \\'#\\' to append after each value is due to the case where in a row there might be all same digit numbers such as in example [[11,1],[1,11]] where when you will store the number as String without appending \\'#\\' you will get 111 and 111 which is completely wrong.**\\n3- Then i am just updating the frequencies.\\n4- Now i started with column wise traversal and storing every column as a string and then looking if the column string is present in the hashmap.\\n5- if it is present in the hashmap ,then add their frequencies to the count\\n\\n# Complexity\\n- Time complexity:\\nfrom my analysis it is -\\n\\n1. O(N^2) for row traversal \\n2. O(N^2) for column traversal \\n3. O(N) for hashMap lookup and Insertions \\n4. //correct me if i am wrong  \\n\\n- Space complexity:\\nAs i took a hashMap ,it can go as long as O(N) space complexity\\n//correct me if i am wrong\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        int n =grid.length;\\n        int m=grid[0].length;\\n        int mod=(int)1e9+7;\\n        HashMap<String,Integer>row = new HashMap<>();\\n        int count=0 ; \\n          for(int i =0 ; i<n ;i++){\\n              StringBuilder sb = new StringBuilder();\\n              for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[i][j]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n             if (row.containsKey(toMatch)) {\\n                int frequency = row.get(toMatch);\\n                row.put(toMatch, frequency + 1);\\n            } else {\\n                row.put(toMatch, 1);\\n            }\\n          }\\n          System.out.print(row);\\n          // column-wise traversal \\n           for(int i =0 ; i<n ;i++){\\n                 StringBuilder sb = new StringBuilder();\\n                for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[j][i]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n              if(row.containsKey(toMatch)){\\n                count+=row.get(toMatch); \\n              }\\n          }\\n          return count ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        int n =grid.length;\\n        int m=grid[0].length;\\n        int mod=(int)1e9+7;\\n        HashMap<String,Integer>row = new HashMap<>();\\n        int count=0 ; \\n          for(int i =0 ; i<n ;i++){\\n              StringBuilder sb = new StringBuilder();\\n              for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[i][j]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n             if (row.containsKey(toMatch)) {\\n                int frequency = row.get(toMatch);\\n                row.put(toMatch, frequency + 1);\\n            } else {\\n                row.put(toMatch, 1);\\n            }\\n          }\\n          System.out.print(row);\\n          // column-wise traversal \\n           for(int i =0 ; i<n ;i++){\\n                 StringBuilder sb = new StringBuilder();\\n                for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[j][i]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n              if(row.containsKey(toMatch)){\\n                count+=row.get(toMatch); \\n              }\\n          }\\n          return count ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633158,
                "title": "equal-row-and-column-pairs",
                "content": "# Intuition\\nWe can optimize this approach by using a hash map data structure to reduce the time complexity.\\n\\n# Approach\\nIn this approach, we can consider each row as the key and store it in a hash map. The corresponding value for each key would be the frequency of that row in the grid. Then, we can traverse through each column of the grid and increment the answer by the frequency of the equivalent row in the hash map.\\n\\n# Complexity\\n- Time complexity:   O(n^2)\\nWe iterate over each row and column only once, converting one array of length n into a hashable object takes O(n) time.\\nOperations like adding or checking on hash map take O(1) time.\\n\\n- Space complexity:   O(n^2)\\nWe store each row of the grid in the hash map, in the worst-case scenario, row_counter might contains nnn distinct rows of length n.\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count =0;\\n        n = len(grid)\\n\\n        # Keep track of the frequency of each row.\\n        row_counter = collections.Counter(tuple(row) for row in grid)\\n\\n        # Add up the frequency of each column in map.\\n        for c in range(n):\\n            col = [grid[i][c] for i in range(n)]\\n            count += row_counter[tuple(col)]\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count =0;\\n        n = len(grid)\\n\\n        # Keep track of the frequency of each row.\\n        row_counter = collections.Counter(tuple(row) for row in grid)\\n\\n        # Add up the frequency of each column in map.\\n        for c in range(n):\\n            col = [grid[i][c] for i in range(n)]\\n            count += row_counter[tuple(col)]\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633097,
                "title": "2-approach-c-o-n-1-space-and-o-n-3-time-o-n-2-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAn equal pair is formed by two rows in the grid that have the same elements in corresponding positions.\\nWe need to count the number of such equal pairs in the grid.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a map **gridRow** to store the **frequency** of each row in the grid.\\nThe **key** of the map is a vector representing a row, and the value is the frequency of that row in the grid.\\n```\\n map<vector<int>,int> gridRow;\\n```\\n- Iterate through each row in the grid and update the frequency in the gridRow map.\\nFor each row row in the grid, increment gridRow[row] by 1.\\n```\\nfor(auto x:grid){\\n            gridRow[x]++;\\n        }\\n```\\n- Create a temporary vector temp to store the elements of each column.\\n```\\n vector<int>temp;\\n```\\n- Iterate through each column in the grid.\\n\\n For each column, iterate through the rows and store the   corresponding elements in the temp vector.\\n This step effectively transposes the grid, allowing us to treat columns as rows\\n```\\n for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]);  \\n            }\\n```\\n- Check if the temp vector exists as a key in the gridRow map.\\n\\nIf it does, increment ans by the frequency of the column stored in gridRow[temp].\\nClear the temp vector to prepare it for the next column.\\n``` \\n if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; \\n            }\\n```\\n# Complexity\\n- Time complexity:**O(N^2)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(N^2)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n``` \\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        std::map<std::vector<int>, int> gridRow; // Map to store the frequency of each row\\n        int ans = 0; // Variable to store the result\\n        \\n        // Count the frequency of each row in the grid\\n        for (auto row : grid) {\\n            gridRow[row]++;\\n        }\\n        \\n        std::vector<int> temp; // Temporary vector to store each column\\n        \\n        // Iterate through each column\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]); // Store the elements of the column in the temporary vector\\n            }\\n            \\n            if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; // Increment the result by the frequency of the column in the grid\\n            }\\n            \\n            temp.clear(); // Clear the temporary vector for the next column\\n        }\\n        \\n        return ans; // Return the final result\\n    }\\n};\\n\\n```\\n# Code 2\\n```\\n \\n\\nclass Solution {\\npublic:\\n    // Function to check if all elements in a row and column are equal to grid[row][col]\\n    bool check(vector<vector<int>>& grid, int row, int col) {\\n        int size = grid.size();\\n        int r1 = 0;\\n        int c1 = 0;\\n        \\n        // Compare each element in the row with corresponding element in the column\\n        while (r1 < size) {\\n            if (grid[row][c1] != grid[r1][col]) {\\n                return false; // If any element is not equal, return false\\n            }\\n            r1++;\\n            c1++;\\n        }\\n        \\n        return true; // All elements in the row and column are equal\\n    }\\n\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        \\n        // Iterate through each element in the grid\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                if (check(grid, i, j)) {\\n                    ans++; // If all elements in the row and column are equal, increment the count\\n                }\\n            }\\n        }\\n        \\n        return ans; // Return the total count of equal pairs\\n    }\\n};\\n \\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n map<vector<int>,int> gridRow;\\n```\n```\\nfor(auto x:grid){\\n            gridRow[x]++;\\n        }\\n```\n```\\n vector<int>temp;\\n```\n```\\n for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]);  \\n            }\\n```\n``` \\n if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; \\n            }\\n```\n``` \\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        std::map<std::vector<int>, int> gridRow; // Map to store the frequency of each row\\n        int ans = 0; // Variable to store the result\\n        \\n        // Count the frequency of each row in the grid\\n        for (auto row : grid) {\\n            gridRow[row]++;\\n        }\\n        \\n        std::vector<int> temp; // Temporary vector to store each column\\n        \\n        // Iterate through each column\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]); // Store the elements of the column in the temporary vector\\n            }\\n            \\n            if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; // Increment the result by the frequency of the column in the grid\\n            }\\n            \\n            temp.clear(); // Clear the temporary vector for the next column\\n        }\\n        \\n        return ans; // Return the final result\\n    }\\n};\\n\\n```\n```\\n \\n\\nclass Solution {\\npublic:\\n    // Function to check if all elements in a row and column are equal to grid[row][col]\\n    bool check(vector<vector<int>>& grid, int row, int col) {\\n        int size = grid.size();\\n        int r1 = 0;\\n        int c1 = 0;\\n        \\n        // Compare each element in the row with corresponding element in the column\\n        while (r1 < size) {\\n            if (grid[row][c1] != grid[r1][col]) {\\n                return false; // If any element is not equal, return false\\n            }\\n            r1++;\\n            c1++;\\n        }\\n        \\n        return true; // All elements in the row and column are equal\\n    }\\n\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        \\n        // Iterate through each element in the grid\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                if (check(grid, i, j)) {\\n                    ans++; // If all elements in the row and column are equal, increment the count\\n                }\\n            }\\n        }\\n        \\n        return ans; // Return the total count of equal pairs\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633018,
                "title": "easy-c-solution-o-n2",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        map<vector<int>,vector<string>>map;\\n\\n        for(int i=0;i<n; i++){\\n            map[grid[i]].push_back(\"r\");\\n        }\\n\\n        for(int j=0; j<m; j++){\\n            vector<int>res;\\n            for(int i=0; i<n; i++){\\n                res.push_back(grid[i][j]);\\n            }\\n            map[res].push_back(\"c\");\\n        }\\n        int count=0;\\n\\n        for(auto x: map){\\n            vector<string>res = x.second;\\n            if(res.size() >1){\\n                int a = std::count(res.begin(),res.end(),\"r\");\\n                int b = std::count(res.begin(),res.end(),\"c\");\\n                count+=a*b;\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n\\n\\n// map <vector<int> , vector<string>>\\n// 3122 - r ,c\\n// 1445 - r\\n// 2422 - r, r , c \\n// 1444 - c\\n// 3522 - c\\n\\n// one row and 1 column -->total pairs ==> 1*2 \\n// 3 row 2 column --==> 6 pairs\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        map<vector<int>,vector<string>>map;\\n\\n        for(int i=0;i<n; i++){\\n            map[grid[i]].push_back(\"r\");\\n        }\\n\\n        for(int j=0; j<m; j++){\\n            vector<int>res;\\n            for(int i=0; i<n; i++){\\n                res.push_back(grid[i][j]);\\n            }\\n            map[res].push_back(\"c\");\\n        }\\n        int count=0;\\n\\n        for(auto x: map){\\n            vector<string>res = x.second;\\n            if(res.size() >1){\\n                int a = std::count(res.begin(),res.end(),\"r\");\\n                int b = std::count(res.begin(),res.end(),\"c\");\\n                count+=a*b;\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n\\n\\n// map <vector<int> , vector<string>>\\n// 3122 - r ,c\\n// 1445 - r\\n// 2422 - r, r , c \\n// 1444 - c\\n// 3522 - c\\n\\n// one row and 1 column -->total pairs ==> 1*2 \\n// 3 row 2 column --==> 6 pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632977,
                "title": "c-2-solutions-easy-methods-bruteforce-and-map",
                "content": "# Approach I\\nThe bruteforce method would be to compare each row with each column taking $$ O(n^3) $$ time and constant space.\\n\\n\\n# Approach II\\n<!-- Describe your approach to solving the problem. -->\\nBy using map (for using vector directly) or unordered map (by converting vector to string) to map every row, and then comparing every column with it.\\nIt takes $$ O(n^2) $$ time and $$ O(n^2) $$ space \\n\\nConversion to string takes extra time and memory, so its better you make your own hash function and use it with <unordered_map> (you can\\'t use vector with unordered map)\\n\\n# Code I\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n        for (int i=0; i<len; i++){\\n            for (int j=0; j<len; j++) {\\n                bool match = true;\\n                for (int k=0; k<len; k++) {\\n                    if (grid[i][k] != grid[k][j]) {match = false; break;}\\n                }\\n                count += match ? 1 : 0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\n\\n# Code II\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n\\n        unordered_map <string, int> mymap;\\n        for (int i=0; i<len; i++) {\\n            string row = \"\";\\n            for (int j=0; j<len; j++) {\\n                row += to_string(grid[i][j]) + \" \"; // We add \" \" in order to handle cases like \"1 11\" and \"11 1\".\\n            }\\n            mymap[row]++;\\n        }\\n\\n        for (int j=0; j<len; j++) {\\n            string col = \"\";\\n            for (int k=0; k<len; k++) {\\n                col += to_string(grid[k][j]) + \" \";\\n            }\\n            if (mymap.find(col) != mymap.end()) count += mymap[col];\\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n        for (int i=0; i<len; i++){\\n            for (int j=0; j<len; j++) {\\n                bool match = true;\\n                for (int k=0; k<len; k++) {\\n                    if (grid[i][k] != grid[k][j]) {match = false; break;}\\n                }\\n                count += match ? 1 : 0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n\\n        unordered_map <string, int> mymap;\\n        for (int i=0; i<len; i++) {\\n            string row = \"\";\\n            for (int j=0; j<len; j++) {\\n                row += to_string(grid[i][j]) + \" \"; // We add \" \" in order to handle cases like \"1 11\" and \"11 1\".\\n            }\\n            mymap[row]++;\\n        }\\n\\n        for (int j=0; j<len; j++) {\\n            string col = \"\";\\n            for (int k=0; k<len; k++) {\\n                col += to_string(grid[k][j]) + \" \";\\n            }\\n            if (mymap.find(col) != mymap.end()) count += mymap[col];\\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632828,
                "title": "maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        unordered_map<int , vector<int>> mp;\\n        unordered_map<int , vector<int>> mpc;\\n        \\n        map<vector<int>, int> mo;\\n        int n  = g.size();\\n        int yy = 0;\\n        for(auto &i: g )\\n            mp[yy++] = i;\\n        \\n        yy=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int > t(n);\\n            for(int j=0;j<n;j++)\\n            {\\n                t[j] = g[j][i];\\n            }\\n            \\n            mpc[yy++] = t;\\n        }\\n        \\n        \\n        int res = 0;\\n        for(auto i=mp.begin();i!=mp.end();i++)\\n        {\\n            for(auto j=mpc.begin();j!=mpc.end();j++)\\n            {\\n                if(i->second == j->second)\\n                    res++;\\n            }\\n        }\\n        return res;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        unordered_map<int , vector<int>> mp;\\n        unordered_map<int , vector<int>> mpc;\\n        \\n        map<vector<int>, int> mo;\\n        int n  = g.size();\\n        int yy = 0;\\n        for(auto &i: g )\\n            mp[yy++] = i;\\n        \\n        yy=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int > t(n);\\n            for(int j=0;j<n;j++)\\n            {\\n                t[j] = g[j][i];\\n            }\\n            \\n            mpc[yy++] = t;\\n        }\\n        \\n        \\n        int res = 0;\\n        for(auto i=mp.begin();i!=mp.end();i++)\\n        {\\n            for(auto j=mpc.begin();j!=mpc.end();j++)\\n            {\\n                if(i->second == j->second)\\n                    res++;\\n            }\\n        }\\n        return res;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632721,
                "title": "2352-equal-row-and-column-pairs-mapping",
                "content": "```\\nclass Solution {\\npublic:\\nint equalPairs(vector<vector<int>> &grid)\\n    {\\n    int ans = 0;\\n    map<vector<int>, int> map;\\n    for (int i = 0; i < grid.size(); i++)\\n    {\\n        map[grid[i]]++;\\n    }\\n    \\n    for (int j = 0; j < grid[0].size(); j++)\\n    {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            column.push_back(grid[i][j]);\\n        }\\n        ans += map[column];\\n    }\\n        return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint equalPairs(vector<vector<int>> &grid)\\n    {\\n    int ans = 0;\\n    map<vector<int>, int> map;\\n    for (int i = 0; i < grid.size(); i++)\\n    {\\n        map[grid[i]]++;\\n    }\\n    \\n    for (int j = 0; j < grid[0].size(); j++)\\n    {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            column.push_back(grid[i][j]);\\n        }\\n        ans += map[column];\\n    }\\n        return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632595,
                "title": "c-trie-o-n-2",
                "content": "If you are not familiar with `Trie` data structure you can solve [this](https://leetcode.com/problems/implement-trie-prefix-tree/) leetcode problem on trie and see [this](https://youtu.be/oobqoCJlHA0) video\\n[https://youtu.be/oobqoCJlHA0]()\\n```\\nclass trieNode{\\n    public:\\n    int count;\\n    unordered_map<int, trieNode*> children;\\n    trieNode(){\\n        this->count = 0;\\n    }\\n};\\n\\nclass Trie{\\n    public:\\n    trieNode* root;\\n    Trie(){\\n        this->root = new trieNode;\\n    }\\n\\n    void insert(vector<int> &arr){\\n        trieNode *temp = root;\\n        for(int num : arr){\\n            if(temp->children.find(num) != temp->children.end()){\\n                temp = temp->children[num];\\n            }else{\\n                trieNode* newNode = new trieNode();\\n                temp->children[num] = newNode;\\n                temp = temp->children[num];\\n            }\\n        }\\n        temp->count++;\\n    }\\n\\n    int search(vector<vector<int>> &grid, int n, int col){\\n        trieNode *temp = root;\\n        for(int i = 0; i < n; i++){\\n            if(temp->children.find(grid[i][col]) == temp->children.end()){\\n                return 0;\\n            }\\n            temp = temp->children[grid[i][col]];\\n        }\\n        return temp->count;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        Trie *myTrie = new Trie();\\n        for(auto &row : grid){\\n            myTrie->insert(row);\\n        }\\n\\n        int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            ans += myTrie->search(grid, n, col);\\n        }\\n        delete myTrie;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass trieNode{\\n    public:\\n    int count;\\n    unordered_map<int, trieNode*> children;\\n    trieNode(){\\n        this->count = 0;\\n    }\\n};\\n\\nclass Trie{\\n    public:\\n    trieNode* root;\\n    Trie(){\\n        this->root = new trieNode;\\n    }\\n\\n    void insert(vector<int> &arr){\\n        trieNode *temp = root;\\n        for(int num : arr){\\n            if(temp->children.find(num) != temp->children.end()){\\n                temp = temp->children[num];\\n            }else{\\n                trieNode* newNode = new trieNode();\\n                temp->children[num] = newNode;\\n                temp = temp->children[num];\\n            }\\n        }\\n        temp->count++;\\n    }\\n\\n    int search(vector<vector<int>> &grid, int n, int col){\\n        trieNode *temp = root;\\n        for(int i = 0; i < n; i++){\\n            if(temp->children.find(grid[i][col]) == temp->children.end()){\\n                return 0;\\n            }\\n            temp = temp->children[grid[i][col]];\\n        }\\n        return temp->count;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        Trie *myTrie = new Trie();\\n        for(auto &row : grid){\\n            myTrie->insert(row);\\n        }\\n\\n        int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            ans += myTrie->search(grid, n, col);\\n        }\\n        delete myTrie;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632583,
                "title": "easiest-approach-o-n-2-explained-in-hindi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       int n=grid.size();\\n       vector<vector<int>>trans(n,vector<int>(n,0));\\n       int count=0;\\n       //transpose matrix bana diya \\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               trans[i][j]=grid[j][i];\\n           }\\n       } \\n\\n       //har ek row grid ki transpose ki har ek row se compare kiya\\n\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               if(grid[i]==trans[j])count++;\\n           }\\n       }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       int n=grid.size();\\n       vector<vector<int>>trans(n,vector<int>(n,0));\\n       int count=0;\\n       //transpose matrix bana diya \\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               trans[i][j]=grid[j][i];\\n           }\\n       } \\n\\n       //har ek row grid ki transpose ki har ek row se compare kiya\\n\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               if(grid[i]==trans[j])count++;\\n           }\\n       }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632488,
                "title": "easy-c-solution-with-explanation-runtime-99-ms-space-28-1-mb",
                "content": "# Intuition\\n\\n# Approach\\nThere are three approaches to solve this question\\nFirst is Brute force\\nWe check each row with each column and if they are the same, we add one to the count\\nSecond is also Brute force but reduces some comparisons\\nWe store the sum of each row and column in another vector and only compare the row and column if there sums are equal\\nThird approach is using maps\\nPush all the row vectors into a map, \\nThen increment the count by the frequency of how many times a column appears in the map\\n# Complexity\\n- Time complexity:\\n    O(n^2), as we go over the whole matrix\\n- Space complexity:\\n    O(n) \\n###    \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        // Approach 1: Brute Force\\n        // int n = grid.size();\\n        // vector<int> row_sum(n,0);\\n        // vector<int> column_sum(n,0);\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         row_sum[i]+=grid[i][j];\\n        //         column_sum[i] += grid[j][i];\\n        //     }\\n        // }\\n\\n        // int count = 0;\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         if(row_sum[i] == column_sum[j]){\\n        //             bool equal = true;\\n        //             for(int k = 0; k<n; k++){\\n        //                 if(grid[i][k] != grid[k][j]){\\n        //                     equal = false;\\n        //                     break;\\n        //                 }\\n        //             }\\n        //             if(equal){\\n        //                 count++;\\n        //             }\\n        //         }\\n        //     }\\n        // }\\n        // return count;\\n\\n\\n        // Approach 2: Using maps\\n\\n        map<vector<int>, int> rows;\\n        int n = grid.size();\\n        for(int i = 0; i<n; i++){\\n            rows[grid[i]]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            vector<int> column(n);\\n            for(int j = 0; j<n; j++){\\n                column[j] = grid[j][i];\\n            }\\n            count+=rows[column];\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        // Approach 1: Brute Force\\n        // int n = grid.size();\\n        // vector<int> row_sum(n,0);\\n        // vector<int> column_sum(n,0);\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         row_sum[i]+=grid[i][j];\\n        //         column_sum[i] += grid[j][i];\\n        //     }\\n        // }\\n\\n        // int count = 0;\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         if(row_sum[i] == column_sum[j]){\\n        //             bool equal = true;\\n        //             for(int k = 0; k<n; k++){\\n        //                 if(grid[i][k] != grid[k][j]){\\n        //                     equal = false;\\n        //                     break;\\n        //                 }\\n        //             }\\n        //             if(equal){\\n        //                 count++;\\n        //             }\\n        //         }\\n        //     }\\n        // }\\n        // return count;\\n\\n\\n        // Approach 2: Using maps\\n\\n        map<vector<int>, int> rows;\\n        int n = grid.size();\\n        for(int i = 0; i<n; i++){\\n            rows[grid[i]]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            vector<int> column(n);\\n            for(int j = 0; j<n; j++){\\n                column[j] = grid[j][i];\\n            }\\n            count+=rows[column];\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632466,
                "title": "python-o-n-2-time-o-n-space-breadth-first-sequence-trie",
                "content": "# Intuition\\nI wanted to try for a solution that skipped unneccesary comparisons at the earliest possible moment, and minimized storage.\\n\\nThe approach that jumped out as a way to do this was to collect matches for each element in a sequence, then only continue to check rows and columns that continued to match. For example, collecting all the rows and columns that match for the 1st element of the sequence. Then, when we moved on to the 2nd element, we need only check that the existing matches continue to have matches with each other.\\n\\nA Trie is well suited for this task, but how it was used in this solution is very different than the suggestion in the editorial. A Breadth First approach to both constructing and validating the trie would discard invalid cases at the earliest opportunity, minimizing best case time needed. The trie nodes only representing valid matches would allow us to only store each index a maximum of 2 times each level, once for row, and once for column. This is key to the better space demands, as we don\\'t need to keep trie nodes we\\'ve already processed.\\n\\n# Approach\\nAt the end of the function, we\\'d need to return the count of the pairs. We start with a variable at the outer scope we can add to later:\\n\\n\\n```\\n+class Solution:\\n+    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        pairs_count = 0\\n+\\n+        return pairs_count\\n```\\n\\nAs an overview, I wanted to construct a Trie.\\n\\nThe keys for the children along a path down the tree would represent the values for the sequence, and the value for the key would recursively be another TrieNode\\n\\n```\\n+class TrieNodeMatches:\\n+    def __init__(self):\\n+        self.children = {}\\n+\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        root = TrieNodeMatches()\\n=        pairs_count = 0\\n=\\n=        return pairs_count\\n```\\n\\nThe children need to be populated. Our breadth first approach demands we collect rows and columns. We\\'ll start by iterating through the first row. \\n\\nEach element in the first row represents the first value in the sequence of a column. This element\\'s value will be the key for child nodes. We can\\'t know yet if there is going to be a match in rows, so for every new value we see, we create a new child node.\\n\\nIn order for us to contine testing matches along this sequence, we need to be able to continue validating along the same column. We will store all the column indexes in lists in the children TrieNodes, but if it\\'s a grid value we\\'ve already seen, it gets added to the existing node.\\n\\nWe also will need to remember which index we are on in the sequence, just the column isn\\'t enough. We will provide that to the TrieNode and store it with the constructor.\\n\\n\\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n+        self.index = index\\n+        self.columns = []\\n=        self.children = {}\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n-        root = TrieNodeMatches()\\n+        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+\\n+        for i in range(len(grid)):\\n+            n = grid[0][i]\\n+            if n not in root.children:\\n+                root.children[n] = TrieNodeMatches(1)\\n+            root.children[n].columns.append(i)\\n=\\n=        return pairs_count\\n```\\n\\nWe do something similar for the rows by iterating through the first column. \\nThe row indexes get stored in lists the children nodes too. The TrieNode index is the same, 0th element in matching sequence so nothing changes there.\\n\\nThere is a slight difference when it comes to finding grid values we haven\\'t yet seen. One way to do it would be identical to the columns, just create new children as needed and add all rows in. If we think for a moment though, this doesn\\'t make sense. Only matches are relevant and anything new doesn\\'t have a column match. Every child we created at this point would be discarded at the next step. For that reason, it is slightly better to just skip creating children for grid values we haven\\'t already seen.\\n\\nI threw in some functions that will allow us to use `print()` for TrieNode as well, which I used to help troubleshoot issues as they arose.\\n\\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n=        self.index = index\\n+        self.rows = []\\n=        self.columns = []\\n=        self.children = {}\\n+    \\n+    def __str__(self):\\n+        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n+    def __repr__(self):\\n+        return self.__str__()\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n=        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+        size = len(grid)\\n-        for i in range(len(grid)):\\n+        for i in range(size):\\n=            n = grid[0][i]\\n=            if n not in root.children:\\n=                root.children[n] = TrieNodeMatches(1)\\n=            root.children[n].columns.append(i)\\n+\\n+        for i in range(size):\\n+            n = grid[i][0]\\n+            if n in root.children:\\n+                root.children[n].rows.append(i)\\n=\\n=        return pairs_count\\n```\\n\\nAt this point, we have a root node of the Trie. The index is 0, and the keys for the children are the 1st number of the sequence. The values of the children contain the lists of row and column grid indexes that belong to that sequence and an sequence index value of 1. Their children\\'s children are emtpy, as we haven\\'t gotten to them yet, that\\'s what we need to do next. Since the plan is breadth first, we will create a queue and add the children to it. We use deque, with appendleft() and pop() for a FIFO queue.\\n\\nWhile we are adding, we will also validate. There needs to be rows and columns for a valid sequence. If either are missing, then we are finished with this sequence as this can\\'t lead to matching rows and columns. Every node will have columns, since every columns first sequence value had a node created for it, and none were created for row values with empty columns. Not every node will have rows, as there is no guarantee that they matched, so we validate that matches exist by checking that there are some positive number of rows before adding it to the queue.\\n\\n\\n```\\n=...\\n=        for i in range(size):\\n=            n = grid[i][0]\\n=            if n in root.children:\\n=                root.children[n].rows.append(i)\\n+\\n+        for t in root.children.values():\\n+            if len(t.rows) > 0:\\n+                q.appendleft(t)\\n=\\n=        return pairs_count\\n```\\n\\nNow that we have all the child nodes in a FIFO queue, Breadth First is just taking items out of the queue, then processing each child node in a way very similar to what we did with root earlier, including adding thier children. The main change is dropping the hardcoded values. The index represents both the level in the tree the node sits at, and the index in the sequence for the rows and columns that have matched so far. Up to now, we have hardcoded the index.\\n\\nWhen iterating over the columns, the way to get the `i`th element for the sequence of the column `c` from the grid is `grid[i][c]` and for row `r` its reverse, `grid[r][i]` . The formula for it\\'s change between parent and child couldn\\'t be simpler, it just increments by 1. The node index we stored with the constructor earlier is this sequence index we need. Since it\\'s availible on the node we are working with, we have what we need for these dynamic values.\\n\\n\\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+\\n+        while q:\\n+            t = q.pop()\\n+\\n+            for c in t.columns:\\n+                n = grid[t.index][c]\\n+                if n not in t.children:\\n+                    t.children[n] = TrieNodeMatches(t.index + 1)\\n+                t.children[n].columns.append(c)\\n+            \\n+            for r in t.rows:\\n+                n = grid[r][t.index]\\n+                if n in t.children:\\n+                    t.children[n].rows.append(r)\\n+            \\n+            for t2 in t.children.values():\\n+                if len(t2.rows) > 0:\\n+                    q.appendleft(t2)\\n=        \\n=        return pairs_count\\n```\\n\\nAt this point, if there are any valid matches, our loop will run over the end of the grid, and try to access invalid indexes. We need to test for reaching the end of sequences, and then act by adding the valid pair amount to the `pairs_count`. The amount of pairs to add is multiplication, each column matches with every row. Critically, we can\\'t let it attempt anything else in the loop for this sequence, as we want to avoid both accessing out of bound indexes, and stop adding children. We don\\'t want to break the loop though, there could still be valid pairs to process in the queue, so we `continue` to skip to the next node. Each node remaining will get processed without adding children until the queue is empty, exiting the loop.\\n\\n```\\n=...\\n=        while q:\\n=            t = q.pop()\\n+\\n+            if t.index == size:\\n+                pairs_count += len(t.rows) * len(t.columns)\\n+                continue\\n=\\n=            for c in t.columns:\\n=...\\n```\\n\\nJust one more thing to add... One of the main benefits to this method is the reduced need to store data, but if you are paying attention, so far we have n levels in the tree which each have up to 2n values. That\\'s O(n<sup>2</sup>) which doesn\\'t save space at all. But, after putting all the children into the queue, we never revisit that node ever again. The node can be discarded. If we do, we will almost always have the equivalent of one level of the trie in memory during the breadth first processing. The one exception is when we have added the rows and columns to the children and are adding them to the queue. \\n\\nWe will evaluate 2 bad cases, one where all grid values are identical, and one where each row matches a different column:\\n\\nOne case, where all values in the grid are identical, each level will be 1 node with 2 lists, each having n values for 2n space. While creating and appending the children to the queue, we would have the lists for at most 2 levels in memory, for an upper limit of 4n grid index values, 2 indexes, and 1 int key, in addition to 2 ints and the deque with 2 items. O(4n + ~7) is O(n)\\n\\nAn alternative, where each row matches a different column, would have n nodes at each level of the trie, each with 1 match. Thats n items in the queue, n index values, 1 keys for children and 2n + 2 items in node lists, in addition to the 2 outer scope ints. I think this evalutates closer to O(3n + 4). Still O(n)\\n\\nAny other cases should get better space results than the worst of these 2.\\nThis gets O(n) space.\\n\\n\\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+        \\n+        del root\\n=\\n=        while q:\\n=...\\n=            for t2 in t.children.values():\\n=                if len(t2.rows) > 0:\\n=                    q.appendleft(t2)\\n+            \\n+            del t\\n=        \\n=        return pairs_count\\n```\\n\\n\\n# Complexity\\nWhere n is the length of a side of the grid.\\n- Time complexity:\\nO(n<sup>2</sup>)\\nWorst case is all rows and columns have matches. A grid with every value identical, or some alternative patterns where the sequences are different but every sequence has a match would have each element of the grid visted twice with this solution. Some value of O(n<sup>2</sup>) should be the minimum, as in this worst case any algorithm would need to visit and check every element, and there are n<sup>2</sup> elements.\\nBest case, at each index in range(n), all sequences that stop matching are discarded, leaving unneccesary elements never visited.\\n\\n- Space complexity:\\nO(n)\\nA tree of n levels is created, and each levels nodes contain arrays. if the entire level had that levels arrays concatenated, worst case would be 2n per level.\\nIf the entire tree was kept, that would be O(n<sup>2</sup>), but nodes are discarded after processing, with worst case 1 full level of the tree and 1 nodes children in memory. For a grid with identical values, that\\'s a cap of 2 levels: 4 lists with n length, but 4n is O(n), far better than O(n<sup>2</sup>) for large n\\'s\\n\\n\\n# Code\\n```\\nclass TrieNodeMatches:\\n    def __init__(self, index):\\n        self.index = index\\n        self.rows = []\\n        self.columns = []\\n        self.children = {}\\n    \\n    def __str__(self):\\n        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n    def __repr__(self):\\n        return self.__str__()\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        q = deque()\\n        root = TrieNodeMatches(0)\\n        pairs_count = 0\\n        size = len(grid)\\n        for i in range(size):\\n            n = grid[0][i]\\n            if n not in root.children:\\n                root.children[n] = TrieNodeMatches(1)\\n            root.children[n].columns.append(i)\\n        \\n        for i in range(size):\\n            n = grid[i][0]\\n            if n in root.children:\\n                root.children[n].rows.append(i)\\n        \\n        for t in root.children.values():\\n            if len(t.rows) > 0:\\n                q.appendleft(t)\\n        \\n        del root\\n\\n        while q:\\n            t = q.pop()\\n\\n            if t.index == size:\\n                pairs_count += len(t.rows) * len(t.columns)\\n                continue\\n            \\n            for c in t.columns:\\n                n = grid[t.index][c]\\n                if n not in t.children:\\n                    t.children[n] = TrieNodeMatches(t.index + 1)\\n                t.children[n].columns.append(c)\\n            \\n            for r in t.rows:\\n                n = grid[r][t.index]\\n                if n in t.children:\\n                    t.children[n].rows.append(r)\\n            \\n            for t2 in t.children.values():\\n                if len(t2.rows) > 0:\\n                    q.appendleft(t2)\\n            \\n            del t\\n        \\n        return pairs_count\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Trie",
                    "Queue"
                ],
                "code": "```\\n+class Solution:\\n+    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        pairs_count = 0\\n+\\n+        return pairs_count\\n```\n```\\n+class TrieNodeMatches:\\n+    def __init__(self):\\n+        self.children = {}\\n+\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        root = TrieNodeMatches()\\n=        pairs_count = 0\\n=\\n=        return pairs_count\\n```\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n+        self.index = index\\n+        self.columns = []\\n=        self.children = {}\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n-        root = TrieNodeMatches()\\n+        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+\\n+        for i in range(len(grid)):\\n+            n = grid[0][i]\\n+            if n not in root.children:\\n+                root.children[n] = TrieNodeMatches(1)\\n+            root.children[n].columns.append(i)\\n=\\n=        return pairs_count\\n```\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n=        self.index = index\\n+        self.rows = []\\n=        self.columns = []\\n=        self.children = {}\\n+    \\n+    def __str__(self):\\n+        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n+    def __repr__(self):\\n+        return self.__str__()\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n=        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+        size = len(grid)\\n-        for i in range(len(grid)):\\n+        for i in range(size):\\n=            n = grid[0][i]\\n=            if n not in root.children:\\n=                root.children[n] = TrieNodeMatches(1)\\n=            root.children[n].columns.append(i)\\n+\\n+        for i in range(size):\\n+            n = grid[i][0]\\n+            if n in root.children:\\n+                root.children[n].rows.append(i)\\n=\\n=        return pairs_count\\n```\n```\\n=...\\n=        for i in range(size):\\n=            n = grid[i][0]\\n=            if n in root.children:\\n=                root.children[n].rows.append(i)\\n+\\n+        for t in root.children.values():\\n+            if len(t.rows) > 0:\\n+                q.appendleft(t)\\n=\\n=        return pairs_count\\n```\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+\\n+        while q:\\n+            t = q.pop()\\n+\\n+            for c in t.columns:\\n+                n = grid[t.index][c]\\n+                if n not in t.children:\\n+                    t.children[n] = TrieNodeMatches(t.index + 1)\\n+                t.children[n].columns.append(c)\\n+            \\n+            for r in t.rows:\\n+                n = grid[r][t.index]\\n+                if n in t.children:\\n+                    t.children[n].rows.append(r)\\n+            \\n+            for t2 in t.children.values():\\n+                if len(t2.rows) > 0:\\n+                    q.appendleft(t2)\\n=        \\n=        return pairs_count\\n```\n```\\n=...\\n=        while q:\\n=            t = q.pop()\\n+\\n+            if t.index == size:\\n+                pairs_count += len(t.rows) * len(t.columns)\\n+                continue\\n=\\n=            for c in t.columns:\\n=...\\n```\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+        \\n+        del root\\n=\\n=        while q:\\n=...\\n=            for t2 in t.children.values():\\n=                if len(t2.rows) > 0:\\n=                    q.appendleft(t2)\\n+            \\n+            del t\\n=        \\n=        return pairs_count\\n```\n```\\nclass TrieNodeMatches:\\n    def __init__(self, index):\\n        self.index = index\\n        self.rows = []\\n        self.columns = []\\n        self.children = {}\\n    \\n    def __str__(self):\\n        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n    def __repr__(self):\\n        return self.__str__()\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        q = deque()\\n        root = TrieNodeMatches(0)\\n        pairs_count = 0\\n        size = len(grid)\\n        for i in range(size):\\n            n = grid[0][i]\\n            if n not in root.children:\\n                root.children[n] = TrieNodeMatches(1)\\n            root.children[n].columns.append(i)\\n        \\n        for i in range(size):\\n            n = grid[i][0]\\n            if n in root.children:\\n                root.children[n].rows.append(i)\\n        \\n        for t in root.children.values():\\n            if len(t.rows) > 0:\\n                q.appendleft(t)\\n        \\n        del root\\n\\n        while q:\\n            t = q.pop()\\n\\n            if t.index == size:\\n                pairs_count += len(t.rows) * len(t.columns)\\n                continue\\n            \\n            for c in t.columns:\\n                n = grid[t.index][c]\\n                if n not in t.children:\\n                    t.children[n] = TrieNodeMatches(t.index + 1)\\n                t.children[n].columns.append(c)\\n            \\n            for r in t.rows:\\n                n = grid[r][t.index]\\n                if n in t.children:\\n                    t.children[n].rows.append(r)\\n            \\n            for t2 in t.children.values():\\n                if len(t2.rows) > 0:\\n                    q.appendleft(t2)\\n            \\n            del t\\n        \\n        return pairs_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632449,
                "title": "c-intuitive-and-easy",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create another vector of vector named v such that the columns of original grid are the rows of \\'v\\'.\\nAfter that we compare the rows of the original grid to each row of the new grid and increment the count if both the rows are totally same.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> v=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                v[i][j]=grid[j][i];\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==v[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> v=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                v[i][j]=grid[j][i];\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==v[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632359,
                "title": "two-nested-loops-in-one-line-python",
                "content": "# Intuition\\nTranspose of a matrix and compare rows.\\n\\n# Approach\\nTwo nested loops.\\n\\n# Complexity\\n- Time complexity:  O(N^2)\\n\\n- Space complexity: O(N^2)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        grid = map(tuple, grid)\\n        return len([True for i in zip(*grid) for j in grid if i == j])\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        grid = map(tuple, grid)\\n        return len([True for i in zip(*grid) for j in grid if i == j])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632207,
                "title": "easy-java-solution-javith-sadham-hussain",
                "content": "# Code\\n```\\nclass Solution \\n{\\n    public int equalPairs(int[][] grid) \\n    {\\n        int countOfEqualPairs = 0;\\n        boolean blnEqual;\\n\\n        for(int idx=0; idx<grid.length; idx++)\\n        { \\n            for(int j=0; j<grid.length; j++)\\n            {\\n                blnEqual = true;\\n                for(int k=0; k<grid.length; k++)\\n                {\\n                    if(grid[idx][k] != grid[k][j])\\n                    {\\n                        blnEqual = false;\\n                        break;\\n                    }\\n                }  \\n                countOfEqualPairs += blnEqual ? 1 : 0;              \\n            }             \\n        }\\n\\n        return countOfEqualPairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int equalPairs(int[][] grid) \\n    {\\n        int countOfEqualPairs = 0;\\n        boolean blnEqual;\\n\\n        for(int idx=0; idx<grid.length; idx++)\\n        { \\n            for(int j=0; j<grid.length; j++)\\n            {\\n                blnEqual = true;\\n                for(int k=0; k<grid.length; k++)\\n                {\\n                    if(grid[idx][k] != grid[k][j])\\n                    {\\n                        blnEqual = false;\\n                        break;\\n                    }\\n                }  \\n                countOfEqualPairs += blnEqual ? 1 : 0;              \\n            }             \\n        }\\n\\n        return countOfEqualPairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632197,
                "title": "2-solutions-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 2 Solutions \\uD83D\\uDD25 || Simple Fast and Easy || with Explanation \\uD83D\\uDE08\\n\\n## Solution - 1\\n\\n```dart\\nclass Solution {\\n  List<List<int>> transpose(List<List<int>> gr) {\\n    final List<List<int>> gc = [].map((e) => <int>[]).toList();\\n    int n = gr.length;\\n\\n    for (int i = 0; i < n; i++) {\\n      final List<int> v = <int>[];\\n      for (int j = 0; j < n; j++) {\\n        v.add(gr[j][i]); // column-wise pushing\\n      }\\n      gc.add(v);\\n    }\\n\\n    return gc;\\n  }\\n\\n  bool isListEqual(List<int> listOne, List<int> listTwo) {\\n    if (listOne.length != listTwo.length) {\\n      return false;\\n    }\\n\\n    for (int i = 0; i < listOne.length; i++) {\\n      if (listOne[i] != listTwo[i]) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  int equalPairs(List<List<int>> gr) {\\n    final List<List<int>> gc = transpose(gr);\\n    final int n = gr.length;\\n\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (isListEqual(gr[i], gc[j])) {\\n          ans++;\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\\n\\n## Solution - 2\\n\\n```dart\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int equalPairs(List<List<int>> grid) {\\n    int pair = 0;\\n    int temp = 0;\\n    int row = 0;\\n\\n    while (temp <= grid.length - 1) {\\n      final HashMap<int, int> map = HashMap<int, int>();\\n      for (int j = 0; j < grid.length; j++) {\\n        map[j] = grid[row][j];\\n      }\\n      for (int i = 0; i < grid.length; i++) {\\n        int current = 0;\\n        for (int k = 0; k < grid.length; k++) {\\n          if (map[k] != grid[k][i]) {\\n            current = 0;\\n            break;\\n          } else {\\n            current = 1;\\n          }\\n        }\\n        pair += current;\\n      }\\n      row++;\\n      temp++;\\n    }\\n    return pair;\\n  }\\n}\\n```\\n### [GitHub Link](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Dart",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```dart\\nclass Solution {\\n  List<List<int>> transpose(List<List<int>> gr) {\\n    final List<List<int>> gc = [].map((e) => <int>[]).toList();\\n    int n = gr.length;\\n\\n    for (int i = 0; i < n; i++) {\\n      final List<int> v = <int>[];\\n      for (int j = 0; j < n; j++) {\\n        v.add(gr[j][i]); // column-wise pushing\\n      }\\n      gc.add(v);\\n    }\\n\\n    return gc;\\n  }\\n\\n  bool isListEqual(List<int> listOne, List<int> listTwo) {\\n    if (listOne.length != listTwo.length) {\\n      return false;\\n    }\\n\\n    for (int i = 0; i < listOne.length; i++) {\\n      if (listOne[i] != listTwo[i]) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  int equalPairs(List<List<int>> gr) {\\n    final List<List<int>> gc = transpose(gr);\\n    final int n = gr.length;\\n\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (isListEqual(gr[i], gc[j])) {\\n          ans++;\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\n```dart\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int equalPairs(List<List<int>> grid) {\\n    int pair = 0;\\n    int temp = 0;\\n    int row = 0;\\n\\n    while (temp <= grid.length - 1) {\\n      final HashMap<int, int> map = HashMap<int, int>();\\n      for (int j = 0; j < grid.length; j++) {\\n        map[j] = grid[row][j];\\n      }\\n      for (int i = 0; i < grid.length; i++) {\\n        int current = 0;\\n        for (int k = 0; k < grid.length; k++) {\\n          if (map[k] != grid[k][i]) {\\n            current = 0;\\n            break;\\n          } else {\\n            current = 1;\\n          }\\n        }\\n        pair += current;\\n      }\\n      row++;\\n      temp++;\\n    }\\n    return pair;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632182,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n\\n## Intuition\\nThe problem requires us to find the number of pairs `(ri, cj)` such that row `ri` and column `cj` are equal. We can use a hash table to store the `frequency` of each row. Then we can iterate over each column and check if it matches any row in the hash table.\\n\\n## Approach\\n1. Create a hash table to store the frequency of each row.\\n2. Iterate over each column and check if it matches any row in the hash table.\\n3. If it matches, add the frequency of that row to the `count`.\\n\\n\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mapping = defaultdict(lambda : 0)\\n        count = 0\\n        n = len(grid)\\n        for row in grid:\\n            mapping[str(row)] += 1\\n        \\n        for i in range(n):\\n            col = []\\n            for j in range(n):\\n                col.append(grid[j][i])\\n            count += mapping[str(col)]\\n        return count\\n```\\n## Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mapping = defaultdict(lambda : 0)\\n        count = 0\\n        n = len(grid)\\n        for row in grid:\\n            mapping[str(row)] += 1\\n        \\n        for i in range(n):\\n            col = []\\n            for j in range(n):\\n                col.append(grid[j][i])\\n            count += mapping[str(col)]\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632179,
                "title": "c-easy-understanding-and-easy-to-implement-clean-matrcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a matrix that are Transpose of the initial matrix and compare each row of initial matrix to each row of its transpose matrix when its equal just increment ans.\\n# Complexity\\n- Time complexity:\\n- O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0,cnt=0;\\n        int n=grid.size();\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        \\n     for(int i=0;i<grid.size();i++){\\n        \\n        for(int j=0;j<grid.size();j++){\\n         // transpose matrix\\n         v[j][i]=grid[i][j];\\n        } \\n        \\n     }\\n    for(int i=0;i<grid.size();i++){\\n      for(int j=0;j<grid.size();j++) {\\n//      compare row of transpose matrix and initial matrix\\n          if(v[j]==grid[i]){\\n              ans++;\\n          }\\n      }\\n        \\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0,cnt=0;\\n        int n=grid.size();\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        \\n     for(int i=0;i<grid.size();i++){\\n        \\n        for(int j=0;j<grid.size();j++){\\n         // transpose matrix\\n         v[j][i]=grid[i][j];\\n        } \\n        \\n     }\\n    for(int i=0;i<grid.size();i++){\\n      for(int j=0;j<grid.size();j++) {\\n//      compare row of transpose matrix and initial matrix\\n          if(v[j]==grid[i]){\\n              ans++;\\n          }\\n      }\\n        \\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1927475,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1810006,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927166,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1891948,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927325,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1928385,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927333,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927125,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927583,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1881303,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927475,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1810006,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927166,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1891948,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927325,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1928385,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927333,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927125,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927583,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1881303,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927296,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1947166,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927568,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927314,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1949055,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1932258,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927857,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927467,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 2059722,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 2046804,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 2045650,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 2001818,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1991924,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1975685,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1972771,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1965066,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1963877,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1959722,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1950408,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1929521,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1928642,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928454,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928180,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928179,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928166,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928148,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927831,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927763,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927748,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927714,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927696,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927659,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927607,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927575,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927496,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927301,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927276,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927154,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1907173,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1706555,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Design a Food Rating System",
        "question_content": "<p>Design a food rating system that can do the following:</p>\n\n<ul>\n\t<li><strong>Modify</strong> the rating of a food item listed in the system.</li>\n\t<li>Return the highest-rated food item for a type of cuisine in the system.</li>\n</ul>\n\n<p>Implement the <code>FoodRatings</code> class:</p>\n\n<ul>\n\t<li><code>FoodRatings(String[] foods, String[] cuisines, int[] ratings)</code> Initializes the system. The food items are described by <code>foods</code>, <code>cuisines</code> and <code>ratings</code>, all of which have a length of <code>n</code>.\n\n\t<ul>\n\t\t<li><code>foods[i]</code> is the name of the <code>i<sup>th</sup></code> food,</li>\n\t\t<li><code>cuisines[i]</code> is the type of cuisine of the <code>i<sup>th</sup></code> food, and</li>\n\t\t<li><code>ratings[i]</code> is the initial rating of the <code>i<sup>th</sup></code> food.</li>\n\t</ul>\n\t</li>\n\t<li><code>void changeRating(String food, int newRating)</code> Changes the rating of the food item with the name <code>food</code>.</li>\n\t<li><code>String highestRated(String cuisine)</code> Returns the name of the food item that has the highest rating for the given type of <code>cuisine</code>. If there is a tie, return the item with the <strong>lexicographically smaller</strong> name.</li>\n</ul>\n\n<p>Note that a string <code>x</code> is lexicographically smaller than string <code>y</code> if <code>x</code> comes before <code>y</code> in dictionary order, that is, either <code>x</code> is a prefix of <code>y</code>, or if <code>i</code> is the first position such that <code>x[i] != y[i]</code>, then <code>x[i]</code> comes before <code>y[i]</code> in alphabetic order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;FoodRatings&quot;, &quot;highestRated&quot;, &quot;highestRated&quot;, &quot;changeRating&quot;, &quot;highestRated&quot;, &quot;changeRating&quot;, &quot;highestRated&quot;]\n[[[&quot;kimchi&quot;, &quot;miso&quot;, &quot;sushi&quot;, &quot;moussaka&quot;, &quot;ramen&quot;, &quot;bulgogi&quot;], [&quot;korean&quot;, &quot;japanese&quot;, &quot;japanese&quot;, &quot;greek&quot;, &quot;japanese&quot;, &quot;korean&quot;], [9, 12, 8, 15, 14, 7]], [&quot;korean&quot;], [&quot;japanese&quot;], [&quot;sushi&quot;, 16], [&quot;japanese&quot;], [&quot;ramen&quot;, 16], [&quot;japanese&quot;]]\n<strong>Output</strong>\n[null, &quot;kimchi&quot;, &quot;ramen&quot;, null, &quot;sushi&quot;, null, &quot;ramen&quot;]\n\n<strong>Explanation</strong>\nFoodRatings foodRatings = new FoodRatings([&quot;kimchi&quot;, &quot;miso&quot;, &quot;sushi&quot;, &quot;moussaka&quot;, &quot;ramen&quot;, &quot;bulgogi&quot;], [&quot;korean&quot;, &quot;japanese&quot;, &quot;japanese&quot;, &quot;greek&quot;, &quot;japanese&quot;, &quot;korean&quot;], [9, 12, 8, 15, 14, 7]);\nfoodRatings.highestRated(&quot;korean&quot;); // return &quot;kimchi&quot;\n                                    // &quot;kimchi&quot; is the highest rated korean food with a rating of 9.\nfoodRatings.highestRated(&quot;japanese&quot;); // return &quot;ramen&quot;\n                                      // &quot;ramen&quot; is the highest rated japanese food with a rating of 14.\nfoodRatings.changeRating(&quot;sushi&quot;, 16); // &quot;sushi&quot; now has a rating of 16.\nfoodRatings.highestRated(&quot;japanese&quot;); // return &quot;sushi&quot;\n                                      // &quot;sushi&quot; is the highest rated japanese food with a rating of 16.\nfoodRatings.changeRating(&quot;ramen&quot;, 16); // &quot;ramen&quot; now has a rating of 16.\nfoodRatings.highestRated(&quot;japanese&quot;); // return &quot;ramen&quot;\n                                      // Both &quot;sushi&quot; and &quot;ramen&quot; have a rating of 16.\n                                      // However, &quot;ramen&quot; is lexicographically smaller than &quot;sushi&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>n == foods.length == cuisines.length == ratings.length</code></li>\n\t<li><code>1 &lt;= foods[i].length, cuisines[i].length &lt;= 10</code></li>\n\t<li><code>foods[i]</code>, <code>cuisines[i]</code> consist of lowercase English letters.</li>\n\t<li><code>1 &lt;= ratings[i] &lt;= 10<sup>8</sup></code></li>\n\t<li>All the strings in <code>foods</code> are <strong>distinct</strong>.</li>\n\t<li><code>food</code> will be the name of a food item in the system across all calls to <code>changeRating</code>.</li>\n\t<li><code>cuisine</code> will be a type of cuisine of <strong>at least one</strong> food item in the system across all calls to <code>highestRated</code>.</li>\n\t<li>At most <code>2 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>changeRating</code> and <code>highestRated</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2324669,
                "title": "three-maps",
                "content": "- `cuisine_ratings` maps cuisine to food, ordered by rating (we use a sorted set).\\n- `food_cuisine` maps food to cuisine.\\n- `food_rating` maps food to the current rating.\\n    \\nFor the `changeRating` operation, we first get the cuisine and current rating for the food. \\n    \\nThen, we remove the old food rating from `cuisine_ratings`, and add the new one.\\n\\n> Implementation note: since we need to return food with the highest rating, we put a negative rating into the set.\\n> That way, we do not have to provide a custom comparator.\\n    \\n**C++**\\n```cpp\\nclass FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int, string>>> cuisine_ratings;\\n    unordered_map<string, string> food_cuisine;\\n    unordered_map<string, int> food_rating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); ++i) {\\n            cuisine_ratings[cuisines[i]].insert({ -ratings[i], foods[i] });\\n            food_cuisine[foods[i]] = cuisines[i];\\n            food_rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto &cuisine = food_cuisine.find(food)->second;\\n        cuisine_ratings[cuisine].erase({ -food_rating[food], food });\\n        cuisine_ratings[cuisine].insert({ -newRating, food });\\n        food_rating[food] = newRating;\\n    }\\n    string highestRated(string cuisine) {\\n        return begin(cuisine_ratings[cuisine])->second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int, string>>> cuisine_ratings;\\n    unordered_map<string, string> food_cuisine;\\n    unordered_map<string, int> food_rating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); ++i) {\\n            cuisine_ratings[cuisines[i]].insert({ -ratings[i], foods[i] });\\n            food_cuisine[foods[i]] = cuisines[i];\\n            food_rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto &cuisine = food_cuisine.find(food)->second;\\n        cuisine_ratings[cuisine].erase({ -food_rating[food], food });\\n        cuisine_ratings[cuisine].insert({ -newRating, food });\\n        food_rating[food] = newRating;\\n    }\\n    string highestRated(string cuisine) {\\n        return begin(cuisine_ratings[cuisine])->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324714,
                "title": "java-priority-queue-hashmap-and-custom-class",
                "content": "**Code:**\\n    \\n    HashMap<String, PriorityQueue<Food>> x = new HashMap<>(); // get pq from cuisine name\\n    HashMap<String, Food> menu = new HashMap<>(); // get Food (object) from food name\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0; i<foods.length; i++){\\n\\t\\t\\tFood curr = new Food(foods[i], cuisines[i], ratings[i]);\\n            x.putIfAbsent(cuisines[i], new PriorityQueue<>((a,b)->\\n                b.rating==a.rating ? a.name.compareTo(b.name) : b.rating-a.rating));\\n\\t\\t\\tPriorityQueue<Food> pq = x.get(cuisines[i]);\\n            pq.add(curr);\\n            menu.put(foods[i], curr);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food curr = menu.get(food);\\n        PriorityQueue<Food> pq = x.get(curr.cuisine);\\n        pq.remove(curr);\\n        curr.rating = newRating;\\n        pq.add(curr);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return x.get(cuisine).peek().name;\\n    }\\n    \\n    class Food{\\n        int rating;\\n        String name, cuisine;\\n        Food(String name, String cuisine, int rating){\\n            this.name = name; this.rating = rating; this.cuisine = cuisine;\\n        }\\n    }\\n\\t\\n---\\n**For TreeSet Based:**\\n* replace all `PriorityQueue<Food>` with `TreeSet<Food>`\\n* use `return x.get(cuisine).first().name;` for highestRated()",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "**Code:**\\n    \\n    HashMap<String, PriorityQueue<Food>> x = new HashMap<>(); // get pq from cuisine name\\n    HashMap<String, Food> menu = new HashMap<>(); // get Food (object) from food name\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0; i<foods.length; i++){\\n\\t\\t\\tFood curr = new Food(foods[i], cuisines[i], ratings[i]);\\n            x.putIfAbsent(cuisines[i], new PriorityQueue<>((a,b)->\\n                b.rating==a.rating ? a.name.compareTo(b.name) : b.rating-a.rating));\\n\\t\\t\\tPriorityQueue<Food> pq = x.get(cuisines[i]);\\n            pq.add(curr);\\n            menu.put(foods[i], curr);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food curr = menu.get(food);\\n        PriorityQueue<Food> pq = x.get(curr.cuisine);\\n        pq.remove(curr);\\n        curr.rating = newRating;\\n        pq.add(curr);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return x.get(cuisine).peek().name;\\n    }\\n    \\n    class Food{\\n        int rating;\\n        String name, cuisine;\\n        Food(String name, String cuisine, int rating){\\n            this.name = name; this.rating = rating; this.cuisine = cuisine;\\n        }\\n    }\\n\\t\\n---\\n**For TreeSet Based:**\\n* replace all `PriorityQueue<Food>` with `TreeSet<Food>`\\n* use `return x.get(cuisine).first().name;` for highestRated()",
                "codeTag": "Java"
            },
            {
                "id": 2324713,
                "title": "c-map",
                "content": "HAPPY CODING :)\\n \\n **IF YOU LEARN SOMETHING FROM THIS POST, DO UPVOTE :)**\\n```\\nclass FoodRatings {\\npublic:\\n    map<string,set<pair<int,string>>> s;\\n    unordered_map<string,string> cus;\\n    unordered_map<string,int> rat;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();++i)\\n        {\\n            s[cuisines[i]].insert({-ratings[i],foods[i]});\\n            cus[foods[i]]=cuisines[i];\\n            rat[foods[i]]=-ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int r=rat[food];\\n        string c=cus[food];\\n        s[c].erase({r,food});\\n        s[c].insert({-newRating,food});\\n        rat[food]=-newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        pair<int,string> p= *(s[cuisine].begin());\\n        return p.second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    map<string,set<pair<int,string>>> s;\\n    unordered_map<string,string> cus;\\n    unordered_map<string,int> rat;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();++i)\\n        {\\n            s[cuisines[i]].insert({-ratings[i],foods[i]});\\n            cus[foods[i]]=cuisines[i];\\n            rat[foods[i]]=-ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int r=rat[food];\\n        string c=cus[food];\\n        s[c].erase({r,food});\\n        s[c].insert({-newRating,food});\\n        rat[food]=-newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        pair<int,string> p= *(s[cuisine].begin());\\n        return p.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324791,
                "title": "python3-sortedlist",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/d61cd3ed09bbf59fd619802a6e861a516ec17094) for solutions of weekly 303. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.mp = {}\\n        self.data = defaultdict(SortedList)\\n        for food, cuisine, rating in zip(foods, cuisines, ratings): \\n            self.mp[food] = (cuisine, rating)\\n            self.data[cuisine].add((-rating, food))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, rating = self.mp[food]\\n        self.mp[food] = cuisine, newRating\\n        self.data[cuisine].remove((-rating, food))\\n        self.data[cuisine].add((-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.data[cuisine][0][1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.mp = {}\\n        self.data = defaultdict(SortedList)\\n        for food, cuisine, rating in zip(foods, cuisines, ratings): \\n            self.mp[food] = (cuisine, rating)\\n            self.data[cuisine].add((-rating, food))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, rating = self.mp[food]\\n        self.mp[food] = cuisine, newRating\\n        self.data[cuisine].remove((-rating, food))\\n        self.data[cuisine].add((-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.data[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324852,
                "title": "python-hashmap-heap-extravaganza",
                "content": "We have a heap for each cuisine. We push to the heap whenever we update a rating. We check the rating is current before returning the Highest rating.\\n\\n```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.foods = foods; self.cuisines = cuisines; self.ratings = ratings\\n        self.index = dict(zip(foods, range(n)))\\n        self.cuisinesMap = defaultdict(list)\\n        for i, cuisine in enumerate(cuisines):\\n            heappush(self.cuisinesMap[cuisine], (-self.ratings[i], self.foods[i]))\\n            \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        i = self.index[food]\\n        self.ratings[i] = newRating; cuisine = self.cuisines[i]\\n        heappush(self.cuisinesMap[cuisine], (-self.ratings[i], self.foods[i]))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisinesMap[cuisine][0]\\n        while rating != -self.ratings[self.index[food]]:  # check highest rating is current\\n            heappop(self.cuisinesMap[cuisine])\\n            rating, food = self.cuisinesMap[cuisine][0]\\n        return food\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.foods = foods; self.cuisines = cuisines; self.ratings = ratings\\n        self.index = dict(zip(foods, range(n)))\\n        self.cuisinesMap = defaultdict(list)\\n        for i, cuisine in enumerate(cuisines):\\n            heappush(self.cuisinesMap[cuisine], (-self.ratings[i], self.foods[i]))\\n            \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        i = self.index[food]\\n        self.ratings[i] = newRating; cuisine = self.cuisines[i]\\n        heappush(self.cuisinesMap[cuisine], (-self.ratings[i], self.foods[i]))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisinesMap[cuisine][0]\\n        while rating != -self.ratings[self.index[food]]:  # check highest rating is current\\n            heappop(self.cuisinesMap[cuisine])\\n            rating, food = self.cuisinesMap[cuisine][0]\\n        return food\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324903,
                "title": "heap-and-hashmap-fully-explained",
                "content": "Our goal is to return quickly the most rated food for the queried cuisine.\\n\\nWe can achieve this with a `heap`\\n\\nNow there is also a functionality to change the rating of a food item.\\n\\nWe could find it in the heap and mutate, but it will be too slow and lose the point of the heap.\\n\\nInstead of that we will do **lazy deletion** with the help of a hash map\\n\\n`food_to_latest_ratings` hashmap will save the latest rating for a specific food, and if the value we found in the heap doesn\\'t match we know that the entry was obsolete, so we continue searching for the next one which is valid.\\n\\nAlso we need to create a custom class `RatedFood` to sort lexicographically as the second sort condition (at least in python)\\n\\n```\\nfrom heapq import heapify, heappop, heappush\\n\\nclass RatedFood:\\n    def __init__(self, rating, food):\\n        self.rating = rating\\n        self.food = food\\n        \\n    def __lt__(self, other):\\n        if other.rating == self.rating:\\n            return self.food < other.food\\n        return self.rating < other.rating\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuis_to_score_heap = defaultdict(list)\\n        self.food_to_latest_ratings = defaultdict(int)\\n        self.food_to_cuis = defaultdict(str)\\n        \\n        for food, cuis, rating in zip(foods, cuisines, ratings):\\n            self.food_to_cuis[food] = cuis\\n            self.food_to_latest_ratings[food] = rating\\n            heappush(self.cuis_to_score_heap[cuis], RatedFood(-rating, food))\\n        \\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_to_latest_ratings[food] = newRating\\n        cuis = self.food_to_cuis[food]\\n        heappush(self.cuis_to_score_heap[cuis], RatedFood(-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while True:\\n            ratedFood = heappop(self.cuis_to_score_heap[cuisine])\\n            if self.food_to_latest_ratings[ratedFood.food] == (-ratedFood.rating):\\n\\t\\t\\t\\n\\t\\t\\t\\t# because the food item is still valid, we put it back into the heap\\n                heappush(self.cuis_to_score_heap[cuisine], ratedFood)\\n\\t\\t\\t\\t\\n                return ratedFood.food\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify, heappop, heappush\\n\\nclass RatedFood:\\n    def __init__(self, rating, food):\\n        self.rating = rating\\n        self.food = food\\n        \\n    def __lt__(self, other):\\n        if other.rating == self.rating:\\n            return self.food < other.food\\n        return self.rating < other.rating\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuis_to_score_heap = defaultdict(list)\\n        self.food_to_latest_ratings = defaultdict(int)\\n        self.food_to_cuis = defaultdict(str)\\n        \\n        for food, cuis, rating in zip(foods, cuisines, ratings):\\n            self.food_to_cuis[food] = cuis\\n            self.food_to_latest_ratings[food] = rating\\n            heappush(self.cuis_to_score_heap[cuis], RatedFood(-rating, food))\\n        \\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_to_latest_ratings[food] = newRating\\n        cuis = self.food_to_cuis[food]\\n        heappush(self.cuis_to_score_heap[cuis], RatedFood(-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while True:\\n            ratedFood = heappop(self.cuis_to_score_heap[cuisine])\\n            if self.food_to_latest_ratings[ratedFood.food] == (-ratedFood.rating):\\n\\t\\t\\t\\n\\t\\t\\t\\t# because the food item is still valid, we put it back into the heap\\n                heappush(self.cuis_to_score_heap[cuisine], ratedFood)\\n\\t\\t\\t\\t\\n                return ratedFood.food\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324861,
                "title": "c-two-unordered-maps-are-all-you-need",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    unordered_map<string, map<int, set<string>>> cuisine2rateAndFood;\\n    unordered_map<string, pair<int, string>> food2cuisineAndRate;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; ++i) {\\n            cuisine2rateAndFood[cuisines[i]][ratings[i]].insert(foods[i]);\\n            food2cuisineAndRate[foods[i]] = make_pair(ratings[i], cuisines[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [prevRating, cuisine] = food2cuisineAndRate[food];\\n        cuisine2rateAndFood[cuisine][prevRating].erase(food);\\n        if (cuisine2rateAndFood[cuisine][prevRating].empty()) {\\n            cuisine2rateAndFood[cuisine].erase(prevRating);\\n        }\\n        cuisine2rateAndFood[cuisine][newRating].insert(food);\\n        \\n        food2cuisineAndRate[food].first = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto foodSet = cuisine2rateAndFood[cuisine].rbegin()->second;\\n        return *foodSet.begin();\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    unordered_map<string, map<int, set<string>>> cuisine2rateAndFood;\\n    unordered_map<string, pair<int, string>> food2cuisineAndRate;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; ++i) {\\n            cuisine2rateAndFood[cuisines[i]][ratings[i]].insert(foods[i]);\\n            food2cuisineAndRate[foods[i]] = make_pair(ratings[i], cuisines[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [prevRating, cuisine] = food2cuisineAndRate[food];\\n        cuisine2rateAndFood[cuisine][prevRating].erase(food);\\n        if (cuisine2rateAndFood[cuisine][prevRating].empty()) {\\n            cuisine2rateAndFood[cuisine].erase(prevRating);\\n        }\\n        cuisine2rateAndFood[cuisine][newRating].insert(food);\\n        \\n        food2cuisineAndRate[food].first = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto foodSet = cuisine2rateAndFood[cuisine].rbegin()->second;\\n        return *foodSet.begin();\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331910,
                "title": "c-map-simple-explanation",
                "content": "\\nWe need to store two things -> rating and cuisine for every food because they are the ones affecting the changes in answer\\nThen we need to change the ratings which is simple using map, last map of set is for getting the highest rated cuisine food in minimum time possible, if we store the ratings in positive values the highest rating will be at the end but the food for that rating in smallest lexicograpgical order will not necessarily be at the end for multiple highest rating, so we use the set property to store the ratings in negative values , eg: { -50, Cake }, {-50, Donut } ......this is how it will be stored for  rating 50 and food items cake and donut, so this way the lexicographically smallest food item will automatically come in the first position\\n\\n``````````````````\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,int>mp;\\n    unordered_map<string,string>mp2;\\n    unordered_map<string,set<pair<int,string>>>hrating;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            mp[foods[i]]=ratings[i];\\n            mp2[foods[i]]=cuisines[i];\\n            hrating[cuisines[i]].insert({-ratings[i],foods[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        string t=mp2[food];\\n        int tmp=mp[food];\\n        mp[food]=newRating;\\n        hrating[t].erase(hrating[t].find({-tmp,food}));\\n        hrating[t].insert({-newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        string res=\"\";\\n        auto anss=*(hrating[cuisine].begin());\\n        res=anss.second;\\n        return res;\\n    }\\n};\\n````````````````````````\\nPls UPVOTE if you understood\\n![image](https://assets.leetcode.com/users/images/71647b89-5e64-4694-b1d4-d096a65e9776_1659218495.424549.jpeg)",
                "solutionTags": [],
                "code": "``````\n``````\n``````\n``````\n``````\n``````\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 2325436,
                "title": "java-with-treeset",
                "content": "I used 3 Maps\\n1. Cuisine to food so we can get all food of that cuisine. I used a TreeSet to keep everything ordered. TreeSet is a binary search tree (Red Black Tree to be precise) so it\\'s balanced. \\n2. Food to Cuisine so we can know where to find the food TreeSet when updating the rating\\n3. Food to Rating (can be avoided if we created a custom class).\\n\\nLessons\\n1. TreeSet uses the comparator to see if your element exists in the TreeSet (might not be correct, that\\'s from personal experiments). Thus, remove the element, THEN update the rating, THEN insert again. Don\\'t do update, remove, insert. This way, TreeSet will contain duplicates.\\n2. Always use .equals() to compare Objects. That includes Integer. ```foodToRat.get(a)==(foodToRat.get(b))``` actually would break the code! HashMap.get() returns an Integer. \\n```\\nclass FoodRatings {\\n    HashMap<String, TreeSet<String>> cuiToFood = new HashMap();\\n    HashMap<String, Integer> foodToRat = new HashMap();\\n    HashMap<String, String> foodToCui = new HashMap();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.length; i++){\\n            TreeSet<String> foodOfThisCuisine = cuiToFood.getOrDefault(cuisines[i], new TreeSet<String> ((a,b)->\\n            foodToRat.get(a).equals(foodToRat.get(b)) ? a.compareTo(b) : foodToRat.get(b)-foodToRat.get(a)));\\n\\t\\t\\t\\n\\t\\t\\t// Both comparators are equal\\n\\t\\t\\t/* new Comparator<String>(){\\n                @Override\\n                public int compare(String a, String b){\\n                    int aRat = foodToRat.get(a);\\n                    int bRat = foodToRat.get(b);\\n                    \\n                    if(aRat != bRat) return bRat - aRat; // largest rating first\\n                    for(int i = 0; i < Math.min(a.length(), b.length()); i++){\\n                        if(a.charAt(i) != b.charAt(i)) return a.charAt(i) - b.charAt(i);\\n                    }\\n                    return a.length() - b.length();\\n                }\\n            })\\n\\t\\t\\t*/\\n            \\n            foodToRat.put(foods[i], ratings[i]);\\n            foodOfThisCuisine.add(foods[i]);\\n            foodToCui.put(foods[i], cuisines[i]);    \\n            \\n            cuiToFood.put(cuisines[i], foodOfThisCuisine);\\n        }\\n    }\\n    \\n    // CompareTo() is used to compare whether 2 strings are equal in hashSet! So remove, change value of key in HashMap, then insert again\\n    public void changeRating(String food, int newRating) {\\n        String cui = foodToCui.get(food);\\n        TreeSet<String> foodOfThisCui = cuiToFood.get(cui);\\n        foodOfThisCui.remove(food);\\n        foodToRat.put(food, newRating);\\n        \\n        foodOfThisCui.add(food);\\n        cuiToFood.put(cui, foodOfThisCui);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuiToFood.get(cuisine).first();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```foodToRat.get(a)==(foodToRat.get(b))```\n```\\nclass FoodRatings {\\n    HashMap<String, TreeSet<String>> cuiToFood = new HashMap();\\n    HashMap<String, Integer> foodToRat = new HashMap();\\n    HashMap<String, String> foodToCui = new HashMap();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.length; i++){\\n            TreeSet<String> foodOfThisCuisine = cuiToFood.getOrDefault(cuisines[i], new TreeSet<String> ((a,b)->\\n            foodToRat.get(a).equals(foodToRat.get(b)) ? a.compareTo(b) : foodToRat.get(b)-foodToRat.get(a)));\\n\\t\\t\\t\\n\\t\\t\\t// Both comparators are equal\\n\\t\\t\\t/* new Comparator<String>(){\\n                @Override\\n                public int compare(String a, String b){\\n                    int aRat = foodToRat.get(a);\\n                    int bRat = foodToRat.get(b);\\n                    \\n                    if(aRat != bRat) return bRat - aRat; // largest rating first\\n                    for(int i = 0; i < Math.min(a.length(), b.length()); i++){\\n                        if(a.charAt(i) != b.charAt(i)) return a.charAt(i) - b.charAt(i);\\n                    }\\n                    return a.length() - b.length();\\n                }\\n            })\\n\\t\\t\\t*/\\n            \\n            foodToRat.put(foods[i], ratings[i]);\\n            foodOfThisCuisine.add(foods[i]);\\n            foodToCui.put(foods[i], cuisines[i]);    \\n            \\n            cuiToFood.put(cuisines[i], foodOfThisCuisine);\\n        }\\n    }\\n    \\n    // CompareTo() is used to compare whether 2 strings are equal in hashSet! So remove, change value of key in HashMap, then insert again\\n    public void changeRating(String food, int newRating) {\\n        String cui = foodToCui.get(food);\\n        TreeSet<String> foodOfThisCui = cuiToFood.get(cui);\\n        foodOfThisCui.remove(food);\\n        foodToRat.put(food, newRating);\\n        \\n        foodOfThisCui.add(food);\\n        cuiToFood.put(cui, foodOfThisCui);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuiToFood.get(cuisine).first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324774,
                "title": "write-bug-free-code-to-get-ac-hints-to-write-clean-code",
                "content": "## Bellow points would cast time in contest but you can able to avoid wa submission and it\\'s best practice for interview purpose. \\nWell, for such question where design is more important than the logic, we have to write bug free code. Because once you get the error in code than it\\'s hard to debug while in the contest because of large number of code.\\n*  So hint to write clean solution :\\n\\t*  Always write a variable name which have clear explanation, will help to quick debug.\\n\\t*  Try to enacpsulat as much as possible in single entity, It will help to handle the data.\\n\\t*  Split the design in class/function and each function must have only one task to do, So this will help to give confidence that if this function is correct you don\\'t need to check again\\n\\t*  Always check **Null Pointer exception** and that\\'s the major problem when you tackel with language like java.\\n\\t*  For debug/print perpuse override toString function of your class, due to this you can simply put sout and see the data.\\n\\t*  Always write code in well farmated manner, leetcode doesn\\'t give feature to auto-formate, So make habit of it.\\n\\t*  Avoid redundant code, it\\'ll give your code in smaller line, so smaller code will take smaller time to debug and you skip the typing time cast.\\n\\n\\n```\\nclass Data {\\n    String food;\\n    String cuisine;\\n    int rating;\\n    public Data(String food, String cuisine, int rating) {\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public void set(String food, String cuisine, int rating) {\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public String toString() {\\n        return food+\" \"+\" \"+cuisine+\" \"+rating;\\n    }\\n}\\n\\nclass FoodRatings {\\n    Map<String, Data> nameToData;\\n    Map<String, TreeSet<Data>> csToData;\\n    \\n    private void add(String food, String cuisine, int rating) {\\n        String combine = rating+food;\\n        Data data = nameToData.getOrDefault(food, null);\\n        \\n        if(data!=null && csToData.containsKey(data.cuisine)) {\\n            TreeSet<Data> set = csToData.get(data.cuisine);\\n            if(set!=null) {\\n                set.remove(data);\\n                if(set.size()==0) {\\n                    csToData.remove(data.cuisine);\\n                }\\n            }\\n        }\\n        \\n        if(data == null) {\\n            data = new Data(food, cuisine, rating);\\n        }\\n        data.set(food, cuisine, rating);\\n        nameToData.put(food, data);\\n        if(!csToData.containsKey(cuisine)) {\\n            csToData.put(cuisine, new TreeSet<>((a,b)->{\\n                if(a.rating == b.rating) {\\n                    return -1*(a.food.compareTo(b.food));\\n                }\\n                return a.rating-b.rating;\\n            }));\\n        }\\n        csToData.get(cuisine).add(data);\\n    }\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        nameToData = new HashMap<>();\\n        csToData = new HashMap<>();\\n        for(int i=0;i<foods.length;i++) {\\n            add(foods[i], cuisines[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        add(food, nameToData.get(food).cuisine, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return csToData.get(cuisine).last().food;\\n    }\\n}\\n```\\n\\n**Please upvote if you find helpful**\\n*Happy coding*",
                "solutionTags": [],
                "code": "```\\nclass Data {\\n    String food;\\n    String cuisine;\\n    int rating;\\n    public Data(String food, String cuisine, int rating) {\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public void set(String food, String cuisine, int rating) {\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public String toString() {\\n        return food+\" \"+\" \"+cuisine+\" \"+rating;\\n    }\\n}\\n\\nclass FoodRatings {\\n    Map<String, Data> nameToData;\\n    Map<String, TreeSet<Data>> csToData;\\n    \\n    private void add(String food, String cuisine, int rating) {\\n        String combine = rating+food;\\n        Data data = nameToData.getOrDefault(food, null);\\n        \\n        if(data!=null && csToData.containsKey(data.cuisine)) {\\n            TreeSet<Data> set = csToData.get(data.cuisine);\\n            if(set!=null) {\\n                set.remove(data);\\n                if(set.size()==0) {\\n                    csToData.remove(data.cuisine);\\n                }\\n            }\\n        }\\n        \\n        if(data == null) {\\n            data = new Data(food, cuisine, rating);\\n        }\\n        data.set(food, cuisine, rating);\\n        nameToData.put(food, data);\\n        if(!csToData.containsKey(cuisine)) {\\n            csToData.put(cuisine, new TreeSet<>((a,b)->{\\n                if(a.rating == b.rating) {\\n                    return -1*(a.food.compareTo(b.food));\\n                }\\n                return a.rating-b.rating;\\n            }));\\n        }\\n        csToData.get(cuisine).add(data);\\n    }\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        nameToData = new HashMap<>();\\n        csToData = new HashMap<>();\\n        for(int i=0;i<foods.length;i++) {\\n            add(foods[i], cuisines[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        add(food, nameToData.get(food).cuisine, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return csToData.get(cuisine).last().food;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325027,
                "title": "c-three-maps-easy-solution-o-n-logn",
                "content": "Take 3 maps\\n(i) Cuisine - priority_queue(rating,food)\\n(ii) Food - cuisine\\n(iii) Rating - Food\\n\\nSort the priority queue in order of highest rating and lexographically order of foods. \\nWhen changing the rating just change the rating of the food in rating map. No need to delete in priority queue.\\nIn highest rated function just check if the top rating coming is equal to the food\\'s rating in ratings map, if yes simply return else pop.\\n\\n```\\nstruct comp{\\n    bool operator() (pair<int,string> &a,pair<int,string> &b){\\n        if(a.first==b.first) return a.second>b.second;\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    \\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,comp>> mp;\\n    unordered_map<string,string> chk;\\n    unordered_map<string,int> rt;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<foods.size();i++){\\n            mp[c[i]].push({r[i],foods[i]});\\n            chk[foods[i]]=c[i];\\n            rt[foods[i]]=r[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        rt[food]=newRating;\\n        mp[chk[food]].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        string x = mp[cuisine].top().second;\\n        int y = mp[cuisine].top().first;\\n        while(rt[x]!=y){\\n            mp[cuisine].pop();\\n            x = mp[cuisine].top().second;\\n            y = mp[cuisine].top().first;\\n        }\\n        return mp[cuisine].top().second;\\n    }\\n};\\n```\\n\\nHope you understand it, if any doubt just comment.\\nThank You",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct comp{\\n    bool operator() (pair<int,string> &a,pair<int,string> &b){\\n        if(a.first==b.first) return a.second>b.second;\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    \\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,comp>> mp;\\n    unordered_map<string,string> chk;\\n    unordered_map<string,int> rt;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<foods.size();i++){\\n            mp[c[i]].push({r[i],foods[i]});\\n            chk[foods[i]]=c[i];\\n            rt[foods[i]]=r[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        rt[food]=newRating;\\n        mp[chk[food]].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        string x = mp[cuisine].top().second;\\n        int y = mp[cuisine].top().first;\\n        while(rt[x]!=y){\\n            mp[cuisine].pop();\\n            x = mp[cuisine].top().second;\\n            y = mp[cuisine].top().first;\\n        }\\n        return mp[cuisine].top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324748,
                "title": "simple-efficient-code",
                "content": "```\\nclass FoodRatings {\\n    typedef long long ll;\\n    typedef pair<string, ll> pi;\\n    class cmp {\\n    public:\\n        bool operator()(const pi& a, const pi& b)const {\\n            return (a.second == b.second ? a.first < b.first : a.second > b.second);\\n        }\\n    };\\n    unordered_map<string, pi>foods;\\n    unordered_map<string, set<pi, cmp>>cus;\\n    ll n;\\npublic:\\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        n = f.size();\\n        for (ll i = 0;i < n;++i) {\\n            foods[f[i]] = pi(c[i], r[i]);\\n            cus[c[i]].insert(pi(f[i], r[i]));\\n        }\\n    }\\n\\n    void changeRating(string food, int newRat) {\\n        string c = foods[food].first;\\n        ll oldRat = foods[food].second;\\n        foods[food].second = newRat;\\n        cus[c].erase({ food, oldRat });\\n        cus[c].insert({ food, newRat });\\n    }\\n\\n    string highestRated(string c) {\\n        return cus[c].begin()->first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    typedef long long ll;\\n    typedef pair<string, ll> pi;\\n    class cmp {\\n    public:\\n        bool operator()(const pi& a, const pi& b)const {\\n            return (a.second == b.second ? a.first < b.first : a.second > b.second);\\n        }\\n    };\\n    unordered_map<string, pi>foods;\\n    unordered_map<string, set<pi, cmp>>cus;\\n    ll n;\\npublic:\\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        n = f.size();\\n        for (ll i = 0;i < n;++i) {\\n            foods[f[i]] = pi(c[i], r[i]);\\n            cus[c[i]].insert(pi(f[i], r[i]));\\n        }\\n    }\\n\\n    void changeRating(string food, int newRat) {\\n        string c = foods[food].first;\\n        ll oldRat = foods[food].second;\\n        foods[food].second = newRat;\\n        cus[c].erase({ food, oldRat });\\n        cus[c].insert({ food, newRat });\\n    }\\n\\n    string highestRated(string c) {\\n        return cus[c].begin()->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324652,
                "title": "python-with-sorted-set",
                "content": "API docs: https://grantjenks.com/docs/sortedcontainers/.\\n\\n```\\nfrom sortedcontainers import SortedSet\\n\\n        \\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisine: List[str], ratings: List[int]):\\n        self.cuisines = defaultdict(lambda: SortedSet(key=lambda x: (-x[0], x[1])))\\n        self.food_to_cuisine = dict()\\n        self.food_to_rating = dict()\\n        \\n        for index in range(len(foods)):\\n            _cuisine, food, rating = cu[index], foods[index], ratings[index]\\n            \\n            self.cuisines[_cuisine].add((rating, food))\\n            self.food_to_cuisine[food] = _cuisine\\n            self.food_to_rating[food] = rating\\n            \\n    def changeRating(self, food: str, new_rating: int) -> None:\\n        old_rating = self.food_to_rating[food]\\n        cuisine = self.food_to_cuisine[food]\\n        \\n        self.cuisines[cuisine].discard((old_rating, food))\\n        self.cuisines[cuisine].add((new_rating, food))\\n        self.food_to_rating[food] = new_rating\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        return self.cuisines[cuisine][0][1]\\n```\\n\\nNote that for an interview, the better idea is to maintain a Heap and delete invalid ratings lazily. Checkout the following implementation for more: https://leetcode.com/problems/design-a-food-rating-system/discuss/2324852/Python-or-Hashmamp-+-Heap-extravaganza.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\n\\n        \\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisine: List[str], ratings: List[int]):\\n        self.cuisines = defaultdict(lambda: SortedSet(key=lambda x: (-x[0], x[1])))\\n        self.food_to_cuisine = dict()\\n        self.food_to_rating = dict()\\n        \\n        for index in range(len(foods)):\\n            _cuisine, food, rating = cu[index], foods[index], ratings[index]\\n            \\n            self.cuisines[_cuisine].add((rating, food))\\n            self.food_to_cuisine[food] = _cuisine\\n            self.food_to_rating[food] = rating\\n            \\n    def changeRating(self, food: str, new_rating: int) -> None:\\n        old_rating = self.food_to_rating[food]\\n        cuisine = self.food_to_cuisine[food]\\n        \\n        self.cuisines[cuisine].discard((old_rating, food))\\n        self.cuisines[cuisine].add((new_rating, food))\\n        self.food_to_rating[food] = new_rating\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        return self.cuisines[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325314,
                "title": "java-treeset-easy-understanding",
                "content": "One can use TreeSet instead of PriorityQueue to boost 3x faster:\\n```\\nclass FoodRatings {\\n\\tMap<String, TreeSet> cuisineMap;\\n\\tMap<String, Food> foodMap;\\n\\tTreeSet foodSet;\\n\\n\\tpublic FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\t\\tfoodMap = new HashMap<>();\\n\\t\\tcuisineMap = new HashMap<>();\\n\\n\\t\\tfor (int i = 0; i < foods.length; ++i) {\\n\\t\\t\\tFood food = new Food(foods[i], cuisines[i], ratings[i]);\\n\\t\\t\\tfoodMap.put(food.name, food);\\n\\t\\t\\tif (!cuisineMap.containsKey(food.cuisine)) {\\n\\t\\t\\t\\tcuisineMap.put(food.cuisine, new TreeSet<>((a, b) -> a.rating == b.rating ?\\n\\t\\t\\t\\t\\t\\ta.name.compareTo(b.name) : b.rating - a.rating));\\n\\t\\t\\t}\\n\\t\\t\\tcuisineMap.get(food.cuisine).add(food);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void changeRating(String food, int newRating) {\\n\\t\\tFood f = foodMap.get(food);\\n\\t\\tfoodSet = cuisineMap.get(f.cuisine);\\n\\t\\tfoodSet.remove(f);\\n\\t\\tf.rating = newRating;\\n\\t\\tfoodSet.add(f);\\n\\t}\\n\\n\\tpublic String highestRated(String cuisine) {\\n\\t\\tfoodSet = cuisineMap.get(cuisine);\\n\\t\\treturn foodSet.first().name;\\n\\t}\\n}\\n\\nclass Food {\\n\\tString name;\\n\\tString cuisine;\\n\\tint rating;\\n\\n\\tFood(String name, String cuisine, int rating) {\\n\\t\\tthis.name = name;\\n\\t\\tthis.rating = rating;\\n\\t\\tthis.cuisine = cuisine;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n\\tMap<String, TreeSet> cuisineMap;\\n\\tMap<String, Food> foodMap;\\n\\tTreeSet foodSet;\\n\\n\\tpublic FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\t\\tfoodMap = new HashMap<>();\\n\\t\\tcuisineMap = new HashMap<>();\\n\\n\\t\\tfor (int i = 0; i < foods.length; ++i) {\\n\\t\\t\\tFood food = new Food(foods[i], cuisines[i], ratings[i]);\\n\\t\\t\\tfoodMap.put(food.name, food);\\n\\t\\t\\tif (!cuisineMap.containsKey(food.cuisine)) {\\n\\t\\t\\t\\tcuisineMap.put(food.cuisine, new TreeSet<>((a, b) -> a.rating == b.rating ?\\n\\t\\t\\t\\t\\t\\ta.name.compareTo(b.name) : b.rating - a.rating));\\n\\t\\t\\t}\\n\\t\\t\\tcuisineMap.get(food.cuisine).add(food);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void changeRating(String food, int newRating) {\\n\\t\\tFood f = foodMap.get(food);\\n\\t\\tfoodSet = cuisineMap.get(f.cuisine);\\n\\t\\tfoodSet.remove(f);\\n\\t\\tf.rating = newRating;\\n\\t\\tfoodSet.add(f);\\n\\t}\\n\\n\\tpublic String highestRated(String cuisine) {\\n\\t\\tfoodSet = cuisineMap.get(cuisine);\\n\\t\\treturn foodSet.first().name;\\n\\t}\\n}\\n\\nclass Food {\\n\\tString name;\\n\\tString cuisine;\\n\\tint rating;\\n\\n\\tFood(String name, String cuisine, int rating) {\\n\\t\\tthis.name = name;\\n\\t\\tthis.rating = rating;\\n\\t\\tthis.cuisine = cuisine;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325148,
                "title": "c-hashmap-commented-code",
                "content": "```\\nmap<string,int> rat; // this will pair food and ratings \\n    \\n    map<string,multiset<pair<int,string>>> bestRat; // this will keep country and pair which is ratings and food used multiset for finding best rating  of that specfic country\\n    map<string,string> foodCount;\\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& ratings) {\\n        for(int i=0;i<size(foods);i++)\\n        {\\n            rat[foods[i]]=ratings[i];\\n            // we are adding -ve rating bcz in multiset heighest rating is -ve than it is always first iterator\\n            bestRat[c[i]].insert({-ratings[i],foods[i]});\\n            foodCount[foods[i]]=c[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int curRat=rat[food]; \\n        // changed the current rating of food\\n        rat[food]=newRating;\\n        string country=foodCount[food]; // we have see the country which have that food\\n        // now we will find the pair of ratings and food and delete the previous and add the cur\\n       auto it= bestRat[country].find({-curRat,food});\\n        bestRat[country].erase(it);// erase that pair\\n        // now insert new pair\\n        bestRat[country].insert({-newRating,food});\\n        \\n        \\n    }\\n    \\n    string highestRated(string country) {\\n        // now best rating is in last in multiset\\n        return bestRat[country].begin()->second;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nmap<string,int> rat; // this will pair food and ratings \\n    \\n    map<string,multiset<pair<int,string>>> bestRat; // this will keep country and pair which is ratings and food used multiset for finding best rating  of that specfic country\\n    map<string,string> foodCount;\\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& ratings) {\\n        for(int i=0;i<size(foods);i++)\\n        {\\n            rat[foods[i]]=ratings[i];\\n            // we are adding -ve rating bcz in multiset heighest rating is -ve than it is always first iterator\\n            bestRat[c[i]].insert({-ratings[i],foods[i]});\\n            foodCount[foods[i]]=c[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int curRat=rat[food]; \\n        // changed the current rating of food\\n        rat[food]=newRating;\\n        string country=foodCount[food]; // we have see the country which have that food\\n        // now we will find the pair of ratings and food and delete the previous and add the cur\\n       auto it= bestRat[country].find({-curRat,food});\\n        bestRat[country].erase(it);// erase that pair\\n        // now insert new pair\\n        bestRat[country].insert({-newRating,food});\\n        \\n        \\n    }\\n    \\n    string highestRated(string country) {\\n        // now best rating is in last in multiset\\n        return bestRat[country].begin()->second;\\n        \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2324756,
                "title": "hashmap-treeset-and-a-comparator-set-o-log-n-get-o-1",
                "content": "The reason I chose **TreeSet** over **PriorityQueue** was :\\n\\nTreeSet **`remove(elem)`** : `O(log n)`\\nPriorityQueue **`remove(elem)`** : `O(n)`\\n\\nhttps://stackoverflow.com/questions/14379515/computational-complexity-of-treeset-methods-in-java\\nhttps://stackoverflow.com/questions/12719066/priority-queue-remove-complexity-time\\n\\n\\n```\\nclass FoodRatings {\\n    class Node{\\n        String food;\\n        String cuisine;\\n        int rating;\\n        \\n        Node(String food, int rating, String cuisine){\\n            this.food = food;\\n            this.rating = rating;\\n            this.cuisine = cuisine;\\n        }\\n    }\\n\\n    Map<String, TreeSet<Node>> map = new HashMap<>();\\n    Map<String, Node> nodes = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        Comparator<Node> comparator = (a,b) -> {\\n            return a.rating == b.rating ? a.food.compareTo(b.food) : b.rating - a.rating;\\n        };\\n        \\n        for(int i=0;i<foods.length;i++){\\n            String food = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            Node node = new Node(food, rating, cuisine);\\n            nodes.put(food, node);\\n                                                      \\n            map.computeIfAbsent(cuisine, a -> new TreeSet<Node>(comparator)).add(node);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Node node = nodes.get(food);\\n        TreeSet<Node> set = map.get(node.cuisine);\\n        set.remove(node);\\n        node.rating = newRating;\\n        set.add(node);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().food;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    class Node{\\n        String food;\\n        String cuisine;\\n        int rating;\\n        \\n        Node(String food, int rating, String cuisine){\\n            this.food = food;\\n            this.rating = rating;\\n            this.cuisine = cuisine;\\n        }\\n    }\\n\\n    Map<String, TreeSet<Node>> map = new HashMap<>();\\n    Map<String, Node> nodes = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        Comparator<Node> comparator = (a,b) -> {\\n            return a.rating == b.rating ? a.food.compareTo(b.food) : b.rating - a.rating;\\n        };\\n        \\n        for(int i=0;i<foods.length;i++){\\n            String food = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            Node node = new Node(food, rating, cuisine);\\n            nodes.put(food, node);\\n                                                      \\n            map.computeIfAbsent(cuisine, a -> new TreeSet<Node>(comparator)).add(node);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Node node = nodes.get(food);\\n        TreeSet<Node> set = map.get(node.cuisine);\\n        set.remove(node);\\n        node.rating = newRating;\\n        set.add(node);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().food;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324661,
                "title": "priority-queue-c",
                "content": "```\\nclass myComparator {\\n  public:\\n    bool operator() (pair<int,string> &p1, pair<int,string> &p2) {\\n      if(p1.first == p2.first) return p1.second > p2.second;\\n      \\n      return p1.first < p2.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,myComparator>\\n>mp;\\n    unordered_map<string,int>rate;\\n    unordered_map<string,string>cuis;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n        int n = foods.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            cuis[foods[i]] = cuisines[i];\\n            rate[foods[i]] = ratings[i];\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating)\\n    {\\n        rate[food] = newRating; \\n        string cuisine = cuis[food];\\n        mp[cuisine].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        while(1)\\n        {\\n            auto it = mp[cuisine].top();\\n            //cout<<it.second<<\" \"<<it.first<<\" \";\\n            if(rate[it.second] == it.first)return it.second;\\n            else mp[cuisine].pop();\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass myComparator {\\n  public:\\n    bool operator() (pair<int,string> &p1, pair<int,string> &p2) {\\n      if(p1.first == p2.first) return p1.second > p2.second;\\n      \\n      return p1.first < p2.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,myComparator>\\n>mp;\\n    unordered_map<string,int>rate;\\n    unordered_map<string,string>cuis;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n        int n = foods.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            cuis[foods[i]] = cuisines[i];\\n            rate[foods[i]] = ratings[i];\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating)\\n    {\\n        rate[food] = newRating; \\n        string cuisine = cuis[food];\\n        mp[cuisine].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        while(1)\\n        {\\n            auto it = mp[cuisine].top();\\n            //cout<<it.second<<\" \"<<it.first<<\" \";\\n            if(rate[it.second] == it.first)return it.second;\\n            else mp[cuisine].pop();\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2324656,
                "title": "c-3-map-and-set-fast-simple",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    struct SortByYX\\n    {\\n      bool operator ()(const pair<int, string>& l, const pair<int, string>& r) const\\n      {\\n        if(l.first != r.first){\\n            return l.first > r.first;\\n        }\\n        else return l.second < r.second;\\n      }\\n    };\\n    \\n    unordered_map<string, set<pair<int, string>, SortByYX>> cuisinToFood;\\n    unordered_map<string, int> rate;\\n    unordered_map<string, string> foodToCuisin;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for(int i=0; i<f.size(); i++){\\n            cuisinToFood[c[i]].insert({r[i], f[i]});\\n            foodToCuisin.insert({f[i], c[i]});\\n            rate.insert({f[i], r[i]});\\n        }\\n    }\\n    \\n    void changeRating(string f, int nr) {\\n        string c = foodToCuisin[f];\\n        int r = rate[f];\\n        rate[f] = nr;\\n        cuisinToFood[c].erase({r, f});\\n        cuisinToFood[c].insert({nr, f});\\n    }\\n    \\n    string highestRated(string c) {\\n        \\n        pair<int, string> p = *(cuisinToFood[c].begin());\\n        return p.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```",
                "solutionTags": [
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    struct SortByYX\\n    {\\n      bool operator ()(const pair<int, string>& l, const pair<int, string>& r) const\\n      {\\n        if(l.first != r.first){\\n            return l.first > r.first;\\n        }\\n        else return l.second < r.second;\\n      }\\n    };\\n    \\n    unordered_map<string, set<pair<int, string>, SortByYX>> cuisinToFood;\\n    unordered_map<string, int> rate;\\n    unordered_map<string, string> foodToCuisin;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for(int i=0; i<f.size(); i++){\\n            cuisinToFood[c[i]].insert({r[i], f[i]});\\n            foodToCuisin.insert({f[i], c[i]});\\n            rate.insert({f[i], r[i]});\\n        }\\n    }\\n    \\n    void changeRating(string f, int nr) {\\n        string c = foodToCuisin[f];\\n        int r = rate[f];\\n        rate[f] = nr;\\n        cuisinToFood[c].erase({r, f});\\n        cuisinToFood[c].insert({nr, f});\\n    }\\n    \\n    string highestRated(string c) {\\n        \\n        pair<int, string> p = *(cuisinToFood[c].begin());\\n        return p.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2327199,
                "title": "maps-custom-comperator",
                "content": "* **Custom Comperator** stores the value of Food according to descending order of rating and in lexicographically smaller food name.\\n*  **Food** Structure stores the value of Food,Rating and Cuisine Type.\\n* **Food_Info** stores Food Info Corresponding to Cuisine type in Set Data structure.\\n* **food_to_cuisine**  Maps food to Cuisine and Rating\\n\\nIn **changeRating** function, we find old rating and cuisine type(from **food_to_cuisine** Map) and Updates the Rating in **Food_Info**.\\n```\\nstruct Food{\\n  string Name;\\n  string Cuisine;\\n  int rating;\\n    \\n    Food(string name_,string cuis_,int rating_)\\n    {\\n        Name=name_;\\n        Cuisine=cuis_;\\n        rating=rating_;\\n    }\\n    //Custom Comperator(Sorts Acc. to Descending Value of Rating  and lexicographically smaller food name)\\n    friend bool operator<(const Food &x,const Food &y)\\n    {\\n        if(x.rating==y.rating)\\n        {\\n\\t\\t//If Foods have same rating, More Priority to lexicographically smaller food name\\n            return x.Name<y.Name;\\n        }\\n        return x.rating>y.rating;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    map<string,set<Food>>Food_Info;//Map Cuisine to Food\\n    map<string, pair<string, int>> food_to_cuisine;//maps food To Cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n       for(int i=0;i<foods.size();i++)\\n       {\\n           food_to_cuisine[foods[i]] = {cuisines[i], ratings[i]};\\n           Food_Info[cuisines[i]].insert(Food(foods[i],cuisines[i],ratings[i]));\\n       }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        int old_rating=food_to_cuisine[food].second;\\n        string cuisine_=food_to_cuisine[food].first;\\n\\t\\t\\n\\t\\t//Updating Ratings\\n        Food_Info[cuisine_].erase(Food(food,cuisine_,old_rating));\\n        Food_Info[cuisine_].insert(Food(food,cuisine_,newRating));\\n        \\n\\t\\tfood_to_cuisine[food]={cuisine_,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return Food_Info[cuisine].begin()->Name;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nstruct Food{\\n  string Name;\\n  string Cuisine;\\n  int rating;\\n    \\n    Food(string name_,string cuis_,int rating_)\\n    {\\n        Name=name_;\\n        Cuisine=cuis_;\\n        rating=rating_;\\n    }\\n    //Custom Comperator(Sorts Acc. to Descending Value of Rating  and lexicographically smaller food name)\\n    friend bool operator<(const Food &x,const Food &y)\\n    {\\n        if(x.rating==y.rating)\\n        {\\n\\t\\t//If Foods have same rating, More Priority to lexicographically smaller food name\\n            return x.Name<y.Name;\\n        }\\n        return x.rating>y.rating;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    map<string,set<Food>>Food_Info;//Map Cuisine to Food\\n    map<string, pair<string, int>> food_to_cuisine;//maps food To Cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n       for(int i=0;i<foods.size();i++)\\n       {\\n           food_to_cuisine[foods[i]] = {cuisines[i], ratings[i]};\\n           Food_Info[cuisines[i]].insert(Food(foods[i],cuisines[i],ratings[i]));\\n       }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        int old_rating=food_to_cuisine[food].second;\\n        string cuisine_=food_to_cuisine[food].first;\\n\\t\\t\\n\\t\\t//Updating Ratings\\n        Food_Info[cuisine_].erase(Food(food,cuisine_,old_rating));\\n        Food_Info[cuisine_].insert(Food(food,cuisine_,newRating));\\n        \\n\\t\\tfood_to_cuisine[food]={cuisine_,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return Food_Info[cuisine].begin()->Name;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325434,
                "title": "javascript-max-heap-pq-lazy-removal-645ms",
                "content": "```\\nfunction FoodRatings(foods, cuisines, ratings) {\\n    let n = foods.length, cm = new Map(), fm = new Map(); // cm: cuisine map {cuisine: pq}, fm: food map {food: [cuisine, rating]}\\n    for (let i = 0; i < n; i++) {\\n        fm.set(foods[i], [cuisines[i], ratings[i]]);\\n        if (!cm.has(cuisines[i])) {\\n            let pq = new MaxPriorityQueue({\\n                compare: (x, y) => {\\n                    if (x[0] != y[0]) return y[0] - x[0]; // first priority: high rate comes first\\n                    return x[1].localeCompare(y[1]); // second priority: lexical smaller comes first\\n                }\\n            });\\n            cm.set(cuisines[i], pq);\\n        }\\n        cm.get(cuisines[i]).enqueue([ratings[i], foods[i]])\\n    }\\n    return { changeRating, highestRated }\\n    function changeRating(food, newRating) {\\n        let cur = fm.get(food), cuisine = cur[0];\\n        cur[1] = newRating;\\n        fm.set(food, cur);\\n        cm.get(cuisine).enqueue([newRating, food]);\\n    }\\n    function highestRated(cuisine) {\\n        let pq = cm.get(cuisine);\\n        while (fm.get(pq.front()[1])[1] != pq.front()[0]) pq.dequeue(); // lazy remove\\n        return pq.front()[1];\\n    }\\n}\\n```\\nSolution 2: use Java TreeSet Comparator:\\nhttps://leetcode.com/problems/design-a-food-rating-system/discuss/2325289/java-3-maps-420ms",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunction FoodRatings(foods, cuisines, ratings) {\\n    let n = foods.length, cm = new Map(), fm = new Map(); // cm: cuisine map {cuisine: pq}, fm: food map {food: [cuisine, rating]}\\n    for (let i = 0; i < n; i++) {\\n        fm.set(foods[i], [cuisines[i], ratings[i]]);\\n        if (!cm.has(cuisines[i])) {\\n            let pq = new MaxPriorityQueue({\\n                compare: (x, y) => {\\n                    if (x[0] != y[0]) return y[0] - x[0]; // first priority: high rate comes first\\n                    return x[1].localeCompare(y[1]); // second priority: lexical smaller comes first\\n                }\\n            });\\n            cm.set(cuisines[i], pq);\\n        }\\n        cm.get(cuisines[i]).enqueue([ratings[i], foods[i]])\\n    }\\n    return { changeRating, highestRated }\\n    function changeRating(food, newRating) {\\n        let cur = fm.get(food), cuisine = cur[0];\\n        cur[1] = newRating;\\n        fm.set(food, cur);\\n        cm.get(cuisine).enqueue([newRating, food]);\\n    }\\n    function highestRated(cuisine) {\\n        let pq = cm.get(cuisine);\\n        while (fm.get(pq.front()[1])[1] != pq.front()[0]) pq.dequeue(); // lazy remove\\n        return pq.front()[1];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325254,
                "title": "simple-python-solution-heap-hashmap",
                "content": "This is a slight variation of https://leetcode.com/problems/design-a-number-container-system/\\n\\nUse 3 hashmaps:\\n- ```f2r``` - key is food, value is rating\\n- ```f2c``` - key is food, value is cuisine\\n- ```c2rf``` - key is cuisine, value is a heap of tuple (-rating, food) - we use negative rating to make this a max heap based on rating\\n\\nWhen finding the highestRated cuisine, we check ```c2rf``` to see if the ```(rating, food)``` combination is found in ```f2r```. If the ```(rating, food)``` combination is not found, the ```rating``` has already been invalidated (updated), so we ignore the value (by popping the heap).\\n\\nSpace Complexity: O(N)\\nTime Complexity:\\n===========\\n- changeRating - O(logN)\\n- highestRated:\\n  - Average case - O(logN)\\n  - Worst case - O(NlogN)\\n\\n```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.f2r = defaultdict(int)\\n        self.f2c = {}\\n        self.c2rf = defaultdict(list)\\n        for i in range(len(foods)):\\n            self.f2c[foods[i]] = cuisines[i]\\n            heappush(self.c2rf[cuisines[i]], (-ratings[i], foods[i]))\\n            self.f2r[foods[i]] = -ratings[i]\\n            \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.f2r[food] = -newRating\\n        heappush(self.c2rf[self.f2c[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.c2rf[cuisine] and self.f2r[self.c2rf[cuisine][0][1]] !=  self.c2rf[cuisine][0][0]:\\n            heappop(self.c2rf[cuisine])\\n        return self.c2rf[cuisine][0][1]\\n```",
                "solutionTags": [],
                "code": "```f2r```\n```f2c```\n```c2rf```\n```c2rf```\n```(rating, food)```\n```f2r```\n```(rating, food)```\n```rating```\n```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.f2r = defaultdict(int)\\n        self.f2c = {}\\n        self.c2rf = defaultdict(list)\\n        for i in range(len(foods)):\\n            self.f2c[foods[i]] = cuisines[i]\\n            heappush(self.c2rf[cuisines[i]], (-ratings[i], foods[i]))\\n            self.f2r[foods[i]] = -ratings[i]\\n            \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.f2r[food] = -newRating\\n        heappush(self.c2rf[self.f2c[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.c2rf[cuisine] and self.f2r[self.c2rf[cuisine][0][1]] !=  self.c2rf[cuisine][0][0]:\\n            heappop(self.c2rf[cuisine])\\n        return self.c2rf[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324844,
                "title": "help-why-is-this-giving-tle-in-java-using-three-hashmaps-with-priority-queue",
                "content": "Does anyone know why this solution is giving TLE and how I can modify this to be accepted?\\n\\n```java\\nclass FoodRatings {\\n    Map<String, Integer> foodToRatingMap = new HashMap<>();\\n    Map<String, String> foodToCuisineMap = new HashMap<>();\\n    Map<String, Queue<String>> cuisineToPQMap = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n = foods.length;\\n        for(int i = 0; i < n ; i++) {\\n            String food = foods[i], cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            foodToRatingMap.put(food, rating);\\n            foodToCuisineMap.put(food, cuisine);\\n            if(!cuisineToPQMap.containsKey(cuisine)) cuisineToPQMap.put(cuisine, new PriorityQueue<String>((a, b) -> {\\n                int r1 = foodToRatingMap.get(a);\\n                int r2 = foodToRatingMap.get(b);\\n                if(r1 != r2) return r2 - r1;\\n                return a.compareTo(b);\\n            }));\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            String food = foods[i], cuisine = cuisines[i];\\n            cuisineToPQMap.get(cuisine).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodToCuisineMap.get(food);\\n        Queue<String> q = cuisineToPQMap.get(cuisine);\\n        \\n        q.remove(food);\\n        foodToRatingMap.put(food, newRating);\\n        q.offer(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineToPQMap.get(cuisine).peek();\\n    }\\n}\\n```\\n\\n**Note:**\\nCheck this solution by another person: https://leetcode.com/problems/design-a-food-rating-system/discuss/2324848/JAVA-oror-MAP-oror-PRIORITY-QUEUE\\n\\nThey are also using a similar solution and even for them, changeRating involves two log(n) operations, but their solution works fine(without TLE).",
                "solutionTags": [],
                "code": "```java\\nclass FoodRatings {\\n    Map<String, Integer> foodToRatingMap = new HashMap<>();\\n    Map<String, String> foodToCuisineMap = new HashMap<>();\\n    Map<String, Queue<String>> cuisineToPQMap = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n = foods.length;\\n        for(int i = 0; i < n ; i++) {\\n            String food = foods[i], cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            foodToRatingMap.put(food, rating);\\n            foodToCuisineMap.put(food, cuisine);\\n            if(!cuisineToPQMap.containsKey(cuisine)) cuisineToPQMap.put(cuisine, new PriorityQueue<String>((a, b) -> {\\n                int r1 = foodToRatingMap.get(a);\\n                int r2 = foodToRatingMap.get(b);\\n                if(r1 != r2) return r2 - r1;\\n                return a.compareTo(b);\\n            }));\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            String food = foods[i], cuisine = cuisines[i];\\n            cuisineToPQMap.get(cuisine).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodToCuisineMap.get(food);\\n        Queue<String> q = cuisineToPQMap.get(cuisine);\\n        \\n        q.remove(food);\\n        foodToRatingMap.put(food, newRating);\\n        q.offer(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineToPQMap.get(cuisine).peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324811,
                "title": "why-priorityqueue-cannot-get-the-right-order",
                "content": "Was trying to use a pq to maintain the sequence - sort the food by the score first, if they are same, then try to sort by the string order aka lexco order, but keep got the wrong order, does anyone know why??? Thanks!:\\n\\ninput:\\n[\"FoodRatings\",\"changeRating\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\",\"highestRated\",\"highestRated\",\"changeRating\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\",\"highestRated\",\"highestRated\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\",\"highestRated\",\"changeRating\",\"changeRating\",\"changeRating\",\"changeRating\",\"highestRated\",\"highestRated\",\"changeRating\",\"changeRating\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\",\"changeRating\",\"changeRating\",\"highestRated\",\"highestRated\",\"highestRated\",\"highestRated\",\"changeRating\",\"highestRated\",\"highestRated\",\"highestRated\",\"highestRated\",\"changeRating\",\"changeRating\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\"]\\n[[[\"vhbibydfop\",\"ggtdlawxup\",\"lslcltacc\",\"bqgkfcy\",\"xxowyabq\",\"ezswv\",\"ewgvsuyvpo\",\"zgochpey\",\"epiaxxiv\",\"idpdiqlcp\",\"wqgrbvme\",\"wqxbxeovwe\",\"iduzk\",\"ahemklz\",\"ah\",\"rvuqnlydxu\",\"dldqmpheob\",\"lzeqwfb\",\"ykwjc\",\"dtrgnrcqr\",\"cwcgevzzz\",\"zejbynj\",\"ivhdsnjpho\",\"gsyewq\",\"ekqhtiijrj\",\"cthwbt\",\"gnbhjyhcil\",\"kkthw\",\"ktiqokzl\",\"zzroi\",\"cjwapjnzql\",\"hfum\",\"jrwby\",\"amhfyno\",\"bj\",\"fszije\",\"nbkpptir\",\"dgzmoxhhoe\",\"bnisfskgxi\",\"uepypxnsy\",\"afdz\",\"tdctkeg\",\"lfsohpzmk\",\"ewwqult\",\"iynyddno\",\"yyroyjzdg\",\"mcpea\",\"lzafjh\",\"jdvcxidtm\",\"qvkyqmupz\",\"kjop\",\"girgfkaib\",\"qecvnaxpsm\",\"itx\",\"xhjmq\",\"lwwbdxkz\",\"chthxuhex\",\"tghokrfica\",\"vrmjibxv\",\"oipnttbz\",\"yyfvlwvj\",\"erbtnw\",\"yezfiom\",\"ismarfqbuv\",\"vmfxlqbxwa\",\"pcwparohxf\",\"bpdrndbv\",\"owgjjitjfd\",\"fdwmxhli\",\"kffetdxvfx\",\"ruahmg\",\"aphbsbkimb\",\"nbkdfkgl\",\"rxehcqcrwu\",\"kxwlfxbe\",\"qukxd\",\"tewgnjuxnm\",\"jxfqwqe\",\"mdgwiok\",\"tbkmnx\",\"klzznopcn\",\"vjbcvddw\",\"yzhawtmpwp\",\"fhjichpi\",\"tapig\",\"glfbwolsoa\",\"xklqlzm\"],[\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\"],[146,562,428,619,731,483,598,619,950,446,630,556,894,911,537,359,863,995,417,702,689,667,502,691,896,582,111,319,182,953,131,372,563,963,300,42,829,187,676,509,259,688,897,614,392,170,392,1,134,79,995,371,886,430,72,830,871,758,247,333,128,987,659,933,640,198,638,585,825,904,729,214,974,935,581,985,85,987,51,174,301,635,148,492,200,275,101]],[\"nbkdfkgl\",908],[\"hfum\",256],[\"kggxajkarh\"],[\"dldqmpheob\",774],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"lfsohpzmk\",217],[\"yyfvlwvj\",372],[\"kggxajkarh\"],[\"owgjjitjfd\",652],[\"kggxajkarh\"],[\"uepypxnsy\",856],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"cwcgevzzz\",889],[\"kggxajkarh\"],[\"vrmjibxv\",228],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"tbkmnx\",963],[\"pcwparohxf\",710],[\"kjop\",89],[\"ah\",309],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"erbtnw\",501],[\"rxehcqcrwu\",306],[\"iynyddno\",260],[\"kggxajkarh\"],[\"jrwby\",205],[\"kggxajkarh\"],[\"wqgrbvme\",703],[\"qukxd\",234],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"jxfqwqe\",38],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"epiaxxiv\",434],[\"zgochpey\",315],[\"vhbibydfop\",915],[\"kggxajkarh\"],[\"tapig\",793],[\"kggxajkarh\"]]\\n\\nOutput:\\n[null,null,null,\"lzeqwfb\",null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,null,\"lzeqwfb\",null,\"lzeqwfb\",null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,\"lzeqwfb\",null,\"lzeqwfb\",\"lzeqwfb\",null,null,null,null,\"lzeqwfb\",\"lzeqwfb\",null,null,null,\"lzeqwfb\",null,\"lzeqwfb\",null,null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,null,null,\"lzeqwfb\",null,\"lzeqwfb\"]\\n\\nExpected:\\n[null,null,null,\"kjop\",null,\"kjop\",\"kjop\",\"kjop\",null,null,\"kjop\",null,\"kjop\",null,\"kjop\",\"kjop\",\"kjop\",null,\"kjop\",null,\"kjop\",\"kjop\",null,null,null,null,\"lzeqwfb\",\"lzeqwfb\",null,null,null,\"lzeqwfb\",null,\"lzeqwfb\",null,null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,null,null,\"lzeqwfb\",null,\"lzeqwfb\"]\\n\\n```\\nclass FoodRatings {\\n    Map<String, Integer> foodToR;\\n    Map<String, String> foodToC;\\n    Map<String, PriorityQueue<String>> cToF;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodToR = new HashMap<>();\\n        foodToC = new HashMap<>();\\n        cToF = new HashMap<>();\\n        \\n        int len = foods.length;\\n        for (int i = 0; i < len; i++) {\\n            foodToR.put(foods[i], ratings[i]);\\n            foodToC.put(foods[i], cuisines[i]);\\n        }\\n        for (int i = 0 ; i < len; i++) {\\n            if (!cToF.containsKey(cuisines[i])) {\\n                PriorityQueue<String> pq = new PriorityQueue<>((a, b) -> foodToR.get(a) == foodToR.get(b) ? a.compareTo(b) : foodToR.get(b) - foodToR.get(a));\\n                cToF.put(cuisines[i], pq);\\n            }\\n            cToF.get(cuisines[i]).add(foods[i]);\\n            // pq.add(foods[i]);\\n        }\\n        \\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodToR.put(food, newRating);\\n        String c = foodToC.get(food);\\n        cToF.get(c).remove(food);\\n        cToF.get(c).add(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cToF.get(cuisine).peek();\\n    }\\n}\\n```\\n\\n**What is wrong with the comparator here???**\\n```\\nPriorityQueue<String> pq = new PriorityQueue<>((a, b) -> foodToR.get(a) == foodToR.get(b) ? a.compareTo(b) : foodToR.get(b) - foodToR.get(a));\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\n    Map<String, Integer> foodToR;\\n    Map<String, String> foodToC;\\n    Map<String, PriorityQueue<String>> cToF;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodToR = new HashMap<>();\\n        foodToC = new HashMap<>();\\n        cToF = new HashMap<>();\\n        \\n        int len = foods.length;\\n        for (int i = 0; i < len; i++) {\\n            foodToR.put(foods[i], ratings[i]);\\n            foodToC.put(foods[i], cuisines[i]);\\n        }\\n        for (int i = 0 ; i < len; i++) {\\n            if (!cToF.containsKey(cuisines[i])) {\\n                PriorityQueue<String> pq = new PriorityQueue<>((a, b) -> foodToR.get(a) == foodToR.get(b) ? a.compareTo(b) : foodToR.get(b) - foodToR.get(a));\\n                cToF.put(cuisines[i], pq);\\n            }\\n            cToF.get(cuisines[i]).add(foods[i]);\\n            // pq.add(foods[i]);\\n        }\\n        \\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodToR.put(food, newRating);\\n        String c = foodToC.get(food);\\n        cToF.get(c).remove(food);\\n        cToF.get(c).add(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cToF.get(cuisine).peek();\\n    }\\n}\\n```\n```\\nPriorityQueue<String> pq = new PriorityQueue<>((a, b) -> foodToR.get(a) == foodToR.get(b) ? a.compareTo(b) : foodToR.get(b) - foodToR.get(a));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324804,
                "title": "c-dictionary-sortedset",
                "content": "```\\npublic class FoodRatings \\n{\\n    //Food -  (Rating - Cousine)\\n    Dictionary<string, (int, string)> foodRating;\\n    //Cousine - Sorted (rating, food)\\n    Dictionary<string, SortedSet<(int, string)>> cuisinesRatingFood;\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings)\\n    {\\n        foodRating = new Dictionary<string, (int, string)>();\\n        cuisinesRatingFood = new Dictionary<string, SortedSet<(int, string)>>();\\n\\n        for (int i = 0; i < foods.Length; i++)\\n        {\\n            foodRating.Add(foods[i], (ratings[i], cuisines[i]));\\n            cuisinesRatingFood.TryAdd(cuisines[i], new SortedSet<(int, string)>(Comparer<(int, string)>.Create((a, b) => a.Item1 != b.Item1 ? a.Item1.CompareTo(b.Item1) : b.Item2.CompareTo(a.Item2))));\\n            cuisinesRatingFood[cuisines[i]].Add((ratings[i], foods[i]));\\n        }\\n    }\\n\\n    public void ChangeRating(string food, int newRating)\\n    {\\n        string cuisine = foodRating[food].Item2;\\n        int oldRating = foodRating[food].Item1;\\n        foodRating[food] = (newRating, cuisine);\\n\\n        cuisinesRatingFood[cuisine].Remove((oldRating, food));\\n        cuisinesRatingFood[cuisine].Add((newRating, food));\\n    }\\n\\n    public string HighestRated(string cuisine)\\n    {\\n        return cuisinesRatingFood[cuisine].Max.Item2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class FoodRatings \\n{\\n    //Food -  (Rating - Cousine)\\n    Dictionary<string, (int, string)> foodRating;\\n    //Cousine - Sorted (rating, food)\\n    Dictionary<string, SortedSet<(int, string)>> cuisinesRatingFood;\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings)\\n    {\\n        foodRating = new Dictionary<string, (int, string)>();\\n        cuisinesRatingFood = new Dictionary<string, SortedSet<(int, string)>>();\\n\\n        for (int i = 0; i < foods.Length; i++)\\n        {\\n            foodRating.Add(foods[i], (ratings[i], cuisines[i]));\\n            cuisinesRatingFood.TryAdd(cuisines[i], new SortedSet<(int, string)>(Comparer<(int, string)>.Create((a, b) => a.Item1 != b.Item1 ? a.Item1.CompareTo(b.Item1) : b.Item2.CompareTo(a.Item2))));\\n            cuisinesRatingFood[cuisines[i]].Add((ratings[i], foods[i]));\\n        }\\n    }\\n\\n    public void ChangeRating(string food, int newRating)\\n    {\\n        string cuisine = foodRating[food].Item2;\\n        int oldRating = foodRating[food].Item1;\\n        foodRating[food] = (newRating, cuisine);\\n\\n        cuisinesRatingFood[cuisine].Remove((oldRating, food));\\n        cuisinesRatingFood[cuisine].Add((newRating, food));\\n    }\\n\\n    public string HighestRated(string cuisine)\\n    {\\n        return cuisinesRatingFood[cuisine].Max.Item2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491691,
                "title": "idea-explained-two-maps-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is to keep track of food and cuisine using food. This would help in updating ratings and get top rated food of particular.\\n\\n* To get highest rated food of given cuisine, we need a `cuisineMap` that would store `rating` and `food`. \\n\\t* **`{cuisine, set{rating, food}}`**\\n\\t* Each cuisine has a set that contains multiple foods and their ratings, sorted by ratings\\n\\t* This will be useful in getting top rated food.\\n* To update rating of given food, we need a `foodMap` that would store `rating` and `cuisine`. \\n\\t* **`{food, {rating, cuisine}}`**\\n\\t* We will use this cuisine value to update cuisine map as well with `newRating`\\n\\n*Note :* \\n* Store rating as `negative` value so we get highest rated food at the top of set in `cuisineMap`.\\n* SO in case of tie i.e same rating, we will get lexicographically smallest `food` string.\\n# Code :\\n\\n```\\nclass FoodRatings {\\n    unordered_map<string, set<pair<int, string>>> cuisineMap; // { cuisine, set{ rating, food } }\\n    unordered_map<string, pair<int, string>> foodMap; // { food, { rating, cuisine } }\\n    \\npublic:\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        \\n        // Create cuisines and foods mapping\\n        for(int i=0; i<n; i++) {\\n            cuisineMap[cuisines[i]].insert({-ratings[i], foods[i]}); // Cuisine -> {Rating, Food}\\n            foodMap[foods[i]] = {-ratings[i], cuisines[i]}; // Food -> {Rating, Food}\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [currentRating, cuisine] = foodMap[food]; // Get existing rating to find this food in cuisine\\n        \\n        foodMap[food] = {-newRating, cuisine}; // Update with new rating\\n            \\n        // Now update rating and food for particular cuisine\\n        cuisineMap[cuisine].erase({currentRating, food}); // Remove old value\\n        cuisineMap[cuisine].insert({-newRating, food}); // Insert new value\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        // First element in set of cuisine will be highest rated (-ve of rating is lowest)\\n        return cuisineMap[cuisine].begin()->second;\\n    }\\n};\\n```\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    unordered_map<string, set<pair<int, string>>> cuisineMap; // { cuisine, set{ rating, food } }\\n    unordered_map<string, pair<int, string>> foodMap; // { food, { rating, cuisine } }\\n    \\npublic:\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        \\n        // Create cuisines and foods mapping\\n        for(int i=0; i<n; i++) {\\n            cuisineMap[cuisines[i]].insert({-ratings[i], foods[i]}); // Cuisine -> {Rating, Food}\\n            foodMap[foods[i]] = {-ratings[i], cuisines[i]}; // Food -> {Rating, Food}\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [currentRating, cuisine] = foodMap[food]; // Get existing rating to find this food in cuisine\\n        \\n        foodMap[food] = {-newRating, cuisine}; // Update with new rating\\n            \\n        // Now update rating and food for particular cuisine\\n        cuisineMap[cuisine].erase({currentRating, food}); // Remove old value\\n        cuisineMap[cuisine].insert({-newRating, food}); // Insert new value\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        // First element in set of cuisine will be highest rated (-ve of rating is lowest)\\n        return cuisineMap[cuisine].begin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332660,
                "title": "priority-queue-c",
                "content": "First time i spent 2+ hours for single question lol.......\\n\\n```\\nclass FoodRatings {\\npublic:\\n   class compare{\\n       public:\\n    bool operator() (pair<int,string>const&a,pair<int,string>const&b) {\\n        \\n        if(a.first==b.first){\\n            return a.second>=b.second;\\n        }\\n        return a.first<b.first;\\n    }\\n       \\n   };        \\n   map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,compare>>m; \\n   map<string,int>mp;\\n   map<string,string>v;\\n    \\nFoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n       for(int i=0;i<foods.size();i++){\\n           mp[foods[i]]=ratings[i];\\n            v[foods[i]]=cuisines[i];\\n       }\\n       for(int i=0;i<foods.size();i++){\\n           m[cuisines[i]].push({ratings[i],foods[i]});\\n       }\\n    }\\n    \\n    \\n    void changeRating(string food, int newRating) {\\n        mp[food]=newRating;\\n        m[v[food]].push({newRating,food});\\n        \\n    }\\n    \\n    string highestRated(string cuisine) {\\n\\n        while(true){\\n            int rating=m[cuisine].top().first;\\n            string food=m[cuisine].top().second;\\n            cout<<rating<<\" \"<<food<<endl;\\n            if(mp[food]==rating){\\n                return food;\\n            }\\n            m[cuisine].pop();\\n            if(m[cuisine].empty())\\n                break;\\n        }\\n        return \"\";\\n     \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n   class compare{\\n       public:\\n    bool operator() (pair<int,string>const&a,pair<int,string>const&b) {\\n        \\n        if(a.first==b.first){\\n            return a.second>=b.second;\\n        }\\n        return a.first<b.first;\\n    }\\n       \\n   };        \\n   map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,compare>>m; \\n   map<string,int>mp;\\n   map<string,string>v;\\n    \\nFoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n       for(int i=0;i<foods.size();i++){\\n           mp[foods[i]]=ratings[i];\\n            v[foods[i]]=cuisines[i];\\n       }\\n       for(int i=0;i<foods.size();i++){\\n           m[cuisines[i]].push({ratings[i],foods[i]});\\n       }\\n    }\\n    \\n    \\n    void changeRating(string food, int newRating) {\\n        mp[food]=newRating;\\n        m[v[food]].push({newRating,food});\\n        \\n    }\\n    \\n    string highestRated(string cuisine) {\\n\\n        while(true){\\n            int rating=m[cuisine].top().first;\\n            string food=m[cuisine].top().second;\\n            cout<<rating<<\" \"<<food<<endl;\\n            if(mp[food]==rating){\\n                return food;\\n            }\\n            m[cuisine].pop();\\n            if(m[cuisine].empty())\\n                break;\\n        }\\n        return \"\";\\n     \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2324989,
                "title": "python-using-sortedlist",
                "content": "Used `SortedList` for this problem. Any alternate approach without using built-in data structures is appreciated.\\n\\n**Code**\\n\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.hmap_food = {}\\n        self.hmap_cuisine = collections.defaultdict(SortedList)\\n        \\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.hmap_food[f] = (c, r)\\n            self.hmap_cuisine[c].add((-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        o_c, o_r = self.hmap_food[food]\\n        self.hmap_cuisine[o_c].discard((-o_r, food))\\n        self.hmap_cuisine[o_c].add((-newRating, food))\\n        self.hmap_food[food] = (o_c, newRating)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        return self.hmap_cuisine[cuisine][0][1]\\n        \\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.hmap_food = {}\\n        self.hmap_cuisine = collections.defaultdict(SortedList)\\n        \\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.hmap_food[f] = (c, r)\\n            self.hmap_cuisine[c].add((-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        o_c, o_r = self.hmap_food[food]\\n        self.hmap_cuisine[o_c].discard((-o_r, food))\\n        self.hmap_cuisine[o_c].add((-newRating, food))\\n        self.hmap_food[food] = (o_c, newRating)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        return self.hmap_cuisine[cuisine][0][1]\\n        \\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324936,
                "title": "simple-map-solution-with-explanation",
                "content": "Why **-ratings[i] , as pushing negative value in set results in greater element at the beginning**\\nand **when ratings clash , set automatically sort on basis of second value**\\nand we needed to return which **food string is lexographically small**\\n\\n```\\n    unordered_map<string,string>cu; //food cusine\\n    unordered_map<string,set<pair<int,string>>>mp; // cusine , rating\\n    unordered_map<string,int>rat; // food rating\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            cu[foods[i]]=cuisines[i];\\n            mp[cuisines[i]].insert({-ratings[i],foods[i]});\\n            rat[foods[i]]=ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto cusine=cu[food];\\n        auto rating=rat[food];\\n        mp[cusine].erase({-rating,food});\\n        mp[cusine].insert({-newRating,food});\\n        rat[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].begin()->second;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    unordered_map<string,string>cu; //food cusine\\n    unordered_map<string,set<pair<int,string>>>mp; // cusine , rating\\n    unordered_map<string,int>rat; // food rating\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            cu[foods[i]]=cuisines[i];\\n            mp[cuisines[i]].insert({-ratings[i],foods[i]});\\n            rat[foods[i]]=ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto cusine=cu[food];\\n        auto rating=rat[food];\\n        mp[cusine].erase({-rating,food});\\n        mp[cusine].insert({-newRating,food});\\n        rat[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].begin()->second;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324742,
                "title": "python-sortedlist-three-maps",
                "content": "\\tfrom sortedcontainers import SortedList\\n\\tclass FoodRatings:\\n\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.a = defaultdict(SortedList)\\n\\t\\t\\tself.country = defaultdict(str)\\n\\t\\t\\tself.prevRating = defaultdict(int)\\n\\n\\t\\t\\tfor food,cuisine,rating in zip(foods,cuisines,ratings): \\n\\t\\t\\t\\tself.a[cuisine].add((-rating,food)) \\n\\t\\t\\t\\tself.country[food] = cuisine\\n\\t\\t\\t\\tself.prevRating[food] = rating\\n\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:  \\n\\t\\t\\tself.a[self.country[food]].remove((-self.prevRating[food],food)) \\n\\t\\t\\tself.prevRating[food] = newRating\\n\\t\\t\\tself.a[self.country[food]].add((-newRating,food))\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\treturn self.a[cuisine][0][1]\\n\\n\\n\\t# Your FoodRatings object will be instantiated and called as such:\\n\\t# obj = FoodRatings(foods, cuisines, ratings)\\n\\t# obj.changeRating(food,newRating)\\n\\t# param_2 = obj.highestRated(cuisine)",
                "solutionTags": [],
                "code": "\\tfrom sortedcontainers import SortedList\\n\\tclass FoodRatings:\\n\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.a = defaultdict(SortedList)\\n\\t\\t\\tself.country = defaultdict(str)\\n\\t\\t\\tself.prevRating = defaultdict(int)\\n\\n\\t\\t\\tfor food,cuisine,rating in zip(foods,cuisines,ratings): \\n\\t\\t\\t\\tself.a[cuisine].add((-rating,food)) \\n\\t\\t\\t\\tself.country[food] = cuisine\\n\\t\\t\\t\\tself.prevRating[food] = rating\\n\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:  \\n\\t\\t\\tself.a[self.country[food]].remove((-self.prevRating[food],food)) \\n\\t\\t\\tself.prevRating[food] = newRating\\n\\t\\t\\tself.a[self.country[food]].add((-newRating,food))\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\treturn self.a[cuisine][0][1]\\n\\n\\n\\t# Your FoodRatings object will be instantiated and called as such:\\n\\t# obj = FoodRatings(foods, cuisines, ratings)\\n\\t# obj.changeRating(food,newRating)\\n\\t# param_2 = obj.highestRated(cuisine)",
                "codeTag": "Java"
            },
            {
                "id": 3560243,
                "title": "java-simple-treeset-solution-100",
                "content": "```java\\nclass FoodRatings {\\n    private final Map<String, TreeSet<Food>> categories;\\n    private final Map<String, Food> meals;\\n\\n    public FoodRatings(final String[] foods, final String[] cuisines, final int[] ratings) {\\n        this.categories = new HashMap<>();\\n        this.meals = new HashMap<>();\\n\\n        for(int i = 0; i < cuisines.length; ++i) {\\n            final Food food = new Food(cuisines[i], foods[i], ratings[i]);\\n\\n            this.categories.putIfAbsent(cuisines[i], new TreeSet<>((a, b) -> a.rating() == b.rating() ? b.name().compareTo(a.name()) : a.rating() - b.rating()));\\n            this.categories.get(cuisines[i]).add(food);\\n            this.meals.put(foods[i], food);\\n        }\\n    }\\n    \\n    public void changeRating(final String food, final int newRating) {\\n        final Food meal = this.meals.get(food);\\n        final TreeSet<Food> category = categories.get(meal.category());\\n\\n        category.remove(meal);\\n\\n        meal.rating(newRating);\\n\\n        category.add(meal);\\n    }\\n    \\n    public String highestRated(final String cuisine) {\\n        return this.categories.get(cuisine).last().name();\\n    }\\n\\n    private final class Food {\\n        private final String category;\\n        private final String name;\\n        private int rating;\\n\\n        public Food(final String category, final String name, final int rating) {\\n            this.category = category;\\n            this.name = name;\\n            this.rating = rating;\\n        }\\n\\n        public void rating(final int rating) {\\n            this.rating = rating;\\n        }\\n\\n        public int rating() {\\n            return this.rating;\\n        }\\n\\n        public String category() {\\n            return this.category;\\n        }\\n\\n        public String name() {\\n            return this.name;\\n        }\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass FoodRatings {\\n    private final Map<String, TreeSet<Food>> categories;\\n    private final Map<String, Food> meals;\\n\\n    public FoodRatings(final String[] foods, final String[] cuisines, final int[] ratings) {\\n        this.categories = new HashMap<>();\\n        this.meals = new HashMap<>();\\n\\n        for(int i = 0; i < cuisines.length; ++i) {\\n            final Food food = new Food(cuisines[i], foods[i], ratings[i]);\\n\\n            this.categories.putIfAbsent(cuisines[i], new TreeSet<>((a, b) -> a.rating() == b.rating() ? b.name().compareTo(a.name()) : a.rating() - b.rating()));\\n            this.categories.get(cuisines[i]).add(food);\\n            this.meals.put(foods[i], food);\\n        }\\n    }\\n    \\n    public void changeRating(final String food, final int newRating) {\\n        final Food meal = this.meals.get(food);\\n        final TreeSet<Food> category = categories.get(meal.category());\\n\\n        category.remove(meal);\\n\\n        meal.rating(newRating);\\n\\n        category.add(meal);\\n    }\\n    \\n    public String highestRated(final String cuisine) {\\n        return this.categories.get(cuisine).last().name();\\n    }\\n\\n    private final class Food {\\n        private final String category;\\n        private final String name;\\n        private int rating;\\n\\n        public Food(final String category, final String name, final int rating) {\\n            this.category = category;\\n            this.name = name;\\n            this.rating = rating;\\n        }\\n\\n        public void rating(final int rating) {\\n            this.rating = rating;\\n        }\\n\\n        public int rating() {\\n            return this.rating;\\n        }\\n\\n        public String category() {\\n            return this.category;\\n        }\\n\\n        public String name() {\\n            return this.name;\\n        }\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419402,
                "title": "c-simple-map-solution-with-explanation",
                "content": "Approach:\\nThere are cuisines. Each cuisine has several foods. And each food has a rating (which can be updated).\\nWe are asked to create 2 functions - Change Rating of a food and Return Highest rated food of a given cuisine.\\nThis gives us the intuition to create a map that maps the cuisine to a priority queue(max heap) which will contain all the foods of that cuisine along with its rating.\\nFor changing the rating of a food, we keep another map, which maps the food item to it\\'s cuisine and it\\'s current rating. \\nSo, when we call highest rated food function, and use the top element of the priority queue, we match the rating of that item with it\\'s current rating. If it doesn\\'t match, keep popping untill you find one that matches.\\n\\n```\\n#define p pair<int,string> \\nstruct Comp{\\n    bool operator()(p a,p b){\\n        return a.first==b.first? a.second>b.second:a.first<b.first;\\n    }  \\n};\\nclass FoodRatings {\\npublic:\\n    map<string,priority_queue<p,vector<p>,Comp>>mp; //maps cuisine to priority queue of pairs of rating and food item name\\n    unordered_map<string,pair<int,string>>curr; //maps food item name to it\\'s current rating and cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            curr[foods[i]]={ratings[i],cuisines[i]};\\n        }\\n    }\\n    void changeRating(string food, int r) {\\n        string c=curr[food].second;\\n        curr[food]={r,c};\\n        mp[c].push({r,food});\\n    }\\n    string highestRated(string cuisine) {\\n        while(true){\\n            string food=mp[cuisine].top().second;\\n            int r=mp[cuisine].top().first;\\n            if(curr[food].first==r){\\n                break;\\n            }\\n            mp[cuisine].pop();\\n        }\\n        return mp[cuisine].top().second;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define p pair<int,string> \\nstruct Comp{\\n    bool operator()(p a,p b){\\n        return a.first==b.first? a.second>b.second:a.first<b.first;\\n    }  \\n};\\nclass FoodRatings {\\npublic:\\n    map<string,priority_queue<p,vector<p>,Comp>>mp; //maps cuisine to priority queue of pairs of rating and food item name\\n    unordered_map<string,pair<int,string>>curr; //maps food item name to it\\'s current rating and cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            curr[foods[i]]={ratings[i],cuisines[i]};\\n        }\\n    }\\n    void changeRating(string food, int r) {\\n        string c=curr[food].second;\\n        curr[food]={r,c};\\n        mp[c].push({r,food});\\n    }\\n    string highestRated(string cuisine) {\\n        while(true){\\n            string food=mp[cuisine].top().second;\\n            int r=mp[cuisine].top().first;\\n            if(curr[food].first==r){\\n                break;\\n            }\\n            mp[cuisine].pop();\\n        }\\n        return mp[cuisine].top().second;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382537,
                "title": "go-two-maps-and-a-heap-discussion",
                "content": "For these types of problems, consider:\\n\\n* How many elements are there?\\n* What are the access patterns?\\n* What is the worst-case scenario?\\n\\nIn a real-world scenario, the access patterns are more well-known.\\nFor example, ChangeRating may be called 100 times as often as HighestRated.\\n\\nSadly, on Leetcode, they rarely give this info, and test cases usually try all extremes,\\nso you are forced to find a generic solution to cater for all cases.\\n\\n`ChangeRating` is easy to solve - simply store all food items in a map.\\n\\n`HighestRated` needs to efficiently find the highest value, and so a heap is a good approach.\\n\\nWhen a food item changes, the rating will also affect the heap.\\nTo solve this, we may share the same food item between the map and the heap,\\nand use `heap.Fix(&h, idx)` to \"fix\" the heap after an item\\'s rating has changed.\\n\\nTo \"fix\" the heap, you must keep track of where the food item is in the heap.\\nFor this, the food item is given an auxiliary `heapIdx` field.\\n\\n**What if each cuisine only had one food item?**\\n\\nConsider the extreme case of having one food item per cuisine. \\nThen there is a lot of overhead in having one heap per item, right?\\n\\nActually, no. The heap is a pointer to a slice, which is a SliceHeader + uintptr.\\nIn total that is 256 bits of data, as opposed to 64 bits. Trading 192 bits for a heap is very cheap.\\n\\nThe real discussion is not in terms of performance but rather about complexity.\\nA heap is arguably more complex than a simple slice.\\nSo if it was known that it is exceedingly rare for a cuisine to have more than, say, 5 items each.\\nThen I\\'d go with a slice instead. Not because it\\'s faster, but because it\\'s simpler.\\n\\n```go\\ntype food struct {\\n\\tname    string\\n\\tcuisine string\\n\\trating  int\\n\\n\\theapIdx int // keep track of food item\\'s position in the heap\\n}\\n\\ntype FoodRatings struct {\\n\\tfoods    map[string]*food\\n\\tcuisines map[string]*foodHeap\\n}\\n\\nfunc Constructor(foods []string, cuisines []string, ratings []int) FoodRatings {\\n\\t// The idea is to use pointers and heap.Fix to manage updates to the\\n\\t// heap and ratings of a given food.\\n\\tvar r FoodRatings\\n\\tr.cuisines = make(map[string]*foodHeap)\\n\\tr.foods = make(map[string]*food)\\n\\tfor i := range foods {\\n\\t\\tif _, exists := r.cuisines[cuisines[i]]; !exists {\\n\\t\\t\\tr.cuisines[cuisines[i]] = &foodHeap{}\\n\\t\\t}\\n\\t\\tf := &food{\\n\\t\\t\\tname:    foods[i],\\n\\t\\t\\tcuisine: cuisines[i],\\n\\t\\t\\trating:  ratings[i],\\n\\t\\t}\\n\\t\\theap.Push(r.cuisines[cuisines[i]], f)\\n\\t\\tr.foods[foods[i]] = f\\n\\t}\\n\\treturn r\\n}\\n\\nfunc (this *FoodRatings) ChangeRating(food string, newRating int) {\\n\\tf := this.foods[food]\\n\\tf.rating = newRating\\n\\theap.Fix(this.cuisines[f.cuisine], f.heapIdx)\\n}\\n\\nfunc (this *FoodRatings) HighestRated(cuisine string) string {\\n\\treturn (*this.cuisines[cuisine])[0].name\\n}\\n\\ntype foodHeap []*food\\n\\nfunc (h foodHeap) Len() int { return len(h) }\\nfunc (h foodHeap) Swap(i, j int) {\\n\\th[i], h[j] = h[j], h[i]\\n\\th[i].heapIdx = i\\n\\th[j].heapIdx = j\\n}\\nfunc (h foodHeap) Less(i, j int) bool {\\n\\tif h[i].rating == h[j].rating {\\n\\t\\treturn h[i].name < h[j].name\\n\\t}\\n\\treturn h[i].rating > h[j].rating\\n}\\nfunc (h *foodHeap) Push(x interface{}) {\\n\\ta := x.(*food)\\n\\ta.heapIdx = len(*h)\\n\\t*h = append(*h, a)\\n}\\nfunc (h *foodHeap) Pop() interface{} {\\n\\tn := len(*h)\\n\\tit := (*h)[n-1]\\n\\t*h = (*h)[:n-1]\\n\\treturn it\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype food struct {\\n\\tname    string\\n\\tcuisine string\\n\\trating  int\\n\\n\\theapIdx int // keep track of food item\\'s position in the heap\\n}\\n\\ntype FoodRatings struct {\\n\\tfoods    map[string]*food\\n\\tcuisines map[string]*foodHeap\\n}\\n\\nfunc Constructor(foods []string, cuisines []string, ratings []int) FoodRatings {\\n\\t// The idea is to use pointers and heap.Fix to manage updates to the\\n\\t// heap and ratings of a given food.\\n\\tvar r FoodRatings\\n\\tr.cuisines = make(map[string]*foodHeap)\\n\\tr.foods = make(map[string]*food)\\n\\tfor i := range foods {\\n\\t\\tif _, exists := r.cuisines[cuisines[i]]; !exists {\\n\\t\\t\\tr.cuisines[cuisines[i]] = &foodHeap{}\\n\\t\\t}\\n\\t\\tf := &food{\\n\\t\\t\\tname:    foods[i],\\n\\t\\t\\tcuisine: cuisines[i],\\n\\t\\t\\trating:  ratings[i],\\n\\t\\t}\\n\\t\\theap.Push(r.cuisines[cuisines[i]], f)\\n\\t\\tr.foods[foods[i]] = f\\n\\t}\\n\\treturn r\\n}\\n\\nfunc (this *FoodRatings) ChangeRating(food string, newRating int) {\\n\\tf := this.foods[food]\\n\\tf.rating = newRating\\n\\theap.Fix(this.cuisines[f.cuisine], f.heapIdx)\\n}\\n\\nfunc (this *FoodRatings) HighestRated(cuisine string) string {\\n\\treturn (*this.cuisines[cuisine])[0].name\\n}\\n\\ntype foodHeap []*food\\n\\nfunc (h foodHeap) Len() int { return len(h) }\\nfunc (h foodHeap) Swap(i, j int) {\\n\\th[i], h[j] = h[j], h[i]\\n\\th[i].heapIdx = i\\n\\th[j].heapIdx = j\\n}\\nfunc (h foodHeap) Less(i, j int) bool {\\n\\tif h[i].rating == h[j].rating {\\n\\t\\treturn h[i].name < h[j].name\\n\\t}\\n\\treturn h[i].rating > h[j].rating\\n}\\nfunc (h *foodHeap) Push(x interface{}) {\\n\\ta := x.(*food)\\n\\ta.heapIdx = len(*h)\\n\\t*h = append(*h, a)\\n}\\nfunc (h *foodHeap) Pop() interface{} {\\n\\tn := len(*h)\\n\\tit := (*h)[n-1]\\n\\t*h = (*h)[:n-1]\\n\\treturn it\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2342927,
                "title": "rust-hashmap-and-btreeset",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/ood/lvl3/lc2353)\\n\\n<b>Problem List</b>\\n#HashMap - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/map/hashmap)\\n#TreeSet - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/set/treeset.txt)\\n\\n```\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::{BTreeSet, HashMap};\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexities:\\n///     `new()`:            O(`len_fs`)\\n///     `change_rating`:    O(lg(`len_fs`))\\n///     `highest_rated`:    O(1)\\n/// Space Complexity:       O(`len_fs`)\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, BTreeSet<Food>>,\\n    name_to_food: HashMap<String, Food>,\\n    name_to_cuisine: HashMap<String, String>,\\n}\\n\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, BTreeSet<Food>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Food> = HashMap::new();\\n        let mut name_to_cuisine: HashMap<String, String> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: &String = &foods[idx];\\n            let cuisine: &String = &cuisines[idx];\\n            let rating: i32 = ratings[idx];\\n            let food: Food = Food {\\n                name: name.to_owned(),\\n                rating,\\n            };\\n            cuisine_to_foods\\n                .entry(cuisine.to_owned())\\n                .or_default()\\n                .insert(food.clone());\\n            name_to_cuisine.insert(name.to_owned(), cuisine.to_owned());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n            name_to_cuisine,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get_mut(&name) {\\n            if let Some(cuisine) = self.name_to_cuisine.get(&name) {\\n                if let Some(foods) = self.cuisine_to_foods.get_mut(cuisine) {\\n                    foods.remove(food);\\n                    food.rating = new_rating;\\n                    foods.insert(food.clone());\\n                }\\n            }\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(foods) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(last) = foods.iter().last() {\\n                return last.name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\n#[derive(Clone)]\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &other.name).cmp(&(other.rating, &self.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(other.name.cmp(&self.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```\\n\\nTo reply on vectors, with sorting them everytime one changing ratings, leads to TLE.\\n\\n```\\nuse std::cell::RefCell;\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::HashMap;\\nuse std::rc::Rc;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexities:\\n///     `new()`:            O(`len_fs`)\\n///     `change_rating`:    O(lg(`len_fs`))\\n///     `highest_rated`:    O(1)\\n/// Space Complexity:       O(`len_fs`)\\n#[allow(dead_code)]\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, Vec<Rc<RefCell<Food>>>>,\\n    name_to_food: HashMap<String, Rc<RefCell<Food>>>,\\n    name_to_cuisine: HashMap<String, String>,\\n}\\n\\n#[allow(dead_code)]\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, Vec<Rc<RefCell<Food>>>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Rc<RefCell<Food>>> = HashMap::new();\\n        let mut name_to_cuisine: HashMap<String, String> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: &String = &foods[idx];\\n            let cuisine: &String = &cuisines[idx];\\n            let rating: i32 = ratings[idx];\\n            let food: Rc<RefCell<Food>> = Rc::new(RefCell::new(Food {\\n                name: name.to_owned(),\\n                rating,\\n            }));\\n            cuisine_to_foods\\n                .entry(cuisine.to_owned())\\n                .or_default()\\n                .push(food.clone());\\n            name_to_cuisine.insert(name.to_owned(), cuisine.to_owned());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        for (_cuisine, foods) in cuisine_to_foods.iter_mut() {\\n            foods.sort();\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n            name_to_cuisine,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get(&name) {\\n            food.borrow_mut().rating = new_rating;\\n            if let Some(cuisine) = self.name_to_cuisine.get(&name) {\\n                if let Some(foods) = self.cuisine_to_foods.get_mut(cuisine) {\\n                    foods.sort();\\n                }\\n            }\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(foods) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(last) = foods.last() {\\n                return last.borrow().name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &other.name).cmp(&(other.rating, &self.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(other.name.cmp(&self.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```\\n\\nTo reply on heaps, even though to leverage interior mutability is technically feasible, it is <b>not</b> recommended to do so, and the order of elements in the heap does <b>not</b> change.\\n\\nThis is a wrong solution.\\n\\n```\\nuse std::cell::RefCell;\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::{BinaryHeap, HashMap};\\nuse std::rc::Rc;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexitiy:   N.A.\\n/// Space Complexity:   N.A.\\n/// Note:\\n/// this is a wrong solution.\\n/// Note - Lessons Learned:\\n/// https://stackoverflow.com/questions/58790368/updating-structs-inside-a-btreeset/58790477#58790477\\n/// https://stackoverflow.com/questions/53111721/can-i-modify-a-value-inside-a-binaryheap-that-isnt-the-top-value\\n#[allow(dead_code)]\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, BinaryHeap<Rc<RefCell<Food>>>>,\\n    name_to_food: HashMap<String, Rc<RefCell<Food>>>,\\n}\\n\\n#[allow(dead_code)]\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, BinaryHeap<Rc<RefCell<Food>>>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Rc<RefCell<Food>>> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: String = foods[idx].to_owned();\\n            let cuisine: String = cuisines[idx].to_owned();\\n            let rating: i32 = ratings[idx];\\n            let food: Rc<RefCell<Food>> = Rc::new(RefCell::new(Food {\\n                name: name.to_owned(),\\n                rating,\\n            }));\\n            cuisine_to_foods\\n                .entry(cuisine)\\n                .or_default()\\n                .push(food.clone());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get(&name) {\\n            food.clone().borrow_mut().rating = new_rating;\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(heap) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(top) = heap.peek() {\\n                return top.clone().borrow().name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &self.name).cmp(&(other.rating, &other.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(self.name.cmp(&other.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    #[should_panic]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::{BTreeSet, HashMap};\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexities:\\n///     `new()`:            O(`len_fs`)\\n///     `change_rating`:    O(lg(`len_fs`))\\n///     `highest_rated`:    O(1)\\n/// Space Complexity:       O(`len_fs`)\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, BTreeSet<Food>>,\\n    name_to_food: HashMap<String, Food>,\\n    name_to_cuisine: HashMap<String, String>,\\n}\\n\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, BTreeSet<Food>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Food> = HashMap::new();\\n        let mut name_to_cuisine: HashMap<String, String> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: &String = &foods[idx];\\n            let cuisine: &String = &cuisines[idx];\\n            let rating: i32 = ratings[idx];\\n            let food: Food = Food {\\n                name: name.to_owned(),\\n                rating,\\n            };\\n            cuisine_to_foods\\n                .entry(cuisine.to_owned())\\n                .or_default()\\n                .insert(food.clone());\\n            name_to_cuisine.insert(name.to_owned(), cuisine.to_owned());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n            name_to_cuisine,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get_mut(&name) {\\n            if let Some(cuisine) = self.name_to_cuisine.get(&name) {\\n                if let Some(foods) = self.cuisine_to_foods.get_mut(cuisine) {\\n                    foods.remove(food);\\n                    food.rating = new_rating;\\n                    foods.insert(food.clone());\\n                }\\n            }\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(foods) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(last) = foods.iter().last() {\\n                return last.name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\n#[derive(Clone)]\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &other.name).cmp(&(other.rating, &self.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(other.name.cmp(&self.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```\n```\\nuse std::cell::RefCell;\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::HashMap;\\nuse std::rc::Rc;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexities:\\n///     `new()`:            O(`len_fs`)\\n///     `change_rating`:    O(lg(`len_fs`))\\n///     `highest_rated`:    O(1)\\n/// Space Complexity:       O(`len_fs`)\\n#[allow(dead_code)]\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, Vec<Rc<RefCell<Food>>>>,\\n    name_to_food: HashMap<String, Rc<RefCell<Food>>>,\\n    name_to_cuisine: HashMap<String, String>,\\n}\\n\\n#[allow(dead_code)]\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, Vec<Rc<RefCell<Food>>>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Rc<RefCell<Food>>> = HashMap::new();\\n        let mut name_to_cuisine: HashMap<String, String> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: &String = &foods[idx];\\n            let cuisine: &String = &cuisines[idx];\\n            let rating: i32 = ratings[idx];\\n            let food: Rc<RefCell<Food>> = Rc::new(RefCell::new(Food {\\n                name: name.to_owned(),\\n                rating,\\n            }));\\n            cuisine_to_foods\\n                .entry(cuisine.to_owned())\\n                .or_default()\\n                .push(food.clone());\\n            name_to_cuisine.insert(name.to_owned(), cuisine.to_owned());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        for (_cuisine, foods) in cuisine_to_foods.iter_mut() {\\n            foods.sort();\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n            name_to_cuisine,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get(&name) {\\n            food.borrow_mut().rating = new_rating;\\n            if let Some(cuisine) = self.name_to_cuisine.get(&name) {\\n                if let Some(foods) = self.cuisine_to_foods.get_mut(cuisine) {\\n                    foods.sort();\\n                }\\n            }\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(foods) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(last) = foods.last() {\\n                return last.borrow().name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &other.name).cmp(&(other.rating, &self.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(other.name.cmp(&self.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```\n```\\nuse std::cell::RefCell;\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::{BinaryHeap, HashMap};\\nuse std::rc::Rc;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexitiy:   N.A.\\n/// Space Complexity:   N.A.\\n/// Note:\\n/// this is a wrong solution.\\n/// Note - Lessons Learned:\\n/// https://stackoverflow.com/questions/58790368/updating-structs-inside-a-btreeset/58790477#58790477\\n/// https://stackoverflow.com/questions/53111721/can-i-modify-a-value-inside-a-binaryheap-that-isnt-the-top-value\\n#[allow(dead_code)]\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, BinaryHeap<Rc<RefCell<Food>>>>,\\n    name_to_food: HashMap<String, Rc<RefCell<Food>>>,\\n}\\n\\n#[allow(dead_code)]\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, BinaryHeap<Rc<RefCell<Food>>>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Rc<RefCell<Food>>> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: String = foods[idx].to_owned();\\n            let cuisine: String = cuisines[idx].to_owned();\\n            let rating: i32 = ratings[idx];\\n            let food: Rc<RefCell<Food>> = Rc::new(RefCell::new(Food {\\n                name: name.to_owned(),\\n                rating,\\n            }));\\n            cuisine_to_foods\\n                .entry(cuisine)\\n                .or_default()\\n                .push(food.clone());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get(&name) {\\n            food.clone().borrow_mut().rating = new_rating;\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(heap) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(top) = heap.peek() {\\n                return top.clone().borrow().name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &self.name).cmp(&(other.rating, &other.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(self.name.cmp(&other.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    #[should_panic]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2334200,
                "title": "python-using-sortedlist-and-heap",
                "content": "### use SortedList\\n\\tfrom sortedcontainers import SortedList\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.f2c = {}\\n\\t\\t\\tself.c2rf = defaultdict(SortedList)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\tself.f2c[foods[i]] = (cuisines[i], ratings[i])\\n\\t\\t\\t\\tself.c2rf[cuisines[i]].add((-ratings[i], foods[i]))\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tcuisine, rating = self.f2c[food]\\n\\t\\t\\tself.c2rf[cuisine].remove((-rating, food))\\n\\t\\t\\tself.c2rf[cuisine].add((-newRating, food))\\n\\t\\t\\tself.f2c[food] = (cuisine, newRating)\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\treturn self.c2rf[cuisine][0][1]\\n\\n### use heap\\n\\tfrom collections import defaultdict\\n\\tfrom heapq import heappush, heappop\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.f2r = defaultdict(int)\\n\\t\\t\\tself.f2c = defaultdict(str)\\n\\t\\t\\tself.c2rf = defaultdict(list)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\tself.f2r[foods[i]] = ratings[i]\\n\\t\\t\\t\\tself.f2c[foods[i]] = cuisines[i]\\n\\t\\t\\t\\theappush(self.c2rf[cuisines[i]], (-ratings[i], foods[i]))\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tself.f2r[food] = newRating\\n\\t\\t\\theappush(self.c2rf[self.f2c[food]], (-newRating, food))\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\twhile (self.c2rf[cuisine]):\\n\\t\\t\\t\\tif (self.c2rf[cuisine][0][0] != -self.f2r[self.c2rf[cuisine][0][1]]):\\n\\t\\t\\t\\t\\theappop(self.c2rf[cuisine])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn self.c2rf[cuisine][0][1]",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "### use SortedList\\n\\tfrom sortedcontainers import SortedList\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.f2c = {}\\n\\t\\t\\tself.c2rf = defaultdict(SortedList)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\tself.f2c[foods[i]] = (cuisines[i], ratings[i])\\n\\t\\t\\t\\tself.c2rf[cuisines[i]].add((-ratings[i], foods[i]))\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tcuisine, rating = self.f2c[food]\\n\\t\\t\\tself.c2rf[cuisine].remove((-rating, food))\\n\\t\\t\\tself.c2rf[cuisine].add((-newRating, food))\\n\\t\\t\\tself.f2c[food] = (cuisine, newRating)\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\treturn self.c2rf[cuisine][0][1]\\n\\n### use heap\\n\\tfrom collections import defaultdict\\n\\tfrom heapq import heappush, heappop\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.f2r = defaultdict(int)\\n\\t\\t\\tself.f2c = defaultdict(str)\\n\\t\\t\\tself.c2rf = defaultdict(list)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\tself.f2r[foods[i]] = ratings[i]\\n\\t\\t\\t\\tself.f2c[foods[i]] = cuisines[i]\\n\\t\\t\\t\\theappush(self.c2rf[cuisines[i]], (-ratings[i], foods[i]))\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tself.f2r[food] = newRating\\n\\t\\t\\theappush(self.c2rf[self.f2c[food]], (-newRating, food))\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\twhile (self.c2rf[cuisine]):\\n\\t\\t\\t\\tif (self.c2rf[cuisine][0][0] != -self.f2r[self.c2rf[cuisine][0][1]]):\\n\\t\\t\\t\\t\\theappop(self.c2rf[cuisine])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn self.c2rf[cuisine][0][1]",
                "codeTag": "Java"
            },
            {
                "id": 2329658,
                "title": "priorityqueue-ordering-not-working-looking-for-help",
                "content": "Could anyone shed light on why is the custom sorting in the PriorityQueue not working?\\n\\nFor this ordering specifically,\\n```\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\\n            (a,b) -> (\\n                a.getValue() == b.getValue() ? \\n                b.getKey().compareTo(a.getKey()) : \\n                a.getValue() - b.getValue()\\n            )\\n        );\\n```\\nMap.Entry<String, Integer> [kjop=995] would come before [lzeqwfb=995]\\n\\n\\nInput:\\n```\\n[\"FoodRatings\",\"changeRating\",\"changeRating\",\"highestRated\"]\\n[[[\"vhbibydfop\",\"ggtdlawxup\",\"lslcltacc\",\"bqgkfcy\",\"xxowyabq\",\"ezswv\",\"ewgvsuyvpo\",\"zgochpey\",\"epiaxxiv\",\"idpdiqlcp\",\"wqgrbvme\",\"wqxbxeovwe\",\"iduzk\",\"ahemklz\",\"ah\",\"rvuqnlydxu\",\"dldqmpheob\",\"lzeqwfb\",\"ykwjc\",\"dtrgnrcqr\",\"cwcgevzzz\",\"zejbynj\",\"ivhdsnjpho\",\"gsyewq\",\"ekqhtiijrj\",\"cthwbt\",\"gnbhjyhcil\",\"kkthw\",\"ktiqokzl\",\"zzroi\",\"cjwapjnzql\",\"hfum\",\"jrwby\",\"amhfyno\",\"bj\",\"fszije\",\"nbkpptir\",\"dgzmoxhhoe\",\"bnisfskgxi\",\"uepypxnsy\",\"afdz\",\"tdctkeg\",\"lfsohpzmk\",\"ewwqult\",\"iynyddno\",\"yyroyjzdg\",\"mcpea\",\"lzafjh\",\"jdvcxidtm\",\"qvkyqmupz\",\"kjop\",\"girgfkaib\",\"qecvnaxpsm\",\"itx\",\"xhjmq\",\"lwwbdxkz\",\"chthxuhex\",\"tghokrfica\",\"vrmjibxv\",\"oipnttbz\",\"yyfvlwvj\",\"erbtnw\",\"yezfiom\",\"ismarfqbuv\",\"vmfxlqbxwa\",\"pcwparohxf\",\"bpdrndbv\",\"owgjjitjfd\",\"fdwmxhli\",\"kffetdxvfx\",\"ruahmg\",\"aphbsbkimb\",\"nbkdfkgl\",\"rxehcqcrwu\",\"kxwlfxbe\",\"qukxd\",\"tewgnjuxnm\",\"jxfqwqe\",\"mdgwiok\",\"tbkmnx\",\"klzznopcn\",\"vjbcvddw\",\"yzhawtmpwp\",\"fhjichpi\",\"tapig\",\"glfbwolsoa\",\"xklqlzm\"],[\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\"],[146,562,428,619,731,483,598,619,950,446,630,556,894,911,537,359,863,995,417,702,689,667,502,691,896,582,111,319,182,953,131,372,563,963,300,42,829,187,676,509,259,688,897,614,392,170,392,1,134,79,995,371,886,430,72,830,871,758,247,333,128,987,659,933,640,198,638,585,825,904,729,214,974,935,581,985,85,987,51,174,301,635,148,492,200,275,101]],[\"nbkdfkgl\",908],[\"hfum\",256],[\"kggxajkarh\"]]\\n```\\n\\nOutput:\\n```\\n[null,null,null,\"lzeqwfb\"]\\n```\\n\\nExpected:\\n```\\n[null,null,null,\"kjop\"]\\n```\\n\\nMy code:\\n```\\nclass FoodRatings {\\n    Map<String, Map<String, Integer>> cuisineMap;\\n    Map<String, String> foodCuisineMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineMap = new HashMap<String, Map<String, Integer>>();\\n        foodCuisineMap = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            cuisineMap.putIfAbsent(cuisines[i], new HashMap<String, Integer>());\\n            cuisineMap.get(cuisines[i]).put(foods[i], ratings[i]);\\n            \\n            foodCuisineMap.putIfAbsent(foods[i], cuisines[i]);\\n        }        \\n    }\\n    \\n    public void changeRating(String food, int newRating) { \\n        String cuisine = foodCuisineMap.get(food);\\n        if (cuisine == null) {\\n            return;\\n        }\\n        \\n        cuisineMap.get(cuisine).put(food, newRating);    \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        Map<String, Integer> entries = cuisineMap.get(cuisine);\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\\n            (a,b) -> (\\n                a.getValue() == b.getValue() ? \\n                b.getKey().compareTo(a.getKey()) : \\n                a.getValue() - b.getValue()\\n            )\\n        );\\n        \\n        for (Map.Entry<String, Integer> entry: entries.entrySet()) {\\n            pq.add(entry);\\n            \\n            if (pq.size() > 1) {\\n                pq.poll();\\n            }\\n        }\\n        \\n        // while (pq.size() > 0) {\\n        //     System.out.println(pq.poll());\\n        // }\\n        \\n        return pq.peek().getKey();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\\n            (a,b) -> (\\n                a.getValue() == b.getValue() ? \\n                b.getKey().compareTo(a.getKey()) : \\n                a.getValue() - b.getValue()\\n            )\\n        );\\n```\n```\\n[\"FoodRatings\",\"changeRating\",\"changeRating\",\"highestRated\"]\\n[[[\"vhbibydfop\",\"ggtdlawxup\",\"lslcltacc\",\"bqgkfcy\",\"xxowyabq\",\"ezswv\",\"ewgvsuyvpo\",\"zgochpey\",\"epiaxxiv\",\"idpdiqlcp\",\"wqgrbvme\",\"wqxbxeovwe\",\"iduzk\",\"ahemklz\",\"ah\",\"rvuqnlydxu\",\"dldqmpheob\",\"lzeqwfb\",\"ykwjc\",\"dtrgnrcqr\",\"cwcgevzzz\",\"zejbynj\",\"ivhdsnjpho\",\"gsyewq\",\"ekqhtiijrj\",\"cthwbt\",\"gnbhjyhcil\",\"kkthw\",\"ktiqokzl\",\"zzroi\",\"cjwapjnzql\",\"hfum\",\"jrwby\",\"amhfyno\",\"bj\",\"fszije\",\"nbkpptir\",\"dgzmoxhhoe\",\"bnisfskgxi\",\"uepypxnsy\",\"afdz\",\"tdctkeg\",\"lfsohpzmk\",\"ewwqult\",\"iynyddno\",\"yyroyjzdg\",\"mcpea\",\"lzafjh\",\"jdvcxidtm\",\"qvkyqmupz\",\"kjop\",\"girgfkaib\",\"qecvnaxpsm\",\"itx\",\"xhjmq\",\"lwwbdxkz\",\"chthxuhex\",\"tghokrfica\",\"vrmjibxv\",\"oipnttbz\",\"yyfvlwvj\",\"erbtnw\",\"yezfiom\",\"ismarfqbuv\",\"vmfxlqbxwa\",\"pcwparohxf\",\"bpdrndbv\",\"owgjjitjfd\",\"fdwmxhli\",\"kffetdxvfx\",\"ruahmg\",\"aphbsbkimb\",\"nbkdfkgl\",\"rxehcqcrwu\",\"kxwlfxbe\",\"qukxd\",\"tewgnjuxnm\",\"jxfqwqe\",\"mdgwiok\",\"tbkmnx\",\"klzznopcn\",\"vjbcvddw\",\"yzhawtmpwp\",\"fhjichpi\",\"tapig\",\"glfbwolsoa\",\"xklqlzm\"],[\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\"],[146,562,428,619,731,483,598,619,950,446,630,556,894,911,537,359,863,995,417,702,689,667,502,691,896,582,111,319,182,953,131,372,563,963,300,42,829,187,676,509,259,688,897,614,392,170,392,1,134,79,995,371,886,430,72,830,871,758,247,333,128,987,659,933,640,198,638,585,825,904,729,214,974,935,581,985,85,987,51,174,301,635,148,492,200,275,101]],[\"nbkdfkgl\",908],[\"hfum\",256],[\"kggxajkarh\"]]\\n```\n```\\n[null,null,null,\"lzeqwfb\"]\\n```\n```\\n[null,null,null,\"kjop\"]\\n```\n```\\nclass FoodRatings {\\n    Map<String, Map<String, Integer>> cuisineMap;\\n    Map<String, String> foodCuisineMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineMap = new HashMap<String, Map<String, Integer>>();\\n        foodCuisineMap = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            cuisineMap.putIfAbsent(cuisines[i], new HashMap<String, Integer>());\\n            cuisineMap.get(cuisines[i]).put(foods[i], ratings[i]);\\n            \\n            foodCuisineMap.putIfAbsent(foods[i], cuisines[i]);\\n        }        \\n    }\\n    \\n    public void changeRating(String food, int newRating) { \\n        String cuisine = foodCuisineMap.get(food);\\n        if (cuisine == null) {\\n            return;\\n        }\\n        \\n        cuisineMap.get(cuisine).put(food, newRating);    \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        Map<String, Integer> entries = cuisineMap.get(cuisine);\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\\n            (a,b) -> (\\n                a.getValue() == b.getValue() ? \\n                b.getKey().compareTo(a.getKey()) : \\n                a.getValue() - b.getValue()\\n            )\\n        );\\n        \\n        for (Map.Entry<String, Integer> entry: entries.entrySet()) {\\n            pq.add(entry);\\n            \\n            if (pq.size() > 1) {\\n                pq.poll();\\n            }\\n        }\\n        \\n        // while (pq.size() > 0) {\\n        //     System.out.println(pq.poll());\\n        // }\\n        \\n        return pq.peek().getKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325377,
                "title": "three-maps-unordered-maps-in-c-explained-thought-process",
                "content": "The first thing is to solve this question is to take a paper and pen and try to write the info and given and functions required. This helped me as earlier i used to just think in my head and directly go on coding just to find later that i missed a requirement and start over again.\\n\\nOk, firstly two functions requirement: \\nchangeRating(food,newRating) -> void\\nhighestRated(cuisine) -> string food(in given cuisine)\\n\\nNow for the first requirement: \\nFirst thought might be simple unordered_map for fast updates of ratings\\n**unordered_map<string,int> foods_to_ratings**\\nNow the first requirement is easy and main bottleneck is second requirement. Also we need to keep in mind that we already choosen a **foods_to_ratings unordered_map** so we have to keep that updated too.\\n\\nSecond function takes a cuisine.\\n\\nWhat if keep **unordered_map<string,vector<pair<int,string>> cuisine_to_ratings_food** where **string is cuisine given** and **vector stores the pair<ratings,food>** \\nIt\\'s because i need to quickly decide which the highest rated food in **given cuisine** so i need **some food division based on cuisine**.\\nBut now for highestRated food in that vector of cuisine_to_ratings_food[given_cuisine] i had to go over the take the entire vector to find highest rated food which will be not good as in worst case all given food can belong to same cuisine and so **it will take O(n) for each call of function** where  **n can be upto 2x10^4**\\nAlso if any food ratings update by **changeRatings(food,newRatings)** then i need to \\n(1) find cuisine of that food \\n(2) remove the <Oldratings,food> pair from vector in cuisine_to_ratings_food[cusine]  \\n(3) add <needRatings,food> pair in that. ( Note [cuisine] in cuisinetoratingsfood used in operation (2) can be found by (1) operation and way to find (1) is given below) \\n(4) Update the food_to_ratings unordered_map which too quick\\n\\n### How to do (1) operation?\\nI need to find food\\'s cuisine so either i can keep unordered_map<food,cuisine> or map for the same.\\n \\n ### How to the (2) operation?\\n We can get the oldRatings of food by **food_to_Ratings unordered_map**\\n\\n### What\\'s the problem in this approach?\\nObviously the O(n) for findHighestRated(cuisine) is there iterating the vector.\\nAlso O(n) for deleting the pair<oldRatings,food> in changeRatings(food,newRatings) so that the findHighestRated() function works fine. \\n\\n### Where can we improve?\\nOk so i need to cut down the effort for finding the highest rated cuisine and also deletion of pair<ratings,food>. \\nHmm the pair<ratings,food> is unique right? Since for every food only one rating is there at  a time so pair<ratings,food> is unique.\\n### What datastructure is good in maintaining unique set of values in some order and give fast retrieval and updation?\\n### That\\'s set\\n\\n**So instead of vector what if we store the pairs in set<ratings,food> with custom comparator which keeps the highest ratings food at first and if the ratings of more than one food items are same then keep the food in lexicographical order.**\\n\\n**findHighestRated is O(1) since we just return the first pair of set in the cuisine division**.\\nAfter keeping set instead of vector let\\'s see operation of changeRatings(food,newRatings):\\n(1) find cuisine of food by food_to_cuisine unordered map\\n(2) remove the <Oldratings,food> pair from vector in cuisine_to_ratings_food[cusine] \\nin O(10.log(20000)) since for every comparison(in worst case) the strings time complexity for same ratings is O(10).\\n(3) add <needRatings,food> pair in that. ( same as removing a pair)\\n(4) Update the food_to_ratings unordered_map so that in operation (2) we can find OldRatings of food quickly.\\n\\n```cpp\\n//custom comparator\\nstruct Compare\\n{\\n    bool operator ()( const std::pair<int, string> &a, \\n                      const std::pair<int, string> &b ) const{\\n        return a.first!=b.first?a.first>b.first:a.second<b.second;\\n    }\\n};\\n\\n//f_t_r means food to ratings mapping\\n//f_t_c means food to cuisine mapping\\n//c_t_r_f means cuisine to pair<ratings,food> mapping\\n\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,int> f_t_r;\\n    unordered_map<string,string> f_t_c;\\n    unordered_map<string,set<pair<int,string>,Compare>> c_t_r_f;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i < foods.size();i++){\\n            f_t_c[foods[i]] = cuisines[i];\\n            f_t_r[foods[i]] = ratings[i];\\n            c_t_r_f[cuisines[i]].insert(make_pair(ratings[i],foods[i]));\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cuisine = f_t_c[food];\\n        int old_ratings = f_t_r[food];\\n        \\n        f_t_r[food] = newRating;\\n        c_t_r_f[cuisine].erase(make_pair(old_ratings,food));\\n        c_t_r_f[cuisine].insert(make_pair(newRating,food));\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return c_t_r_f[cuisine].begin()->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```\\n\\nAlso note that all the places you can replace unordered_map with map of same kind. It should work fine enough to pass.",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n//custom comparator\\nstruct Compare\\n{\\n    bool operator ()( const std::pair<int, string> &a, \\n                      const std::pair<int, string> &b ) const{\\n        return a.first!=b.first?a.first>b.first:a.second<b.second;\\n    }\\n};\\n\\n//f_t_r means food to ratings mapping\\n//f_t_c means food to cuisine mapping\\n//c_t_r_f means cuisine to pair<ratings,food> mapping\\n\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,int> f_t_r;\\n    unordered_map<string,string> f_t_c;\\n    unordered_map<string,set<pair<int,string>,Compare>> c_t_r_f;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i < foods.size();i++){\\n            f_t_c[foods[i]] = cuisines[i];\\n            f_t_r[foods[i]] = ratings[i];\\n            c_t_r_f[cuisines[i]].insert(make_pair(ratings[i],foods[i]));\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cuisine = f_t_c[food];\\n        int old_ratings = f_t_r[food];\\n        \\n        f_t_r[food] = newRating;\\n        c_t_r_f[cuisine].erase(make_pair(old_ratings,food));\\n        c_t_r_f[cuisine].insert(make_pair(newRating,food));\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return c_t_r_f[cuisine].begin()->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325023,
                "title": "java-clean-code-100-fastest",
                "content": "Tried my best to write modular maintainable code. Food and FoodComparator object can be expanded with extra properties as well as.\\n\\nImprovements are welcome and upvote if it helps.\\n\\n**PriorityQueue vs TreeSet**\\n* PQ remove(), i.e the top element is only O(log N), parameterized removal is O(N) to search the object and O(log N) to remove it. TreeSet is O(log N) removal.\\n* PQ allows duplicates while TS has to be unique. \\n* Actually we can use TS here as it\\'s objects we are storing and comparator takes care of order.\\n![image](https://assets.leetcode.com/users/images/b0c9b538-8a4d-48a2-9233-7404d915e45c_1658766363.7961705.png)\\n\\n*Using TreeSet instead of PriorityQueue made the solution 1500ms+ faster!*\\n\\n```\\nclass FoodRatings {\\n    \\n    class Food {\\n        private String food, cuisine;\\n        private int rating;\\n        Food(String food, String cuisine, int rating){\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    \\n    class FoodComparator implements Comparator<Food>{\\n        public int compare(Food s1, Food s2) {\\n            if (s1.rating < s2.rating)\\n                return 1;\\n            else if (s1.rating > s2.rating)\\n                return -1;\\n            return (s1.food).compareTo(s2.food); // if ratings are equal\\n        }\\n    }\\n    \\n    HashMap<String, Food> foodMap;\\n    HashMap<String, TreeSet<Food>> cuisineMap;\\n    TreeSet<Food> bestFoods;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n        \\n        for(int i=0; i<foods.length; i++){\\n            if(cuisineMap.containsKey(cuisines[i])){\\n                bestFoods = cuisineMap.get(cuisines[i]);\\n            } else{\\n                bestFoods = new TreeSet<>(new FoodComparator());\\n            }\\n            \\n            Food foodObj = new Food(foods[i], cuisines[i], ratings[i]);\\n            bestFoods.add(foodObj);\\n            cuisineMap.put(cuisines[i], bestFoods);\\n            foodMap.put(foods[i], foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String newFood, int newRating) {\\n        Food foodObj = foodMap.get(newFood);\\n        String cuisine = foodObj.cuisine;\\n        bestFoods = cuisineMap.get(cuisine);\\n        \\n        // recompute heap\\n        bestFoods.remove(foodObj);\\n        foodObj.rating = newRating;\\n        bestFoods.add(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        bestFoods = cuisineMap.get(cuisine);\\n        Food foodObj = bestFoods.first();\\n        return foodObj.food;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    \\n    class Food {\\n        private String food, cuisine;\\n        private int rating;\\n        Food(String food, String cuisine, int rating){\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    \\n    class FoodComparator implements Comparator<Food>{\\n        public int compare(Food s1, Food s2) {\\n            if (s1.rating < s2.rating)\\n                return 1;\\n            else if (s1.rating > s2.rating)\\n                return -1;\\n            return (s1.food).compareTo(s2.food); // if ratings are equal\\n        }\\n    }\\n    \\n    HashMap<String, Food> foodMap;\\n    HashMap<String, TreeSet<Food>> cuisineMap;\\n    TreeSet<Food> bestFoods;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n        \\n        for(int i=0; i<foods.length; i++){\\n            if(cuisineMap.containsKey(cuisines[i])){\\n                bestFoods = cuisineMap.get(cuisines[i]);\\n            } else{\\n                bestFoods = new TreeSet<>(new FoodComparator());\\n            }\\n            \\n            Food foodObj = new Food(foods[i], cuisines[i], ratings[i]);\\n            bestFoods.add(foodObj);\\n            cuisineMap.put(cuisines[i], bestFoods);\\n            foodMap.put(foods[i], foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String newFood, int newRating) {\\n        Food foodObj = foodMap.get(newFood);\\n        String cuisine = foodObj.cuisine;\\n        bestFoods = cuisineMap.get(cuisine);\\n        \\n        // recompute heap\\n        bestFoods.remove(foodObj);\\n        foodObj.rating = newRating;\\n        bestFoods.add(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        bestFoods = cuisineMap.get(cuisine);\\n        Food foodObj = bestFoods.first();\\n        return foodObj.food;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324952,
                "title": "c-three-maps",
                "content": "\\tclass FoodRatings {\\n\\tpublic:\\n\\t   unordered_map<string,string>focu; // stores food as key and cuisine as value\\n\\t\\tunordered_map<string,int>fRating; // stores food as key and rating as value\\n\\t\\tunordered_map<string,set<pair<int,string>>>focura; // strores cuisine as key and rating and food as value\\n\\t\\tFoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n\\t\\t\\tfor(int i=0;i<size(foods);i++){\\n\\t\\t\\t\\tfocu[foods[i]] = cuisines[i];\\n\\t\\t\\t\\tfRating[foods[i]] = ratings[i];\\n\\t\\t\\t\\tfocura[cuisines[i]].insert({ratings[i],foods[i]});\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid changeRating(string food, int newRating) {\\n\\t\\t\\t   int num = fRating[food];\\n\\t\\t\\t\\tstring cu = focu[food];\\n\\t\\t\\t\\tfocura[cu].erase({num,food});\\n\\t\\t\\t\\tfocura[cu].insert({newRating,food});\\n\\t\\t\\t\\tfRating[food] = newRating;\\n\\t\\t}\\n\\n\\t\\tstring highestRated(string cuisine) {\\n\\t\\t\\tstring res = focura[cuisine].rbegin()->second;\\n\\t\\t\\tint cnt = focura[cuisine].rbegin()->first;\\n\\t\\t\\tfor(auto it = focura[cuisine].rbegin(); it!=focura[cuisine].rend();it++){\\n\\t\\t\\t\\tif(it->first==cnt){\\n\\t\\t\\t\\t\\tres = min(it->second,res);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse break;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [],
                "code": "\\tclass FoodRatings {\\n\\tpublic:\\n\\t   unordered_map<string,string>focu; // stores food as key and cuisine as value\\n\\t\\tunordered_map<string,int>fRating; // stores food as key and rating as value\\n\\t\\tunordered_map<string,set<pair<int,string>>>focura; // strores cuisine as key and rating and food as value\\n\\t\\tFoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n\\t\\t\\tfor(int i=0;i<size(foods);i++){\\n\\t\\t\\t\\tfocu[foods[i]] = cuisines[i];\\n\\t\\t\\t\\tfRating[foods[i]] = ratings[i];\\n\\t\\t\\t\\tfocura[cuisines[i]].insert({ratings[i],foods[i]});\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid changeRating(string food, int newRating) {\\n\\t\\t\\t   int num = fRating[food];\\n\\t\\t\\t\\tstring cu = focu[food];\\n\\t\\t\\t\\tfocura[cu].erase({num,food});\\n\\t\\t\\t\\tfocura[cu].insert({newRating,food});\\n\\t\\t\\t\\tfRating[food] = newRating;\\n\\t\\t}\\n\\n\\t\\tstring highestRated(string cuisine) {\\n\\t\\t\\tstring res = focura[cuisine].rbegin()->second;\\n\\t\\t\\tint cnt = focura[cuisine].rbegin()->first;\\n\\t\\t\\tfor(auto it = focura[cuisine].rbegin(); it!=focura[cuisine].rend();it++){\\n\\t\\t\\t\\tif(it->first==cnt){\\n\\t\\t\\t\\t\\tres = min(it->second,res);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse break;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2324935,
                "title": "easy-java-solution-using-priority-queue-and-hashmap",
                "content": "``` java\\nclass FoodRatings {\\n\\n    class Food {\\n        String name;\\n        String cuisine;\\n        int rating;\\n\\n        public Food(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n\\n    Map<String, Food> map;\\n    Map<String, PriorityQueue<Food>> cuisineMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n        for (int i = 0; i < foods.length; i++) {\\n            Food food = new Food(foods[i], cuisines[i], ratings[i]);\\n            map.put(foods[i], food);\\n            if (!cuisineMap.containsKey(cuisines[i])) \\n                cuisineMap.put(cuisines[i], new PriorityQueue<>(\\n                    (a, b) -> b.rating == a.rating ? a.name.compareTo(b.name) : b.rating - a.rating\\n                ));\\n            cuisineMap.get(cuisines[i]).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        map.get(food).rating = newRating;\\n        PriorityQueue<Food> q = cuisineMap.get(map.get(food).cuisine);\\n        q.remove(map.get(food));\\n        q.offer(map.get(food));\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).peek().name;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass FoodRatings {\\n\\n    class Food {\\n        String name;\\n        String cuisine;\\n        int rating;\\n\\n        public Food(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n\\n    Map<String, Food> map;\\n    Map<String, PriorityQueue<Food>> cuisineMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n        for (int i = 0; i < foods.length; i++) {\\n            Food food = new Food(foods[i], cuisines[i], ratings[i]);\\n            map.put(foods[i], food);\\n            if (!cuisineMap.containsKey(cuisines[i])) \\n                cuisineMap.put(cuisines[i], new PriorityQueue<>(\\n                    (a, b) -> b.rating == a.rating ? a.name.compareTo(b.name) : b.rating - a.rating\\n                ));\\n            cuisineMap.get(cuisines[i]).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        map.get(food).rating = newRating;\\n        PriorityQueue<Food> q = cuisineMap.get(map.get(food).cuisine);\\n        q.remove(map.get(food));\\n        q.offer(map.get(food));\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).peek().name;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324901,
                "title": "c-three-maps",
                "content": "```\\nstruct comp {\\n bool operator()(const pair<int, string> &a, const pair<int, string> &b) const \\n    { \\n        if(a.first==b.first)\\n        {\\n            return a.second>b.second;\\n        }\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    map<string, int> r; \\n    map<string, set<pair<int, string>, comp>> m;\\n    map<string, string> c;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            r[foods[i]]=ratings[i];\\n            m[cuisines[i]].insert({ratings[i], foods[i]});\\n            c[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[c[food]].erase({r[food], food});\\n        m[c[food]].insert({newRating, food});\\n        r[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--m[cuisine].end()).second;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstruct comp {\\n bool operator()(const pair<int, string> &a, const pair<int, string> &b) const \\n    { \\n        if(a.first==b.first)\\n        {\\n            return a.second>b.second;\\n        }\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    map<string, int> r; \\n    map<string, set<pair<int, string>, comp>> m;\\n    map<string, string> c;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            r[foods[i]]=ratings[i];\\n            m[cuisines[i]].insert({ratings[i], foods[i]});\\n            c[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[c[food]].erase({r[food], food});\\n        m[c[food]].insert({newRating, food});\\n        r[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--m[cuisine].end()).second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324694,
                "title": "two-maps",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    map<string,pair<int,string>> foodRating;\\n    map<string,map<int,set<string>>> cuisineRating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            foodRating[foods[i]] = {ratings[i],cuisines[i]};\\n            cuisineRating[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto it = foodRating[food];\\n        cuisineRating[it.second][it.first].erase(food);\\n        if(cuisineRating[it.second][it.first].size()==0){\\n            cuisineRating[it.second].erase(it.first);\\n        }\\n        cuisineRating[it.second][newRating].insert(food);\\n        foodRating[food] = {newRating,it.second};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = cuisineRating[cuisine].rbegin()->second;\\n        return *it.begin();\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    map<string,pair<int,string>> foodRating;\\n    map<string,map<int,set<string>>> cuisineRating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            foodRating[foods[i]] = {ratings[i],cuisines[i]};\\n            cuisineRating[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto it = foodRating[food];\\n        cuisineRating[it.second][it.first].erase(food);\\n        if(cuisineRating[it.second][it.first].size()==0){\\n            cuisineRating[it.second].erase(it.first);\\n        }\\n        cuisineRating[it.second][newRating].insert(food);\\n        foodRating[food] = {newRating,it.second};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = cuisineRating[cuisine].rbegin()->second;\\n        return *it.begin();\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324665,
                "title": "python-3-maps-heap-solution",
                "content": "```python\\nimport heapq\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_ratings = {food:-rating for food, rating in zip(foods, ratings)}\\n        \\n        self.food_cuisine = {food:cuisine for food, cuisine in zip(foods, cuisines)}\\n        \\n        self.cuisine_foods = collections.defaultdict(list)\\n        for cuisine, (food, rating) in zip(cuisines, zip(foods, ratings)):\\n            self.cuisine_foods[cuisine].append((-rating, food))\\n        for cuisine in self.cuisine_foods:\\n            heapq.heapify(self.cuisine_foods[cuisine])\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_ratings[food] = -newRating\\n        cuisine = self.food_cuisine[food]\\n        heapq.heappush(self.cuisine_foods[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.cuisine_foods[cuisine]:\\n            rating, food = self.cuisine_foods[cuisine][0]\\n            if self.food_ratings[food] != rating:\\n                heapq.heappop(self.cuisine_foods[cuisine])\\n            else:\\n                return food\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nimport heapq\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_ratings = {food:-rating for food, rating in zip(foods, ratings)}\\n        \\n        self.food_cuisine = {food:cuisine for food, cuisine in zip(foods, cuisines)}\\n        \\n        self.cuisine_foods = collections.defaultdict(list)\\n        for cuisine, (food, rating) in zip(cuisines, zip(foods, ratings)):\\n            self.cuisine_foods[cuisine].append((-rating, food))\\n        for cuisine in self.cuisine_foods:\\n            heapq.heapify(self.cuisine_foods[cuisine])\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_ratings[food] = -newRating\\n        cuisine = self.food_cuisine[food]\\n        heapq.heappush(self.cuisine_foods[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.cuisine_foods[cuisine]:\\n            rating, food = self.cuisine_foods[cuisine][0]\\n            if self.food_ratings[food] != rating:\\n                heapq.heappop(self.cuisine_foods[cuisine])\\n            else:\\n                return food\\n",
                "codeTag": "Java"
            },
            {
                "id": 2324636,
                "title": "priority-queue-for-every-cuisine",
                "content": "```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.deleted = defaultdict(int)\\n        self.cuisines = defaultdict(list)\\n        self.f2c = {}\\n        self.ratings = {}\\n        for i in range(n):\\n            heapq.heappush(self.cuisines[cuisines[i]], (-ratings[i], foods[i]))\\n            self.f2c[foods[i]] = cuisines[i]\\n            self.ratings[foods[i]] = ratings[i]\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.f2c[food]\\n        old = self.ratings[food]\\n        self.deleted[(cuisine, -old, food)] += 1\\n        self.ratings[food] = newRating\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisines[cuisine][0]\\n        while (cuisine, rating, food) in self.deleted:\\n            heapq.heappop(self.cuisines[cuisine])\\n            self.deleted[(cuisine, rating, food)] -= 1\\n            if self.deleted[(cuisine, rating, food)] == 0:\\n                del self.deleted[(cuisine, rating, food)]\\n            rating, food = self.cuisines[cuisine][0]\\n        return food\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.deleted = defaultdict(int)\\n        self.cuisines = defaultdict(list)\\n        self.f2c = {}\\n        self.ratings = {}\\n        for i in range(n):\\n            heapq.heappush(self.cuisines[cuisines[i]], (-ratings[i], foods[i]))\\n            self.f2c[foods[i]] = cuisines[i]\\n            self.ratings[foods[i]] = ratings[i]\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.f2c[food]\\n        old = self.ratings[food]\\n        self.deleted[(cuisine, -old, food)] += 1\\n        self.ratings[food] = newRating\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisines[cuisine][0]\\n        while (cuisine, rating, food) in self.deleted:\\n            heapq.heappop(self.cuisines[cuisine])\\n            self.deleted[(cuisine, rating, food)] -= 1\\n            if self.deleted[(cuisine, rating, food)] == 0:\\n                del self.deleted[(cuisine, rating, food)]\\n            rating, food = self.cuisines[cuisine][0]\\n        return food\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573300,
                "title": "python-with-sortedlist",
                "content": "`SortedList`\\xA0is a self-balanced tree with\\xA0`O(logK)`\\xA0insert and\\xA0`O(logK)`\\xA0remove.\\n\\n``` python\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuisine_to_ratings = defaultdict(SortedList)\\n        self.food_to_cuisine = dict()\\n        self.food_to_rating = dict()\\n        for food, cuisine, rating in zip(foods, cuisines, ratings):\\n            self.cuisine_to_ratings[cuisine].add([-rating, food])\\n            if food not in self.food_to_cuisine:\\n                self.food_to_cuisine[food] = cuisine\\n            if food not in self.food_to_rating:\\n                self.food_to_rating[food] = rating\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.food_to_cuisine[food]\\n        self.cuisine_to_ratings[cuisine].discard([-self.food_to_rating[food], food])\\n        self.food_to_rating[food] = newRating\\n        self.cuisine_to_ratings[cuisine].add([-newRating, food])\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if cuisine in self.cuisine_to_ratings:\\n            return self.cuisine_to_ratings[cuisine][0][1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` python\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuisine_to_ratings = defaultdict(SortedList)\\n        self.food_to_cuisine = dict()\\n        self.food_to_rating = dict()\\n        for food, cuisine, rating in zip(foods, cuisines, ratings):\\n            self.cuisine_to_ratings[cuisine].add([-rating, food])\\n            if food not in self.food_to_cuisine:\\n                self.food_to_cuisine[food] = cuisine\\n            if food not in self.food_to_rating:\\n                self.food_to_rating[food] = rating\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.food_to_cuisine[food]\\n        self.cuisine_to_ratings[cuisine].discard([-self.food_to_rating[food], food])\\n        self.food_to_rating[food] = newRating\\n        self.cuisine_to_ratings[cuisine].add([-newRating, food])\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if cuisine in self.cuisine_to_ratings:\\n            return self.cuisine_to_ratings[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498618,
                "title": "priority-queue-three-maps-c",
                "content": "```\\nclass dish{\\npublic:\\n    string food;\\n    int rating;\\n    \\n    dish(string food, int rating){\\n        this->food = food;\\n        this->rating = rating;\\n    }\\n};\\n\\nbool operator<(const dish &d1, const dish &d2){\\n    if(d1.rating == d2.rating) return d1.food > d2.food;\\n    return d1.rating < d2.rating;\\n}\\n\\nclass FoodRatings {\\nprivate:\\n    unordered_map<string, priority_queue<dish>> menuChart;\\n    unordered_map<string, int> foodRatingMap;\\n    unordered_map<string, string> foodCuisineMap;\\n    \\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        \\n        for(int i = 0; i < n; i++){\\n            string cuisine = cuisines[i];\\n            string food = foods[i];\\n            int rating = ratings[i];\\n            dish d = dish(food, rating);\\n            \\n            menuChart[cuisine].emplace(d);\\n            foodCuisineMap[food] = cuisine;\\n            foodRatingMap[food] = rating;\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        foodRatingMap[food] = newRating;\\n        string cuisine = foodCuisineMap[food];\\n        menuChart[cuisine].emplace(dish(food, newRating));\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        while(true){\\n            dish d = menuChart[cuisine].top();\\n            if(foodRatingMap[d.food] == d.rating) return d.food;\\n            else menuChart[cuisine].pop();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass dish{\\npublic:\\n    string food;\\n    int rating;\\n    \\n    dish(string food, int rating){\\n        this->food = food;\\n        this->rating = rating;\\n    }\\n};\\n\\nbool operator<(const dish &d1, const dish &d2){\\n    if(d1.rating == d2.rating) return d1.food > d2.food;\\n    return d1.rating < d2.rating;\\n}\\n\\nclass FoodRatings {\\nprivate:\\n    unordered_map<string, priority_queue<dish>> menuChart;\\n    unordered_map<string, int> foodRatingMap;\\n    unordered_map<string, string> foodCuisineMap;\\n    \\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        \\n        for(int i = 0; i < n; i++){\\n            string cuisine = cuisines[i];\\n            string food = foods[i];\\n            int rating = ratings[i];\\n            dish d = dish(food, rating);\\n            \\n            menuChart[cuisine].emplace(d);\\n            foodCuisineMap[food] = cuisine;\\n            foodRatingMap[food] = rating;\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        foodRatingMap[food] = newRating;\\n        string cuisine = foodCuisineMap[food];\\n        menuChart[cuisine].emplace(dish(food, newRating));\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        while(true){\\n            dish d = menuChart[cuisine].top();\\n            if(foodRatingMap[d.food] == d.rating) return d.food;\\n            else menuChart[cuisine].pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468117,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.size = len(foods)\\n        # foodToCuisine is a map where key will be the food item and value will be the cuisine\\n        # cuisineToFood will be a dict of minheaps were food and ratings are stored as a tuple in values with cuisine as key\\n        # ratingMap contains foods as key and their ratings as values\\n        self.foodToCuisine, self.ratingMap, self.cuisineToFood = self.initialize()\\n    \\n    #Method to initialize our 3 hashMaps\\n    def initialize(self):\\n        foodToCuisine, ratingMap = {}, {}\\n        cuisineToFood = defaultdict(list)\\n        for i in range(self.size):\\n            foodToCuisine[self.foods[i]] = self.cuisines[i]\\n            heapq.heappush(cuisineToFood[self.cuisines[i]], (-self.ratings[i], self.foods[i]))\\n            ratingMap[self.foods[i]] = self.ratings[i]\\n        return foodToCuisine, ratingMap, cuisineToFood\\n        \\n    # Due to cuisineToFood hashMap, this method becomes an easy O(log(n)) method while changing the rating is constant time because of ratingMap\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.ratingMap[food] = newRating\\n        # New rating is pushed in the heap\\n        heapq.heappush(self.cuisineToFood[self.foodToCuisine[food]], (-newRating, food))  \\n    \\n    # RatingMap contains the latest rating of the food whereas the cuisineToFood contains all the ratings.\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisineToFood[cuisine][0]\\n        #While loop to fetch the exact latest rating from all the ratings we have\\n        while -rating != self.ratingMap[food]:\\n            heapq.heappop(self.cuisineToFood[cuisine])\\n            rating,food = self.cuisineToFood[cuisine][0]\\n        return food\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.size = len(foods)\\n        # foodToCuisine is a map where key will be the food item and value will be the cuisine\\n        # cuisineToFood will be a dict of minheaps were food and ratings are stored as a tuple in values with cuisine as key\\n        # ratingMap contains foods as key and their ratings as values\\n        self.foodToCuisine, self.ratingMap, self.cuisineToFood = self.initialize()\\n    \\n    #Method to initialize our 3 hashMaps\\n    def initialize(self):\\n        foodToCuisine, ratingMap = {}, {}\\n        cuisineToFood = defaultdict(list)\\n        for i in range(self.size):\\n            foodToCuisine[self.foods[i]] = self.cuisines[i]\\n            heapq.heappush(cuisineToFood[self.cuisines[i]], (-self.ratings[i], self.foods[i]))\\n            ratingMap[self.foods[i]] = self.ratings[i]\\n        return foodToCuisine, ratingMap, cuisineToFood\\n        \\n    # Due to cuisineToFood hashMap, this method becomes an easy O(log(n)) method while changing the rating is constant time because of ratingMap\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.ratingMap[food] = newRating\\n        # New rating is pushed in the heap\\n        heapq.heappush(self.cuisineToFood[self.foodToCuisine[food]], (-newRating, food))  \\n    \\n    # RatingMap contains the latest rating of the food whereas the cuisineToFood contains all the ratings.\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisineToFood[cuisine][0]\\n        #While loop to fetch the exact latest rating from all the ratings we have\\n        while -rating != self.ratingMap[food]:\\n            heapq.heappop(self.cuisineToFood[cuisine])\\n            rating,food = self.cuisineToFood[cuisine][0]\\n        return food\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451220,
                "title": "two-maps-one-pair-one-treeset-java-o-nlogn",
                "content": "```\\nclass FoodRatings {\\n    // Lesson1, TreeSet && TreeMap don\\'t use hashcode() and equal() to avoid duplicates\\n    // they only use compare() method of Comparator interface OR compareTo() method of Comparable interface to avoid duplicates\\n    // For example, when we call set.remove(\"ABC\"), if set find there exist another elements that compareTo(\"ABC\") returns 0\\n    // -> set will consider these two elements are equal(duplicates)\\n    \\n    // Lesson2, there exists some food with same rating, and we need to return the item with the lexicographically smaller name\\n    // the rating in Map is Integer(which is an object), we need to use equals() instead of \"==\" to check this condition\\n    \\n    \\n    // food name - (cursine name - rating)\\n    Map<String, Pair<String, Integer>> foodMap;\\n    // cuisine - food name\\n    Map<String, TreeSet<String>> cuisinesMap;\\n    \\n    // initialization, O(n + nlogn) -> worst case O(nlogn), there is only 1 cuisine\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        // initialization for two maps\\n        for(int i = 0; i < foods.length; i++){\\n            foodMap.put(foods[i], new Pair(cuisines[i], ratings[i]));\\n            // new cuisine\\n            if(!cuisinesMap.containsKey(cuisines[i])){\\n                // a,b are food names\\n                cuisinesMap.put(cuisines[i], new TreeSet<>((a,b) -> {\\n                    Pair<String, Integer> food1 = foodMap.get(a);\\n                    Pair<String, Integer> food2 = foodMap.get(b);\\n                    // ratings are equal, compare lexicographical food name\\n                    // Integer is object class, use euqlas instead of ==\\n                    if(food1.getValue().equals(food2.getValue())) return a.compareTo(b);\\n                    else return food2.getValue() - food1.getValue();\\n                }));\\n            }\\n            cuisinesMap.get(cuisines[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    // O(logn) -> worst case, there is only 1 cuisine\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodMap.get(food).getKey();\\n        // update order in TreeSet, according to the lesson ->\\n        // we need to remove food from set first, then update rating in the foodmap\\n        // Otherwise, the compareTo() method won\\'t find the same object(returns 0) in set.remove()\\n        // thus we add duplicates to this set\\n        TreeSet<String> set = cuisinesMap.get(cuisine);\\n        // remove old data\\n        set.remove(food);\\n        \\n        // update rating\\n        foodMap.put(food, new Pair(cuisine, newRating));\\n        set.add(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n    // Lesson1, TreeSet && TreeMap don\\'t use hashcode() and equal() to avoid duplicates\\n    // they only use compare() method of Comparator interface OR compareTo() method of Comparable interface to avoid duplicates\\n    // For example, when we call set.remove(\"ABC\"), if set find there exist another elements that compareTo(\"ABC\") returns 0\\n    // -> set will consider these two elements are equal(duplicates)\\n    \\n    // Lesson2, there exists some food with same rating, and we need to return the item with the lexicographically smaller name\\n    // the rating in Map is Integer(which is an object), we need to use equals() instead of \"==\" to check this condition\\n    \\n    \\n    // food name - (cursine name - rating)\\n    Map<String, Pair<String, Integer>> foodMap;\\n    // cuisine - food name\\n    Map<String, TreeSet<String>> cuisinesMap;\\n    \\n    // initialization, O(n + nlogn) -> worst case O(nlogn), there is only 1 cuisine\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        // initialization for two maps\\n        for(int i = 0; i < foods.length; i++){\\n            foodMap.put(foods[i], new Pair(cuisines[i], ratings[i]));\\n            // new cuisine\\n            if(!cuisinesMap.containsKey(cuisines[i])){\\n                // a,b are food names\\n                cuisinesMap.put(cuisines[i], new TreeSet<>((a,b) -> {\\n                    Pair<String, Integer> food1 = foodMap.get(a);\\n                    Pair<String, Integer> food2 = foodMap.get(b);\\n                    // ratings are equal, compare lexicographical food name\\n                    // Integer is object class, use euqlas instead of ==\\n                    if(food1.getValue().equals(food2.getValue())) return a.compareTo(b);\\n                    else return food2.getValue() - food1.getValue();\\n                }));\\n            }\\n            cuisinesMap.get(cuisines[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    // O(logn) -> worst case, there is only 1 cuisine\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodMap.get(food).getKey();\\n        // update order in TreeSet, according to the lesson ->\\n        // we need to remove food from set first, then update rating in the foodmap\\n        // Otherwise, the compareTo() method won\\'t find the same object(returns 0) in set.remove()\\n        // thus we add duplicates to this set\\n        TreeSet<String> set = cuisinesMap.get(cuisine);\\n        // remove old data\\n        set.remove(food);\\n        \\n        // update rating\\n        foodMap.put(food, new Pair(cuisine, newRating));\\n        set.add(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363381,
                "title": "2-simple-c-solution-maps",
                "content": "**1. Using 3 Maps**\\n```\\nstruct comp{\\n    bool operator()(const pair<string,int> &a,const pair<string,int> &b)const{\\n        if(a.second == b.second)\\n            return a.first < b.first;\\n        return a.second > b.second;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map <string,set<pair<string,int>,comp>> highestR;\\n    unordered_map <string,string> foodTocuisine;\\n    unordered_map <string,int> foodTorating;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            highestR[cuisines[i]].insert({foods[i],ratings[i]});\\n            foodTocuisine[foods[i]] = cuisines[i];\\n            foodTorating[foods[i]] = ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string tmpcui = foodTocuisine[food]; \\n        highestR[tmpcui].erase({food,foodTorating[food]});\\n        highestR[tmpcui].insert({food,newRating});\\n        foodTorating[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return highestR[cuisine].begin()->first;\\n    }\\n};\\n```\\n\\n**2. Using 2 Maps**\\n```\\nstruct comp{\\n    bool operator()(const pair<string,int> &a,const pair<string,int> &b)const{\\n        if(a.second == b.second)\\n            return a.first < b.first;\\n        return a.second > b.second;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map <string,set<pair<string,int>,comp>> highestR;\\n    unordered_map <string,pair<string,int>> foodTocuisineRating;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            highestR[cuisines[i]].insert({foods[i],ratings[i]});\\n            foodTocuisineRating[foods[i]] = {cuisines[i],ratings[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto tmp = foodTocuisineRating[food]; \\n        highestR[tmp.first].erase({food,tmp.second});\\n        highestR[tmp.first].insert({food,newRating});\\n        foodTocuisineRating[food] = {tmp.first,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return highestR[cuisine].begin()->first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nstruct comp{\\n    bool operator()(const pair<string,int> &a,const pair<string,int> &b)const{\\n        if(a.second == b.second)\\n            return a.first < b.first;\\n        return a.second > b.second;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map <string,set<pair<string,int>,comp>> highestR;\\n    unordered_map <string,string> foodTocuisine;\\n    unordered_map <string,int> foodTorating;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            highestR[cuisines[i]].insert({foods[i],ratings[i]});\\n            foodTocuisine[foods[i]] = cuisines[i];\\n            foodTorating[foods[i]] = ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string tmpcui = foodTocuisine[food]; \\n        highestR[tmpcui].erase({food,foodTorating[food]});\\n        highestR[tmpcui].insert({food,newRating});\\n        foodTorating[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return highestR[cuisine].begin()->first;\\n    }\\n};\\n```\n```\\nstruct comp{\\n    bool operator()(const pair<string,int> &a,const pair<string,int> &b)const{\\n        if(a.second == b.second)\\n            return a.first < b.first;\\n        return a.second > b.second;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map <string,set<pair<string,int>,comp>> highestR;\\n    unordered_map <string,pair<string,int>> foodTocuisineRating;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            highestR[cuisines[i]].insert({foods[i],ratings[i]});\\n            foodTocuisineRating[foods[i]] = {cuisines[i],ratings[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto tmp = foodTocuisineRating[food]; \\n        highestR[tmp.first].erase({food,tmp.second});\\n        highestR[tmp.first].insert({food,newRating});\\n        foodTocuisineRating[food] = {tmp.first,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return highestR[cuisine].begin()->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362151,
                "title": "python-maps-and-heaps",
                "content": "```python\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        cmap, nmap, tmap = defaultdict(list), {}, {}\\n        for i in range(len(cuisines)):\\n            heappush(cmap[cuisines[i]], (-ratings[i], foods[i]))\\n            nmap[foods[i]], tmap[foods[i]] = ratings[i], cuisines[i]\\n        self.cmap, self.nmap, self.tmap = cmap, nmap, tmap\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        heappush(self.cmap[self.tmap[food]], (-newRating, food))\\n        self.nmap[food] = newRating\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.nmap[self.cmap[cuisine][0][1]] != -self.cmap[cuisine][0][0]:\\n            heappop(self.cmap[cuisine])\\n        return self.cmap[cuisine][0][1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        cmap, nmap, tmap = defaultdict(list), {}, {}\\n        for i in range(len(cuisines)):\\n            heappush(cmap[cuisines[i]], (-ratings[i], foods[i]))\\n            nmap[foods[i]], tmap[foods[i]] = ratings[i], cuisines[i]\\n        self.cmap, self.nmap, self.tmap = cmap, nmap, tmap\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        heappush(self.cmap[self.tmap[food]], (-newRating, food))\\n        self.nmap[food] = newRating\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.nmap[self.cmap[cuisine][0][1]] != -self.cmap[cuisine][0][0]:\\n            heappop(self.cmap[cuisine])\\n        return self.cmap[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358332,
                "title": "c-3-maps-set-custom-cmp",
                "content": "```\\n struct cmp{\\n      bool operator()(const pair<int,string>&a, const pair<int,string>&b)const{\\n          if(a.first==b.first){\\n              return a.second<b.second;\\n          }else{\\n              return a.first>b.first;\\n          }\\n      }  \\n    };\\n    unordered_map<string,set<pair<int,string>,cmp>>CTF;\\n    unordered_map<string,string>FTC;\\n    unordered_map<string,int>FTR;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            FTR[foods[i]]=ratings[i];\\n            FTC[foods[i]]=cuisines[i];\\n            CTF[cuisines[i]].insert({ratings[i],foods[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cui=FTC[food];\\n        int r=FTR[food];\\n        CTF[cui].erase({r,food});\\n        CTF[cui].insert({newRating,food});\\n        FTR[food]=newRating;\\n          \\n    }\\n    \\n    string highestRated(string cuisine) {\\n        for(auto it:CTF[cuisine]){\\n            return it.second;\\n        }\\n        return \"\";\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n struct cmp{\\n      bool operator()(const pair<int,string>&a, const pair<int,string>&b)const{\\n          if(a.first==b.first){\\n              return a.second<b.second;\\n          }else{\\n              return a.first>b.first;\\n          }\\n      }  \\n    };\\n    unordered_map<string,set<pair<int,string>,cmp>>CTF;\\n    unordered_map<string,string>FTC;\\n    unordered_map<string,int>FTR;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            FTR[foods[i]]=ratings[i];\\n            FTC[foods[i]]=cuisines[i];\\n            CTF[cuisines[i]].insert({ratings[i],foods[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cui=FTC[food];\\n        int r=FTR[food];\\n        CTF[cui].erase({r,food});\\n        CTF[cui].insert({newRating,food});\\n        FTR[food]=newRating;\\n          \\n    }\\n    \\n    string highestRated(string cuisine) {\\n        for(auto it:CTF[cuisine]){\\n            return it.second;\\n        }\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2345127,
                "title": "java-3-maps-solution",
                "content": "```\\nclass FoodRatings {\\n    \\n    private class Food {\\n        private String food;\\n        private String cuisine;\\n        private int rating;\\n        \\n        Food(String food, String cuisine, int rating) {\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    \\n    private final Map<String, TreeSet<Food>> cuisineFood;\\n    private final Map<String, Food> foodRating;\\n    private final Map<String, String> foodCuisine;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        final int n = foods.length;\\n        cuisineFood = new HashMap<>();\\n        foodRating = new HashMap<>();\\n        foodCuisine = new HashMap<>();\\n        \\n        for (int i=0; i<n; i++) {\\n            final String food = foods[i];\\n            final String cuisine = cuisines[i];\\n            final int rating = ratings[i];\\n            \\n            final Food f = new Food(food, cuisine, rating);\\n            final TreeSet<Food> set = cuisineFood.computeIfAbsent(cuisine, c -> new TreeSet<>((f1, f2) -> {\\n                int diff = f2.rating - f1.rating;\\n                if (diff != 0) return diff;\\n                return f1.food.compareTo(f2.food);\\n            }));\\n            set.add(f);\\n            foodRating.put(food, f);\\n            foodCuisine.put(food, cuisine);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food f = foodRating.get(food);\\n        String cuisine = foodCuisine.get(food);\\n        TreeSet<Food> set = cuisineFood.get(cuisine);\\n        \\n        set.remove(f);\\n        f.rating = newRating;\\n        set.add(f);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineFood.get(cuisine).first().food;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\n    \\n    private class Food {\\n        private String food;\\n        private String cuisine;\\n        private int rating;\\n        \\n        Food(String food, String cuisine, int rating) {\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    \\n    private final Map<String, TreeSet<Food>> cuisineFood;\\n    private final Map<String, Food> foodRating;\\n    private final Map<String, String> foodCuisine;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        final int n = foods.length;\\n        cuisineFood = new HashMap<>();\\n        foodRating = new HashMap<>();\\n        foodCuisine = new HashMap<>();\\n        \\n        for (int i=0; i<n; i++) {\\n            final String food = foods[i];\\n            final String cuisine = cuisines[i];\\n            final int rating = ratings[i];\\n            \\n            final Food f = new Food(food, cuisine, rating);\\n            final TreeSet<Food> set = cuisineFood.computeIfAbsent(cuisine, c -> new TreeSet<>((f1, f2) -> {\\n                int diff = f2.rating - f1.rating;\\n                if (diff != 0) return diff;\\n                return f1.food.compareTo(f2.food);\\n            }));\\n            set.add(f);\\n            foodRating.put(food, f);\\n            foodCuisine.put(food, cuisine);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food f = foodRating.get(food);\\n        String cuisine = foodCuisine.get(food);\\n        TreeSet<Food> set = cuisineFood.get(cuisine);\\n        \\n        set.remove(f);\\n        f.rating = newRating;\\n        set.add(f);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineFood.get(cuisine).first().food;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2341407,
                "title": "python-heap-easy-code",
                "content": "```\\nfrom collections import defaultdict\\nfrom heapq import heappush, heappop\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_cuisine = defaultdict(str)\\n        self.food_rating = defaultdict(int)\\n        for i, f in enumerate(foods):\\n            self.food_cuisine[f] = cuisines[i]\\n            self.food_rating[f] = ratings[i]\\n        self.cuisines_heap = defaultdict(list)\\n        for i, c in enumerate(cuisines):\\n            heappush(self.cuisines_heap[c], (-ratings[i],foods[i]))\\n            \\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_rating[food] = newRating\\n        heappush(self.cuisines_heap[self.food_cuisine[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.cuisines_heap[cuisine] and self.food_rating[self.cuisines_heap[cuisine][0][1]] != -self.cuisines_heap[cuisine][0][0]:\\n            heappop(self.cuisines_heap[cuisine])\\n        return self.cuisines_heap[cuisine][0][1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom heapq import heappush, heappop\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_cuisine = defaultdict(str)\\n        self.food_rating = defaultdict(int)\\n        for i, f in enumerate(foods):\\n            self.food_cuisine[f] = cuisines[i]\\n            self.food_rating[f] = ratings[i]\\n        self.cuisines_heap = defaultdict(list)\\n        for i, c in enumerate(cuisines):\\n            heappush(self.cuisines_heap[c], (-ratings[i],foods[i]))\\n            \\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_rating[food] = newRating\\n        heappush(self.cuisines_heap[self.food_cuisine[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.cuisines_heap[cuisine] and self.food_rating[self.cuisines_heap[cuisine][0][1]] != -self.cuisines_heap[cuisine][0][0]:\\n            heappop(self.cuisines_heap[cuisine])\\n        return self.cuisines_heap[cuisine][0][1]",
                "codeTag": "Java"
            },
            {
                "id": 2340226,
                "title": "using-sortedset",
                "content": "![image](https://assets.leetcode.com/users/images/fec04c07-4b8f-49d2-a48d-d04500970084_1658911623.1543102.png)\\n```\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedSet\\n\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str],\\n                 ratings: List[int]):\\n        self.f_dict = dict()\\n        self.c_dict = defaultdict(SortedSet)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.f_dict[f] = [-r, c]\\n            self.c_dict[c].add((-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        current_rating, current_cuisine = self.f_dict[food]\\n        self.f_dict[food][0] = -newRating\\n        self.c_dict[current_cuisine].remove((current_rating, food))\\n        self.c_dict[current_cuisine].add((-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.c_dict[cuisine][0][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedSet\\n\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str],\\n                 ratings: List[int]):\\n        self.f_dict = dict()\\n        self.c_dict = defaultdict(SortedSet)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.f_dict[f] = [-r, c]\\n            self.c_dict[c].add((-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        current_rating, current_cuisine = self.f_dict[food]\\n        self.f_dict[food][0] = -newRating\\n        self.c_dict[current_cuisine].remove((current_rating, food))\\n        self.c_dict[current_cuisine].add((-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.c_dict[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337961,
                "title": "python-simple-hashmap",
                "content": "\\n\\tfrom sortedcontainers import SortedList\\n\\n\\n    def __init__(self, foods, cuisines, ratings):\\n        self.dict1 = defaultdict(SortedList)\\n        self.dict2 = defaultdict(int)\\n        self.dict3 = defaultdict(int)\\n        \\n        for i in range(len(cuisines)):\\n            self.dict1[cuisines[i]].add((-ratings[i], foods[i]))\\n            self.dict2[foods[i]] = ratings[i]\\n            self.dict3[foods[i]] = cuisines[i]\\n            \\n    def changeRating(self, food, newRating):\\n        oldRating = self.dict2[food]\\n        cuisine = self.dict3[food]\\n        \\n        self.dict1[cuisine].discard((-oldRating, food))\\n        self.dict1[cuisine].add((-newRating, food))\\n        self.dict2[food] = newRating\\n        \\n    def highestRated(self, cuisine):\\n        return self.dict1[cuisine][0][1]",
                "solutionTags": [],
                "code": "\\n\\tfrom sortedcontainers import SortedList\\n\\n\\n    def __init__(self, foods, cuisines, ratings):\\n        self.dict1 = defaultdict(SortedList)\\n        self.dict2 = defaultdict(int)\\n        self.dict3 = defaultdict(int)\\n        \\n        for i in range(len(cuisines)):\\n            self.dict1[cuisines[i]].add((-ratings[i], foods[i]))\\n            self.dict2[foods[i]] = ratings[i]\\n            self.dict3[foods[i]] = cuisines[i]\\n            \\n    def changeRating(self, food, newRating):\\n        oldRating = self.dict2[food]\\n        cuisine = self.dict3[food]\\n        \\n        self.dict1[cuisine].discard((-oldRating, food))\\n        self.dict1[cuisine].add((-newRating, food))\\n        self.dict2[food] = newRating\\n        \\n    def highestRated(self, cuisine):\\n        return self.dict1[cuisine][0][1]",
                "codeTag": "Python3"
            },
            {
                "id": 2330091,
                "title": "c-solution-hashmap-explained",
                "content": "**Method:**\\n\\n* we will use 3 maps\\n* ```one map to store the {rating,food} pair for a particular cuisine = mp```\\n* ```one map to get the rating of a particular food = cs```\\n* ```one map to get the cuisine of a particular food = rt```\\n* as in the highest rated function we will want the highest rated food of that cuisine so we will use ordered_set so that ```{rating,food}``` pair will get stored in sorted order \\n* now the ordered_set stores it in increasing order of the rating so we will store ```{-rating,food}``` pair so that in the sorted order(increasing) we will get the pair with highest rating at first place\\n* ```For the changeRating operation```\\n\\t* we first get the cuisine and current rating for the food.\\n\\t* Then, we remove the old food rating from cuisine_ratings, and add the new one.\\n\\n**Code:**\\n\\n```\\nclass FoodRatings\\n{\\npublic:\\n    typedef pair<int, string> pi;\\n    unordered_map<string, set<pi>> mp;\\n    unordered_map<string, string> cs;\\n    unordered_map<string, int> rt;\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector<int> &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[cuisines[i]].insert({-ratings[i], foods[i]});\\n            cs[foods[i]] = cuisines[i];\\n            rt[foods[i]] = -ratings[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        string c = cs[food];\\n        int r = rt[food];\\n        mp[c].erase({r, food});\\n        mp[c].insert({-newRating, food});\\n        rt[food] = -newRating;\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        auto p = begin(mp[cuisine]);\\n        return p->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```one map to store the {rating,food} pair for a particular cuisine = mp```\n```one map to get the rating of a particular food = cs```\n```one map to get the cuisine of a particular food = rt```\n```{rating,food}```\n```{-rating,food}```\n```For the changeRating operation```\n```\\nclass FoodRatings\\n{\\npublic:\\n    typedef pair<int, string> pi;\\n    unordered_map<string, set<pi>> mp;\\n    unordered_map<string, string> cs;\\n    unordered_map<string, int> rt;\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector<int> &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[cuisines[i]].insert({-ratings[i], foods[i]});\\n            cs[foods[i]] = cuisines[i];\\n            rt[foods[i]] = -ratings[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        string c = cs[food];\\n        int r = rt[food];\\n        mp[c].erase({r, food});\\n        mp[c].insert({-newRating, food});\\n        rt[food] = -newRating;\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        auto p = begin(mp[cuisine]);\\n        return p->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329980,
                "title": "clean-solution-with-hash-map-and-tree-set",
                "content": "Similar question:\\nhttps://leetcode.com/problems/design-a-number-container-system/discuss/2326616/concise-solution-with-tree-set-and-explanation\\n```\\nclass FoodRatings {\\n\\n    Map<String, TreeSet<Food>> cuisineMap = new HashMap<String, TreeSet<Food>>();\\n    Map<String, Food> foodMap = new HashMap<String, Food>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n = foods.length;\\n        for(int i=0; i<n; i++) {\\n            String name = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            Food item = new Food(name, cuisine, rating);\\n            cuisineMap.putIfAbsent(cuisine, new TreeSet<Food> \\n                ((a,b) -> a.rating == b.rating ? a.name.compareTo(b.name) : b.rating - a.rating)\\n            );\\n            cuisineMap.get(cuisine).add(item);\\n            foodMap.put(name, item);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food item = foodMap.get(food);\\n        String cuisine = item.cuisine;\\n        cuisineMap.get(cuisine).remove(item);\\n        \\n        item.rating = newRating;\\n        foodMap.put(food, item);\\n        cuisineMap.get(cuisine).add(item);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).first().name;\\n    }\\n}\\n\\nclass Food {\\n    String name;\\n    String cuisine;\\n    int rating;\\n    \\n    Food(String name, String cuisine, int rating){\\n        this.name = name; this.rating = rating; this.cuisine = cuisine;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    Map<String, TreeSet<Food>> cuisineMap = new HashMap<String, TreeSet<Food>>();\\n    Map<String, Food> foodMap = new HashMap<String, Food>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n = foods.length;\\n        for(int i=0; i<n; i++) {\\n            String name = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            Food item = new Food(name, cuisine, rating);\\n            cuisineMap.putIfAbsent(cuisine, new TreeSet<Food> \\n                ((a,b) -> a.rating == b.rating ? a.name.compareTo(b.name) : b.rating - a.rating)\\n            );\\n            cuisineMap.get(cuisine).add(item);\\n            foodMap.put(name, item);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food item = foodMap.get(food);\\n        String cuisine = item.cuisine;\\n        cuisineMap.get(cuisine).remove(item);\\n        \\n        item.rating = newRating;\\n        foodMap.put(food, item);\\n        cuisineMap.get(cuisine).add(item);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).first().name;\\n    }\\n}\\n\\nclass Food {\\n    String name;\\n    String cuisine;\\n    int rating;\\n    \\n    Food(String name, String cuisine, int rating){\\n        this.name = name; this.rating = rating; this.cuisine = cuisine;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328993,
                "title": "java-solution-using-two-hashmaps-and-priorityqueue",
                "content": "```java\\nclass FoodRatings {\\n    Map<String, PriorityQueue<FoodCuisineRating>> cuisineMap;\\n    Map<String, FoodCuisineRating> foodMap;\\n    int n;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineMap = new HashMap<>();\\n        foodMap = new HashMap<>();\\n        n = foods.length;\\n        for(int i = 0; i < n; i++) {\\n            FoodCuisineRating fcr = new FoodCuisineRating(foods[i], cuisines[i], ratings[i]);\\n            cuisineMap.putIfAbsent(cuisines[i], new PriorityQueue<>((a, b) -> a.rating == b.rating ? a.food.compareTo(b.food) : b.rating - a.rating));\\n            PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(cuisines[i]);\\n            maxHeap.offer(fcr);\\n            foodMap.put(foods[i], fcr);\\n        }\\n    }\\n    public void changeRating(String food, int newRating) {\\n        FoodCuisineRating fcr = foodMap.get(food);\\n        PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(fcr.cuisine);\\n        maxHeap.remove(fcr);\\n        fcr.rating = newRating;\\n        maxHeap.offer(fcr);\\n    }\\n    public String highestRated(String cuisine) {\\n        PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(cuisine);\\n        FoodCuisineRating fcr = maxHeap.peek();\\n        String highestRatedFood = fcr.food;\\n        return highestRatedFood;\\n    }\\n    class FoodCuisineRating {\\n        String food;\\n        String cuisine;\\n        int rating;\\n        public FoodCuisineRating(String food, String cuisine, int rating) {\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n/*\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass FoodRatings {\\n    Map<String, PriorityQueue<FoodCuisineRating>> cuisineMap;\\n    Map<String, FoodCuisineRating> foodMap;\\n    int n;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineMap = new HashMap<>();\\n        foodMap = new HashMap<>();\\n        n = foods.length;\\n        for(int i = 0; i < n; i++) {\\n            FoodCuisineRating fcr = new FoodCuisineRating(foods[i], cuisines[i], ratings[i]);\\n            cuisineMap.putIfAbsent(cuisines[i], new PriorityQueue<>((a, b) -> a.rating == b.rating ? a.food.compareTo(b.food) : b.rating - a.rating));\\n            PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(cuisines[i]);\\n            maxHeap.offer(fcr);\\n            foodMap.put(foods[i], fcr);\\n        }\\n    }\\n    public void changeRating(String food, int newRating) {\\n        FoodCuisineRating fcr = foodMap.get(food);\\n        PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(fcr.cuisine);\\n        maxHeap.remove(fcr);\\n        fcr.rating = newRating;\\n        maxHeap.offer(fcr);\\n    }\\n    public String highestRated(String cuisine) {\\n        PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(cuisine);\\n        FoodCuisineRating fcr = maxHeap.peek();\\n        String highestRatedFood = fcr.food;\\n        return highestRatedFood;\\n    }\\n    class FoodCuisineRating {\\n        String food;\\n        String cuisine;\\n        int rating;\\n        public FoodCuisineRating(String food, String cuisine, int rating) {\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n/*\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2327644,
                "title": "c-easy-solution-3-maps",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nstruct node {\\n    bool operator()(const pair<int, string> &a, const pair<int, string> &b) const { \\n        if(a.first==b.first) return a.second>b.second;\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\nprivate:\\n    map<string, string> cui;\\n    map<string, set<pair<int, string>, node>> mp;\\n    map<string, int> rate;\\n    \\npublic:\\n\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0; i<n; i++){\\n            rate[foods[i]]=ratings[i];\\n            mp[cuisines[i]].insert({ratings[i], foods[i]});\\n            cui[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        mp[cui[food]].erase({rate[food], food});\\n        mp[cui[food]].insert({newRating, food});\\n        rate[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--mp[cuisine].end()).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstruct node {\\n    bool operator()(const pair<int, string> &a, const pair<int, string> &b) const { \\n        if(a.first==b.first) return a.second>b.second;\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\nprivate:\\n    map<string, string> cui;\\n    map<string, set<pair<int, string>, node>> mp;\\n    map<string, int> rate;\\n    \\npublic:\\n\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0; i<n; i++){\\n            rate[foods[i]]=ratings[i];\\n            mp[cuisines[i]].insert({ratings[i], foods[i]});\\n            cui[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        mp[cui[food]].erase({rate[food], food});\\n        mp[cui[food]].insert({newRating, food});\\n        rate[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--mp[cuisine].end()).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326993,
                "title": "c-fully-explained-commented-set-2-map-good-application-of-map-data-structure",
                "content": "```\\n  map< string  , map< int , set< string> , greater<int> >> mp;\\n  \\n  // this above map has cuisine as key , then its inside there is another \\n  \\n  // map which stores rating as key & Stores Different foods for a particular rating in set \\n  \\n  // in lexographically order , smaller first\\n    \\n    unordered_map< string , pair< int , string> > mp1;\\n\\t\\n\\t// This map stores food as key & in the pair , it has rating & cuisine .\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            mp1[foods[i]]={r[i] , c[i]};\\n        }\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            mp[c[i]][r[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n\\t\\n\\t// For change of the  rating for a given food\\n\\t\\n\\t// Find the cuisine of that food & old rating in map mp1\\n\\t\\n\\t// Now we have to update the new rating , what we will do \\n\\t\\n\\t// for a old rating we will find the iterator in the map<int , set<string > , greater<int>> \\n\\t\\n\\t// embedded in the map , to check that food is present in the given old rating map inside it \\n\\t\\n\\t// if present remove that food from there , if there is no food for that rating , erase that old rating\\n\\t\\n\\t// Now insert the new rating with that food \\n\\t\\n\\t// Also update new rating with food in the map mp1 , as rating is changed for food\\n\\t\\n\\t\\n\\t\\n\\t\\n    \\n    void changeRating(string food, int rating) {\\n        // rating change \\n        \\n        string cu=mp1[food].second;\\n        \\n        int curr_rating=mp1[food].first;\\n        \\n         auto it=mp[cu][curr_rating].find(food);\\n        \\n         mp[cu][curr_rating].erase(it);\\n        \\n         if(mp[cu][curr_rating].size()==0)\\n         {\\n             mp[cu].erase(curr_rating);\\n         }\\n         \\n         mp[cu][rating].insert(food);\\n         \\n        mp1[food]={rating , cu};\\n        \\n    }\\n\\t\\n\\t// Highest rating will be that element which will be first in the \\n    \\n\\t// set of rating map of cuisine map -> named mp\\n\\t\\n    string highestRated(string cu) {\\n        if(mp.find(cu)!=mp.end())\\n        {\\n           auto it= mp[cu].begin();\\n            \\n            string ans=*it->second.begin();\\n            \\n            return ans;\\n        }\\n        \\n        return \"\";\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n  map< string  , map< int , set< string> , greater<int> >> mp;\\n  \\n  // this above map has cuisine as key , then its inside there is another \\n  \\n  // map which stores rating as key & Stores Different foods for a particular rating in set \\n  \\n  // in lexographically order , smaller first\\n    \\n    unordered_map< string , pair< int , string> > mp1;\\n\\t\\n\\t// This map stores food as key & in the pair , it has rating & cuisine .\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            mp1[foods[i]]={r[i] , c[i]};\\n        }\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            mp[c[i]][r[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n\\t\\n\\t// For change of the  rating for a given food\\n\\t\\n\\t// Find the cuisine of that food & old rating in map mp1\\n\\t\\n\\t// Now we have to update the new rating , what we will do \\n\\t\\n\\t// for a old rating we will find the iterator in the map<int , set<string > , greater<int>> \\n\\t\\n\\t// embedded in the map , to check that food is present in the given old rating map inside it \\n\\t\\n\\t// if present remove that food from there , if there is no food for that rating , erase that old rating\\n\\t\\n\\t// Now insert the new rating with that food \\n\\t\\n\\t// Also update new rating with food in the map mp1 , as rating is changed for food\\n\\t\\n\\t\\n\\t\\n\\t\\n    \\n    void changeRating(string food, int rating) {\\n        // rating change \\n        \\n        string cu=mp1[food].second;\\n        \\n        int curr_rating=mp1[food].first;\\n        \\n         auto it=mp[cu][curr_rating].find(food);\\n        \\n         mp[cu][curr_rating].erase(it);\\n        \\n         if(mp[cu][curr_rating].size()==0)\\n         {\\n             mp[cu].erase(curr_rating);\\n         }\\n         \\n         mp[cu][rating].insert(food);\\n         \\n        mp1[food]={rating , cu};\\n        \\n    }\\n\\t\\n\\t// Highest rating will be that element which will be first in the \\n    \\n\\t// set of rating map of cuisine map -> named mp\\n\\t\\n    string highestRated(string cu) {\\n        if(mp.find(cu)!=mp.end())\\n        {\\n           auto it= mp[cu].begin();\\n            \\n            string ans=*it->second.begin();\\n            \\n            return ans;\\n        }\\n        \\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326329,
                "title": "easy-c-2-maps-only-using-custom-comparator-of-set-new-for-begineers",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    \\n    struct compare\\n    {\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b) const\\n        { \\n          if(a.first == b.first)\\n             return a.second < b.second;\\n          else return a.first > b.first;\\n        }\\n    };\\n    \\n    int n;\\n    unordered_map<string, pair<string,int>>fc; // Distinct food, {cuisine, rating}       \\n    unordered_map<string, set<pair<int,string>, compare>>crf; // cuisine--->list{rating, food}\\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) \\n    {\\n        n=f.size();\\n        for(int i=0;i<n;i++){\\n            fc[f[i]] = {c[i],r[i]};\\n            crf[c[i]].insert({r[i], f[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        \\n        string cuisine = fc[food].first;\\n        int oldRating = fc[food].second;\\n        \\n        crf[cuisine].erase({oldRating, food});\\n        crf[cuisine].insert({newRating,food});\\n        fc[food] = {cuisine, newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        pair<int, string> p = *(crf[cuisine].begin());\\n        return p.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    \\n    struct compare\\n    {\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b) const\\n        { \\n          if(a.first == b.first)\\n             return a.second < b.second;\\n          else return a.first > b.first;\\n        }\\n    };\\n    \\n    int n;\\n    unordered_map<string, pair<string,int>>fc; // Distinct food, {cuisine, rating}       \\n    unordered_map<string, set<pair<int,string>, compare>>crf; // cuisine--->list{rating, food}\\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) \\n    {\\n        n=f.size();\\n        for(int i=0;i<n;i++){\\n            fc[f[i]] = {c[i],r[i]};\\n            crf[c[i]].insert({r[i], f[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        \\n        string cuisine = fc[food].first;\\n        int oldRating = fc[food].second;\\n        \\n        crf[cuisine].erase({oldRating, food});\\n        crf[cuisine].insert({newRating,food});\\n        fc[food] = {cuisine, newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        pair<int, string> p = *(crf[cuisine].begin());\\n        return p.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326281,
                "title": "two-maps-and-priority-queue-nlogn-tc",
                "content": "```\\nclass restu{\\n    String f,c;\\n    int r;\\n    public restu(String fo,String cu,int ra){\\n        f=fo;\\n        c=cu;\\n        r=ra;\\n    }\\n}\\n\\nclass The_Comparator implements Comparator<restu> {\\n    public int compare(restu ob1, restu ob2)  {\\n        return ob2.r==ob1.r?ob1.f.compareTo(ob2.f):ob2.r-ob1.r;\\n    }\\n}\\n\\nclass FoodRatings {\\n    HashMap<String,restu> map;\\n    HashMap<String,PriorityQueue<restu>> maq;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<String,restu>();\\n        maq = new HashMap<String,PriorityQueue<restu>>();\\n        int len=foods.length,i;\\n        for(i=0;i<len;i++){\\n            restu ob = new restu(foods[i],cuisines[i],ratings[i]);\\n            map.put(foods[i],ob);\\n            PriorityQueue<restu> q = maq.getOrDefault(cuisines[i],new PriorityQueue<restu>(new The_Comparator()));\\n            q.add(ob);\\n            maq.put(cuisines[i],q);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        restu ob = map.get(food);\\n        PriorityQueue<restu> pq = maq.get(ob.c);\\n        pq.remove(ob);\\n        ob.r=newRating;\\n        pq.add(ob);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return maq.get(cuisine).peek().f;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass restu{\\n    String f,c;\\n    int r;\\n    public restu(String fo,String cu,int ra){\\n        f=fo;\\n        c=cu;\\n        r=ra;\\n    }\\n}\\n\\nclass The_Comparator implements Comparator<restu> {\\n    public int compare(restu ob1, restu ob2)  {\\n        return ob2.r==ob1.r?ob1.f.compareTo(ob2.f):ob2.r-ob1.r;\\n    }\\n}\\n\\nclass FoodRatings {\\n    HashMap<String,restu> map;\\n    HashMap<String,PriorityQueue<restu>> maq;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<String,restu>();\\n        maq = new HashMap<String,PriorityQueue<restu>>();\\n        int len=foods.length,i;\\n        for(i=0;i<len;i++){\\n            restu ob = new restu(foods[i],cuisines[i],ratings[i]);\\n            map.put(foods[i],ob);\\n            PriorityQueue<restu> q = maq.getOrDefault(cuisines[i],new PriorityQueue<restu>(new The_Comparator()));\\n            q.add(ob);\\n            maq.put(cuisines[i],q);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        restu ob = map.get(food);\\n        PriorityQueue<restu> pq = maq.get(ob.c);\\n        pq.remove(ob);\\n        ob.r=newRating;\\n        pq.add(ob);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return maq.get(cuisine).peek().f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326073,
                "title": "no-tle-with-priorityqueue-in-java",
                "content": "```\\nclass FoodRatings {\\n\\n    Map<String, PriorityQueue<Object[]>> map = new HashMap<>(); // two size array in pq, index 0 is rating, index 1 is name\\n    Map<String, Integer> foodRating = new HashMap<>(); // put latest rating here\\n    Map<String, String> foodCuisine = new HashMap<>(); // food cuisine map\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for (int i = 0; i < foods.length; i++) {\\n            foodCuisine.put(foods[i], cuisines[i]);\\n            \\n            map.putIfAbsent(cuisines[i], new PriorityQueue<>((a, b) -> {\\n                if (((int)a[1]) != (int)b[1]) {\\n                    return (int)b[1] - (int)a[1]; \\n                }\\n                \\n                return ((String)a[0]).compareTo((String)b[0]);\\n            }));\\n            \\n            PriorityQueue<Object[]> pq = map.get(cuisines[i]);\\n            pq.offer(new Object[] {foods[i], ratings[i]});\\n            \\n            map.put(cuisines[i], pq);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodCuisine.get(food);\\n        foodRating.put(food, newRating);\\n       \\n        PriorityQueue<Object[]> pq = map.get(cuisine);\\n\\t\\t// put the latest rating to pq\\n        pq.offer(new Object[] {food, newRating});\\n\\n        map.put(cuisine, pq);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Object[]> pq = map.get(cuisine);\\n        \\n        String result = null;\\n        \\n        while (!pq.isEmpty()) {\\n\\t\\t\\t// get the top result\\n            Object[] top = pq.peek();\\n            String food = (String)top[0];\\n            int rating = (int)top[1];\\n            \\n            result = food;\\n            \\n\\t\\t\\t// check if we have updated the rating of the food, if the rating is the latest one\\n            if (!foodRating.containsKey(food) || foodRating.get(food) == rating) {\\n                break;\\n            } \\n            pq.poll();\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    Map<String, PriorityQueue<Object[]>> map = new HashMap<>(); // two size array in pq, index 0 is rating, index 1 is name\\n    Map<String, Integer> foodRating = new HashMap<>(); // put latest rating here\\n    Map<String, String> foodCuisine = new HashMap<>(); // food cuisine map\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for (int i = 0; i < foods.length; i++) {\\n            foodCuisine.put(foods[i], cuisines[i]);\\n            \\n            map.putIfAbsent(cuisines[i], new PriorityQueue<>((a, b) -> {\\n                if (((int)a[1]) != (int)b[1]) {\\n                    return (int)b[1] - (int)a[1]; \\n                }\\n                \\n                return ((String)a[0]).compareTo((String)b[0]);\\n            }));\\n            \\n            PriorityQueue<Object[]> pq = map.get(cuisines[i]);\\n            pq.offer(new Object[] {foods[i], ratings[i]});\\n            \\n            map.put(cuisines[i], pq);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodCuisine.get(food);\\n        foodRating.put(food, newRating);\\n       \\n        PriorityQueue<Object[]> pq = map.get(cuisine);\\n\\t\\t// put the latest rating to pq\\n        pq.offer(new Object[] {food, newRating});\\n\\n        map.put(cuisine, pq);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Object[]> pq = map.get(cuisine);\\n        \\n        String result = null;\\n        \\n        while (!pq.isEmpty()) {\\n\\t\\t\\t// get the top result\\n            Object[] top = pq.peek();\\n            String food = (String)top[0];\\n            int rating = (int)top[1];\\n            \\n            result = food;\\n            \\n\\t\\t\\t// check if we have updated the rating of the food, if the rating is the latest one\\n            if (!foodRating.containsKey(food) || foodRating.get(food) == rating) {\\n                break;\\n            } \\n            pq.poll();\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326015,
                "title": "three-unordered-map-easy-solution",
                "content": "class FoodRatings {\\npublic:\\n    \\n    unordered_map<string,set<pair<int,string>>>mp;\\n    unordered_map<string,string> fc;\\n    unordered_map<string,int> fr;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        \\n        mp.clear();\\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].insert({ratings[i],foods[i]});\\n            \\n            fc[foods[i]]= cuisines[i];\\n            fr[foods[i]]= ratings[i];\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        \\n        if(fc.find(food)!=fc.end()){\\n            string cuisine = fc[food];\\n            int rating = fr[food];\\n            if(mp[cuisine].find({rating,food})!=mp[cuisine].end())\\n            mp[cuisine].erase({rating,food});\\n            fr[food] = newRating;\\n         mp[cuisine].insert({newRating,food});\\n        }\\n        \\n         \\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        if(mp[cuisine].size()==0){\\n            return \"\";\\n        }\\n        \\n        auto it =(mp[cuisine].end());\\n        it--;\\n        pair<int,string> temp = *it;\\n        \\n       // cout<< temp.second<<endl;\\n        string ans= temp.second;\\n        \\n        while(it!=mp[cuisine].begin() && it->first == temp.first){\\n          // cout<<it->first<<endl;\\n            ans = it->second;\\n          it--;\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */",
                "solutionTags": [
                    "C"
                ],
                "code": "class FoodRatings {\\npublic:\\n    \\n    unordered_map<string,set<pair<int,string>>>mp;\\n    unordered_map<string,string> fc;\\n    unordered_map<string,int> fr;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        \\n        mp.clear();\\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].insert({ratings[i],foods[i]});\\n            \\n            fc[foods[i]]= cuisines[i];\\n            fr[foods[i]]= ratings[i];\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        \\n        if(fc.find(food)!=fc.end()){\\n            string cuisine = fc[food];\\n            int rating = fr[food];\\n            if(mp[cuisine].find({rating,food})!=mp[cuisine].end())\\n            mp[cuisine].erase({rating,food});\\n            fr[food] = newRating;\\n         mp[cuisine].insert({newRating,food});\\n        }\\n        \\n         \\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        if(mp[cuisine].size()==0){\\n            return \"\";\\n        }\\n        \\n        auto it =(mp[cuisine].end());\\n        it--;\\n        pair<int,string> temp = *it;\\n        \\n       // cout<< temp.second<<endl;\\n        string ans= temp.second;\\n        \\n        while(it!=mp[cuisine].begin() && it->first == temp.first){\\n          // cout<<it->first<<endl;\\n            ans = it->second;\\n          it--;\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */",
                "codeTag": "C++"
            },
            {
                "id": 2325947,
                "title": "c-three-maps-easy-to-understand",
                "content": "\\n```\\nstruct comp{\\n    bool operator()(const pair<int,string> &p, const pair<int,string>&q) const\\n    {\\n        if(p.first == q.first)\\n        {\\n            return p.second > q.second;\\n        }\\n        \\n        return p.first < q.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    map<string,int> r;\\n    map<string,set<pair<int,string>,comp>> m;\\n    map<string,string> c;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for(int i=0;i<n;i++)\\n        {\\n         r[foods[i]] = ratings[i];\\n            m[cuisines[i]].insert({ratings[i],foods[i]});\\n            c[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[c[food]].erase({r[food],food});\\n        m[c[food]].insert({newRating,food});\\n        r[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--m[cuisine].end()).second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```\\n **Upvote if you like the solution**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct comp{\\n    bool operator()(const pair<int,string> &p, const pair<int,string>&q) const\\n    {\\n        if(p.first == q.first)\\n        {\\n            return p.second > q.second;\\n        }\\n        \\n        return p.first < q.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    map<string,int> r;\\n    map<string,set<pair<int,string>,comp>> m;\\n    map<string,string> c;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for(int i=0;i<n;i++)\\n        {\\n         r[foods[i]] = ratings[i];\\n            m[cuisines[i]].insert({ratings[i],foods[i]});\\n            c[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[c[food]].erase({r[food],food});\\n        m[c[food]].insert({newRating,food});\\n        r[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--m[cuisine].end()).second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2325795,
                "title": "three-maps-set-with-custom-comparator-c",
                "content": "```\\nclass FoodRatings {\\n\\t// custom class to store information of the food\\n    class info{\\n        public:\\n            int rating;\\n            string food_name;\\n\\t\\t\\n        info(int r,string s) //constructor\\n        {\\n            rating = r;\\n            food_name=s;\\n        }\\n    };\\n    \\n\\t//custom comparator to maintan ordering in set...\\n    class comp{\\n        public:\\n            bool operator()(info a,info b)const\\n            {\\n                if(a.rating==b.rating)\\n                    return a.food_name<b.food_name;\\n                return a.rating>b.rating;\\n            }\\n    };\\n    \\n    map<string,string> which_cuisine; // mapping food with corresponding cuisine\\n    map<string,set<info,comp>> cuisine_info; // storing food information and mapping it to the corresponding cuisine\\n    map<string,int> curr_r; // a map to store the current rating of the food... \\n    \\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            curr_r[foods[i]]=ratings[i];\\n            which_cuisine[foods[i]]=cuisines[i];\\n            cuisine_info[cuisines[i]].insert(info(ratings[i],foods[i]));\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n\\t\\t//getting the current rating of the food\\n        int old_r=curr_r[food]; \\n        string cuisine = which_cuisine[food];\\n        \\n        cuisine_info[cuisine].erase(cuisine_info[cuisine].find(info(old_r,food))); //removing the food previous rating\\n        cuisine_info[cuisine].insert(info(newRating,food));\\n        curr_r[food]=newRating; //updating the current rating...\\n    }\\n    \\n    string highestRated(string cuisine) {\\n     \\n        info temp = *cuisine_info[cuisine].begin();\\n        return temp.food_name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n\\t// custom class to store information of the food\\n    class info{\\n        public:\\n            int rating;\\n            string food_name;\\n\\t\\t\\n        info(int r,string s) //constructor\\n        {\\n            rating = r;\\n            food_name=s;\\n        }\\n    };\\n    \\n\\t//custom comparator to maintan ordering in set...\\n    class comp{\\n        public:\\n            bool operator()(info a,info b)const\\n            {\\n                if(a.rating==b.rating)\\n                    return a.food_name<b.food_name;\\n                return a.rating>b.rating;\\n            }\\n    };\\n    \\n    map<string,string> which_cuisine; // mapping food with corresponding cuisine\\n    map<string,set<info,comp>> cuisine_info; // storing food information and mapping it to the corresponding cuisine\\n    map<string,int> curr_r; // a map to store the current rating of the food... \\n    \\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            curr_r[foods[i]]=ratings[i];\\n            which_cuisine[foods[i]]=cuisines[i];\\n            cuisine_info[cuisines[i]].insert(info(ratings[i],foods[i]));\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n\\t\\t//getting the current rating of the food\\n        int old_r=curr_r[food]; \\n        string cuisine = which_cuisine[food];\\n        \\n        cuisine_info[cuisine].erase(cuisine_info[cuisine].find(info(old_r,food))); //removing the food previous rating\\n        cuisine_info[cuisine].insert(info(newRating,food));\\n        curr_r[food]=newRating; //updating the current rating...\\n    }\\n    \\n    string highestRated(string cuisine) {\\n     \\n        info temp = *cuisine_info[cuisine].begin();\\n        return temp.food_name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325688,
                "title": "python-3-collections-defaultdict-heapq-priority-queue",
                "content": "Remove outdated ratings when you attempt to query highest rating.\\n\\n```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.foods = {foods[i]:ratings[i] for i in range(n)}\\n        self.cuisines = {foods[i]:cuisines[i] for i in range(n)}\\n        self.cuisine_rating = defaultdict(list)\\n        for i in range(n):\\n            heapq.heappush(self.cuisine_rating[cuisines[i]], (-1 * ratings[i], foods[i]))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.foods[food]=newRating\\n        heapq.heappush(self.cuisine_rating[self.cuisines[food]], (-1 * newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while  self.cuisine_rating[cuisine]:\\n            if -1 * self.cuisine_rating[cuisine][0][0] == self.foods[self.cuisine_rating[cuisine][0][1]]:\\n                return self.cuisine_rating[cuisine][0][1]\\n            else:\\n                heapq.heappop(self.cuisine_rating[cuisine])\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.foods = {foods[i]:ratings[i] for i in range(n)}\\n        self.cuisines = {foods[i]:cuisines[i] for i in range(n)}\\n        self.cuisine_rating = defaultdict(list)\\n        for i in range(n):\\n            heapq.heappush(self.cuisine_rating[cuisines[i]], (-1 * ratings[i], foods[i]))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.foods[food]=newRating\\n        heapq.heappush(self.cuisine_rating[self.cuisines[food]], (-1 * newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while  self.cuisine_rating[cuisine]:\\n            if -1 * self.cuisine_rating[cuisine][0][0] == self.foods[self.cuisine_rating[cuisine][0][1]]:\\n                return self.cuisine_rating[cuisine][0][1]\\n            else:\\n                heapq.heappop(self.cuisine_rating[cuisine])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325584,
                "title": "weird-time-limit-exceeded-for-java-priorityqueue",
                "content": "Learned this in the hard way. In order to not have time limit exceeded, the code cannot find the object in PriorityQueue to remove by name comparison (String), but to only compare the object address (Integer). String comparison takes more time.\\nTo find the object to remove by address, it needs to keep the object address (reference) in a map indexed by the food name.\\n\\nI think this \"finding object only by reference can pass\" should not be the case when generating test cases. It should let both comparing object content or object address pass.\\n\\n```\\n    Map<String, String> cuisineByFood;\\n    Map<String, FoodAndRating> frByFood;\\n    Map<String, PriorityQueue<FoodAndRating>> pqByCuisine;\\n    \\n    class FoodAndRating implements Comparable<FoodAndRating> {\\n        String food;\\n        int rating;\\n        \\n        public FoodAndRating(String f, int r) {\\n            this.food = f;\\n            this.rating = r;\\n        }\\n        \\n        public String toString() {\\n            return \"[ \" + food + \", \" + rating + \" ]\";\\n        }\\n        \\n        @Override\\n        public int compareTo(FoodAndRating anotherFr) {\\n            if (this.rating == anotherFr.rating) {\\n                return this.food.compareTo(anotherFr.food);\\n            } else {\\n                return anotherFr.rating - this.rating;\\n            }\\n        }\\n\\n        @Override\\n        public boolean equals(Object object) {\\n            /////////////////////////////////////////////////// \\n            //                                               //\\n            //     Time Limit Exceeded at test case 74       //\\n            //                                               //\\n            ///////////////////////////////////////////////////\\n            // FoodAndRating fr = (FoodAndRating) object;\\n            // return this.food.equals(fr.food) && this.rating == fr.rating;\\n            \\n            /////////////////////////////////////////////////// \\n            //                                               //\\n            //               Works fine.                     //\\n            //     Time on creating more objects is OK.      //\\n            //                                               //\\n            ///////////////////////////////////////////////////\\n            return this == object;\\n        }\\n    }\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int m = foods.length;\\n        \\n        cuisineByFood = new HashMap<>(m);\\n        \\n        frByFood = new HashMap<>(m);\\n        pqByCuisine = new HashMap<>(m);\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            cuisineByFood.put(foods[i], cuisines[i]);\\n            \\n            FoodAndRating fr = new FoodAndRating(foods[i], ratings[i]);\\n            frByFood.put(foods[i], fr);\\n            pqByCuisine.putIfAbsent(cuisines[i], new PriorityQueue<FoodAndRating>());\\n            pqByCuisine.get(cuisines[i]).add(fr);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodAndRating fr = frByFood.get(food);\\n        String cuisine = cuisineByFood.get(food);\\n        PriorityQueue pq = pqByCuisine.get(cuisine);\\n        pq.remove(fr);\\n        FoodAndRating newFr = new FoodAndRating(food, newRating);\\n        frByFood.put(food, newFr);\\n        pq.add(newFr);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return pqByCuisine.get(cuisine).peek().food;\\n    }\\n```\\n\\nGive it a try. The TLE can be easily reproduced by changing the `equals` method in `FoodAndRating`.",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    Map<String, String> cuisineByFood;\\n    Map<String, FoodAndRating> frByFood;\\n    Map<String, PriorityQueue<FoodAndRating>> pqByCuisine;\\n    \\n    class FoodAndRating implements Comparable<FoodAndRating> {\\n        String food;\\n        int rating;\\n        \\n        public FoodAndRating(String f, int r) {\\n            this.food = f;\\n            this.rating = r;\\n        }\\n        \\n        public String toString() {\\n            return \"[ \" + food + \", \" + rating + \" ]\";\\n        }\\n        \\n        @Override\\n        public int compareTo(FoodAndRating anotherFr) {\\n            if (this.rating == anotherFr.rating) {\\n                return this.food.compareTo(anotherFr.food);\\n            } else {\\n                return anotherFr.rating - this.rating;\\n            }\\n        }\\n\\n        @Override\\n        public boolean equals(Object object) {\\n            /////////////////////////////////////////////////// \\n            //                                               //\\n            //     Time Limit Exceeded at test case 74       //\\n            //                                               //\\n            ///////////////////////////////////////////////////\\n            // FoodAndRating fr = (FoodAndRating) object;\\n            // return this.food.equals(fr.food) && this.rating == fr.rating;\\n            \\n            /////////////////////////////////////////////////// \\n            //                                               //\\n            //               Works fine.                     //\\n            //     Time on creating more objects is OK.      //\\n            //                                               //\\n            ///////////////////////////////////////////////////\\n            return this == object;\\n        }\\n    }\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int m = foods.length;\\n        \\n        cuisineByFood = new HashMap<>(m);\\n        \\n        frByFood = new HashMap<>(m);\\n        pqByCuisine = new HashMap<>(m);\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            cuisineByFood.put(foods[i], cuisines[i]);\\n            \\n            FoodAndRating fr = new FoodAndRating(foods[i], ratings[i]);\\n            frByFood.put(foods[i], fr);\\n            pqByCuisine.putIfAbsent(cuisines[i], new PriorityQueue<FoodAndRating>());\\n            pqByCuisine.get(cuisines[i]).add(fr);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodAndRating fr = frByFood.get(food);\\n        String cuisine = cuisineByFood.get(food);\\n        PriorityQueue pq = pqByCuisine.get(cuisine);\\n        pq.remove(fr);\\n        FoodAndRating newFr = new FoodAndRating(food, newRating);\\n        frByFood.put(food, newFr);\\n        pq.add(newFr);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return pqByCuisine.get(cuisine).peek().food;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325431,
                "title": "c-sortedset-solution",
                "content": "```\\npublic class FoodRatings {\\n    \\n    class Food {\\n        public string Name { get; set; }\\n        public int Rating { get; set; }\\n    }\\n    \\n    class FoodComparer : IComparer<Food>{\\n        public int Compare(Food a, Food b){\\n            if(a.Rating != b.Rating)\\n                return a.Rating-b.Rating;\\n            else\\n                return string.Compare(b.Name, a.Name);\\n        }\\n    }    \\n    \\n    Dictionary<string, SortedSet<Food>> cusineFoodList = new Dictionary<string, SortedSet<Food>>();\\n    Dictionary<string, string> foodCusine = new Dictionary<string, string>();\\n    Dictionary<string, Food> foodnameFood = new Dictionary<string, Food>();\\n\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.Length; i++){\\n            if(!cusineFoodList.ContainsKey(cuisines[i]))\\n                cusineFoodList.Add(cuisines[i], new SortedSet<Food>(new FoodComparer()));\\n            Food f = new Food() { Name = foods[i], Rating = ratings[i] };\\n            cusineFoodList[cuisines[i]].Add(f);\\n            foodnameFood.Add(foods[i], f);\\n            foodCusine.Add(foods[i], cuisines[i]);\\n        }\\n    }\\n    \\n    public void ChangeRating(string food, int newRating) {\\n        Food old = foodnameFood[food];\\n        Food f = new Food() { Name = food, Rating = newRating };\\n        cusineFoodList[foodCusine[food]].Remove(old);\\n        cusineFoodList[foodCusine[food]].Add(f);\\n        foodnameFood[food] = f;\\n    }\\n    \\n    public string HighestRated(string cuisine) {\\n        return cusineFoodList[cuisine].Max.Name;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class FoodRatings {\\n    \\n    class Food {\\n        public string Name { get; set; }\\n        public int Rating { get; set; }\\n    }\\n    \\n    class FoodComparer : IComparer<Food>{\\n        public int Compare(Food a, Food b){\\n            if(a.Rating != b.Rating)\\n                return a.Rating-b.Rating;\\n            else\\n                return string.Compare(b.Name, a.Name);\\n        }\\n    }    \\n    \\n    Dictionary<string, SortedSet<Food>> cusineFoodList = new Dictionary<string, SortedSet<Food>>();\\n    Dictionary<string, string> foodCusine = new Dictionary<string, string>();\\n    Dictionary<string, Food> foodnameFood = new Dictionary<string, Food>();\\n\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.Length; i++){\\n            if(!cusineFoodList.ContainsKey(cuisines[i]))\\n                cusineFoodList.Add(cuisines[i], new SortedSet<Food>(new FoodComparer()));\\n            Food f = new Food() { Name = foods[i], Rating = ratings[i] };\\n            cusineFoodList[cuisines[i]].Add(f);\\n            foodnameFood.Add(foods[i], f);\\n            foodCusine.Add(foods[i], cuisines[i]);\\n        }\\n    }\\n    \\n    public void ChangeRating(string food, int newRating) {\\n        Food old = foodnameFood[food];\\n        Food f = new Food() { Name = food, Rating = newRating };\\n        cusineFoodList[foodCusine[food]].Remove(old);\\n        cusineFoodList[foodCusine[food]].Add(f);\\n        foodnameFood[food] = f;\\n    }\\n    \\n    public string HighestRated(string cuisine) {\\n        return cusineFoodList[cuisine].Max.Name;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325281,
                "title": "python-solution-using-two-dictionaries-and-one-heap",
                "content": "Code:\\n\\n\\tfrom collections import defaultdict\\n\\timport heapq\\n\\n\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.food_data = dict()\\n\\t\\t\\tself.heaps_of_cuis = defaultdict(list)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\theapq.heappush(self.heaps_of_cuis[cuisines[i]], [-ratings[i], foods[i]])\\n\\t\\t\\t\\tself.food_data[foods[i]] = [cuisines[i], ratings[i]]\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tcuisine = self.food_data[food][0]\\n\\t\\t\\tself.food_data[food][1] = newRating\\n\\t\\t\\theapq.heappush(self.heaps_of_cuis[cuisine], [-newRating, food])\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\trating, food = self.heaps_of_cuis[cuisine][0]\\n\\t\\t\\twhile  -rating != self.food_data[food][1]:\\n\\t\\t\\t\\theapq.heappop(self.heaps_of_cuis[cuisine])\\n\\t\\t\\t\\trating, food = self.heaps_of_cuis[cuisine][0]\\n\\t\\t\\treturn food\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "Code:\\n\\n\\tfrom collections import defaultdict\\n\\timport heapq\\n\\n\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.food_data = dict()\\n\\t\\t\\tself.heaps_of_cuis = defaultdict(list)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\theapq.heappush(self.heaps_of_cuis[cuisines[i]], [-ratings[i], foods[i]])\\n\\t\\t\\t\\tself.food_data[foods[i]] = [cuisines[i], ratings[i]]\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tcuisine = self.food_data[food][0]\\n\\t\\t\\tself.food_data[food][1] = newRating\\n\\t\\t\\theapq.heappush(self.heaps_of_cuis[cuisine], [-newRating, food])\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\trating, food = self.heaps_of_cuis[cuisine][0]\\n\\t\\t\\twhile  -rating != self.food_data[food][1]:\\n\\t\\t\\t\\theapq.heappop(self.heaps_of_cuis[cuisine])\\n\\t\\t\\t\\trating, food = self.heaps_of_cuis[cuisine][0]\\n\\t\\t\\treturn food\\n",
                "codeTag": "Java"
            },
            {
                "id": 2325196,
                "title": "c-easy-to-understand-using-map",
                "content": "```\\n// upvote if solution was helpful\\nclass FoodRatings {\\npublic:\\n    map<string, string>food; //food name, cuisine\\n    map<string, int>foodRating; // food name, rating\\n    map<string,map<int, set<string>, greater<int>>>m; // cuisine, rating, set of foods\\n\\t\\n\\t/*\\n\\tFor eg1:\\n\\tfood:\\n\\tkim->kor\\n\\tmis->jap\\n\\tsus->jap\\n\\tmou->gre\\n\\tram->jap\\n\\tbul->kor\\n\\t\\n\\tfoorRating:\\n\\tkim->9\\n\\tmis->12\\n\\tsus->8\\n\\tmou->15\\n\\tram->14\\n\\tbul->7\\n\\t\\n\\tm:\\n\\tgre-> 15->{mou}\\n\\tjap-> 14->{ram}\\n\\t      12->{mis}\\n\\t\\t  8->{sus}\\n\\tkor-> 9->{kim}\\n\\t      7->{bul}\\n\\t*/\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for(int i = 0;i<n;i++) {\\n            food[foods[i]] = cuisines[i];\\n            foodRating[foods[i]] = ratings[i];\\n            m[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n    \\n    void changeRating(string fod, int newRating) {\\n        string c = food[fod]; // cuisine of food\\n        int oldRating = foodRating[fod]; // old rating of food\\n        m[c][oldRating].erase(fod); // remove food from cuisine and old rating\\n        if(m[c][oldRating].empty()) m[c].erase(oldRating); // if old rating is empty, remove old rating\\n        m[c][newRating].insert(fod); // add food to new rating\\n        foodRating[fod] = newRating; // update food rating\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return *m[cuisine].begin()->second.begin();  // return highest rated food in cuisine\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// upvote if solution was helpful\\nclass FoodRatings {\\npublic:\\n    map<string, string>food; //food name, cuisine\\n    map<string, int>foodRating; // food name, rating\\n    map<string,map<int, set<string>, greater<int>>>m; // cuisine, rating, set of foods\\n\\t\\n\\t/*\\n\\tFor eg1:\\n\\tfood:\\n\\tkim->kor\\n\\tmis->jap\\n\\tsus->jap\\n\\tmou->gre\\n\\tram->jap\\n\\tbul->kor\\n\\t\\n\\tfoorRating:\\n\\tkim->9\\n\\tmis->12\\n\\tsus->8\\n\\tmou->15\\n\\tram->14\\n\\tbul->7\\n\\t\\n\\tm:\\n\\tgre-> 15->{mou}\\n\\tjap-> 14->{ram}\\n\\t      12->{mis}\\n\\t\\t  8->{sus}\\n\\tkor-> 9->{kim}\\n\\t      7->{bul}\\n\\t*/\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for(int i = 0;i<n;i++) {\\n            food[foods[i]] = cuisines[i];\\n            foodRating[foods[i]] = ratings[i];\\n            m[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n    \\n    void changeRating(string fod, int newRating) {\\n        string c = food[fod]; // cuisine of food\\n        int oldRating = foodRating[fod]; // old rating of food\\n        m[c][oldRating].erase(fod); // remove food from cuisine and old rating\\n        if(m[c][oldRating].empty()) m[c].erase(oldRating); // if old rating is empty, remove old rating\\n        m[c][newRating].insert(fod); // add food to new rating\\n        foodRating[fod] = newRating; // update food rating\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return *m[cuisine].begin()->second.begin();  // return highest rated food in cuisine\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325115,
                "title": "very-easy-and-simple-to-understand-c-solution-detail-explanation",
                "content": "<b> Up Vote if you like the Solution\\n```\\nclass FoodRatings {\\npublic:\\n    //Rating is stored as -ve as to have the largest value at the begining\\n    //to store data in the format - coisines :{ {-rating1, food1}, {-rating1, food1} ...}\\n    //This map will be used to get the highest rating\\n    map<string, set<pair<int, string>>> smp; \\n    \\n    //to store maping of food to coisine type ( food -> coisine)\\n    map<string, string> tmp;\\n    \\n    // to store maping of last rating of a food ( food -> rating)\\n    map<string, int> rmp;\\n\\t\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings){\\n        //store all the data\\n        for(int i = 0; i < foods.size(); ++i){\\n            smp[cuisines[i]].insert({-ratings[i], foods[i]});\\n            tmp[foods[i]] = cuisines[i];\\n            rmp[foods[i]] = ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string ctype = tmp[food];\\n        int oldRating = rmp[food];  //get older rating of the food\\n        rmp[food] = newRating;      \\n        smp[ctype].erase({-oldRating, food});  //erase the older rating \\n        smp[ctype].insert({-newRating, food}); //iinsert the new one\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = smp[cuisine].begin(); //this will return a pointer to first {-rating, food}\\n        return (*it).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    //Rating is stored as -ve as to have the largest value at the begining\\n    //to store data in the format - coisines :{ {-rating1, food1}, {-rating1, food1} ...}\\n    //This map will be used to get the highest rating\\n    map<string, set<pair<int, string>>> smp; \\n    \\n    //to store maping of food to coisine type ( food -> coisine)\\n    map<string, string> tmp;\\n    \\n    // to store maping of last rating of a food ( food -> rating)\\n    map<string, int> rmp;\\n\\t\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings){\\n        //store all the data\\n        for(int i = 0; i < foods.size(); ++i){\\n            smp[cuisines[i]].insert({-ratings[i], foods[i]});\\n            tmp[foods[i]] = cuisines[i];\\n            rmp[foods[i]] = ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string ctype = tmp[food];\\n        int oldRating = rmp[food];  //get older rating of the food\\n        rmp[food] = newRating;      \\n        smp[ctype].erase({-oldRating, food});  //erase the older rating \\n        smp[ctype].insert({-newRating, food}); //iinsert the new one\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = smp[cuisine].begin(); //this will return a pointer to first {-rating, food}\\n        return (*it).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325102,
                "title": "3-maps-explanation-c",
                "content": "At first glace, it makes sense to use 2 maps for this problem. Why?\\n- Firstly, we need a map that stores the cuisine name for a given food.\\n- We need a map that takes the cuisine name and outputs two things: rating and food. \\nThe first map maps cuisine to food\\nThe second map is a little tricky because it needs to be sorted. We can use a set of type pair<rating, food> as the value and cuisine as the key. Note that a set will sort in ascending order (to get around this, I push -1\\\\*rating).\\n\\nThis might seem enough until you start coding the logic, after which you realise that you need a **third map**. Why?\\n\\n- While changing the rating of a food, we need to erase it from the set in the second map and push the new rating. In order to erase it from the set, we need to pass both the food and the previous rating to the erase function. To keep track of the previous rating we use another map.\\n\\n```\\n\\n\\nclass FoodRatings {\\npublic:\\n    // [food] = cuisine name\\n    unordered_map <string, string> getcus;\\n    // [cuisine] = <rating, food>\\n    unordered_map <string, set <pair<int, string>>> crf;\\n    // [food] = rating (used to remove pair from crf)\\n    unordered_map <string, int> foodrating;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++) {\\n            getcus[foods[i]] = cuisines[i];\\n            crf[cuisines[i]].insert({-ratings[i], foods[i]});\\n            foodrating[foods[i]] = -ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cus = getcus[food];\\n        int currating = foodrating[food];\\n        crf[cus].erase({currating, food});\\n        crf[cus].insert({-newRating, food});\\n        foodrating[food] = -newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        // just gets the first element from the iterator\\n        auto ans(crf[cuisine].begin());\\n        return (*ans).second;\\n    }\\n};\\n```\\n\\nSimilar (but slightly more complex) problem to try: [Design Movie Rental System](https://leetcode.com/problems/design-movie-rental-system/)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nclass FoodRatings {\\npublic:\\n    // [food] = cuisine name\\n    unordered_map <string, string> getcus;\\n    // [cuisine] = <rating, food>\\n    unordered_map <string, set <pair<int, string>>> crf;\\n    // [food] = rating (used to remove pair from crf)\\n    unordered_map <string, int> foodrating;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++) {\\n            getcus[foods[i]] = cuisines[i];\\n            crf[cuisines[i]].insert({-ratings[i], foods[i]});\\n            foodrating[foods[i]] = -ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cus = getcus[food];\\n        int currating = foodrating[food];\\n        crf[cus].erase({currating, food});\\n        crf[cus].insert({-newRating, food});\\n        foodrating[food] = -newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        // just gets the first element from the iterator\\n        auto ans(crf[cuisine].begin());\\n        return (*ans).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324953,
                "title": "python-priority-queue-hashmap-100-faster",
                "content": "\\n```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        \\n\\t\\t#store heap of food & rating linked to cusine \\n        self.cusine_heap_lookup = {}\\n\\t\\t\\n\\t\\t#store rating for easy update  : O(1)\\n        self.cusine_hash_lookup = {}\\n\\t\\t\\n\\t\\t#find out food by cusine : O(1)\\n        self.cusine_revese_lookup = {}\\n        \\n        for cusine in cuisines:\\n            self.cusine_heap_lookup[cusine] = []\\n            self.cusine_hash_lookup[cusine] = {}\\n            \\n        \\n        n = len(foods)\\n        for index in range(n):\\n            heap_lookup = self.cusine_heap_lookup[cuisines[index]]\\n            hash_lookup = self.cusine_hash_lookup[cuisines[index]] \\n            \\n            self.cusine_revese_lookup[foods[index]] = cuisines[index]\\n            heapq.heappush(heap_lookup,[-ratings[index], foods[index]])\\n            hash_lookup[foods[index]] = ratings[index]\\n           \\n\\t# TC : O(1) hashmap + O(1) heap insert\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        \\n        cusine = self.cusine_revese_lookup[food]\\n        heap_lookup = self.cusine_heap_lookup[cusine]\\n        hash_lookup = self.cusine_hash_lookup[cusine] \\n        \\n        heapq.heappush(heap_lookup,[-newRating,food])\\n        hash_lookup[food] = newRating\\n       \\n\\t# TC : O(1) hashmap + n.O(1) heap find \\n    def highestRated(self, cuisine: str) -> str:\\n        heap_lookup = self.cusine_heap_lookup[cuisine]\\n        hash_lookup = self.cusine_hash_lookup[cuisine]\\n        \\n\\t\\t#reject heap value until it\\'s invalid \\n        while heap_lookup and -heap_lookup[0][0] != hash_lookup[heap_lookup[0][1]]:\\n            heapq.heappop(heap_lookup)\\n        \\n        return heap_lookup[0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        \\n\\t\\t#store heap of food & rating linked to cusine \\n        self.cusine_heap_lookup = {}\\n\\t\\t\\n\\t\\t#store rating for easy update  : O(1)\\n        self.cusine_hash_lookup = {}\\n\\t\\t\\n\\t\\t#find out food by cusine : O(1)\\n        self.cusine_revese_lookup = {}\\n        \\n        for cusine in cuisines:\\n            self.cusine_heap_lookup[cusine] = []\\n            self.cusine_hash_lookup[cusine] = {}\\n            \\n        \\n        n = len(foods)\\n        for index in range(n):\\n            heap_lookup = self.cusine_heap_lookup[cuisines[index]]\\n            hash_lookup = self.cusine_hash_lookup[cuisines[index]] \\n            \\n            self.cusine_revese_lookup[foods[index]] = cuisines[index]\\n            heapq.heappush(heap_lookup,[-ratings[index], foods[index]])\\n            hash_lookup[foods[index]] = ratings[index]\\n           \\n\\t# TC : O(1) hashmap + O(1) heap insert\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        \\n        cusine = self.cusine_revese_lookup[food]\\n        heap_lookup = self.cusine_heap_lookup[cusine]\\n        hash_lookup = self.cusine_hash_lookup[cusine] \\n        \\n        heapq.heappush(heap_lookup,[-newRating,food])\\n        hash_lookup[food] = newRating\\n       \\n\\t# TC : O(1) hashmap + n.O(1) heap find \\n    def highestRated(self, cuisine: str) -> str:\\n        heap_lookup = self.cusine_heap_lookup[cuisine]\\n        hash_lookup = self.cusine_hash_lookup[cuisine]\\n        \\n\\t\\t#reject heap value until it\\'s invalid \\n        while heap_lookup and -heap_lookup[0][0] != hash_lookup[heap_lookup[0][1]]:\\n            heapq.heappop(heap_lookup)\\n        \\n        return heap_lookup[0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324944,
                "title": "java-2-hashmap-tree-set-comparable-approach",
                "content": "Using custom class to encapsulate fields- foodname and cuisine are declared final, rating is mutable\\n2 hashmaps to maintain a)foodname vs food and b)cuisine vs set of foods (naturally ordered by rating)\\n\\n```\\nclass Food implements Comparable{\\n    public final String food;\\n    public final String cuisine;\\n    public int rating;\\n    \\n    public Food(String food, String cuisine, int rating){\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    \\n    public int compareTo(Object other){\\n        Food otherFood =  ((Food)other);\\n        int ratingDiff = this.rating -otherFood.rating;\\n        return ratingDiff == 0 ? otherFood.food.compareTo(this.food) : ratingDiff;\\n    }\\n}\\n\\n\\nclass FoodRatings {\\n    \\n    Map<String,Food> foodMap = new HashMap<>();\\n    Map<String,TreeSet<Food>> cuisineToFoods = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0;i<foods.length;i++){\\n            Food f = new Food(foods[i],cuisines[i],ratings[i]);\\n            foodMap.put(foods[i],f);\\n            cuisineToFoods.putIfAbsent(cuisines[i],new TreeSet<Food>());\\n            cuisineToFoods.get(cuisines[i]).add(f);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food currFood = foodMap.get(food);\\n        cuisineToFoods.get(currFood.cuisine).remove(currFood);\\n        currFood.rating=newRating;\\n        cuisineToFoods.get(currFood.cuisine).add(currFood);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineToFoods.get(cuisine).last().food;\\n    }\\n}\\n```\\n\\nminor Improvement - can replace comparable with external comparator sort",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Food implements Comparable{\\n    public final String food;\\n    public final String cuisine;\\n    public int rating;\\n    \\n    public Food(String food, String cuisine, int rating){\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    \\n    public int compareTo(Object other){\\n        Food otherFood =  ((Food)other);\\n        int ratingDiff = this.rating -otherFood.rating;\\n        return ratingDiff == 0 ? otherFood.food.compareTo(this.food) : ratingDiff;\\n    }\\n}\\n\\n\\nclass FoodRatings {\\n    \\n    Map<String,Food> foodMap = new HashMap<>();\\n    Map<String,TreeSet<Food>> cuisineToFoods = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0;i<foods.length;i++){\\n            Food f = new Food(foods[i],cuisines[i],ratings[i]);\\n            foodMap.put(foods[i],f);\\n            cuisineToFoods.putIfAbsent(cuisines[i],new TreeSet<Food>());\\n            cuisineToFoods.get(cuisines[i]).add(f);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food currFood = foodMap.get(food);\\n        cuisineToFoods.get(currFood.cuisine).remove(currFood);\\n        currFood.rating=newRating;\\n        cuisineToFoods.get(currFood.cuisine).add(currFood);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineToFoods.get(cuisine).last().food;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324896,
                "title": "java-3-map-treeset-why-pair-not-work-but-custom-class-does",
                "content": "Below is my code, 3 Maps with TreeSet, and passed the base test case. HOWEVER, it failed in the test case that \\'kjop\\' and \\'lzeqwfb\\' where these 2 has same rating. I MERELY want to know why this case failed. I cannot really find out the reasons. \\n\\n(I\\'ve tried different Comparator in comments, NOT WORK, WHY)\\n \\n```\\nclass FoodRatings {\\n    Map<String, String> dishSys;\\n    Map<String, Integer> dishPrice;\\n    Map<String, TreeSet<Pair<String, Integer>>> map; // cuisine --SortedList<Pair<String, Integer>>\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        dishSys = new HashMap<>();\\n        dishPrice = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            TreeSet<Pair<String, Integer>> set = map.getOrDefault(cuisines[i], new TreeSet(new Comparator<Pair<String, Integer>>(){\\n         @Override\\n         public int compare(Pair<String, Integer> o1, Pair<String, Integer> o2){\\n             if (o1.getValue() == o2.getValue())\\n                 return o1.getKey().compareTo(o2.getKey());\\n             // if (o1.getValue() == o2.getValue()){\\n             //     String s1 = o1.getKey();\\n             //     String s2 = o2.getKey();\\n             //     int i = 0, j = 0;\\n             //     while(i < s1.length() && j < s2.length()) {\\n             //         if(s1.charAt(i) > s2.charAt(j)) {\\n             //             return 1;\\n             //         }else if (s1.charAt(i) < s2.charAt(j)) {\\n             //             return -1;\\n             //         }\\n             //         i++;\\n             //         j++;\\n             //     }\\n             //     if (i == s1.length() && j < s2.length())\\n             //         return -1;\\n             //     if (i < s1.length() && j == s2.length())\\n             //         return 1;\\n             //     return 0;\\n             // }    \\n                 \\n             \\n             return o2.getValue() - o1.getValue();\\n         }\\n     }));\\n            set.add(new Pair(foods[i], ratings[i]));\\n            map.put(cuisines[i], set);\\n            dishSys.put(foods[i], cuisines[i]);\\n            dishPrice.put(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String belongSys = dishSys.get(food);\\n        Integer oldPrice = dishPrice.get(food);\\n        Pair<String, Integer> pair = new Pair(food, oldPrice);\\n        map.get(belongSys).remove(pair);\\n        map.get(belongSys).add(new Pair(food, newRating));\\n        dishPrice.put(food, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().getKey();\\n    }\\n}\\n```\\n\\n--------------------EDITED---------------------\\nfreakly weird! JUST create a custom class, and store the name String, it works, BUT if using Pair, It does NOT work. HELLLLLLLLLLLLLLLP!!! CAN anyone explain it to me? Thank you!!!!!!\\n\\n\\n```\\n    Map<String, String> dishSys;\\n    Map<String, Integer> dishPrice;\\n    Map<String, TreeSet<Food>> map; // cuisine --SortedList<Pair<String, Integer>>\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        dishSys = new HashMap<>();\\n        dishPrice = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            Food f = new Food(foods[i], ratings[i]);\\n            TreeSet<Food> set = map.getOrDefault(cuisines[i], new TreeSet(new Comparator<Food>(){\\n         @Override\\n         public int compare(Food o1, Food o2){\\n             if (o1.rate == o2.rate)\\n                 return o1.name.compareTo(o2.name);                 \\n             \\n             return o2.rate - o1.rate;\\n         }\\n     }));\\n            set.add(f);\\n            map.put(cuisines[i], set);\\n            dishSys.put(foods[i], cuisines[i]);\\n            dishPrice.put(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String belongSys = dishSys.get(food);\\n        Integer oldPrice = dishPrice.get(food);\\n        Food pair = new Food(food, oldPrice);\\n        map.get(belongSys).remove(pair);\\n        map.get(belongSys).add(new Food(food, newRating));\\n        dishPrice.put(food, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().name;\\n    }\\n    \\n    \\n    class Food{\\n        String name;\\n        int rate;\\n        \\n        public Food (String n, int r) {\\n            name = n;\\n            rate = r;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    Map<String, String> dishSys;\\n    Map<String, Integer> dishPrice;\\n    Map<String, TreeSet<Pair<String, Integer>>> map; // cuisine --SortedList<Pair<String, Integer>>\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        dishSys = new HashMap<>();\\n        dishPrice = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            TreeSet<Pair<String, Integer>> set = map.getOrDefault(cuisines[i], new TreeSet(new Comparator<Pair<String, Integer>>(){\\n         @Override\\n         public int compare(Pair<String, Integer> o1, Pair<String, Integer> o2){\\n             if (o1.getValue() == o2.getValue())\\n                 return o1.getKey().compareTo(o2.getKey());\\n             // if (o1.getValue() == o2.getValue()){\\n             //     String s1 = o1.getKey();\\n             //     String s2 = o2.getKey();\\n             //     int i = 0, j = 0;\\n             //     while(i < s1.length() && j < s2.length()) {\\n             //         if(s1.charAt(i) > s2.charAt(j)) {\\n             //             return 1;\\n             //         }else if (s1.charAt(i) < s2.charAt(j)) {\\n             //             return -1;\\n             //         }\\n             //         i++;\\n             //         j++;\\n             //     }\\n             //     if (i == s1.length() && j < s2.length())\\n             //         return -1;\\n             //     if (i < s1.length() && j == s2.length())\\n             //         return 1;\\n             //     return 0;\\n             // }    \\n                 \\n             \\n             return o2.getValue() - o1.getValue();\\n         }\\n     }));\\n            set.add(new Pair(foods[i], ratings[i]));\\n            map.put(cuisines[i], set);\\n            dishSys.put(foods[i], cuisines[i]);\\n            dishPrice.put(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String belongSys = dishSys.get(food);\\n        Integer oldPrice = dishPrice.get(food);\\n        Pair<String, Integer> pair = new Pair(food, oldPrice);\\n        map.get(belongSys).remove(pair);\\n        map.get(belongSys).add(new Pair(food, newRating));\\n        dishPrice.put(food, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().getKey();\\n    }\\n}\\n```\n```\\n    Map<String, String> dishSys;\\n    Map<String, Integer> dishPrice;\\n    Map<String, TreeSet<Food>> map; // cuisine --SortedList<Pair<String, Integer>>\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        dishSys = new HashMap<>();\\n        dishPrice = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            Food f = new Food(foods[i], ratings[i]);\\n            TreeSet<Food> set = map.getOrDefault(cuisines[i], new TreeSet(new Comparator<Food>(){\\n         @Override\\n         public int compare(Food o1, Food o2){\\n             if (o1.rate == o2.rate)\\n                 return o1.name.compareTo(o2.name);                 \\n             \\n             return o2.rate - o1.rate;\\n         }\\n     }));\\n            set.add(f);\\n            map.put(cuisines[i], set);\\n            dishSys.put(foods[i], cuisines[i]);\\n            dishPrice.put(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String belongSys = dishSys.get(food);\\n        Integer oldPrice = dishPrice.get(food);\\n        Food pair = new Food(food, oldPrice);\\n        map.get(belongSys).remove(pair);\\n        map.get(belongSys).add(new Food(food, newRating));\\n        dishPrice.put(food, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().name;\\n    }\\n    \\n    \\n    class Food{\\n        String name;\\n        int rate;\\n        \\n        public Food (String n, int r) {\\n            name = n;\\n            rate = r;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324860,
                "title": "c-priorityqueue-explained",
                "content": "```\\n    public class FoodRatings\\n    {\\n        private readonly Dictionary<string, int> dict;\\n        private readonly Dictionary<string, string> set;\\n\\t\\t//we donot design a new class, but using a string[2], string[0] is foodname, string[1] is rate.ToString()\\n        private readonly Dictionary<string, PriorityQueue<string[], string[]>> map;\\n        public FoodRatings(string[] foods, string[] cuisines, int[] ratings)\\n        {\\n            dict = new Dictionary<string, int>();\\n            set = new Dictionary<string, string>();\\n            map = new Dictionary<string, PriorityQueue<string[], string[]>>();\\n            int n = foods.Length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                dict.Add(foods[i], ratings[i]);//store {food,rating} pairs\\n                set.Add(foods[i], cuisines[i]);//store {food,cursine} pairs\\n                if (!map.ContainsKey(cuisines[i]))\\n                    map.Add(cuisines[i], new PriorityQueue<string[], string[]>(Comparer<string[]>.Create((x, y) =>\\n                    {\\n                        var rate1 = int.Parse(x[1]);\\n                        var rate2 = int.Parse(y[1]);\\n                        if (rate1 > rate2) return -1;//return better rating food of this cuisine type\\n                        else if (rate1 < rate2) return 1;\\n                        else return x[0].CompareTo(y[0]);//if two same rating existed, return smaller name\\n                    })));\\n\\t\\t\\t\\t//store string[]{ foods[i], ratings[i].ToString()} pairs\\n                map[cuisines[i]].Enqueue(new string[] { foods[i], ratings[i].ToString() }, new string[] { foods[i], ratings[i].ToString() });\\n            }\\n        }\\n\\n        public void ChangeRating(string food, int newRating)\\n        {\\n            dict[food] = newRating;\\n            var cuisine = set[food];\\n\\t\\t\\t//every time changing rating, Enqueue new one in map, old still in map but expired!\\n            map[cuisine].Enqueue(new string[] { food, newRating.ToString() }, new string[] { food, newRating.ToString() });\\n        }\\n\\n        public string HighestRated(string cuisine)\\n        {\\n            var pq = map[cuisine];\\n            while (pq.Count > 0)\\n            {\\n                var top = pq.Peek();\\n                var rate = int.Parse(top[1]);\\n                if (dict[top[0]] == rate) return top[0];//if current rating is correct, return top[0] as food name\\n                else pq.Dequeue();//if rating of this food - top[0] was changed, the discard this expired one\\n            }\\n            return \"\";//never go here\\n        }\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public class FoodRatings\\n    {\\n        private readonly Dictionary<string, int> dict;\\n        private readonly Dictionary<string, string> set;\\n\\t\\t//we donot design a new class, but using a string[2], string[0] is foodname, string[1] is rate.ToString()\\n        private readonly Dictionary<string, PriorityQueue<string[], string[]>> map;\\n        public FoodRatings(string[] foods, string[] cuisines, int[] ratings)\\n        {\\n            dict = new Dictionary<string, int>();\\n            set = new Dictionary<string, string>();\\n            map = new Dictionary<string, PriorityQueue<string[], string[]>>();\\n            int n = foods.Length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                dict.Add(foods[i], ratings[i]);//store {food,rating} pairs\\n                set.Add(foods[i], cuisines[i]);//store {food,cursine} pairs\\n                if (!map.ContainsKey(cuisines[i]))\\n                    map.Add(cuisines[i], new PriorityQueue<string[], string[]>(Comparer<string[]>.Create((x, y) =>\\n                    {\\n                        var rate1 = int.Parse(x[1]);\\n                        var rate2 = int.Parse(y[1]);\\n                        if (rate1 > rate2) return -1;//return better rating food of this cuisine type\\n                        else if (rate1 < rate2) return 1;\\n                        else return x[0].CompareTo(y[0]);//if two same rating existed, return smaller name\\n                    })));\\n\\t\\t\\t\\t//store string[]{ foods[i], ratings[i].ToString()} pairs\\n                map[cuisines[i]].Enqueue(new string[] { foods[i], ratings[i].ToString() }, new string[] { foods[i], ratings[i].ToString() });\\n            }\\n        }\\n\\n        public void ChangeRating(string food, int newRating)\\n        {\\n            dict[food] = newRating;\\n            var cuisine = set[food];\\n\\t\\t\\t//every time changing rating, Enqueue new one in map, old still in map but expired!\\n            map[cuisine].Enqueue(new string[] { food, newRating.ToString() }, new string[] { food, newRating.ToString() });\\n        }\\n\\n        public string HighestRated(string cuisine)\\n        {\\n            var pq = map[cuisine];\\n            while (pq.Count > 0)\\n            {\\n                var top = pq.Peek();\\n                var rate = int.Parse(top[1]);\\n                if (dict[top[0]] == rate) return top[0];//if current rating is correct, return top[0] as food name\\n                else pq.Dequeue();//if rating of this food - top[0] was changed, the discard this expired one\\n            }\\n            return \"\";//never go here\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324848,
                "title": "java-map-priority-queue",
                "content": "```\\nclass FoodRatings \\n{\\n    class Pair implements Comparable<Pair>\\n    {\\n        String s;int r;\\n        \\n        Pair(String a,int b)\\n        {\\n            s=a;\\n            r=b;\\n        }\\n        \\n        public int compareTo(Pair obj)\\n        {\\n            if(this.r!=obj.r)\\n            return obj.r-this.r;\\n            \\n            return this.s.compareTo(obj.s);\\n            \\n        }\\n    }\\n    \\n    Map<String,PriorityQueue<Pair>> map;\\n    Map<String,Integer> name;\\n    Map<String,String> c;\\n    Pair a[];\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) \\n    {\\n        int n=foods.length;\\n        \\n        map=new HashMap<>();\\n        name=new HashMap<>();\\n        c=new HashMap<>();\\n        \\n        a=new Pair[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=new Pair(foods[i],ratings[i]);\\n            \\n            name.put(foods[i],i);\\n            c.put(foods[i],cuisines[i]);\\n            \\n            if(!map.containsKey(cuisines[i]))\\n            map.put(cuisines[i],new PriorityQueue<>());\\n            \\n            PriorityQueue<Pair> temp=map.get(cuisines[i]);\\n            temp.offer(a[i]);\\n            map.put(cuisines[i],temp);\\n                \\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) \\n    {\\n        int pos=name.get(food);\\n        \\n        map.get(c.get(food)).remove(a[pos]);\\n        a[pos].r=newRating;\\n        map.get(c.get(food)).offer(a[pos]);\\n    }\\n    \\n    public String highestRated(String cuisine) \\n    {\\n        return map.get(cuisine).peek().s;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings \\n{\\n    class Pair implements Comparable<Pair>\\n    {\\n        String s;int r;\\n        \\n        Pair(String a,int b)\\n        {\\n            s=a;\\n            r=b;\\n        }\\n        \\n        public int compareTo(Pair obj)\\n        {\\n            if(this.r!=obj.r)\\n            return obj.r-this.r;\\n            \\n            return this.s.compareTo(obj.s);\\n            \\n        }\\n    }\\n    \\n    Map<String,PriorityQueue<Pair>> map;\\n    Map<String,Integer> name;\\n    Map<String,String> c;\\n    Pair a[];\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) \\n    {\\n        int n=foods.length;\\n        \\n        map=new HashMap<>();\\n        name=new HashMap<>();\\n        c=new HashMap<>();\\n        \\n        a=new Pair[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=new Pair(foods[i],ratings[i]);\\n            \\n            name.put(foods[i],i);\\n            c.put(foods[i],cuisines[i]);\\n            \\n            if(!map.containsKey(cuisines[i]))\\n            map.put(cuisines[i],new PriorityQueue<>());\\n            \\n            PriorityQueue<Pair> temp=map.get(cuisines[i]);\\n            temp.offer(a[i]);\\n            map.put(cuisines[i],temp);\\n                \\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) \\n    {\\n        int pos=name.get(food);\\n        \\n        map.get(c.get(food)).remove(a[pos]);\\n        a[pos].r=newRating;\\n        map.get(c.get(food)).offer(a[pos]);\\n    }\\n    \\n    public String highestRated(String cuisine) \\n    {\\n        return map.get(cuisine).peek().s;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324836,
                "title": "c-easy-solution-map",
                "content": "```\\nstruct compare\\n{\\n    bool operator()(const pair<int, string> &x, const pair<int, string> &y) const\\n    {\\n        if (x.first == y.first)\\n        {\\n            return x.second > y.second;\\n        }\\n        return x.first < y.first;\\n    }\\n};\\n\\n\\nclass FoodRatings\\n{\\npublic:\\n    map<string, int> Mapstr;\\n    map<string, string> Mapstrstr;\\n    map<string, set<pair<int, string>, compare>> MapSet;\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector<int> &ratings)\\n    {\\n        for (int i = 0; i < foods.size(); i++)\\n        {\\n            Mapstr[foods[i]] = ratings[i];\\n            MapSet[cuisines[i]].insert({ratings[i], foods[i]});\\n            Mapstrstr[foods[i]] = cuisines[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        MapSet[Mapstrstr[food]].erase({Mapstr[food], food});\\n        MapSet[Mapstrstr[food]].insert({newRating, food});\\n        Mapstr[food] = newRating;\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return (*--MapSet[cuisine].end()).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstruct compare\\n{\\n    bool operator()(const pair<int, string> &x, const pair<int, string> &y) const\\n    {\\n        if (x.first == y.first)\\n        {\\n            return x.second > y.second;\\n        }\\n        return x.first < y.first;\\n    }\\n};\\n\\n\\nclass FoodRatings\\n{\\npublic:\\n    map<string, int> Mapstr;\\n    map<string, string> Mapstrstr;\\n    map<string, set<pair<int, string>, compare>> MapSet;\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector<int> &ratings)\\n    {\\n        for (int i = 0; i < foods.size(); i++)\\n        {\\n            Mapstr[foods[i]] = ratings[i];\\n            MapSet[cuisines[i]].insert({ratings[i], foods[i]});\\n            Mapstrstr[foods[i]] = cuisines[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        MapSet[Mapstrstr[food]].erase({Mapstr[food], food});\\n        MapSet[Mapstrstr[food]].insert({newRating, food});\\n        Mapstr[food] = newRating;\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return (*--MapSet[cuisine].end()).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324733,
                "title": "easy-solution-with-two-maps-java",
                "content": "PQ with cuisinesMap to get largest\\nand foodMap get the object to update the rate.\\n\\n```\\nclass FoodRatings {\\n    \\n    Map<String, PriorityQueue<Food>> cuisinesMap;\\n    Map<String, Food> foodMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisinesMap = new HashMap<>();\\n        foodMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i++){\\n            String food = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            Food foodObj = new Food(food, rating, cuisine);\\n            if(!cuisinesMap.containsKey(cuisine)){\\n                PriorityQueue<Food> pq = new PriorityQueue<>((a, b) -> a.rate == b.rate ? a.name.compareTo(b.name) : b.rate - a.rate);\\n                cuisinesMap.put(cuisine, pq);\\n            }\\n            \\n            cuisinesMap.get(cuisine).offer(foodObj);\\n            foodMap.put(food, foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food foodObj = foodMap.get(food);\\n        foodObj.rate = newRating;\\n        PriorityQueue<Food> pq = cuisinesMap.get(foodObj.cuisine);\\n        pq.remove(foodObj);\\n        pq.offer(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Food> pq = cuisinesMap.get(cuisine);\\n        return pq.peek().name;\\n    }\\n    \\n    class Food{\\n        String name;\\n        int rate;\\n        String cuisine;\\n        \\n        Food(String n, int r, String c){\\n            this.name = n;\\n            this.rate = r;\\n            this.cuisine = c;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings {\\n    \\n    Map<String, PriorityQueue<Food>> cuisinesMap;\\n    Map<String, Food> foodMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisinesMap = new HashMap<>();\\n        foodMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i++){\\n            String food = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            Food foodObj = new Food(food, rating, cuisine);\\n            if(!cuisinesMap.containsKey(cuisine)){\\n                PriorityQueue<Food> pq = new PriorityQueue<>((a, b) -> a.rate == b.rate ? a.name.compareTo(b.name) : b.rate - a.rate);\\n                cuisinesMap.put(cuisine, pq);\\n            }\\n            \\n            cuisinesMap.get(cuisine).offer(foodObj);\\n            foodMap.put(food, foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food foodObj = foodMap.get(food);\\n        foodObj.rate = newRating;\\n        PriorityQueue<Food> pq = cuisinesMap.get(foodObj.cuisine);\\n        pq.remove(foodObj);\\n        pq.offer(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Food> pq = cuisinesMap.get(cuisine);\\n        return pq.peek().name;\\n    }\\n    \\n    class Food{\\n        String name;\\n        int rate;\\n        String cuisine;\\n        \\n        Food(String n, int r, String c){\\n            this.name = n;\\n            this.rate = r;\\n            this.cuisine = c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324722,
                "title": "simple-set-hashmap-solution-c",
                "content": "```\\n    map<string,string>m3;\\n    map<string,set<pair<int,string>>>m1;\\n    map<string,int>m2;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n      \\n        for(int i=0;i<foods.size();i++){\\n            m2[foods[i]]=ratings[i];\\n            m1[cuisines[i]].insert({ratings[i],foods[i]});\\n            m3[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating)\\n    {\\n        auto it=m1[m3[food]].find({m2[food],food});\\n        m1[m3[food]].erase(*it);\\n        m1[m3[food]].insert({newRating,food});\\n        m2[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        int ans=0;\\n        string res;\\n        auto it=m1[cuisine].end();\\n        it--;\\n        pair<int,string>p=*it;\\n        res=p.second;\\n        while(1)\\n        {\\n            it--;\\n            pair<int,string>p1=*it;\\n            if(p1.first==p.first){\\n                res=p1.second;\\n                \\n            }\\n            else\\n            {\\n                break;\\n            }\\n            if(it==m1[cuisine].begin())break;\\n        }\\n      \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n    map<string,string>m3;\\n    map<string,set<pair<int,string>>>m1;\\n    map<string,int>m2;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n      \\n        for(int i=0;i<foods.size();i++){\\n            m2[foods[i]]=ratings[i];\\n            m1[cuisines[i]].insert({ratings[i],foods[i]});\\n            m3[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating)\\n    {\\n        auto it=m1[m3[food]].find({m2[food],food});\\n        m1[m3[food]].erase(*it);\\n        m1[m3[food]].insert({newRating,food});\\n        m2[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        int ans=0;\\n        string res;\\n        auto it=m1[cuisine].end();\\n        it--;\\n        pair<int,string>p=*it;\\n        res=p.second;\\n        while(1)\\n        {\\n            it--;\\n            pair<int,string>p1=*it;\\n            if(p1.first==p.first){\\n                res=p1.second;\\n                \\n            }\\n            else\\n            {\\n                break;\\n            }\\n            if(it==m1[cuisine].begin())break;\\n        }\\n      \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324703,
                "title": "javascript-priority-queue-w-lazy-removal",
                "content": "**Solution: Priority Queue w/ Lazy Removal**\\n\\nFor each cuisine, keep a priority queue of `[food, rating]` ordered by rating (desc) and food in lexicographical order.\\nUse a hashmap to keep track of the rating and cuisine of each food.\\nWhen a rating is updated, update the hashmap and add `[food, newRating]` to the priority queue.\\nWhen getting the highest rated food, remove all foods with an outdated rating before getting the topmost food.\\n\\n**Time Complexity**: \\n  initialization: `O(n log(n))`\\n  changeRating: `O(log(n))`\\n  highestRated: `O(m log(m))` worst case, but will never be more than `O(m log(m))` for the total number of calls (`m` is the number of calls)\\n**Space Complexity**: `O(n)`\\n```\\nvar FoodRatings = function(foods, cuisines, ratings) {\\n  this.heaps = {}, this.foods = {};\\n  let n = foods.length;\\n  for (let i = 0; i < n; i++) {\\n    let food = foods[i], cuisine = cuisines[i], rating = ratings[i];\\n    if (!this.heaps[cuisine]) this.heaps[cuisine] = new PriorityQueue((a, b) => { // [food, rating]\\n      return a[1] === b[1] ? a[0].localeCompare(b[0]) : b[1] - a[1];\\n    })\\n    this.heaps[cuisine].add([food, rating]);\\n    this.foods[food] = { cuisine, rating };\\n  } \\n};\\n\\nFoodRatings.prototype.changeRating = function(food, newRating) {\\n  this.foods[food].rating = newRating;\\n  let { cuisine } = this.foods[food];\\n  this.heaps[cuisine].add([food, newRating]);\\n};\\n\\nFoodRatings.prototype.highestRated = function(cuisine) {\\n  let heap = this.heaps[cuisine];  \\n  while (this.foods[heap.top()[0]].rating !== heap.top()[1]) {\\n    heap.remove();\\n  }\\n  return heap.top()[0];\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar FoodRatings = function(foods, cuisines, ratings) {\\n  this.heaps = {}, this.foods = {};\\n  let n = foods.length;\\n  for (let i = 0; i < n; i++) {\\n    let food = foods[i], cuisine = cuisines[i], rating = ratings[i];\\n    if (!this.heaps[cuisine]) this.heaps[cuisine] = new PriorityQueue((a, b) => { // [food, rating]\\n      return a[1] === b[1] ? a[0].localeCompare(b[0]) : b[1] - a[1];\\n    })\\n    this.heaps[cuisine].add([food, rating]);\\n    this.foods[food] = { cuisine, rating };\\n  } \\n};\\n\\nFoodRatings.prototype.changeRating = function(food, newRating) {\\n  this.foods[food].rating = newRating;\\n  let { cuisine } = this.foods[food];\\n  this.heaps[cuisine].add([food, newRating]);\\n};\\n\\nFoodRatings.prototype.highestRated = function(cuisine) {\\n  let heap = this.heaps[cuisine];  \\n  while (this.foods[heap.top()[0]].rating !== heap.top()[1]) {\\n    heap.remove();\\n  }\\n  return heap.top()[0];\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324702,
                "title": "map-set-c",
                "content": "```\\nclass FoodRatings {\\nprivate:\\n    map<string,int> m;\\n    set<pair<int,string>> f[100];\\n    map<string,pair<int,int>> ff;\\n    int size = 0;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<ratings.size();++i){\\n            \\n            if(m.find(cuisines[i])!= m.end()){\\n                f[m[cuisines[i]]].insert({-1*ratings[i],foods[i]});\\n            }else{\\n                set<int,string> temp;\\n                m[cuisines[i]] = size;\\n                f[size].insert({-1*ratings[i],foods[i]});\\n                ++size;\\n            }\\n            ff[foods[i]] = {ratings[i],m[cuisines[i]]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int nrr) {\\n        pair<int,int> remp = ff[food];\\n        int orr = remp.first, i = remp.second;\\n        f[i].erase({-1*orr,food});\\n        f[i].insert({-1*nrr,food});\\n        ff[food] = {nrr,i};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        int i = m[cuisine];\\n        auto it = f[i].begin();\\n        \\n        pair<int,string> temp = *it;\\n        \\n        return temp.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FoodRatings {\\nprivate:\\n    map<string,int> m;\\n    set<pair<int,string>> f[100];\\n    map<string,pair<int,int>> ff;\\n    int size = 0;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<ratings.size();++i){\\n            \\n            if(m.find(cuisines[i])!= m.end()){\\n                f[m[cuisines[i]]].insert({-1*ratings[i],foods[i]});\\n            }else{\\n                set<int,string> temp;\\n                m[cuisines[i]] = size;\\n                f[size].insert({-1*ratings[i],foods[i]});\\n                ++size;\\n            }\\n            ff[foods[i]] = {ratings[i],m[cuisines[i]]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int nrr) {\\n        pair<int,int> remp = ff[food];\\n        int orr = remp.first, i = remp.second;\\n        f[i].erase({-1*orr,food});\\n        f[i].insert({-1*nrr,food});\\n        ff[food] = {nrr,i};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        int i = m[cuisine];\\n        auto it = f[i].begin();\\n        \\n        pair<int,string> temp = *it;\\n        \\n        return temp.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324676,
                "title": "c-easy-2-maps-with-explanation",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    //cuis -> map[rating -> set[dish]]\\n    map<string, map<int,set<string>>> mc;\\n    //dish -> pair of {rating, cuisine}\\n    map<string, pair<int,string>> md;\\n    FoodRatings(vector<string>& food, vector<string>& cuisine, vector<int>& rating) {\\n        for(int i=0;i<food.size();i++){                      //insert in maps\\n            mc[cuisine[i]][rating[i]].insert(food[i]);\\n            md[food[i]]={rating[i],cuisine[i]};\\n        }\\n    }\\n    \\n    void changeRating(string f, int n) {\\n        if(md.find(f)==md.end()) return;  // if this food don\\'t exsist \\n        auto p=md[f];\\n        int rate=p.first;\\n        string cuise=p.second;\\n        \\n        mc[cuise][rate].erase(f);    //update cuisine map\\n        mc[cuise][n].insert(f);\\n        if(mc[cuise][rate].size()==0) mc[cuise].erase(rate);   //if rate set has size zero, then remove that rating entry for that cuisine\\n        \\n        md[f].first=n;    //update food map\\n    }\\n    \\n    string highestRated(string c) {\\n        if(mc.find(c)==mc.end()) return \"\";   //if cuisine don\\'t exist\\n        auto i = mc[c].rbegin();                // fetch last rating(highest) of that cuisne\\n        auto st=i->second;                    // fetch set (foods) with that rating\\n        return *st.begin();                      // return first food (lexo. smallest)\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    //cuis -> map[rating -> set[dish]]\\n    map<string, map<int,set<string>>> mc;\\n    //dish -> pair of {rating, cuisine}\\n    map<string, pair<int,string>> md;\\n    FoodRatings(vector<string>& food, vector<string>& cuisine, vector<int>& rating) {\\n        for(int i=0;i<food.size();i++){                      //insert in maps\\n            mc[cuisine[i]][rating[i]].insert(food[i]);\\n            md[food[i]]={rating[i],cuisine[i]};\\n        }\\n    }\\n    \\n    void changeRating(string f, int n) {\\n        if(md.find(f)==md.end()) return;  // if this food don\\'t exsist \\n        auto p=md[f];\\n        int rate=p.first;\\n        string cuise=p.second;\\n        \\n        mc[cuise][rate].erase(f);    //update cuisine map\\n        mc[cuise][n].insert(f);\\n        if(mc[cuise][rate].size()==0) mc[cuise].erase(rate);   //if rate set has size zero, then remove that rating entry for that cuisine\\n        \\n        md[f].first=n;    //update food map\\n    }\\n    \\n    string highestRated(string c) {\\n        if(mc.find(c)==mc.end()) return \"\";   //if cuisine don\\'t exist\\n        auto i = mc[c].rbegin();                // fetch last rating(highest) of that cuisne\\n        auto st=i->second;                    // fetch set (foods) with that rating\\n        return *st.begin();                      // return first food (lexo. smallest)\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324670,
                "title": "c-set-map-easy-solution-no-compare-function",
                "content": "```\\n#include <type_traits>\\nclass FoodRatings {\\npublic:\\n \\n    map<string,set<pair<int,string>>>mp;\\n    map<string,pair<string,int>>mp1;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        mp.clear();\\n        mp1.clear();\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            string a = foods[i];\\n            string b = cuisines[i];\\n            int c = ratings[i];\\n            mp1[a]={b,c};\\n            mp[b].insert({c,a});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string a = mp1[food].first;\\n        int b = mp1[food].second;\\n       \\n        mp[a].erase({b,food});\\n        mp[a].insert({newRating,food});\\n        mp1[food]={a,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n\\n        auto s1 = (mp[cuisine].end());\\n        s1--;\\n        int s = s1->first;\\n        auto it = mp[cuisine].lower_bound({s,\"a\"});\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n#include <type_traits>\\nclass FoodRatings {\\npublic:\\n \\n    map<string,set<pair<int,string>>>mp;\\n    map<string,pair<string,int>>mp1;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        mp.clear();\\n        mp1.clear();\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            string a = foods[i];\\n            string b = cuisines[i];\\n            int c = ratings[i];\\n            mp1[a]={b,c};\\n            mp[b].insert({c,a});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string a = mp1[food].first;\\n        int b = mp1[food].second;\\n       \\n        mp[a].erase({b,food});\\n        mp[a].insert({newRating,food});\\n        mp1[food]={a,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n\\n        auto s1 = (mp[cuisine].end());\\n        s1--;\\n        int s = s1->first;\\n        auto it = mp[cuisine].lower_bound({s,\"a\"});\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2324640,
                "title": "hashmap-set-c",
                "content": "```\\nclass FoodRatings {\\nprivate:\\n    struct cmp{\\n        bool operator()(const pair<int,string> &p1,const pair<int,string> &p2) const{\\n            return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;\\n        }\\n    };    \\n    \\n    unordered_map<string,unordered_map<string,int>> mp1; // cuisine -> {food, rating}\\n    unordered_map<string,set<pair<int,string>,cmp>> mp2; // cuisine -> {rating,food} - in decreasing order of rating and incr. order of name\\n    unordered_map<string,string> mp3; // food -> cuisine    \\npublic:    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            auto &mp = mp1[cuisines[i]];\\n            mp[foods[i]] = ratings[i];       \\n            \\n            auto &st = mp2[cuisines[i]];\\n            st.insert({ratings[i],foods[i]});            \\n            \\n            mp3[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto &name = mp3[food];\\n        auto &rating = mp1[name][food];\\n        \\n        auto &st = mp2[name];\\n        st.erase({rating,food});\\n        st.insert({newRating,food});\\n        \\n        mp1[name][food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*(mp2[cuisine].begin())).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\nprivate:\\n    struct cmp{\\n        bool operator()(const pair<int,string> &p1,const pair<int,string> &p2) const{\\n            return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;\\n        }\\n    };    \\n    \\n    unordered_map<string,unordered_map<string,int>> mp1; // cuisine -> {food, rating}\\n    unordered_map<string,set<pair<int,string>,cmp>> mp2; // cuisine -> {rating,food} - in decreasing order of rating and incr. order of name\\n    unordered_map<string,string> mp3; // food -> cuisine    \\npublic:    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            auto &mp = mp1[cuisines[i]];\\n            mp[foods[i]] = ratings[i];       \\n            \\n            auto &st = mp2[cuisines[i]];\\n            st.insert({ratings[i],foods[i]});            \\n            \\n            mp3[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto &name = mp3[food];\\n        auto &rating = mp1[name][food];\\n        \\n        auto &st = mp2[name];\\n        st.erase({rating,food});\\n        st.insert({newRating,food});\\n        \\n        mp1[name][food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*(mp2[cuisine].begin())).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088068,
                "title": "c-python-heap-binary-search-tree-solution-with-explanation",
                "content": "### max heap + lazy remove\\nwe have 3 tables,\\nmx_heap record each cuisine\\'s max heap,\\ncuisines record each food\\'s cuisine,\\nfoods record each food\\'s rating.\\n\\nchangeRating just change food\\'s rating in table foods,\\nand push a new food and new rating pair into max heap.\\n\\nhighestRated find the max rating food in max heap,\\nif rating top of heap != rating in table foods, this pair is invalid, pop it until we meet a valid pair.\\n\\ntc of highestRated and changeRating is O(logn), sc is O(n).\\n\\n### python\\n\\n```python\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.mx_heap = defaultdict(list)\\n        self.cuisines = {}\\n        self.foods = {}\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.mx_heap[c].append((-r, f))\\n            self.cuisines[f] = c\\n            self.foods[f] = r\\n        for h in self.mx_heap.values():\\n            heapify(h)\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.foods[food] = newRating\\n        heappush(self.mx_heap[self.cuisines[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        h = self.mx_heap[cuisine]\\n        while h and -h[0][0] != self.foods[h[0][1]]:\\n            heappop(h)\\n        return h[0][1]\\n```\\n\\n### c++\\n```cpp\\nclass FoodRatings {\\n    unordered_map<string, int> food_;\\n    unordered_map<string, string> cuisine_;\\n    unordered_map<string, priority_queue<pair<int, string>, vector<pair<int, string>>, greater<>>> mn_heap;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); i+=1) {\\n            string& f = foods[i], &c = cuisines[i];\\n            int& r = ratings[i];\\n            food_[f] = r;\\n            cuisine_[f] = c;\\n            mn_heap[c].emplace(-r, f);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        food_[food] = newRating;\\n        mn_heap[cuisine_[food]].emplace(-newRating, food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto& h = mn_heap[cuisine];\\n        while (!h.empty() && -h.top().first != food_[h.top().second])\\n            h.pop();\\n        return h.top().second;\\n    }\\n};\\n```\\n\\n### binary search tree\\n```python\\nfrom sortedcontainers import SortedSet\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.bst = defaultdict(SortedSet)\\n        self.food = {}\\n        self.cuisine = {}\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.cuisine[f] = c\\n            self.food[f] = r\\n            self.bst[c].add((-r, f))\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.bst[self.cuisine[food]].remove((-self.food[food], food))\\n        self.food[food] = newRating\\n        self.bst[self.cuisine[food]].add((-newRating, food));\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.bst[cuisine][0][1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Search Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.mx_heap = defaultdict(list)\\n        self.cuisines = {}\\n        self.foods = {}\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.mx_heap[c].append((-r, f))\\n            self.cuisines[f] = c\\n            self.foods[f] = r\\n        for h in self.mx_heap.values():\\n            heapify(h)\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.foods[food] = newRating\\n        heappush(self.mx_heap[self.cuisines[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        h = self.mx_heap[cuisine]\\n        while h and -h[0][0] != self.foods[h[0][1]]:\\n            heappop(h)\\n        return h[0][1]\\n```\n```cpp\\nclass FoodRatings {\\n    unordered_map<string, int> food_;\\n    unordered_map<string, string> cuisine_;\\n    unordered_map<string, priority_queue<pair<int, string>, vector<pair<int, string>>, greater<>>> mn_heap;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); i+=1) {\\n            string& f = foods[i], &c = cuisines[i];\\n            int& r = ratings[i];\\n            food_[f] = r;\\n            cuisine_[f] = c;\\n            mn_heap[c].emplace(-r, f);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        food_[food] = newRating;\\n        mn_heap[cuisine_[food]].emplace(-newRating, food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto& h = mn_heap[cuisine];\\n        while (!h.empty() && -h.top().first != food_[h.top().second])\\n            h.pop();\\n        return h.top().second;\\n    }\\n};\\n```\n```python\\nfrom sortedcontainers import SortedSet\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.bst = defaultdict(SortedSet)\\n        self.food = {}\\n        self.cuisine = {}\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.cuisine[f] = c\\n            self.food[f] = r\\n            self.bst[c].add((-r, f))\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.bst[self.cuisine[food]].remove((-self.food[food], food))\\n        self.food[food] = newRating\\n        self.bst[self.cuisine[food]].add((-newRating, food));\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.bst[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078961,
                "title": "python3-very-easy-heap-and-lazy-deletion",
                "content": "```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.f2c = {}\\n        self.f2r = defaultdict(int)\\n        self.c2fr = defaultdict(list)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.f2c[f] = c\\n            self.f2r[f] = r\\n            heappush(self.c2fr[c], (-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        if newRating == self.f2r[food]:\\n            return\\n        heap = self.c2fr[self.f2c[food]]\\n        heappush(heap, (-newRating, food))\\n        self.f2r[food] = newRating\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        heap = self.c2fr[cuisine]\\n        while self.f2r[heap[0][1]] != -heap[0][0]:\\n            heappop(heap)\\n        return heap[0][1]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.f2c = {}\\n        self.f2r = defaultdict(int)\\n        self.c2fr = defaultdict(list)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.f2c[f] = c\\n            self.f2r[f] = r\\n            heappush(self.c2fr[c], (-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        if newRating == self.f2r[food]:\\n            return\\n        heap = self.c2fr[self.f2c[food]]\\n        heappush(heap, (-newRating, food))\\n        self.f2r[food] = newRating\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        heap = self.c2fr[cuisine]\\n        while self.f2r[heap[0][1]] != -heap[0][0]:\\n            heappop(heap)\\n        return heap[0][1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014627,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass FoodRatings {\\n\\n    private HashMap<String, TreeMap<Integer, TreeSet<String>>> map;\\n    private HashMap<String, List<String>> pairs;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = initialize(foods, cuisines, ratings);\\n    }\\n\\n    private HashMap<String, TreeMap<Integer, TreeSet<String>>> initialize(String[] food, String[] cuisine, int[] rating) {\\n        pairs = new HashMap<>();\\n        map = new HashMap<>();\\n        for (int i = 0; i < cuisine.length; i++) {\\n            map.putIfAbsent(cuisine[i], new TreeMap<>());\\n            map.get(cuisine[i]).putIfAbsent(rating[i], new TreeSet<>());\\n            map.get(cuisine[i]).get(rating[i]).add(food[i]);\\n            pairs.put(food[i], List.of(String.valueOf(rating[i]), cuisine[i]));\\n        }\\n        return map;\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = pairs.get(food).get(1);\\n        int rating = Integer.parseInt(pairs.get(food).get(0));\\n        pairs.put(food, List.of(String.valueOf(newRating), cuisine));\\n        if (map.get(cuisine).get(rating).size() == 1) {\\n            map.get(cuisine).remove(rating);\\n        } else {\\n            map.get(cuisine).get(rating).remove(food);\\n        }\\n        map.get(cuisine).putIfAbsent(newRating, new TreeSet<>());\\n        map.get(cuisine).get(newRating).add(food);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).get(map.get(cuisine).lastKey()).first();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    private HashMap<String, TreeMap<Integer, TreeSet<String>>> map;\\n    private HashMap<String, List<String>> pairs;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = initialize(foods, cuisines, ratings);\\n    }\\n\\n    private HashMap<String, TreeMap<Integer, TreeSet<String>>> initialize(String[] food, String[] cuisine, int[] rating) {\\n        pairs = new HashMap<>();\\n        map = new HashMap<>();\\n        for (int i = 0; i < cuisine.length; i++) {\\n            map.putIfAbsent(cuisine[i], new TreeMap<>());\\n            map.get(cuisine[i]).putIfAbsent(rating[i], new TreeSet<>());\\n            map.get(cuisine[i]).get(rating[i]).add(food[i]);\\n            pairs.put(food[i], List.of(String.valueOf(rating[i]), cuisine[i]));\\n        }\\n        return map;\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = pairs.get(food).get(1);\\n        int rating = Integer.parseInt(pairs.get(food).get(0));\\n        pairs.put(food, List.of(String.valueOf(newRating), cuisine));\\n        if (map.get(cuisine).get(rating).size() == 1) {\\n            map.get(cuisine).remove(rating);\\n        } else {\\n            map.get(cuisine).get(rating).remove(food);\\n        }\\n        map.get(cuisine).putIfAbsent(newRating, new TreeSet<>());\\n        map.get(cuisine).get(newRating).add(food);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).get(map.get(cuisine).lastKey()).first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967710,
                "title": "java-clean-3-maps-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1) for highestRated\\nO(Log(ratings)) for changeRating\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings {\\n     Map<String, Integer> foodToRating = new HashMap();\\n  Map<String, String> foodToCuisine = new HashMap();\\n  Map<String, TreeMap<Integer, Set<String>>> cuisineToRating = new HashMap();\\n\\n  public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n    for(int i=0; i< foods.length; i++){\\n      var food = foods[i];\\n      var rating = ratings[i];\\n      var cuisine = cuisines[i];\\n      foodToRating.put(food, rating);\\n      foodToCuisine.put(food, cuisine);\\n\\n      cuisineToRating.putIfAbsent(cuisine, new TreeMap(Collections.reverseOrder()));\\n      cuisineToRating.get(cuisine).putIfAbsent(rating, new TreeSet());\\n      cuisineToRating.get(cuisine).get(rating).add(food);\\n\\n    }\\n  }\\n\\n  public void changeRating(String food, int newRating) {\\n    var oldRating = foodToRating.get(food);\\n           if(oldRating==newRating) return;\\n\\n\\n    foodToRating.put(food, newRating);\\n    var cuisine = foodToCuisine.get(food);\\n    cuisineToRating.get(cuisine).putIfAbsent(newRating, new TreeSet());\\n    cuisineToRating.get(cuisine).get(newRating).add(food);\\n\\n    cuisineToRating.get(cuisine).get(oldRating).remove(food);\\n    if(cuisineToRating.get(cuisine).get(oldRating).size()==0){\\n      cuisineToRating.get(cuisine).remove(oldRating);\\n    }\\n  }\\n\\n  public String highestRated(String cuisine) {\\n    Set<String> names = cuisineToRating.get(cuisine).firstEntry().getValue();\\n    return names.iterator().next();\\n  }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n     Map<String, Integer> foodToRating = new HashMap();\\n  Map<String, String> foodToCuisine = new HashMap();\\n  Map<String, TreeMap<Integer, Set<String>>> cuisineToRating = new HashMap();\\n\\n  public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n    for(int i=0; i< foods.length; i++){\\n      var food = foods[i];\\n      var rating = ratings[i];\\n      var cuisine = cuisines[i];\\n      foodToRating.put(food, rating);\\n      foodToCuisine.put(food, cuisine);\\n\\n      cuisineToRating.putIfAbsent(cuisine, new TreeMap(Collections.reverseOrder()));\\n      cuisineToRating.get(cuisine).putIfAbsent(rating, new TreeSet());\\n      cuisineToRating.get(cuisine).get(rating).add(food);\\n\\n    }\\n  }\\n\\n  public void changeRating(String food, int newRating) {\\n    var oldRating = foodToRating.get(food);\\n           if(oldRating==newRating) return;\\n\\n\\n    foodToRating.put(food, newRating);\\n    var cuisine = foodToCuisine.get(food);\\n    cuisineToRating.get(cuisine).putIfAbsent(newRating, new TreeSet());\\n    cuisineToRating.get(cuisine).get(newRating).add(food);\\n\\n    cuisineToRating.get(cuisine).get(oldRating).remove(food);\\n    if(cuisineToRating.get(cuisine).get(oldRating).size()==0){\\n      cuisineToRating.get(cuisine).remove(oldRating);\\n    }\\n  }\\n\\n  public String highestRated(String cuisine) {\\n    Set<String> names = cuisineToRating.get(cuisine).firstEntry().getValue();\\n    return names.iterator().next();\\n  }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922674,
                "title": "heap-hashmap-python3-solution",
                "content": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.rating = {}\\n        self.cuisines = defaultdict(list)\\n        self.food_cuisine = {}\\n        \\n        for i in range(len(foods)):\\n            food, r, cuisine = foods[i], ratings[i], cuisines[i]\\n            self.rating[food] = -r\\n            self.food_cuisine[food] = cuisine\\n            heapq.heappush(self.cuisines[cuisine], (-r, food))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.rating[food] = -newRating\\n        cuisine = self.food_cuisine[food]\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.rating[self.cuisines[cuisine][0][1]] != self.cuisines[cuisine][0][0]:\\n            heapq.heappop(self.cuisines[cuisine])\\n            \\n        return self.cuisines[cuisine][0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python3",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.rating = {}\\n        self.cuisines = defaultdict(list)\\n        self.food_cuisine = {}\\n        \\n        for i in range(len(foods)):\\n            food, r, cuisine = foods[i], ratings[i], cuisines[i]\\n            self.rating[food] = -r\\n            self.food_cuisine[food] = cuisine\\n            heapq.heappush(self.cuisines[cuisine], (-r, food))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.rating[food] = -newRating\\n        cuisine = self.food_cuisine[food]\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.rating[self.cuisines[cuisine][0][1]] != self.cuisines[cuisine][0][0]:\\n            heapq.heappop(self.cuisines[cuisine])\\n            \\n        return self.cuisines[cuisine][0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906313,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass FoodRatings {\\n    HashMap<String,ArrayList<Integer>> cuisineRatingMap;\\n    HashMap<String,HashMap<Integer,TreeMap<String,Integer>>> map;\\n    HashMap<String,String> foodCusineMap=new HashMap<String,String>();\\n    HashMap<String,Integer> foodRatingMap=new HashMap<String,Integer>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineRatingMap=new HashMap<String,ArrayList<Integer>>();\\n        map=new HashMap<String,HashMap<Integer,TreeMap<String,Integer>>>();\\n        for(int i=0;i<foods.length;i++)\\n        {\\n            foodCusineMap.put(foods[i],cuisines[i]);\\n            foodRatingMap.put(foods[i],ratings[i]);\\n            if(!map.containsKey(cuisines[i]))\\n            {\\n                HashMap<Integer,TreeMap<String,Integer>> h=new HashMap<Integer,TreeMap<String,Integer>>();\\n                TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n                tmap.put(foods[i],1);\\n                h.put(ratings[i],tmap);\\n                map.put(cuisines[i],h);\\n            }\\n            else\\n            {\\n                HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisines[i]);\\n                if(h.containsKey(ratings[i]))\\n                {\\n                    TreeMap<String,Integer> tmap=h.get(ratings[i]);\\n                    tmap.put(foods[i],1);\\n                    h.put(ratings[i],tmap);\\n                    map.put(cuisines[i],h);\\n                }\\n                else\\n                {\\n                    TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n                    tmap.put(foods[i],1);\\n                    h.put(ratings[i],tmap);\\n                    map.put(cuisines[i],h);\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<cuisines.length;i++)\\n        {\\n            if(!cuisineRatingMap.containsKey(cuisines[i]))\\n            {\\n                ArrayList<Integer> l=new ArrayList<Integer>();\\n                l.add(ratings[i]);\\n                cuisineRatingMap.put(cuisines[i],l);\\n            }\\n            else\\n            {\\n                ArrayList<Integer> l=cuisineRatingMap.get(cuisines[i]);\\n                int low=0,high=l.size()-1,index=0;\\n                while(low<=high)\\n                {\\n                    int mid=(low+high)/2;\\n                    if(l.get(mid)>ratings[i])\\n                    {\\n                        index=mid;\\n                        high=mid-1;\\n                    }\\n                    else\\n                    {\\n                        index=mid+1;\\n                        low=mid+1;\\n                    }\\n                }\\n                l.add(index,ratings[i]);\\n                cuisineRatingMap.put(cuisines[i],l);\\n            }\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine=foodCusineMap.get(food);\\n        int prevRating=foodRatingMap.get(food);\\n        foodRatingMap.put(food,newRating);\\n        ArrayList<Integer> l=cuisineRatingMap.get(cuisine);\\n        int low=0,high=l.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(l.get(mid)==prevRating)\\n            {\\n                l.remove(mid);\\n                break;\\n            }\\n            else if(l.get(mid)>prevRating)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        low=0;\\n        high=l.size()-1;\\n        int index=0;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(l.get(mid)>newRating)\\n            {\\n                index=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                index=mid+1;\\n                low=mid+1;\\n            }\\n        }\\n        l.add(index,newRating);\\n        cuisineRatingMap.put(cuisine,l);\\n        HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisine);\\n        h.get(prevRating).remove(food);\\n        if(h.get(prevRating).size()==0)\\n        {\\n            h.remove(prevRating);\\n        }\\n        if(!h.containsKey(newRating))\\n        {\\n            TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n            tmap.put(food,1);\\n            h.put(newRating,tmap);\\n        }\\n        else\\n        {\\n            TreeMap<String,Integer> tmap=h.get(newRating);\\n            tmap.put(food,1);\\n            h.put(newRating,tmap);\\n        }\\n         map.put(cuisine,h);\\n        \\n\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        ArrayList<Integer> l=cuisineRatingMap.get(cuisine);\\n        int highestRating= l.get(l.size()-1);\\n        HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisine);\\n        return h.get(highestRating).firstKey();\\n\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n    HashMap<String,ArrayList<Integer>> cuisineRatingMap;\\n    HashMap<String,HashMap<Integer,TreeMap<String,Integer>>> map;\\n    HashMap<String,String> foodCusineMap=new HashMap<String,String>();\\n    HashMap<String,Integer> foodRatingMap=new HashMap<String,Integer>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineRatingMap=new HashMap<String,ArrayList<Integer>>();\\n        map=new HashMap<String,HashMap<Integer,TreeMap<String,Integer>>>();\\n        for(int i=0;i<foods.length;i++)\\n        {\\n            foodCusineMap.put(foods[i],cuisines[i]);\\n            foodRatingMap.put(foods[i],ratings[i]);\\n            if(!map.containsKey(cuisines[i]))\\n            {\\n                HashMap<Integer,TreeMap<String,Integer>> h=new HashMap<Integer,TreeMap<String,Integer>>();\\n                TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n                tmap.put(foods[i],1);\\n                h.put(ratings[i],tmap);\\n                map.put(cuisines[i],h);\\n            }\\n            else\\n            {\\n                HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisines[i]);\\n                if(h.containsKey(ratings[i]))\\n                {\\n                    TreeMap<String,Integer> tmap=h.get(ratings[i]);\\n                    tmap.put(foods[i],1);\\n                    h.put(ratings[i],tmap);\\n                    map.put(cuisines[i],h);\\n                }\\n                else\\n                {\\n                    TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n                    tmap.put(foods[i],1);\\n                    h.put(ratings[i],tmap);\\n                    map.put(cuisines[i],h);\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<cuisines.length;i++)\\n        {\\n            if(!cuisineRatingMap.containsKey(cuisines[i]))\\n            {\\n                ArrayList<Integer> l=new ArrayList<Integer>();\\n                l.add(ratings[i]);\\n                cuisineRatingMap.put(cuisines[i],l);\\n            }\\n            else\\n            {\\n                ArrayList<Integer> l=cuisineRatingMap.get(cuisines[i]);\\n                int low=0,high=l.size()-1,index=0;\\n                while(low<=high)\\n                {\\n                    int mid=(low+high)/2;\\n                    if(l.get(mid)>ratings[i])\\n                    {\\n                        index=mid;\\n                        high=mid-1;\\n                    }\\n                    else\\n                    {\\n                        index=mid+1;\\n                        low=mid+1;\\n                    }\\n                }\\n                l.add(index,ratings[i]);\\n                cuisineRatingMap.put(cuisines[i],l);\\n            }\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine=foodCusineMap.get(food);\\n        int prevRating=foodRatingMap.get(food);\\n        foodRatingMap.put(food,newRating);\\n        ArrayList<Integer> l=cuisineRatingMap.get(cuisine);\\n        int low=0,high=l.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(l.get(mid)==prevRating)\\n            {\\n                l.remove(mid);\\n                break;\\n            }\\n            else if(l.get(mid)>prevRating)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        low=0;\\n        high=l.size()-1;\\n        int index=0;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(l.get(mid)>newRating)\\n            {\\n                index=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                index=mid+1;\\n                low=mid+1;\\n            }\\n        }\\n        l.add(index,newRating);\\n        cuisineRatingMap.put(cuisine,l);\\n        HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisine);\\n        h.get(prevRating).remove(food);\\n        if(h.get(prevRating).size()==0)\\n        {\\n            h.remove(prevRating);\\n        }\\n        if(!h.containsKey(newRating))\\n        {\\n            TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n            tmap.put(food,1);\\n            h.put(newRating,tmap);\\n        }\\n        else\\n        {\\n            TreeMap<String,Integer> tmap=h.get(newRating);\\n            tmap.put(food,1);\\n            h.put(newRating,tmap);\\n        }\\n         map.put(cuisine,h);\\n        \\n\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        ArrayList<Integer> l=cuisineRatingMap.get(cuisine);\\n        int highestRating= l.get(l.size()-1);\\n        HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisine);\\n        return h.get(highestRating).firstKey();\\n\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894400,
                "title": "solution-via-a-ptr-to-structure",
                "content": "# Intuition\\nLet\\'s have a look at the required Interface. We have to implement 2 functions.\\nhighestRated - supposed to return best in cuisine, so it leads to the thought that it would be nice to take this value from some container that is already sorted. Since we get as an argument about cuisine, the container is supposed to be like cuisine - set<Food*>. For Food* we can use sort of a structure with overwritten operator<(or something similar).\\nAs fields we can take name and rating since they both take part in comparison\\\\sorting.\\nWe only need to take care of updating it in the set.\\n <!-- Describe your first thoughts on how to solve this problem. -->\\n\\n # Approach\\n The real issue comes when we want to update our rating.\\n 1. We need to have an access cuisine - set<Food*> when we update. So this \\n particular struct Food* has to be found in the whole structure(cuisine - set<Food*>).\\n 2. Even if we have Food* we still need to know the cuisine to know in which set we shall seek.\\n\\n Since changeRating accepts food\\'s name, we can connect food - Food* as well.\\n Thus we get by 1nd obstacle. The 2nd obstacle can be managed by adding cuisine to the field of Food*. Thus knowing the name of food, we can access it in cuisine - set<Food*>. Having access we can simply remove, update Food* ptr with a new rating(no need to create a new object), and insert it back.\\n\\n We end up with 2 containers:\\n <food - Food*> m_foods;\\n <cusine - set<Food*>> m_chart;\\n For both, unordered_map is a good solution. (Since we need mostly to find elements)\\n\\n For putting Food* (pointers) in the set, we also will write a custom comparator with the overloaded operator() for the set. Implementation of operator() has logic described in the task itself(bigger rating first but if ratings are same, return lexically higher).\\n\\n <!-- Describe your approach to solving the problem. -->\\n\\n # Complexity\\n - Time complexity:\\n - FoodRatings - O(n * log n)\\n We have a cycle, and on each iteration, we have log i complexity. We have log i complexity because we insert in set, and the worst case is when we have only one type of kitchen. It leads to Log(1*2*3*..n) -> (Stirling\\'s formula, approx.) = n log(n). \\n - changeRating - O(log n).\\n Delete and insert have O(log n) complexity, all the rest is constant.\\n - highestRated - O(1).\\n <!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n), to be more precise O(2n) since we have 2 unordered_maps + ~O(3n)\\n- space for Food struct. And don\\'t forget to clean up the space in the real world or wrap up raw pointers!\\n <!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings {\\n    struct Food{\\n        string name;\\n        string cusine;\\n        int rating;\\n\\n        Food(){\\n        }\\n\\n        Food(const string& _name, int _rating, const string& _cusine){\\n            name = _name;\\n            rating = _rating;\\n            cusine = _cusine;\\n        }\\n    };\\n\\n    struct CustomCmp {\\n    bool operator()(const Food* lhs, const Food* rhs) const { \\n            if(lhs->rating == rhs->rating)\\n                return lhs->name < rhs->name;\\n            return lhs->rating > rhs->rating;\\n    }\\n};\\n    unordered_map<string, Food*> m_cuisines; // food Food*\\n    unordered_map<string, set<Food*, CustomCmp>> m_chart; // cousine - set(of foods*)\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0; i != foods.size(); ++i){\\n            Food* f = new Food(foods[i], ratings[i], cuisines[i]);\\n            m_cuisines[foods[i]] = f;\\n            m_chart[cuisines[i]].insert(f);\\n        }\\n    }\\n\\n    void changeRating(const string &food, int newRating) {\\n        auto f = m_cuisines[food];\\n        m_chart[f->cusine].erase(f);\\n        f->rating = newRating;\\n        m_chart[f->cusine].insert(f);\\n\\n    }\\n\\n    string highestRated(const string& cuisine) {\\n        return (*m_chart[cuisine].begin())->name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\n    struct Food{\\n        string name;\\n        string cusine;\\n        int rating;\\n\\n        Food(){\\n        }\\n\\n        Food(const string& _name, int _rating, const string& _cusine){\\n            name = _name;\\n            rating = _rating;\\n            cusine = _cusine;\\n        }\\n    };\\n\\n    struct CustomCmp {\\n    bool operator()(const Food* lhs, const Food* rhs) const { \\n            if(lhs->rating == rhs->rating)\\n                return lhs->name < rhs->name;\\n            return lhs->rating > rhs->rating;\\n    }\\n};\\n    unordered_map<string, Food*> m_cuisines; // food Food*\\n    unordered_map<string, set<Food*, CustomCmp>> m_chart; // cousine - set(of foods*)\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0; i != foods.size(); ++i){\\n            Food* f = new Food(foods[i], ratings[i], cuisines[i]);\\n            m_cuisines[foods[i]] = f;\\n            m_chart[cuisines[i]].insert(f);\\n        }\\n    }\\n\\n    void changeRating(const string &food, int newRating) {\\n        auto f = m_cuisines[food];\\n        m_chart[f->cusine].erase(f);\\n        f->rating = newRating;\\n        m_chart[f->cusine].insert(f);\\n\\n    }\\n\\n    string highestRated(const string& cuisine) {\\n        return (*m_chart[cuisine].begin())->name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834831,
                "title": "c-faster-than-100-using-2-maps",
                "content": "```\\n#define pii pair<int,string>\\nclass Compare\\n{\\npublic:\\n    bool operator() (pii p1,pii p2)\\n    {\\n        if(p1.first<p2.first)\\n            return true;\\n        else if(p1.first==p2.first)\\n        {\\n            return (p1.second>p2.second);\\n        }\\n        return false;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,pair<int,string>>m;\\n    unordered_map<string,priority_queue<pii,vector<pii>,Compare>>mcu;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<f.size();i++)\\n        {\\n            m[f[i]]={r[i],c[i]};\\n            mcu[c[i]].push({r[i],f[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[food].first=newRating;\\n        mcu[m[food].second].push({newRating,food});\\n    }\\n    \\n    string highestRated(string c) {\\n        \\n        while(!mcu[c].empty())\\n        {\\n            auto [rating,food]=mcu[c].top();\\n            if(m[food].first!=rating)\\n                mcu[c].pop();\\n            else\\n            {\\n                return food;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n#define pii pair<int,string>\\nclass Compare\\n{\\npublic:\\n    bool operator() (pii p1,pii p2)\\n    {\\n        if(p1.first<p2.first)\\n            return true;\\n        else if(p1.first==p2.first)\\n        {\\n            return (p1.second>p2.second);\\n        }\\n        return false;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,pair<int,string>>m;\\n    unordered_map<string,priority_queue<pii,vector<pii>,Compare>>mcu;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<f.size();i++)\\n        {\\n            m[f[i]]={r[i],c[i]};\\n            mcu[c[i]].push({r[i],f[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[food].first=newRating;\\n        mcu[m[food].second].push({newRating,food});\\n    }\\n    \\n    string highestRated(string c) {\\n        \\n        while(!mcu[c].empty())\\n        {\\n            auto [rating,food]=mcu[c].top();\\n            if(m[food].first!=rating)\\n                mcu[c].pop();\\n            else\\n            {\\n                return food;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3757385,
                "title": "java-easy-change-rating-o-log-n-highestrated-o-1-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThinking in faster retrival perspective, Constructor initalized one time can take more time to load. Post construct, methods should return result faster.\\n\\nUsed multiple `hashtable` to know `cuisine` against `food`, `rating` aginst `food` and `food-rating` collection against `cuisine` (Collections thought for faster response of `highestRated` method.).\\n\\nPriorityQueue for storing food rating in sorted manner\\n`new PriorityQueue<FoodRating>((p1, p2) -> (p1.rating==p2.rating) ? p1.food.compareTo(p2.food) : p2.rating-p1.rating)`\\n\\n# Complexity\\n- Time complexity: $$Constructor = O(n*log(n) \\n- changeRating = O(log(n)) \\n- highestRated = O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings {\\n\\n    class FoodRating {\\n        String food;\\n        int rating;\\n        FoodRating(String food, int rating){\\n            this.food = food;\\n            this.rating = rating;\\n        }\\n    }\\n\\n    Map<String, String> foodCuisineMap = new HashMap<>();\\n    Map<String, FoodRating> foodRatingMap = new HashMap<>();\\n    Map<String, PriorityQueue<FoodRating>> cuisineFoodRatingMap \\n        = new HashMap<>();\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodRatingMap = new HashMap<>();\\n        cuisineFoodRatingMap = new HashMap<>();\\n        foodCuisineMap = new HashMap<>();\\n\\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            foodCuisineMap.put(foods[i], cuisines[i]);\\n            FoodRating fr = new FoodRating(foods[i], ratings[i]);\\n            foodRatingMap.put(foods[i], fr);\\n            PriorityQueue<FoodRating> pq = cuisineFoodRatingMap.getOrDefault(cuisines[i], new PriorityQueue<FoodRating>((p1, p2) -> (p1.rating==p2.rating) ? p1.food.compareTo(p2.food) : p2.rating-p1.rating));\\n            pq.offer(fr);\\n            cuisineFoodRatingMap.put(cuisines[i], pq);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        \\n        FoodRating foodRatingInstance = foodRatingMap.get(food);\\n        String cuisine = foodCuisineMap.get(food);\\n        \\n        PriorityQueue<FoodRating> pq = cuisineFoodRatingMap.get(cuisine);\\n        pq.remove(foodRatingInstance);\\n\\n        FoodRating newInstance = new FoodRating(food, newRating);\\n        pq.offer(newInstance); \\n\\n        cuisineFoodRatingMap.put(food, pq);\\n        foodRatingMap.put(food, newInstance);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineFoodRatingMap.get(cuisine).peek().food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    class FoodRating {\\n        String food;\\n        int rating;\\n        FoodRating(String food, int rating){\\n            this.food = food;\\n            this.rating = rating;\\n        }\\n    }\\n\\n    Map<String, String> foodCuisineMap = new HashMap<>();\\n    Map<String, FoodRating> foodRatingMap = new HashMap<>();\\n    Map<String, PriorityQueue<FoodRating>> cuisineFoodRatingMap \\n        = new HashMap<>();\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodRatingMap = new HashMap<>();\\n        cuisineFoodRatingMap = new HashMap<>();\\n        foodCuisineMap = new HashMap<>();\\n\\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            foodCuisineMap.put(foods[i], cuisines[i]);\\n            FoodRating fr = new FoodRating(foods[i], ratings[i]);\\n            foodRatingMap.put(foods[i], fr);\\n            PriorityQueue<FoodRating> pq = cuisineFoodRatingMap.getOrDefault(cuisines[i], new PriorityQueue<FoodRating>((p1, p2) -> (p1.rating==p2.rating) ? p1.food.compareTo(p2.food) : p2.rating-p1.rating));\\n            pq.offer(fr);\\n            cuisineFoodRatingMap.put(cuisines[i], pq);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        \\n        FoodRating foodRatingInstance = foodRatingMap.get(food);\\n        String cuisine = foodCuisineMap.get(food);\\n        \\n        PriorityQueue<FoodRating> pq = cuisineFoodRatingMap.get(cuisine);\\n        pq.remove(foodRatingInstance);\\n\\n        FoodRating newInstance = new FoodRating(food, newRating);\\n        pq.offer(newInstance); \\n\\n        cuisineFoodRatingMap.put(food, pq);\\n        foodRatingMap.put(food, newInstance);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineFoodRatingMap.get(cuisine).peek().food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686669,
                "title": "ordered-unordered-set-and-maps-red",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,string> fc; \\n    unordered_map<string,int> fr;\\n    unordered_map<string,map<int,set<string>,greater<int>>> built;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n        // food to cuisine\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            fc[foods[i]]=cuisines[i];\\n            fr[foods[i]]=ratings[i];\\n            built[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        built[fc[food]][fr[food]].erase(food); // erase food from previous rating \\n        if(built[fc[food]][fr[food]].empty())\\n        {\\n            built[fc[food]].erase(fr[food]);\\n        }\\n        \\n        built[fc[food]][newRating].insert(food);  // insert food from new rating \\n        fr[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        return *built[cuisine].begin()->second.begin();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,string> fc; \\n    unordered_map<string,int> fr;\\n    unordered_map<string,map<int,set<string>,greater<int>>> built;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n        // food to cuisine\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            fc[foods[i]]=cuisines[i];\\n            fr[foods[i]]=ratings[i];\\n            built[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        built[fc[food]][fr[food]].erase(food); // erase food from previous rating \\n        if(built[fc[food]][fr[food]].empty())\\n        {\\n            built[fc[food]].erase(fr[food]);\\n        }\\n        \\n        built[fc[food]][newRating].insert(food);  // insert food from new rating \\n        fr[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        return *built[cuisine].begin()->second.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638815,
                "title": "simple-solution-using-sortedset-red-black-tree-in-c",
                "content": "### Time complexity \\n    => O(NLOGN) => initialzaiton\\n    => O(1) HighestRated => OLOGN for ChangeRating\\n  sortedset add operation takes O(LogN) time\\n  Therefore,  during initialization it takes O(NLogN) time beacuase of for loop and sortedset element addition\\n\\n# Code\\n```\\npublic class FoodRatings {\\n\\n // custom comparer class is required because we want to sort our red-black tree or sorted set \\n//in such a way that lexicographical ordering is followed.\\n     class Cmp:IComparer<(int r, string f)> {\\n        public int Compare((int r, string f) o1, (int r, string f) o2) {\\n            if(o1.r > o2.r) return 1;\\n            else if(o1.r < o2.r) return -1;\\n            else {\\n                return o2.f.CompareTo(o1.f);\\n            }\\n        }\\n    }\\n\\n    private Dictionary<string, SortedSet<(int rating, string food)>> map;\\n    private Dictionary<string, int> mapFood;\\n    private Dictionary<string ,string> mapFoodKit;\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings) {\\n        map = new Dictionary<string, SortedSet<(int, string)>>();\\n        mapFood = new Dictionary<string, int>();\\n         mapFoodKit = new Dictionary<string, string>();\\n        for(int i=0;i<foods.Length;i++){\\n             mapFood[foods[i]] = ratings[i];\\n            mapFoodKit[foods[i]] = cuisines[i];\\n            if(map.ContainsKey(cuisines[i])){\\n                 map[cuisines[i]].Add((ratings[i], foods[i]));\\n            }\\n            else{\\n                SortedSet<(int rating, string food)> s = new SortedSet<(int, string)>(new Cmp());\\n                s.Add((ratings[i], foods[i]));\\n                map.Add(cuisines[i], s);\\n            }\\n        }\\n    }\\n    \\n    public void ChangeRating(string food, int newRating) {\\n        if(mapFood.ContainsKey(food)){\\n            int ir = mapFood[food];\\n            mapFood[food] = newRating;\\n            string cuisine = mapFoodKit[food];\\n            var s = map[cuisine];\\n             s.Remove((ir, food));\\n             s.Add((newRating, food));\\n        }\\n    }\\n    \\n    public string HighestRated(string cuisine) {\\n        var s = map[cuisine].Max;\\n        return s.food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.ChangeRating(food,newRating);\\n * string param_2 = obj.HighestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Ordered Set"
                ],
                "code": "```\\npublic class FoodRatings {\\n\\n // custom comparer class is required because we want to sort our red-black tree or sorted set \\n//in such a way that lexicographical ordering is followed.\\n     class Cmp:IComparer<(int r, string f)> {\\n        public int Compare((int r, string f) o1, (int r, string f) o2) {\\n            if(o1.r > o2.r) return 1;\\n            else if(o1.r < o2.r) return -1;\\n            else {\\n                return o2.f.CompareTo(o1.f);\\n            }\\n        }\\n    }\\n\\n    private Dictionary<string, SortedSet<(int rating, string food)>> map;\\n    private Dictionary<string, int> mapFood;\\n    private Dictionary<string ,string> mapFoodKit;\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings) {\\n        map = new Dictionary<string, SortedSet<(int, string)>>();\\n        mapFood = new Dictionary<string, int>();\\n         mapFoodKit = new Dictionary<string, string>();\\n        for(int i=0;i<foods.Length;i++){\\n             mapFood[foods[i]] = ratings[i];\\n            mapFoodKit[foods[i]] = cuisines[i];\\n            if(map.ContainsKey(cuisines[i])){\\n                 map[cuisines[i]].Add((ratings[i], foods[i]));\\n            }\\n            else{\\n                SortedSet<(int rating, string food)> s = new SortedSet<(int, string)>(new Cmp());\\n                s.Add((ratings[i], foods[i]));\\n                map.Add(cuisines[i], s);\\n            }\\n        }\\n    }\\n    \\n    public void ChangeRating(string food, int newRating) {\\n        if(mapFood.ContainsKey(food)){\\n            int ir = mapFood[food];\\n            mapFood[food] = newRating;\\n            string cuisine = mapFoodKit[food];\\n            var s = map[cuisine];\\n             s.Remove((ir, food));\\n             s.Add((newRating, food));\\n        }\\n    }\\n    \\n    public string HighestRated(string cuisine) {\\n        var s = map[cuisine].Max;\\n        return s.food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.ChangeRating(food,newRating);\\n * string param_2 = obj.HighestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633839,
                "title": "swift-sorted-array-implementation",
                "content": "# Swift: Two Maps\\n```\\nstruct FoodRating: Comparable {\\n    let name: String\\n    let rating: Int\\n\\n    static func < (lhs: Self, rhs: Self) -> Bool {\\n        (lhs.rating, lhs.name) < (rhs.rating, rhs.name)\\n    }\\n\\n    static func == (lhs: Self, rhs: Self) -> Bool {\\n        (lhs.rating, lhs.name) == (rhs.rating, rhs.name)\\n    }\\n}\\n\\nclass FoodRatings {\\n    var foodRating: [String: SortedArray<FoodRating>]\\n    var foodStat: [String: (String, Int)]\\n    init(_ foods: [String], _ cuisines: [String], _ ratings: [Int]) {\\n        foodRating = [:]\\n        foodStat = [:]\\n        for (cuisine, (food, rating)) in zip(cuisines, zip(foods, ratings)) {\\n            foodRating[cuisine, default: SortedArray()].insert(FoodRating(name: food, rating: -rating))\\n            foodStat[food] = (cuisine, -rating)\\n        }\\n    }\\n    \\n    func changeRating(_ food: String, _ newRating: Int) {\\n        let (cuisine, rating) = foodStat[food]!\\n        foodStat[food] = (cuisine, -newRating)\\n        foodRating[cuisine]!.remove(FoodRating(name: food, rating: rating))\\n        foodRating[cuisine]!.insert(FoodRating(name: food, rating: -newRating))\\n    }\\n    \\n    func highestRated(_ cuisine: String) -> String {\\n        foodRating[cuisine]!.min()!.name\\n    }\\n}\\n\\nstruct SortedArray<T: Comparable> {\\n    private var arr: [T]\\n    var count: Int {\\n        arr.count\\n    }\\n    init(_ arr: [T]? = []) {\\n        self.arr = []\\n        for ele in arr ?? [] {\\n            self.insert(ele)\\n        }\\n    }\\n    \\n    mutating func insert(_ element: T) {\\n        let i = bisectRight(element)\\n        arr.insert(element, at: i)\\n    }\\n    \\n    mutating func remove(_ value: T) {\\n        let i = bisectRight(value) - 1\\n        arr.remove(at: i)\\n    }\\n    \\n    private func bisectRight(_ target: T) -> Int {\\n        var (lo, hi) = (0, count)\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2\\n            if arr[mid] <= target {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        return lo\\n    }\\n    \\n    func min() -> T? {\\n        arr.min()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nstruct FoodRating: Comparable {\\n    let name: String\\n    let rating: Int\\n\\n    static func < (lhs: Self, rhs: Self) -> Bool {\\n        (lhs.rating, lhs.name) < (rhs.rating, rhs.name)\\n    }\\n\\n    static func == (lhs: Self, rhs: Self) -> Bool {\\n        (lhs.rating, lhs.name) == (rhs.rating, rhs.name)\\n    }\\n}\\n\\nclass FoodRatings {\\n    var foodRating: [String: SortedArray<FoodRating>]\\n    var foodStat: [String: (String, Int)]\\n    init(_ foods: [String], _ cuisines: [String], _ ratings: [Int]) {\\n        foodRating = [:]\\n        foodStat = [:]\\n        for (cuisine, (food, rating)) in zip(cuisines, zip(foods, ratings)) {\\n            foodRating[cuisine, default: SortedArray()].insert(FoodRating(name: food, rating: -rating))\\n            foodStat[food] = (cuisine, -rating)\\n        }\\n    }\\n    \\n    func changeRating(_ food: String, _ newRating: Int) {\\n        let (cuisine, rating) = foodStat[food]!\\n        foodStat[food] = (cuisine, -newRating)\\n        foodRating[cuisine]!.remove(FoodRating(name: food, rating: rating))\\n        foodRating[cuisine]!.insert(FoodRating(name: food, rating: -newRating))\\n    }\\n    \\n    func highestRated(_ cuisine: String) -> String {\\n        foodRating[cuisine]!.min()!.name\\n    }\\n}\\n\\nstruct SortedArray<T: Comparable> {\\n    private var arr: [T]\\n    var count: Int {\\n        arr.count\\n    }\\n    init(_ arr: [T]? = []) {\\n        self.arr = []\\n        for ele in arr ?? [] {\\n            self.insert(ele)\\n        }\\n    }\\n    \\n    mutating func insert(_ element: T) {\\n        let i = bisectRight(element)\\n        arr.insert(element, at: i)\\n    }\\n    \\n    mutating func remove(_ value: T) {\\n        let i = bisectRight(value) - 1\\n        arr.remove(at: i)\\n    }\\n    \\n    private func bisectRight(_ target: T) -> Int {\\n        var (lo, hi) = (0, count)\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2\\n            if arr[mid] <= target {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        return lo\\n    }\\n    \\n    func min() -> T? {\\n        arr.min()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557765,
                "title": "easy-solution-using-priorityqueue-and-hashmap-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Food {\\n    int rating;\\n    String food,cuisine;\\n    Food(String food,String cuisine,int rating){\\n        this.rating = rating;\\n        this.food = food;\\n        this.cuisine = cuisine;\\n    }\\n}\\nclass FoodRatings {\\n    Map<String,PriorityQueue<Food>> cuisineMap;\\n    Map<String,Food> foodMap;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n       cuisineMap = new HashMap<>();\\n       foodMap = new HashMap<>();\\n       for(int i=0;i<foods.length;i++){\\n           Food f = new Food(foods[i],cuisines[i],ratings[i]);\\n            cuisineMap.putIfAbsent(cuisines[i],new PriorityQueue<>((a,b) -> b.rating == a.rating ? a.food.compareTo(b.food) : b.rating - a.rating));\\n            PriorityQueue pq = cuisineMap.get(cuisines[i]);\\n            pq.add(f);\\n            foodMap.put(foods[i],f);\\n       }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food f = foodMap.get(food);\\n        PriorityQueue pq = cuisineMap.get(f.cuisine);\\n        pq.remove(f);\\n        f.rating = newRating;\\n        pq.add(f);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).peek().food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n /*             TLE             */\\n /*\\n class Node <String,Integer>{\\n    private String cuisine;\\n    private int rating;\\n    Node(String cuisine,int rating){\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public void setCuisine(String cuisine){\\n        this.cuisine = cuisine;\\n    }\\n    public String getCuisine(){\\n        return this.cuisine;\\n    }\\n    public void setRating(int rating){\\n        this.rating = rating;\\n    }\\n    public int getRating(){\\n        return this.rating;\\n    }\\n}\\nclass FoodRatings {\\n    HashMap<String,Node<String,Integer>> food; // SC : O (length of foods array)\\n    HashMap<String,List<String>> cuisineToFood; // Sc : O(length of cuisine)\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        food = new HashMap<>();\\n        cuisineToFood = new HashMap<>();\\n        for(int i=0;i<foods.length;i++){\\n            Node<String,Integer> p = new Node<>(cuisines[i],ratings[i]);\\n            food.put(foods[i],p);\\n            if(!cuisineToFood.containsKey(cuisines[i])){\\n                cuisineToFood.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineToFood.get(cuisines[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food1, int newRating) {\\n        food.get(food1).setRating(newRating);\\n        // TC : O(1)\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Node<String,Integer>> pq = new PriorityQueue<>((a,b) -> b.getRating() - a.getRating());\\n        for(String f : cuisineToFood.get(cuisine)){\\n                pq.offer(new Node<>(f,food.get(f).getRating()));\\n        }\\n        List<String> list = new ArrayList<>();\\n        if(!pq.isEmpty()){\\n            int highVal = pq.peek().getRating();\\n            list.add(pq.remove().getCuisine());\\n            while(!pq.isEmpty() && pq.peek().getRating() == highVal){\\n                list.add(pq.remove().getCuisine());\\n            }\\n            Collections.sort(list);\\n        }\\n        if(list.size() > 0){\\n            return list.get(0);\\n        }\\n        return \"\";\\n    }\\n}\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Food {\\n    int rating;\\n    String food,cuisine;\\n    Food(String food,String cuisine,int rating){\\n        this.rating = rating;\\n        this.food = food;\\n        this.cuisine = cuisine;\\n    }\\n}\\nclass FoodRatings {\\n    Map<String,PriorityQueue<Food>> cuisineMap;\\n    Map<String,Food> foodMap;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n       cuisineMap = new HashMap<>();\\n       foodMap = new HashMap<>();\\n       for(int i=0;i<foods.length;i++){\\n           Food f = new Food(foods[i],cuisines[i],ratings[i]);\\n            cuisineMap.putIfAbsent(cuisines[i],new PriorityQueue<>((a,b) -> b.rating == a.rating ? a.food.compareTo(b.food) : b.rating - a.rating));\\n            PriorityQueue pq = cuisineMap.get(cuisines[i]);\\n            pq.add(f);\\n            foodMap.put(foods[i],f);\\n       }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food f = foodMap.get(food);\\n        PriorityQueue pq = cuisineMap.get(f.cuisine);\\n        pq.remove(f);\\n        f.rating = newRating;\\n        pq.add(f);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).peek().food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n /*             TLE             */\\n /*\\n class Node <String,Integer>{\\n    private String cuisine;\\n    private int rating;\\n    Node(String cuisine,int rating){\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public void setCuisine(String cuisine){\\n        this.cuisine = cuisine;\\n    }\\n    public String getCuisine(){\\n        return this.cuisine;\\n    }\\n    public void setRating(int rating){\\n        this.rating = rating;\\n    }\\n    public int getRating(){\\n        return this.rating;\\n    }\\n}\\nclass FoodRatings {\\n    HashMap<String,Node<String,Integer>> food; // SC : O (length of foods array)\\n    HashMap<String,List<String>> cuisineToFood; // Sc : O(length of cuisine)\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        food = new HashMap<>();\\n        cuisineToFood = new HashMap<>();\\n        for(int i=0;i<foods.length;i++){\\n            Node<String,Integer> p = new Node<>(cuisines[i],ratings[i]);\\n            food.put(foods[i],p);\\n            if(!cuisineToFood.containsKey(cuisines[i])){\\n                cuisineToFood.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineToFood.get(cuisines[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food1, int newRating) {\\n        food.get(food1).setRating(newRating);\\n        // TC : O(1)\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Node<String,Integer>> pq = new PriorityQueue<>((a,b) -> b.getRating() - a.getRating());\\n        for(String f : cuisineToFood.get(cuisine)){\\n                pq.offer(new Node<>(f,food.get(f).getRating()));\\n        }\\n        List<String> list = new ArrayList<>();\\n        if(!pq.isEmpty()){\\n            int highVal = pq.peek().getRating();\\n            list.add(pq.remove().getCuisine());\\n            while(!pq.isEmpty() && pq.peek().getRating() == highVal){\\n                list.add(pq.remove().getCuisine());\\n            }\\n            Collections.sort(list);\\n        }\\n        if(list.size() > 0){\\n            return list.get(0);\\n        }\\n        return \"\";\\n    }\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549644,
                "title": "java-solution-using-hashmap-and-treemap",
                "content": "# Code\\n```\\nclass FoodRatings {\\n\\n    private Map<String, Map<String, Integer>> map;\\n    private Map<String, String> mapFC;\\n    private TreeMap<Integer, TreeMap<String, String>> mapR;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        mapFC = new HashMap<>();\\n        mapR = new TreeMap<>(Comparator.reverseOrder());\\n        for (int i = 0; i < foods.length; i++) {\\n            if (!map.containsKey(cuisines[i])) map.put(cuisines[i], new TreeMap<>());\\n            map.get(cuisines[i]).put(foods[i], ratings[i]);\\n            mapFC.put(foods[i], cuisines[i]);\\n\\n            if (!mapR.containsKey(ratings[i])) mapR.put(ratings[i], new TreeMap<>());\\n            mapR.get(ratings[i]).put(foods[i], cuisines[i]);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = mapFC.get(food);\\n        int oldRating = map.get(cuisine).get(food);\\n        map.get(cuisine).put(food, newRating);\\n\\n        mapR.get(oldRating).remove(food);\\n        if (!mapR.containsKey(newRating)) mapR.put(newRating, new TreeMap<>());\\n        mapR.get(newRating).put(food, cuisine);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        for (int r : mapR.keySet()) {\\n            Map<String, String> map1 = mapR.get(r);\\n            for (String food : map1.keySet()) if (map1.get(food).equals(cuisine)) return food;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    private Map<String, Map<String, Integer>> map;\\n    private Map<String, String> mapFC;\\n    private TreeMap<Integer, TreeMap<String, String>> mapR;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        mapFC = new HashMap<>();\\n        mapR = new TreeMap<>(Comparator.reverseOrder());\\n        for (int i = 0; i < foods.length; i++) {\\n            if (!map.containsKey(cuisines[i])) map.put(cuisines[i], new TreeMap<>());\\n            map.get(cuisines[i]).put(foods[i], ratings[i]);\\n            mapFC.put(foods[i], cuisines[i]);\\n\\n            if (!mapR.containsKey(ratings[i])) mapR.put(ratings[i], new TreeMap<>());\\n            mapR.get(ratings[i]).put(foods[i], cuisines[i]);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = mapFC.get(food);\\n        int oldRating = map.get(cuisine).get(food);\\n        map.get(cuisine).put(food, newRating);\\n\\n        mapR.get(oldRating).remove(food);\\n        if (!mapR.containsKey(newRating)) mapR.put(newRating, new TreeMap<>());\\n        mapR.get(newRating).put(food, cuisine);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        for (int r : mapR.keySet()) {\\n            Map<String, String> map1 = mapR.get(r);\\n            for (String food : map1.keySet()) if (map1.get(food).equals(cuisine)) return food;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462740,
                "title": "design-a-food-rating-system",
                "content": "-------------- Easy C++ Solution ----------------------\\n\\n# Code\\n```\\nclass FoodRatings {\\npublic:\\n  FoodRatings(vector<string>& foods, vector<string>& cuisines,vector<int>& ratings){\\n    for (int i=0; i<foods.size();++i) {\\n      cuisineToRatingAndFoods[cuisines[i]].insert({-ratings[i], foods[i]});\\n      foodToCuisine[foods[i]]=cuisines[i];\\n      foodToRating[foods[i]]=ratings[i];\\n    }\\n  }\\n\\n  void changeRating(string food, int newRating) {\\n    const string cuisine = foodToCuisine[food];\\n    const int oldRating = foodToRating[food];\\n    auto& ratingAndFoods = cuisineToRatingAndFoods[cuisine];\\n    ratingAndFoods.erase({-oldRating, food});\\n    ratingAndFoods.insert({-newRating, food});\\n    foodToRating[food] = newRating;\\n  }\\n\\n  string highestRated(string cuisine) {\\n    return begin(cuisineToRatingAndFoods[cuisine])->second;\\n  }\\n\\n private:\\n  unordered_map<string, set<pair<int, string>>> cuisineToRatingAndFoods;\\n  unordered_map<string, string> foodToCuisine;\\n  unordered_map<string, int> foodToRating;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n  FoodRatings(vector<string>& foods, vector<string>& cuisines,vector<int>& ratings){\\n    for (int i=0; i<foods.size();++i) {\\n      cuisineToRatingAndFoods[cuisines[i]].insert({-ratings[i], foods[i]});\\n      foodToCuisine[foods[i]]=cuisines[i];\\n      foodToRating[foods[i]]=ratings[i];\\n    }\\n  }\\n\\n  void changeRating(string food, int newRating) {\\n    const string cuisine = foodToCuisine[food];\\n    const int oldRating = foodToRating[food];\\n    auto& ratingAndFoods = cuisineToRatingAndFoods[cuisine];\\n    ratingAndFoods.erase({-oldRating, food});\\n    ratingAndFoods.insert({-newRating, food});\\n    foodToRating[food] = newRating;\\n  }\\n\\n  string highestRated(string cuisine) {\\n    return begin(cuisineToRatingAndFoods[cuisine])->second;\\n  }\\n\\n private:\\n  unordered_map<string, set<pair<int, string>>> cuisineToRatingAndFoods;\\n  unordered_map<string, string> foodToCuisine;\\n  unordered_map<string, int> foodToRating;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459829,
                "title": "python-simple-hashmap-and-heapq",
                "content": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        f = self.food = defaultdict(tuple)\\n        c = self.cuis = defaultdict(list)\\n        for fd, cu, rt in zip(foods, cuisines, ratings):\\n            f[fd] = [cu, -rt]\\n            heappush(c[cu], (-rt, fd))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        newRating *= -1\\n        f = self.food\\n        c = self.cuis\\n        if f[food][-1] == newRating:\\n            return\\n        f[food][-1] = newRating\\n        heappush(c[f[food][0]], (newRating, food))\\n        \\n\\n    def highestRated(self, cui: str) -> str:\\n        f = self.food\\n        c = self.cuis\\n        rt, fd = c[cui][0]\\n        while f[fd][-1] != rt:\\n            heappop(c[cui])\\n            rt, fd = c[cui][0]\\n        return fd\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        f = self.food = defaultdict(tuple)\\n        c = self.cuis = defaultdict(list)\\n        for fd, cu, rt in zip(foods, cuisines, ratings):\\n            f[fd] = [cu, -rt]\\n            heappush(c[cu], (-rt, fd))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        newRating *= -1\\n        f = self.food\\n        c = self.cuis\\n        if f[food][-1] == newRating:\\n            return\\n        f[food][-1] = newRating\\n        heappush(c[f[food][0]], (newRating, food))\\n        \\n\\n    def highestRated(self, cui: str) -> str:\\n        f = self.food\\n        c = self.cuis\\n        rt, fd = c[cui][0]\\n        while f[fd][-1] != rt:\\n            heappop(c[cui])\\n            rt, fd = c[cui][0]\\n        return fd\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414877,
                "title": "c-maps",
                "content": "\\n# Code\\n```\\nclass FoodRatings {\\n\\nprivate:\\n\\nmap<string, map<int, set<string>>> mp;\\nunordered_map<string, string> c;\\nunordered_map<string, int> r;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n            for(int i = 0; i < foods.size(); i++){\\n                mp[cuisines[i]][ratings[i]].insert(foods[i]);\\n                c[foods[i]] = cuisines[i];\\n                r[foods[i]] = ratings[i];\\n            }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cuisine = c[food];\\n        int rating = r[food];\\n        r[food] = newRating;\\n        mp[cuisine][rating].erase(food);\\n        if(mp[cuisine][rating].size() == 0) mp[cuisine].erase(rating);\\n        mp[cuisine][newRating].insert(food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mp[cuisine].rbegin();\\n        return *(it->second.begin());\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\n\\nprivate:\\n\\nmap<string, map<int, set<string>>> mp;\\nunordered_map<string, string> c;\\nunordered_map<string, int> r;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n            for(int i = 0; i < foods.size(); i++){\\n                mp[cuisines[i]][ratings[i]].insert(foods[i]);\\n                c[foods[i]] = cuisines[i];\\n                r[foods[i]] = ratings[i];\\n            }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cuisine = c[food];\\n        int rating = r[food];\\n        r[food] = newRating;\\n        mp[cuisine][rating].erase(food);\\n        if(mp[cuisine][rating].size() == 0) mp[cuisine].erase(rating);\\n        mp[cuisine][newRating].insert(food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mp[cuisine].rbegin();\\n        return *(it->second.begin());\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370498,
                "title": "lazy-but-easy",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string[]} foods\\n * @param {string[]} cuisines\\n * @param {number[]} ratings\\n */\\nvar FoodRatings = function(foods, cuisines, ratings) {\\n        this.foods= foods\\n        this.cuisines= cuisines\\n        this.ratings= ratings\\n};\\n\\n/** \\n * @param {string} food \\n * @param {number} newRating\\n * @return {void}\\n */\\nFoodRatings.prototype.changeRating = function(food, newRating) {\\n    let idx =this.foods.indexOf(food)\\n    this.ratings[idx]= newRating\\n};\\n\\n/** \\n * @param {string} cuisine\\n * @return {string}\\n */\\nFoodRatings.prototype.highestRated = function(cuisine) {\\n     let cuisineFoods =[]\\n     let cuisineRating =[]\\n     this.cuisines.forEach((ele,idx)=>{\\n         \\n        if(ele == cuisine && (cuisineRating[cuisineRating.length-1]<= this.ratings[idx] || !cuisineRating.length )){\\n            if(cuisineRating.length && cuisineRating[cuisineRating.length-1]< this.ratings[idx]){\\n                cuisineFoods=[]\\n                cuisineRating=[]\\n            }\\n\\n            cuisineFoods.push(this.foods[idx]) \\n            cuisineRating.push(this.ratings[idx]) \\n        }\\n    })\\n\\n       return cuisineFoods.sort()[0]\\n\\n};\\n\\n/** \\n * Your FoodRatings object will be instantiated and called as such:\\n * var obj = new FoodRatings(foods, cuisines, ratings)\\n * obj.changeRating(food,newRating)\\n * var param_2 = obj.highestRated(cuisine)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} foods\\n * @param {string[]} cuisines\\n * @param {number[]} ratings\\n */\\nvar FoodRatings = function(foods, cuisines, ratings) {\\n        this.foods= foods\\n        this.cuisines= cuisines\\n        this.ratings= ratings\\n};\\n\\n/** \\n * @param {string} food \\n * @param {number} newRating\\n * @return {void}\\n */\\nFoodRatings.prototype.changeRating = function(food, newRating) {\\n    let idx =this.foods.indexOf(food)\\n    this.ratings[idx]= newRating\\n};\\n\\n/** \\n * @param {string} cuisine\\n * @return {string}\\n */\\nFoodRatings.prototype.highestRated = function(cuisine) {\\n     let cuisineFoods =[]\\n     let cuisineRating =[]\\n     this.cuisines.forEach((ele,idx)=>{\\n         \\n        if(ele == cuisine && (cuisineRating[cuisineRating.length-1]<= this.ratings[idx] || !cuisineRating.length )){\\n            if(cuisineRating.length && cuisineRating[cuisineRating.length-1]< this.ratings[idx]){\\n                cuisineFoods=[]\\n                cuisineRating=[]\\n            }\\n\\n            cuisineFoods.push(this.foods[idx]) \\n            cuisineRating.push(this.ratings[idx]) \\n        }\\n    })\\n\\n       return cuisineFoods.sort()[0]\\n\\n};\\n\\n/** \\n * Your FoodRatings object will be instantiated and called as such:\\n * var obj = new FoodRatings(foods, cuisines, ratings)\\n * obj.changeRating(food,newRating)\\n * var param_2 = obj.highestRated(cuisine)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337463,
                "title": "c-map-of-map-of-set",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    // for each type of cuisine\\n        // maintain a list of ratings, food\\n        // foods at each rating should be stored\\n        // using a set\\n    //            cuisine,    rating, foods at rating\\n    unordered_map<string, map<int, set<string>>> m;\\n    //            food, cuisine, rating\\n    unordered_map<string, pair<string, int>> fc;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for (int i = 0; i < f.size(); ++i){\\n            m[c[i]][r[i]].insert(f[i]);\\n            fc[f[i]] = {c[i], r[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n                    auto [s, i] = fc[food];\\n                    m[s][i].erase(food);\\n                    if (m[s][i].size() == 0) m[s].erase(i);\\n                    m[s][newRating].insert(food);\\n                    fc[food].second = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto& it = m[cuisine];\\n        auto itr = it.rbegin();\\n        auto& s = itr->second;\\n        return *s.begin();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    // for each type of cuisine\\n        // maintain a list of ratings, food\\n        // foods at each rating should be stored\\n        // using a set\\n    //            cuisine,    rating, foods at rating\\n    unordered_map<string, map<int, set<string>>> m;\\n    //            food, cuisine, rating\\n    unordered_map<string, pair<string, int>> fc;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for (int i = 0; i < f.size(); ++i){\\n            m[c[i]][r[i]].insert(f[i]);\\n            fc[f[i]] = {c[i], r[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n                    auto [s, i] = fc[food];\\n                    m[s][i].erase(food);\\n                    if (m[s][i].size() == 0) m[s].erase(i);\\n                    m[s][newRating].insert(food);\\n                    fc[food].second = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto& it = m[cuisine];\\n        auto itr = it.rbegin();\\n        auto& s = itr->second;\\n        return *s.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330763,
                "title": "java-comparator-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass FoodRatings {\\n    private Map<String, Food> foodNameMappedToFood = new HashMap<>();\\n    private Map<String, Queue<Food>> cuisinesMappedToFood = new HashMap<>();\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for (int i = 0; i < foods.length; i++) {\\n            Food food = new Food(foods[i], cuisines[i], ratings[i]);\\n            cuisinesMappedToFood.putIfAbsent(cuisines[i], \\n            new PriorityQueue<>(new FoodComparator()));\\n            cuisinesMappedToFood.get(cuisines[i]).add(food);\\n            foodNameMappedToFood.put(foods[i], food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food foodObj = foodNameMappedToFood.get(food);\\n        String cuisine = foodNameMappedToFood.get(food).cuisine;\\n        cuisinesMappedToFood.get(cuisine).remove(foodObj);\\n        foodObj.rating = newRating;\\n        cuisinesMappedToFood.get(cuisine).add(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMappedToFood.get(cuisine).peek().name;\\n    }\\n\\n    \\n}\\n\\nclass FoodComparator implements Comparator<Food> {\\n    @Override\\n    public int compare(Food first, Food second) {\\n        if (first.rating == second.rating)\\n            return first.name.compareTo(second.name);\\n        return second.rating - first.rating;\\n    }\\n}\\n\\nclass Food {\\n    public String name;\\n    public String cuisine;\\n    public int rating;\\n\\n    public Food(String name, String cuisine, int rating) {\\n        this.name = name;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n    private Map<String, Food> foodNameMappedToFood = new HashMap<>();\\n    private Map<String, Queue<Food>> cuisinesMappedToFood = new HashMap<>();\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for (int i = 0; i < foods.length; i++) {\\n            Food food = new Food(foods[i], cuisines[i], ratings[i]);\\n            cuisinesMappedToFood.putIfAbsent(cuisines[i], \\n            new PriorityQueue<>(new FoodComparator()));\\n            cuisinesMappedToFood.get(cuisines[i]).add(food);\\n            foodNameMappedToFood.put(foods[i], food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food foodObj = foodNameMappedToFood.get(food);\\n        String cuisine = foodNameMappedToFood.get(food).cuisine;\\n        cuisinesMappedToFood.get(cuisine).remove(foodObj);\\n        foodObj.rating = newRating;\\n        cuisinesMappedToFood.get(cuisine).add(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMappedToFood.get(cuisine).peek().name;\\n    }\\n\\n    \\n}\\n\\nclass FoodComparator implements Comparator<Food> {\\n    @Override\\n    public int compare(Food first, Food second) {\\n        if (first.rating == second.rating)\\n            return first.name.compareTo(second.name);\\n        return second.rating - first.rating;\\n    }\\n}\\n\\nclass Food {\\n    public String name;\\n    public String cuisine;\\n    public int rating;\\n\\n    public Food(String name, String cuisine, int rating) {\\n        this.name = name;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303198,
                "title": "ood-object-oriented-design-solution",
                "content": "\\n# Code\\n```\\nclass FoodRatings {\\n    class FoodItem {\\n        private final String foodName;\\n        private final String cuisineType;\\n        private int rating;\\n        public FoodItem(String food, String cuisine, int rating) {\\n            this.foodName = food;\\n            this.cuisineType = cuisine;\\n            this.rating = rating;\\n        }\\n\\n        public void updateRating(int newRating) {\\n            this.rating = newRating;\\n        }\\n\\n        public int getRating() {\\n            return rating;\\n        }\\n\\n        public String getFoodName() {\\n            return foodName;\\n        }\\n\\n        public String getCuisineType() {\\n            return cuisineType;\\n        }\\n    }\\n    \\n    public class FoodItemComparator implements Comparator<FoodItem> {\\n        @Override\\n        public int compare(FoodItem food1, FoodItem food2) {\\n            if (food1.getRating() != food2.getRating()) {\\n                return Integer.compare(food2.getRating(), food1.getRating());\\n            }\\n            return food1.getFoodName().compareTo(food2.getFoodName());\\n        }\\n    }\\n\\n    Map<String, FoodItem> foodMap;\\n    Map<String, TreeSet<FoodItem>> cuisineMap;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n\\n        for (int i = 0; i < foods.length; i++) {\\n            FoodItem newFood = new FoodItem(foods[i], cuisines[i], ratings[i]);\\n            foodMap.put(foods[i], newFood);\\n            cuisineMap.computeIfAbsent(cuisines[i], k -> new TreeSet<FoodItem>(new FoodItemComparator())).add(newFood);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodItem foodItem = foodMap.get(food);\\n        TreeSet<FoodItem> sortedFood = cuisineMap.get(foodItem.getCuisineType());\\n        sortedFood.remove(foodItem);\\n        foodItem.updateRating(newRating);\\n        sortedFood.add(foodItem);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).first().getFoodName();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n    class FoodItem {\\n        private final String foodName;\\n        private final String cuisineType;\\n        private int rating;\\n        public FoodItem(String food, String cuisine, int rating) {\\n            this.foodName = food;\\n            this.cuisineType = cuisine;\\n            this.rating = rating;\\n        }\\n\\n        public void updateRating(int newRating) {\\n            this.rating = newRating;\\n        }\\n\\n        public int getRating() {\\n            return rating;\\n        }\\n\\n        public String getFoodName() {\\n            return foodName;\\n        }\\n\\n        public String getCuisineType() {\\n            return cuisineType;\\n        }\\n    }\\n    \\n    public class FoodItemComparator implements Comparator<FoodItem> {\\n        @Override\\n        public int compare(FoodItem food1, FoodItem food2) {\\n            if (food1.getRating() != food2.getRating()) {\\n                return Integer.compare(food2.getRating(), food1.getRating());\\n            }\\n            return food1.getFoodName().compareTo(food2.getFoodName());\\n        }\\n    }\\n\\n    Map<String, FoodItem> foodMap;\\n    Map<String, TreeSet<FoodItem>> cuisineMap;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n\\n        for (int i = 0; i < foods.length; i++) {\\n            FoodItem newFood = new FoodItem(foods[i], cuisines[i], ratings[i]);\\n            foodMap.put(foods[i], newFood);\\n            cuisineMap.computeIfAbsent(cuisines[i], k -> new TreeSet<FoodItem>(new FoodItemComparator())).add(newFood);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodItem foodItem = foodMap.get(food);\\n        TreeSet<FoodItem> sortedFood = cuisineMap.get(foodItem.getCuisineType());\\n        sortedFood.remove(foodItem);\\n        foodItem.updateRating(newRating);\\n        sortedFood.add(foodItem);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).first().getFoodName();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288993,
                "title": "fast-c-custom-max-heap-implementation-logn-update-o-1-getmax",
                "content": "```\\nclass FoodPQ\\n{\\n    vector<pair<string, int>> v;\\n    unordered_map<string, int> mp;\\t// food to idx_in_heap\\n    public:\\n        FoodPQ() {}\\n    void push(pair<string, int> p)\\n    {\\n        v.push_back(p);\\n        mp[p.first] = v.size()-1;\\n    }\\n    bool isLeftBigger(pair<string, int> a, pair<string, int> b)\\n    {\\n        if (a.second != b.second) return a.second > b.second;\\n        return a.first < b.first;\\n    }\\n    void swapper(int idx1, int idx2)\\n    {\\n        mp[v[idx1].first] = idx2;\\n        mp[v[idx2].first] = idx1;\\n        swap(v[idx1], v[idx2]);\\n    }\\n    bool isV(int idx){\\n        return idx>=0 && idx<v.size();\\n    }\\n    void bubbleUp(int idx)\\n    {\\n       \\t// i -> 2i+1, 2i+2\\n       \\t// child-1/2 = parent\\n        int par = (idx - 1) / 2;\\n        if (isV(par) && isLeftBigger(v[idx], v[par]))\\n        {\\n            swapper(idx, par);\\n            bubbleUp(par);\\n        }\\n        \\n    }\\n    void bubbleDn(int idx)\\n    {\\n       \\t// i -> 2i+1, 2i+2\\n       \\t// child-1/2 = parent\\n        int c1 = 2 *idx + 1;\\n        int c2 = 2 *idx + 2;\\n        int n = v.size();\\n\\n        if (isV(c1)==false || isLeftBigger(v[idx], v[c1]))  // cant go c1 side\\n        {\\n           \\t// can only go c2 side\\n            if (isV(c2) && (!isLeftBigger(v[idx], v[c2])))\\n            {\\n                swapper(idx, c2);\\n                bubbleDn(c2);\\n            }\\n        }\\n        else\\n        {\\n           \\t// can go c1 side\\n            if ( isV(c2)==false || isLeftBigger(v[idx], v[c2]))\\t// cant go c2 side \\n            {\\n                swapper(idx, c1);\\n                bubbleDn(c1);\\n            }\\n            else\\n            {\\n               \\t// might go either c1/c2\\n                if ( isV(c2) && isLeftBigger(v[c1], v[c2]) )\\n                {\\n                   \\t// go down c1 side \\n                    swapper(idx, c1);\\n                    bubbleDn(c1);\\n                }\\n                else\\n                {\\n                   \\t// go c2 side\\n                    swapper(idx, c2);\\n                    bubbleDn(c2);\\n                }\\n            }\\n        }\\n    }\\n    void heapify()\\n    {\\n        for(int i = v.size()-1;i>=0;i--){\\n            bubbleDn(i);\\n        }\\n    }\\n    void update(string food, int r)\\n    {\\n        int idx = mp[food];\\n        int orgR = v[idx].second;\\n        v[idx].second = r;\\n        if(r>orgR)\\n        bubbleUp(idx);\\n        else bubbleDn(idx);\\n    }\\n    string getMax()\\n    {\\n        return v[0].first;\\n    }\\n};\\nclass FoodRatings\\n{\\n    unordered_map<string, FoodPQ*> mp;\\t// cuisine -> pq_of_foods_of_a_particular_cuisine\\n    unordered_map<string, string> ftc;\\t// food -> cuisine\\n    public:\\n        FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n        {\\n            int n = foods.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                ftc[foods[i]] = cuisines[i];\\n                if(!mp.count(cuisines[i]))\\n                mp[cuisines[i]] = new FoodPQ();\\n                mp[cuisines[i]]->push({ foods[i],ratings[i] });\\n            }\\n            for(auto it:mp){\\n                mp[it.first]->heapify();\\n            }\\n        }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        mp[ftc[food]]->update(food, newRating);\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return mp[cuisine]->getMax();\\n    }\\n};\\n\\n/**\\n *Your FoodRatings object will be instantiated and called as such:\\n *FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n *obj->changeRating(food,newRating);\\n *string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FoodPQ\\n{\\n    vector<pair<string, int>> v;\\n    unordered_map<string, int> mp;\\t// food to idx_in_heap\\n    public:\\n        FoodPQ() {}\\n    void push(pair<string, int> p)\\n    {\\n        v.push_back(p);\\n        mp[p.first] = v.size()-1;\\n    }\\n    bool isLeftBigger(pair<string, int> a, pair<string, int> b)\\n    {\\n        if (a.second != b.second) return a.second > b.second;\\n        return a.first < b.first;\\n    }\\n    void swapper(int idx1, int idx2)\\n    {\\n        mp[v[idx1].first] = idx2;\\n        mp[v[idx2].first] = idx1;\\n        swap(v[idx1], v[idx2]);\\n    }\\n    bool isV(int idx){\\n        return idx>=0 && idx<v.size();\\n    }\\n    void bubbleUp(int idx)\\n    {\\n       \\t// i -> 2i+1, 2i+2\\n       \\t// child-1/2 = parent\\n        int par = (idx - 1) / 2;\\n        if (isV(par) && isLeftBigger(v[idx], v[par]))\\n        {\\n            swapper(idx, par);\\n            bubbleUp(par);\\n        }\\n        \\n    }\\n    void bubbleDn(int idx)\\n    {\\n       \\t// i -> 2i+1, 2i+2\\n       \\t// child-1/2 = parent\\n        int c1 = 2 *idx + 1;\\n        int c2 = 2 *idx + 2;\\n        int n = v.size();\\n\\n        if (isV(c1)==false || isLeftBigger(v[idx], v[c1]))  // cant go c1 side\\n        {\\n           \\t// can only go c2 side\\n            if (isV(c2) && (!isLeftBigger(v[idx], v[c2])))\\n            {\\n                swapper(idx, c2);\\n                bubbleDn(c2);\\n            }\\n        }\\n        else\\n        {\\n           \\t// can go c1 side\\n            if ( isV(c2)==false || isLeftBigger(v[idx], v[c2]))\\t// cant go c2 side \\n            {\\n                swapper(idx, c1);\\n                bubbleDn(c1);\\n            }\\n            else\\n            {\\n               \\t// might go either c1/c2\\n                if ( isV(c2) && isLeftBigger(v[c1], v[c2]) )\\n                {\\n                   \\t// go down c1 side \\n                    swapper(idx, c1);\\n                    bubbleDn(c1);\\n                }\\n                else\\n                {\\n                   \\t// go c2 side\\n                    swapper(idx, c2);\\n                    bubbleDn(c2);\\n                }\\n            }\\n        }\\n    }\\n    void heapify()\\n    {\\n        for(int i = v.size()-1;i>=0;i--){\\n            bubbleDn(i);\\n        }\\n    }\\n    void update(string food, int r)\\n    {\\n        int idx = mp[food];\\n        int orgR = v[idx].second;\\n        v[idx].second = r;\\n        if(r>orgR)\\n        bubbleUp(idx);\\n        else bubbleDn(idx);\\n    }\\n    string getMax()\\n    {\\n        return v[0].first;\\n    }\\n};\\nclass FoodRatings\\n{\\n    unordered_map<string, FoodPQ*> mp;\\t// cuisine -> pq_of_foods_of_a_particular_cuisine\\n    unordered_map<string, string> ftc;\\t// food -> cuisine\\n    public:\\n        FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n        {\\n            int n = foods.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                ftc[foods[i]] = cuisines[i];\\n                if(!mp.count(cuisines[i]))\\n                mp[cuisines[i]] = new FoodPQ();\\n                mp[cuisines[i]]->push({ foods[i],ratings[i] });\\n            }\\n            for(auto it:mp){\\n                mp[it.first]->heapify();\\n            }\\n        }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        mp[ftc[food]]->update(food, newRating);\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return mp[cuisine]->getMax();\\n    }\\n};\\n\\n/**\\n *Your FoodRatings object will be instantiated and called as such:\\n *FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n *obj->changeRating(food,newRating);\\n *string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282417,
                "title": "lazy-updation-with-heaps-and-sets-python3",
                "content": "\\n# Code\\n```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.map = {}\\n        self.cusineratings = defaultdict(set)\\n        self.heaps = defaultdict(list)\\n        self.foodrating = defaultdict(int)\\n        for food,cuisine,rating in zip(foods,cuisines,ratings):\\n            self.map[food] = cuisine\\n            self.cusineratings[cuisine].add((-rating,food))\\n            heappush(self.heaps[cuisine],(-rating,food))\\n            self.foodrating[food] = -rating\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        if food in self.map:  \\n            cuisine = self.map[food]\\n            prev = self.foodrating[food]\\n            self.cusineratings[cuisine].remove((prev,food))\\n            self.cusineratings[cuisine].add((-newRating,food))\\n            heappush(self.heaps[cuisine],(-newRating,food))\\n            self.foodrating[food] = -newRating\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        while self.heaps[cuisine] and self.heaps[cuisine][0] not in self.cusineratings[cuisine]:\\n            heappop(self.heaps[cuisine])\\n        return self.heaps[cuisine][0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.map = {}\\n        self.cusineratings = defaultdict(set)\\n        self.heaps = defaultdict(list)\\n        self.foodrating = defaultdict(int)\\n        for food,cuisine,rating in zip(foods,cuisines,ratings):\\n            self.map[food] = cuisine\\n            self.cusineratings[cuisine].add((-rating,food))\\n            heappush(self.heaps[cuisine],(-rating,food))\\n            self.foodrating[food] = -rating\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        if food in self.map:  \\n            cuisine = self.map[food]\\n            prev = self.foodrating[food]\\n            self.cusineratings[cuisine].remove((prev,food))\\n            self.cusineratings[cuisine].add((-newRating,food))\\n            heappush(self.heaps[cuisine],(-newRating,food))\\n            self.foodrating[food] = -newRating\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        while self.heaps[cuisine] and self.heaps[cuisine][0] not in self.cusineratings[cuisine]:\\n            heappop(self.heaps[cuisine])\\n        return self.heaps[cuisine][0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251845,
                "title": "hashmap-simple-java-solution-hashing",
                "content": "# Complexity\\n- Time complexity:\\nO(no of calls)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass FoodRatings {\\n    HashMap<String,String> map = new HashMap<>();\\n    HashMap<String,Integer>rating;\\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> highrated;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        this.rating = new HashMap<>();\\n        this.highrated = new HashMap<>();\\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            rating.put(foods[i],ratings[i]);\\n            map.put(foods[i],cuisines[i]);\\n           if(!highrated.containsKey(cuisines[i])){\\n                TreeMap<Integer,TreeSet<String>> tree = new TreeMap<>();\\n                TreeSet<String> str = new TreeSet<>();\\n                tree.put(ratings[i],str);\\n                highrated.put(cuisines[i],tree);\\n            }\\n            if(!highrated.get(cuisines[i]).containsKey(ratings[i])){\\n                TreeSet<String> st = new TreeSet<>();\\n                highrated.get(cuisines[i]).put(ratings[i],st);\\n            }\\n            highrated.get(cuisines[i]).get(ratings[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        int x = rating.get(food);\\n        String t = map.get(food);\\n        highrated.get(t).get(x).remove(food);\\n        if(highrated.get(t).get(x).size()==0) highrated.get(t).remove(x);\\n        if(!highrated.get(t).containsKey(newRating)){\\n            TreeSet<String> str = new TreeSet<>();\\n            highrated.get(t).put(newRating,str);\\n        }\\n        highrated.get(t).get(newRating).add(food);\\n        rating.put(food,newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        int y = highrated.get(cuisine).lastKey();\\n        return highrated.get(cuisine).get(y).first();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    HashMap<String,String> map = new HashMap<>();\\n    HashMap<String,Integer>rating;\\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> highrated;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        this.rating = new HashMap<>();\\n        this.highrated = new HashMap<>();\\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            rating.put(foods[i],ratings[i]);\\n            map.put(foods[i],cuisines[i]);\\n           if(!highrated.containsKey(cuisines[i])){\\n                TreeMap<Integer,TreeSet<String>> tree = new TreeMap<>();\\n                TreeSet<String> str = new TreeSet<>();\\n                tree.put(ratings[i],str);\\n                highrated.put(cuisines[i],tree);\\n            }\\n            if(!highrated.get(cuisines[i]).containsKey(ratings[i])){\\n                TreeSet<String> st = new TreeSet<>();\\n                highrated.get(cuisines[i]).put(ratings[i],st);\\n            }\\n            highrated.get(cuisines[i]).get(ratings[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        int x = rating.get(food);\\n        String t = map.get(food);\\n        highrated.get(t).get(x).remove(food);\\n        if(highrated.get(t).get(x).size()==0) highrated.get(t).remove(x);\\n        if(!highrated.get(t).containsKey(newRating)){\\n            TreeSet<String> str = new TreeSet<>();\\n            highrated.get(t).put(newRating,str);\\n        }\\n        highrated.get(t).get(newRating).add(food);\\n        rating.put(food,newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        int y = highrated.get(cuisine).lastKey();\\n        return highrated.get(cuisine).get(y).first();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249446,
                "title": "python3-max-heap-lazy-delete",
                "content": "```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuisines = defaultdict(list)   # cuisine -> max heap of (rating, food)\\n        self.foods = defaultdict(str)       # food -> cuisine\\n        self.ratings = defaultdict(int)     # food -> rating \\n\\n        # build mappings \\n        for food, cuisine, rating in zip(foods, cuisines, ratings):\\n            rating = -rating\\n            self.foods[food] = cuisine\\n            self.cuisines[cuisine] += [(rating, food)]\\n            self.ratings[food] = rating\\n\\n        # heapify ratings \\n        for ratings in self.cuisines.values():\\n            heapify(ratings)\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        # update food rating\\n        rating = -newRating\\n        self.ratings[food] = rating\\n        # push new heap element \\n        cuisine = self.foods[food]\\n        heappush(self.cuisines[cuisine], (rating, food))\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        # get max heap\\n        heap = self.cuisines[cuisine]\\n        # lazy delete changed ratings \\n        while heap and self.ratings[heap[0][-1]] != heap[0][0]:\\n            heappop(heap)\\n        # return food of max rating \\n        return heap[0][-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuisines = defaultdict(list)   # cuisine -> max heap of (rating, food)\\n        self.foods = defaultdict(str)       # food -> cuisine\\n        self.ratings = defaultdict(int)     # food -> rating \\n\\n        # build mappings \\n        for food, cuisine, rating in zip(foods, cuisines, ratings):\\n            rating = -rating\\n            self.foods[food] = cuisine\\n            self.cuisines[cuisine] += [(rating, food)]\\n            self.ratings[food] = rating\\n\\n        # heapify ratings \\n        for ratings in self.cuisines.values():\\n            heapify(ratings)\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        # update food rating\\n        rating = -newRating\\n        self.ratings[food] = rating\\n        # push new heap element \\n        cuisine = self.foods[food]\\n        heappush(self.cuisines[cuisine], (rating, food))\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        # get max heap\\n        heap = self.cuisines[cuisine]\\n        # lazy delete changed ratings \\n        while heap and self.ratings[heap[0][-1]] != heap[0][0]:\\n            heappop(heap)\\n        # return food of max rating \\n        return heap[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169604,
                "title": "c-easy-solution-using-2-maps-top-99-runtime-top-97-memory-420ms",
                "content": "# Code\\n```\\nstruct compare {\\n    bool operator() (const pair<int, string>& a, const pair<int, string>& b) const{\\n        if ( a.first > b.first ) return true;\\n        else if ( a.first == b.first ) return a.second < b.second ? true : false;\\n        return false;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map<string, pair<int, string>> m; // keep track of the rating and cuisine of each food\\n    unordered_map<string, set<pair<int, string>, compare>> c; // keep track of an ordered set for each cuisine\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for ( int i = 0; i < foods.size(); ++i )\\n        {\\n            m[foods[i]] = { ratings[i], cuisines[i] };\\n            c[cuisines[i]].insert({ratings[i], foods[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if ( m.find(food) == m.end() ) return;\\n\\n        auto [oldRating, cuisine] = m.find(food)->second; // get the rating and cuisine for this food\\n        m[food].first = newRating;\\n\\n        // Let\\'s update the rating in the cuisine map\\n        c.find(cuisine)->second.erase(c.find(cuisine)->second.find({oldRating, food}));\\n        c.find(cuisine)->second.insert({newRating, food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return c.find(cuisine)->second.begin()->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct compare {\\n    bool operator() (const pair<int, string>& a, const pair<int, string>& b) const{\\n        if ( a.first > b.first ) return true;\\n        else if ( a.first == b.first ) return a.second < b.second ? true : false;\\n        return false;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map<string, pair<int, string>> m; // keep track of the rating and cuisine of each food\\n    unordered_map<string, set<pair<int, string>, compare>> c; // keep track of an ordered set for each cuisine\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for ( int i = 0; i < foods.size(); ++i )\\n        {\\n            m[foods[i]] = { ratings[i], cuisines[i] };\\n            c[cuisines[i]].insert({ratings[i], foods[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if ( m.find(food) == m.end() ) return;\\n\\n        auto [oldRating, cuisine] = m.find(food)->second; // get the rating and cuisine for this food\\n        m[food].first = newRating;\\n\\n        // Let\\'s update the rating in the cuisine map\\n        c.find(cuisine)->second.erase(c.find(cuisine)->second.find({oldRating, food}));\\n        c.find(cuisine)->second.insert({newRating, food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return c.find(cuisine)->second.begin()->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162174,
                "title": "c-unordered-map-string-map-int-set-string-greater",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            cuis[foods[i]] = cuisines[i];\\n            rates[foods[i]] = ratings[i];\\n            mm[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int p = rates[food];\\n        auto& m = mm[cuis[food]];\\n        m[p].erase(food);\\n        if(m[p].empty()) m.erase(p);\\n        m[newRating].insert(food);\\n        rates[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mm[cuisine].begin();\\n        return *it->second.begin();\\n    }\\n\\n    unordered_map<string, string> cuis; //{food, cuisines}\\n    unordered_map<string, map<int, set<string>, greater<>>> mm; //cuisines, {rate, {foot}}\\n    unordered_map<string, int> rates;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            cuis[foods[i]] = cuisines[i];\\n            rates[foods[i]] = ratings[i];\\n            mm[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int p = rates[food];\\n        auto& m = mm[cuis[food]];\\n        m[p].erase(food);\\n        if(m[p].empty()) m.erase(p);\\n        m[newRating].insert(food);\\n        rates[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mm[cuisine].begin();\\n        return *it->second.begin();\\n    }\\n\\n    unordered_map<string, string> cuis; //{food, cuisines}\\n    unordered_map<string, map<int, set<string>, greater<>>> mm; //cuisines, {rate, {foot}}\\n    unordered_map<string, int> rates;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148193,
                "title": "c-three-maps-consider-one-food-can-be-present-in-multiple-cuisines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings {\\nprivate:\\n    class Comp {\\n    public:\\n        bool operator()(const pair<int, string>& p1, const pair<int, string>& p2) const {\\n            return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;   \\n        } \\n    };\\n\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; ++i) {\\n            auto p = cuisineMap[cuisines[i]].insert({ratings[i], foods[i]});\\n            cuisineFoodMap[cuisines[i]][foods[i]] = p.first;\\n            foodCuisineMap[foods[i]].push_back(cuisines[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        const auto& cuisines = foodCuisineMap[food];\\n        for (const auto & cs : cuisines) {\\n            auto iter = cuisineFoodMap[cs][food];\\n            cuisineMap[cs].erase(iter);\\n            auto p = cuisineMap[cs].insert({newRating, food});\\n            cuisineFoodMap[cs][food] = p.first;\\n        }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return cuisineMap[cuisine].begin()->second;\\n    }\\n\\nprivate:\\n    std::unordered_map<string, std::set<pair<int, string>, Comp>> cuisineMap;\\n    std::unordered_map<string, std::unordered_map<std::string, std::set<pair<int, string>>::iterator>> cuisineFoodMap;\\n    std::unordered_map<string, vector<string>> foodCuisineMap;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\nprivate:\\n    class Comp {\\n    public:\\n        bool operator()(const pair<int, string>& p1, const pair<int, string>& p2) const {\\n            return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;   \\n        } \\n    };\\n\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; ++i) {\\n            auto p = cuisineMap[cuisines[i]].insert({ratings[i], foods[i]});\\n            cuisineFoodMap[cuisines[i]][foods[i]] = p.first;\\n            foodCuisineMap[foods[i]].push_back(cuisines[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        const auto& cuisines = foodCuisineMap[food];\\n        for (const auto & cs : cuisines) {\\n            auto iter = cuisineFoodMap[cs][food];\\n            cuisineMap[cs].erase(iter);\\n            auto p = cuisineMap[cs].insert({newRating, food});\\n            cuisineFoodMap[cs][food] = p.first;\\n        }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return cuisineMap[cuisine].begin()->second;\\n    }\\n\\nprivate:\\n    std::unordered_map<string, std::set<pair<int, string>, Comp>> cuisineMap;\\n    std::unordered_map<string, std::unordered_map<std::string, std::set<pair<int, string>>::iterator>> cuisineFoodMap;\\n    std::unordered_map<string, vector<string>> foodCuisineMap;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129093,
                "title": "python-hashmaps-heap-no-comparator-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We know we need to track \"highest\" rated for a collection of items. A heap seems like a good candidate here. \\n\\n- We know we need to get the \"highest\" rated for a cuisine. So we can maintain a dictionary of cuisine to a heap of foods with their ratings.\\n\\n- We also know we need to update the ratings for a food item so we can maintain a dictionary for that as well.\\n\\nUpdating a value in a heap is expensive because we have to iterate through the heap, update the value, and reheapify. \\n\\nWe can maintain some other dictionary to track food and rating and only insert into the heap which is an O(nlogn) operation. When grabbing a value from our heap, we can check to make sure the rating is what we expect in our dictionary. If it\\'s not it will be \"lazy\" deleted from our heap.\\n\\nWhen calling `changeRating` we only get the food and newRating. After updating the rating we need to insert the food and newRating into our heap. We need to figure out which cuisine a food item belongs to so we can track that as well.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will need:\\n\\n1. Dictionary to track food to rating & cuisine\\n2. Dictionary to track cuisine -> heap of (rating, food)\\n\\n`changeRating` will update value in dictionary and insert into heap in cuisine map. \\n\\n`highestRated` will pop the max in the cuisine heap. If the rating matches what we have in the dictionary then it\\'s valid otherwise we ignore that value and keep looking.\\n\\nheapq in python by default implements a min heap. If we are inserting tuples into our min heap we can negate the rating (highest rating) and in case of a tie it will return the lexographically smaller food item so we don\\'t need a special comparator or class.\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        # Map FoodInfo -> Rating, Cuisine\\n        self.foodInfo = defaultdict(list)\\n        # Map Cuisine -> Heap of (rating, food)\\n        self.cuisines = defaultdict(list)\\n\\n        for i in range(len(foods)):\\n            self.foodInfo[foods[i]] = [ratings[i], cuisines[i]]\\n            # We want max for the rating & lex. min for the item so negate rating as heapq is a min heap.\\n            heapq.heappush(self.cuisines[cuisines[i]], (-ratings[i], foods[i]))\\n\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        # Update food to rating in map. Push the new rating and food into the heap for the respective cuisine.\\n        cuisine = self.foodInfo[food][1]\\n        self.foodInfo[food] = [newRating, cuisine]\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while True:\\n            # Pop the heap for the topRated item in the cuisine map. \\n            topRatedValue, foodItem = heapq.heappop(self.cuisines[cuisine])\\n            # If the rating is the same as the value we have in the foodInfo map, we know its up to date.\\n            # Push it back into the heap since it\\'s current. If we get one where the rating is not current\\n            # with what we have in our foodInfo map the item will be lazy deleted from the heap.  \\n            if self.foodInfo[foodItem][0] == -topRatedValue:\\n                heapq.heappush(self.cuisines[cuisine], (topRatedValue, foodItem))\\n                return foodItem\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        # Map FoodInfo -> Rating, Cuisine\\n        self.foodInfo = defaultdict(list)\\n        # Map Cuisine -> Heap of (rating, food)\\n        self.cuisines = defaultdict(list)\\n\\n        for i in range(len(foods)):\\n            self.foodInfo[foods[i]] = [ratings[i], cuisines[i]]\\n            # We want max for the rating & lex. min for the item so negate rating as heapq is a min heap.\\n            heapq.heappush(self.cuisines[cuisines[i]], (-ratings[i], foods[i]))\\n\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        # Update food to rating in map. Push the new rating and food into the heap for the respective cuisine.\\n        cuisine = self.foodInfo[food][1]\\n        self.foodInfo[food] = [newRating, cuisine]\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while True:\\n            # Pop the heap for the topRated item in the cuisine map. \\n            topRatedValue, foodItem = heapq.heappop(self.cuisines[cuisine])\\n            # If the rating is the same as the value we have in the foodInfo map, we know its up to date.\\n            # Push it back into the heap since it\\'s current. If we get one where the rating is not current\\n            # with what we have in our foodInfo map the item will be lazy deleted from the heap.  \\n            if self.foodInfo[foodItem][0] == -topRatedValue:\\n                heapq.heappush(self.cuisines[cuisine], (topRatedValue, foodItem))\\n                return foodItem\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118050,
                "title": "treemap-java",
                "content": "```\\nclass FoodRatings {\\n\\n   class Node {\\n        Map<String, Integer> foodRatingMap;\\n        Map<Integer, TreeSet<String>> ratingFoodMap;\\n        \\n        public Node(){\\n            foodRatingMap = new HashMap<>();\\n            ratingFoodMap = new TreeMap<>(Comparator.reverseOrder());\\n        }\\n    }\\n\\n    private Map<String, String> foodCusineMap;\\n    private Map<String, Node> cusineFoodRatingMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodCusineMap = new HashMap<>();\\n        cusineFoodRatingMap = new HashMap<>();\\n        for (int i = 0; i < foods.length; i++){\\n            String food = foods[i];\\n            String cusine = cuisines[i];\\n            int rating = ratings[i];\\n            foodCusineMap.put(food, cusine);\\n            \\n            if(cusineFoodRatingMap.get(cusine) == null){\\n                cusineFoodRatingMap.put(cusine, new Node());\\n            }\\n\\n            Map<String, Integer> foodRatingMap = cusineFoodRatingMap.get(cusine).foodRatingMap;\\n            Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cusine).ratingFoodMap;\\n\\n            foodRatingMap.put(food, rating);\\n            TreeSet<String> set = ratingFoodMap.getOrDefault(rating, new TreeSet<>());\\n            set.add(food);\\n            ratingFoodMap.put(rating, set);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cusine = foodCusineMap.get(food);\\n\\n        Map<String, Integer> foodRatingMap = cusineFoodRatingMap.get(cusine).foodRatingMap;\\n        Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cusine).ratingFoodMap;\\n        \\n        int currRating = foodRatingMap.get(food);\\n        //remove the food from the current rating map\\n        TreeSet<String> set = ratingFoodMap.getOrDefault(currRating, new TreeSet<>());\\n        set.remove(food);\\n        if(set.isEmpty()) //caution , to remove the key if the set size if 0\\n            ratingFoodMap.remove(currRating);\\n        else \\n            ratingFoodMap.put(currRating, set);\\n\\n        //update the mapping\\n        foodRatingMap.put(food, newRating);\\n\\n        //add the food in the current rating \\n        TreeSet<String> newFoodSet = ratingFoodMap.getOrDefault(currRating, new TreeSet<>());\\n        newFoodSet.add(food);\\n        ratingFoodMap.put(newRating, newFoodSet);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cuisine).ratingFoodMap;\\n        int highestRating = ratingFoodMap.keySet().iterator().next(); //first item in the map\\n        TreeSet<String> foodSet = ratingFoodMap.get(highestRating);\\n        return foodSet.iterator().next();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\n\\n   class Node {\\n        Map<String, Integer> foodRatingMap;\\n        Map<Integer, TreeSet<String>> ratingFoodMap;\\n        \\n        public Node(){\\n            foodRatingMap = new HashMap<>();\\n            ratingFoodMap = new TreeMap<>(Comparator.reverseOrder());\\n        }\\n    }\\n\\n    private Map<String, String> foodCusineMap;\\n    private Map<String, Node> cusineFoodRatingMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodCusineMap = new HashMap<>();\\n        cusineFoodRatingMap = new HashMap<>();\\n        for (int i = 0; i < foods.length; i++){\\n            String food = foods[i];\\n            String cusine = cuisines[i];\\n            int rating = ratings[i];\\n            foodCusineMap.put(food, cusine);\\n            \\n            if(cusineFoodRatingMap.get(cusine) == null){\\n                cusineFoodRatingMap.put(cusine, new Node());\\n            }\\n\\n            Map<String, Integer> foodRatingMap = cusineFoodRatingMap.get(cusine).foodRatingMap;\\n            Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cusine).ratingFoodMap;\\n\\n            foodRatingMap.put(food, rating);\\n            TreeSet<String> set = ratingFoodMap.getOrDefault(rating, new TreeSet<>());\\n            set.add(food);\\n            ratingFoodMap.put(rating, set);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cusine = foodCusineMap.get(food);\\n\\n        Map<String, Integer> foodRatingMap = cusineFoodRatingMap.get(cusine).foodRatingMap;\\n        Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cusine).ratingFoodMap;\\n        \\n        int currRating = foodRatingMap.get(food);\\n        //remove the food from the current rating map\\n        TreeSet<String> set = ratingFoodMap.getOrDefault(currRating, new TreeSet<>());\\n        set.remove(food);\\n        if(set.isEmpty()) //caution , to remove the key if the set size if 0\\n            ratingFoodMap.remove(currRating);\\n        else \\n            ratingFoodMap.put(currRating, set);\\n\\n        //update the mapping\\n        foodRatingMap.put(food, newRating);\\n\\n        //add the food in the current rating \\n        TreeSet<String> newFoodSet = ratingFoodMap.getOrDefault(currRating, new TreeSet<>());\\n        newFoodSet.add(food);\\n        ratingFoodMap.put(newRating, newFoodSet);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cuisine).ratingFoodMap;\\n        int highestRating = ratingFoodMap.keySet().iterator().next(); //first item in the map\\n        TreeSet<String> foodSet = ratingFoodMap.get(highestRating);\\n        return foodSet.iterator().next();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111164,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings {\\npublic:\\n    map<string,set<int>>mp;\\n    map<pair<string,int>,set<string>>m;\\n    map<string,int>r;\\n    map<string,string>c;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++) {\\n            mp[cuisines[i]].insert({ratings[i]});\\n            m[{cuisines[i],ratings[i]}].insert(foods[i]);\\n            r[foods[i]] = ratings[i];\\n            c[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int old_rating = r[food];\\n        string cuisine = c[food];\\n        r[food] = newRating;\\n        m[{cuisine,old_rating}].erase(food);\\n        if(m[{cuisine,old_rating}].empty()) {\\n            m.erase({cuisine,old_rating});\\n            mp[cuisine].erase(old_rating);\\n        }\\n        mp[cuisine].insert(newRating);\\n        m[{cuisine, newRating}].insert(food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mp[cuisine].end();\\n        it--;\\n        int rating = *it;\\n        auto it1 = m[{cuisine,rating}].begin();\\n        return *it1;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    map<string,set<int>>mp;\\n    map<pair<string,int>,set<string>>m;\\n    map<string,int>r;\\n    map<string,string>c;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++) {\\n            mp[cuisines[i]].insert({ratings[i]});\\n            m[{cuisines[i],ratings[i]}].insert(foods[i]);\\n            r[foods[i]] = ratings[i];\\n            c[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int old_rating = r[food];\\n        string cuisine = c[food];\\n        r[food] = newRating;\\n        m[{cuisine,old_rating}].erase(food);\\n        if(m[{cuisine,old_rating}].empty()) {\\n            m.erase({cuisine,old_rating});\\n            mp[cuisine].erase(old_rating);\\n        }\\n        mp[cuisine].insert(newRating);\\n        m[{cuisine, newRating}].insert(food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mp[cuisine].end();\\n        it--;\\n        int rating = *it;\\n        auto it1 = m[{cuisine,rating}].begin();\\n        return *it1;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067080,
                "title": "javascript-avl-tree-761ms",
                "content": "```\\n///////////////////////////// Template ///////////////////////////////\\nclass AVLNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.left = null;\\n        this.right = null;\\n        this.height = 1;\\n        this.cnt = 1;\\n        this.SubTreeNodes = 1;\\n    }\\n}\\n\\nclass AVLTree {\\n    constructor(comparator = null) {\\n        this.root = null;\\n        this.nodeCount = 0;\\n        this.tot = 0;\\n        this.comparator = comparator ? comparator : (x, y) => x - y;\\n    }\\n    cmp(x, y) { // compare nodes: x is inserted item\\n        if (x == null || y == null) return 0;\\n        if (Array.isArray(x) || Number.isInteger(x)) x = new AVLNode(x);\\n        if (Array.isArray(y) || Number.isInteger(y)) y = new AVLNode(y);\\n        if (Array.isArray(x.val) || Array.isArray(y.val)) {\\n            if (Array.isArray(x.val) && Array.isArray(y.val)) {\\n                return this.comparator(x.val, y.val);\\n            } else {\\n                return 0;\\n            }\\n        } else if (Number.isInteger(x.val) || Number.isInteger(y.val)) {\\n            if (Number.isInteger(x.val) && Number.isInteger(y.val)) {\\n                return this.comparator(x.val, y.val);\\n            } else {\\n                return 0;\\n            }\\n        }\\n        return 0;\\n    }\\n    getHeight(node) {\\n        return node != null ? node.height : 0;\\n    }\\n    getBalance(node) {\\n        return node != null ? this.getHeight(node.left) - this.getHeight(node.right) : 0;\\n    }\\n    update(node) {\\n        let leftHeight = this.getHeight(node.left), rightHeight = this.getHeight(node.right);\\n        node.height = 1 + Math.max(leftHeight, rightHeight);\\n        node.SubTreeNodes = 1 + (node.left != null ? node.left.SubTreeNodes : 0) + (node.right != null ? node.right.SubTreeNodes : 0);\\n    }\\n    LR(z) {\\n        let y = z.right;\\n        let T2 = y.left;\\n        y.left = z;\\n        z.right = T2;\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    RR(z) {\\n        let y = z.left;\\n        let T3 = y.right;\\n        y.right = z\\n        z.left = T3\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    insert(item) {\\n        this.root = this.insertUtil(this.root, item);\\n    }\\n    insertUtil(node, item) {\\n        if (node == null) { // find place to insert\\n            this.nodeCount++;\\n            this.tot++;\\n            return new AVLNode(item);\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.insertUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.insertUtil(node.right, item);\\n        } else {\\n            node.cnt++;\\n            this.tot++;\\n            return node;\\n        }\\n        this.update(node);\\n        return this.rebalanceAfterInsert(node, item);\\n    }\\n    remove(v) {\\n        this.root = this.removeUtil(this.root, v);\\n    }\\n    removeUtil(node, item) {\\n        if (node == null) {\\n            return node;\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.removeUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.removeUtil(node.right, item);\\n        } else { // find node\\n            if (node.cnt > 1) { // current node > 1, remove 1, tree size keep the same\\n                node.cnt--;\\n                this.tot--;\\n                return node;\\n            } else { // current node == 1, delete, tree size--\\n                this.nodeCount--;\\n                this.tot--;\\n            }\\n            // delete process\\n            if (node.left == null) {\\n                let tmp = node.right;\\n                node = null;\\n                return tmp;\\n            } else if (node.right == null) {\\n                let tmp = node.left;\\n                node = null;\\n                return tmp;\\n            }\\n            let tmp = this.findFirst(node.right);\\n            node.val = tmp.val;\\n            node.right = this.removeUtil(node.right, tmp.val);\\n        }\\n        if (node == null) return node;\\n        this.update(node);\\n        return this.rebalanceAfterDeletion(node, item);\\n    }\\n    rebalanceAfterInsert(node, item) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.cmp(item, node.left) < 0) return this.RR(node);\\n        if (bal < -1 && this.cmp(item, node.right) > 0) return this.LR(node);\\n        if (bal > 1 && this.cmp(item, node.left) > 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.cmp(item, node.right) < 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    rebalanceAfterDeletion(node) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.getBalance(node.left) >= 0) return this.RR(node);\\n        if (bal < -1 && this.getBalance(node.right) <= 0) return this.LR(node);\\n        if (bal > 1 && this.getBalance(node.left) < 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.getBalance(node.right) > 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    find(item) {\\n        return this.findFirstOf(item);\\n    }\\n    findFirstOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    higher(item) {// > upper_bound\\n        let node = this.findSuccessorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findSuccessorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                res = node;\\n                node = node.left;\\n            } else {\\n                node = node.right;\\n            }\\n        }\\n        return res;\\n    }\\n    lower(item) { // < \\n        let node = this.findPrecursorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findPrecursorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) > 0) {\\n                res = node;\\n                node = node.right;\\n            } else {\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    findKth(k) { // (1-indexed)  unique\\n        let res = this.findKthNode(k);\\n        return res == null ? null : res.val;\\n    }\\n    findKthNode(k) {\\n        return this.size() < k ? null : this.KthUtil(this.root, k);\\n    }\\n    KthUtil(node, k) {\\n        let leftCount = node.left ? node.left.SubTreeNodes : 0;\\n        if (leftCount + 1 === k) return node;\\n        if (leftCount + 1 < k) return this.KthUtil(node.right, k - leftCount - 1);\\n        return this.KthUtil(node.left, k);\\n    }\\n    rankOf(item) { // unique value treeset    total elements in tree with val < item\\n        let x = this.findPrecursorOf(item);\\n        return x == null ? 0 : this.findRankOf(x, this.root) + 1;\\n    }\\n    findRankOf(item, node) {\\n        let rank = 0;\\n        while (node != null) {\\n            let leftSubtreeNodes = node.left != null ? node.left.SubTreeNodes : 0;\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                rank += leftSubtreeNodes + 1;\\n                node = node.right;\\n            } else {\\n                return rank + leftSubtreeNodes;\\n            }\\n        }\\n        return 0;\\n    }\\n    has(item) {\\n        return this.count(item) > 0;\\n    }\\n    count(item) {\\n        let node = this.find(item);\\n        return node == null ? 0 : node.cnt;\\n    }\\n    first() {\\n        let node = this.findFirst(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    last() {\\n        let node = this.findLast(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    poll() {\\n        let res = this.first();\\n        this.remove(res);\\n        return res;\\n    }\\n    pollLast() {\\n        let res = this.last();\\n        this.remove(res);\\n        return res;\\n    }\\n    findFirst(node) {\\n        return node == null || node.left == null ? node : this.findFirst(node.left);\\n    }\\n    findLast(node) {\\n        return node == null || node.right == null ? node : this.findLast(node.right);\\n    }\\n    size() {\\n        return this.nodeCount;\\n    }\\n    total() {\\n        return this.tot;\\n    }\\n    isEmpty() {\\n        return this.root == null;\\n    }\\n    show() { // inorder\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left);\\n            res.push(x.val);\\n            dfs(x.right);\\n        };\\n        dfs(this.root);\\n        return res;\\n    }\\n    showAll() {\\n        let d = this.show(), res = [];\\n        for (const x of d) {\\n            for (let i = 0; i < this.count(x); i++) res.push(x);\\n        }\\n        return res;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////////\\n\\nconst lexical_smallest_comp = (x, y) => x < y ? -1 : x > y ? 1 : 0;\\n\\nfunction FoodRatings(foods, cuisines, ratings) {\\n    let n = foods.length, cm = new Map(), fm = new Map(), rm = new Map();\\n    for (let i = 0; i < n; i++) {\\n        fm.set(foods[i], cuisines[i]);\\n        rm.set(foods[i], ratings[i]);\\n        if (!cm.has(cuisines[i])) {\\n            let tree = new AVLTree((x, y) => {\\n                if (x[0] != y[0]) return y[0] - x[0]; // first priority higher rating comes first\\n                return lexical_smallest_comp(x[1], y[1]); // second priority lexical small comes first\\n            });\\n            cm.set(cuisines[i], tree);\\n        }\\n        cm.get(cuisines[i]).insert([ratings[i], foods[i]]);\\n    }\\n    return { changeRating, highestRated }\\n    function changeRating(food, newRating) {\\n        let cuisine = fm.get(food);\\n        cm.get(cuisine).remove([rm.get(food), food]);\\n        rm.set(food, newRating);\\n        cm.get(cuisine).insert([rm.get(food), food]);\\n    }\\n    function highestRated(cuisine) {\\n        return cm.get(cuisine).first()[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Search Tree",
                    "Ordered Map"
                ],
                "code": "```\\n///////////////////////////// Template ///////////////////////////////\\nclass AVLNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.left = null;\\n        this.right = null;\\n        this.height = 1;\\n        this.cnt = 1;\\n        this.SubTreeNodes = 1;\\n    }\\n}\\n\\nclass AVLTree {\\n    constructor(comparator = null) {\\n        this.root = null;\\n        this.nodeCount = 0;\\n        this.tot = 0;\\n        this.comparator = comparator ? comparator : (x, y) => x - y;\\n    }\\n    cmp(x, y) { // compare nodes: x is inserted item\\n        if (x == null || y == null) return 0;\\n        if (Array.isArray(x) || Number.isInteger(x)) x = new AVLNode(x);\\n        if (Array.isArray(y) || Number.isInteger(y)) y = new AVLNode(y);\\n        if (Array.isArray(x.val) || Array.isArray(y.val)) {\\n            if (Array.isArray(x.val) && Array.isArray(y.val)) {\\n                return this.comparator(x.val, y.val);\\n            } else {\\n                return 0;\\n            }\\n        } else if (Number.isInteger(x.val) || Number.isInteger(y.val)) {\\n            if (Number.isInteger(x.val) && Number.isInteger(y.val)) {\\n                return this.comparator(x.val, y.val);\\n            } else {\\n                return 0;\\n            }\\n        }\\n        return 0;\\n    }\\n    getHeight(node) {\\n        return node != null ? node.height : 0;\\n    }\\n    getBalance(node) {\\n        return node != null ? this.getHeight(node.left) - this.getHeight(node.right) : 0;\\n    }\\n    update(node) {\\n        let leftHeight = this.getHeight(node.left), rightHeight = this.getHeight(node.right);\\n        node.height = 1 + Math.max(leftHeight, rightHeight);\\n        node.SubTreeNodes = 1 + (node.left != null ? node.left.SubTreeNodes : 0) + (node.right != null ? node.right.SubTreeNodes : 0);\\n    }\\n    LR(z) {\\n        let y = z.right;\\n        let T2 = y.left;\\n        y.left = z;\\n        z.right = T2;\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    RR(z) {\\n        let y = z.left;\\n        let T3 = y.right;\\n        y.right = z\\n        z.left = T3\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    insert(item) {\\n        this.root = this.insertUtil(this.root, item);\\n    }\\n    insertUtil(node, item) {\\n        if (node == null) { // find place to insert\\n            this.nodeCount++;\\n            this.tot++;\\n            return new AVLNode(item);\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.insertUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.insertUtil(node.right, item);\\n        } else {\\n            node.cnt++;\\n            this.tot++;\\n            return node;\\n        }\\n        this.update(node);\\n        return this.rebalanceAfterInsert(node, item);\\n    }\\n    remove(v) {\\n        this.root = this.removeUtil(this.root, v);\\n    }\\n    removeUtil(node, item) {\\n        if (node == null) {\\n            return node;\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.removeUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.removeUtil(node.right, item);\\n        } else { // find node\\n            if (node.cnt > 1) { // current node > 1, remove 1, tree size keep the same\\n                node.cnt--;\\n                this.tot--;\\n                return node;\\n            } else { // current node == 1, delete, tree size--\\n                this.nodeCount--;\\n                this.tot--;\\n            }\\n            // delete process\\n            if (node.left == null) {\\n                let tmp = node.right;\\n                node = null;\\n                return tmp;\\n            } else if (node.right == null) {\\n                let tmp = node.left;\\n                node = null;\\n                return tmp;\\n            }\\n            let tmp = this.findFirst(node.right);\\n            node.val = tmp.val;\\n            node.right = this.removeUtil(node.right, tmp.val);\\n        }\\n        if (node == null) return node;\\n        this.update(node);\\n        return this.rebalanceAfterDeletion(node, item);\\n    }\\n    rebalanceAfterInsert(node, item) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.cmp(item, node.left) < 0) return this.RR(node);\\n        if (bal < -1 && this.cmp(item, node.right) > 0) return this.LR(node);\\n        if (bal > 1 && this.cmp(item, node.left) > 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.cmp(item, node.right) < 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    rebalanceAfterDeletion(node) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.getBalance(node.left) >= 0) return this.RR(node);\\n        if (bal < -1 && this.getBalance(node.right) <= 0) return this.LR(node);\\n        if (bal > 1 && this.getBalance(node.left) < 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.getBalance(node.right) > 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    find(item) {\\n        return this.findFirstOf(item);\\n    }\\n    findFirstOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    higher(item) {// > upper_bound\\n        let node = this.findSuccessorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findSuccessorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                res = node;\\n                node = node.left;\\n            } else {\\n                node = node.right;\\n            }\\n        }\\n        return res;\\n    }\\n    lower(item) { // < \\n        let node = this.findPrecursorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findPrecursorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) > 0) {\\n                res = node;\\n                node = node.right;\\n            } else {\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    findKth(k) { // (1-indexed)  unique\\n        let res = this.findKthNode(k);\\n        return res == null ? null : res.val;\\n    }\\n    findKthNode(k) {\\n        return this.size() < k ? null : this.KthUtil(this.root, k);\\n    }\\n    KthUtil(node, k) {\\n        let leftCount = node.left ? node.left.SubTreeNodes : 0;\\n        if (leftCount + 1 === k) return node;\\n        if (leftCount + 1 < k) return this.KthUtil(node.right, k - leftCount - 1);\\n        return this.KthUtil(node.left, k);\\n    }\\n    rankOf(item) { // unique value treeset    total elements in tree with val < item\\n        let x = this.findPrecursorOf(item);\\n        return x == null ? 0 : this.findRankOf(x, this.root) + 1;\\n    }\\n    findRankOf(item, node) {\\n        let rank = 0;\\n        while (node != null) {\\n            let leftSubtreeNodes = node.left != null ? node.left.SubTreeNodes : 0;\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                rank += leftSubtreeNodes + 1;\\n                node = node.right;\\n            } else {\\n                return rank + leftSubtreeNodes;\\n            }\\n        }\\n        return 0;\\n    }\\n    has(item) {\\n        return this.count(item) > 0;\\n    }\\n    count(item) {\\n        let node = this.find(item);\\n        return node == null ? 0 : node.cnt;\\n    }\\n    first() {\\n        let node = this.findFirst(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    last() {\\n        let node = this.findLast(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    poll() {\\n        let res = this.first();\\n        this.remove(res);\\n        return res;\\n    }\\n    pollLast() {\\n        let res = this.last();\\n        this.remove(res);\\n        return res;\\n    }\\n    findFirst(node) {\\n        return node == null || node.left == null ? node : this.findFirst(node.left);\\n    }\\n    findLast(node) {\\n        return node == null || node.right == null ? node : this.findLast(node.right);\\n    }\\n    size() {\\n        return this.nodeCount;\\n    }\\n    total() {\\n        return this.tot;\\n    }\\n    isEmpty() {\\n        return this.root == null;\\n    }\\n    show() { // inorder\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left);\\n            res.push(x.val);\\n            dfs(x.right);\\n        };\\n        dfs(this.root);\\n        return res;\\n    }\\n    showAll() {\\n        let d = this.show(), res = [];\\n        for (const x of d) {\\n            for (let i = 0; i < this.count(x); i++) res.push(x);\\n        }\\n        return res;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////////\\n\\nconst lexical_smallest_comp = (x, y) => x < y ? -1 : x > y ? 1 : 0;\\n\\nfunction FoodRatings(foods, cuisines, ratings) {\\n    let n = foods.length, cm = new Map(), fm = new Map(), rm = new Map();\\n    for (let i = 0; i < n; i++) {\\n        fm.set(foods[i], cuisines[i]);\\n        rm.set(foods[i], ratings[i]);\\n        if (!cm.has(cuisines[i])) {\\n            let tree = new AVLTree((x, y) => {\\n                if (x[0] != y[0]) return y[0] - x[0]; // first priority higher rating comes first\\n                return lexical_smallest_comp(x[1], y[1]); // second priority lexical small comes first\\n            });\\n            cm.set(cuisines[i], tree);\\n        }\\n        cm.get(cuisines[i]).insert([ratings[i], foods[i]]);\\n    }\\n    return { changeRating, highestRated }\\n    function changeRating(food, newRating) {\\n        let cuisine = fm.get(food);\\n        cm.get(cuisine).remove([rm.get(food), food]);\\n        rm.set(food, newRating);\\n        cm.get(cuisine).insert([rm.get(food), food]);\\n    }\\n    function highestRated(cuisine) {\\n        return cm.get(cuisine).first()[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013131,
                "title": "using-priority-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTotal number of calls made to changeRating/highestRated is 2*10^4, so we need to make sure that the worst case time complexity of these two functions should be less then O(n).\\n\\nPriority is decided based on the rating followed by lexicographically smaller string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the highest rating is decided based on the crusine, so PQ for each crusine would be different. \\n\\nTime complexity of changeRating is O(log n), as we are overriding the existing rating with \"#REMOVED\" and then inserting a new rating in the heap.\\n\\nTime Complexity for highestRated function will be O(log n) assuming there are several redundant enteries present at the top.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings:\\n\\n    def __init__(self, f: List[str], c: List[str], r: List[int]):\\n        self.fr = {}\\n        self.cf = defaultdict(list)\\n        for i in range(len(f)):\\n            self.fr[f[i]] = [-r[i], f[i], c[i]]\\n            heappush(self.cf[c[i]], self.fr[f[i]])\\n\\n    def changeRating(self, f: str, nr: int) -> None:\\n        e = self.fr[f]\\n        e[-2] = \"#REMOVED\"\\n        ne = [-nr, f, e[-1]]\\n        heappush(self.cf[e[-1]], ne)\\n        self.fr[f] = ne\\n\\n    def highestRated(self, c: str) -> str:\\n        while self.cf[c][0][-2] == \"#REMOVED\":\\n            heappop(self.cf[c])\\n\\n        return self.cf[c][0][-2]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, f: List[str], c: List[str], r: List[int]):\\n        self.fr = {}\\n        self.cf = defaultdict(list)\\n        for i in range(len(f)):\\n            self.fr[f[i]] = [-r[i], f[i], c[i]]\\n            heappush(self.cf[c[i]], self.fr[f[i]])\\n\\n    def changeRating(self, f: str, nr: int) -> None:\\n        e = self.fr[f]\\n        e[-2] = \"#REMOVED\"\\n        ne = [-nr, f, e[-1]]\\n        heappush(self.cf[e[-1]], ne)\\n        self.fr[f] = ne\\n\\n    def highestRated(self, c: str) -> str:\\n        while self.cf[c][0][-2] == \"#REMOVED\":\\n            heappop(self.cf[c])\\n\\n        return self.cf[c][0][-2]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979785,
                "title": "c-unordered-map-of-food-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nFoodRating: O(nlogn)\\nchangeRating: O(logn)\\nhighestRated: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct FoodRating {\\n    std::string food;\\n    int rating;\\n    bool operator<(const FoodRating& o) const {\\n        if (rating == o.rating) {\\n            return food.compare(o.food) < 0;\\n        }\\n        return rating > o.rating;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        const auto sz = foods.size();\\n        for (int i=0;i<sz;++i) {\\n            CuisineToFood[cuisines[i]].insert({foods[i], ratings[i]});\\n            FoodToCuisine[foods[i]] = {ratings[i], cuisines[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto it = FoodToCuisine.find(food);\\n        const auto& cuisine = it->second.second;\\n\\n        FoodRating fr{food, it->second.first};\\n        CuisineToFood[cuisine].erase(fr);\\n        CuisineToFood[cuisine].insert({food, newRating});\\n\\n        FoodToCuisine[food] = {newRating, it->second.second};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        const auto& p = CuisineToFood.find(cuisine);\\n        return p->second.begin()->food;\\n    }\\n\\nprivate:\\n    // cuisine --> food set\\n    std::unordered_map<std::string, std::set<FoodRating>> CuisineToFood;\\n    std::unordered_map<string, std::pair<int, std::string>> FoodToCuisine;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct FoodRating {\\n    std::string food;\\n    int rating;\\n    bool operator<(const FoodRating& o) const {\\n        if (rating == o.rating) {\\n            return food.compare(o.food) < 0;\\n        }\\n        return rating > o.rating;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        const auto sz = foods.size();\\n        for (int i=0;i<sz;++i) {\\n            CuisineToFood[cuisines[i]].insert({foods[i], ratings[i]});\\n            FoodToCuisine[foods[i]] = {ratings[i], cuisines[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto it = FoodToCuisine.find(food);\\n        const auto& cuisine = it->second.second;\\n\\n        FoodRating fr{food, it->second.first};\\n        CuisineToFood[cuisine].erase(fr);\\n        CuisineToFood[cuisine].insert({food, newRating});\\n\\n        FoodToCuisine[food] = {newRating, it->second.second};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        const auto& p = CuisineToFood.find(cuisine);\\n        return p->second.begin()->food;\\n    }\\n\\nprivate:\\n    // cuisine --> food set\\n    std::unordered_map<std::string, std::set<FoodRating>> CuisineToFood;\\n    std::unordered_map<string, std::pair<int, std::string>> FoodToCuisine;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965199,
                "title": "ruby-982-ms-using-crbtreemap",
                "content": "```ruby\\nclass FoodRatings\\n\\n    def initialize f, c, r\\n        @c, @f = {}, {}\\n        f.each_with_index do | f, i |\\n            @f[f] = [c[i], -r[i]]\\n            @c[c[i]] ||= CRBTreeMap.new\\n            @c[c[i]].push [-r[i], f], true\\n        end\\n    end\\n\\n    def change_rating f, n\\n        c, p = @f[f]\\n        n = -n\\n        if p != n\\n            @f[f] = [c, n]\\n            @c[c].delete [p, f]\\n            @c[c].push [n, f], true\\n        end\\n    end\\n\\n    def highest_rated(c) = @c[c].min_key.last\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass FoodRatings\\n\\n    def initialize f, c, r\\n        @c, @f = {}, {}\\n        f.each_with_index do | f, i |\\n            @f[f] = [c[i], -r[i]]\\n            @c[c[i]] ||= CRBTreeMap.new\\n            @c[c[i]].push [-r[i], f], true\\n        end\\n    end\\n\\n    def change_rating f, n\\n        c, p = @f[f]\\n        n = -n\\n        if p != n\\n            @f[f] = [c, n]\\n            @c[c].delete [p, f]\\n            @c[c].push [n, f], true\\n        end\\n    end\\n\\n    def highest_rated(c) = @c[c].min_key.last\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943270,
                "title": "python-fast-solution-using-priority-and-lazy-delete-90-fast",
                "content": "# Approach\\n1) First we create several mapping in order to get fast which cuisine the food is and it\\'s priority (which version of rating is actual)\\n2) On each update we change priority, rating and push new value to necessary $$heap$$\\n3) To get correct $$highest$$ rating firstly we clean top value from heap which are not actual and only after that we can get the answer\\n\\n# Complexity\\n- Time complexity: $$O(Nlog(N))$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nimport heapq\\n\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.heaps = defaultdict(list)\\n        self.food_mapping = defaultdict(str)\\n        self.food_priorities = defaultdict(int)\\n        self._build(foods, cuisines, ratings)\\n    \\n\\n    def _build(self, foods, cuisines, ratings):\\n        for ind, rating in enumerate(ratings):\\n            self.food_mapping[foods[ind]] = cuisines[ind]\\n            self.food_priorities[foods[ind]] = 1\\n            heapq.heappush(self.heaps[cuisines[ind]], (-rating, foods[ind], -1))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        new_priority = self.food_priorities[food] + 1\\n        self.food_priorities[food] = new_priority\\n        cuisine = self.food_mapping[food]\\n        heapq.heappush(self.heaps[cuisine], (-newRating, food, -new_priority))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.heaps[cuisine]:\\n            top = self.heaps[cuisine][0]\\n            if -top[2] != self.food_priorities[top[1]]:\\n                heapq.heappop(self.heaps[cuisine])\\n            else:\\n                break\\n        return self.heaps[cuisine][0][1]\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.heaps = defaultdict(list)\\n        self.food_mapping = defaultdict(str)\\n        self.food_priorities = defaultdict(int)\\n        self._build(foods, cuisines, ratings)\\n    \\n\\n    def _build(self, foods, cuisines, ratings):\\n        for ind, rating in enumerate(ratings):\\n            self.food_mapping[foods[ind]] = cuisines[ind]\\n            self.food_priorities[foods[ind]] = 1\\n            heapq.heappush(self.heaps[cuisines[ind]], (-rating, foods[ind], -1))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        new_priority = self.food_priorities[food] + 1\\n        self.food_priorities[food] = new_priority\\n        cuisine = self.food_mapping[food]\\n        heapq.heappush(self.heaps[cuisine], (-newRating, food, -new_priority))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.heaps[cuisine]:\\n            top = self.heaps[cuisine][0]\\n            if -top[2] != self.food_priorities[top[1]]:\\n                heapq.heappop(self.heaps[cuisine])\\n            else:\\n                break\\n        return self.heaps[cuisine][0][1]\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936408,
                "title": "simple-heap-solution-ood",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##high level:\\n## 1. food needs to be separate class. In a real system, this needs to be a table. \\n## 2. ranking, heap is data structure to use. for each type, we keep a heap. \\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## tricky part is when rating is changed, how do we update the heap. \\n## heap is not opertimized for searching an item. so for performance, we can just update it in the food class then everytime, we visit heap, check if the rating is matching with food, if not,just ignore it and delete it from heap\\n\\n## other things to consider when you see this Question in an interview\\n## 1. cuisions can be enum instead, easier for searching\\n## 2. ranking can be async jobs, in system design, this is the topK problem. Take a look at the min sketch algorism.  \\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ninit o(nlogn)\\nget_top o(lgm)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\n##high level:\\n## 1. food needs to be separate class. In a real system, this needs to be a table. \\n## 2. ranking, heap is data structure to use. for each type, we keep a heap. \\n## tricky part is when rating is changed, how do we update the heap. \\n## heap is not opertimized for searching an item. so for performance, we can just update it in the food class then everytime, we visit heap, check if the rating is matching with food, if not,just ignore it and delete it from heap\\n\\n## other things to consider when you see this Question in an interview\\n## 1. cuisions can be enum instead, easier for searching\\n## 2. ranking can be async jobs, in system design, this is the topK problem. Take a look at the min sketch algorism.  \\n \\nclass Food:\\n    def __init__(self, name: str, cuisine: str, rating: int):\\n        self.name = name\\n        self.cuisine =  cuisine\\n        self.rating = rating\\n\\nclass CuisineRanking:\\n    def __init__(self) -> None:\\n        self.food = []\\n    \\n    def add(self, food: Food) -> None:\\n        heappush(self.food, (-food.rating, food.name, food))\\n    \\n    def get_top(self) -> Food:\\n        while self.food and self.food[0][0] != -self.food[0][2].rating:\\n            heappop(self.food)\\n        if not self.food:\\n            return None\\n        return self.food[0][2]\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.all_food = defaultdict(Food)\\n        self.rankers = defaultdict(CuisineRanking)\\n        for i in range(len(foods)):\\n            food = Food(foods[i], cuisines[i], ratings[i])\\n            self.all_food[foods[i]] = food\\n            self.rankers[cuisines[i]].add(food)\\n\\n    def changeRating(self, food_name: str, newRating: int) -> None:\\n        if food_name not in self.all_food:\\n            return None\\n        food = self.all_food[food_name]\\n        food.rating = newRating\\n        self.rankers[food.cuisine].add(food)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        if cuisine not in self.rankers:\\n            return \"not valid\"\\n        top_food = self.rankers[cuisine].get_top()\\n        if not top_food:\\n            return \"not valid\"\\n        return top_food.name\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python3",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n##high level:\\n## 1. food needs to be separate class. In a real system, this needs to be a table. \\n## 2. ranking, heap is data structure to use. for each type, we keep a heap. \\n## tricky part is when rating is changed, how do we update the heap. \\n## heap is not opertimized for searching an item. so for performance, we can just update it in the food class then everytime, we visit heap, check if the rating is matching with food, if not,just ignore it and delete it from heap\\n\\n## other things to consider when you see this Question in an interview\\n## 1. cuisions can be enum instead, easier for searching\\n## 2. ranking can be async jobs, in system design, this is the topK problem. Take a look at the min sketch algorism.  \\n \\nclass Food:\\n    def __init__(self, name: str, cuisine: str, rating: int):\\n        self.name = name\\n        self.cuisine =  cuisine\\n        self.rating = rating\\n\\nclass CuisineRanking:\\n    def __init__(self) -> None:\\n        self.food = []\\n    \\n    def add(self, food: Food) -> None:\\n        heappush(self.food, (-food.rating, food.name, food))\\n    \\n    def get_top(self) -> Food:\\n        while self.food and self.food[0][0] != -self.food[0][2].rating:\\n            heappop(self.food)\\n        if not self.food:\\n            return None\\n        return self.food[0][2]\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.all_food = defaultdict(Food)\\n        self.rankers = defaultdict(CuisineRanking)\\n        for i in range(len(foods)):\\n            food = Food(foods[i], cuisines[i], ratings[i])\\n            self.all_food[foods[i]] = food\\n            self.rankers[cuisines[i]].add(food)\\n\\n    def changeRating(self, food_name: str, newRating: int) -> None:\\n        if food_name not in self.all_food:\\n            return None\\n        food = self.all_food[food_name]\\n        food.rating = newRating\\n        self.rankers[food.cuisine].add(food)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        if cuisine not in self.rankers:\\n            return \"not valid\"\\n        top_food = self.rankers[cuisine].get_top()\\n        if not top_food:\\n            return \"not valid\"\\n        return top_food.name\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926648,
                "title": "c-modern-clean-solution-with-3-hash-maps-and-a-sorted-hash-set-beats-92",
                "content": "# Code\\n```\\nclass Compare {\\n public:\\n  // If same rating, return lexicalgraphically smaller food.\\n  // NOTE: parameters must be const, and function itself must also be const.\\n  bool operator()(const pair<string, int>& p1,\\n                  const pair<string, int>& p2) const {\\n    if (p1.second == p2.second) {\\n      return p1.first < p2.first;\\n    }\\n    return p1.second > p2.second;\\n  }\\n};\\n\\nclass FoodRatings {\\n public:\\n  FoodRatings(const vector<string>& foods,\\n              const vector<string>& cuisines,\\n              const vector<int>& ratings) {\\n    for (int i = 0, n = int(foods.size()); i < n; ++i) {\\n      auto food = foods[i];\\n      auto cuisine = cuisines[i];\\n      auto rating = ratings[i];\\n\\n      food_to_cuisine[food] = cuisine;\\n      food_to_rating[food] = rating;\\n      cuisine_to_sorted_set[cuisine].insert({food, rating});\\n    }\\n  }\\n\\n  void changeRating(const string& food, int new_rating) {\\n    auto cuisine = food_to_cuisine[food];\\n    auto& old_rating = food_to_rating[food];\\n\\n    cuisine_to_sorted_set[cuisine].erase({food, old_rating});\\n    cuisine_to_sorted_set[cuisine].insert({food, new_rating});\\n\\n    old_rating = new_rating;  // Don\\'t forget to update here.\\n  }\\n\\n  string highestRated(const string& cuisine) {\\n    return cuisine_to_sorted_set[cuisine].begin()->first;\\n  }\\n\\n private:\\n  unordered_map<string, string> food_to_cuisine;\\n  unordered_map<string, int> food_to_rating;\\n  unordered_map<string, set<pair<string, int>, Compare>> cuisine_to_sorted_set;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Compare {\\n public:\\n  // If same rating, return lexicalgraphically smaller food.\\n  // NOTE: parameters must be const, and function itself must also be const.\\n  bool operator()(const pair<string, int>& p1,\\n                  const pair<string, int>& p2) const {\\n    if (p1.second == p2.second) {\\n      return p1.first < p2.first;\\n    }\\n    return p1.second > p2.second;\\n  }\\n};\\n\\nclass FoodRatings {\\n public:\\n  FoodRatings(const vector<string>& foods,\\n              const vector<string>& cuisines,\\n              const vector<int>& ratings) {\\n    for (int i = 0, n = int(foods.size()); i < n; ++i) {\\n      auto food = foods[i];\\n      auto cuisine = cuisines[i];\\n      auto rating = ratings[i];\\n\\n      food_to_cuisine[food] = cuisine;\\n      food_to_rating[food] = rating;\\n      cuisine_to_sorted_set[cuisine].insert({food, rating});\\n    }\\n  }\\n\\n  void changeRating(const string& food, int new_rating) {\\n    auto cuisine = food_to_cuisine[food];\\n    auto& old_rating = food_to_rating[food];\\n\\n    cuisine_to_sorted_set[cuisine].erase({food, old_rating});\\n    cuisine_to_sorted_set[cuisine].insert({food, new_rating});\\n\\n    old_rating = new_rating;  // Don\\'t forget to update here.\\n  }\\n\\n  string highestRated(const string& cuisine) {\\n    return cuisine_to_sorted_set[cuisine].begin()->first;\\n  }\\n\\n private:\\n  unordered_map<string, string> food_to_cuisine;\\n  unordered_map<string, int> food_to_rating;\\n  unordered_map<string, set<pair<string, int>, Compare>> cuisine_to_sorted_set;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895531,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.Map;\\nimport java.util.HashMap;\\nimport java.util.TreeSet;\\n\\npublic class FoodRatings {\\n\\n    private final Map<String, FoodData> foodNameToFoodData;\\n    private final Map<String, TreeSet<FoodData>> cuisineNameToSortedFoodData;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodNameToFoodData = new HashMap<>();\\n        cuisineNameToSortedFoodData = new HashMap<>();\\n\\n        for (int i = 0; i < foods.length; ++i) {\\n            FoodData current = new FoodData(foods[i], cuisines[i], ratings[i]);\\n            foodNameToFoodData.put(foods[i], current);\\n            cuisineNameToSortedFoodData.computeIfAbsent(cuisines[i], orderedFoodData -> new TreeSet<>()).add(current);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        FoodData toUpdate = foodNameToFoodData.get(food);\\n        cuisineNameToSortedFoodData.get(toUpdate.cuisine).remove(toUpdate);\\n        toUpdate.rating = newRating;\\n        cuisineNameToSortedFoodData.get(toUpdate.cuisine).add(toUpdate);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        return cuisineNameToSortedFoodData.get(cuisine).first().name;\\n    }\\n\\n}\\n\\nclass FoodData implements Comparable<FoodData> {\\n\\n    String name;\\n    String cuisine;\\n    int rating;\\n\\n    FoodData(String name, String cuisine, int rating) {\\n        this.name = name;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n\\n    @Override\\n    public int compareTo(FoodData other) {\\n        if (this.rating == other.rating) {\\n            return this.name.compareTo(other.name);\\n        }\\n        return other.rating - this.rating;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/*\\n @param{string}name\\n @param{string}cuisine\\n @param{number}rating\\n */\\nfunction FoodData(name, cuisine, rating) {\\n    this.name = name;\\n    this.cuisine = cuisine;\\n    this.rating = rating;\\n}\\n\\nclass FoodRatings {\\n\\n    /*\\n     @param{string[]}foods\\n     @param{string[]}cuisines\\n     @param{number[]}ratings\\n     */\\n    constructor(foods, cuisines, ratings) {\\n        //Map<string, FoodData>\\n        this.foodNameToFoodData = new Map();\\n        //const {MaxPriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n        //Map<string, MaxPriorityQueue<FoodData>>, lazy update for MaxPriorityQueue<FoodData> in method \\'highestRated(cuisine)\\'\\n        this.cuisineNameToHeapifiedFoodData = new Map();\\n\\n        for (let i = 0; i < foods.length; ++i) {\\n            let currentFood = new FoodData(foods[i], cuisines[i], ratings[i]);\\n            this.foodNameToFoodData.set(foods[i], currentFood);\\n            if (!this.cuisineNameToHeapifiedFoodData.has(cuisines[i])) {\\n                this.cuisineNameToHeapifiedFoodData.set(cuisines[i],\\n                        new MaxPriorityQueue({compare: (x, y) => (x.rating === y.rating) ? x.name.localeCompare(y.name) : (y.rating - x.rating)}));\\n            }\\n            this.cuisineNameToHeapifiedFoodData.get(cuisines[i]).enqueue(currentFood);\\n        }\\n    }\\n\\n    /**\\n     *@param{string}food\\n     *@param{number}newRating\\n     *@return{void}\\n     */\\n    changeRating(food, newRating) {\\n        let toUpdate = this.foodNameToFoodData.get(food);\\n        let updated = new FoodData(toUpdate.name, toUpdate.cuisine, newRating);\\n        this.foodNameToFoodData.set(food, updated);\\n        this.cuisineNameToHeapifiedFoodData.get(toUpdate.cuisine).enqueue(updated);\\n    }\\n\\n    /**\\n     *@param{string}cuisine\\n     *@return{string}\\n     */\\n    highestRated(cuisine) {\\n        let highestRatedFoodForCuisine = \"\";\\n        while (true) {\\n            let food = this.cuisineNameToHeapifiedFoodData.get(cuisine).front();\\n            if (food.rating !== this.foodNameToFoodData.get(food.name).rating) {\\n                this.cuisineNameToHeapifiedFoodData.get(cuisine).dequeue();\\n            } else {\\n                highestRatedFoodForCuisine = food.name;\\n                break;\\n            }\\n        }\\n        return highestRatedFoodForCuisine;\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <set>\\n#include <string>\\nusing namespace std;\\n\\nstruct FoodData {\\n    string name;\\n    string cuisine;\\n    int rating{};\\n\\n    FoodData() = default;\\n    FoodData(string name, string cuisine, int rating) : name{name}, cuisine{cuisine}, rating{rating}{}\\n\\n    bool operator<(const FoodData& first) const {\\n        if (rating == first.rating) {\\n            return name < first.name;\\n        }\\n        return rating > first.rating;\\n    }\\n};\\n\\nclass FoodRatings {\\n    \\n    unordered_map<string, FoodData> foodNameToFoodData;\\n    unordered_map<string, set<FoodData>> cuisineNameToSortedFoodData;\\n\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (size_t i = 0; i < foods.size(); ++i) {\\n            foodNameToFoodData.emplace(foods[i], FoodData(foods[i], cuisines[i], ratings[i]));\\n            cuisineNameToSortedFoodData[cuisines[i]].emplace(foods[i], cuisines[i], ratings[i]);\\n        }\\n    }\\n\\n    void changeRating(const string& food, int newRating) {\\n        FoodData& toUpdate = foodNameToFoodData[food];\\n        cuisineNameToSortedFoodData[toUpdate.cuisine].erase(toUpdate);\\n        toUpdate.rating = newRating;\\n        cuisineNameToSortedFoodData[toUpdate.cuisine].insert(toUpdate);\\n    }\\n\\n    string highestRated(const string& cuisine) const {\\n        return cuisineNameToSortedFoodData.at(cuisine).begin()->name;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nimport java.util.Map;\\nimport java.util.HashMap;\\nimport java.util.TreeSet;\\n\\npublic class FoodRatings {\\n\\n    private final Map<String, FoodData> foodNameToFoodData;\\n    private final Map<String, TreeSet<FoodData>> cuisineNameToSortedFoodData;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodNameToFoodData = new HashMap<>();\\n        cuisineNameToSortedFoodData = new HashMap<>();\\n\\n        for (int i = 0; i < foods.length; ++i) {\\n            FoodData current = new FoodData(foods[i], cuisines[i], ratings[i]);\\n            foodNameToFoodData.put(foods[i], current);\\n            cuisineNameToSortedFoodData.computeIfAbsent(cuisines[i], orderedFoodData -> new TreeSet<>()).add(current);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        FoodData toUpdate = foodNameToFoodData.get(food);\\n        cuisineNameToSortedFoodData.get(toUpdate.cuisine).remove(toUpdate);\\n        toUpdate.rating = newRating;\\n        cuisineNameToSortedFoodData.get(toUpdate.cuisine).add(toUpdate);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        return cuisineNameToSortedFoodData.get(cuisine).first().name;\\n    }\\n\\n}\\n\\nclass FoodData implements Comparable<FoodData> {\\n\\n    String name;\\n    String cuisine;\\n    int rating;\\n\\n    FoodData(String name, String cuisine, int rating) {\\n        this.name = name;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n\\n    @Override\\n    public int compareTo(FoodData other) {\\n        if (this.rating == other.rating) {\\n            return this.name.compareTo(other.name);\\n        }\\n        return other.rating - this.rating;\\n    }\\n}\\n```\n```\\n/*\\n @param{string}name\\n @param{string}cuisine\\n @param{number}rating\\n */\\nfunction FoodData(name, cuisine, rating) {\\n    this.name = name;\\n    this.cuisine = cuisine;\\n    this.rating = rating;\\n}\\n\\nclass FoodRatings {\\n\\n    /*\\n     @param{string[]}foods\\n     @param{string[]}cuisines\\n     @param{number[]}ratings\\n     */\\n    constructor(foods, cuisines, ratings) {\\n        //Map<string, FoodData>\\n        this.foodNameToFoodData = new Map();\\n        //const {MaxPriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n        //Map<string, MaxPriorityQueue<FoodData>>, lazy update for MaxPriorityQueue<FoodData> in method \\'highestRated(cuisine)\\'\\n        this.cuisineNameToHeapifiedFoodData = new Map();\\n\\n        for (let i = 0; i < foods.length; ++i) {\\n            let currentFood = new FoodData(foods[i], cuisines[i], ratings[i]);\\n            this.foodNameToFoodData.set(foods[i], currentFood);\\n            if (!this.cuisineNameToHeapifiedFoodData.has(cuisines[i])) {\\n                this.cuisineNameToHeapifiedFoodData.set(cuisines[i],\\n                        new MaxPriorityQueue({compare: (x, y) => (x.rating === y.rating) ? x.name.localeCompare(y.name) : (y.rating - x.rating)}));\\n            }\\n            this.cuisineNameToHeapifiedFoodData.get(cuisines[i]).enqueue(currentFood);\\n        }\\n    }\\n\\n    /**\\n     *@param{string}food\\n     *@param{number}newRating\\n     *@return{void}\\n     */\\n    changeRating(food, newRating) {\\n        let toUpdate = this.foodNameToFoodData.get(food);\\n        let updated = new FoodData(toUpdate.name, toUpdate.cuisine, newRating);\\n        this.foodNameToFoodData.set(food, updated);\\n        this.cuisineNameToHeapifiedFoodData.get(toUpdate.cuisine).enqueue(updated);\\n    }\\n\\n    /**\\n     *@param{string}cuisine\\n     *@return{string}\\n     */\\n    highestRated(cuisine) {\\n        let highestRatedFoodForCuisine = \"\";\\n        while (true) {\\n            let food = this.cuisineNameToHeapifiedFoodData.get(cuisine).front();\\n            if (food.rating !== this.foodNameToFoodData.get(food.name).rating) {\\n                this.cuisineNameToHeapifiedFoodData.get(cuisine).dequeue();\\n            } else {\\n                highestRatedFoodForCuisine = food.name;\\n                break;\\n            }\\n        }\\n        return highestRatedFoodForCuisine;\\n    }\\n}\\n```\n```\\n#include <set>\\n#include <string>\\nusing namespace std;\\n\\nstruct FoodData {\\n    string name;\\n    string cuisine;\\n    int rating{};\\n\\n    FoodData() = default;\\n    FoodData(string name, string cuisine, int rating) : name{name}, cuisine{cuisine}, rating{rating}{}\\n\\n    bool operator<(const FoodData& first) const {\\n        if (rating == first.rating) {\\n            return name < first.name;\\n        }\\n        return rating > first.rating;\\n    }\\n};\\n\\nclass FoodRatings {\\n    \\n    unordered_map<string, FoodData> foodNameToFoodData;\\n    unordered_map<string, set<FoodData>> cuisineNameToSortedFoodData;\\n\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (size_t i = 0; i < foods.size(); ++i) {\\n            foodNameToFoodData.emplace(foods[i], FoodData(foods[i], cuisines[i], ratings[i]));\\n            cuisineNameToSortedFoodData[cuisines[i]].emplace(foods[i], cuisines[i], ratings[i]);\\n        }\\n    }\\n\\n    void changeRating(const string& food, int newRating) {\\n        FoodData& toUpdate = foodNameToFoodData[food];\\n        cuisineNameToSortedFoodData[toUpdate.cuisine].erase(toUpdate);\\n        toUpdate.rating = newRating;\\n        cuisineNameToSortedFoodData[toUpdate.cuisine].insert(toUpdate);\\n    }\\n\\n    string highestRated(const string& cuisine) const {\\n        return cuisineNameToSortedFoodData.at(cuisine).begin()->name;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2887449,
                "title": "three-maps",
                "content": "\\n# Complexity\\n- Time complexity:\\n   O(n)+O(log n)\\n\\n# Code\\n```\\nclass FoodRatings {\\n    HashMap<String,Integer> foodRating=new HashMap<>();\\n    HashMap<String,String> foodCuisine=new HashMap<>();\\n    HashMap<String, SortedSet<Pair<String,Integer>>> cuisineToFoodMap=new HashMap<>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n=foods.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            foodRating.put(foods[i],ratings[i]);\\n            foodCuisine.put(foods[i],cuisines[i]);\\n            if(!cuisineToFoodMap.containsKey(cuisines[i]))\\n            {\\n                cuisineToFoodMap.put(cuisines[i], new TreeSet<Pair<String,Integer>>(\\n                    (a,b)->\\n                    (int)a.getValue()==(int)b.getValue()? a.getKey().toString().compareTo(b.getKey().toString()):\\n                    (int)b.getValue()-(int)a.getValue()\\n                    )\\n                    );\\n            }\\n            Pair<String,Integer> temp=new Pair<>(foods[i],ratings[i]);\\n            cuisineToFoodMap.get(cuisines[i]).add(temp);\\n        }\\n        // System.out.println( cuisineToFoodMap);\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cui=foodCuisine.get(food);\\n        int rate=foodRating.get(food);\\n        cuisineToFoodMap.get(cui).remove(new Pair<String,Integer>(food,rate));\\n        cuisineToFoodMap.get(cui).add(new Pair<String,Integer>(food,newRating));\\n        // System.out.println( cuisineToFoodMap);\\n       foodRating.put(food,newRating); \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        return  cuisineToFoodMap.get(cuisine).first().getKey();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    HashMap<String,Integer> foodRating=new HashMap<>();\\n    HashMap<String,String> foodCuisine=new HashMap<>();\\n    HashMap<String, SortedSet<Pair<String,Integer>>> cuisineToFoodMap=new HashMap<>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n=foods.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            foodRating.put(foods[i],ratings[i]);\\n            foodCuisine.put(foods[i],cuisines[i]);\\n            if(!cuisineToFoodMap.containsKey(cuisines[i]))\\n            {\\n                cuisineToFoodMap.put(cuisines[i], new TreeSet<Pair<String,Integer>>(\\n                    (a,b)->\\n                    (int)a.getValue()==(int)b.getValue()? a.getKey().toString().compareTo(b.getKey().toString()):\\n                    (int)b.getValue()-(int)a.getValue()\\n                    )\\n                    );\\n            }\\n            Pair<String,Integer> temp=new Pair<>(foods[i],ratings[i]);\\n            cuisineToFoodMap.get(cuisines[i]).add(temp);\\n        }\\n        // System.out.println( cuisineToFoodMap);\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cui=foodCuisine.get(food);\\n        int rate=foodRating.get(food);\\n        cuisineToFoodMap.get(cui).remove(new Pair<String,Integer>(food,rate));\\n        cuisineToFoodMap.get(cui).add(new Pair<String,Integer>(food,newRating));\\n        // System.out.println( cuisineToFoodMap);\\n       foodRating.put(food,newRating); \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        return  cuisineToFoodMap.get(cuisine).first().getKey();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800606,
                "title": "simplified-solution",
                "content": "```\\nclass FoodRatings\\n{\\n    public:\\n    unordered_map<string, int> mp; // for ratings\\n    unordered_map<string, string> mp2; // for cuisins\\n    unordered_map<string, set<pair<int, string>>> hrating;\\n\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[foods[i]] = ratings[i]; // O(N)\\n            mp2[foods[i]] = cuisines[i]; // O(N)\\n            hrating[cuisines[i]].insert({ -ratings[i], foods[i] }); // O(N log M) M => size(set)\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        string t = mp2[food];  // O(1)\\n        int tmp = mp[food]; //  O(1)\\n        mp[food] = newRating; // O(1)\\n        hrating[t].erase(hrating[t].find({ -tmp, food }));  // O(log M)\\n        hrating[t].insert({ -newRating, food }); // O(log M)\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n\\n        string res = \"\";\\n        auto anss = *(hrating[cuisine].begin());  // O(1)\\n        res = anss.second;\\n        return res;\\n    }\\n};\\n\\n/*\\n    Time Complexity => ~ O(N log N)\\n    Space Complexity => 3 * O(N)\\n*/\\n\\n\\n// class Food\\n// {\\n//     int rating;\\n//     string name, cuisine;\\n//     Food(string name, string cuisine, int rating)\\n//     {\\n//         name = name; rating = rating; cuisine = cuisine;\\n//     }\\n// }\\n\\n/**\\n *Your FoodRatings object will be instantiated and called as such:\\n *FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n *obj->changeRating(food,newRating);\\n *string param_2 = obj->highestRated(cuisine);\\n */\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings\\n{\\n    public:\\n    unordered_map<string, int> mp; // for ratings\\n    unordered_map<string, string> mp2; // for cuisins\\n    unordered_map<string, set<pair<int, string>>> hrating;\\n\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[foods[i]] = ratings[i]; // O(N)\\n            mp2[foods[i]] = cuisines[i]; // O(N)\\n            hrating[cuisines[i]].insert({ -ratings[i], foods[i] }); // O(N log M) M => size(set)\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        string t = mp2[food];  // O(1)\\n        int tmp = mp[food]; //  O(1)\\n        mp[food] = newRating; // O(1)\\n        hrating[t].erase(hrating[t].find({ -tmp, food }));  // O(log M)\\n        hrating[t].insert({ -newRating, food }); // O(log M)\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n\\n        string res = \"\";\\n        auto anss = *(hrating[cuisine].begin());  // O(1)\\n        res = anss.second;\\n        return res;\\n    }\\n};\\n\\n/*\\n    Time Complexity => ~ O(N log N)\\n    Space Complexity => 3 * O(N)\\n*/\\n\\n\\n// class Food\\n// {\\n//     int rating;\\n//     string name, cuisine;\\n//     Food(string name, string cuisine, int rating)\\n//     {\\n//         name = name; rating = rating; cuisine = cuisine;\\n//     }\\n// }\\n\\n/**\\n *Your FoodRatings object will be instantiated and called as such:\\n *FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n *obj->changeRating(food,newRating);\\n *string param_2 = obj->highestRated(cuisine);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779058,
                "title": "best-solution-in-c-heap",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass FoodRatings {\\npublic:\\n    class comp{\\n        public:\\n            bool operator()(pair<int,string> p1,pair<int,string> p2){\\n                if(p1.first>p2.first)\\n                    return false;\\n                if(p1.first==p2.first){\\n                    if(p1.second<p2.second)\\n                        return false;\\n                }\\n                return true;\\n            }\\n    };\\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,comp>> mp;\\n    unordered_map<string,pair<int,string>> mm;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            mm[foods[i]].first=ratings[i];\\n            mm[foods[i]].second=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        mm[food].first=newRating;\\n        string req_cuisine=mm[food].second;\\n        mp[req_cuisine].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        while(mp[cuisine].size()){\\n            pair<int,string> p=mp[cuisine].top();\\n            string s=p.second;\\n            int r=p.first;\\n            if(mm[s].first==r)\\n                return s;\\n            mp[cuisine].pop();\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    class comp{\\n        public:\\n            bool operator()(pair<int,string> p1,pair<int,string> p2){\\n                if(p1.first>p2.first)\\n                    return false;\\n                if(p1.first==p2.first){\\n                    if(p1.second<p2.second)\\n                        return false;\\n                }\\n                return true;\\n            }\\n    };\\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,comp>> mp;\\n    unordered_map<string,pair<int,string>> mm;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            mm[foods[i]].first=ratings[i];\\n            mm[foods[i]].second=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        mm[food].first=newRating;\\n        string req_cuisine=mm[food].second;\\n        mp[req_cuisine].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        while(mp[cuisine].size()){\\n            pair<int,string> p=mp[cuisine].top();\\n            string s=p.second;\\n            int r=p.first;\\n            if(mm[s].first==r)\\n                return s;\\n            mp[cuisine].pop();\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760987,
                "title": "c-887-ms",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(const vector<string>& foods,\\n                const vector<string>& cuisines,\\n                const vector<int>&    ratings  ) {\\n        \\n        for(size_t i=0; i<foods.size(); ++i) {\\n            cuisineTable[foods[i]] = cuisines[i];\\n            ratingTable [foods[i]] = ratings[i];\\n            dataTable[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(const string& food, int newRating) {\\n        int rating = ratingTable[food];\\n        string cuisine = cuisineTable[food];\\n        \\n        if(dataTable[cuisine][rating].size()==1)\\n            dataTable[cuisine].erase(rating);\\n        else dataTable[cuisine][rating].erase(food);\\n            \\n        dataTable[cuisine][newRating].insert(food);\\n        ratingTable[food] = newRating;\\n    }\\n    \\n    string highestRated(const string& cuisine) {\\n        return *dataTable[cuisine].rbegin()->second.begin();\\n    }\\n    \\nprivate:\\n    unordered_map<string, string>                cuisineTable; //food,cuisine\\n    unordered_map<string, int>                   ratingTable; //food,raiting\\n    unordered_map<string, map<int,set<string>>>  dataTable;  //cuisine,rating,foods\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(const vector<string>& foods,\\n                const vector<string>& cuisines,\\n                const vector<int>&    ratings  ) {\\n        \\n        for(size_t i=0; i<foods.size(); ++i) {\\n            cuisineTable[foods[i]] = cuisines[i];\\n            ratingTable [foods[i]] = ratings[i];\\n            dataTable[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(const string& food, int newRating) {\\n        int rating = ratingTable[food];\\n        string cuisine = cuisineTable[food];\\n        \\n        if(dataTable[cuisine][rating].size()==1)\\n            dataTable[cuisine].erase(rating);\\n        else dataTable[cuisine][rating].erase(food);\\n            \\n        dataTable[cuisine][newRating].insert(food);\\n        ratingTable[food] = newRating;\\n    }\\n    \\n    string highestRated(const string& cuisine) {\\n        return *dataTable[cuisine].rbegin()->second.begin();\\n    }\\n    \\nprivate:\\n    unordered_map<string, string>                cuisineTable; //food,cuisine\\n    unordered_map<string, int>                   ratingTable; //food,raiting\\n    unordered_map<string, map<int,set<string>>>  dataTable;  //cuisine,rating,foods\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701008,
                "title": "solution-1-sorted-list-solution-2-heap-python",
                "content": "**Sorted List** solution:\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.ratings = defaultdict(SortedList) # c --> [(-r, f), ...]\\n        self.frc = {} # f --> (c, r)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.ratings[c].add((-r, f))\\n            self.frc[f] = c, r\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, oldRating = self.frc[food]\\n        self.ratings[cuisine].remove((-oldRating, food))\\n        self.ratings[cuisine].add((-newRating, food))       \\n        self.frc[food] = (cuisine, newRating)\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.ratings[cuisine][0][1]\\n```\\n\\\\\\n**Heap** solution:\\n```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.ratings = defaultdict(list) # c --> [[-r, f], ...]\\n        self.frc = {} # f --> r, c\\n        \\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.ratings[c].append([-r, f])\\n            self.frc[f] = r, c\\n            \\n        for h in self.ratings.values():\\n            heapify(h)\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.frc[food][1]\\n        heappush(self.ratings[cuisine], [-newRating, food])\\n        self.frc[food] = (newRating, cuisine)    \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        heap = self.ratings[cuisine]\\n        while self.frc[heap[0][1]][0] != -heap[0][0]:\\n            heappop(heap)\\n        return heap[0][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.ratings = defaultdict(SortedList) # c --> [(-r, f), ...]\\n        self.frc = {} # f --> (c, r)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.ratings[c].add((-r, f))\\n            self.frc[f] = c, r\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, oldRating = self.frc[food]\\n        self.ratings[cuisine].remove((-oldRating, food))\\n        self.ratings[cuisine].add((-newRating, food))       \\n        self.frc[food] = (cuisine, newRating)\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.ratings[cuisine][0][1]\\n```\n```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.ratings = defaultdict(list) # c --> [[-r, f], ...]\\n        self.frc = {} # f --> r, c\\n        \\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.ratings[c].append([-r, f])\\n            self.frc[f] = r, c\\n            \\n        for h in self.ratings.values():\\n            heapify(h)\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.frc[food][1]\\n        heappush(self.ratings[cuisine], [-newRating, food])\\n        self.frc[food] = (newRating, cuisine)    \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        heap = self.ratings[cuisine]\\n        while self.frc[heap[0][1]][0] != -heap[0][0]:\\n            heappop(heap)\\n        return heap[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694641,
                "title": "python3-priority-queue-and-three-hashmaps",
                "content": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n      self.data_ = {}\\n      self.valid_ = defaultdict(int)\\n      self.lookup_ = defaultdict(str)\\n      for i in range(len(foods)):\\n        f, c, r = foods[i], cuisines[i], ratings[i]\\n        self.valid_[f] = -r\\n        self.lookup_[f] = c\\n        if c not in self.data_:\\n          self.data_[c] = [(-r, f)]\\n        else:\\n          self.data_[c].append((-r, f))\\n      for key in self.data_.keys():\\n        self.data_[key].sort(key = lambda x: (x[0], x[1]))\\n        heapify(self.data_[key])\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n      self.valid_[food] = -newRating\\n      heappush(self.data_[self.lookup_[food]], (-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n      while True:\\n        r, f = self.data_[cuisine][0]\\n        if self.valid_[f] == r:\\n          return f\\n        else:\\n          heappop(self.data_[cuisine])\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n      self.data_ = {}\\n      self.valid_ = defaultdict(int)\\n      self.lookup_ = defaultdict(str)\\n      for i in range(len(foods)):\\n        f, c, r = foods[i], cuisines[i], ratings[i]\\n        self.valid_[f] = -r\\n        self.lookup_[f] = c\\n        if c not in self.data_:\\n          self.data_[c] = [(-r, f)]\\n        else:\\n          self.data_[c].append((-r, f))\\n      for key in self.data_.keys():\\n        self.data_[key].sort(key = lambda x: (x[0], x[1]))\\n        heapify(self.data_[key])\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n      self.valid_[food] = -newRating\\n      heappush(self.data_[self.lookup_[food]], (-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n      while True:\\n        r, f = self.data_[cuisine][0]\\n        if self.valid_[f] == r:\\n          return f\\n        else:\\n          heappop(self.data_[cuisine])\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674015,
                "title": "golang-369-ms-20-mb",
                "content": "```\\ntype Food struct {\\n\\tname       string\\n\\trating     int32\\n\\tcuisineIdx int16\\n\\tcuisinePos int16\\n}\\n\\ntype Cuisine []*Food\\n\\nfunc (c Cuisine) Len() int { return len(c) }\\nfunc (c Cuisine) Less(i, j int) bool {\\n\\treturn c[i].rating > c[j].rating || (c[i].rating == c[j].rating && c[i].name < c[j].name)\\n}\\nfunc (c Cuisine) Swap(i, j int) {\\n\\tc[i].cuisinePos = int16(j)\\n\\tc[j].cuisinePos = int16(i)\\n\\tc[i], c[j] = c[j], c[i]\\n}\\nfunc (c *Cuisine) Push(x interface{}) { *c = append(*c, x.(*Food)) }\\nfunc (c *Cuisine) Pop() interface{} {\\n\\told := *c\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*c = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype FoodRatings struct {\\n\\tfoodNameToIdx    map[string]int16\\n\\tfoods            []Food\\n\\tcuisineNameToIdx map[string]int16\\n\\tcuisines         []Cuisine\\n}\\n\\nfunc Constructor(foods []string, cuisines []string, ratings []int) FoodRatings {\\n\\tfoodsSl := make([]Food, len(foods))\\n\\tfoodsM := make(map[string]int16, len(foods))\\n\\tcuisineM := make(map[string]int16)\\n\\n\\tfor i := 0; i < len(foods); i++ {\\n\\t\\tfoodsSl[i].name = foods[i]\\n\\t\\tfoodsSl[i].rating = int32(ratings[i])\\n\\t\\tfoodsM[foods[i]] = int16(i)\\n\\t\\tcuisineM[cuisines[i]]++\\n\\t}\\n\\n\\tcuisinesSl := make([]Cuisine, 0, len(cuisineM))\\n\\tfor cuisine, count := range cuisineM {\\n\\t\\tcuisineIdx := int16(len(cuisinesSl))\\n\\t\\tcuisinesSl = append(cuisinesSl, make([]*Food, 0, count))\\n\\t\\tcuisineM[cuisine] = cuisineIdx\\n\\t}\\n\\n\\tfor i := 0; i < len(foods); i++ {\\n\\t\\tcuisineIdx := cuisineM[cuisines[i]]\\n\\t\\tfoodsSl[i].cuisineIdx = cuisineIdx\\n\\t\\tfoodsSl[i].cuisinePos = int16(len(cuisinesSl[cuisineIdx]))\\n\\t\\tcuisinesSl[cuisineIdx] = append(cuisinesSl[cuisineIdx], &foodsSl[i])\\n\\t}\\n\\n\\tfor i := 0; i < len(cuisinesSl); i++ {\\n\\t\\theap.Init(&cuisinesSl[i])\\n\\t}\\n\\n\\treturn FoodRatings{\\n\\t\\tfoodNameToIdx:    foodsM,\\n\\t\\tfoods:            foodsSl,\\n\\t\\tcuisineNameToIdx: cuisineM,\\n\\t\\tcuisines:         cuisinesSl,\\n\\t}\\n}\\n\\nfunc (f FoodRatings) ChangeRating(foodName string, newRating int) {\\n\\tfoodIdx := f.foodNameToIdx[foodName]\\n\\tif f.foods[foodIdx].rating != int32(newRating) {\\n\\t\\tf.foods[foodIdx].rating = int32(newRating)\\n\\t\\theap.Fix(&f.cuisines[f.foods[foodIdx].cuisineIdx], int(f.foods[foodIdx].cuisinePos))\\n\\t}\\n}\\n\\nfunc (f FoodRatings) HighestRated(cuisine string) string {\\n\\treturn f.cuisines[f.cuisineNameToIdx[cuisine]][0].name\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Food struct {\\n\\tname       string\\n\\trating     int32\\n\\tcuisineIdx int16\\n\\tcuisinePos int16\\n}\\n\\ntype Cuisine []*Food\\n\\nfunc (c Cuisine) Len() int { return len(c) }\\nfunc (c Cuisine) Less(i, j int) bool {\\n\\treturn c[i].rating > c[j].rating || (c[i].rating == c[j].rating && c[i].name < c[j].name)\\n}\\nfunc (c Cuisine) Swap(i, j int) {\\n\\tc[i].cuisinePos = int16(j)\\n\\tc[j].cuisinePos = int16(i)\\n\\tc[i], c[j] = c[j], c[i]\\n}\\nfunc (c *Cuisine) Push(x interface{}) { *c = append(*c, x.(*Food)) }\\nfunc (c *Cuisine) Pop() interface{} {\\n\\told := *c\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*c = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype FoodRatings struct {\\n\\tfoodNameToIdx    map[string]int16\\n\\tfoods            []Food\\n\\tcuisineNameToIdx map[string]int16\\n\\tcuisines         []Cuisine\\n}\\n\\nfunc Constructor(foods []string, cuisines []string, ratings []int) FoodRatings {\\n\\tfoodsSl := make([]Food, len(foods))\\n\\tfoodsM := make(map[string]int16, len(foods))\\n\\tcuisineM := make(map[string]int16)\\n\\n\\tfor i := 0; i < len(foods); i++ {\\n\\t\\tfoodsSl[i].name = foods[i]\\n\\t\\tfoodsSl[i].rating = int32(ratings[i])\\n\\t\\tfoodsM[foods[i]] = int16(i)\\n\\t\\tcuisineM[cuisines[i]]++\\n\\t}\\n\\n\\tcuisinesSl := make([]Cuisine, 0, len(cuisineM))\\n\\tfor cuisine, count := range cuisineM {\\n\\t\\tcuisineIdx := int16(len(cuisinesSl))\\n\\t\\tcuisinesSl = append(cuisinesSl, make([]*Food, 0, count))\\n\\t\\tcuisineM[cuisine] = cuisineIdx\\n\\t}\\n\\n\\tfor i := 0; i < len(foods); i++ {\\n\\t\\tcuisineIdx := cuisineM[cuisines[i]]\\n\\t\\tfoodsSl[i].cuisineIdx = cuisineIdx\\n\\t\\tfoodsSl[i].cuisinePos = int16(len(cuisinesSl[cuisineIdx]))\\n\\t\\tcuisinesSl[cuisineIdx] = append(cuisinesSl[cuisineIdx], &foodsSl[i])\\n\\t}\\n\\n\\tfor i := 0; i < len(cuisinesSl); i++ {\\n\\t\\theap.Init(&cuisinesSl[i])\\n\\t}\\n\\n\\treturn FoodRatings{\\n\\t\\tfoodNameToIdx:    foodsM,\\n\\t\\tfoods:            foodsSl,\\n\\t\\tcuisineNameToIdx: cuisineM,\\n\\t\\tcuisines:         cuisinesSl,\\n\\t}\\n}\\n\\nfunc (f FoodRatings) ChangeRating(foodName string, newRating int) {\\n\\tfoodIdx := f.foodNameToIdx[foodName]\\n\\tif f.foods[foodIdx].rating != int32(newRating) {\\n\\t\\tf.foods[foodIdx].rating = int32(newRating)\\n\\t\\theap.Fix(&f.cuisines[f.foods[foodIdx].cuisineIdx], int(f.foods[foodIdx].cuisinePos))\\n\\t}\\n}\\n\\nfunc (f FoodRatings) HighestRated(cuisine string) string {\\n\\treturn f.cuisines[f.cuisineNameToIdx[cuisine]][0].name\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2663919,
                "title": "hashmap-and-ordered-set-c-easy-implementation",
                "content": "```\\nclass FoodRatings\\n{\\n    public:\\n\\n        unordered_map<string, int> food_rating;\\n    unordered_map<string, set<pair<int, string>>> cousin_rating;\\n    unordered_map<string, string> food_cousin;\\n\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            food_rating[foods[i]] = ratings[i];\\n            cousin_rating[cuisines[i]].insert({ -ratings[i],\\n                foods[i] });\\n            food_cousin[foods[i]] = cuisines[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        int curr_rating = food_rating[food];\\n\\n        food_rating[food] = newRating;\\n\\n        string find_cusine = food_cousin[food];\\n\\n       \\t\\n        cousin_rating[find_cusine].erase({ -curr_rating,\\n            food });\\n\\n        cousin_rating[find_cusine].insert({ -newRating,\\n            food });\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return cousin_rating[cuisine].begin()->second;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings\\n{\\n    public:\\n\\n        unordered_map<string, int> food_rating;\\n    unordered_map<string, set<pair<int, string>>> cousin_rating;\\n    unordered_map<string, string> food_cousin;\\n\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            food_rating[foods[i]] = ratings[i];\\n            cousin_rating[cuisines[i]].insert({ -ratings[i],\\n                foods[i] });\\n            food_cousin[foods[i]] = cuisines[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        int curr_rating = food_rating[food];\\n\\n        food_rating[food] = newRating;\\n\\n        string find_cusine = food_cousin[food];\\n\\n       \\t\\n        cousin_rating[find_cusine].erase({ -curr_rating,\\n            food });\\n\\n        cousin_rating[find_cusine].insert({ -newRating,\\n            food });\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return cousin_rating[cuisine].begin()->second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659084,
                "title": "three-map-custom-set-comparator-c",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    struct cmp{\\n        bool operator()(const pair<int,string> &a,const pair<int,string>& b)\\n        const {\\n            if(a.first!=b.first)\\n            {\\n                return a.first>b.first;\\n            }\\n            return a.second<b.second;\\n        }\\n    };\\n    \\n    unordered_map<string,set<pair<int,string>,cmp>> m;\\n    unordered_map<string,string> m2;\\n    unordered_map<string,pair<int,string>> m3;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<ratings.size();++i)\\n        {\\n            m[cuisines[i]].insert({ratings[i],foods[i]});\\n            m2[foods[i]]=cuisines[i];\\n            m3[foods[i]]={ratings[i],foods[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string& cuisi=m2[food];\\n        pair<int,string>& oldfood=m3[food];\\n        m[cuisi].erase(oldfood);\\n        m[cuisi].insert({newRating,food});\\n        m3[food]={newRating,food};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*(m[cuisine].begin())).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    struct cmp{\\n        bool operator()(const pair<int,string> &a,const pair<int,string>& b)\\n        const {\\n            if(a.first!=b.first)\\n            {\\n                return a.first>b.first;\\n            }\\n            return a.second<b.second;\\n        }\\n    };\\n    \\n    unordered_map<string,set<pair<int,string>,cmp>> m;\\n    unordered_map<string,string> m2;\\n    unordered_map<string,pair<int,string>> m3;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<ratings.size();++i)\\n        {\\n            m[cuisines[i]].insert({ratings[i],foods[i]});\\n            m2[foods[i]]=cuisines[i];\\n            m3[foods[i]]={ratings[i],foods[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string& cuisi=m2[food];\\n        pair<int,string>& oldfood=m3[food];\\n        m[cuisi].erase(oldfood);\\n        m[cuisi].insert({newRating,food});\\n        m3[food]={newRating,food};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*(m[cuisine].begin())).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610520,
                "title": "using-two-maps-oops-two-different-implementations-treeset-pq",
                "content": "```\\nUsing TreeSet + HashTable : Much Faster Than PriorityQueue Approach(Removal in TreeSet is Fast)\\n```\\n\\n```\\nclass FoodRatings {\\n    \\n    //Used to uniquely identfied the [food, rating] inside TreeSet to make\\n    //the search easier inside TreeSet\\n    private Map<String, FoodInfo> foodInfos; \\n    \\n    private Map<String, TreeSet<FoodInfo>> cuisinesMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisine, int[] ratings) {\\n        foodInfos = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            String name = foods[i], foodStyle = cuisine[i];\\n            int rating = ratings[i];\\n            \\n            FoodInfo foodObj = new FoodInfo(name, foodStyle, rating);\\n            \\n            cuisinesMap.putIfAbsent(foodStyle, new TreeSet<>((a, b) -> {\\n                if(a.rating == b.rating) return a.name.compareTo(b.name);\\n                return Integer.compare(b.rating, a.rating);\\n            }));\\n            \\n            cuisinesMap.get(foodStyle).add(foodObj);\\n            foodInfos.put(name, foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodInfo obj = foodInfos.get(food);\\n        TreeSet<FoodInfo> nameRatings = cuisinesMap.get(obj.cuisine);\\n        //Removal & Insertion : This step must be done to re-arrange the data [name, ratings] in TreeSet\\n        //After Updation in Rating.\\n        nameRatings.remove(obj);\\n        obj.rating = newRating;\\n        nameRatings.add(obj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first().name;\\n    }\\n    \\n    private class FoodInfo {\\n        String name;\\n        String cuisine;\\n        int rating;\\n        \\n        FoodInfo(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n```\\n\\n```\\nUsing PriorityQueue + HashTable\\n```\\n\\n```\\nclass FoodRatings {\\n\\n    private Map<String, FoodInfo> foodInfos;\\n    private Map<String, PriorityQueue<FoodInfo>> cuisinesMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisine, int[] ratings) {\\n        foodInfos = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            FoodInfo foodObj = new FoodInfo(foods[i], cuisine[i], ratings[i]);\\n            \\n            cuisinesMap.putIfAbsent(cuisine[i], new PriorityQueue<>((a, b) -> {\\n                if(a.rating == b.rating) return a.name.compareTo(b.name);\\n                return Integer.compare(b.rating, a.rating);\\n            }));\\n            \\n            cuisinesMap.get(cuisine[i]).offer(foodObj);\\n            foodInfos.put(foods[i], foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodInfo obj = foodInfos.get(food);\\n        PriorityQueue<FoodInfo> nameRatings = cuisinesMap.get(obj.cuisine);\\n        nameRatings.remove(obj); //This step makes this approach slower than TreeSet Approach\\n        obj.rating = newRating;\\n        nameRatings.offer(obj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).peek().name;\\n    }\\n    \\n    private class FoodInfo {\\n        String name;\\n        String cuisine;\\n        int rating;\\n        \\n        FoodInfo(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nUsing TreeSet + HashTable : Much Faster Than PriorityQueue Approach(Removal in TreeSet is Fast)\\n```\n```\\nclass FoodRatings {\\n    \\n    //Used to uniquely identfied the [food, rating] inside TreeSet to make\\n    //the search easier inside TreeSet\\n    private Map<String, FoodInfo> foodInfos; \\n    \\n    private Map<String, TreeSet<FoodInfo>> cuisinesMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisine, int[] ratings) {\\n        foodInfos = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            String name = foods[i], foodStyle = cuisine[i];\\n            int rating = ratings[i];\\n            \\n            FoodInfo foodObj = new FoodInfo(name, foodStyle, rating);\\n            \\n            cuisinesMap.putIfAbsent(foodStyle, new TreeSet<>((a, b) -> {\\n                if(a.rating == b.rating) return a.name.compareTo(b.name);\\n                return Integer.compare(b.rating, a.rating);\\n            }));\\n            \\n            cuisinesMap.get(foodStyle).add(foodObj);\\n            foodInfos.put(name, foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodInfo obj = foodInfos.get(food);\\n        TreeSet<FoodInfo> nameRatings = cuisinesMap.get(obj.cuisine);\\n        //Removal & Insertion : This step must be done to re-arrange the data [name, ratings] in TreeSet\\n        //After Updation in Rating.\\n        nameRatings.remove(obj);\\n        obj.rating = newRating;\\n        nameRatings.add(obj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first().name;\\n    }\\n    \\n    private class FoodInfo {\\n        String name;\\n        String cuisine;\\n        int rating;\\n        \\n        FoodInfo(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n```\n```\\nUsing PriorityQueue + HashTable\\n```\n```\\nclass FoodRatings {\\n\\n    private Map<String, FoodInfo> foodInfos;\\n    private Map<String, PriorityQueue<FoodInfo>> cuisinesMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisine, int[] ratings) {\\n        foodInfos = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            FoodInfo foodObj = new FoodInfo(foods[i], cuisine[i], ratings[i]);\\n            \\n            cuisinesMap.putIfAbsent(cuisine[i], new PriorityQueue<>((a, b) -> {\\n                if(a.rating == b.rating) return a.name.compareTo(b.name);\\n                return Integer.compare(b.rating, a.rating);\\n            }));\\n            \\n            cuisinesMap.get(cuisine[i]).offer(foodObj);\\n            foodInfos.put(foods[i], foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodInfo obj = foodInfos.get(food);\\n        PriorityQueue<FoodInfo> nameRatings = cuisinesMap.get(obj.cuisine);\\n        nameRatings.remove(obj); //This step makes this approach slower than TreeSet Approach\\n        obj.rating = newRating;\\n        nameRatings.offer(obj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).peek().name;\\n    }\\n    \\n    private class FoodInfo {\\n        String name;\\n        String cuisine;\\n        int rating;\\n        \\n        FoodInfo(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609133,
                "title": "using-three-maps-self-descriptive-codes-all-operations-are-in-proportion-to-log-items",
                "content": "```\\nclass FoodRatings {\\n\\n    //Used to hold [food_name ==> cuisine_type]\\n    private Map<String, String> typeOf;\\n    \\n    //Used to hold [cuisine_type => [(food_name, food_rating)]]\\n    private Map<String, TreeSet<Pair<String, Integer>>> cuisinesMap;\\n    \\n    //Used to hold food_name -> reference_of_food_info_in_treeSet\\n    private Map<String, Pair<String, Integer>> foodToInfo;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisinesMap = new HashMap<>();\\n        foodToInfo = new HashMap<>();\\n        typeOf = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            String foodName = foods[i], foodStyle = cuisines[i];\\n            int foodRating = ratings[i];\\n            cuisinesMap.putIfAbsent(foodStyle, new TreeSet<>((a, b) -> {\\n                Integer r1 = a.second, r2 = b.second;\\n                if(r1.equals(r2)) return a.first.compareTo(b.first); \\n                return Integer.compare(r2, r1);\\n            }));\\n            Pair<String, Integer> foodInfo = new Pair<>(foodName, foodRating);\\n            typeOf.put(foodName, foodStyle);\\n            cuisinesMap.get(foodStyle).add(foodInfo);\\n            foodToInfo.put(foodName, foodInfo);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Pair<String, Integer> foodInfo = foodToInfo.get(food);\\n        String foodStyle = typeOf.get(food);\\n         //removal & addition required to re-arrange the data in TreeSet\\n        cuisinesMap.get(foodStyle).remove(foodInfo);\\n        foodInfo.second = newRating;\\n        cuisinesMap.get(foodStyle).add(foodInfo);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first().first;\\n    }\\n    \\n    private static class Pair<T1, T2> {\\n\\t\\tT1 first;\\n\\t\\tT2 second;\\n\\n\\t\\tPair(T1 _first, T2 _second) {\\n\\t\\t\\tfirst = _first;\\n\\t\\t\\tsecond = _second;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"[\" + first.toString() + \",\" + second.toString() + \"]\";\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic int hashCode() {\\n\\t\\t\\treturn 31 * second.hashCode() + first.hashCode();\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic boolean equals(Object obj) {\\n\\t\\t\\tif(obj == null || obj.getClass() != this.getClass()) return false;\\n\\t\\t\\tif(obj == this) return true;\\n\\t\\t\\tPair<?, ?> p = (Pair)obj;\\n\\t\\t\\treturn this.first.equals(p.first) && this.second.equals(p.second);\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    //Used to hold [food_name ==> cuisine_type]\\n    private Map<String, String> typeOf;\\n    \\n    //Used to hold [cuisine_type => [(food_name, food_rating)]]\\n    private Map<String, TreeSet<Pair<String, Integer>>> cuisinesMap;\\n    \\n    //Used to hold food_name -> reference_of_food_info_in_treeSet\\n    private Map<String, Pair<String, Integer>> foodToInfo;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisinesMap = new HashMap<>();\\n        foodToInfo = new HashMap<>();\\n        typeOf = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            String foodName = foods[i], foodStyle = cuisines[i];\\n            int foodRating = ratings[i];\\n            cuisinesMap.putIfAbsent(foodStyle, new TreeSet<>((a, b) -> {\\n                Integer r1 = a.second, r2 = b.second;\\n                if(r1.equals(r2)) return a.first.compareTo(b.first); \\n                return Integer.compare(r2, r1);\\n            }));\\n            Pair<String, Integer> foodInfo = new Pair<>(foodName, foodRating);\\n            typeOf.put(foodName, foodStyle);\\n            cuisinesMap.get(foodStyle).add(foodInfo);\\n            foodToInfo.put(foodName, foodInfo);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Pair<String, Integer> foodInfo = foodToInfo.get(food);\\n        String foodStyle = typeOf.get(food);\\n         //removal & addition required to re-arrange the data in TreeSet\\n        cuisinesMap.get(foodStyle).remove(foodInfo);\\n        foodInfo.second = newRating;\\n        cuisinesMap.get(foodStyle).add(foodInfo);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first().first;\\n    }\\n    \\n    private static class Pair<T1, T2> {\\n\\t\\tT1 first;\\n\\t\\tT2 second;\\n\\n\\t\\tPair(T1 _first, T2 _second) {\\n\\t\\t\\tfirst = _first;\\n\\t\\t\\tsecond = _second;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"[\" + first.toString() + \",\" + second.toString() + \"]\";\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic int hashCode() {\\n\\t\\t\\treturn 31 * second.hashCode() + first.hashCode();\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic boolean equals(Object obj) {\\n\\t\\t\\tif(obj == null || obj.getClass() != this.getClass()) return false;\\n\\t\\t\\tif(obj == this) return true;\\n\\t\\t\\tPair<?, ?> p = (Pair)obj;\\n\\t\\t\\treturn this.first.equals(p.first) && this.second.equals(p.second);\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555337,
                "title": "unordered-map-set-98-faster-c",
                "content": "```\\nstruct comp{\\n    bool operator()(const pair<int,string>& a,const pair<int,string>& b) const{\\n        return a.first==b.first ? a.second<b.second : a.first>b.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,set<pair<int,string>,comp>> m;\\n    unordered_map<string,int> index;\\n    vector<string> c;\\n    vector<int> r;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        c=cuisines;\\n        r=ratings;\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            m[cuisines[i]].insert(make_pair(ratings[i],foods[i]));\\n            index[foods[i]]=i;\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int i=index[food];\\n        string cuisine = c[i];\\n        m[cuisine].erase(make_pair(r[i],food));\\n        m[cuisine].insert(make_pair(newRating,food));\\n        r[i]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = m[cuisine].begin();\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nstruct comp{\\n    bool operator()(const pair<int,string>& a,const pair<int,string>& b) const{\\n        return a.first==b.first ? a.second<b.second : a.first>b.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,set<pair<int,string>,comp>> m;\\n    unordered_map<string,int> index;\\n    vector<string> c;\\n    vector<int> r;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        c=cuisines;\\n        r=ratings;\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            m[cuisines[i]].insert(make_pair(ratings[i],foods[i]));\\n            index[foods[i]]=i;\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int i=index[food];\\n        string cuisine = c[i];\\n        m[cuisine].erase(make_pair(r[i],food));\\n        m[cuisine].insert(make_pair(newRating,food));\\n        r[i]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = m[cuisine].begin();\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545864,
                "title": "2-maps-used-c-simple-and-clean",
                "content": "class FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int,string>>> cuisineMP; // cuisine -> (raintg,food)\\n    unordered_map<string,pair<int,string>> foodMP; // food -> (rating,cuisine)\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        \\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            // pushing the food and cuisine in negative rating so that the highest rating is on top\\n            cuisineMP[cuisines[i]].insert({-ratings[i],foods[i]});\\n            foodMP[foods[i]] = {-ratings[i],cuisines[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [currRating,cuisine] = foodMP[food];\\n        \\n        foodMP[food] = {-newRating,cuisine};\\n        \\n        cuisineMP[cuisine].erase({currRating,food});\\n        cuisineMP[cuisine].insert({-newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        return cuisineMP[cuisine].begin()->second;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int,string>>> cuisineMP; // cuisine -> (raintg,food)\\n    unordered_map<string,pair<int,string>> foodMP; // food -> (rating,cuisine)\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        \\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            // pushing the food and cuisine in negative rating so that the highest rating is on top\\n            cuisineMP[cuisines[i]].insert({-ratings[i],foods[i]});\\n            foodMP[foods[i]] = {-ratings[i],cuisines[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [currRating,cuisine] = foodMP[food];\\n        \\n        foodMP[food] = {-newRating,cuisine};\\n        \\n        cuisineMP[cuisine].erase({currRating,food});\\n        cuisineMP[cuisine].insert({-newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        return cuisineMP[cuisine].begin()->second;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2519918,
                "title": "3-maps-used-most-simple-c-solution",
                "content": "class FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int, string>>> cuisine_ratings;\\n    unordered_map<string, string> food_cuisine;\\n    unordered_map<string, int> food_rating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); ++i) {\\n            cuisine_ratings[cuisines[i]].insert({ -ratings[i], foods[i] });\\n            food_cuisine[foods[i]] = cuisines[i];\\n            food_rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto &cuisine = food_cuisine.find(food)->second;\\n        cuisine_ratings[cuisine].erase({ -food_rating[food], food });\\n        cuisine_ratings[cuisine].insert({ -newRating, food });\\n        food_rating[food] = newRating;\\n    }\\n    string highestRated(string cuisine) {\\n        return cuisine_ratings[cuisine].begin()->second;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "class FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int, string>>> cuisine_ratings;\\n    unordered_map<string, string> food_cuisine;\\n    unordered_map<string, int> food_rating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); ++i) {\\n            cuisine_ratings[cuisines[i]].insert({ -ratings[i], foods[i] });\\n            food_cuisine[foods[i]] = cuisines[i];\\n            food_rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto &cuisine = food_cuisine.find(food)->second;\\n        cuisine_ratings[cuisine].erase({ -food_rating[food], food });\\n        cuisine_ratings[cuisine].insert({ -newRating, food });\\n        food_rating[food] = newRating;\\n    }\\n    string highestRated(string cuisine) {\\n        return cuisine_ratings[cuisine].begin()->second;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2507622,
                "title": "two-maps",
                "content": "```\\n\\nclass FoodRatings {\\n    unordered_map<string,pair<string,int>> food;\\n    unordered_map<string,set<pair<int,string>>> cuisine;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            food[foods[i]] = {cuisines[i],ratings[i]} ;\\n            \\n            cuisine[cuisines[i]].insert( {-ratings[i],foods[i]} );\\n        }\\n    }\\n    \\n    void changeRating(string f, int newRating) {\\n        \\n        string c = food[f].first;\\n        cuisine[c].erase({-food[f].second,f});\\n        food[f].second = newRating;\\n        cuisine[c].insert({-newRating,f});\\n    }\\n    \\n    string highestRated(string c) {\\n       return begin(cuisine[c])->second;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\nclass FoodRatings {\\n    unordered_map<string,pair<string,int>> food;\\n    unordered_map<string,set<pair<int,string>>> cuisine;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            food[foods[i]] = {cuisines[i],ratings[i]} ;\\n            \\n            cuisine[cuisines[i]].insert( {-ratings[i],foods[i]} );\\n        }\\n    }\\n    \\n    void changeRating(string f, int newRating) {\\n        \\n        string c = food[f].first;\\n        cuisine[c].erase({-food[f].second,f});\\n        food[f].second = newRating;\\n        cuisine[c].insert({-newRating,f});\\n    }\\n    \\n    string highestRated(string c) {\\n       return begin(cuisine[c])->second;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2502142,
                "title": "python-hashmap-maxheap-solution",
                "content": "This problem can be solved with exactly the same algorithm with [Leetcode 2349](https://leetcode.com/problems/design-a-number-container-system/discuss/2502175/Python-hashmap-%2B-min_heap-solution) \\n\\n```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food2cui = dict(zip(foods, cuisines))\\n        self.cui2heap = defaultdict(list)   # {cuisine:[(-rate, food)]}\\n        self.rate = defaultdict(dict)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.rate[c][f] = -r\\n            heappush(self.cui2heap[c], (-r, f))\\n\\n    def changeRating(self, f: str, r: int) -> None:\\n        c = self.food2cui[f]\\n        self.rate[c][f] = -r\\n        heappush(self.cui2heap[c], (-r, f))\\n\\n    def highestRated(self, c: str) -> str:\\n\\t\\t# remove the top element with unmatched rate in self.rate \\n        while(self.rate[c][self.cui2heap[c][0][1]]!=self.cui2heap[c][0][0]):\\n            heappop(self.cui2heap[c])\\n        return self.cui2heap[c][0][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food2cui = dict(zip(foods, cuisines))\\n        self.cui2heap = defaultdict(list)   # {cuisine:[(-rate, food)]}\\n        self.rate = defaultdict(dict)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.rate[c][f] = -r\\n            heappush(self.cui2heap[c], (-r, f))\\n\\n    def changeRating(self, f: str, r: int) -> None:\\n        c = self.food2cui[f]\\n        self.rate[c][f] = -r\\n        heappush(self.cui2heap[c], (-r, f))\\n\\n    def highestRated(self, c: str) -> str:\\n\\t\\t# remove the top element with unmatched rate in self.rate \\n        while(self.rate[c][self.cui2heap[c][0][1]]!=self.cui2heap[c][0][0]):\\n            heappop(self.cui2heap[c])\\n        return self.cui2heap[c][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501823,
                "title": "c-string-view",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < size(foods); i++) {\\n            f2c[foods[i]] = cuisines[i];\\n            f2r[foods[i]] = ratings[i];\\n            c2r[cuisines[i]].emplace(-ratings[i], foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int r = exchange(f2r[food], newRating);\\n        auto& c = f2c[food];\\n        auto it = c2r.find(c);\\n        it->second.erase({-r, food});\\n        it->second.emplace(-newRating, food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return begin(c2r[cuisine])->second;\\n    }\\nprivate:\\n    unordered_map<string_view, string_view> f2c;\\n    unordered_map<string_view, int> f2r;\\n    unordered_map<string_view, set<pair<int, string>>> c2r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < size(foods); i++) {\\n            f2c[foods[i]] = cuisines[i];\\n            f2r[foods[i]] = ratings[i];\\n            c2r[cuisines[i]].emplace(-ratings[i], foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int r = exchange(f2r[food], newRating);\\n        auto& c = f2c[food];\\n        auto it = c2r.find(c);\\n        it->second.erase({-r, food});\\n        it->second.emplace(-newRating, food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return begin(c2r[cuisine])->second;\\n    }\\nprivate:\\n    unordered_map<string_view, string_view> f2c;\\n    unordered_map<string_view, int> f2r;\\n    unordered_map<string_view, set<pair<int, string>>> c2r;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475611,
                "title": "python-help",
                "content": "I am alway take Time exceed error but code is working. How can I edit this code to be fast.\\n\\n```\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food = foods #to find exact index. I think it is easy way\\n        self.Cus  = cuisines\\n        self.Rates = ratings\\n        self.SizeFoods = len(foods)\\n        self.FandRC = {i:[j, k] for i, j, k in zip(foods, cuisines, ratings)}\\n    \\n    def changeRating(self, food: str, newRating: int) -> None:        \\n        indexF = self.food.index(food)\\n        self.Rates[indexF] = newRating \\n        self.FandRC[food][1] = newRating\\n        \\n        #We have changed rate of food.\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        \\n        FoodNames = list()\\n        MaxRate    =  max([i[1] for i in self.FandRC.values() if i[0] == cuisine])\\n        constrain = self.Cus.count(cuisine)\\n        counter = 0\\n        i = self.Rates.index(MaxRate)\\n        while counter < constrain:\\n          \\n            if self.Cus[i] == cuisine:\\n                    FoodNames.append(self.food[i])\\n                    FoodNames = list(set(FoodNames))\\n                    counter +=1\\n            \\n            if MaxRate not in self.Rates[i+1:]:\\n                break\\n            \\n            i = self.Rates[i+1:].index(MaxRate) + i + 1\\n            \\n                    \\n        \\n        \\n        \\n        \\n        return sorted(FoodNames)[0]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food = foods #to find exact index. I think it is easy way\\n        self.Cus  = cuisines\\n        self.Rates = ratings\\n        self.SizeFoods = len(foods)\\n        self.FandRC = {i:[j, k] for i, j, k in zip(foods, cuisines, ratings)}\\n    \\n    def changeRating(self, food: str, newRating: int) -> None:        \\n        indexF = self.food.index(food)\\n        self.Rates[indexF] = newRating \\n        self.FandRC[food][1] = newRating\\n        \\n        #We have changed rate of food.\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        \\n        FoodNames = list()\\n        MaxRate    =  max([i[1] for i in self.FandRC.values() if i[0] == cuisine])\\n        constrain = self.Cus.count(cuisine)\\n        counter = 0\\n        i = self.Rates.index(MaxRate)\\n        while counter < constrain:\\n          \\n            if self.Cus[i] == cuisine:\\n                    FoodNames.append(self.food[i])\\n                    FoodNames = list(set(FoodNames))\\n                    counter +=1\\n            \\n            if MaxRate not in self.Rates[i+1:]:\\n                break\\n            \\n            i = self.Rates[i+1:].index(MaxRate) + i + 1\\n            \\n                    \\n        \\n        \\n        \\n        \\n        return sorted(FoodNames)[0]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415059,
                "title": "java-solution-custom-class-priorityqueue-custom-sorting-2-hashmap",
                "content": "```\\nclass FoodRatings {\\n    class Food{\\n        String foodItem;\\n        String cuisine;\\n        int rating;\\n        Food(String foodItem,String cuisine,int rating){\\n            this.foodItem = foodItem;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    HashMap<String,Food> foodItems;\\n    HashMap<String,PriorityQueue<Food>> highestRatingFood;    \\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodItems = new HashMap<>();\\n        highestRatingFood = new HashMap<>();\\n        \\n        for(int i=0;i<foods.length;i++){\\n            Food food = new Food(foods[i],cuisines[i],ratings[i]);\\n            foodItems.put(foods[i],food); // Since its gaurenteed all foods[i] is unique, directly adding in the hashmap.\\n            PriorityQueue<Food> pq;\\n            if(highestRatingFood.containsKey(cuisines[i]))\\n                pq = highestRatingFood.get(cuisines[i]);\\n            else\\n                pq = new PriorityQueue<>((a,b)->b.rating == a.rating ? a.foodItem.compareTo(b.foodItem) : b.rating-a.rating); // Desc Order.\\n            pq.add(food);\\n            highestRatingFood.put(cuisines[i],pq);\\n        }\\n    }\\n    public void changeRating(String food, int newRating) {\\n        Food prevHistory = foodItems.get(food);\\n        PriorityQueue<Food> pq = highestRatingFood.get(prevHistory.cuisine);\\n        pq.remove(prevHistory); //Removing the old value\\n        prevHistory.rating = newRating;  //Updating Rating\\n        pq.add(prevHistory); //Adding it back\\n        highestRatingFood.put(prevHistory.cuisine,pq); // Updating cuising\\n        foodItems.put(food,prevHistory); // Not needed yet updated.\\n    }\\n    public String highestRated(String cuisine) {\\n        return highestRatingFood.get(cuisine).peek().foodItem;\\n    }    \\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n\\n// kimchi 9\\n// bulgogi 7\\n// AAAA\\n\\n// ramen 14\\n// miso 12\\n// sushi 8\\n// AAAA\\n\\n// sushi 16\\n// AAAA\\n// ramen 16\\n// AAAA\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\n    class Food{\\n        String foodItem;\\n        String cuisine;\\n        int rating;\\n        Food(String foodItem,String cuisine,int rating){\\n            this.foodItem = foodItem;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    HashMap<String,Food> foodItems;\\n    HashMap<String,PriorityQueue<Food>> highestRatingFood;    \\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodItems = new HashMap<>();\\n        highestRatingFood = new HashMap<>();\\n        \\n        for(int i=0;i<foods.length;i++){\\n            Food food = new Food(foods[i],cuisines[i],ratings[i]);\\n            foodItems.put(foods[i],food); // Since its gaurenteed all foods[i] is unique, directly adding in the hashmap.\\n            PriorityQueue<Food> pq;\\n            if(highestRatingFood.containsKey(cuisines[i]))\\n                pq = highestRatingFood.get(cuisines[i]);\\n            else\\n                pq = new PriorityQueue<>((a,b)->b.rating == a.rating ? a.foodItem.compareTo(b.foodItem) : b.rating-a.rating); // Desc Order.\\n            pq.add(food);\\n            highestRatingFood.put(cuisines[i],pq);\\n        }\\n    }\\n    public void changeRating(String food, int newRating) {\\n        Food prevHistory = foodItems.get(food);\\n        PriorityQueue<Food> pq = highestRatingFood.get(prevHistory.cuisine);\\n        pq.remove(prevHistory); //Removing the old value\\n        prevHistory.rating = newRating;  //Updating Rating\\n        pq.add(prevHistory); //Adding it back\\n        highestRatingFood.put(prevHistory.cuisine,pq); // Updating cuising\\n        foodItems.put(food,prevHistory); // Not needed yet updated.\\n    }\\n    public String highestRated(String cuisine) {\\n        return highestRatingFood.get(cuisine).peek().foodItem;\\n    }    \\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n\\n// kimchi 9\\n// bulgogi 7\\n// AAAA\\n\\n// ramen 14\\n// miso 12\\n// sushi 8\\n// AAAA\\n\\n// sushi 16\\n// AAAA\\n// ramen 16\\n// AAAA\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411832,
                "title": "c-solution",
                "content": "We avoid TLE via an *ordered* set for logarithmic indels (insertions/deletions), ie. we store foods sorted by rating per cuisine in a `bucket`.\\n\\n```\\nclass FoodRatings {\\npublic:\\n    using VI = vector<int>;\\n    using VS = vector<string>;\\n    using Pair = pair<int, string>; // rating, food\\n    struct Comp {\\n        bool operator()(const Pair& a, const Pair& b) const {\\n            return a.first == b.first ? a.second < b.second : b.first < a.first;\\n        }\\n    };\\n    using Set = set<Pair, Comp>;\\n    using CuisineFoods = unordered_map<string, Set>;   // cuisine -> foods\\n    using FoodCuisine = unordered_map<string, string>; // food -> cuisine\\n    using FoodRating = unordered_map<string, int>;     // food -> rating\\n    CuisineFoods bucket;\\n    FoodCuisine type;\\n    FoodRating rating;\\n    FoodRatings(VS& foods, VS& cuisines, VI& ratings) {\\n        int N = foods.size();\\n        for (auto i{ 0 }; i < N; ++i) {\\n            bucket[cuisines[i]].emplace(ratings[i], foods[i]);\\n            type[foods[i]] = cuisines[i];\\n            rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto oldRating = rating[food];\\n        rating[food] = newRating;\\n        auto cuisine = type[food];\\n        bucket[cuisine].erase({oldRating, food});\\n        bucket[cuisine].emplace(newRating, food);\\n    }\\n    string highestRated(string cuisine) {\\n        auto it = bucket[cuisine].begin();\\n        auto [_, food] = make_pair(it->first, it->second);\\n        return food;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    using VI = vector<int>;\\n    using VS = vector<string>;\\n    using Pair = pair<int, string>; // rating, food\\n    struct Comp {\\n        bool operator()(const Pair& a, const Pair& b) const {\\n            return a.first == b.first ? a.second < b.second : b.first < a.first;\\n        }\\n    };\\n    using Set = set<Pair, Comp>;\\n    using CuisineFoods = unordered_map<string, Set>;   // cuisine -> foods\\n    using FoodCuisine = unordered_map<string, string>; // food -> cuisine\\n    using FoodRating = unordered_map<string, int>;     // food -> rating\\n    CuisineFoods bucket;\\n    FoodCuisine type;\\n    FoodRating rating;\\n    FoodRatings(VS& foods, VS& cuisines, VI& ratings) {\\n        int N = foods.size();\\n        for (auto i{ 0 }; i < N; ++i) {\\n            bucket[cuisines[i]].emplace(ratings[i], foods[i]);\\n            type[foods[i]] = cuisines[i];\\n            rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto oldRating = rating[food];\\n        rating[food] = newRating;\\n        auto cuisine = type[food];\\n        bucket[cuisine].erase({oldRating, food});\\n        bucket[cuisine].emplace(newRating, food);\\n    }\\n    string highestRated(string cuisine) {\\n        auto it = bucket[cuisine].begin();\\n        auto [_, food] = make_pair(it->first, it->second);\\n        return food;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411061,
                "title": "java-custom-food-class-comparable-interface-hashmap-treeset",
                "content": "**Time Complexity:**\\n*changeRating* can be done in *O(log(N))* complexity where N is total number of foods (length of foods array)\\n*highest rated food can be retrived in O(1)* complexity\\n\\nFoodRatings class initialization thorugh constructor takes O(N * log(N) time;\\n\\n**Space Complexity :**\\n3 hashMaps of N lengths\\nfor each key in one hashmap we have a TreeSet of average length 1;\\nO(3N+N) > O(4N) > *O(N)*\\n\\n```\\nclass FoodRatings {\\n    \\n    //custom Food class to store food name and rating\\n    private class Food implements Comparable<Food>{\\n        String name;\\n        int rating;\\n        \\n        Food(String name, int rating){\\n            this.name = name;\\n            this.rating = rating;\\n        }\\n        \\n        public int compareTo(Food food){\\n            if(this.rating == food.rating)\\n                return this.name.compareTo(food.name);\\n            return food.rating-this.rating;\\n        }\\n    }\\n    \\n    //this hashMap will map foods according to cuisine\\n    //used treeSet so we always get highest priority food  ( Treating it like priorit queue)\\n    //used Custom Food class which implements Comparable<T> interface, compareTo Method is written keeping in mind that, food should be sorted based on desc order of rating and then as per lexicographical order of food name\\n    HashMap<String, TreeSet<Food>> cuisineToFoods = new HashMap<>();\\n    \\n    //this hashMap maps food to cuisine\\n    HashMap<String, String> foodToCuisine = new HashMap<>();\\n    \\n    //this hashMap maps food to its rating\\n    HashMap<String, Integer> foodToRating = new HashMap<>();\\n    \\n    //initializes above defined maps\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.length; i++){\\n            foodToCuisine.put(foods[i], cuisines[i]);\\n            \\n            Food f = new Food(foods[i], ratings[i]);\\n            \\n            TreeSet<Food> tempSet = cuisineToFoods.getOrDefault(cuisines[i], new TreeSet<>());\\n            tempSet.add(f);\\n            cuisineToFoods.put(cuisines[i], tempSet);\\n            foodToRating.putIfAbsent(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    // takes out food from tempSet (TreeSet) O(Log(N)) timeComplexity\\n    // adds food with new Rating to tempSet o(Log(N)) timeComplexity\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodToCuisine.get(food);\\n        TreeSet<Food> tempSet = cuisineToFoods.get(cuisine);\\n        \\n        int rating = foodToRating.get(food);\\n        Food crit = new Food(food,rating);\\n        //System.out.println(\"Rating will be removed for food:\"+ food +\" with crit as follows\");\\n        //System.out.println(crit.name+\" \"+ crit.rating);\\n        //System.out.println(\"size before\"+ tempSet.size());\\n        tempSet.remove(crit);\\n        //System.out.println(\"size after\"+tempSet.size());\\n        crit.rating = newRating;\\n        tempSet.add(crit);\\n        foodToRating.put(food,newRating);\\n        return;\\n    }\\n    \\n    //Retrives in constant time O(1) time complexity\\n    public String highestRated(String cuisine) {\\n        TreeSet<Food> tempSet = cuisineToFoods.get(cuisine);\\n        \\n        return tempSet.first().name;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    \\n    //custom Food class to store food name and rating\\n    private class Food implements Comparable<Food>{\\n        String name;\\n        int rating;\\n        \\n        Food(String name, int rating){\\n            this.name = name;\\n            this.rating = rating;\\n        }\\n        \\n        public int compareTo(Food food){\\n            if(this.rating == food.rating)\\n                return this.name.compareTo(food.name);\\n            return food.rating-this.rating;\\n        }\\n    }\\n    \\n    //this hashMap will map foods according to cuisine\\n    //used treeSet so we always get highest priority food  ( Treating it like priorit queue)\\n    //used Custom Food class which implements Comparable<T> interface, compareTo Method is written keeping in mind that, food should be sorted based on desc order of rating and then as per lexicographical order of food name\\n    HashMap<String, TreeSet<Food>> cuisineToFoods = new HashMap<>();\\n    \\n    //this hashMap maps food to cuisine\\n    HashMap<String, String> foodToCuisine = new HashMap<>();\\n    \\n    //this hashMap maps food to its rating\\n    HashMap<String, Integer> foodToRating = new HashMap<>();\\n    \\n    //initializes above defined maps\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.length; i++){\\n            foodToCuisine.put(foods[i], cuisines[i]);\\n            \\n            Food f = new Food(foods[i], ratings[i]);\\n            \\n            TreeSet<Food> tempSet = cuisineToFoods.getOrDefault(cuisines[i], new TreeSet<>());\\n            tempSet.add(f);\\n            cuisineToFoods.put(cuisines[i], tempSet);\\n            foodToRating.putIfAbsent(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    // takes out food from tempSet (TreeSet) O(Log(N)) timeComplexity\\n    // adds food with new Rating to tempSet o(Log(N)) timeComplexity\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodToCuisine.get(food);\\n        TreeSet<Food> tempSet = cuisineToFoods.get(cuisine);\\n        \\n        int rating = foodToRating.get(food);\\n        Food crit = new Food(food,rating);\\n        //System.out.println(\"Rating will be removed for food:\"+ food +\" with crit as follows\");\\n        //System.out.println(crit.name+\" \"+ crit.rating);\\n        //System.out.println(\"size before\"+ tempSet.size());\\n        tempSet.remove(crit);\\n        //System.out.println(\"size after\"+tempSet.size());\\n        crit.rating = newRating;\\n        tempSet.add(crit);\\n        foodToRating.put(food,newRating);\\n        return;\\n    }\\n    \\n    //Retrives in constant time O(1) time complexity\\n    public String highestRated(String cuisine) {\\n        TreeSet<Food> tempSet = cuisineToFoods.get(cuisine);\\n        \\n        return tempSet.first().name;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401281,
                "title": "design-the-system-using-multiset-map",
                "content": "```\\nstruct person {\\n        string name;\\n        int value;\\n    };\\n\\nbool operator< (person a, person b)\\n    {\\n        if(a.value!=b.value)\\n            return a.value>b.value;\\n        string t_a = a.name, t_b = b.name;\\n        return lexicographical_compare(t_a.begin(), t_a.end(),\\n                                      t_b.begin(), t_b.end());\\n    }\\n\\nclass FoodRatings {\\npublic:\\n    \\n    //Change Rating: Unordered Map\\n    // Highest Rated: Heap\\n    \\n    // Problem? If rating change is O(1), then Highest Rated would be O(n)\\n    \\n    // i_to_s -> map int to cusine\\n    // s_to_i -> reverse of i_to_s\\n    \\n    // food_to_i -> map food to its corresponding rating\\n    unordered_map<int, string>i_to_s; unordered_map<string, int>s_to_i, food_to_i;\\n    \\n    // Would map food to its corresponding cuision\\n    unordered_map<string, string>food_to_cuisine;    \\n    \\n    // Would contain the sorted value by rating\\n    vector<multiset<person>>v;    \\n\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {   \\n        int count = 0; int food_id = 0;\\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            food_to_i[foods[i]] = ratings[i];\\n            food_to_cuisine[foods[i]] = cuisines[i];\\n            \\n            if(s_to_i.find(cuisines[i]) == s_to_i.end())\\n            {\\n                i_to_s[count] = cuisines[i];\\n                s_to_i[cuisines[i]] = count;\\n                count++;\\n                person p; p.name = foods[i];\\n                p.value = ratings[i];\\n                multiset<person>ms; ms.insert(p);\\n                v.push_back(ms);\\n            }\\n            else\\n            {\\n                person p; p.name = foods[i];\\n                p.value = ratings[i];\\n                v[s_to_i[cuisines[i]]].insert(p);\\n            }            \\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        // Getting the current rating\\n        int curr_rate = food_to_i[food];\\n        food_to_i[food] = newRating;\\n        \\n        // Getting the cuisine of the food\\n        int cuisine = s_to_i[food_to_cuisine[food]];\\n        \\n        // Erasing the old rating\\n        person p; p.value = curr_rate, p.name = food;\\n        v[cuisine].erase(v[cuisine].find(p));\\n        \\n        // Inserting the new rating\\n        p.value = newRating;\\n        v[cuisine].insert(p);\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        if(s_to_i.find(cuisine) == s_to_i.end())\\n                return \"None\";\\n        int cu = s_to_i[cuisine];\\n        // for(auto &itr: v[cu])\\n        //     cout<<itr.name<<\" \"<<itr.value<<endl;\\n        return (v[cu].begin())->name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nstruct person {\\n        string name;\\n        int value;\\n    };\\n\\nbool operator< (person a, person b)\\n    {\\n        if(a.value!=b.value)\\n            return a.value>b.value;\\n        string t_a = a.name, t_b = b.name;\\n        return lexicographical_compare(t_a.begin(), t_a.end(),\\n                                      t_b.begin(), t_b.end());\\n    }\\n\\nclass FoodRatings {\\npublic:\\n    \\n    //Change Rating: Unordered Map\\n    // Highest Rated: Heap\\n    \\n    // Problem? If rating change is O(1), then Highest Rated would be O(n)\\n    \\n    // i_to_s -> map int to cusine\\n    // s_to_i -> reverse of i_to_s\\n    \\n    // food_to_i -> map food to its corresponding rating\\n    unordered_map<int, string>i_to_s; unordered_map<string, int>s_to_i, food_to_i;\\n    \\n    // Would map food to its corresponding cuision\\n    unordered_map<string, string>food_to_cuisine;    \\n    \\n    // Would contain the sorted value by rating\\n    vector<multiset<person>>v;    \\n\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {   \\n        int count = 0; int food_id = 0;\\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            food_to_i[foods[i]] = ratings[i];\\n            food_to_cuisine[foods[i]] = cuisines[i];\\n            \\n            if(s_to_i.find(cuisines[i]) == s_to_i.end())\\n            {\\n                i_to_s[count] = cuisines[i];\\n                s_to_i[cuisines[i]] = count;\\n                count++;\\n                person p; p.name = foods[i];\\n                p.value = ratings[i];\\n                multiset<person>ms; ms.insert(p);\\n                v.push_back(ms);\\n            }\\n            else\\n            {\\n                person p; p.name = foods[i];\\n                p.value = ratings[i];\\n                v[s_to_i[cuisines[i]]].insert(p);\\n            }            \\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        // Getting the current rating\\n        int curr_rate = food_to_i[food];\\n        food_to_i[food] = newRating;\\n        \\n        // Getting the cuisine of the food\\n        int cuisine = s_to_i[food_to_cuisine[food]];\\n        \\n        // Erasing the old rating\\n        person p; p.value = curr_rate, p.name = food;\\n        v[cuisine].erase(v[cuisine].find(p));\\n        \\n        // Inserting the new rating\\n        p.value = newRating;\\n        v[cuisine].insert(p);\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        if(s_to_i.find(cuisine) == s_to_i.end())\\n                return \"None\";\\n        int cu = s_to_i[cuisine];\\n        // for(auto &itr: v[cu])\\n        //     cout<<itr.name<<\" \"<<itr.value<<endl;\\n        return (v[cu].begin())->name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2396100,
                "title": "python-single-source-of-truth",
                "content": "```class FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.size = len(foods)\\n        self.foodToCuisine,self.ratingMap,self.cuisineToFood = self.getMaps()\\n\\n    def getMaps(self):\\n        ftc = {}\\n        r = {}\\n        ctf = defaultdict(list)\\n        for i in range(self.size):\\n            ftc[self.foods[i]] = self.cuisines[i]\\n            heapq.heappush(ctf[self.cuisines[i]],(-self.ratings[i],self.foods[i]))\\n            r[self.foods[i]] = self.ratings[i]\\n        return ftc,r,ctf\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.ratingMap[food] = newRating\\n        heapq.heappush(self.cuisineToFood[self.foodToCuisine[food]],(-newRating,food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating,food = self.cuisineToFood[cuisine][0]\\n        while -rating != self.ratingMap[food]:\\n            heapq.heappop(self.cuisineToFood[cuisine])\\n            rating,food = self.cuisineToFood[cuisine][0]\\n        return food\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.size = len(foods)\\n        self.foodToCuisine,self.ratingMap,self.cuisineToFood = self.getMaps()\\n\\n    def getMaps(self):\\n        ftc = {}\\n        r = {}\\n        ctf = defaultdict(list)\\n        for i in range(self.size):\\n            ftc[self.foods[i]] = self.cuisines[i]\\n            heapq.heappush(ctf[self.cuisines[i]],(-self.ratings[i],self.foods[i]))\\n            r[self.foods[i]] = self.ratings[i]\\n        return ftc,r,ctf\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.ratingMap[food] = newRating\\n        heapq.heappush(self.cuisineToFood[self.foodToCuisine[food]],(-newRating,food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating,food = self.cuisineToFood[cuisine][0]\\n        while -rating != self.ratingMap[food]:\\n            heapq.heappop(self.cuisineToFood[cuisine])\\n            rating,food = self.cuisineToFood[cuisine][0]\\n        return food\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)",
                "codeTag": "Java"
            },
            {
                "id": 2394925,
                "title": "soln-using-dictionaries",
                "content": "```\\nclass FoodRatings:\\n    from sortedcontainers import SortedList\\n        \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.dp = defaultdict()\\n        self.f_c = defaultdict()\\n        self.f_r = defaultdict()\\n        for food, cuisine, rating in zip(foods,cuisines,ratings):\\n            #print(food, cuisine, rating)\\n            self.f_c[food] = [cuisine,rating]\\n            \\n            if cuisine in self.dp:\\n                d = self.dp[cuisine]\\n                d1 = self.f_r[cuisine]\\n                if rating in d:\\n                    sorted_list =  d[rating]\\n                    sorted_list.add(food)\\n                else:\\n                    sorted_list = SortedList()\\n                    sorted_list.add(food)\\n                    d[rating] = sorted_list\\n                    d1.add(rating)\\n            else:\\n                from sortedcontainers import SortedList\\n                sorted_r = SortedList()\\n                sorted_list = SortedList()\\n                sorted_list.add(food)\\n                sorted_r.add(rating)\\n                d = defaultdict(SortedList)\\n                d[rating] = sorted_list\\n                self.dp[cuisine] = d\\n                self.f_r[cuisine] = sorted_r\\n                \\n                \\n        #for i in self.f_r:\\n        #    print(i,self.f_r[i])\\n        \\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, rating = self.f_c[food]\\n        rl = self.f_r[cuisine]\\n        f_r = self.dp[cuisine]\\n        self.f_c[food]= [cuisine, newRating]\\n        if newRating in f_r:\\n            sorted_list =  f_r[newRating]\\n            sorted_list.add(food)\\n        else:\\n            from sortedcontainers import SortedList\\n\\n            sorted_list = SortedList()\\n            sorted_list.add(food)\\n            f_r[newRating] = sorted_list\\n            rl.add(newRating)\\n            \\n        s = f_r[rating]\\n        s.discard(food)\\n        if len(s) ==0:\\n            f_r.pop(rating)\\n            rl.discard(rating)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        f_r = self.dp[cuisine]\\n        r_d = self.f_r[cuisine]\\n        #f_r = dict(sorted(f_r.items(), key=lambda item: item[0], reverse=True) )\\n        #print(f_r)\\n        #print(r_d)\\n        r = r_d[-1]\\n        return f_r[r][0]\\n        #key = next(iter(f_r))\\n        #return f_r[key][0]\\n        #return \"\"\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FoodRatings:\\n    from sortedcontainers import SortedList\\n        \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.dp = defaultdict()\\n        self.f_c = defaultdict()\\n        self.f_r = defaultdict()\\n        for food, cuisine, rating in zip(foods,cuisines,ratings):\\n            #print(food, cuisine, rating)\\n            self.f_c[food] = [cuisine,rating]\\n            \\n            if cuisine in self.dp:\\n                d = self.dp[cuisine]\\n                d1 = self.f_r[cuisine]\\n                if rating in d:\\n                    sorted_list =  d[rating]\\n                    sorted_list.add(food)\\n                else:\\n                    sorted_list = SortedList()\\n                    sorted_list.add(food)\\n                    d[rating] = sorted_list\\n                    d1.add(rating)\\n            else:\\n                from sortedcontainers import SortedList\\n                sorted_r = SortedList()\\n                sorted_list = SortedList()\\n                sorted_list.add(food)\\n                sorted_r.add(rating)\\n                d = defaultdict(SortedList)\\n                d[rating] = sorted_list\\n                self.dp[cuisine] = d\\n                self.f_r[cuisine] = sorted_r\\n                \\n                \\n        #for i in self.f_r:\\n        #    print(i,self.f_r[i])\\n        \\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, rating = self.f_c[food]\\n        rl = self.f_r[cuisine]\\n        f_r = self.dp[cuisine]\\n        self.f_c[food]= [cuisine, newRating]\\n        if newRating in f_r:\\n            sorted_list =  f_r[newRating]\\n            sorted_list.add(food)\\n        else:\\n            from sortedcontainers import SortedList\\n\\n            sorted_list = SortedList()\\n            sorted_list.add(food)\\n            f_r[newRating] = sorted_list\\n            rl.add(newRating)\\n            \\n        s = f_r[rating]\\n        s.discard(food)\\n        if len(s) ==0:\\n            f_r.pop(rating)\\n            rl.discard(rating)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        f_r = self.dp[cuisine]\\n        r_d = self.f_r[cuisine]\\n        #f_r = dict(sorted(f_r.items(), key=lambda item: item[0], reverse=True) )\\n        #print(f_r)\\n        #print(r_d)\\n        r = r_d[-1]\\n        return f_r[r][0]\\n        #key = next(iter(f_r))\\n        #return f_r[key][0]\\n        #return \"\"\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386591,
                "title": "simple-java-code-2-hashmaps-and-treeset-faster-than-98-codes-239-ms",
                "content": "```\\nclass FoodRatings {\\n    HashMap<String, TreeSet<Food>> cus = new HashMap<>();\\n    HashMap<String, Food> f = new HashMap<>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0; i<foods.length; i++){\\n            Food food = new Food(foods[i], ratings[i], cuisines[i]);\\n            f.put(foods[i], food);\\n            if(cus.containsKey(cuisines[i])){\\n                cus.get(cuisines[i]).add(food);\\n            } else {\\n                TreeSet<Food> pq = new TreeSet<>(new Comp());\\n                pq.add(food);\\n                cus.put(cuisines[i], pq);\\n            }\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food dish = f.get(food);\\n        TreeSet<Food> pq = cus.get(dish.cus);\\n        pq.remove(dish);\\n        dish.rating = newRating;\\n        pq.add(dish);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cus.get(cuisine).first().food;\\n    }\\n}\\n\\nclass Comp implements Comparator<Food>{\\n    public int compare(Food f1, Food f2){\\n        if(f1.rating == f2.rating)\\n            return f1.food.compareTo(f2.food);\\n        return Integer.compare(f2.rating, f1.rating);\\n    }\\n}\\n\\nclass Food{\\n    String food, cus;\\n    int rating;\\n    Food(String food, int rating, String cus){\\n        this.food = food;\\n        this.rating = rating;\\n        this.cus = cus;\\n    }\\n}\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    HashMap<String, TreeSet<Food>> cus = new HashMap<>();\\n    HashMap<String, Food> f = new HashMap<>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0; i<foods.length; i++){\\n            Food food = new Food(foods[i], ratings[i], cuisines[i]);\\n            f.put(foods[i], food);\\n            if(cus.containsKey(cuisines[i])){\\n                cus.get(cuisines[i]).add(food);\\n            } else {\\n                TreeSet<Food> pq = new TreeSet<>(new Comp());\\n                pq.add(food);\\n                cus.put(cuisines[i], pq);\\n            }\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food dish = f.get(food);\\n        TreeSet<Food> pq = cus.get(dish.cus);\\n        pq.remove(dish);\\n        dish.rating = newRating;\\n        pq.add(dish);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cus.get(cuisine).first().food;\\n    }\\n}\\n\\nclass Comp implements Comparator<Food>{\\n    public int compare(Food f1, Food f2){\\n        if(f1.rating == f2.rating)\\n            return f1.food.compareTo(f2.food);\\n        return Integer.compare(f2.rating, f1.rating);\\n    }\\n}\\n\\nclass Food{\\n    String food, cus;\\n    int rating;\\n    Food(String food, int rating, String cus){\\n        this.food = food;\\n        this.rating = rating;\\n        this.cus = cus;\\n    }\\n}\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385943,
                "title": "simple-java-design-using-priority-queue",
                "content": "```\\n  //cuisineId :: Food with highest rating in front\\n    Map<String,PriorityQueue<Food>> cuisinesMap = new HashMap<>();\\n    \\n    //FoodId::Food reference to enable disable food\\n    Map<String,Food> refMap = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        \\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            \\n            Food food = new Food(foods[i],cuisines[i],ratings[i],true);\\n            \\n            refMap.put(foods[i],food);\\n            cuisinesMap.putIfAbsent(cuisines[i],new PriorityQueue<>());\\n            cuisinesMap.get(cuisines[i]).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n       \\n        Food foodRef = refMap.get(food);\\n        if(foodRef!=null){\\n            foodRef.enabled = false;\\n            \\n            Food newFood = new Food(food,foodRef.cuisineId,newRating,true);\\n            cuisinesMap.get(foodRef.cuisineId).offer(newFood);\\n            refMap.put(food,newFood);\\n        }\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        Food found = null;\\n        PriorityQueue<Food> queue = cuisinesMap.get(cuisine);\\n        \\n        while(found==null && !queue.isEmpty()){\\n            \\n            Food food = queue.peek();\\n            if(food.enabled){\\n                found = food;\\n            }else{\\n                queue.poll();\\n            }\\n        }\\n        \\n        \\n        return found == null ? null : found.foodId;\\n    }\\n    \\n    private static class Food implements Comparable<Food>{\\n        \\n        public String foodId;\\n        public String cuisineId;\\n        public Integer rating;\\n        public boolean enabled;\\n        \\n        public Food(String foodId,String cuisineId,Integer rating,boolean enabled){\\n            this.foodId = foodId;\\n            this.cuisineId = cuisineId;\\n            this.rating = rating;\\n            this.enabled = enabled;\\n        }\\n        \\n        @Override\\n        public int compareTo(Food obj2){\\n            \\n            if(obj2.rating.compareTo(this.rating) == 0){\\n                return this.foodId.compareTo(obj2.foodId);\\n            }\\n            \\n            return obj2.rating.compareTo(this.rating);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n  //cuisineId :: Food with highest rating in front\\n    Map<String,PriorityQueue<Food>> cuisinesMap = new HashMap<>();\\n    \\n    //FoodId::Food reference to enable disable food\\n    Map<String,Food> refMap = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        \\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            \\n            Food food = new Food(foods[i],cuisines[i],ratings[i],true);\\n            \\n            refMap.put(foods[i],food);\\n            cuisinesMap.putIfAbsent(cuisines[i],new PriorityQueue<>());\\n            cuisinesMap.get(cuisines[i]).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n       \\n        Food foodRef = refMap.get(food);\\n        if(foodRef!=null){\\n            foodRef.enabled = false;\\n            \\n            Food newFood = new Food(food,foodRef.cuisineId,newRating,true);\\n            cuisinesMap.get(foodRef.cuisineId).offer(newFood);\\n            refMap.put(food,newFood);\\n        }\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        Food found = null;\\n        PriorityQueue<Food> queue = cuisinesMap.get(cuisine);\\n        \\n        while(found==null && !queue.isEmpty()){\\n            \\n            Food food = queue.peek();\\n            if(food.enabled){\\n                found = food;\\n            }else{\\n                queue.poll();\\n            }\\n        }\\n        \\n        \\n        return found == null ? null : found.foodId;\\n    }\\n    \\n    private static class Food implements Comparable<Food>{\\n        \\n        public String foodId;\\n        public String cuisineId;\\n        public Integer rating;\\n        public boolean enabled;\\n        \\n        public Food(String foodId,String cuisineId,Integer rating,boolean enabled){\\n            this.foodId = foodId;\\n            this.cuisineId = cuisineId;\\n            this.rating = rating;\\n            this.enabled = enabled;\\n        }\\n        \\n        @Override\\n        public int compareTo(Food obj2){\\n            \\n            if(obj2.rating.compareTo(this.rating) == 0){\\n                return this.foodId.compareTo(obj2.foodId);\\n            }\\n            \\n            return obj2.rating.compareTo(this.rating);\\n        }\\n    }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2049312,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1995740,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1794448,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1780923,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1771448,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1731468,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1723297,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1700667,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            }
        ]
    }
]