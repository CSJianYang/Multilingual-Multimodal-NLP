[
    {
        "title": "Difference Between Ones and Zeros in Row and Column",
        "question_content": "You are given a 0-indexed m x n binary matrix grid.\nA 0-indexed m x n difference matrix diff is created with the following procedure:\n\n\tLet the number of ones in the ith row be onesRowi.\n\tLet the number of ones in the jth column be onesColj.\n\tLet the number of zeros in the ith row be zerosRowi.\n\tLet the number of zeros in the jth column be zerosColj.\n\tdiff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj\n\nReturn the difference matrix diff.\n&nbsp;\nExample 1:\n\nInput: grid = [[0,1,1],[1,0,1],[0,0,1]]\nOutput: [[0,0,4],[0,0,4],[-2,-2,2]]\nExplanation:\n- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2\n- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2\n- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2\n\nExample 2:\n\nInput: grid = [[1,1,1],[1,1,1]]\nOutput: [[5,5,5],[5,5,5]]\nExplanation:\n- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 105\n\t1 <= m * n <= 105\n\tgrid[i][j] is either 0 or 1.",
        "solutions": [
            {
                "id": 2850475,
                "title": "very-easy-simple-to-understand-solution",
                "content": "<b>Up Vote if you like the solution\\n```\\n/*\\nSimply evaluate no of 1\\'s in row and col by taking the sum of the row and col.\\nThen evaluate the diff matrix.\\nTo evaluate 0\\'s count, subtract sum from the size of the row or col\\nso total value of diff[i][j] = row[i] + col[j] - (grid.size()- row[i]) - (grid[0].size() - col[j]) \\nabove equation can be simplified as : diff[i][j] = 2*row[i] + 2*col[j] - grid.size() - grid[0].size();\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<int> row(grid.size());\\n        vector<int> col(grid[0].size());\\n        for(int i = 0; i < grid.size(); ++i){\\n            for(int j = 0; j < grid[0].size(); ++j){\\n                row[i] += grid[i][j];\\n                col[j] += grid[i][j];\\n            }\\n        }\\n        vector<vector<int>> diff(grid.size(), vector<int> (grid[0].size()));\\n        for(int i = 0; i < grid.size(); ++i){\\n            for(int j = 0; j < grid[0].size(); ++j){\\n                diff[i][j] = 2*row[i] + 2*col[j] - grid.size() - grid[0].size();\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nSimply evaluate no of 1\\'s in row and col by taking the sum of the row and col.\\nThen evaluate the diff matrix.\\nTo evaluate 0\\'s count, subtract sum from the size of the row or col\\nso total value of diff[i][j] = row[i] + col[j] - (grid.size()- row[i]) - (grid[0].size() - col[j]) \\nabove equation can be simplified as : diff[i][j] = 2*row[i] + 2*col[j] - grid.size() - grid[0].size();\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<int> row(grid.size());\\n        vector<int> col(grid[0].size());\\n        for(int i = 0; i < grid.size(); ++i){\\n            for(int j = 0; j < grid[0].size(); ++j){\\n                row[i] += grid[i][j];\\n                col[j] += grid[i][j];\\n            }\\n        }\\n        vector<vector<int>> diff(grid.size(), vector<int> (grid[0].size()));\\n        for(int i = 0; i < grid.size(); ++i){\\n            for(int j = 0; j < grid[0].size(); ++j){\\n                diff[i][j] = 2*row[i] + 2*col[j] - grid.size() - grid[0].size();\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850512,
                "title": "python-o-mn-count-scores-for-columns-rows-then-add-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Comment**. All cells within the same row (column) will be updated with the same row (column) score. Thus, we can precompute scores for rows & columns separately just once, then add them when iterating over the cells.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        def count(nums) : return 2*sum(nums)-len(nums)       # [1] count score for a list of numbers\\n            \\n        rows = list(map(count, grid))                        # [2] count scores for rows\\n        cols = list(map(count, zip(*grid)))                  # [3] count scores for columns (transpose)\\n\\n        for i,j in product(range(m), range(n)):              # [4] update the input matrix with\\n            grid[i][j] = rows[i] + cols[j]                   #     sums of precomputed scores\\n                \\n        return grid\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        def count(nums) : return 2*sum(nums)-len(nums)       # [1] count score for a list of numbers\\n            \\n        rows = list(map(count, grid))                        # [2] count scores for rows\\n        cols = list(map(count, zip(*grid)))                  # [3] count scores for columns (transpose)\\n\\n        for i,j in product(range(m), range(n)):              # [4] update the input matrix with\\n            grid[i][j] = rows[i] + cols[j]                   #     sums of precomputed scores\\n                \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850670,
                "title": "java-python-3-short-codes-w-brief-explanation-and-analysis",
                "content": "Let `row[r] = onesRow[r] - zerosRow[r]` and `col[c] = onesCol[c] - zerosCol[c]`, then `ans[r][c] = row[r] - col[c]`.\\n```java\\n   public int[][] onesMinusZeros(int[][] grid) {\\n        int R = grid.length, C = grid[0].length;\\n        int[] row = new int[R], col = new int[C]; \\n        for (int r = 0; r < R; ++r) {\\n            for (int c = 0; c < C; ++c) {\\n                int offset = 2 * grid[r][c] - 1; // grid[r][c] = 1: 1, grid[r][c] = 0: -1.\\n                row[r] += offset;\\n                col[c] += offset;\\n            }\\n        }\\n        int[][] ans = new int[R][C];\\n        for (int r = 0; r < R; ++r) {\\n            for (int c = 0; c < C; ++c) {\\n                ans[r][c] = row[r] + col[c];\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        row, col = [0] * R, [0] * C\\n        for r in range(R):\\n            for c in range(C):\\n                offset = 2 * grid[r][c] - 1 # grid[r][c] = 1: 1, grid[r][c] = 0: -1.\\n                row[r] += offset\\n                col[c] += offset\\n        return [[row[r] + col[c] for c in range(C)] for r in range(R)]\\n```\\n**Analysis:**\\n\\nTime & space: `O(R * C)`, where `R = grid.length, C = grid[0].length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n   public int[][] onesMinusZeros(int[][] grid) {\\n        int R = grid.length, C = grid[0].length;\\n        int[] row = new int[R], col = new int[C]; \\n        for (int r = 0; r < R; ++r) {\\n            for (int c = 0; c < C; ++c) {\\n                int offset = 2 * grid[r][c] - 1; // grid[r][c] = 1: 1, grid[r][c] = 0: -1.\\n                row[r] += offset;\\n                col[c] += offset;\\n            }\\n        }\\n        int[][] ans = new int[R][C];\\n        for (int r = 0; r < R; ++r) {\\n            for (int c = 0; c < C; ++c) {\\n                ans[r][c] = row[r] + col[c];\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        row, col = [0] * R, [0] * C\\n        for r in range(R):\\n            for c in range(C):\\n                offset = 2 * grid[r][c] - 1 # grid[r][c] = 1: 1, grid[r][c] = 0: -1.\\n                row[r] += offset\\n                col[c] += offset\\n        return [[row[r] + col[c] for c in range(C)] for r in range(R)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2852150,
                "title": "java-very-easy-solution",
                "content": "**simply storing no of ones in a row and column in two arrays and finding the no of 0\\'s by substracting (rowlength-count of 1\\'s in that row) similarly for column**\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        //precomputing the no of ones in a row and column\\n        int rowone[]=new int[grid.length];\\n        int colone[]=new int[grid[0].length];\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1)c++;\\n            }\\n            rowone[i]=c;\\n        }\\n        for(int i=0;i<n;i++){\\n          int c=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[j][i]==1)c++;\\n            }\\n            colone[i]=c;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                grid[i][j]=rowone[i]+colone[j]-(m-rowone[i])-(n-colone[j]);\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```\\nTime complexity: O(n*m)\\nSpace complexity: O(max(n,m))\\n**please upvote if you like my solution**",
                "solutionTags": [
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        //precomputing the no of ones in a row and column\\n        int rowone[]=new int[grid.length];\\n        int colone[]=new int[grid[0].length];\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1)c++;\\n            }\\n            rowone[i]=c;\\n        }\\n        for(int i=0;i<n;i++){\\n          int c=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[j][i]==1)c++;\\n            }\\n            colone[i]=c;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                grid[i][j]=rowone[i]+colone[j]-(m-rowone[i])-(n-colone[j]);\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850761,
                "title": "c-easy-solution-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> orows(n);\\n        vector<int> ocol(m);\\n        \\n        vector<int> zrow(n);\\n        vector<int> zcol(m);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++){\\n                \\n                if(grid[i][j] == 1)\\n                {\\n                    orows[i] += 1;\\n                    ocol[j] += 1;\\n                }\\n                else\\n                {\\n                    zrow[i]+=1;\\n                    zcol[j]+=1;\\n                }\\n            }\\n        }\\n        vector<vector<int>> diff(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                diff[i][j] = orows[i] + ocol[j] - zrow[i] - zcol[j];\\n            }\\n        }\\n        return diff;\\n        \\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> orows(n);\\n        vector<int> ocol(m);\\n        \\n        vector<int> zrow(n);\\n        vector<int> zcol(m);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++){\\n                \\n                if(grid[i][j] == 1)\\n                {\\n                    orows[i] += 1;\\n                    ocol[j] += 1;\\n                }\\n                else\\n                {\\n                    zrow[i]+=1;\\n                    zcol[j]+=1;\\n                }\\n            }\\n        }\\n        vector<vector<int>> diff(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                diff[i][j] = orows[i] + ocol[j] - zrow[i] - zcol[j];\\n            }\\n        }\\n        return diff;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851439,
                "title": "rows-and-cols-counter",
                "content": "**C++**\\n```cpp\\nvector<vector<int>> onesMinusZeros(vector<vector<int>>& g) {\\n    int si = g.size(), sj = g[0].size();\\n    vector<int> r(g.size()), c(g[0].size());\\n    for (int i = 0; i < r.size(); ++i)\\n        for (int j = 0; j < c.size(); ++j) {\\n            r[i] += g[i][j];\\n            c[j] += g[i][j];\\n        }\\n    for (int i = 0; i < si; ++i)\\n        for (int j = 0; j < sj; ++j)\\n            g[i][j] = r[i] + c[j] - (si - r[i]) - (sj - c[j]);\\n    return g;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> onesMinusZeros(vector<vector<int>>& g) {\\n    int si = g.size(), sj = g[0].size();\\n    vector<int> r(g.size()), c(g[0].size());\\n    for (int i = 0; i < r.size(); ++i)\\n        for (int j = 0; j < c.size(); ++j) {\\n            r[i] += g[i][j];\\n            c[j] += g[i][j];\\n        }\\n    for (int i = 0; i < si; ++i)\\n        for (int j = 0; j < sj; ++j)\\n            g[i][j] = r[i] + c[j] - (si - r[i]) - (sj - c[j]);\\n    return g;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2850488,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def onesMinusZeros(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        row = [0] * m  #taken extra space to count 1\\'s\\n        col = [0] * n\\n        \\n        #this two loops for count 1\\'s in each row and column\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                col[j] += grid[i][j]\\n                row[i] += grid[i][j]\\n        ans = []\\n        for i in range(len(grid)):\\n            temp = []\\n            for j in range(len(grid[0])):\\n                temp.append(row[i] + col[j] - (n - row[i]) - (m - col[j]))\\n            ans.append(temp)\\n        return ans\\n```\\n**UpVote**, if it helps a little to you **:)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def onesMinusZeros(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        row = [0] * m  #taken extra space to count 1\\'s\\n        col = [0] * n\\n        \\n        #this two loops for count 1\\'s in each row and column\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                col[j] += grid[i][j]\\n                row[i] += grid[i][j]\\n        ans = []\\n        for i in range(len(grid)):\\n            temp = []\\n            for j in range(len(grid[0])):\\n                temp.append(row[i] + col[j] - (n - row[i]) - (m - col[j]))\\n            ans.append(temp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850907,
                "title": "c-row-column-sum-counter-and-rewrite-in-place",
                "content": "# Approach 1: row and column sum\\n\\nWe compute the sum of each row and column, which is equal to the number of ones and from that we can reason about the number of zeros. Note that we are rewriting the input.\\n\\n```cpp\\n    static vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) noexcept {\\n        const int rows = size(grid);\\n        const int cols = size(grid[0]);\\n\\n        vector<int> rs(rows);\\n        vector<int> cs(cols);\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c) {\\n                rs[r] += grid[r][c];\\n                cs[c] += grid[r][c];\\n            }\\n        \\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                grid[r][c] = rs[r] + cs[c] - (rows - rs[r]) - (cols - cs[c]);\\n\\n        return grid;\\n    }\\n```\\n\\nFor the second pass over the ```grid``` we can factor out some invariants and make it:\\n\\n```cpp\\n        for (int r = 0; r < rows; ++r) {\\n            const int k = 2 * rs[r] - rows - cols;\\n            for (int c = 0; c < cols; ++c)\\n                grid[r][c] = k + 2 * cs[c];\\n        }\\n```\\n\\nThis generated different code (https://godbolt.org/z/G7xoWGqj9) and is faster than the version above.\\n\\n## Bonus Variant: using the Elvis operator ?:\\n\\n```cpp\\n    static vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) noexcept {\\n        const int rows = size(grid);\\n        const int cols = size(grid[0]);\\n\\n        vector<int> rs(rows);\\n        vector<int> cs(cols);\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c) {\\n                rs[r] += grid[r][c] ?: -1;\\n                cs[c] += grid[r][c] ?: -1;\\n            }\\n        \\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                grid[r][c] = rs[r] + cs[c];\\n\\n        return grid;\\n    }\\n```\\n\\nUnfortunatly this variant seems quite a bit slower, but if you turn your head to the left you might see the King of Rock\\'n\\'Roll. :)\\n\\n**Complexity Analysis**\\nLet $$n$$ be the number of rows and $$m$$ be the number of columns then the\\n  * Time complexity: $$O(n m)$$ as we need to compute the row and column sums and the fill the grid.\\n  * Space complexity: $$O(n + m)$$ for the row and column sums.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) noexcept {\\n        const int rows = size(grid);\\n        const int cols = size(grid[0]);\\n\\n        vector<int> rs(rows);\\n        vector<int> cs(cols);\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c) {\\n                rs[r] += grid[r][c];\\n                cs[c] += grid[r][c];\\n            }\\n        \\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                grid[r][c] = rs[r] + cs[c] - (rows - rs[r]) - (cols - cs[c]);\\n\\n        return grid;\\n    }\\n```\n```grid```\n```cpp\\n        for (int r = 0; r < rows; ++r) {\\n            const int k = 2 * rs[r] - rows - cols;\\n            for (int c = 0; c < cols; ++c)\\n                grid[r][c] = k + 2 * cs[c];\\n        }\\n```\n```cpp\\n    static vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) noexcept {\\n        const int rows = size(grid);\\n        const int cols = size(grid[0]);\\n\\n        vector<int> rs(rows);\\n        vector<int> cs(cols);\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c) {\\n                rs[r] += grid[r][c] ?: -1;\\n                cs[c] += grid[r][c] ?: -1;\\n            }\\n        \\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                grid[r][c] = rs[r] + cs[c];\\n\\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2850543,
                "title": "o-n-m-c-explained",
                "content": "**The basic idea is to maintain zeroes and ones of each column and each row in a vector.**\\nLet the zrow and zcol be the vectors for storing zeroes of row and column respectively.\\nSimilary, we do it for one and the vectors are orow and ocol.\\n```\\nclass Solution {\\npublic:\\n       vector<vector<int>> onesMinusZeros(vector<vector<int>>& a) {\\n        int n=a.size(),m=a[0].size();\\n        vector<int> zrow(n),zcol(m),orow(n),ocol(m);\\n\\t  //calculating number of one and zero in a row and storing that in their respective vectors\\n        for(int i=0;i<n;i++){\\n            int o=0,z=0;\\n            for(int j=0;j<m;j++){\\n                if(a[i][j]==0)z++;\\n                else if(a[i][j]==1) o++;\\n            }\\n            zrow[i]=z;\\n            orow[i]=o;\\n        }\\n\\t   //calculating number of one and zero in a column and storing that in their respective vectors\\n         for(int i=0;i<m;i++){\\n            int o=0,z=0;\\n            for(int j=0;j<n;j++){\\n                if(a[j][i]==0)z++;\\n                else if(a[j][i]==1) o++;\\n            }\\n            zcol[i]=z;\\n            ocol[i]=o;\\n        }\\n        vector<vector<int>> ans;\\n\\t  //for calculating the ans vector we simpy have ans[i][j]= onesRowi + onesColj - zerosRowi - zerosColj\\n        for(int i=0;i<n;i++){\\n            vector<int> v;\\n            for(int j=0;j<m;j++){\\n                int c=0;\\n                c+=orow[i]+ocol[j]-zrow[i]-zcol[j];\\n                v.push_back(c);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime complexity: O(n*m)\\nSpace complexity: O(n)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n       vector<vector<int>> onesMinusZeros(vector<vector<int>>& a) {\\n        int n=a.size(),m=a[0].size();\\n        vector<int> zrow(n),zcol(m),orow(n),ocol(m);\\n\\t  //calculating number of one and zero in a row and storing that in their respective vectors\\n        for(int i=0;i<n;i++){\\n            int o=0,z=0;\\n            for(int j=0;j<m;j++){\\n                if(a[i][j]==0)z++;\\n                else if(a[i][j]==1) o++;\\n            }\\n            zrow[i]=z;\\n            orow[i]=o;\\n        }\\n\\t   //calculating number of one and zero in a column and storing that in their respective vectors\\n         for(int i=0;i<m;i++){\\n            int o=0,z=0;\\n            for(int j=0;j<n;j++){\\n                if(a[j][i]==0)z++;\\n                else if(a[j][i]==1) o++;\\n            }\\n            zcol[i]=z;\\n            ocol[i]=o;\\n        }\\n        vector<vector<int>> ans;\\n\\t  //for calculating the ans vector we simpy have ans[i][j]= onesRowi + onesColj - zerosRowi - zerosColj\\n        for(int i=0;i<n;i++){\\n            vector<int> v;\\n            for(int j=0;j<m;j++){\\n                int c=0;\\n                c+=orow[i]+ocol[j]-zrow[i]-zcol[j];\\n                v.push_back(c);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850453,
                "title": "c-use-counting-method-simple-approach",
                "content": "**Approach:** We store the number of 1s and 0s for each row and column into 4 different arrays then create diff 2d vector (because it\\'s not good practice to change the given data i.e. grid vector) then apply given formula and stores answer in diff array.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<int> row1(m), row0(m), col1(n), col0(n); \\n        \\n        //storing 0s and 1s count for each row\\n        int r0, r1;\\n        for(int i=0; i<m; i++)\\n        {\\n            r0=0, r1=0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j]==0)\\n                    r0++;\\n                else r1++;\\n                    \\n            }\\n            row1[i] = r1;\\n            row0[i] = r0;\\n        }\\n        \\n        //storing 0s and 1s count for each column\\n        int c0, c1;\\n        for(int j=0; j<n; j++)\\n        {\\n            c0=0, c1=0;\\n            for(int i=0; i<m; i++)\\n            {\\n                if(grid[i][j]==0)\\n                    c0++;\\n                else c1++;\\n                    \\n            }\\n            col1[j] = c1;\\n            col0[j] = c0;\\n        }\\n        \\n        vector<vector<int>> diff(m, vector<int> (n, 0));\\n        \\n        //apply formula\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                diff[i][j] = row1[i] + col1[j] - row0[i] - col0[j];\\n            }\\n        }\\n        \\n        return diff;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<int> row1(m), row0(m), col1(n), col0(n); \\n        \\n        //storing 0s and 1s count for each row\\n        int r0, r1;\\n        for(int i=0; i<m; i++)\\n        {\\n            r0=0, r1=0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j]==0)\\n                    r0++;\\n                else r1++;\\n                    \\n            }\\n            row1[i] = r1;\\n            row0[i] = r0;\\n        }\\n        \\n        //storing 0s and 1s count for each column\\n        int c0, c1;\\n        for(int j=0; j<n; j++)\\n        {\\n            c0=0, c1=0;\\n            for(int i=0; i<m; i++)\\n            {\\n                if(grid[i][j]==0)\\n                    c0++;\\n                else c1++;\\n                    \\n            }\\n            col1[j] = c1;\\n            col0[j] = c0;\\n        }\\n        \\n        vector<vector<int>> diff(m, vector<int> (n, 0));\\n        \\n        //apply formula\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                diff[i][j] = row1[i] + col1[j] - row0[i] - col0[j];\\n            }\\n        }\\n        \\n        return diff;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850435,
                "title": "c-easy-code-with-explanation",
                "content": "**Approach**- make 4 vectors OnesRow(OR), OnesCol(OC), ZeroesRow(ZR), ZeroesCol(ZC) to store number of 1\\'s and 0\\'s in a particular row or column to calculate these numbers fast.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        //make vector for every value\\n        vector<int> OR(n), ZR(n);           //OnesRow, ZeroRow\\n        vector<int> OC(m), ZC(m);            //OnesCol, ZeroesCol\\n            \\n        //count- for rows\\n        for(int i=0; i<n; i++){\\n            int orr=0, zrr=0;               //ones in a row & zeroes in a row\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==0) zrr++;\\n                if(grid[i][j]==1) orr++;\\n            }\\n            \\n            // cout<<orr<<\" \"<<zrr<<endl;\\n            OR[i] = orr;\\n            ZR[i] = zrr;\\n             // cout<<i<<\" \"<<occ<<\" \"<<zcc<<endl;\\n        }\\n        \\n        //count- for colm\\n        for(int i=0; i<m; i++){\\n            int occ=0, zcc=0;               //ones in a row & zeroes in a row\\n            for(int j=0; j<n; j++){\\n                if(grid[j][i]==0) zcc++;\\n                if(grid[j][i]==1) occ++;\\n            }\\n            \\n            OC[i] = occ;\\n            ZC[i] = zcc;\\n            // cout<<OR[i]<<\" \"<<ZR[i]<<endl;\\n        }\\n        \\n        //business\\n        vector<vector<int>> ans(n, vector<int>(m, -1));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans[i][j] = OR[i] + OC[j] - ZR[i] - ZC[j];\\n                // cout<<OR[i]<<\" \"<<OC[j]<<\" \"<<ZR[i]<<\" \"<<ZC[j]<<endl;\\n            }\\n        }\\n        \\n        \\n        // for(int i=0; i<n; i++){\\n        //     cout<<OR[i]<<\" \"<<ZR[i]<<endl;\\n        // }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        //make vector for every value\\n        vector<int> OR(n), ZR(n);           //OnesRow, ZeroRow\\n        vector<int> OC(m), ZC(m);            //OnesCol, ZeroesCol\\n            \\n        //count- for rows\\n        for(int i=0; i<n; i++){\\n            int orr=0, zrr=0;               //ones in a row & zeroes in a row\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==0) zrr++;\\n                if(grid[i][j]==1) orr++;\\n            }\\n            \\n            // cout<<orr<<\" \"<<zrr<<endl;\\n            OR[i] = orr;\\n            ZR[i] = zrr;\\n             // cout<<i<<\" \"<<occ<<\" \"<<zcc<<endl;\\n        }\\n        \\n        //count- for colm\\n        for(int i=0; i<m; i++){\\n            int occ=0, zcc=0;               //ones in a row & zeroes in a row\\n            for(int j=0; j<n; j++){\\n                if(grid[j][i]==0) zcc++;\\n                if(grid[j][i]==1) occ++;\\n            }\\n            \\n            OC[i] = occ;\\n            ZC[i] = zcc;\\n            // cout<<OR[i]<<\" \"<<ZR[i]<<endl;\\n        }\\n        \\n        //business\\n        vector<vector<int>> ans(n, vector<int>(m, -1));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans[i][j] = OR[i] + OC[j] - ZR[i] - ZC[j];\\n                // cout<<OR[i]<<\" \"<<OC[j]<<\" \"<<ZR[i]<<\" \"<<ZC[j]<<endl;\\n            }\\n        }\\n        \\n        \\n        // for(int i=0; i<n; i++){\\n        //     cout<<OR[i]<<\" \"<<ZR[i]<<endl;\\n        // }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2850780,
                "title": "difference-between-ones-and-zeros-in-row-and-column-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSaving the count of zeroes and ones in both row and columns and store in the list. \\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        l1=[]\\n        l2=[]\\n        for i in range(len(grid)):\\n            zero=0\\n            one=0\\n            for j in range(len(grid[i])):\\n                if(grid[i][j]==1):\\n                    one+=1\\n                else:\\n                    zero+=1\\n            l1.append([one,zero]) \\n\\n        for i in range(len(grid[0])):\\n            zero=0\\n            one=0\\n            for j in range(len(grid)):\\n                if(grid[j][i]==1):\\n                    one+=1\\n                else:\\n                    zero+=1\\n            l2.append([one,zero]) \\n        # print(l1,l2)\\n        ans=grid.copy()\\n        # print(ans)\\n        for i in range(len(ans)):\\n            for j in range(len(ans[0])):\\n                ans[i][j] = l1[i][0]+l2[j][0]-l1[i][1]-l2[j][1]\\n        return ans\\n         \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        l1=[]\\n        l2=[]\\n        for i in range(len(grid)):\\n            zero=0\\n            one=0\\n            for j in range(len(grid[i])):\\n                if(grid[i][j]==1):\\n                    one+=1\\n                else:\\n                    zero+=1\\n            l1.append([one,zero]) \\n\\n        for i in range(len(grid[0])):\\n            zero=0\\n            one=0\\n            for j in range(len(grid)):\\n                if(grid[j][i]==1):\\n                    one+=1\\n                else:\\n                    zero+=1\\n            l2.append([one,zero]) \\n        # print(l1,l2)\\n        ans=grid.copy()\\n        # print(ans)\\n        for i in range(len(ans)):\\n            for j in range(len(ans[0])):\\n                ans[i][j] = l1[i][0]+l2[j][0]-l1[i][1]-l2[j][1]\\n        return ans\\n         \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850567,
                "title": "precompute-c-java",
                "content": "Precompute all one and zeroes count of every `row` and `column` in array.\\n Use equation given & assign the answer using precompuations done in step - 1\\n# C++\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& A) {\\n        int m = A.size(), n = A[0].size();\\n        vector<int> r_one(m), c_one(n), r_zero(m), c_zero(n);\\n         \\n        for(int i = 0;i < m; i++)\\n            for(int j = 0;j < n; ++j)\\n                if(A[i][j])\\n                    r_one[i]++ , c_one[j]++;\\n                else\\n                    r_zero[i]++, c_zero[j]++;\\n        \\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                A[i][j] = r_one[i] + c_one[j] - r_zero[i] - c_zero[j];\\n        \\n        return A;\\n    }\\n\\t\\n# Java\\n    public int[][] onesMinusZeros(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        int []r_one = new int[m];\\n        int []c_one = new int[n];\\n        int []r_zero = new int[m];\\n        int []c_zero = new int[n];\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;++j)\\n                if(A[i][j] > 0){\\n                    r_one[i]++;  \\n                    c_one[j]++;\\n                }\\n                else{\\n                    r_zero[i]++; \\n                    c_zero[j]++;\\n                }\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                A[i][j] = r_one[i] + c_one[j] - r_zero[i] - c_zero[j];\\n        \\n        return A;\\n    }",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "Precompute all one and zeroes count of every `row` and `column` in array.\\n Use equation given & assign the answer using precompuations done in step - 1\\n# C++\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& A) {\\n        int m = A.size(), n = A[0].size();\\n        vector<int> r_one(m), c_one(n), r_zero(m), c_zero(n);\\n         \\n        for(int i = 0;i < m; i++)\\n            for(int j = 0;j < n; ++j)\\n                if(A[i][j])\\n                    r_one[i]++ , c_one[j]++;\\n                else\\n                    r_zero[i]++, c_zero[j]++;\\n        \\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                A[i][j] = r_one[i] + c_one[j] - r_zero[i] - c_zero[j];\\n        \\n        return A;\\n    }\\n\\t\\n# Java\\n    public int[][] onesMinusZeros(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        int []r_one = new int[m];\\n        int []c_one = new int[n];\\n        int []r_zero = new int[m];\\n        int []c_zero = new int[n];\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;++j)\\n                if(A[i][j] > 0){\\n                    r_one[i]++;  \\n                    c_one[j]++;\\n                }\\n                else{\\n                    r_zero[i]++; \\n                    c_zero[j]++;\\n                }\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                A[i][j] = r_one[i] + c_one[j] - r_zero[i] - c_zero[j];\\n        \\n        return A;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3291663,
                "title": "js-ts-typescript-beats-100-time-o-m-n-space-o-m-n-using-simplified-formula",
                "content": "# Approach\\n1. Loop through the matrix to calculate the values of onesRow and onesCol. The zerosRow and zerosCol can be calculated from these.\\n2. Change the values of each element in matrix `grid` to the difference between ones and zeros.\\n3. Instead of using the supplied formula :\\n ```diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j]```\\nwe can simplify the formula to :\\n```diff[i][j] = 2 * onesRow[i] - m + 2 * onesColj - n```\\n, because :\\n```zerosRow[i] = m - onesRow[i]```\\n4. Return the modified matrix.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$ \\n\\n- Space complexity:\\n$$O(m+n)$$\\n\\n# Code\\n```\\nfunction onesMinusZeros(grid: number[][]): number[][] {\\n    let onesRow = new Array(grid.length).fill(0);\\n    let onesCol = new Array(grid[0].length).fill(0);\\n    const m = grid[0].length;\\n    const n = grid.length;\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] != 1) continue;\\n            onesRow[i]++;\\n            onesCol[j]++;\\n        }\\n    }\\n\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            grid[i][j] = (2 * onesRow[i]) - m + (2 * onesCol[j]) - n;\\n        }\\n    }\\n    return grid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j]```\n```diff[i][j] = 2 * onesRow[i] - m + 2 * onesColj - n```\n```zerosRow[i] = m - onesRow[i]```\n```\\nfunction onesMinusZeros(grid: number[][]): number[][] {\\n    let onesRow = new Array(grid.length).fill(0);\\n    let onesCol = new Array(grid[0].length).fill(0);\\n    const m = grid[0].length;\\n    const n = grid.length;\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] != 1) continue;\\n            onesRow[i]++;\\n            onesCol[j]++;\\n        }\\n    }\\n\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            grid[i][j] = (2 * onesRow[i]) - m + (2 * onesCol[j]) - n;\\n        }\\n    }\\n    return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3289024,
                "title": "easy-10lines-solution-in-python",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def onesMinusZeros(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        rev=[[len(i)-sum(i),sum(i)] for i in zip(*grid)]\\n        lst=[]\\n        for i in grid:\\n            v=[]\\n            sm=sum(i)\\n            ln=len(i)-sm\\n            for j in range(len(i)):\\n                v.append(sm+rev[j][1]-ln-rev[j][0])\\n            lst.append(v)\\n        return lst\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def onesMinusZeros(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        rev=[[len(i)-sum(i),sum(i)] for i in zip(*grid)]\\n        lst=[]\\n        for i in grid:\\n            v=[]\\n            sm=sum(i)\\n            ln=len(i)-sm\\n            for j in range(len(i)):\\n                v.append(sm+rev[j][1]-ln-rev[j][0])\\n            lst.append(v)\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057373,
                "title": "beats-100-o-n2-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(); //rows\\n        int n=grid[0].size(); //columns\\n        vector<int> r(m,0);\\n        vector<int> c(n,0);\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    r[i]++; c[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j]=2*(r[i]+c[j])-m-n;\\n            }\\n        }\\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(); //rows\\n        int n=grid[0].size(); //columns\\n        vector<int> r(m,0);\\n        vector<int> c(n,0);\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    r[i]++; c[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j]=2*(r[i]+c[j])-m-n;\\n            }\\n        }\\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851378,
                "title": "python-3-3-lines-w-explanation-t-m-96-38",
                "content": "Here\\'s the plan:\\n\\n1. We precompute the sum of each row and each column in `rowSum` and `colSum`.\\n\\n1. We use elementary algebra to optimize the `diff[r][c]` formula to  `2*(rowSum[r] + colSum[c]) - m - n`.\\n1. We return the grid after applying the formula to each element in the grid\\n```\\n\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n\\n        rowSum, colSum = list(map(sum, grid)), list(map(sum, chain(zip(*grid))))\\n        \\n        return [[2*(rowSum[r] + colSum[c]) - m-n\\n                 for c in range(n)] for r in range(m)]\\n\\n\\n```\\n[https://leetcode.com/submissions/detail/850271783/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is *O*(*MN*), in which *M* ~`m` and *N* ~`n`.\\n\\n(Updated 6/16/2023)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n\\n        rowSum, colSum = list(map(sum, grid)), list(map(sum, chain(zip(*grid))))\\n        \\n        return [[2*(rowSum[r] + colSum[c]) - m-n\\n                 for c in range(n)] for r in range(m)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850657,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int zero=0;\\n\\t\\tint one=0;\\n\\t\\tint col[]=new int[grid[0].length];\\n\\t\\tint row[]=new int[grid.length];\\n\\t\\tint ans[][]=new int[grid.length][grid[0].length];\\n\\t\\tfor(int i=0;i<grid.length;i++) {\\n\\t\\t\\tone=0;\\n\\t\\t\\tfor(int j=0;j<grid[0].length;j++) {\\n\\t\\t\\t\\tif(grid[i][j]==1) one++;\\n\\t\\t\\t}\\n\\t\\t\\trow[i]=one;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i=0;i<grid[0].length;i++) {\\n\\t\\t\\tone=0;\\n\\t\\t\\tfor(int j=0;j<grid.length;j++) {\\n\\t\\t\\t\\tif(grid[j][i]==1) one++;\\n\\t\\t\\t}\\n\\t\\t\\tcol[i]=one;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<ans.length;i++) {\\n            one=0;\\n            zero=0;\\n\\t\\t\\tfor(int j=0;j<ans[0].length;j++) {\\n\\t\\t\\t\\tone=row[i]+col[j];\\n\\t\\t\\t\\tzero=(ans.length-row[i])+(ans[0].length-col[j]);\\n\\t\\t\\t\\tans[i][j]=one-zero;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t\\t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int zero=0;\\n\\t\\tint one=0;\\n\\t\\tint col[]=new int[grid[0].length];\\n\\t\\tint row[]=new int[grid.length];\\n\\t\\tint ans[][]=new int[grid.length][grid[0].length];\\n\\t\\tfor(int i=0;i<grid.length;i++) {\\n\\t\\t\\tone=0;\\n\\t\\t\\tfor(int j=0;j<grid[0].length;j++) {\\n\\t\\t\\t\\tif(grid[i][j]==1) one++;\\n\\t\\t\\t}\\n\\t\\t\\trow[i]=one;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i=0;i<grid[0].length;i++) {\\n\\t\\t\\tone=0;\\n\\t\\t\\tfor(int j=0;j<grid.length;j++) {\\n\\t\\t\\t\\tif(grid[j][i]==1) one++;\\n\\t\\t\\t}\\n\\t\\t\\tcol[i]=one;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<ans.length;i++) {\\n            one=0;\\n            zero=0;\\n\\t\\t\\tfor(int j=0;j<ans[0].length;j++) {\\n\\t\\t\\t\\tone=row[i]+col[j];\\n\\t\\t\\t\\tzero=(ans.length-row[i])+(ans[0].length-col[j]);\\n\\t\\t\\t\\tans[i][j]=one-zero;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t\\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850501,
                "title": "c-easy-solution-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        //for storing count of 1 and 0 in each row and column\\n        vector<int> r1(m, 0);\\n        vector<int> c1(n, 0);\\n        vector<int> r0(m, 0);\\n        vector<int> c0(n, 0);\\n        \\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0){\\n                    c0[j]++;\\n                    r0[i]++;\\n                }else{\\n                    c1[j]++;\\n                    r1[i]++;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = r1[i]+c1[j]-r0[i]-c0[j]; \\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        //for storing count of 1 and 0 in each row and column\\n        vector<int> r1(m, 0);\\n        vector<int> c1(n, 0);\\n        vector<int> r0(m, 0);\\n        vector<int> c0(n, 0);\\n        \\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0){\\n                    c0[j]++;\\n                    r0[i]++;\\n                }else{\\n                    c1[j]++;\\n                    r1[i]++;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = r1[i]+c1[j]-r0[i]-c0[j]; \\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254588,
                "title": "time-space-96-beats-time-o-m-n-space-o-m-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& v) {\\n        int i,j,m=v.size(),n=v[0].size();\\n        vector<int> r(m,0),c(n,0);\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                r[i] += v[i][j];\\n                c[j] += v[i][j];\\n            }\\n        }\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                v[i][j] = 2*r[i]-m+2*c[j]-n;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& v) {\\n        int i,j,m=v.size(),n=v[0].size();\\n        vector<int> r(m,0),c(n,0);\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                r[i] += v[i][j];\\n                c[j] += v[i][j];\\n            }\\n        }\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                v[i][j] = 2*r[i]-m+2*c[j]-n;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853664,
                "title": "precompute-row-and-column",
                "content": "# Intuition\\nCompute the score for each row and column before hand and then use the scores to compute the score for the `grid[i][j]`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIterate over the grid\\nif `grid[i][j] == 1` then `+1` respective row and column\\nelse `-1` respective row and column.\\nAfter compute score for each `grid[i][j]`\\nas `row[i] + col[j]`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n * m)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n + m)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> row(n, 0), col(m, 0);\\n        int i, j;\\n        for(i = 0; i < n; i++)\\n            for(j = 0; j < m; j++) {\\n                if(grid[i][j]) {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n                else {\\n                    row[i]--;\\n                    col[j]--;\\n                }\\n            }\\n        for(i = 0; i < n; i++)\\n            for(j = 0; j < m; j++)\\n                grid[i][j] = row[i] + col[j];\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> row(n, 0), col(m, 0);\\n        int i, j;\\n        for(i = 0; i < n; i++)\\n            for(j = 0; j < m; j++) {\\n                if(grid[i][j]) {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n                else {\\n                    row[i]--;\\n                    col[j]--;\\n                }\\n            }\\n        for(i = 0; i < n; i++)\\n            for(j = 0; j < m; j++)\\n                grid[i][j] = row[i] + col[j];\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850741,
                "title": "python-simple-python-solution-100-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 2610 ms, faster than 100.00% of Python3 online submissions for Difference Between Ones and Zeros in Row and Column.\\n# Memory Usage: 49 MB, less than 100.00% of Python3 online submissions for Difference Between Ones and Zeros in Row and Column.\\n\\n![image](https://assets.leetcode.com/users/images/086e31d9-27cf-43c1-9d1a-db7a40ae63ae_1669479905.4351444.png)\\n\\n\\tclass Solution:\\n\\t\\tdef onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n\\n\\t\\t\\tones_row = []\\n\\t\\t\\tones_col = []\\n\\n\\t\\t\\tzero_row = []\\n\\t\\t\\tzero_col = []\\n\\n\\t\\t\\tfor row in grid:\\n\\t\\t\\t\\tone = sum(row)\\n\\t\\t\\t\\tzero = len(grid[0]) - one\\n\\n\\t\\t\\t\\tones_row.append(one)\\n\\t\\t\\t\\tzero_row.append(zero)\\n\\n\\t\\t\\tfor c in range(len(grid[0])):\\n\\t\\t\\t\\tcurrent_sum = 0\\n\\t\\t\\t\\tfor r in range(len(grid)):\\n\\t\\t\\t\\t\\tcurrent_sum = current_sum + grid[r][c]\\n\\n\\t\\t\\t\\tones_col.append(current_sum)\\n\\t\\t\\t\\tzero_col.append(len(grid) - current_sum)\\n\\n\\t\\t\\tresult = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n\\t\\t\\tfor r in range(len(grid)):\\n\\t\\t\\t\\tfor c in range(len(grid[0])):\\n\\t\\t\\t\\t\\tresult[r][c] = ones_row[r] + ones_col[c] - zero_row[r] - zero_col[c]\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 2610 ms, faster than 100.00% of Python3 online submissions for Difference Between Ones and Zeros in Row and Column.\\n# Memory Usage: 49 MB, less than 100.00% of Python3 online submissions for Difference Between Ones and Zeros in Row and Column.\\n\\n![image](https://assets.leetcode.com/users/images/086e31d9-27cf-43c1-9d1a-db7a40ae63ae_1669479905.4351444.png)\\n\\n\\tclass Solution:\\n\\t\\tdef onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n\\n\\t\\t\\tones_row = []\\n\\t\\t\\tones_col = []\\n\\n\\t\\t\\tzero_row = []\\n\\t\\t\\tzero_col = []\\n\\n\\t\\t\\tfor row in grid:\\n\\t\\t\\t\\tone = sum(row)\\n\\t\\t\\t\\tzero = len(grid[0]) - one\\n\\n\\t\\t\\t\\tones_row.append(one)\\n\\t\\t\\t\\tzero_row.append(zero)\\n\\n\\t\\t\\tfor c in range(len(grid[0])):\\n\\t\\t\\t\\tcurrent_sum = 0\\n\\t\\t\\t\\tfor r in range(len(grid)):\\n\\t\\t\\t\\t\\tcurrent_sum = current_sum + grid[r][c]\\n\\n\\t\\t\\t\\tones_col.append(current_sum)\\n\\t\\t\\t\\tzero_col.append(len(grid) - current_sum)\\n\\n\\t\\t\\tresult = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n\\t\\t\\tfor r in range(len(grid)):\\n\\t\\t\\t\\tfor c in range(len(grid[0])):\\n\\t\\t\\t\\t\\tresult[r][c] = ones_row[r] + ones_col[c] - zero_row[r] - zero_col[c]\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2850551,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int a[][]=new int[grid.length][grid[0].length];\\n        int b[]=new int[grid.length];\\n        int c[]=new int[grid[0].length];\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            int s=0,p=0;\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                    p++;\\n                }\\n            }\\n            b[i]=p-s;\\n        }\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            int s=0,p=0;\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                if(grid[j][i]==0)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                    p++;\\n                }\\n            }\\n            c[i]=p-s;\\n        }\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                a[i][j]=b[i]+c[j];\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int a[][]=new int[grid.length][grid[0].length];\\n        int b[]=new int[grid.length];\\n        int c[]=new int[grid[0].length];\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            int s=0,p=0;\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                    p++;\\n                }\\n            }\\n            b[i]=p-s;\\n        }\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            int s=0,p=0;\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                if(grid[j][i]==0)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                    p++;\\n                }\\n            }\\n            c[i]=p-s;\\n        }\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                a[i][j]=b[i]+c[j];\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905249,
                "title": "c-easy-simple-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int>row(n, 0), col(m, 0);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                row[i] += grid[i][j];\\n                col[j] += grid[i][j];\\n            }\\n        }\\n        vector<vector<int>>ans(n, vector<int>(m, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                ans[i][j] = row[i] + col[j] - (m - row[i]) - (n - col[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int>row(n, 0), col(m, 0);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                row[i] += grid[i][j];\\n                col[j] += grid[i][j];\\n            }\\n        }\\n        vector<vector<int>>ans(n, vector<int>(m, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                ans[i][j] = row[i] + col[j] - (m - row[i]) - (n - col[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840406,
                "title": "python-3-save-diff-for-rows-and-cols-beats-100-1304ms",
                "content": "```python3 []\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        \\n        rows = list(map(lambda row: 2 * sum(row) - R, grid))\\n        cols = list(map(lambda col: 2 * sum(col) - C, zip(*grid)))\\n        \\n        for i, j in product(range(R), range(C)):\\n            grid[i][j] = rows[i] + cols[j]\\n\\n        return grid\\n```\\n![Screenshot 2023-07-31 at 01.22.34.png](https://assets.leetcode.com/users/images/ca825542-7c35-4c3e-96de-47c1e86a4189_1690755793.9108202.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        \\n        rows = list(map(lambda row: 2 * sum(row) - R, grid))\\n        cols = list(map(lambda col: 2 * sum(col) - C, zip(*grid)))\\n        \\n        for i, j in product(range(R), range(C)):\\n            grid[i][j] = rows[i] + cols[j]\\n\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643793,
                "title": "easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int one=0;\\n        int zero=0;\\n\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        int col[]=new int[m];\\n        int row[]=new int[n];\\n\\n        int ans[][]=new int[n][m];\\n\\n        for(int i=0;i<n;i++){\\n            one=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    one++;\\n                }\\n            }\\n            row[i]=one;\\n        }\\n        for(int i=0;i<m;i++){\\n            one=0;\\n            for(int j=0;j<n;j++){\\n                if(grid[j][i]==1){\\n                    one++;\\n                }\\n            }\\n            col[i]=one;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            one =0;\\n            zero=0;\\n\\n            for(int j=0;j<m;j++){\\n                one=row[i]+col[j];\\n                zero=(n-row[i])+(m-col[j]);\\n                ans[i][j]=one-zero;\\n            }\\n            \\n        }\\n            \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int one=0;\\n        int zero=0;\\n\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        int col[]=new int[m];\\n        int row[]=new int[n];\\n\\n        int ans[][]=new int[n][m];\\n\\n        for(int i=0;i<n;i++){\\n            one=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    one++;\\n                }\\n            }\\n            row[i]=one;\\n        }\\n        for(int i=0;i<m;i++){\\n            one=0;\\n            for(int j=0;j<n;j++){\\n                if(grid[j][i]==1){\\n                    one++;\\n                }\\n            }\\n            col[i]=one;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            one =0;\\n            zero=0;\\n\\n            for(int j=0;j<m;j++){\\n                one=row[i]+col[j];\\n                zero=(n-row[i])+(m-col[j]);\\n                ans[i][j]=one-zero;\\n            }\\n            \\n        }\\n            \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039689,
                "title": "c-easy-o-n-2",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<vector<int>> res(grid.size(),vector<int>(grid[0].size(), 0));\\n        vector<int> col(grid[0].size(), 0), row(grid.size(), 0);\\n        for (int i = 0; i < grid.size(); i++) \\n            for (int j = 0; j < grid[i].size(); j++) \\n                row[i] += grid[i][j], col[j] += grid[i][j];\\n        \\n        for (int i = 0; i < grid.size(); i++) \\n            for (int j = 0; j < grid[i].size(); j++) \\n                res[i][j] = 2 * (row[i] + col[j] ) - grid[i].size() - grid.size();\\n        return res;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<vector<int>> res(grid.size(),vector<int>(grid[0].size(), 0));\\n        vector<int> col(grid[0].size(), 0), row(grid.size(), 0);\\n        for (int i = 0; i < grid.size(); i++) \\n            for (int j = 0; j < grid[i].size(); j++) \\n                row[i] += grid[i][j], col[j] += grid[i][j];\\n        \\n        for (int i = 0; i < grid.size(); i++) \\n            for (int j = 0; j < grid[i].size(); j++) \\n                res[i][j] = 2 * (row[i] + col[j] ) - grid[i].size() - grid.size();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926647,
                "title": "beats-100-o-1-space-unique-solution-easy-to-understand",
                "content": "PLEASE UPVOTE IF U FIND IT HELPFUL!!!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int c=grid.size();\\n        int r=grid[0].size();\\n        vector<vector<int>>ans(grid.begin(),grid.end());\\n        int y=0,z=0;\\n        \\n        for(int i=0;i<c;i++){\\n                int a=0;y=0;\\n                while(y<r){\\n                  if(grid[i][y]==0)\\n                      a--;\\n                    else\\n                      a++;\\n                  y++;\\n                }\\n                for(int j=0;j<r;j++)\\n                 ans[i][j]=a; \\n            }\\n        for(int i=0;i<r;i++){\\n                int b=0;z=0;\\n                while( z<c){\\n                  if(grid[z][i]==0)\\n                      b--;\\n                    else\\n                      b++;\\n                  z++;\\n                }\\n                 for(int j=0;j<c;j++)\\n                 ans[j][i]=ans[j][i]+b; \\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int c=grid.size();\\n        int r=grid[0].size();\\n        vector<vector<int>>ans(grid.begin(),grid.end());\\n        int y=0,z=0;\\n        \\n        for(int i=0;i<c;i++){\\n                int a=0;y=0;\\n                while(y<r){\\n                  if(grid[i][y]==0)\\n                      a--;\\n                    else\\n                      a++;\\n                  y++;\\n                }\\n                for(int j=0;j<r;j++)\\n                 ans[i][j]=a; \\n            }\\n        for(int i=0;i<r;i++){\\n                int b=0;z=0;\\n                while( z<c){\\n                  if(grid[z][i]==0)\\n                      b--;\\n                    else\\n                      b++;\\n                  z++;\\n                }\\n                 for(int j=0;j<c;j++)\\n                 ans[j][i]=ans[j][i]+b; \\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876177,
                "title": "java-96-faster-o-n-solution",
                "content": "# Complexity\\n- Time complexity: O(N + N) => O(N)\\n\\n1. First I find zeros and ones in rows and columns in one run and increment relevant array\\'s value.\\n2. In the second run I calculate the result for each cell of the grid.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int[] onesInRows = new int[grid.length];\\n        int[] zerosInRows = new int[grid.length];\\n        int[] onesInCols = new int[grid[0].length];\\n        int[] zerosInCols = new int[grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    onesInRows[i]++;\\n                    onesInCols[j]++;\\n                } else {\\n                    zerosInRows[i]++;\\n                    zerosInCols[j]++;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                grid[i][j] = onesInRows[i] + onesInCols[j] - zerosInRows[i] - zerosInCols[j];\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int[] onesInRows = new int[grid.length];\\n        int[] zerosInRows = new int[grid.length];\\n        int[] onesInCols = new int[grid[0].length];\\n        int[] zerosInCols = new int[grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    onesInRows[i]++;\\n                    onesInCols[j]++;\\n                } else {\\n                    zerosInRows[i]++;\\n                    zerosInCols[j]++;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                grid[i][j] = onesInRows[i] + onesInCols[j] - zerosInRows[i] - zerosInCols[j];\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854322,
                "title": "c-easy-solution-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        unordered_map<int,int> one_row;\\n        unordered_map<int,int> one_col;\\n        unordered_map<int,int> zero_row;\\n        unordered_map<int,int> zero_col;\\n        for(int i = 0 ; i < grid.size() ;i++){\\n            for(int j =0 ; j < grid[0].size() ;j++){\\n                if(grid[i][j]==0){\\n                    zero_row[i]++;\\n                    zero_col[j]++;\\n                }\\n                else{\\n                    one_row[i]++;\\n                    one_col[j]++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(grid.size(),vector<int>(grid[0].size()));\\n        for(int i = 0 ; i < grid.size() ;i++){\\n            for(int j = 0 ; j< grid[0].size() ;j++){\\n                ans[i][j] = one_row[i] + one_col[j] - zero_row[i] - zero_col[j];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        unordered_map<int,int> one_row;\\n        unordered_map<int,int> one_col;\\n        unordered_map<int,int> zero_row;\\n        unordered_map<int,int> zero_col;\\n        for(int i = 0 ; i < grid.size() ;i++){\\n            for(int j =0 ; j < grid[0].size() ;j++){\\n                if(grid[i][j]==0){\\n                    zero_row[i]++;\\n                    zero_col[j]++;\\n                }\\n                else{\\n                    one_row[i]++;\\n                    one_col[j]++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(grid.size(),vector<int>(grid[0].size()));\\n        for(int i = 0 ; i < grid.size() ;i++){\\n            for(int j = 0 ; j< grid[0].size() ;j++){\\n                ans[i][j] = one_row[i] + one_col[j] - zero_row[i] - zero_col[j];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852917,
                "title": "java-100-faster-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n * m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n       //rowOnes stores sum of elements in every row == no of ones\\n        List<Integer> rowOnes = new ArrayList<>();\\n        //colOnes stores sum Of elements in evry coloumn == no of ones\\n        List<Integer> colOnes = new ArrayList<>();\\n        \\n        \\n       //Calculate no of ones at each row add it to rowOnes\\n        for(int i = 0;i<grid.length;i++){\\n            int sum = 0;\\n            for(int j = 0;j<grid[i].length;j++){\\n                sum+= grid[i][j];\\n                \\n            }\\n            rowOnes.add(sum);\\n            \\n        }\\n       //Calculate no of ones at each coloumn and add it to colOnes\\n        int m = 0,n=0;\\n        while(m < grid[0].length){\\n            int sum = 0;n=0;\\n            while(n < grid.length){\\n                sum+=grid[n][m];\\n                n++;\\n            }\\n            colOnes.add(sum);\\n            m++;\\n        }\\n        \\n       \\n        \\n        //---------main part---------//\\n         int k = 0;\\n        while(k < grid.length){\\n            \\n            int l = 0;\\n            while(l < grid[k].length){\\n            //length of the grid[k] minus no of ones at kth row gives no of zeros at kth row\\n                int rowZeros = grid[k].length-rowOnes.get(k);\\n            //length of the grid minus no of ones at lth coloumn gives no of zeros at lth col\\n                int colZeros = grid.length - colOnes.get(l);\\n             //Formula given in description  \\n                int val = rowOnes.get(k) + colOnes.get(l) - (rowZeros + colZeros);\\n                grid[k][l] = val;\\n                l++;\\n            }\\n            \\n            k++;\\n            \\n        }\\n        //-------main part-------//\\n       \\n        \\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n       //rowOnes stores sum of elements in every row == no of ones\\n        List<Integer> rowOnes = new ArrayList<>();\\n        //colOnes stores sum Of elements in evry coloumn == no of ones\\n        List<Integer> colOnes = new ArrayList<>();\\n        \\n        \\n       //Calculate no of ones at each row add it to rowOnes\\n        for(int i = 0;i<grid.length;i++){\\n            int sum = 0;\\n            for(int j = 0;j<grid[i].length;j++){\\n                sum+= grid[i][j];\\n                \\n            }\\n            rowOnes.add(sum);\\n            \\n        }\\n       //Calculate no of ones at each coloumn and add it to colOnes\\n        int m = 0,n=0;\\n        while(m < grid[0].length){\\n            int sum = 0;n=0;\\n            while(n < grid.length){\\n                sum+=grid[n][m];\\n                n++;\\n            }\\n            colOnes.add(sum);\\n            m++;\\n        }\\n        \\n       \\n        \\n        //---------main part---------//\\n         int k = 0;\\n        while(k < grid.length){\\n            \\n            int l = 0;\\n            while(l < grid[k].length){\\n            //length of the grid[k] minus no of ones at kth row gives no of zeros at kth row\\n                int rowZeros = grid[k].length-rowOnes.get(k);\\n            //length of the grid minus no of ones at lth coloumn gives no of zeros at lth col\\n                int colZeros = grid.length - colOnes.get(l);\\n             //Formula given in description  \\n                int val = rowOnes.get(k) + colOnes.get(l) - (rowZeros + colZeros);\\n                grid[k][l] = val;\\n                l++;\\n            }\\n            \\n            k++;\\n            \\n        }\\n        //-------main part-------//\\n       \\n        \\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851665,
                "title": "c-linq-queries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can precompute sum of ones for each row and col, then diff will be 2 * rows[i] + 2 * cols[j] - m - n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThree Linq queries \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] OnesMinusZeros(int[][] grid) {\\n        int n = grid.Length;\\n        int m = grid[0].Length;\\n\\n        int[] rows = Enumerable\\n            .Range(0, n)\\n            .Select(index => grid[index].Sum())\\n            .ToArray();\\n\\n        int[] cols = Enumerable\\n            .Range(0, m)\\n            .Select(c => Enumerable.Range(0, n).Sum(r => grid[r][c]))\\n            .ToArray();\\n \\n        return Enumerable\\n            .Range(0, n)\\n            .Select(r => Enumerable\\n                .Range(0, m)\\n                .Select(c => 2 * rows[r] + 2 * cols[c] - n - m)\\n                .ToArray())\\n            .ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] OnesMinusZeros(int[][] grid) {\\n        int n = grid.Length;\\n        int m = grid[0].Length;\\n\\n        int[] rows = Enumerable\\n            .Range(0, n)\\n            .Select(index => grid[index].Sum())\\n            .ToArray();\\n\\n        int[] cols = Enumerable\\n            .Range(0, m)\\n            .Select(c => Enumerable.Range(0, n).Sum(r => grid[r][c]))\\n            .ToArray();\\n \\n        return Enumerable\\n            .Range(0, n)\\n            .Select(r => Enumerable\\n                .Range(0, m)\\n                .Select(c => 2 * rows[r] + 2 * cols[c] - n - m)\\n                .ToArray())\\n            .ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850734,
                "title": "easy-c-solution-basic",
                "content": "Here is my C++ solution :-\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n= grid.size(); int m= grid[0].size();\\n        vector<int> onesRow,onesCol;\\n        for (int i=0; i<n; i++){\\n            int val=0;\\n            for (int j=0; j<m; j++){\\n                if (grid[i][j]==1)val++;\\n            }\\n            onesRow.push_back(val);\\n        }\\n        for (int i=0; i<m; i++){\\n            int val=0;\\n            for (int j=0; j<n; j++){\\n                if (grid[j][i])val++;\\n            }\\n            onesCol.push_back(val);\\n        }\\n        vector<vector<int>> diff(n,vector<int>(m,0));\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                diff[i][j]= 2*onesRow[i] + 2*onesCol[j] - n - m;\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n= grid.size(); int m= grid[0].size();\\n        vector<int> onesRow,onesCol;\\n        for (int i=0; i<n; i++){\\n            int val=0;\\n            for (int j=0; j<m; j++){\\n                if (grid[i][j]==1)val++;\\n            }\\n            onesRow.push_back(val);\\n        }\\n        for (int i=0; i<m; i++){\\n            int val=0;\\n            for (int j=0; j<n; j++){\\n                if (grid[j][i])val++;\\n            }\\n            onesCol.push_back(val);\\n        }\\n        vector<vector<int>> diff(n,vector<int>(m,0));\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                diff[i][j]= 2*onesRow[i] + 2*onesCol[j] - n - m;\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850709,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n\\t\\t\\tvector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n\\t\\t\\tunordered_map<int, int>m1, m2;\\n\\t\\t\\tfor(int i=0; i<grid.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<grid[0].size(); j++){\\n\\t\\t\\t\\t\\tif(grid[i][j]==1){\\n\\t\\t\\t\\t\\t\\tm1[i]++;\\n\\t\\t\\t\\t\\t\\tm2[j]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i<grid.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<grid[0].size(); j++){\\n\\t\\t\\t\\t\\tv[i][j]=m1[i]+m2[j]-(grid.size()-m1[i]+grid[0].size()-m2[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n\\t\\t\\tvector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n\\t\\t\\tunordered_map<int, int>m1, m2;\\n\\t\\t\\tfor(int i=0; i<grid.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<grid[0].size(); j++){\\n\\t\\t\\t\\t\\tif(grid[i][j]==1){\\n\\t\\t\\t\\t\\t\\tm1[i]++;\\n\\t\\t\\t\\t\\t\\tm2[j]++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2850633,
                "title": "c-simple-4-arrays",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>onerow; vector<int>zerorow;\\n        vector<int>onecol; vector<int>zerocol;\\n        for(int i=0;i<n;i++)\\n        {\\n            int zero=0;\\n            int one=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0) zero++;\\n                else\\n                    one++;\\n            }\\n            onerow.push_back(one);\\n            zerorow.push_back(zero);\\n        }\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            int zero=0; int one=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(grid[i][j]==0) zero++;\\n                else\\n                    one++;\\n            }\\n            onecol.push_back(one);\\n            zerocol.push_back(zero);\\n        }\\n        //diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans[i][j]=onerow[i]+onecol[j]-zerorow[i]-zerocol[j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>onerow; vector<int>zerorow;\\n        vector<int>onecol; vector<int>zerocol;\\n        for(int i=0;i<n;i++)\\n        {\\n            int zero=0;\\n            int one=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0) zero++;\\n                else\\n                    one++;\\n            }\\n            onerow.push_back(one);\\n            zerorow.push_back(zero);\\n        }\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            int zero=0; int one=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(grid[i][j]==0) zero++;\\n                else\\n                    one++;\\n            }\\n            onecol.push_back(one);\\n            zerocol.push_back(zero);\\n        }\\n        //diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans[i][j]=onerow[i]+onecol[j]-zerorow[i]-zerocol[j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850581,
                "title": "c-java-python3-simulation",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/679b6a406693e67fb9637bbd1c8449f2372e76c5) for solutions of biweekly 92. \\n\\n**Intuition**\\nOne can directly solve this problem by simulating the process. \\n\\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(); \\n        vector<int> row(m), col(n); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (grid[i][j]) {\\n                    ++row[i]; \\n                    ++col[j]; \\n                }\\n        vector<vector<int>> ans(m, vector<int>(n)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                ans[i][j] = 2*row[i] + 2*col[j] - m - n;\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length; \\n        int[] row = new int[m], col = new int[n]; \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (grid[i][j] == 1) {\\n                    ++row[i]; \\n                    ++col[j]; \\n                }\\n        int[][] ans = new int[m][n]; \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                ans[i][j] = 2*row[i] + 2*col[j] - m - n; \\n        return ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        row = [0]*m\\n        col = [0]*n\\n        for i in range(m): \\n            for j in range(n): \\n                if grid[i][j]: \\n                    row[i] += 1\\n                    col[j] += 1\\n        ans = [[0]*n for _ in range(m)]\\n        for i in range(m): \\n            for j in range(n): \\n                ans[i][j] = 2*row[i] + 2*col[j] - m - n\\n        return ans \\n```\\n\\n**Complexity**\\nTime O(MN)\\nSpace O(MN)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(); \\n        vector<int> row(m), col(n); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (grid[i][j]) {\\n                    ++row[i]; \\n                    ++col[j]; \\n                }\\n        vector<vector<int>> ans(m, vector<int>(n)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                ans[i][j] = 2*row[i] + 2*col[j] - m - n;\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length; \\n        int[] row = new int[m], col = new int[n]; \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (grid[i][j] == 1) {\\n                    ++row[i]; \\n                    ++col[j]; \\n                }\\n        int[][] ans = new int[m][n]; \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                ans[i][j] = 2*row[i] + 2*col[j] - m - n; \\n        return ans; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        row = [0]*m\\n        col = [0]*n\\n        for i in range(m): \\n            for j in range(n): \\n                if grid[i][j]: \\n                    row[i] += 1\\n                    col[j] += 1\\n        ans = [[0]*n for _ in range(m)]\\n        for i in range(m): \\n            for j in range(n): \\n                ans[i][j] = 2*row[i] + 2*col[j] - m - n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850554,
                "title": "c-easy-intuitive",
                "content": "\\n```\\n class Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        \\n        unordered_map<int,int>rowOnes,colOnes;\\n        int m=grid.size(),n=grid[0].size();\\n        \\n        for(int i=0;i<grid.size();i++){\\n           \\n            int countOnesRow=0;\\n            for(int j=0;j<grid[0].size();j++){\\n                countOnesRow+=grid[i][j];\\n            }\\n            rowOnes[i]=countOnesRow;\\n            \\n        }\\n        \\n         for(int j=0;j<grid[0].size();j++){\\n           \\n            int countOnesCol=0;\\n            for(int i=0;i<grid.size();i++){\\n                countOnesCol+=grid[i][j];\\n            }\\n            colOnes[j]=countOnesCol;\\n            \\n        }\\n        \\n        for(int i=0;i<grid.size();i++){\\n            \\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]= rowOnes[i]+colOnes[j] - (m-rowOnes[i])- (n-colOnes[j]);\\n            }\\n            \\n        }\\n        return grid;\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        \\n        unordered_map<int,int>rowOnes,colOnes;\\n        int m=grid.size(),n=grid[0].size();\\n        \\n        for(int i=0;i<grid.size();i++){\\n           \\n            int countOnesRow=0;\\n            for(int j=0;j<grid[0].size();j++){\\n                countOnesRow+=grid[i][j];\\n            }\\n            rowOnes[i]=countOnesRow;\\n            \\n        }\\n        \\n         for(int j=0;j<grid[0].size();j++){\\n           \\n            int countOnesCol=0;\\n            for(int i=0;i<grid.size();i++){\\n                countOnesCol+=grid[i][j];\\n            }\\n            colOnes[j]=countOnesCol;\\n            \\n        }\\n        \\n        for(int i=0;i<grid.size();i++){\\n            \\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]= rowOnes[i]+colOnes[j] - (m-rowOnes[i])- (n-colOnes[j]);\\n            }\\n            \\n        }\\n        return grid;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850542,
                "title": "python-easy-to-read-o-rows-cols-two-arrays-count-zeroes-and-ones",
                "content": "\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        rows,cols = len(grid), len(grid[0])\\n        rowZeroesCnt , colZeroesCnt = [0]*rows, [0]*cols\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 0 :\\n                    rowZeroesCnt[r] +=1\\n                    colZeroesCnt[c] +=1\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                currZeroes = rowZeroesCnt[r] + colZeroesCnt[c]\\n                currOnes = (rows-rowZeroesCnt[r]) + (cols-colZeroesCnt[c])\\n                grid[r][c] = currOnes - currZeroes\\n        return grid\\n",
                "solutionTags": [],
                "code": "\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        rows,cols = len(grid), len(grid[0])\\n        rowZeroesCnt , colZeroesCnt = [0]*rows, [0]*cols\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 0 :\\n                    rowZeroesCnt[r] +=1\\n                    colZeroesCnt[c] +=1\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                currZeroes = rowZeroesCnt[r] + colZeroesCnt[c]\\n                currOnes = (rows-rowZeroesCnt[r]) + (cols-colZeroesCnt[c])\\n                grid[r][c] = currOnes - currZeroes\\n        return grid\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2850520,
                "title": "concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> onesRowi(n), zerosRowi(n), onesColj(m), zerosColj(m); \\n        \\n        for(int i=0; i<n; i++) {\\n            int ze = 0, on = 0;\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]) on++;\\n                else ze++;\\n            }\\n            onesRowi[i] = on;\\n            zerosRowi[i] = ze;\\n        }\\n        \\n        for(int i=0; i<m; i++) {\\n            int ze = 0, on = 0;\\n            for(int j=0; j<n; j++) {\\n                if(grid[j][i]) on++;\\n                else ze++;\\n            }\\n            onesColj[i] = on;\\n            zerosColj[i] = ze;\\n        }\\n        vector<vector<int>> ans(n, vector<int>(m));\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                ans[i][j] = onesRowi[i] + onesColj[j] - zerosRowi[i] - zerosColj[j];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> onesRowi(n), zerosRowi(n), onesColj(m), zerosColj(m); \\n        \\n        for(int i=0; i<n; i++) {\\n            int ze = 0, on = 0;\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]) on++;\\n                else ze++;\\n            }\\n            onesRowi[i] = on;\\n            zerosRowi[i] = ze;\\n        }\\n        \\n        for(int i=0; i<m; i++) {\\n            int ze = 0, on = 0;\\n            for(int j=0; j<n; j++) {\\n                if(grid[j][i]) on++;\\n                else ze++;\\n            }\\n            onesColj[i] = on;\\n            zerosColj[i] = ze;\\n        }\\n        vector<vector<int>> ans(n, vector<int>(m));\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                ans[i][j] = onesRowi[i] + onesColj[j] - zerosRowi[i] - zerosColj[j];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850519,
                "title": "2482-difference-between-ones-and-zeros-in-row-and-column-java",
                "content": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int ans[][]=new int[grid.length][grid[0].length];\\n        int b[]=new int[grid.length];\\n        int c[]=new int[grid[0].length];\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            int s=0,p=0;\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                    p++;\\n                }\\n            }\\n            b[i]=p-s;\\n        }\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            int s=0,p=0;\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                if(grid[j][i]==0)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                    p++;\\n                }\\n            }\\n            c[i]=p-s;\\n        }\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                ans[i][j]=b[i]+c[j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int ans[][]=new int[grid.length][grid[0].length];\\n        int b[]=new int[grid.length];\\n        int c[]=new int[grid[0].length];\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            int s=0,p=0;\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                    p++;\\n                }\\n            }\\n            b[i]=p-s;\\n        }\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            int s=0,p=0;\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                if(grid[j][i]==0)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                    p++;\\n                }\\n            }\\n            c[i]=p-s;\\n        }\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                ans[i][j]=b[i]+c[j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019231,
                "title": "java-beats-99-beginner-friendly-detailed-explanation",
                "content": "# Intuition\\nAfter reading the problem carefully, I understood that we are supposed to store the number of ones and zeros for both rows and columns respectvely.\\nAfter calculating the above four values for each element in matrix we simply require to calculate the difference value for them.\\n\\n\\n# Approach\\nFirstly, I have stored the number of rows and columns in two integer variable to avoid using length function again and again.\\nI have created a two dimensional array rows[2][m] whose size is equal to the number of rows in grid matrix.\\nThe rows[0][i] stores the number of 0\\'s in i\\'th row and similary rows[1][i] stores the number of 1\\'s in i\\'th row.\\nWith the very same logic I have also created two dimensional array colu[2][n] to store zeros and ones in i\\'th column.\\n\\nAs there are m rows in rows matrix outer loop runs for m times to store zeros and ones in respective element.\\nIn m rows each row has n number of elements and hence inner loop n times to iterate through them.\\nFor each row, I have added all the elements present in i\\'th row which is equal to the number of ones in that row.\\nTo get the number of zeros in i\\'th row, I subracted the size of i\\'th row by the number of ones in i\\'th row.\\nWith the very same logic I have also calculated and stored the number of zeros and ones in i\\'th column.\\n\\nThis is my very first solution and I hope you understood this approach if you liked this please upvote it.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m+n)$$\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int[][] onesMinusZeros(int[][] grid)\\n    {\\n        int m=grid.length,n=grid[0].length;\\n        int[][] rows=new int[2][m];\\n        int[][] colu=new int[2][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            int sumi=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                sumi+=grid[i][j];\\n            }\\n            rows[1][i]=sumi;\\n            rows[0][i]=n-sumi;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int sumi=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                sumi+=grid[j][i];\\n            }\\n            colu[1][i]=sumi;\\n            colu[0][i]=m-sumi;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                grid[i][j]=rows[1][i]+colu[1][j]-rows[0][i]-colu[0][j];\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int[][] onesMinusZeros(int[][] grid)\\n    {\\n        int m=grid.length,n=grid[0].length;\\n        int[][] rows=new int[2][m];\\n        int[][] colu=new int[2][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            int sumi=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                sumi+=grid[i][j];\\n            }\\n            rows[1][i]=sumi;\\n            rows[0][i]=n-sumi;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int sumi=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                sumi+=grid[j][i];\\n            }\\n            colu[1][i]=sumi;\\n            colu[0][i]=m-sumi;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                grid[i][j]=rows[1][i]+colu[1][j]-rows[0][i]-colu[0][j];\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921213,
                "title": "difference-between-ones-and-zeros-in-row-and-column",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size() , m = grid[0].size();\\n\\n        vector<int>row_one;\\n        vector<int>col_one;\\n        \\n        for (int i=0;i<n;i++)\\n        {\\n            int count_one = 0;\\n            for (int j=0;j<m;j++)\\n            {\\n                if (grid[i][j] == 1)   count_one += 1;\\n            }\\n            row_one.push_back(count_one);\\n        }\\n        \\n        for (int i=0;i<m;i++)\\n        {\\n            int count_one = 0;\\n            for (int j=0;j<n;j++)\\n            {\\n                if (grid[j][i] == 1)   count_one += 1;\\n            }\\n            col_one.push_back(count_one);\\n        }\\n        \\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {   \\n                int cal = row_one[i] + col_one[j] - (n - row_one[i]) - (m - col_one[j]);\\n                ans[i][j] = cal;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size() , m = grid[0].size();\\n\\n        vector<int>row_one;\\n        vector<int>col_one;\\n        \\n        for (int i=0;i<n;i++)\\n        {\\n            int count_one = 0;\\n            for (int j=0;j<m;j++)\\n            {\\n                if (grid[i][j] == 1)   count_one += 1;\\n            }\\n            row_one.push_back(count_one);\\n        }\\n        \\n        for (int i=0;i<m;i++)\\n        {\\n            int count_one = 0;\\n            for (int j=0;j<n;j++)\\n            {\\n                if (grid[j][i] == 1)   count_one += 1;\\n            }\\n            col_one.push_back(count_one);\\n        }\\n        \\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {   \\n                int cal = row_one[i] + col_one[j] - (n - row_one[i]) - (m - col_one[j]);\\n                ans[i][j] = cal;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871206,
                "title": "simple-java-solution",
                "content": "\\n# Approach\\nUsing the approach of maintaining 4 temporary arrays, one for number of 1\\'s in each row, one for number of 0\\'s in each row, one for number of 1\\'s in each column and one for number of 0\\'s in each column and finall computing the result in the matrix.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2m+2n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int rOne[] = new int[m];\\n        int rZero[] = new int[m];\\n        int cOne[] = new int[n];\\n        int cZero[] = new int[n];\\n        for(int i=0; i<m; i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==0) {\\n                    rZero[i]++;\\n                    cZero[j]++;\\n                } else {\\n                    rOne[i]++;\\n                    cOne[j]++;\\n                }\\n            }\\n        }\\n        for(int i=0; i<m;i++) {\\n            for(int j=0; j<n; j++) {\\n                grid[i][j] = rOne[i] + cOne[j] - rZero[i] - cZero[j];\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int rOne[] = new int[m];\\n        int rZero[] = new int[m];\\n        int cOne[] = new int[n];\\n        int cZero[] = new int[n];\\n        for(int i=0; i<m; i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==0) {\\n                    rZero[i]++;\\n                    cZero[j]++;\\n                } else {\\n                    rOne[i]++;\\n                    cOne[j]++;\\n                }\\n            }\\n        }\\n        for(int i=0; i<m;i++) {\\n            for(int j=0; j<n; j++) {\\n                grid[i][j] = rOne[i] + cOne[j] - rZero[i] - cZero[j];\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854501,
                "title": "easy-and-beginner-solution",
                "content": "# Intuition\\nbasic rules that used in matrix\\n\\n# Approach\\n1. Create ones(col,row) and zero(col,row)\\n2. calculate the number of ones and zero in every row, seprate \"for loop\" for only row\\n3. similary as row calulate for column ,and it should be an seprate for loop\\n4. Then as per question formula for \"diff matrix\",\\ndiff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j]\\n\\n5. and finally print the  diff matrix\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& v) {\\n        \\n        int  n=v.size() , m=v[0].size();\\n        vector<int> oneR(n) ,oneC(m) ,zeroR(n) ,zeroC(m);\\n    \\n        vector<vector<int>> dif;\\n\\n        //no of 1\\'s and 0\\'s in row\\n        for(int i=0;i<n;i++)\\n        {\\n            int a=0,b=0;    //a for ones ,b for zeros\\n            for(int j =0;j<m;j++)\\n            {\\n                if(v[i][j] == 1)\\n                    a++;\\n                else if(v[i][j] == 0)\\n                    b++;                \\n            }\\n            oneR[i]=a;\\n            zeroR[i]=b;\\n        }\\n\\n        //no. of 1\\'s and 0\\'s in col\\n        for(int i=0;i<m;i++)\\n        {\\n            int a=0,b=0;    //a for ones ,b for zeros\\n            for(int j =0;j<n;j++)\\n            {\\n                if(v[j][i] == 1)\\n                    a++;\\n                else if(v[j][i] == 0)\\n                    b++;                \\n            }\\n            oneC[i]=a;\\n            zeroC[i]=b;\\n        }\\n\\n        //printing the dif matrix according to the question\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> x;\\n            for(int j=0;j<m;j++)\\n            {\\n                int sum = 0;\\n                sum+= oneR[i]+oneC[j] - zeroR[i]-zeroC[j];\\n                x.push_back(sum);\\n            }\\n            dif.push_back(x);\\n        }\\n\\n        return dif;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& v) {\\n        \\n        int  n=v.size() , m=v[0].size();\\n        vector<int> oneR(n) ,oneC(m) ,zeroR(n) ,zeroC(m);\\n    \\n        vector<vector<int>> dif;\\n\\n        //no of 1\\'s and 0\\'s in row\\n        for(int i=0;i<n;i++)\\n        {\\n            int a=0,b=0;    //a for ones ,b for zeros\\n            for(int j =0;j<m;j++)\\n            {\\n                if(v[i][j] == 1)\\n                    a++;\\n                else if(v[i][j] == 0)\\n                    b++;                \\n            }\\n            oneR[i]=a;\\n            zeroR[i]=b;\\n        }\\n\\n        //no. of 1\\'s and 0\\'s in col\\n        for(int i=0;i<m;i++)\\n        {\\n            int a=0,b=0;    //a for ones ,b for zeros\\n            for(int j =0;j<n;j++)\\n            {\\n                if(v[j][i] == 1)\\n                    a++;\\n                else if(v[j][i] == 0)\\n                    b++;                \\n            }\\n            oneC[i]=a;\\n            zeroC[i]=b;\\n        }\\n\\n        //printing the dif matrix according to the question\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> x;\\n            for(int j=0;j<m;j++)\\n            {\\n                int sum = 0;\\n                sum+= oneR[i]+oneC[j] - zeroR[i]-zeroC[j];\\n                x.push_back(sum);\\n            }\\n            dif.push_back(x);\\n        }\\n\\n        return dif;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716061,
                "title": "solution",
                "content": "# Code\\n```\\nfunction onesMinusZeros(grid: number[][]): number[][] {\\n    const m: number = grid.length;\\n    const n: number = grid[0].length;\\n    const onesRow: number[] = new Array(m).fill(0);\\n    const onesCol: number[] = new Array(n).fill(0);\\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n        onesRow[i] += grid[i][j];\\n        onesCol[j] += grid[i][j];\\n        }\\n    }\\n\\n    const diff: number[][] = Array.from({ length: m }, () => Array(n).fill(0));\\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n        const zerosRowi: number = n - onesRow[i];\\n        const zerosColj: number = m - onesCol[j];\\n        diff[i][j] = onesRow[i] + onesCol[j] - zerosRowi - zerosColj;\\n        }\\n    }\\n\\n    return diff;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction onesMinusZeros(grid: number[][]): number[][] {\\n    const m: number = grid.length;\\n    const n: number = grid[0].length;\\n    const onesRow: number[] = new Array(m).fill(0);\\n    const onesCol: number[] = new Array(n).fill(0);\\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n        onesRow[i] += grid[i][j];\\n        onesCol[j] += grid[i][j];\\n        }\\n    }\\n\\n    const diff: number[][] = Array.from({ length: m }, () => Array(n).fill(0));\\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n        const zerosRowi: number = n - onesRow[i];\\n        const zerosColj: number = m - onesCol[j];\\n        diff[i][j] = onesRow[i] + onesCol[j] - zerosRowi - zerosColj;\\n        }\\n    }\\n\\n    return diff;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3660920,
                "title": "very-simple-c-beats-98",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is very simple, Just count the occurrence of 1 and 0 in each and every column after that, follow the problem statement.\\n\\n**To Calculate the occurrence of 1 and 0 in any row and in cols just follow the below Points-**\\n\\n**Number of 1 in Row r: Sum of all the element in row(r).\\nNumber of 0 in Row r: n-sum of the row(r)\\nNumber of 1 in Col c: Sum of all the element in Col(c).\\nNumber of 0 in Col c: m-sum of the Col(c)**\\n\\n\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N+M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& mat) {\\n        n = mat.size();\\n        m = mat[0].size();\\n        vector<int> rows(n,0),cols(m,0);\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n             rows[i]+=mat[i][j];  \\n             cols[j]+=mat[i][j]; \\n            }\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                int nr1 = rows[i],nc1 = cols[j];\\n                int nr0 = n-nr1,nc0 = m-nc1;\\n                mat[i][j] = nr1+nc1-nr0-nc0;\\n            }\\n        }\\n        return mat;    \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/831f7f33-79d3-4155-ae8c-efa7d116e178_1687254260.4085693.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& mat) {\\n        n = mat.size();\\n        m = mat[0].size();\\n        vector<int> rows(n,0),cols(m,0);\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n             rows[i]+=mat[i][j];  \\n             cols[j]+=mat[i][j]; \\n            }\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                int nr1 = rows[i],nc1 = cols[j];\\n                int nr0 = n-nr1,nc0 = m-nc1;\\n                mat[i][j] = nr1+nc1-nr0-nc0;\\n            }\\n        }\\n        return mat;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545461,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int> row(m,0);\\n        vector<int> col(n,0);\\n\\n\\n        for(int i=0;i<m;i++){\\n            int k = 0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j] == 0){\\n                    k++;\\n                }\\n            }\\n            row[i] = k;\\n        }\\n        for(int i=0;i<n;i++){\\n            int k = 0;\\n            for(int j=0;j<m;j++){\\n                if(mat[j][i] == 0){\\n                    k++;\\n                }\\n            }\\n            col[i] = k;\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int zeroRow = row[i];\\n                int onesRow = n - row[i];\\n                int zeroCol = col[j];\\n                int onesCol = m - col[j];\\n                // cout << onesRow  << \" \" <<  onesCol   << \" \" <<zeroRow   << \" \" <<zeroCol  << \" \" << endl;\\n                int ans = onesRow + onesCol - zeroRow - zeroCol;\\n                mat[i][j] = ans;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int> row(m,0);\\n        vector<int> col(n,0);\\n\\n\\n        for(int i=0;i<m;i++){\\n            int k = 0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j] == 0){\\n                    k++;\\n                }\\n            }\\n            row[i] = k;\\n        }\\n        for(int i=0;i<n;i++){\\n            int k = 0;\\n            for(int j=0;j<m;j++){\\n                if(mat[j][i] == 0){\\n                    k++;\\n                }\\n            }\\n            col[i] = k;\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int zeroRow = row[i];\\n                int onesRow = n - row[i];\\n                int zeroCol = col[j];\\n                int onesCol = m - col[j];\\n                // cout << onesRow  << \" \" <<  onesCol   << \" \" <<zeroRow   << \" \" <<zeroCol  << \" \" << endl;\\n                int ans = onesRow + onesCol - zeroRow - zeroCol;\\n                mat[i][j] = ans;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3518223,
                "title": "java-6-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        List<Integer> onesRows = Arrays\\n                .stream(grid)\\n                .map(arr -> Arrays.stream(arr).sum())\\n                .toList();\\n        List<Integer> onesCols = IntStream\\n                .range(0, n)\\n                .map(j -> Arrays.stream(grid).mapToInt(ints -> ints[j]).sum())\\n                .boxed()\\n                .toList();\\n        int[][] diff = new int[m][n];\\n        IntStream.range(0, m)\\n                .forEach(i -> IntStream.range(0, n).forEach(j -> {\\n                    diff[i][j] = onesRows.get(i) + onesCols.get(j) - (n - onesRows.get(i)) - (m - onesCols.get(j));\\n                }));\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        List<Integer> onesRows = Arrays\\n                .stream(grid)\\n                .map(arr -> Arrays.stream(arr).sum())\\n                .toList();\\n        List<Integer> onesCols = IntStream\\n                .range(0, n)\\n                .map(j -> Arrays.stream(grid).mapToInt(ints -> ints[j]).sum())\\n                .boxed()\\n                .toList();\\n        int[][] diff = new int[m][n];\\n        IntStream.range(0, m)\\n                .forEach(i -> IntStream.range(0, n).forEach(j -> {\\n                    diff[i][j] = onesRows.get(i) + onesCols.get(j) - (n - onesRows.get(i)) - (m - onesCols.get(j));\\n                }));\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461554,
                "title": "difference-between-ones-and-zeros-in-row-and-column-easiest-with-c",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int r=grid.size(), c=grid[0].size();\\n        vector<int>rOnes(r,0), cOnes(c,0);\\n        for(int i=0; i<r; i++)\\n            for(int j=0; j<c; j++)\\n                if(grid[i][j] == 1)\\n                    rOnes[i]++, cOnes[j]++;\\n\\n        for(int i=0; i<r; i++)\\n            for(int j=0; j<c; j++)\\n                grid[i][j] = 2*(rOnes[i] + cOnes[j]) - r - c;\\n        \\n        return grid;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int r=grid.size(), c=grid[0].size();\\n        vector<int>rOnes(r,0), cOnes(c,0);\\n        for(int i=0; i<r; i++)\\n            for(int j=0; j<c; j++)\\n                if(grid[i][j] == 1)\\n                    rOnes[i]++, cOnes[j]++;\\n\\n        for(int i=0; i<r; i++)\\n            for(int j=0; j<c; j++)\\n                grid[i][j] = 2*(rOnes[i] + cOnes[j]) - r - c;\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3443019,
                "title": "difference-between-ones-and-zeros-in-row-and-column-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int i, j, k, onerow, onecol, zerorow, zerocol, ans;\\n        vector<vector<int>> diff;\\n        vector<int> temp;\\n        vector<int> rows;\\n        vector<int> cols;\\n\\n        for(i=0 ; i<grid.size() ; i++)\\n        {\\n            onerow = count(grid[i].begin(), grid[i].end(), 1);\\n            rows.push_back(onerow);\\n        }\\n        for(i=0 ; i<grid[0].size() ; i++)\\n        {\\n            onecol=0;\\n            for(j=0 ; j<grid.size() ; j++)\\n            {\\n                if(grid[j][i]==1)\\n                {\\n                    onecol++;\\n                }\\n            }\\n            cols.push_back(onecol);\\n        }\\n\\n\\n        for(i=0 ; i<grid.size() ; i++)\\n        {\\n            for(j=0 ; j<grid[i].size() ; j++)\\n            {\\n                \\n                ans = rows[i]+cols[j] - (grid[i].size()-rows[i]) - (grid.size()-cols[j]);\\n                temp.push_back(ans);\\n            }\\n            diff.push_back(temp);\\n            temp.clear();\\n        }\\n        return diff;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/76cc5af5-d448-4d65-92a7-5c30c60b8f73_1682612955.1816487.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int i, j, k, onerow, onecol, zerorow, zerocol, ans;\\n        vector<vector<int>> diff;\\n        vector<int> temp;\\n        vector<int> rows;\\n        vector<int> cols;\\n\\n        for(i=0 ; i<grid.size() ; i++)\\n        {\\n            onerow = count(grid[i].begin(), grid[i].end(), 1);\\n            rows.push_back(onerow);\\n        }\\n        for(i=0 ; i<grid[0].size() ; i++)\\n        {\\n            onecol=0;\\n            for(j=0 ; j<grid.size() ; j++)\\n            {\\n                if(grid[j][i]==1)\\n                {\\n                    onecol++;\\n                }\\n            }\\n            cols.push_back(onecol);\\n        }\\n\\n\\n        for(i=0 ; i<grid.size() ; i++)\\n        {\\n            for(j=0 ; j<grid[i].size() ; j++)\\n            {\\n                \\n                ans = rows[i]+cols[j] - (grid[i].size()-rows[i]) - (grid.size()-cols[j]);\\n                temp.push_back(ans);\\n            }\\n            diff.push_back(temp);\\n            temp.clear();\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376191,
                "title": "ones-and-zeros-o-1-space-javascript-memory-95-45-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\nvar onesMinusZeros = function (grid) {\\n  for (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n    for (\\n      let columnIndex = 0;\\n      columnIndex < grid[rowIndex].length;\\n      columnIndex++\\n    ) {\\n      if (grid[rowIndex][columnIndex]) {\\n        grid[rowIndex][columnIndex] = {\\n          rowSum: {\\n            0: 0,\\n            1: 1,\\n          },\\n          columnSum: {\\n            0: 0,\\n            1: 1,\\n          },\\n        }\\n      } else {\\n        grid[rowIndex][columnIndex] = {\\n          rowSum: {\\n            0: 1,\\n            1: 0,\\n          },\\n          columnSum: {\\n            0: 1,\\n            1: 0,\\n          },\\n        }\\n      }\\n    }\\n  }\\n\\n  for (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n    for (\\n      let columnIndex = 0;\\n      columnIndex < grid[rowIndex].length;\\n      columnIndex++\\n    ) {\\n      if (grid[rowIndex - 1] && grid[rowIndex - 1][columnIndex]) {\\n        grid[rowIndex][columnIndex].rowSum[\\'0\\'] +=\\n          grid[rowIndex - 1][columnIndex].rowSum[\\'0\\']\\n        grid[rowIndex][columnIndex].rowSum[\\'1\\'] +=\\n          grid[rowIndex - 1][columnIndex].rowSum[\\'1\\']\\n      }\\n      if (grid[rowIndex][columnIndex - 1]) {\\n        grid[rowIndex][columnIndex].columnSum[\\'0\\'] +=\\n          grid[rowIndex][columnIndex - 1].columnSum[\\'0\\']\\n        grid[rowIndex][columnIndex].columnSum[\\'1\\'] +=\\n          grid[rowIndex][columnIndex - 1].columnSum[\\'1\\']\\n      }\\n    }\\n  }\\n\\n  const lastRowIndex = grid.length - 1\\n  const lastColumnIndex = grid[0].length - 1\\n  for (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n    for (\\n      let columnIndex = 0;\\n      columnIndex < grid[rowIndex].length;\\n      columnIndex++\\n    ) {\\n      grid[rowIndex][columnIndex].output =\\n        grid[rowIndex][lastColumnIndex].columnSum[\\'1\\'] -\\n        grid[rowIndex][lastColumnIndex].columnSum[\\'0\\'] +\\n        grid[lastRowIndex][columnIndex].rowSum[\\'1\\'] -\\n        grid[lastRowIndex][columnIndex].rowSum[\\'0\\']\\n    }\\n  }\\n\\n  for (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n    for (\\n      let columnIndex = 0;\\n      columnIndex < grid[rowIndex].length;\\n      columnIndex++\\n    ) {\\n      grid[rowIndex][columnIndex] = grid[rowIndex][columnIndex].output\\n    }\\n  }\\n\\n  return grid\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar onesMinusZeros = function (grid) {\\n  for (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n    for (\\n      let columnIndex = 0;\\n      columnIndex < grid[rowIndex].length;\\n      columnIndex++\\n    ) {\\n      if (grid[rowIndex][columnIndex]) {\\n        grid[rowIndex][columnIndex] = {\\n          rowSum: {\\n            0: 0,\\n            1: 1,\\n          },\\n          columnSum: {\\n            0: 0,\\n            1: 1,\\n          },\\n        }\\n      } else {\\n        grid[rowIndex][columnIndex] = {\\n          rowSum: {\\n            0: 1,\\n            1: 0,\\n          },\\n          columnSum: {\\n            0: 1,\\n            1: 0,\\n          },\\n        }\\n      }\\n    }\\n  }\\n\\n  for (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n    for (\\n      let columnIndex = 0;\\n      columnIndex < grid[rowIndex].length;\\n      columnIndex++\\n    ) {\\n      if (grid[rowIndex - 1] && grid[rowIndex - 1][columnIndex]) {\\n        grid[rowIndex][columnIndex].rowSum[\\'0\\'] +=\\n          grid[rowIndex - 1][columnIndex].rowSum[\\'0\\']\\n        grid[rowIndex][columnIndex].rowSum[\\'1\\'] +=\\n          grid[rowIndex - 1][columnIndex].rowSum[\\'1\\']\\n      }\\n      if (grid[rowIndex][columnIndex - 1]) {\\n        grid[rowIndex][columnIndex].columnSum[\\'0\\'] +=\\n          grid[rowIndex][columnIndex - 1].columnSum[\\'0\\']\\n        grid[rowIndex][columnIndex].columnSum[\\'1\\'] +=\\n          grid[rowIndex][columnIndex - 1].columnSum[\\'1\\']\\n      }\\n    }\\n  }\\n\\n  const lastRowIndex = grid.length - 1\\n  const lastColumnIndex = grid[0].length - 1\\n  for (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n    for (\\n      let columnIndex = 0;\\n      columnIndex < grid[rowIndex].length;\\n      columnIndex++\\n    ) {\\n      grid[rowIndex][columnIndex].output =\\n        grid[rowIndex][lastColumnIndex].columnSum[\\'1\\'] -\\n        grid[rowIndex][lastColumnIndex].columnSum[\\'0\\'] +\\n        grid[lastRowIndex][columnIndex].rowSum[\\'1\\'] -\\n        grid[lastRowIndex][columnIndex].rowSum[\\'0\\']\\n    }\\n  }\\n\\n  for (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n    for (\\n      let columnIndex = 0;\\n      columnIndex < grid[rowIndex].length;\\n      columnIndex++\\n    ) {\\n      grid[rowIndex][columnIndex] = grid[rowIndex][columnIndex].output\\n    }\\n  }\\n\\n  return grid\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364334,
                "title": "c-matrix-faster-easy-to-understand",
                "content": "* ***Matrix***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        vector<int> row_0(n, 0), row_1(n, 0);\\n        \\n        vector<int> col_0(m, 0), col_1(m, 0);\\n        \\n        // count the no. of zeros and ones in rows\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int zero = 0, one = 0;\\n            \\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] == 0)\\n                {\\n                    zero++;\\n                }\\n                else if(grid[i][j] == 1)\\n                {\\n                    one++;\\n                }\\n            }\\n            \\n            row_0[i] = zero;\\n            \\n            row_1[i] = one;\\n        }\\n        \\n        // count the no. of zeros and ones in col.\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            int zero = 0, one = 0;\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                if(grid[i][j] == 0)\\n                {\\n                    zero++;\\n                }\\n                else if(grid[i][j] == 1)\\n                {\\n                    one++;\\n                }\\n            }\\n            \\n            col_0[j] = zero;\\n            \\n            col_1[j] = one;\\n        }\\n        \\n        // generate res matrix\\n        \\n        vector<vector<int>> res(n, vector<int> (m, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                res[i][j] = row_1[i] + col_1[j] - row_0[i] - col_0[j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        vector<int> row_0(n, 0), row_1(n, 0);\\n        \\n        vector<int> col_0(m, 0), col_1(m, 0);\\n        \\n        // count the no. of zeros and ones in rows\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int zero = 0, one = 0;\\n            \\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] == 0)\\n                {\\n                    zero++;\\n                }\\n                else if(grid[i][j] == 1)\\n                {\\n                    one++;\\n                }\\n            }\\n            \\n            row_0[i] = zero;\\n            \\n            row_1[i] = one;\\n        }\\n        \\n        // count the no. of zeros and ones in col.\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            int zero = 0, one = 0;\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                if(grid[i][j] == 0)\\n                {\\n                    zero++;\\n                }\\n                else if(grid[i][j] == 1)\\n                {\\n                    one++;\\n                }\\n            }\\n            \\n            col_0[j] = zero;\\n            \\n            col_1[j] = one;\\n        }\\n        \\n        // generate res matrix\\n        \\n        vector<vector<int>> res(n, vector<int> (m, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                res[i][j] = row_1[i] + col_1[j] - row_0[i] - col_0[j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349159,
                "title": "easy-to-understand-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& g) {\\n        int c = g.size();\\n        int r = g[0].size();\\n        vector<int> onr;\\n        vector<int> onc;\\n        \\n        vector<vector<int>> res(c,vector<int>(r));\\n        for(int i=0;i<c;i++)\\n        {\\n            int cnt = 0;\\n            for(int j = 0;j<r;j++)\\n            {\\n                cnt+=g[i][j];\\n            }\\n            onr.push_back(cnt);\\n        }\\n        \\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            int cnt = 0;\\n            for(int j = 0;j<c;j++)\\n            {\\n                cnt+=g[j][i];\\n            }\\n            onc.push_back(cnt);\\n        }\\n        \\n        for(int i=0;i<c;i++)\\n        {\\n            for(int j=0;j<r;j++)\\n            {\\n                res[i][j] = onr[i]+onc[j] - (r-onr[i]+c-onc[j]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& g) {\\n        int c = g.size();\\n        int r = g[0].size();\\n        vector<int> onr;\\n        vector<int> onc;\\n        \\n        vector<vector<int>> res(c,vector<int>(r));\\n        for(int i=0;i<c;i++)\\n        {\\n            int cnt = 0;\\n            for(int j = 0;j<r;j++)\\n            {\\n                cnt+=g[i][j];\\n            }\\n            onr.push_back(cnt);\\n        }\\n        \\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            int cnt = 0;\\n            for(int j = 0;j<c;j++)\\n            {\\n                cnt+=g[j][i];\\n            }\\n            onc.push_back(cnt);\\n        }\\n        \\n        for(int i=0;i<c;i++)\\n        {\\n            for(int j=0;j<r;j++)\\n            {\\n                res[i][j] = onr[i]+onc[j] - (r-onr[i]+c-onc[j]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336956,
                "title": "brute-force-easy-cpp-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Please upvote the solution if you like it.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function calculates the number of ones and zeros in each row and each column of the input \"grid\" vector, and then subtracts the number of zeros from the number of ones in each row and column separately.\\n\\nFinally, the result of subtraction is assigned to each cell of the \"grid\" vector and the modified \"grid\" vector is returned as the output of the function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(false);\\n        vector<pair<int,int>> row;\\n        for(int i=0;i<grid.size();i++){\\n            int countOne = count(grid[i].begin(),grid[i].end(),1);\\n            row.push_back({countOne,grid[i].size()-countOne});\\n        }\\n        vector<pair<int,int>> col;\\n        for(int i=0;i<grid[0].size();i++){\\n            int countOne=0;\\n            int countZero=0;\\n            for(int j=0;j<grid.size();j++){\\n                if(grid[j][i]==1){\\n                    countOne++;\\n                }\\n                else{\\n                    countZero++;\\n                }\\n            }\\n            col.push_back({countOne,countZero});\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                grid[i][j]=row[i].first+col[j].first-row[i].second-col[j].second;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(false);\\n        vector<pair<int,int>> row;\\n        for(int i=0;i<grid.size();i++){\\n            int countOne = count(grid[i].begin(),grid[i].end(),1);\\n            row.push_back({countOne,grid[i].size()-countOne});\\n        }\\n        vector<pair<int,int>> col;\\n        for(int i=0;i<grid[0].size();i++){\\n            int countOne=0;\\n            int countZero=0;\\n            for(int j=0;j<grid.size();j++){\\n                if(grid[j][i]==1){\\n                    countOne++;\\n                }\\n                else{\\n                    countZero++;\\n                }\\n            }\\n            col.push_back({countOne,countZero});\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                grid[i][j]=row[i].first+col[j].first-row[i].second-col[j].second;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332700,
                "title": "beginner-friendly-simple-soln",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int Ones[] = new int[m+n];\\n        int Zeroes[] = new int[m+n];\\n\\n        int idx = 0;\\n        \\n        // Calculating the number of ones , zeroes for each rows  \\n        for (int i = 0; i < m ; i++) {\\n\\n            int countOnes = 0;\\n            int countZeroes = 0;\\n\\n            for (int j = 0; j < n ; j++) {\\n\\n                if (grid[i][j] == 1) {\\n\\n                    countOnes += 1;\\n\\n                } else {\\n\\n                    countZeroes += 1;\\n                }\\n            }\\n\\n            Ones[idx] = countOnes;\\n            Zeroes[idx] = countZeroes;\\n\\n            idx += 1;\\n        }\\n        \\n        // Calculating Ones and Zeroes for each columns.    \\n        for (int j = 0; j < n ; j++) {\\n\\n            int countOnes = 0;\\n            int countZeroes = 0;\\n\\n            for (int i = 0; i < m ; i++) {\\n\\n                if (grid[i][j] == 1) {\\n\\n                    countOnes += 1;\\n\\n                } else {\\n\\n                    countZeroes += 1;\\n                }\\n            }\\n\\n            Ones[idx] = countOnes;\\n            Zeroes[idx] = countZeroes;\\n\\n            idx += 1;\\n        }\\n\\n        for (int i = 0; i < m ; i++) {\\n\\n            for (int j = 0; j < n ; j++) {\\n\\n                grid[i][j] = Ones[i] + Ones[m+j] - Zeroes[i] - Zeroes[m+j];\\n            }\\n        }\\n\\n        return grid;\\n\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int Ones[] = new int[m+n];\\n        int Zeroes[] = new int[m+n];\\n\\n        int idx = 0;\\n        \\n        // Calculating the number of ones , zeroes for each rows  \\n        for (int i = 0; i < m ; i++) {\\n\\n            int countOnes = 0;\\n            int countZeroes = 0;\\n\\n            for (int j = 0; j < n ; j++) {\\n\\n                if (grid[i][j] == 1) {\\n\\n                    countOnes += 1;\\n\\n                } else {\\n\\n                    countZeroes += 1;\\n                }\\n            }\\n\\n            Ones[idx] = countOnes;\\n            Zeroes[idx] = countZeroes;\\n\\n            idx += 1;\\n        }\\n        \\n        // Calculating Ones and Zeroes for each columns.    \\n        for (int j = 0; j < n ; j++) {\\n\\n            int countOnes = 0;\\n            int countZeroes = 0;\\n\\n            for (int i = 0; i < m ; i++) {\\n\\n                if (grid[i][j] == 1) {\\n\\n                    countOnes += 1;\\n\\n                } else {\\n\\n                    countZeroes += 1;\\n                }\\n            }\\n\\n            Ones[idx] = countOnes;\\n            Zeroes[idx] = countZeroes;\\n\\n            idx += 1;\\n        }\\n\\n        for (int i = 0; i < m ; i++) {\\n\\n            for (int j = 0; j < n ; j++) {\\n\\n                grid[i][j] = Ones[i] + Ones[m+j] - Zeroes[i] - Zeroes[m+j];\\n            }\\n        }\\n\\n        return grid;\\n\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332652,
                "title": "simple-java-solution",
                "content": "# Intuition\\n    Traverse each element for 0 and 1\\n\\n\\n# Approach\\n    count 0 and 1 for every grid[i][j]\\n\\n# Complexity\\n-  Time complexity:\\n    O(n^2)\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int rowzero[] = new int[m];\\n        int colzero[] = new int[n];\\n        int rowone[] = new int[m];\\n        int colone[] = new int[n];\\n        for(int i = 0;i < m;i++)\\n        {\\n            for(int j = 0;j < n;j++)\\n            {\\n                if(grid[i][j] == 0)\\n                {\\n                    rowzero[i]++;\\n                    colzero[j]++;\\n                }\\n                else\\n                {\\n                    rowone[i]++;\\n                    colone[j]++;\\n                }\\n            }\\n        }\\n        for(int i = 0;i < m;i++)\\n        {\\n            for(int j = 0;j < n;j++)\\n            {\\n            grid[i][j] = rowone[i] + colone[j] - rowzero[i] -colzero[j];\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int rowzero[] = new int[m];\\n        int colzero[] = new int[n];\\n        int rowone[] = new int[m];\\n        int colone[] = new int[n];\\n        for(int i = 0;i < m;i++)\\n        {\\n            for(int j = 0;j < n;j++)\\n            {\\n                if(grid[i][j] == 0)\\n                {\\n                    rowzero[i]++;\\n                    colzero[j]++;\\n                }\\n                else\\n                {\\n                    rowone[i]++;\\n                    colone[j]++;\\n                }\\n            }\\n        }\\n        for(int i = 0;i < m;i++)\\n        {\\n            for(int j = 0;j < n;j++)\\n            {\\n            grid[i][j] = rowone[i] + colone[j] - rowzero[i] -colzero[j];\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067563,
                "title": "easy-java-solution-82-beat-asked-in-amazon-internship",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        int[][] diff = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    row[i] += grid[i][j];\\n                    col[j] += grid[i][j];\\n                }\\n            }\\n        }\\n        for(int i= 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                diff[i][j] = row[i] + col[j] - (m - row[i] + n - col[j]);\\n            }\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        int[][] diff = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    row[i] += grid[i][j];\\n                    col[j] += grid[i][j];\\n                }\\n            }\\n        }\\n        for(int i= 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                diff[i][j] = row[i] + col[j] - (m - row[i] + n - col[j]);\\n            }\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055342,
                "title": "efficient-o-nxn-time-space-approach-using-prefix-sum-in-each-row-column",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        //idea is to create prefix sum matrix of rows & cols\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>preRows;\\n        vector<vector<int>>preCols;\\n        preRows=grid;\\n        preCols=grid;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                preRows[i][j]+=preRows[i][j-1];\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                preCols[j][i]+=preCols[j-1][i];\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int ones=preRows[i][n-1]+preCols[m-1][j];\\n                int zeros=(m+n)-ones;\\n                grid[i][j]=(ones-zeros);\\n            }\\n        }\\n        return grid;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        //idea is to create prefix sum matrix of rows & cols\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>preRows;\\n        vector<vector<int>>preCols;\\n        preRows=grid;\\n        preCols=grid;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                preRows[i][j]+=preRows[i][j-1];\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                preCols[j][i]+=preCols[j-1][i];\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int ones=preRows[i][n-1]+preCols[m-1][j];\\n                int zeros=(m+n)-ones;\\n                grid[i][j]=(ones-zeros);\\n            }\\n        }\\n        return grid;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040500,
                "title": "easy-java-solution-beats-98-online-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(max(n,m))\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[] row0 = new int[n];\\n        int[] row1 = new int[n];\\n        int[] col1 = new int[m];\\n        int[] col0 = new int[m];\\n\\n\\n        for(int i = 0;i < n;i++){\\n            int ct1 = 0,ct0 = 0;\\n            for(int j = 0;j < m;j++){\\n                if(grid[i][j] == 0){\\n                    ct0++;\\n                }\\n                else{\\n                    ct1++;\\n                }\\n            }\\n            row1[i] = ct1;\\n            row0[i] = ct0;\\n        }\\n        for(int j = 0;j < m;j++){\\n            int ct0 = 0,ct1 = 0;\\n            for(int i = 0;i < n;i++){\\n                if(grid[i][j] == 0){\\n                    ct0++;\\n                }\\n                else{\\n                    ct1++;\\n                }\\n            }\\n            col0[j] = ct0;\\n            col1[j] = ct1;\\n        }\\n\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < m;j++){\\n                grid[i][j] = (row1[i]+col1[j]) - (row0[i]+col0[j]);\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```\\nDo Upvote",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[] row0 = new int[n];\\n        int[] row1 = new int[n];\\n        int[] col1 = new int[m];\\n        int[] col0 = new int[m];\\n\\n\\n        for(int i = 0;i < n;i++){\\n            int ct1 = 0,ct0 = 0;\\n            for(int j = 0;j < m;j++){\\n                if(grid[i][j] == 0){\\n                    ct0++;\\n                }\\n                else{\\n                    ct1++;\\n                }\\n            }\\n            row1[i] = ct1;\\n            row0[i] = ct0;\\n        }\\n        for(int j = 0;j < m;j++){\\n            int ct0 = 0,ct1 = 0;\\n            for(int i = 0;i < n;i++){\\n                if(grid[i][j] == 0){\\n                    ct0++;\\n                }\\n                else{\\n                    ct1++;\\n                }\\n            }\\n            col0[j] = ct0;\\n            col1[j] = ct1;\\n        }\\n\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < m;j++){\\n                grid[i][j] = (row1[i]+col1[j]) - (row0[i]+col0[j]);\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027736,
                "title": "c-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo keep count of number of 0\\'s in a row , number of 1\\'s in a row, number of 1\\'s in a column and number of 0\\'s in a column, we create four vectors for each.  \\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int rowsz=grid.size();\\n        int colsz=grid[0].size();\\n        vector<vector<int>> diff=grid;\\n        vector<int> rowszero(rowsz,0); vector<int> colszero(colsz,0);\\n        vector<int> rowsone(rowsz,0);  vector<int> colsone(colsz,0);\\n\\n        for(int i=0;i<rowsz;i++){\\n            for(int j=0;j<colsz;j++){\\n                if(grid[i][j]) \\n                { rowsone[i]++; colsone[j]++; }\\n                else\\n                { rowszero[i]++; colszero[j]++; }\\n            }\\n        }\\n        for(int i=0;i<rowsz;i++){\\n            for(int j=0;j<colsz;j++){\\n                diff[i][j]=colsone[j]+rowsone[i]-rowszero[i]-colszero[j];\\n            }\\n        }\\n        return diff;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int rowsz=grid.size();\\n        int colsz=grid[0].size();\\n        vector<vector<int>> diff=grid;\\n        vector<int> rowszero(rowsz,0); vector<int> colszero(colsz,0);\\n        vector<int> rowsone(rowsz,0);  vector<int> colsone(colsz,0);\\n\\n        for(int i=0;i<rowsz;i++){\\n            for(int j=0;j<colsz;j++){\\n                if(grid[i][j]) \\n                { rowsone[i]++; colsone[j]++; }\\n                else\\n                { rowszero[i]++; colszero[j]++; }\\n            }\\n        }\\n        for(int i=0;i<rowsz;i++){\\n            for(int j=0;j<colsz;j++){\\n                diff[i][j]=colsone[j]+rowsone[i]-rowszero[i]-colszero[j];\\n            }\\n        }\\n        return diff;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973204,
                "title": "c-concised-solution-easy-to-understand-80-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<int>rowz(m),rowo(m),colz(n),colo(n);\\n        for(int i=0;i<m;i++){\\n            int sum=0;\\n            for(int j=0;j<n;j++){\\n               sum+=mat[i][j];  \\n            }\\n            rowo[i]=sum;\\n            rowz[i]=n-sum;\\n        \\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=0;j<m;j++){\\n               sum+=mat[j][i];  \\n            }\\n            colo[i]=sum;\\n            colz[i]=m-sum;\\n        }\\n        vector<vector<int>>ret;\\n        for(int i=0;i<m;i++){\\n            vector<int>ans;\\n            for(int j=0;j<n;j++){\\n                ans.push_back(rowo[i]+colo[j]-rowz[i]-colz[j]);\\n            }\\n            ret.push_back(ans);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<int>rowz(m),rowo(m),colz(n),colo(n);\\n        for(int i=0;i<m;i++){\\n            int sum=0;\\n            for(int j=0;j<n;j++){\\n               sum+=mat[i][j];  \\n            }\\n            rowo[i]=sum;\\n            rowz[i]=n-sum;\\n        \\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=0;j<m;j++){\\n               sum+=mat[j][i];  \\n            }\\n            colo[i]=sum;\\n            colz[i]=m-sum;\\n        }\\n        vector<vector<int>>ret;\\n        for(int i=0;i<m;i++){\\n            vector<int>ans;\\n            for(int j=0;j<n;j++){\\n                ans.push_back(rowo[i]+colo[j]-rowz[i]-colz[j]);\\n            }\\n            ret.push_back(ans);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951601,
                "title": "c-count-ones",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<int> onesRow(m);\\n        vector<int> onesCol(n);\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                onesRow[i] += grid[i][j] == 1;\\n                onesCol[j] += grid[i][j] == 1;\\n            }\\n        }\\n\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                ans[i][j] = onesRow[i] + onesCol[j] - (m - onesRow[i]) - (n - onesCol[j]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<int> onesRow(m);\\n        vector<int> onesCol(n);\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                onesRow[i] += grid[i][j] == 1;\\n                onesCol[j] += grid[i][j] == 1;\\n            }\\n        }\\n\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                ans[i][j] = onesRow[i] + onesCol[j] - (m - onesRow[i]) - (n - onesCol[j]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937809,
                "title": "optimized-rust-solution",
                "content": "# About the Solution\\nMy initial solution had lots of redudent parts. There were four `Vec`s (ones and zeros for rows and cols), and I was iterating over the grid get the output (for ease).\\n\\nAfter that, I started optimizing. You can calculate a row/col\\'s zeros from the one via `len - ones[i]`. Also, I didn\\'t need to iterate over grid to get the output, its indices would suffice.\\n\\nThis was a good solution, but still used more memory than needed. Since the function gets an owned `Vec<Vec<>>`, we can manipulate it in-place to cut down on a second series of allocations.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m + n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn ones_minus_zeros(mut grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let rows_ones: Vec<i32> = grid.iter().map(|r| r.iter().sum()).collect();\\n        let row_len = grid.len() as i32;\\n\\n        let cols_ones: Vec<i32> = (0..grid[0].len())\\n            .map(|i| grid.iter().map(|r| r[i]).sum())\\n            .collect();\\n        let col_len = grid[0].len() as i32;\\n        let grid_val = row_len + col_len;\\n\\n        grid.iter_mut().enumerate().for_each(|(i, r)| {\\n            r.iter_mut()\\n                .enumerate()\\n                .for_each(|(j, v)| *v = 2 * (rows_ones[i] + cols_ones[j]) - grid_val)\\n        });\\n        grid\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn ones_minus_zeros(mut grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let rows_ones: Vec<i32> = grid.iter().map(|r| r.iter().sum()).collect();\\n        let row_len = grid.len() as i32;\\n\\n        let cols_ones: Vec<i32> = (0..grid[0].len())\\n            .map(|i| grid.iter().map(|r| r[i]).sum())\\n            .collect();\\n        let col_len = grid[0].len() as i32;\\n        let grid_val = row_len + col_len;\\n\\n        grid.iter_mut().enumerate().for_each(|(i, r)| {\\n            r.iter_mut()\\n                .enumerate()\\n                .for_each(|(j, v)| *v = 2 * (rows_ones[i] + cols_ones[j]) - grid_val)\\n        });\\n        grid\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2897762,
                "title": "super-simple-typescript-beats-90-video-explanation",
                "content": "# Approach\\nPre calculate all sums in one dimentional arrays for columns and rows\\n\\n# Complexity\\n- Time complexity:\\nO(n * m)\\n\\n- Space complexity:\\nO(n * m)\\n\\n# Code\\n```\\nfunction onesMinusZeros(grid: number[][]): number[][] {\\n    if (grid.length === 0) return [];\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const onesRow = [...Array(m)].fill(0);\\n    const onesCol = [...Array(n)].fill(0);\\n    const zerosRow = [...Array(m)].fill(0);\\n    const zeroCol = [...Array(n)].fill(0);\\n\\n    const diff = [...Array(m)].map(() => [...Array(n)].fill(0));\\n\\n    for (let i = 0 ; i < m; i++) {\\n        for (let j = 0 ; j < n; j++) {\\n            if (grid[i][j] === 1) {\\n                onesRow[i]++\\n                onesCol[j]++\\n            } else {\\n                zerosRow[i]++\\n                zeroCol[j]++\\n            }\\n        }\\n    }\\n\\n    for (let i = 0 ; i < m; i++) {\\n        for (let j = 0 ; j < n; j++) {\\n            diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zeroCol[j]\\n        }\\n    }\\n\\n\\n    return diff;\\n};\\n```\\n\\nexplanation https://www.youtube.com/watch?v=2Dtf06jkBpI&ab_channel=YoucodewithDmytro",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction onesMinusZeros(grid: number[][]): number[][] {\\n    if (grid.length === 0) return [];\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const onesRow = [...Array(m)].fill(0);\\n    const onesCol = [...Array(n)].fill(0);\\n    const zerosRow = [...Array(m)].fill(0);\\n    const zeroCol = [...Array(n)].fill(0);\\n\\n    const diff = [...Array(m)].map(() => [...Array(n)].fill(0));\\n\\n    for (let i = 0 ; i < m; i++) {\\n        for (let j = 0 ; j < n; j++) {\\n            if (grid[i][j] === 1) {\\n                onesRow[i]++\\n                onesCol[j]++\\n            } else {\\n                zerosRow[i]++\\n                zeroCol[j]++\\n            }\\n        }\\n    }\\n\\n    for (let i = 0 ; i < m; i++) {\\n        for (let j = 0 ; j < n; j++) {\\n            diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zeroCol[j]\\n        }\\n    }\\n\\n\\n    return diff;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2891090,
                "title": "cpp-two-vector-method-simple-n-sweet",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust make two 2D vector `row[zeros][ones] , col[zeros][ones]` of `m x n` size and collect all the zeros and ones and add it into the respected 2D vector after that  do `   diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj`\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(2*m+2*n)== O(m+n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<vector<int>> row(grid.size(),vector<int>(2,0)),\\n                            col(grid[0].size(),vector<int>(2,0)),\\n                    diff(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0){\\n                    row[i][0]++;\\n                    col[j][0]++;\\n                }else{\\n                    row[i][1]++;\\n                    col[j][1]++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                diff[i][j]= row[i][1]+col[j][1]-row[i][0]-col[j][0];\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<vector<int>> row(grid.size(),vector<int>(2,0)),\\n                            col(grid[0].size(),vector<int>(2,0)),\\n                    diff(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0){\\n                    row[i][0]++;\\n                    col[j][0]++;\\n                }else{\\n                    row[i][1]++;\\n                    col[j][1]++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                diff[i][j]= row[i][1]+col[j][1]-row[i][0]-col[j][0];\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887064,
                "title": "beginner-friendly-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int[] onesrow = new int[grid.length];\\n        int[] onescol = new int[grid[0].length];\\n        int[][] result = new int[grid.length][grid[0].length];\\n        \\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n               if(grid[i][j] == 1){\\n                   onesrow[i]++;\\n                   onescol[j]++;\\n               } \\n            }\\n        }\\n        \\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n               result[i][j] = 2 * (onesrow[i] + onescol[j]) - grid.length - grid[0].length; \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int[] onesrow = new int[grid.length];\\n        int[] onescol = new int[grid[0].length];\\n        int[][] result = new int[grid.length][grid[0].length];\\n        \\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n               if(grid[i][j] == 1){\\n                   onesrow[i]++;\\n                   onescol[j]++;\\n               } \\n            }\\n        }\\n        \\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n               result[i][j] = 2 * (onesrow[i] + onescol[j]) - grid.length - grid[0].length; \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882722,
                "title": "my-submission-very-easy-java",
                "content": "- 85/85 cases passed (22 ms)\\n- Your runtime beats 62.36 % of java submissions\\n- Your memory usage beats 55.52 % of java submissions (146.4 MB)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int [][] r=new int[2][m];\\n        int [][] c=new int[2][n];\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                r[grid[i][j]][i]++;\\n                c[grid[i][j]][j]++;\\n            }\\n        \\n\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                grid[i][j]=r[1][i]+c[1][j]-r[0][i]-c[0][j];\\n            \\n        \\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int [][] r=new int[2][m];\\n        int [][] c=new int[2][n];\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                r[grid[i][j]][i]++;\\n                c[grid[i][j]][j]++;\\n            }\\n        \\n\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                grid[i][j]=r[1][i]+c[1][j]-r[0][i]-c[0][j];\\n            \\n        \\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864001,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        vector<pair<int,int>> row, col;\\n        for(int i=0; i<n; ++i){\\n            pair<int,int> count{0,0};\\n            for(int j=0; j<m; ++j){\\n                grid[i][j] ? count.second++ : count.first++;\\n            }\\n            row.push_back(count);\\n        }\\n        for(int i=0; i<m; ++i){\\n            pair<int,int> count{0,0};\\n            for(int j=0; j<n; ++j){\\n                grid[j][i] ? count.second++ : count.first++;\\n            }\\n            col.push_back(count);\\n        }\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                ans[i][j] = row[i].second + col[j].second - row[i].first - col[j].first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        vector<pair<int,int>> row, col;\\n        for(int i=0; i<n; ++i){\\n            pair<int,int> count{0,0};\\n            for(int j=0; j<m; ++j){\\n                grid[i][j] ? count.second++ : count.first++;\\n            }\\n            row.push_back(count);\\n        }\\n        for(int i=0; i<m; ++i){\\n            pair<int,int> count{0,0};\\n            for(int j=0; j<n; ++j){\\n                grid[j][i] ? count.second++ : count.first++;\\n            }\\n            col.push_back(count);\\n        }\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                ans[i][j] = row[i].second + col[j].second - row[i].first - col[j].first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852502,
                "title": "simple-c-code-o-n-m",
                "content": "# Intuition\\n\\n\\n# Approach\\nWe will traverse the grid thrice. First time we will traverse row by row and store the number of 1s in each row in a vector.\\nNext time we will traverse column by column and store the no. of 1s in each column in second vector.\\nNow in our final traversal we will calculate the answer of each element.\\nClearly ans = rowcount1s + columncount1s -rowscount0s -columnscount0s.\\ni.e ans = rowscount1s + coumncount1s - (m-rowscount1s)- (n-columscount1s).\\n\\n\\n# Complexity\\n- Time complexity:\\n3* O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size(),count;\\n        vector<int> counti(m);\\n        vector<int> countj(n);\\n        for(int i=0;i<m;i++)          //first traversal to store rowcount\\n        {\\n            count=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                count++;\\n            }\\n            counti[i]=count;\\n        }\\n        for(int j=0;j<n;j++)         //second traversal to store columncount\\n        {\\n            count=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                if(grid[i][j]==1)\\n                count++;\\n            }\\n            countj[j]=count;\\n        }\\n\\n        vector<vector<int>> ans;\\n        vector<int> order;\\n        int x;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                x=counti[i]+countj[j]-(m-counti[i])-(n-countj[j]);\\n                order.push_back(x);\\n            }\\n            ans.push_back(order);\\n            order.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size(),count;\\n        vector<int> counti(m);\\n        vector<int> countj(n);\\n        for(int i=0;i<m;i++)          //first traversal to store rowcount\\n        {\\n            count=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                count++;\\n            }\\n            counti[i]=count;\\n        }\\n        for(int j=0;j<n;j++)         //second traversal to store columncount\\n        {\\n            count=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                if(grid[i][j]==1)\\n                count++;\\n            }\\n            countj[j]=count;\\n        }\\n\\n        vector<vector<int>> ans;\\n        vector<int> order;\\n        int x;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                x=counti[i]+countj[j]-(m-counti[i])-(n-countj[j]);\\n                order.push_back(x);\\n            }\\n            ans.push_back(order);\\n            order.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852451,
                "title": "basic-python3-solution",
                "content": "\\n![image](https://assets.leetcode.com/users/images/2cadf59c-644b-47e0-9e84-9775c8742a8a_1669524938.7382567.png)\\n\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        nr = len(grid)\\n        nc = len(grid[0])\\n        \\n        tempr = [0]*nr\\n        tempc = [0]*nc\\n        \\n        diff = [[0]*nc for _ in range(nr)]\\n        \\n        for i in range(nr):\\n            tempr[i] = grid[i].count(1) - grid[i].count(0)\\n            \\n        for j in range(nc):\\n            val = 0\\n            for i in range(nr):\\n                if grid[i][j] == 1:\\n                    val+=1\\n                if grid[i][j] == 0:\\n                    val-=1\\n                    \\n            tempc[j] = val\\n    \\n        \\n        for i in range(nr):\\n            for j in range(nc):\\n                diff[i][j] = tempr[i]+tempc[j]\\n        \\n        return diff\\n                \\n        \\n        \\n",
                "solutionTags": [],
                "code": "\\n![image](https://assets.leetcode.com/users/images/2cadf59c-644b-47e0-9e84-9775c8742a8a_1669524938.7382567.png)\\n\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        nr = len(grid)\\n        nc = len(grid[0])\\n        \\n        tempr = [0]*nr\\n        tempc = [0]*nc\\n        \\n        diff = [[0]*nc for _ in range(nr)]\\n        \\n        for i in range(nr):\\n            tempr[i] = grid[i].count(1) - grid[i].count(0)\\n            \\n        for j in range(nc):\\n            val = 0\\n            for i in range(nr):\\n                if grid[i][j] == 1:\\n                    val+=1\\n                if grid[i][j] == 0:\\n                    val-=1\\n                    \\n            tempc[j] = val\\n    \\n        \\n        for i in range(nr):\\n            for j in range(nc):\\n                diff[i][j] = tempr[i]+tempc[j]\\n        \\n        return diff\\n                \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2852286,
                "title": "c-easy-simple-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int> row1(m,0);\\n        vector<int> col1(n,0);\\n        vector<int> row0(m,0);\\n        vector<int> col0(n,0);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                row1[i]+=(grid[i][j]==1);\\n                row0[i]+=(grid[i][j]==0);\\n            }\\n        }\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                col1[j]+=(grid[i][j]==1);\\n                col0[j]+=(grid[i][j]==0);\\n            }\\n        }\\n        vector<vector<int>> diff(m,vector<int>(n,-1));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                diff[i][j]=row1[i]+col1[j]-row0[i]-col0[j];\\n                // cout<<row1[i]<<\" \"<<row0[i]<<\" \"<<col1[j]<<\" \"<<col0[j]<<endl;\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int> row1(m,0);\\n        vector<int> col1(n,0);\\n        vector<int> row0(m,0);\\n        vector<int> col0(n,0);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                row1[i]+=(grid[i][j]==1);\\n                row0[i]+=(grid[i][j]==0);\\n            }\\n        }\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                col1[j]+=(grid[i][j]==1);\\n                col0[j]+=(grid[i][j]==0);\\n            }\\n        }\\n        vector<vector<int>> diff(m,vector<int>(n,-1));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                diff[i][j]=row1[i]+col1[j]-row0[i]-col0[j];\\n                // cout<<row1[i]<<\" \"<<row0[i]<<\" \"<<col1[j]<<\" \"<<col0[j]<<endl;\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2851436,
                "title": "simple-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int numOfRows = grid.length;\\n        int numOfColumns = grid[0].length;\\n        int[] onesInRows = new int[numOfRows];\\n        int[] onesInColumns = new int[numOfColumns];\\n\\n\\t\\t// Arrays onesInRows[] and onesInColumns[] are initialized with 0s (guaranteed by the language spec)\\n\\t\\t// Going to count 1s to fill these arrays\\n\\t\\t\\n        for (int row = 0; row < numOfRows; row++) {\\n            for (int column = 0; column < numOfColumns; column++) {\\n                if (grid[row][column] == 1) {\\n                    onesInRows[row]++;\\n                    onesInColumns[column]++;\\n                }\\n            }\\n        }\\n\\n\\t\\t// Filling the result matrix res using data from onesInRows[] and onesInColumns[]\\n\\t\\t// We know number of 1s, so we can calculate num of 0s: numOfRows - onesInRows[row] and numOfColumns - onesInColumns[column]\\n\\t\\t\\n        int[][] res = new int[numOfRows][numOfColumns];\\n        for (int row = 0; row < numOfRows; row++) {\\n            for (int column = 0; column < numOfColumns; column++) {\\n                res[row][column] = onesInColumns[column] + onesInRows[row]\\n                        - (numOfRows - onesInRows[row])\\n                        - (numOfColumns - onesInColumns[column]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int numOfRows = grid.length;\\n        int numOfColumns = grid[0].length;\\n        int[] onesInRows = new int[numOfRows];\\n        int[] onesInColumns = new int[numOfColumns];\\n\\n\\t\\t// Arrays onesInRows[] and onesInColumns[] are initialized with 0s (guaranteed by the language spec)\\n\\t\\t// Going to count 1s to fill these arrays\\n\\t\\t\\n        for (int row = 0; row < numOfRows; row++) {\\n            for (int column = 0; column < numOfColumns; column++) {\\n                if (grid[row][column] == 1) {\\n                    onesInRows[row]++;\\n                    onesInColumns[column]++;\\n                }\\n            }\\n        }\\n\\n\\t\\t// Filling the result matrix res using data from onesInRows[] and onesInColumns[]\\n\\t\\t// We know number of 1s, so we can calculate num of 0s: numOfRows - onesInRows[row] and numOfColumns - onesInColumns[column]\\n\\t\\t\\n        int[][] res = new int[numOfRows][numOfColumns];\\n        for (int row = 0; row < numOfRows; row++) {\\n            for (int column = 0; column < numOfColumns; column++) {\\n                res[row][column] = onesInColumns[column] + onesInRows[row]\\n                        - (numOfRows - onesInRows[row])\\n                        - (numOfColumns - onesInColumns[column]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851430,
                "title": "easy-to-understand-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        map<int,int> mp;\\n        map<int, int> mp1;\\n        int sum = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> v(n, vector<int> (m,0));\\n        \\n        for(int i = 0; i < n; i++){\\n            sum = 0;\\n            for(int j = 0; j < m; j++){\\n                sum += grid[i][j];\\n            }\\n            mp[i] = sum;\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            sum = 0;\\n            for(int j = 0; j < n; j++){\\n                sum += grid[j][i];\\n            }\\n            mp1[i] = sum;\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                v[i][j] = mp[i] + mp1[j] - (n - mp[i]) - (m - mp1[j]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        map<int,int> mp;\\n        map<int, int> mp1;\\n        int sum = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> v(n, vector<int> (m,0));\\n        \\n        for(int i = 0; i < n; i++){\\n            sum = 0;\\n            for(int j = 0; j < m; j++){\\n                sum += grid[i][j];\\n            }\\n            mp[i] = sum;\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            sum = 0;\\n            for(int j = 0; j < n; j++){\\n                sum += grid[j][i];\\n            }\\n            mp1[i] = sum;\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                v[i][j] = mp[i] + mp1[j] - (n - mp[i]) - (m - mp1[j]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851410,
                "title": "java-easy-100",
                "content": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int onerow[] = new int[grid.length];\\n        int onecol[] = new int[grid[0].length];\\n        int mat[][] = new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    onerow[i]++;\\n            }\\n            //System.out.println(\"row: \"+onerow[i]);\\n        }\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                if(grid[j][i]==1)\\n                    onecol[i]++;\\n            }\\n            //System.out.println(\"col: \"+onecol[i]);\\n        }\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                mat[i][j]=onerow[i]+onecol[j]-(grid.length-onerow[i])-(grid[0].length-onecol[j]);\\n            }\\n        }\\n        return mat;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int onerow[] = new int[grid.length];\\n        int onecol[] = new int[grid[0].length];\\n        int mat[][] = new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    onerow[i]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2851372,
                "title": "java-2-solutions-clean-and-simple",
                "content": "### **Please Upvote** :D\\n##### 1. Brute force solution:\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] diff = new int[m][n];\\n\\n        int[] zeroRows = new int[m];\\n        int[] zeroCols = new int[n];\\n        int[] oneRows = new int[m];\\n        int[] oneCols = new int[n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    oneRows[i]++;\\n                    oneCols[j]++;\\n                }\\n                else {\\n                    zeroRows[i]++;\\n                    zeroCols[j]++;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                diff[i][j] = oneRows[i] + oneCols[j] - zeroRows[i] - zeroCols[j];\\n            }\\n        }\\n\\n        return diff;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m + n)\\n```\\n##### 2. Extra space reduced:\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n\\n        int[] oneRows = new int[m];\\n        int[] oneCols = new int[n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    oneRows[i]++;\\n                    oneCols[j]++;\\n                }\\n            }\\n        }\\n\\n        int[][] diff = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // diff[i][j] = oneRows[i] + oneCols[j] - (m - oneRows[i]) - (n - oneCols[j]);\\n                diff[i][j] = 2 * (oneRows[i] + oneCols[j]) - m - n;\\n            }\\n        }\\n\\n        return diff;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m + n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] diff = new int[m][n];\\n\\n        int[] zeroRows = new int[m];\\n        int[] zeroCols = new int[n];\\n        int[] oneRows = new int[m];\\n        int[] oneCols = new int[n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    oneRows[i]++;\\n                    oneCols[j]++;\\n                }\\n                else {\\n                    zeroRows[i]++;\\n                    zeroCols[j]++;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                diff[i][j] = oneRows[i] + oneCols[j] - zeroRows[i] - zeroCols[j];\\n            }\\n        }\\n\\n        return diff;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m + n)\\n```\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n\\n        int[] oneRows = new int[m];\\n        int[] oneCols = new int[n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    oneRows[i]++;\\n                    oneCols[j]++;\\n                }\\n            }\\n        }\\n\\n        int[][] diff = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // diff[i][j] = oneRows[i] + oneCols[j] - (m - oneRows[i]) - (n - oneCols[j]);\\n                diff[i][j] = 2 * (oneRows[i] + oneCols[j]) - m - n;\\n            }\\n        }\\n\\n        return diff;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m + n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851174,
                "title": "c-easy-solution-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& arr) {\\n        vector<pair<int,int>>row(arr.size(),{0,0}),col(arr[0].size(),{0,0});\\n\\t\\t\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                if(arr[i][j]==1)row[i].first++,col[j].first++;\\n                else row[i].second++,col[j].second++;\\n            }            \\n        }\\n\\t\\t\\n        vector<vector<int>>ans;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                arr[i][j]=row[i].first +col[j].first -row[i].second -col[j].second;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& arr) {\\n        vector<pair<int,int>>row(arr.size(),{0,0}),col(arr[0].size(),{0,0});\\n\\t\\t\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                if(arr[i][j]==1)row[i].first++,col[j].first++;\\n                else row[i].second++,col[j].second++;\\n            }            \\n        }\\n\\t\\t\\n        vector<vector<int>>ans;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                arr[i][j]=row[i].first +col[j].first -row[i].second -col[j].second;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850937,
                "title": "compute-row-and-column-one-count-only",
                "content": "num of zero in any column = size of row - num of one in that column\\nlikewise for row as well\\n\\nrone + cone + rzero + czero = rone + cone + n-rone + m-cone\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = 2(rone + cone) - (n + m)\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<int>rowOnes(grid.size(), 0);\\n        vector<int>colOnes(grid[0].size(), 0);\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                rowOnes[i] += grid[i][j];\\n                colOnes[j] += grid[i][j];\\n            }\\n        }\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                grid[i][j] = 2*(rowOnes[i]+colOnes[j])-(grid.size()+grid[0].size());\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<int>rowOnes(grid.size(), 0);\\n        vector<int>colOnes(grid[0].size(), 0);\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                rowOnes[i] += grid[i][j];\\n                colOnes[j] += grid[i][j];\\n            }\\n        }\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                grid[i][j] = 2*(rowOnes[i]+colOnes[j])-(grid.size()+grid[0].size());\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850754,
                "title": "c-using-two-extra-arrays",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int N = size(grid), M = size(grid[0]);\\n        vector<int> r(N,0) , c(M,0);\\n        for(int i = 0; i < N; i++)\\n        {\\n            for(int j = 0; j < M; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    r[i]++;c[j]++;\\n                }\\n                else\\n                {\\n                    r[i]--;c[j]--;\\n                }\\n            }\\n        }\\n        vector<vector<int>> res(N,vector<int>(M,0));\\n        for(int i = 0; i < N; i++)\\n        {\\n            for(int j = 0; j < M; j++)\\n            {\\n                res[i][j] = r[i] + c[j];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int N = size(grid), M = size(grid[0]);\\n        vector<int> r(N,0) , c(M,0);\\n        for(int i = 0; i < N; i++)\\n        {\\n            for(int j = 0; j < M; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    r[i]++;c[j]++;\\n                }\\n                else\\n                {\\n                    r[i]--;c[j]--;\\n                }\\n            }\\n        }\\n        vector<vector<int>> res(N,vector<int>(M,0));\\n        for(int i = 0; i < N; i++)\\n        {\\n            for(int j = 0; j < M; j++)\\n            {\\n                res[i][j] = r[i] + c[j];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850718,
                "title": "python3-pre-count-sum-of-rows-and-columns",
                "content": "# Notes\\nonesRowi + onesColj - zerosRowi - zerosColj\\n\\nNumber of zeros in row is length of the row minus number od ones in the row.\\n\\n`grid[r][c]=onesR[r] + onesC[c] - (R-onesR[r]) - (C-onesC[c])`\\n`grid[r][c]=2*onesR[r] + 2*onesC[c] - R - C`\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m+n)\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        R,C=len(grid),len(grid[0])\\n        onesR,onesC=[0]*R,[0]*C\\n        for r in range(R):\\n            for c in range(C):\\n                onesR[r]+=grid[r][c]\\n                onesC[c]+=grid[r][c]\\n        for r in range(R):\\n            for c in range(C):\\n                grid[r][c]=2*onesR[r] + 2*onesC[c] - R - C\\n        return grid    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        R,C=len(grid),len(grid[0])\\n        onesR,onesC=[0]*R,[0]*C\\n        for r in range(R):\\n            for c in range(C):\\n                onesR[r]+=grid[r][c]\\n                onesC[c]+=grid[r][c]\\n        for r in range(R):\\n            for c in range(C):\\n                grid[r][c]=2*onesR[r] + 2*onesC[c] - R - C\\n        return grid    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850665,
                "title": "easy-python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        lis = [ [0]*len(grid[0]) for i in range(len(grid))]\\n        # grid1 = [ [0]*len(grid[0]) for i in range(len(grid))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 0:\\n                    grid[i][j] =-1\\n        \\n                \\n        \\n        \\n        rows = {}\\n        cols = {}\\n        ele = 0\\n        for i in range(len(grid)):\\n            rows[i] = sum(grid[i])\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if j not in cols:\\n                    cols[j] = grid[i][j] \\n                else:\\n                    cols[j] += grid[i][j] \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                ele = rows[i]+cols[j]\\n                lis[i][j] = ele\\n            \\n        return lis\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        lis = [ [0]*len(grid[0]) for i in range(len(grid))]\\n        # grid1 = [ [0]*len(grid[0]) for i in range(len(grid))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 0:\\n                    grid[i][j] =-1\\n        \\n                \\n        \\n        \\n        rows = {}\\n        cols = {}\\n        ele = 0\\n        for i in range(len(grid)):\\n            rows[i] = sum(grid[i])\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if j not in cols:\\n                    cols[j] = grid[i][j] \\n                else:\\n                    cols[j] += grid[i][j] \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                ele = rows[i]+cols[j]\\n                lis[i][j] = ele\\n            \\n        return lis\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850645,
                "title": "easy-to-understand-o-n-m",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> zero_row(n), zero_col(m);\\n        vector<int> one_row(n),one_col(m);\\n        for(int i =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 1) one_row[i]++, one_col[j]++;\\n                else zero_row[i]++,zero_col[j]++;\\n            }\\n        };\\n        for(int i= 0;i<n;i++){\\n            for(int j = 0;j<m;j++)grid[i][j] = one_row[i] + one_col[j] - zero_row[i] - zero_col[j];\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> zero_row(n), zero_col(m);\\n        vector<int> one_row(n),one_col(m);\\n        for(int i =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 1) one_row[i]++, one_col[j]++;\\n                else zero_row[i]++,zero_col[j]++;\\n            }\\n        };\\n        for(int i= 0;i<n;i++){\\n            for(int j = 0;j<m;j++)grid[i][j] = one_row[i] + one_col[j] - zero_row[i] - zero_col[j];\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850533,
                "title": "c-use-simple-formula",
                "content": "class Solution {\\npublic:\\n//     use simple formula\\n//     ans[i][j] = ((row[i]+col[j]) - (row_size-row[i]) - (col_size-col[j]))\\n//     where zerosRowi = row_size-row[i]\\n//     where zerosColj = col_size-col[j]\\n//     O(N*M) TIME\\n//     O(N + M) SPACE\\n\\n    \\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& g) {\\n        int row_size = g.size();\\n        int col_size = g[0].size();\\n        vector<vector<int>>ans(row_size , vector<int>(col_size,0));\\n        vector<int>row(row_size,0);   vector<int>col(col_size,0);\\n\\n        for(int i=0;i<row_size;i++) { // precalculation for ROWS\\n            int rc =0;\\n            for(int j=0;j<col_size;j++)\\n                rc += g[i][j];\\n            row[i] = rc;\\n        }\\n         for(int i=0;i<col_size;i++) { // precalculation for COLUMNS \\n            int cc =0;\\n            for(int j=0;j<row_size;j++)\\n                cc += g[j][i];\\n            col[i] = cc;\\n        }\\n        \\n        for(int i=0;i<row_size;i++) {\\n            for(int j=0;j<col_size;j++) {\\n                ans[i][j] = ((row[i]+col[j]) - (row_size-row[i]) - (col_size-col[j])); \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n//     use simple formula\\n//     ans[i][j] = ((row[i]+col[j]) - (row_size-row[i]) - (col_size-col[j]))\\n//     where zerosRowi = row_size-row[i]\\n//     where zerosColj = col_size-col[j]\\n//     O(N*M) TIME\\n//     O(N + M) SPACE\\n\\n    \\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& g) {\\n        int row_size = g.size();\\n        int col_size = g[0].size();\\n        vector<vector<int>>ans(row_size , vector<int>(col_size,0));\\n        vector<int>row(row_size,0);   vector<int>col(col_size,0);\\n\\n        for(int i=0;i<row_size;i++) { // precalculation for ROWS\\n            int rc =0;\\n            for(int j=0;j<col_size;j++)\\n                rc += g[i][j];\\n            row[i] = rc;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2850515,
                "title": "c-count-ones",
                "content": "```\\n    public int[][] OnesMinusZeros(int[][] grid) \\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n\\n        int[] countRowOnes = new int[m];\\n        int[] countColOnes = new int[n];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    countRowOnes[i]++;\\n                    countColOnes[j]++;\\n                }\\n            }\\n        }\\n\\n        int[][] result = new int[m][];\\n        for (int i = 0; i < m; i++)\\n        {\\n            result[i] = new int[n];\\n            for (int j = 0; j < n; j++)\\n            {\\n                result[i][j] = countRowOnes[i] + countColOnes[j] - (m - countRowOnes[i]) - (n - countColOnes[j]);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] OnesMinusZeros(int[][] grid) \\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n\\n        int[] countRowOnes = new int[m];\\n        int[] countColOnes = new int[n];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    countRowOnes[i]++;\\n                    countColOnes[j]++;\\n                }\\n            }\\n        }\\n\\n        int[][] result = new int[m][];\\n        for (int i = 0; i < m; i++)\\n        {\\n            result[i] = new int[n];\\n            for (int j = 0; j < n; j++)\\n            {\\n                result[i][j] = countRowOnes[i] + countColOnes[j] - (m - countRowOnes[i]) - (n - countColOnes[j]);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2850500,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        \\n        vector<int>oneRow,oneCol,zeroRow,zeroCol;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i =0;i<n;i++){\\n            int countZero =0;\\n            int countOne = 0;\\n            for(int j =0;j<m;j++){\\n                if(grid[i][j]==0){\\n                    countZero++;\\n                }\\n                if(grid[i][j]==1){\\n                    countOne++;\\n                }\\n            }\\n            oneRow.push_back(countOne);\\n            zeroRow.push_back(countZero);\\n        }\\n        \\n        for(int j =0;j<m;j++){\\n            int countZero =0;\\n            int countOne = 0;\\n            for(int i =0;i<n;i++){\\n                if(grid[i][j]==0){\\n                    countZero++;\\n                }\\n                if(grid[i][j]==1){\\n                    countOne++;\\n                }\\n            }\\n            oneCol.push_back(countOne);\\n            zeroCol.push_back(countZero);\\n        }\\n        \\n        // for(int i =0;i<oneCol.size();i++){\\n        //     cout<<oneRow[i]<<endl;\\n        //      cout<<oneCol[i]<<endl;\\n        //      cout<<zeroRow[i]<<endl;\\n        //      cout<<zeroCol[i]<<endl;\\n        // }\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                ans[i][j]=oneRow[i] + oneCol[j] - zeroRow[i] - zeroCol[j];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        \\n        vector<int>oneRow,oneCol,zeroRow,zeroCol;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i =0;i<n;i++){\\n            int countZero =0;\\n            int countOne = 0;\\n            for(int j =0;j<m;j++){\\n                if(grid[i][j]==0){\\n                    countZero++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2850487,
                "title": "c-do-as-told",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<int> rowo,colo,rowz,colz;\\n        for(int i=0;i<grid.size();i++){\\n            int z=0,o=0;\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0) z++;\\n                else o++;\\n            }\\n            rowo.push_back(o);\\n            rowz.push_back(z);\\n        }\\n        for(int i=0;i<grid[0].size();i++){\\n            int z=0,o=0;\\n            for(int j=0;j<grid.size();j++){\\n                if(grid[j][i]==0)z++;\\n                else o++;\\n            }\\n            colo.push_back(o);\\n            colz.push_back(z);\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                // cout<<rowz[i]<<\" \"<<colz[j]<<\"\\\\n\";\\n                grid[i][j] = rowo[i]+colo[j]-rowz[i]-colz[j];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<int> rowo,colo,rowz,colz;\\n        for(int i=0;i<grid.size();i++){\\n            int z=0,o=0;\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0) z++;\\n                else o++;\\n            }\\n            rowo.push_back(o);\\n            rowz.push_back(z);\\n        }\\n        for(int i=0;i<grid[0].size();i++){\\n            int z=0,o=0;\\n            for(int j=0;j<grid.size();j++){\\n                if(grid[j][i]==0)z++;\\n                else o++;\\n            }\\n            colo.push_back(o);\\n            colz.push_back(z);\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                // cout<<rowz[i]<<\" \"<<colz[j]<<\"\\\\n\";\\n                grid[i][j] = rowo[i]+colo[j]-rowz[i]-colz[j];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2850484,
                "title": "python-just-calculate",
                "content": "```python\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        diff = [[0]*w for _ in range(h)]\\n        \\n        onesRow, zerosRow = [0]*h, [0]*h\\n        onesCol, zerosCol = [0]*w, [0]*w\\n\\n        for i, row in enumerate(grid):\\n            onesRow[i] = sum(row)\\n            zerosRow[i] = len(row) - onesRow[i]\\n\\n        for x in range(w):\\n            ones = 0\\n            for y in range(h):\\n                ones += grid[y][x]\\n            onesCol[x] = ones\\n            zerosCol[x] = h - onesCol[x]\\n\\n        for y in range(h):\\n            for x in range(w):\\n                diff[y][x] = onesRow[y] + onesCol[x] - zerosRow[y] - zerosCol[x]\\n\\n        return diff\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        diff = [[0]*w for _ in range(h)]\\n        \\n        onesRow, zerosRow = [0]*h, [0]*h\\n        onesCol, zerosCol = [0]*w, [0]*w\\n\\n        for i, row in enumerate(grid):\\n            onesRow[i] = sum(row)\\n            zerosRow[i] = len(row) - onesRow[i]\\n\\n        for x in range(w):\\n            ones = 0\\n            for y in range(h):\\n                ones += grid[y][x]\\n            onesCol[x] = ones\\n            zerosCol[x] = h - onesCol[x]\\n\\n        for y in range(h):\\n            for x in range(w):\\n                diff[y][x] = onesRow[y] + onesCol[x] - zerosRow[y] - zerosCol[x]\\n\\n        return diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850473,
                "title": "c-solution",
                "content": "```\\npublic int[][] OnesMinusZeros(int[][] grid)\\n{\\n\\tvar m = grid.Length;\\n\\tvar n = grid[0].Length;\\n\\tvar onesRow = new int[m];\\n\\tvar onesCol = new int[n];\\n\\tvar zerosRow = new int[m];\\n\\tvar zerosCol = new int[n];\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tonesRow[i]++;\\n\\t\\t\\t\\tonesCol[j]++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tzerosRow[i]++;\\n\\t\\t\\t\\tzerosCol[j]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar result = new int[m][];\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tresult[i] = new int[n];\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tresult[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] OnesMinusZeros(int[][] grid)\\n{\\n\\tvar m = grid.Length;\\n\\tvar n = grid[0].Length;\\n\\tvar onesRow = new int[m];\\n\\tvar onesCol = new int[n];\\n\\tvar zerosRow = new int[m];\\n\\tvar zerosCol = new int[n];\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tonesRow[i]++;\\n\\t\\t\\t\\tonesCol[j]++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tzerosRow[i]++;\\n\\t\\t\\t\\tzerosCol[j]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar result = new int[m][];\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tresult[i] = new int[n];\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tresult[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2850471,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        vector<int> onesRow(rows, 0), onesCol(cols, 0);\\n        vector<int> zerosRow(rows, 0), zerosCol(cols, 0);\\n        for (int i=0; i<rows; i++) {\\n            for (int j=0; j<cols; j++) {\\n                if (grid[i][j] == 0) {\\n                    zerosRow[i]++;\\n                    zerosCol[j]++;\\n                } else {\\n                    onesRow[i]++;\\n                    onesCol[j]++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> diff(rows, vector<int>(cols, 0));\\n        for (int i=0; i<rows; i++) {\\n            for (int j=0; j<cols; j++) {\\n                diff[i][j] = onesRow[i]+onesCol[j]-zerosRow[i]-zerosCol[j];\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        vector<int> onesRow(rows, 0), onesCol(cols, 0);\\n        vector<int> zerosRow(rows, 0), zerosCol(cols, 0);\\n        for (int i=0; i<rows; i++) {\\n            for (int j=0; j<cols; j++) {\\n                if (grid[i][j] == 0) {\\n                    zerosRow[i]++;\\n                    zerosCol[j]++;\\n                } else {\\n                    onesRow[i]++;\\n                    onesCol[j]++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> diff(rows, vector<int>(cols, 0));\\n        for (int i=0; i<rows; i++) {\\n            for (int j=0; j<cols; j++) {\\n                diff[i][j] = onesRow[i]+onesCol[j]-zerosRow[i]-zerosCol[j];\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077537,
                "title": "python3-solution-with-using-simulation-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        rows = [0] * len(grid)\\n        cols = [0] * len(grid[0]) \\n\\n        diff = [[0 for j in range(len(cols))] for i in range(len(rows))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                rows[i] += grid[i][j] - abs(grid[i][j] - 1) # grid[i][j] for 1 val, abs(grid[i][j] - 1) for 0 zero value: example case: (1 - abs(1 - 1) = 0) - no modification for 1 value and (0 - abs(0 - 1) = -1) - modification\\n                cols[j] += grid[i][j] - abs(grid[i][j] - 1)\\n        \\n        diff = [[0 for j in range(len(cols))] for i in range(len(rows))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                diff[i][j] += rows[i] + cols[j]\\n        \\n        return diff\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        rows = [0] * len(grid)\\n        cols = [0] * len(grid[0]) \\n\\n        diff = [[0 for j in range(len(cols))] for i in range(len(rows))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                rows[i] += grid[i][j] - abs(grid[i][j] - 1) # grid[i][j] for 1 val, abs(grid[i][j] - 1) for 0 zero value: example case: (1 - abs(1 - 1) = 0) - no modification for 1 value and (0 - abs(0 - 1) = -1) - modification\\n                cols[j] += grid[i][j] - abs(grid[i][j] - 1)\\n        \\n        diff = [[0 for j in range(len(cols))] for i in range(len(rows))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                diff[i][j] += rows[i] + cols[j]\\n        \\n        return diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073783,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        grid_transpose = [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))]\\n\\n        count_ones_zeros_grid = []\\n        \\n        for r in range(len(grid)):\\n            c1 = grid[r].count(1)\\n            c0 = grid[r].count(0)\\n            count_ones_zeros_grid.append([c1,c0])\\n        \\n        count_ones_zeros_grid_transpose = []\\n        \\n        for r in range(len(grid_transpose)):\\n            c1 = grid_transpose[r].count(1)\\n            c0 = grid_transpose[r].count(0)\\n            count_ones_zeros_grid_transpose.append([c1,c0])\\n\\n        output = []\\n        vals = []\\n\\n        for one_grid, zero_grid in count_ones_zeros_grid:\\n            for one_grid_transpose, zero_grid_transpose in count_ones_zeros_grid_transpose:\\n                total = one_grid + one_grid_transpose - zero_grid - zero_grid_transpose\\n                vals.append(total)\\n\\n        step = len(grid[0])\\n        for r in range(0, len(vals), step):\\n            output.append(vals[r:r+step])\\n\\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        grid_transpose = [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))]\\n\\n        count_ones_zeros_grid = []\\n        \\n        for r in range(len(grid)):\\n            c1 = grid[r].count(1)\\n            c0 = grid[r].count(0)\\n            count_ones_zeros_grid.append([c1,c0])\\n        \\n        count_ones_zeros_grid_transpose = []\\n        \\n        for r in range(len(grid_transpose)):\\n            c1 = grid_transpose[r].count(1)\\n            c0 = grid_transpose[r].count(0)\\n            count_ones_zeros_grid_transpose.append([c1,c0])\\n\\n        output = []\\n        vals = []\\n\\n        for one_grid, zero_grid in count_ones_zeros_grid:\\n            for one_grid_transpose, zero_grid_transpose in count_ones_zeros_grid_transpose:\\n                total = one_grid + one_grid_transpose - zero_grid - zero_grid_transpose\\n                vals.append(total)\\n\\n        step = len(grid[0])\\n        for r in range(0, len(vals), step):\\n            output.append(vals[r:r+step])\\n\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071796,
                "title": "easy-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        d = []\\n        zero_row, one_row = [], []\\n        for i in range(m):\\n            zero_row += [grid[i].count(0)]\\n            one_row += [grid[i].count(1)]\\n\\n        trans = [[grid[i][j] for i in range(m)] for j in range(n)]\\n        zero_col, one_col = [], []\\n        for i in range(n):\\n            zero_col += [trans[i].count(0)]\\n            one_col += [trans[i].count(1)]    \\n\\n        for i in range(m) :\\n            temp = []\\n            for j in range(n) :                \\n                temp += [(one_row[i] + one_col[j] - zero_row[i] - zero_col[j])]\\n            d += [temp]\\n            \\n        return d \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        d = []\\n        zero_row, one_row = [], []\\n        for i in range(m):\\n            zero_row += [grid[i].count(0)]\\n            one_row += [grid[i].count(1)]\\n\\n        trans = [[grid[i][j] for i in range(m)] for j in range(n)]\\n        zero_col, one_col = [], []\\n        for i in range(n):\\n            zero_col += [trans[i].count(0)]\\n            one_col += [trans[i].count(1)]    \\n\\n        for i in range(m) :\\n            temp = []\\n            for j in range(n) :                \\n                temp += [(one_row[i] + one_col[j] - zero_row[i] - zero_col[j])]\\n            d += [temp]\\n            \\n        return d \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070760,
                "title": "easy-python-implementation-difference-between-ones-and-zeros-in-row-and-column",
                "content": "\\n# Complexity\\n- Time complexity and Space complexity:\\n$O(n*m)\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        oneRows = [0 for i in range(len(grid))]\\n        zeroRows = [0 for i in range(len(grid))]\\n        oneCols = [0 for i in range(len(grid[0]))]\\n        zeroCols = [0 for i in range(len(grid[0]))]\\n        diff = [[0 for i in range(len(oneCols))] for i in range(len(grid))]\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n\\n                if(grid[i][j] == 1):\\n                    oneRows[i] +=1\\n                    oneCols[j] +=1\\n                else:\\n                    zeroRows[i]+=1\\n                    zeroCols[j]+=1\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                diff[i][j]= oneRows[i]+ oneCols[j] - zeroRows[i] - zeroCols[j]\\n\\n\\n\\n\\n        return diff\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        oneRows = [0 for i in range(len(grid))]\\n        zeroRows = [0 for i in range(len(grid))]\\n        oneCols = [0 for i in range(len(grid[0]))]\\n        zeroCols = [0 for i in range(len(grid[0]))]\\n        diff = [[0 for i in range(len(oneCols))] for i in range(len(grid))]\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n\\n                if(grid[i][j] == 1):\\n                    oneRows[i] +=1\\n                    oneCols[j] +=1\\n                else:\\n                    zeroRows[i]+=1\\n                    zeroCols[j]+=1\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                diff[i][j]= oneRows[i]+ oneCols[j] - zeroRows[i] - zeroCols[j]\\n\\n\\n\\n\\n        return diff\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065295,
                "title": "easy-solution-93-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& v) {\\n        vector<vector<int>> p,pp;\\n        int n=v[0].size();\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            int c=0;\\n            for(int j=0; j<v[i].size(); j++)\\n            {\\n                if(v[i][j]==1)\\n                c++;\\n            }\\n            v[i].push_back(c);\\n        }\\n        vector<int> dd;\\n        for(int i=0; i<v[0].size()-1; i++)\\n        {\\n            int c=0;\\n            for(int j=0; j<v.size(); j++)\\n            {\\n                if(v[j][i]==1)\\n                c++;\\n            }\\n            dd.push_back(c);\\n        }\\n       \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            vector<int> ff;\\n            for(int j=0; j<v[i].size()-1; j++)\\n            {\\n                int d=v[i][n]+dd[j]-(n-v[i][n])-(v.size()-dd[j]);\\n                ff.push_back(d);\\n            }\\n            p.push_back(ff);\\n        }\\n        return p;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& v) {\\n        vector<vector<int>> p,pp;\\n        int n=v[0].size();\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            int c=0;\\n            for(int j=0; j<v[i].size(); j++)\\n            {\\n                if(v[i][j]==1)\\n                c++;\\n            }\\n            v[i].push_back(c);\\n        }\\n        vector<int> dd;\\n        for(int i=0; i<v[0].size()-1; i++)\\n        {\\n            int c=0;\\n            for(int j=0; j<v.size(); j++)\\n            {\\n                if(v[j][i]==1)\\n                c++;\\n            }\\n            dd.push_back(c);\\n        }\\n       \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            vector<int> ff;\\n            for(int j=0; j<v[i].size()-1; j++)\\n            {\\n                int d=v[i][n]+dd[j]-(n-v[i][n])-(v.size()-dd[j]);\\n                ff.push_back(d);\\n            }\\n            p.push_back(ff);\\n        }\\n        return p;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041690,
                "title": "understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply store the count of 1\\'s and 0\\'s for every row and every column\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrow0(n, 0) --> Here each index represents a row, row0[1] = x means 1th row has x 0\\'s\\ncol0(m, 0) --> Here each index represents a col, col0[1] = x means 1th col has x 0\\'s\\nSame goes for row1(n, 0) and col1(m, 0)\\nThey store their respective counts\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) + O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> row0(n, 0);\\n        vector<int> col0(m, 0);\\n        vector<int> row1(n, 0);\\n        vector<int> col1(m, 0);\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(grid[i][j] == 0) {\\n                    row0[i]++;\\n                    col0[j]++;\\n                    }else {\\n                     row1[i]++;\\n                     col1[j]++;\\n                   }\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                grid[i][j] = row1[i] + col1[j] - row0[i] - col0[j];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> row0(n, 0);\\n        vector<int> col0(m, 0);\\n        vector<int> row1(n, 0);\\n        vector<int> col1(m, 0);\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(grid[i][j] == 0) {\\n                    row0[i]++;\\n                    col0[j]++;\\n                    }else {\\n                     row1[i]++;\\n                     col1[j]++;\\n                   }\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                grid[i][j] = row1[i] + col1[j] - row0[i] - col0[j];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038397,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        ans=[[0 for i in range(len(grid[0]))] for i in range(len(grid))]\\n        row,col=[],[]\\n        for i in range(len(grid)):\\n            oR=zR=0\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1: oR+=1\\n                else: zR+=1\\n            row.append([oR,zR])\\n        for i in range(len(grid[0])):\\n            oC=zC=0\\n            for j in range(len(grid)):\\n                if grid[j][i]==1: oC+=1\\n                else: zC+=1\\n            col.append([oC,zC])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j]=row[i][0]+col[j][0]-row[i][1]-col[j][1]\\n        return grid\\n                \\n```\\n***Hope it helps...!!*** \\uD83D\\uDE07\\u270C\\uFE0F",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        ans=[[0 for i in range(len(grid[0]))] for i in range(len(grid))]\\n        row,col=[],[]\\n        for i in range(len(grid)):\\n            oR=zR=0\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1: oR+=1\\n                else: zR+=1\\n            row.append([oR,zR])\\n        for i in range(len(grid[0])):\\n            oC=zC=0\\n            for j in range(len(grid)):\\n                if grid[j][i]==1: oC+=1\\n                else: zC+=1\\n            col.append([oC,zC])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j]=row[i][0]+col[j][0]-row[i][1]-col[j][1]\\n        return grid\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035900,
                "title": "brute-force-c-solution-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore every row\\'s and column\\'s count of 1 and 0 in a 1D array .After that just do the normal calculation as given to find the val of index of diff matrix.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   O(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> r1 , r0 , c1 , c0 ; \\n        for(int i = 0 ; i<n ; i++){\\n            int cnt0 = 0 ; \\n            int cnt1  = 0 ;\\n            for(int j = 0 ; j<m ; j++){\\n                if(grid[i][j] == 1) cnt1++ ;\\n                else cnt0++ ;\\n            }\\n            r1.push_back(cnt1);\\n            r0.push_back(cnt0);\\n        }\\n        for(int i = 0 ; i<m ; i++){\\n            int cnt0 = 0 ; \\n            int cnt1  = 0 ;\\n            for(int j = 0 ; j<n ; j++){\\n                if(grid[j][i] == 1) cnt1++ ;\\n                else cnt0++ ;\\n            }\\n            c1.push_back(cnt1);\\n            c0.push_back(cnt0);\\n        }\\n        for(int i = 0 ; i<n ; i++){\\n            for(int j = 0 ; j<m ; j++){\\n                int val = r1[i] + c1[j] - r0[i] - c0[j] ;\\n                grid[i][j] = val ;\\n            }\\n        }\\n        return grid ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> r1 , r0 , c1 , c0 ; \\n        for(int i = 0 ; i<n ; i++){\\n            int cnt0 = 0 ; \\n            int cnt1  = 0 ;\\n            for(int j = 0 ; j<m ; j++){\\n                if(grid[i][j] == 1) cnt1++ ;\\n                else cnt0++ ;\\n            }\\n            r1.push_back(cnt1);\\n            r0.push_back(cnt0);\\n        }\\n        for(int i = 0 ; i<m ; i++){\\n            int cnt0 = 0 ; \\n            int cnt1  = 0 ;\\n            for(int j = 0 ; j<n ; j++){\\n                if(grid[j][i] == 1) cnt1++ ;\\n                else cnt0++ ;\\n            }\\n            c1.push_back(cnt1);\\n            c0.push_back(cnt0);\\n        }\\n        for(int i = 0 ; i<n ; i++){\\n            for(int j = 0 ; j<m ; j++){\\n                int val = r1[i] + c1[j] - r0[i] - c0[j] ;\\n                grid[i][j] = val ;\\n            }\\n        }\\n        return grid ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035289,
                "title": "east-and-short-cpp-solution-for-beginner",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> r(n, 0), c(m, 0);\\n        for(int i=0;i<n;i++){\\n            int temp=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    temp++;\\n                }\\n            }\\n            r[i]=temp;\\n        }\\n        for(int i=0;i<m;i++){\\n            int temp=0;\\n            for(int j=0;j<n;j++){\\n                if(grid[j][i]==1){\\n                    temp++;\\n                }\\n            }\\n            c[i]=temp;\\n        }\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        for(int i=0;i<n;i++){\\n            cout<<r[i]<<\"  \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<m;i++){\\n            cout<<c[i]<<\" \";\\n        }\\n        cout<<endl;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans[i][j]=r[i]+c[j]-(n-r[i])-(m-c[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> r(n, 0), c(m, 0);\\n        for(int i=0;i<n;i++){\\n            int temp=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    temp++;\\n                }\\n            }\\n            r[i]=temp;\\n        }\\n        for(int i=0;i<m;i++){\\n            int temp=0;\\n            for(int j=0;j<n;j++){\\n                if(grid[j][i]==1){\\n                    temp++;\\n                }\\n            }\\n            c[i]=temp;\\n        }\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        for(int i=0;i<n;i++){\\n            cout<<r[i]<<\"  \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<m;i++){\\n            cout<<c[i]<<\" \";\\n        }\\n        cout<<endl;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans[i][j]=r[i]+c[j]-(n-r[i])-(m-c[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4035121,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n\\n    vector<int> onesRow(m, 0);\\n    vector<int> onesCol(n, 0);\\n    vector<int> zerosRow(m, 0);\\n    vector<int> zerosCol(n, 0);\\n\\n    // Calculate the counts\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] == 1) {\\n                onesRow[i]++;\\n                onesCol[j]++;\\n            } else {\\n                zerosRow[i]++;\\n                zerosCol[j]++;\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> diff(m, vector<int>(n, 0));\\n\\n    // Calculate the difference\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j];\\n        }\\n    }\\n\\n    return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n\\n    vector<int> onesRow(m, 0);\\n    vector<int> onesCol(n, 0);\\n    vector<int> zerosRow(m, 0);\\n    vector<int> zerosCol(n, 0);\\n\\n    // Calculate the counts\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] == 1) {\\n                onesRow[i]++;\\n                onesCol[j]++;\\n            } else {\\n                zerosRow[i]++;\\n                zerosCol[j]++;\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> diff(m, vector<int>(n, 0));\\n\\n    // Calculate the difference\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j];\\n        }\\n    }\\n\\n    return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030667,
                "title": "c-simple-easy-beats-100",
                "content": "# Approach\\n- Create 2 arrays each to store the sum of all rows and columns.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> row(m, 0);\\n        vector<int> col(n, 0);\\n        vector<vector<int>> diff(m, vector<int>(n, 0));\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n                else{\\n                    row[i]--;\\n                    col[j]--;\\n                }\\n            }\\n        }\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                diff[i][j] = row[i] + col[j]; \\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> row(m, 0);\\n        vector<int> col(n, 0);\\n        vector<vector<int>> diff(m, vector<int>(n, 0));\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n                else{\\n                    row[i]--;\\n                    col[j]--;\\n                }\\n            }\\n        }\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                diff[i][j] = row[i] + col[j]; \\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021383,
                "title": "straight-forward-solution-beats-100-space",
                "content": "# Complexity\\n- Time complexity:\\nBeats 93.48%\\n\\n- Space complexity:\\nBeats 100% \\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[][]}\\n */\\nvar onesMinusZeros = function (grid) {\\n\\n    const rowLen = grid.length\\n    const colLen = grid[0].length\\n\\n    let rowOnes = new Array(rowLen).fill(0)\\n    let columnOnes = new Array(colLen).fill(0)\\n\\n    for (let i = 0; i < rowLen; i++) {\\n        for (let j = 0; j < colLen; j++) {\\n            rowOnes[i] += grid[i][j]\\n            columnOnes[j] += grid[i][j]\\n        }\\n    }\\n\\n    for (let i = 0; i < rowLen; i++) {\\n        for (let j = 0; j < colLen; j++) {\\n            grid[i][j] = rowOnes[i] + columnOnes[j] - (rowLen - rowOnes[i]) - (colLen - columnOnes[j])\\n        }\\n        \\n    }\\n\\n    return grid\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[][]}\\n */\\nvar onesMinusZeros = function (grid) {\\n\\n    const rowLen = grid.length\\n    const colLen = grid[0].length\\n\\n    let rowOnes = new Array(rowLen).fill(0)\\n    let columnOnes = new Array(colLen).fill(0)\\n\\n    for (let i = 0; i < rowLen; i++) {\\n        for (let j = 0; j < colLen; j++) {\\n            rowOnes[i] += grid[i][j]\\n            columnOnes[j] += grid[i][j]\\n        }\\n    }\\n\\n    for (let i = 0; i < rowLen; i++) {\\n        for (let j = 0; j < colLen; j++) {\\n            grid[i][j] = rowOnes[i] + columnOnes[j] - (rowLen - rowOnes[i]) - (colLen - columnOnes[j])\\n        }\\n        \\n    }\\n\\n    return grid\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009730,
                "title": "beats-94-43-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n178ms\\nBeats 94.43%of users with C++\\n\\n- Space complexity:\\n114.48MB\\nBeats 99.40%of users with C++\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        std::vector <std::vector <int>> ans = grid;\\n        int counter = 0;\\n        const size_t n = grid.size();\\n        const size_t m = grid[0].size();\\n        for (size_t i = 0; i != n; ++i) {\\n            for (size_t j = 0; j != m; ++j) {\\n                if (grid[i][j] == 0) {\\n                    counter--;\\n                }\\n                else {\\n                    counter++;\\n                }\\n            }\\n            for (size_t j = 0; j != m; ++j) {\\n                ans[i][j] = counter;\\n            }\\n            counter = 0;\\n        }\\n\\n        for (size_t i = 0; i != m; ++i) {\\n            for (size_t j = 0; j != n; ++j) {\\n                if (grid[j][i] == 0) {\\n                    counter--;\\n                }\\n                else {\\n                    counter++;\\n                }\\n            }\\n            for (size_t j = 0; j != n; ++j) {\\n                ans[j][i] = counter + ans[j][i];\\n            }\\n            counter = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        std::vector <std::vector <int>> ans = grid;\\n        int counter = 0;\\n        const size_t n = grid.size();\\n        const size_t m = grid[0].size();\\n        for (size_t i = 0; i != n; ++i) {\\n            for (size_t j = 0; j != m; ++j) {\\n                if (grid[i][j] == 0) {\\n                    counter--;\\n                }\\n                else {\\n                    counter++;\\n                }\\n            }\\n            for (size_t j = 0; j != m; ++j) {\\n                ans[i][j] = counter;\\n            }\\n            counter = 0;\\n        }\\n\\n        for (size_t i = 0; i != m; ++i) {\\n            for (size_t j = 0; j != n; ++j) {\\n                if (grid[j][i] == 0) {\\n                    counter--;\\n                }\\n                else {\\n                    counter++;\\n                }\\n            }\\n            for (size_t j = 0; j != n; ++j) {\\n                ans[j][i] = counter + ans[j][i];\\n            }\\n            counter = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997632,
                "title": "easy-c-solution-simple-approach-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size() , n = grid[0].size() ;\\n        vector<int>R(m,0);    \\n        vector<int>C(n,0);\\n\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    R[i]+= 2 ;\\n                    C[j]+= 2 ;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>>mat(m,vector<int>(n,0));\\n\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                mat[i][j] = R[i]+C[j] -m-n ;\\n            }\\n        }\\n        return mat;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size() , n = grid[0].size() ;\\n        vector<int>R(m,0);    \\n        vector<int>C(n,0);\\n\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    R[i]+= 2 ;\\n                    C[j]+= 2 ;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>>mat(m,vector<int>(n,0));\\n\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                mat[i][j] = R[i]+C[j] -m-n ;\\n            }\\n        }\\n        return mat;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991395,
                "title": "simple-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncalculate row-wise sum and store in vector of size n(no. of row)\\nsame for col-wise\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    TC - 0(n*m) where n = no. of row and m = no. of cols\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    SC - 0(n+m);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> row;\\n        vector<int> col;\\n        for(int i = 0;i<n;i++){\\n            int sum = 0;\\n            for(int j = 0;j<m;j++){\\n                sum+=grid[i][j];\\n            }\\n            row.push_back(sum);\\n        }\\n        for(int i = 0;i<m;i++){\\n            int sum = 0;\\n            for(int j = 0;j<n;j++){\\n                sum+=grid[j][i];\\n            }\\n            col.push_back(sum);\\n        }\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                grid[i][j] = row[i]+col[j] -(n-row[i])-(m-col[j]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> row;\\n        vector<int> col;\\n        for(int i = 0;i<n;i++){\\n            int sum = 0;\\n            for(int j = 0;j<m;j++){\\n                sum+=grid[i][j];\\n            }\\n            row.push_back(sum);\\n        }\\n        for(int i = 0;i<m;i++){\\n            int sum = 0;\\n            for(int j = 0;j<n;j++){\\n                sum+=grid[j][i];\\n            }\\n            col.push_back(sum);\\n        }\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                grid[i][j] = row[i]+col[j] -(n-row[i])-(m-col[j]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975892,
                "title": "java-m-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int row[]   = new int [grid.length] , col[]  =  new int [grid[0].length] ;\\n        int m = grid.length , n = grid[0].length ; \\n        for( int  i = 0 ; i < m ; i++){\\n            for( int j = 0 ; j < n ;j++){\\n                if(grid[i][j] == 1){\\n                    row[i]++;col[j]++;\\n                }\\n            }\\n        } \\n        \\n        int[][] diff = new int[m][n];\\n        for( int  i = 0 ; i < m ; i++){\\n            for( int j = 0 ; j < n ;j++){\\n                diff[i][j] = row[i] + col[j] - (n-row[i] ) -  (m - col[j]);\\n            }\\n        }\\n        return diff;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int row[]   = new int [grid.length] , col[]  =  new int [grid[0].length] ;\\n        int m = grid.length , n = grid[0].length ; \\n        for( int  i = 0 ; i < m ; i++){\\n            for( int j = 0 ; j < n ;j++){\\n                if(grid[i][j] == 1){\\n                    row[i]++;col[j]++;\\n                }\\n            }\\n        } \\n        \\n        int[][] diff = new int[m][n];\\n        for( int  i = 0 ; i < m ; i++){\\n            for( int j = 0 ; j < n ;j++){\\n                diff[i][j] = row[i] + col[j] - (n-row[i] ) -  (m - col[j]);\\n            }\\n        }\\n        return diff;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966642,
                "title": "python-easy-for-beginers",
                "content": "# easiest python solution \\n**brute force method**\\n```\\nclass Solution(object):\\n    def onesMinusZeros(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        m = len(grid)\\n        n = len(grid[0])\\n        diff = [[0]*n for i in range(m)]\\n        \\n        onesrow = [0]*m\\n        onescol = [0]*n\\n        zerosrow = [0]*m\\n        zeroscol = [0]*n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    onesrow[i] += 1\\n                    onescol[j] += 1\\n                else:\\n                    zerosrow[i] += 1\\n                    zeroscol[j] += 1\\n        for i in range(m):\\n            for j in range(n):\\n                diff[i][j] = onesrow[i] + onescol[j] - zerosrow[i] - zeroscol[j]\\n        return diff\\n                    \\n                \\n        \\n```\\n# please upvote\\n![image](https://assets.leetcode.com/users/images/9c843e31-e908-492a-bdd8-c492623b2213_1693128879.2808256.jpeg)\\n\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution(object):\\n    def onesMinusZeros(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        m = len(grid)\\n        n = len(grid[0])\\n        diff = [[0]*n for i in range(m)]\\n        \\n        onesrow = [0]*m\\n        onescol = [0]*n\\n        zerosrow = [0]*m\\n        zeroscol = [0]*n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    onesrow[i] += 1\\n                    onescol[j] += 1\\n                else:\\n                    zerosrow[i] += 1\\n                    zeroscol[j] += 1\\n        for i in range(m):\\n            for j in range(n):\\n                diff[i][j] = onesrow[i] + onescol[j] - zerosrow[i] - zeroscol[j]\\n        return diff\\n                    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963058,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<vector<int>> row;\\n        vector<vector<int>> col;\\n        for(int r=0;r<grid.size();r++)\\n        {\\n            vector<int> v;\\n            int z=0,one=0;\\n            for(int c=0;c<grid[0].size();c++)\\n            {\\n                if(grid[r][c]==0)\\n                    z++;\\n                else\\n                    one++;\\n            }\\n            v.push_back(z);\\n            v.push_back(one);\\n            cout<<r<<\" \"<<z<<one<<endl;\\n            row.push_back(v);\\n        }\\n        for(int c=0;c<grid[0].size();c++)\\n        {\\n            vector<int> v;\\n            int z=0,one=0;\\n            for(int r=0;r<grid.size();r++)\\n            {\\n                if(grid[r][c]==0)\\n                    z++;\\n                else\\n                    one++;\\n            }\\n            v.push_back(z);\\n            v.push_back(one);\\n            cout<<c<<\" \"<<z<<one<<endl;\\n            col.push_back(v);\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n                grid[i][j]=row[i][1]+col[j][1]-row[i][0]-col[j][0];\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<vector<int>> row;\\n        vector<vector<int>> col;\\n        for(int r=0;r<grid.size();r++)\\n        {\\n            vector<int> v;\\n            int z=0,one=0;\\n            for(int c=0;c<grid[0].size();c++)\\n            {\\n                if(grid[r][c]==0)\\n                    z++;\\n                else\\n                    one++;\\n            }\\n            v.push_back(z);\\n            v.push_back(one);\\n            cout<<r<<\" \"<<z<<one<<endl;\\n            row.push_back(v);\\n        }\\n        for(int c=0;c<grid[0].size();c++)\\n        {\\n            vector<int> v;\\n            int z=0,one=0;\\n            for(int r=0;r<grid.size();r++)\\n            {\\n                if(grid[r][c]==0)\\n                    z++;\\n                else\\n                    one++;\\n            }\\n            v.push_back(z);\\n            v.push_back(one);\\n            cout<<c<<\" \"<<z<<one<<endl;\\n            col.push_back(v);\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n                grid[i][j]=row[i][1]+col[j][1]-row[i][0]-col[j][0];\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3955877,
                "title": "java-solution-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int[] row = new int[grid.length];\\n        int[] col = new int[grid[0].length];\\n\\n        for(int i = 0 ; i < grid.length; i++){\\n            int count = 0;\\n\\n            for(int j = 0; j < grid[0].length; j++)\\n                if(grid[i][j] == 1)\\n                    count++;\\n            \\n            row[i] = count;\\n        }\\n\\n        for(int j = 0 ; j < grid[0].length; j++){\\n            int count = 0;\\n\\n            for(int i = 0; i < grid.length; i++)\\n                if(grid[i][j] == 1)\\n                    count++;\\n            \\n            col[j] = count;\\n        }\\n\\n        int[][] diff = new int[row.length][col.length];\\n\\n        for(int i = 0; i < row.length; i++)\\n            for(int j = 0; j < col.length; j++)\\n                diff[i][j] = row[i] + col[j] - row.length + row[i] - col.length + col[j];\\n\\n        return diff;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int[] row = new int[grid.length];\\n        int[] col = new int[grid[0].length];\\n\\n        for(int i = 0 ; i < grid.length; i++){\\n            int count = 0;\\n\\n            for(int j = 0; j < grid[0].length; j++)\\n                if(grid[i][j] == 1)\\n                    count++;\\n            \\n            row[i] = count;\\n        }\\n\\n        for(int j = 0 ; j < grid[0].length; j++){\\n            int count = 0;\\n\\n            for(int i = 0; i < grid.length; i++)\\n                if(grid[i][j] == 1)\\n                    count++;\\n            \\n            col[j] = count;\\n        }\\n\\n        int[][] diff = new int[row.length][col.length];\\n\\n        for(int i = 0; i < row.length; i++)\\n            for(int j = 0; j < col.length; j++)\\n                diff[i][j] = row[i] + col[j] - row.length + row[i] - col.length + col[j];\\n\\n        return diff;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947583,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe calculate the total counts of ones and zeros for each row and column separately, and store them in arrays (oneRowCounts, zeroRowCounts, oneColCounts, zeroColCounts).\\nThen, we use these precalculated totals to directly compute the difference for each cell in the diff array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        int[] oneRowCounts = new int[rows];\\n        int[] zeroRowCounts = new int[rows];\\n        \\n        int[] oneColCounts = new int[cols];\\n        int[] zeroColCounts = new int[cols];\\n        \\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 1) {\\n                    oneRowCounts[i]++;\\n                    oneColCounts[j]++;\\n                } else if (grid[i][j] == 0) {\\n                    zeroRowCounts[i]++;\\n                    zeroColCounts[j]++;\\n                }\\n            }\\n        }\\n\\n        int[][] diff = new int[rows][cols];\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                diff[i][j] = (oneRowCounts[i] + oneColCounts[j]) - (zeroRowCounts[i] + zeroColCounts[j]);\\n            }\\n        }\\n\\n        return diff;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        int[] oneRowCounts = new int[rows];\\n        int[] zeroRowCounts = new int[rows];\\n        \\n        int[] oneColCounts = new int[cols];\\n        int[] zeroColCounts = new int[cols];\\n        \\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 1) {\\n                    oneRowCounts[i]++;\\n                    oneColCounts[j]++;\\n                } else if (grid[i][j] == 0) {\\n                    zeroRowCounts[i]++;\\n                    zeroColCounts[j]++;\\n                }\\n            }\\n        }\\n\\n        int[][] diff = new int[rows][cols];\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                diff[i][j] = (oneRowCounts[i] + oneColCounts[j]) - (zeroRowCounts[i] + zeroColCounts[j]);\\n            }\\n        }\\n\\n        return diff;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947430,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int r1[]=new int[n];\\n        int r0[]=new int[n];\\n        int c1[]=new int[m];\\n        int c0[]=new int[m];\\n        int o=0;\\n        int z=0;\\n        for(int i=0;i<n;i++){\\n            o=0;\\n            z=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==0){\\n                    z++;\\n                }else{\\n                    o++;\\n                }\\n            }\\n            r1[i]=o;\\n            r0[i]=z;\\n        }\\n        for(int i=0;i<m;i++){\\n            o=0;\\n            z=0;\\n            for(int j=0;j<n;j++){\\n                if(grid[j][i]==0){\\n                    z++;\\n                }else{\\n                    o++;\\n                }\\n            }\\n            c1[i]=o;\\n            c0[i]=z;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j]=r1[i]+c1[j]-r0[i]-c0[j];\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int r1[]=new int[n];\\n        int r0[]=new int[n];\\n        int c1[]=new int[m];\\n        int c0[]=new int[m];\\n        int o=0;\\n        int z=0;\\n        for(int i=0;i<n;i++){\\n            o=0;\\n            z=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==0){\\n                    z++;\\n                }else{\\n                    o++;\\n                }\\n            }\\n            r1[i]=o;\\n            r0[i]=z;\\n        }\\n        for(int i=0;i<m;i++){\\n            o=0;\\n            z=0;\\n            for(int j=0;j<n;j++){\\n                if(grid[j][i]==0){\\n                    z++;\\n                }else{\\n                    o++;\\n                }\\n            }\\n            c1[i]=o;\\n            c0[i]=z;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j]=r1[i]+c1[j]-r0[i]-c0[j];\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947063,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        x=[]\\n        y=[]\\n        z=[]\\n        for i in range(0,len(grid)) :\\n            x.append([])\\n            z.append([])\\n        for i in range(0,len(grid[0])) :\\n            y.append([])\\n        for i in range(0,len(grid)) :\\n            x[i].append(grid[i].count(1))\\n            x[i].append(grid[i].count(0))\\n        for i in range(0,len(grid[0])) :\\n            m=n=0\\n            for j in range(0,len(grid)) :\\n                if grid[j][i] == 1:\\n                    m+=1\\n                else :\\n                    n+=1\\n            y[i].append(m)\\n            y[i].append(n)\\n        for i in range(0,len(grid))  :\\n            for j in range(0,len(grid[0])) :\\n                z[i].append(x[i][0]+y[j][0]-x[i][1]-y[j][1])\\n        return z\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        x=[]\\n        y=[]\\n        z=[]\\n        for i in range(0,len(grid)) :\\n            x.append([])\\n            z.append([])\\n        for i in range(0,len(grid[0])) :\\n            y.append([])\\n        for i in range(0,len(grid)) :\\n            x[i].append(grid[i].count(1))\\n            x[i].append(grid[i].count(0))\\n        for i in range(0,len(grid[0])) :\\n            m=n=0\\n            for j in range(0,len(grid)) :\\n                if grid[j][i] == 1:\\n                    m+=1\\n                else :\\n                    n+=1\\n            y[i].append(m)\\n            y[i].append(n)\\n        for i in range(0,len(grid))  :\\n            for j in range(0,len(grid[0])) :\\n                z[i].append(x[i][0]+y[j][0]-x[i][1]-y[j][1])\\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946438,
                "title": "java-beats-100-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int[][] onesMinusZeros(int[][] grid) {\\n\\t        int r=grid.length;\\n\\t        int c=grid[0].length;\\n\\t       \\n\\t       int onesRow[]=new int[r];\\n\\t       int onesCol[]=new int[c];\\n\\t       //row\\n\\t       for(int i=0;i<r;i++) {\\n\\t    \\t   int count=0;\\n\\t    \\t   for(int j=0;j<c;j++) {\\n\\t    \\t\\t   count+=grid[i][j];\\n\\t    \\t   }\\n\\t    \\t   onesRow[i]=count;\\n\\t       }\\n\\t       \\n\\t       //col\\n\\t       \\n\\t       for(int j=0;j<c;j++) {\\n\\t    \\t   int count=0;\\n\\t    \\t   for(int i=0;i<r;i++) {\\n\\t    \\t\\t   count+=grid[i][j];\\n\\t    \\t   }\\n\\t    \\t   onesCol[j]=count;   \\n\\t       }\\n\\t       \\n\\t       //diff\\n\\t\\t\\t\\t \\n\\t       for(int i=0;i<r;i++) {\\n\\t    \\t   for(int j=0;j<c;j++) {\\n\\t    \\t\\t  grid[i][j]=2*(onesRow[i]+onesCol[j])-(r+c);\\n\\t    \\t   }\\n\\t       }\\n\\t       return grid;\\n\\t    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int[][] onesMinusZeros(int[][] grid) {\\n\\t        int r=grid.length;\\n\\t        int c=grid[0].length;\\n\\t       \\n\\t       int onesRow[]=new int[r];\\n\\t       int onesCol[]=new int[c];\\n\\t       //row\\n\\t       for(int i=0;i<r;i++) {\\n\\t    \\t   int count=0;\\n\\t    \\t   for(int j=0;j<c;j++) {\\n\\t    \\t\\t   count+=grid[i][j];\\n\\t    \\t   }\\n\\t    \\t   onesRow[i]=count;\\n\\t       }\\n\\t       \\n\\t       //col\\n\\t       \\n\\t       for(int j=0;j<c;j++) {\\n\\t    \\t   int count=0;\\n\\t    \\t   for(int i=0;i<r;i++) {\\n\\t    \\t\\t   count+=grid[i][j];\\n\\t    \\t   }\\n\\t    \\t   onesCol[j]=count;   \\n\\t       }\\n\\t       \\n\\t       //diff\\n\\t\\t\\t\\t \\n\\t       for(int i=0;i<r;i++) {\\n\\t    \\t   for(int j=0;j<c;j++) {\\n\\t    \\t\\t  grid[i][j]=2*(onesRow[i]+onesCol[j])-(r+c);\\n\\t    \\t   }\\n\\t       }\\n\\t       return grid;\\n\\t    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944857,
                "title": "come-to-dadddyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        row=[]\\n        col=[]\\n        for j in range(0,len(grid[0])):\\n            c1=0\\n            for i in range(0,len(grid)):\\n                c1 = c1 + grid[i][j]\\n            c0 = len(grid)-c1\\n            col.append([c1,c0])\\n        for i in grid:\\n            r1=sum(i)\\n            r0=len(i)-r1\\n            row.append([r1,r0])\\n        final=[]\\n        for i in row:\\n            arr=[]\\n            for j in col:\\n                arr.append(i[0]+j[0]-i[1]-j[1])\\n            final.append(arr)\\n        return final\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        row=[]\\n        col=[]\\n        for j in range(0,len(grid[0])):\\n            c1=0\\n            for i in range(0,len(grid)):\\n                c1 = c1 + grid[i][j]\\n            c0 = len(grid)-c1\\n            col.append([c1,c0])\\n        for i in grid:\\n            r1=sum(i)\\n            r0=len(i)-r1\\n            row.append([r1,r0])\\n        final=[]\\n        for i in row:\\n            arr=[]\\n            for j in col:\\n                arr.append(i[0]+j[0]-i[1]-j[1])\\n            final.append(arr)\\n        return final\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941191,
                "title": "runtime-beats-92-golang",
                "content": "# Intuition\\nRow and column sums can be reused for each grid item. We go through and calculate the row and column sums, then index the grid cells by the sum of its row and col.\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(mn)\\n\\n\\n# Code\\n```\\nfunc onesMinusZeros(grid [][]int) [][]int {\\n    r, c := len(grid), len(grid[0])\\n    diff := make([][]int,r)\\n    for i:=0; i<len(grid); i++ {\\n        diff[i] = make([]int, c)\\n    }\\n    var row_sums []int\\n    var col_sums []int\\n    for _,v := range(grid) {\\n        row_sum := 0\\n        for _,w := range(v) {\\n            if w == 0{\\n                row_sum -= 1\\n            } else {\\n                row_sum += 1\\n            }\\n        }\\n        row_sums = append(row_sums, row_sum)\\n    }\\n\\n    for i:=0;i<c;i++{\\n        col_sum := 0\\n        for _,w := range(grid) {\\n            if w[i] == 0{\\n                col_sum -= 1\\n            } else {\\n                col_sum += 1\\n            }\\n        }\\n        col_sums = append(col_sums, col_sum)\\n    }\\n\\n    for i,v := range(diff){\\n        for j,_ := range(v){\\n            v[j] = row_sums[i]+col_sums[j]\\n        }\\n    }\\n    return diff\\n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc onesMinusZeros(grid [][]int) [][]int {\\n    r, c := len(grid), len(grid[0])\\n    diff := make([][]int,r)\\n    for i:=0; i<len(grid); i++ {\\n        diff[i] = make([]int, c)\\n    }\\n    var row_sums []int\\n    var col_sums []int\\n    for _,v := range(grid) {\\n        row_sum := 0\\n        for _,w := range(v) {\\n            if w == 0{\\n                row_sum -= 1\\n            } else {\\n                row_sum += 1\\n            }\\n        }\\n        row_sums = append(row_sums, row_sum)\\n    }\\n\\n    for i:=0;i<c;i++{\\n        col_sum := 0\\n        for _,w := range(grid) {\\n            if w[i] == 0{\\n                col_sum -= 1\\n            } else {\\n                col_sum += 1\\n            }\\n        }\\n        col_sums = append(col_sums, col_sum)\\n    }\\n\\n    for i,v := range(diff){\\n        for j,_ := range(v){\\n            v[j] = row_sums[i]+col_sums[j]\\n        }\\n    }\\n    return diff\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935847,
                "title": "cpp-solution",
                "content": "# Intuition\\nJust count the zeros and ones and store them, and use the data to build the answer;\\n\\n# Approach\\n1. Create 4 arrays\\n2. Iterate through grid and if the element is zero then increment zero\\'s arrat else increment one\\'s array\\n3. Build the answer based on the stored data\\n4. return answer\\n\\n# Complexity\\n- Time complexity:\\n2(O(n^2))\\n\\n- Space complexity:\\n2(O(n))X2(O(n^2))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> oneRows(n), oneCols(m), zeroRows(n), zeroCols(m);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    oneRows[i]++;\\n                    oneCols[j]++;\\n                }\\n                if(!grid[i][j])\\n                {\\n                    zeroRows[i]++;\\n                    zeroCols[j]++;\\n                }\\n                \\n            }\\n        }\\n        vector<vector<int>> answer(n , vector<int> (m));\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                answer[i][j] = oneRows[i] + oneCols[j] - zeroRows[i] - zeroCols[j];\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> oneRows(n), oneCols(m), zeroRows(n), zeroCols(m);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    oneRows[i]++;\\n                    oneCols[j]++;\\n                }\\n                if(!grid[i][j])\\n                {\\n                    zeroRows[i]++;\\n                    zeroCols[j]++;\\n                }\\n                \\n            }\\n        }\\n        vector<vector<int>> answer(n , vector<int> (m));\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                answer[i][j] = oneRows[i] + oneCols[j] - zeroRows[i] - zeroCols[j];\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935846,
                "title": "cpp-solution",
                "content": "# Intuition\\nJust count the zeros and ones and store them, and use the data to build the answer;\\n\\n# Approach\\n1. Create 4 arrays\\n2. Iterate through grid and if the element is zero then increment zero\\'s arrat else increment one\\'s array\\n3. Build the answer based on the stored data\\n4. return answer\\n\\n# Complexity\\n- Time complexity:\\n2(O(n^2))\\n\\n- Space complexity:\\n2(O(n))X2(O(n^2))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> oneRows(n), oneCols(m), zeroRows(n), zeroCols(m);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    oneRows[i]++;\\n                    oneCols[j]++;\\n                }\\n                if(!grid[i][j])\\n                {\\n                    zeroRows[i]++;\\n                    zeroCols[j]++;\\n                }\\n                \\n            }\\n        }\\n        vector<vector<int>> answer(n , vector<int> (m));\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                answer[i][j] = oneRows[i] + oneCols[j] - zeroRows[i] - zeroCols[j];\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> oneRows(n), oneCols(m), zeroRows(n), zeroCols(m);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    oneRows[i]++;\\n                    oneCols[j]++;\\n                }\\n                if(!grid[i][j])\\n                {\\n                    zeroRows[i]++;\\n                    zeroCols[j]++;\\n                }\\n                \\n            }\\n        }\\n        vector<vector<int>> answer(n , vector<int> (m));\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                answer[i][j] = oneRows[i] + oneCols[j] - zeroRows[i] - zeroCols[j];\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933903,
                "title": "easy-dictionary-approach",
                "content": "# Intuition\\n\\n\\n# Approach\\nCalculate the number of 1\\'s and 0\\'s in each row, do the same for each col. Finally update the graph with the difference between 1\\'s and 0\\'s for each intersection of row\\'s and col\\'s.\\nFor ex: if we take an index 2,3 then sum up all the 1\\'s available at row2 and col3 and subtract all the 0\\'s available at row 2 and col3\\n\\nThat is to say, for an index[i][j], we get a formula \\nmatrix[i][j]=row_of_1[i]+col_of_i[j]-row_of_0[i]-col_of_0[j]\\n\\nwhere row of 1 gives count of 1 for each row and col of 1 gives count of 1 in each col.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, mat: List[List[int]]) -> List[List[int]]:\\n        row=len(mat)\\n        col=len(mat[0])\\n\\n        d_row_1={}\\n        d_row_0={}\\n        d_col_1={}\\n        d_col_0={}\\n\\n        for i in range(row):\\n            d_row_1[i]=0\\n            d_row_0[i]=0\\n\\n        for i in range(col):\\n            d_col_1[i]=0\\n            d_col_0[i]=0\\n        #This will give us the number of 1\\'s or 0\\'s in a particular row\\n        for i in range(row):\\n            for j in range(col):\\n                if(mat[i][j]==1):\\n                    d_row_1[i]+=1\\n\\n                else:\\n                    d_row_0[i]+=1\\n        #this will give us the number of 1\\'s or 0\\'s in a particular col\\n\\n        for i in range(col):\\n            for j in range(row):\\n                if(mat[j][i]==1):\\n                    d_col_1[i]+=1\\n\\n                else:\\n                    d_col_0[i]+=1\\n\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                mat[i][j]=d_row_1[i]+d_col_1[j]-d_row_0[i]-d_col_0[j]\\n\\n        return (mat)\\n\\n            \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, mat: List[List[int]]) -> List[List[int]]:\\n        row=len(mat)\\n        col=len(mat[0])\\n\\n        d_row_1={}\\n        d_row_0={}\\n        d_col_1={}\\n        d_col_0={}\\n\\n        for i in range(row):\\n            d_row_1[i]=0\\n            d_row_0[i]=0\\n\\n        for i in range(col):\\n            d_col_1[i]=0\\n            d_col_0[i]=0\\n        #This will give us the number of 1\\'s or 0\\'s in a particular row\\n        for i in range(row):\\n            for j in range(col):\\n                if(mat[i][j]==1):\\n                    d_row_1[i]+=1\\n\\n                else:\\n                    d_row_0[i]+=1\\n        #this will give us the number of 1\\'s or 0\\'s in a particular col\\n\\n        for i in range(col):\\n            for j in range(row):\\n                if(mat[j][i]==1):\\n                    d_col_1[i]+=1\\n\\n                else:\\n                    d_col_0[i]+=1\\n\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                mat[i][j]=d_row_1[i]+d_col_1[j]-d_row_0[i]-d_col_0[j]\\n\\n        return (mat)\\n\\n            \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930314,
                "title": "java-easy-to-understand-solution-in-o-n-m-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore the number of 1\\'s in a particular row and Store the number of 1\\'s in a particular col.Now traverse the array and do the necessary formula to calculate desired ans. I used the given array as the solution array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M) + O(N*M) + O(N*M) = O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) + O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] a) {\\n        int n = a.length, m = a[0].length;\\n        int[] row = new int[n];\\n        int[] col = new int[m];\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j = 0; j<m; ++j){\\n                row[i] +=  a[i][j];\\n            }\\n        }\\n\\n        for(int j=0; j<m; ++j){\\n            for(int i=0; i<n; ++i){\\n                col[j] += a[i][j];\\n            }\\n        }\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                a[i][j] = row[i] + col[j] -(n - row[i]) - (m - col[j]);\\n            }\\n        }\\n\\n        return a;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] a) {\\n        int n = a.length, m = a[0].length;\\n        int[] row = new int[n];\\n        int[] col = new int[m];\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j = 0; j<m; ++j){\\n                row[i] +=  a[i][j];\\n            }\\n        }\\n\\n        for(int j=0; j<m; ++j){\\n            for(int i=0; i<n; ++i){\\n                col[j] += a[i][j];\\n            }\\n        }\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                a[i][j] = row[i] + col[j] -(n - row[i]) - (m - col[j]);\\n            }\\n        }\\n\\n        return a;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929842,
                "title": "c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)+O(N/2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        vector<pair<int,int>>v(n);\\n        vector<pair<int,int>>w(m);\\n        for(int i=0;i<n;i++)\\n        {    int zero=0;int one=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                 if(grid[i][j]==1)\\n                 { \\n                     one++;\\n                 }else\\n                 {\\n                     zero++;\\n                 }\\n            }\\n            v[i]={zero,one};  \\n        }\\n        for(int i=0;i<m;i++)\\n        {    int zero=0;int one=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                 if(grid[j][i]==1)\\n                 { \\n                     one++;\\n                 }else\\n                 {\\n                     zero++;\\n                 }\\n            }\\n            w[i]={zero,one};  \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n            ans[i][j]=v[i].second+w[j].second-v[i].first-w[j].first;\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        vector<pair<int,int>>v(n);\\n        vector<pair<int,int>>w(m);\\n        for(int i=0;i<n;i++)\\n        {    int zero=0;int one=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                 if(grid[i][j]==1)\\n                 { \\n                     one++;\\n                 }else\\n                 {\\n                     zero++;\\n                 }\\n            }\\n            v[i]={zero,one};  \\n        }\\n        for(int i=0;i<m;i++)\\n        {    int zero=0;int one=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                 if(grid[j][i]==1)\\n                 { \\n                     one++;\\n                 }else\\n                 {\\n                     zero++;\\n                 }\\n            }\\n            w[i]={zero,one};  \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n            ans[i][j]=v[i].second+w[j].second-v[i].first-w[j].first;\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928717,
                "title": "python3-two-passes",
                "content": "# Intuition\\nVery straightforward - should be an easy\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        v1 = [0] * len(grid)\\n        v2 = [0] * len(grid[0])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    v1[i] += 1\\n                    v2[j] += 1\\n                else:\\n                    v1[i] -= 1\\n                    v2[j] -= 1\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j] = v1[i] + v2[j]\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        v1 = [0] * len(grid)\\n        v2 = [0] * len(grid[0])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    v1[i] += 1\\n                    v2[j] += 1\\n                else:\\n                    v1[i] -= 1\\n                    v2[j] -= 1\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j] = v1[i] + v2[j]\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927531,
                "title": "rust-simple-optimised-double-iteration-solution",
                "content": "# Intuition\\nLooking at the problem, it\\'s clear that it requires an iterative solution. A naive approach would be to iterate over every row, then over every column, and then over the collected sums. However, this approach is wasteful - we can just as easily iterate over the grid once to collect the sums in both rows and columns, and another time to add up these sums.\\n\\n# Approach\\nThe approach is simple: first, we create help vectors for holding sums from each row and column. We then iterate over every cell in the grid, adding or subtracting to/from the corresponding sum (depending on the encountered digit, using the created ```add()``` function). Lastly, we iterate over every pair of row and column sums and set the corresponding cell in the result vector to the sum of the two. Notice that the result vector is just the starting vector - we only make it mutable so we can change its values. This eliminates the need to allocate a whole new vector.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m \\\\cdot n)$$, because we have to iterate over every cell in the matrix.\\n\\n# Code\\n```\\nimpl Solution {\\n    fn add(num: i32) -> i32 {\\n        if num > 0 {\\n            1\\n        } else {\\n            -1\\n        }\\n    }\\n\\n    pub fn ones_minus_zeros(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut rows = vec![0i32; grid.len()];\\n        let mut cols = vec![0i32; grid[0].len()];\\n        for i in 0..grid.len() {\\n            for j in 0..grid[i].len() {\\n                rows[i] += Self::add(grid[i][j]);\\n                cols[j] += Self::add(grid[i][j]);\\n            }\\n        }\\n\\n        let mut res = grid;\\n\\n        for i in 0..rows.len() {\\n            for j in 0..cols.len() {\\n                res[i][j] = rows[i] + cols[j];\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```add()```\n```\\nimpl Solution {\\n    fn add(num: i32) -> i32 {\\n        if num > 0 {\\n            1\\n        } else {\\n            -1\\n        }\\n    }\\n\\n    pub fn ones_minus_zeros(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut rows = vec![0i32; grid.len()];\\n        let mut cols = vec![0i32; grid[0].len()];\\n        for i in 0..grid.len() {\\n            for j in 0..grid[i].len() {\\n                rows[i] += Self::add(grid[i][j]);\\n                cols[j] += Self::add(grid[i][j]);\\n            }\\n        }\\n\\n        let mut res = grid;\\n\\n        for i in 0..rows.len() {\\n            for j in 0..cols.len() {\\n                res[i][j] = rows[i] + cols[j];\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924339,
                "title": "easy-to-understand-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<int> oneRow;\\n        vector<int> oneCol;\\n        vector<int> zerosRow;\\n        vector<int> zerosCol;\\n        for(int i=0; i<grid.size(); i++){\\n            int one = 0, zero = 0;\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j] == 1)\\n                    one++;\\n                if(grid[i][j] == 0)    \\n                    zero++;\\n            }\\n            oneRow.push_back(one);\\n            zerosRow.push_back(zero);\\n        }\\n        for(int i=0; i<grid[0].size(); i++){\\n            int one = 0, zero = 0;\\n            for(int j=0; j<grid.size(); j++){\\n                if(grid[j][i] == 1)\\n                    one++;\\n                if(grid[j][i] == 0)    \\n                    zero++;\\n            }\\n            oneCol.push_back(one);\\n            zerosCol.push_back(zero);\\n        }\\n        vector<vector<int>> ans(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                ans[i][j] = oneRow[i] + oneCol[j] - zerosRow[i] - zerosCol[j];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        vector<int> oneRow;\\n        vector<int> oneCol;\\n        vector<int> zerosRow;\\n        vector<int> zerosCol;\\n        for(int i=0; i<grid.size(); i++){\\n            int one = 0, zero = 0;\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j] == 1)\\n                    one++;\\n                if(grid[i][j] == 0)    \\n                    zero++;\\n            }\\n            oneRow.push_back(one);\\n            zerosRow.push_back(zero);\\n        }\\n        for(int i=0; i<grid[0].size(); i++){\\n            int one = 0, zero = 0;\\n            for(int j=0; j<grid.size(); j++){\\n                if(grid[j][i] == 1)\\n                    one++;\\n                if(grid[j][i] == 0)    \\n                    zero++;\\n            }\\n            oneCol.push_back(one);\\n            zerosCol.push_back(zero);\\n        }\\n        vector<vector<int>> ans(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                ans[i][j] = oneRow[i] + oneCol[j] - zerosRow[i] - zerosCol[j];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923848,
                "title": "difference-between-ones-and-zeros-in-row-and-column",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        ArrayList<Integer> rowone =new ArrayList<Integer>();\\n        ArrayList<Integer> colone =new ArrayList<Integer>();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        System.out.println(m+\" \"+n);\\n        for(int i=0;i<m;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                count++;\\n            }\\n            rowone.add(count);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[j][i]==1)\\n                count++;\\n            }\\n            colone.add(count);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                grid[i][j] = rowone.get(i)+ colone.get(j)-(m-rowone.get(i))-(n-colone.get(j));\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        ArrayList<Integer> rowone =new ArrayList<Integer>();\\n        ArrayList<Integer> colone =new ArrayList<Integer>();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        System.out.println(m+\" \"+n);\\n        for(int i=0;i<m;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                count++;\\n            }\\n            rowone.add(count);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[j][i]==1)\\n                count++;\\n            }\\n            colone.add(count);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                grid[i][j] = rowone.get(i)+ colone.get(j)-(m-rowone.get(i))-(n-colone.get(j));\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923764,
                "title": "simplest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<int> row_ones(m);\\n        vector<int> row_zeroes(m);\\n        vector<int> col_ones(n);\\n        vector<int> col_zeroes(n);    \\n\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            int cnt1=0;\\n            int cnt0=0;\\n\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    cnt0++;\\n                }\\n                else\\n                {\\n                    cnt1++;\\n                }\\n            }\\n            row_ones[i] = cnt1;\\n            row_zeroes[i] = cnt0;\\n        }\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int cnt1=0;\\n            int cnt0=0;\\n\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[j][i]==0)\\n                {\\n                    cnt0++;\\n                }\\n                else\\n                {\\n                    cnt1++;\\n                }\\n            }\\n            col_zeroes[i] = cnt0;\\n            col_ones[i] = cnt1;\\n        }\\n\\n        vector<vector<int>> ans(m, vector<int>(n));\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                ans[i][j] = (row_ones[i]+col_ones[j]) - (row_zeroes[i]+col_zeroes[j]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<int> row_ones(m);\\n        vector<int> row_zeroes(m);\\n        vector<int> col_ones(n);\\n        vector<int> col_zeroes(n);    \\n\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            int cnt1=0;\\n            int cnt0=0;\\n\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    cnt0++;\\n                }\\n                else\\n                {\\n                    cnt1++;\\n                }\\n            }\\n            row_ones[i] = cnt1;\\n            row_zeroes[i] = cnt0;\\n        }\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int cnt1=0;\\n            int cnt0=0;\\n\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[j][i]==0)\\n                {\\n                    cnt0++;\\n                }\\n                else\\n                {\\n                    cnt1++;\\n                }\\n            }\\n            col_zeroes[i] = cnt0;\\n            col_ones[i] = cnt1;\\n        }\\n\\n        vector<vector<int>> ans(m, vector<int>(n));\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                ans[i][j] = (row_ones[i]+col_ones[j]) - (row_zeroes[i]+col_zeroes[j]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923686,
                "title": "c-solution-tc-o-n-2-sc-o-n-two-1d-vectors-80-in-tc-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& g) {\\n        int m = g.size(), n = g[0].size();\\n\\n        vector<int> row(m,0), col(n,0);\\n        int sum = 0;\\n        for(int i=0;i<m;i++){\\n            sum = 0;\\n            for(int j=0;j<n;j++){\\n                if(g[i][j] == 0) sum -= 1;\\n                else sum += 1;\\n            }\\n            row[i]=sum;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            sum = 0;\\n            for(int j=0;j<m;j++){\\n                if(g[j][i] == 0) sum -= 1;\\n                else sum += 1;\\n            }\\n            col[i] = sum;\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                g[i][j] = row[i];\\n            }\\n        }       \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                g[j][i] += col[i];\\n            }\\n        }\\n\\n        return g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& g) {\\n        int m = g.size(), n = g[0].size();\\n\\n        vector<int> row(m,0), col(n,0);\\n        int sum = 0;\\n        for(int i=0;i<m;i++){\\n            sum = 0;\\n            for(int j=0;j<n;j++){\\n                if(g[i][j] == 0) sum -= 1;\\n                else sum += 1;\\n            }\\n            row[i]=sum;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            sum = 0;\\n            for(int j=0;j<m;j++){\\n                if(g[j][i] == 0) sum -= 1;\\n                else sum += 1;\\n            }\\n            col[i] = sum;\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                g[i][j] = row[i];\\n            }\\n        }       \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                g[j][i] += col[i];\\n            }\\n        }\\n\\n        return g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922743,
                "title": "c-easy-approach-11-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngrid = [[0,1,1],[1,0,1],[0,0,1]]\\n\\n- diff[0][0]= onesRow0+ onesCol0- zerosRow0 - zerosCol0= **2** + 1 - **1** - 2\\n\\nIt\\'s easy to tell that onesRow+zerosRow equals grid[0].size for every element in the vector. Likewise, onesCol+zerosCol equals grid.size.\\n\\nSo, you only have to get onesRow and onesCol using a for loop.\\n\\nFinally, every value in ret is onesRow[i]+onesCol[j] - (sum + onesRow[i]+onesCol[j]), which equals 2*(onesRow[i]+onesCol[j])-sum\\n\\n*sum = grid.size()+grid[0].size()\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: (n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), sum = n+m;\\n        vector<int> onesRow(n), onesCol(m);\\n        vector<vector<int>> ret(n, vector<int>(m));\\n\\n        for ( int i=0;i<n;i++)\\n            for ( int j=0;j<m;j++)\\n                if (grid[i][j] == 1)\\n                {\\n                    onesRow[i]++;\\n                    onesCol[j]++;\\n                }\\n        \\n        for ( int i=0;i<n;i++)\\n            for ( int j=0;j<m;j++)\\n                ret[i][j] = 2*(onesRow[i]+onesCol[j])-sum;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), sum = n+m;\\n        vector<int> onesRow(n), onesCol(m);\\n        vector<vector<int>> ret(n, vector<int>(m));\\n\\n        for ( int i=0;i<n;i++)\\n            for ( int j=0;j<m;j++)\\n                if (grid[i][j] == 1)\\n                {\\n                    onesRow[i]++;\\n                    onesCol[j]++;\\n                }\\n        \\n        for ( int i=0;i<n;i++)\\n            for ( int j=0;j<m;j++)\\n                ret[i][j] = 2*(onesRow[i]+onesCol[j])-sum;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922600,
                "title": "rust-short-functional-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn ones_minus_zeros(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut onesCol = vec![0; n];\\n\\n        (0..m)\\n            .map(|row| {\\n                (0..n)\\n                    .filter(|&c| grid[row][c] != 0)\\n                    .map(|col| onesCol[col] += 1)\\n                    .count()\\n            })\\n            .collect::<Vec<_>>()\\n            .into_iter()\\n            .map(|r| {\\n                onesCol\\n                    .iter()\\n                    .map(|c| ((r + c) << 1) as i32 - (m + n) as i32)\\n                    .collect()\\n            })\\n            .collect()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn ones_minus_zeros(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut onesCol = vec![0; n];\\n\\n        (0..m)\\n            .map(|row| {\\n                (0..n)\\n                    .filter(|&c| grid[row][c] != 0)\\n                    .map(|col| onesCol[col] += 1)\\n                    .count()\\n            })\\n            .collect::<Vec<_>>()\\n            .into_iter()\\n            .map(|r| {\\n                onesCol\\n                    .iter()\\n                    .map(|c| ((r + c) << 1) as i32 - (m + n) as i32)\\n                    .collect()\\n            })\\n            .collect()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921986,
                "title": "sum-python3",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m + n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        onesRow  = [sum(row) for row in grid]\\n        onesCol = []\\n        for j in range(n):\\n            sm = 0\\n            for i in range(m):\\n                sm += grid[i][j]\\n            onesCol.append(sm)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                grid[i][j] = 2 * onesRow[i] + 2 * onesCol[j] - n - m \\n\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        onesRow  = [sum(row) for row in grid]\\n        onesCol = []\\n        for j in range(n):\\n            sm = 0\\n            for i in range(m):\\n                sm += grid[i][j]\\n            onesCol.append(sm)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                grid[i][j] = 2 * onesRow[i] + 2 * onesCol[j] - n - m \\n\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921981,
                "title": "use-2-arrays-to-store-count-of-1s",
                "content": "# Intuition\\nUse 2 arrays. One will store the count of number of 1s in that row and the other will store the count of numbers 1s in that column.\\nOnce done, we just iterate over the matrix and set the matrix.\\nEach diff grid is basically -> rowSum + colSum\\nwhere rowSum: \\n-> row1s - row0s which equls to... \\n    -> row1s - (len(row)-row1s) which equals to ...\\n        -> 2(row1s) - len(row)\\n\\nsame applies for col sum\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n\\n        ROWS,COLS = len(grid),len(grid[0])\\n        rowOnes,colOnes = [0 for i in range(ROWS)],[0 for i in range(COLS)]\\n        matrix = [[0 for i in range(COLS)] for i in range(ROWS)]\\n\\n        for y in range(ROWS):\\n            for x in range(COLS):\\n                cell = grid[y][x]\\n                if cell:\\n                    rowOnes[y] += 1\\n                    colOnes[x] += 1\\n        \\n        for y in range(ROWS):\\n            for x in range(COLS):\\n                rowSum = 2*rowOnes[y] - COLS\\n                colSum = 2*colOnes[x] - ROWS\\n                matrix[y][x] = rowSum + colSum\\n\\n        return matrix\\n        \\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n\\n        ROWS,COLS = len(grid),len(grid[0])\\n        rowOnes,colOnes = [0 for i in range(ROWS)],[0 for i in range(COLS)]\\n        matrix = [[0 for i in range(COLS)] for i in range(ROWS)]\\n\\n        for y in range(ROWS):\\n            for x in range(COLS):\\n                cell = grid[y][x]\\n                if cell:\\n                    rowOnes[y] += 1\\n                    colOnes[x] += 1\\n        \\n        for y in range(ROWS):\\n            for x in range(COLS):\\n                rowSum = 2*rowOnes[y] - COLS\\n                colSum = 2*colOnes[x] - ROWS\\n                matrix[y][x] = rowSum + colSum\\n\\n        return matrix\\n        \\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921887,
                "title": "in-place-clean-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) I have stored the number of zeroes and number of ones in the zeroth column in the different variables.\\n\\n2) Same thing I have done for the last column\\n\\n3) Now, I have stored the number of zeroes in the ith in grid[i][0] , \\nAnd number of ones in the grid[i][m - 1]\\n\\n4) Then, I have stored the number of zeroes in jth column in grid[0][j], \\nAnd number of ones in the grid[n - 1][j] . \\n\\nI have performed the above steps in order so that original data gets updated only when it has been counted/\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int diff(int onesrow, int onescol, int zeroesrow, int zeroescol) {\\n\\n        return onesrow + onescol - zeroesrow - zeroescol;\\n\\n    }\\n\\n\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        \\n        int numRows = grid.size();\\n        int numCols = grid[0].size();\\n\\n        vector<vector<int>> ans(numRows, vector<int>(numCols, 0));\\n\\n        if(numRows == 1 && numCols == 1) {\\n            \\n            if(grid[0][0] == 1) {\\n                ans[0][0] = 2;\\n            }\\n            else {\\n                ans[0][0] = -2;\\n            }\\n\\n            return ans;\\n\\n        }\\n\\n        if(numRows == 1) {\\n\\n            int rowsones = 0;\\n            int rowszeroes = 0;\\n\\n            for(int j = 0 ; j < numCols; j++) {\\n                if(grid[0][j] == 1) {\\n                    rowsones++;\\n                } else {\\n                    rowszeroes++;\\n                }\\n            }\\n\\n\\n            for(int j = 0; j < numCols; j++) {\\n\\n                int columnzeroes = 0;\\n                int columnones = 0;\\n\\n                if(grid[0][j] == 0) columnzeroes++;\\n                else columnones++;\\n\\n                ans[0][j] = diff(rowsones, columnones, rowszeroes, columnzeroes);\\n            }\\n\\n\\n            return ans;\\n\\n        }\\n\\n\\n        if(numCols == 1) {\\n\\n            int colsones = 0;\\n            int colszeroes = 0;\\n\\n            for(int i = 0; i < numRows; i++) {\\n                if(grid[i][0] == 1) {\\n                    colsones++;\\n                } else {\\n                    colszeroes++;\\n                }\\n            }\\n\\n            for(int i = 0; i < numRows; i++) {\\n                \\n                int rowszeroes = 0;\\n                int rowsones = 0;\\n\\n                if(grid[i][0] == 1) rowsones++;\\n                else rowszeroes++;\\n\\n                ans[i][0] = diff(rowsones, colsones, rowszeroes, colszeroes);\\n\\n            }\\n\\n            return ans;\\n        }\\n\\n        int zerocolumnzeroes = 0;\\n        int zerocolumnones = 0;\\n        int lastcolumnzeroes = 0;\\n        int lastcolumnones = 0;\\n\\n        for(int i = 0; i < numRows; i++) {\\n            if(grid[i][0] == 1) {\\n                zerocolumnones++;\\n            } else {\\n                zerocolumnzeroes++;\\n            }\\n        }\\n\\n        for(int i = 0; i < numRows; i++) {\\n            if(grid[i][numCols - 1] == 1) {\\n                lastcolumnones++;\\n            } else {\\n                lastcolumnzeroes++;\\n            }\\n        }\\n\\n        for(int i = 0; i < numRows; i++) {\\n            \\n            int ithrowzeroes = 0;\\n            int ithrowones = 0;\\n\\n            for(int j = 0; j < numCols; j++) {\\n                if(grid[i][j] == 1) {\\n                    ithrowones++;\\n                } else {\\n                    ithrowzeroes++;\\n                }\\n            }\\n\\n            grid[i][0] = ithrowzeroes;\\n            grid[i][numCols - 1] = ithrowones;\\n\\n        }\\n\\n        for(int j = 1; j < numCols - 1; j++) {\\n\\n            int jthcolumnzeroes = 0;\\n            int jthcolumnones = 0;\\n\\n            for(int i = 0 ; i < numRows; i++) {\\n                if(grid[i][j] == 1) {\\n                    jthcolumnones++;\\n                } else {\\n                    jthcolumnzeroes++;\\n                }\\n            }\\n\\n            grid[0][j] = jthcolumnzeroes;\\n            grid[numRows - 1][j] = jthcolumnones;\\n\\n        }\\n\\n        for(int i = 0; i < numRows; i++) {\\n            for(int j = 0; j < numCols; j++) {\\n                \\n                if(j == 0) {\\n                    ans[i][j] = diff(grid[i][numCols - 1], zerocolumnones, grid[i][0], zerocolumnzeroes);\\n                } else if(j == numCols - 1) {\\n                    ans[i][j] = diff(grid[i][numCols - 1], lastcolumnones, grid[i][0], lastcolumnzeroes);\\n                } else {\\n                    ans[i][j] = diff(grid[i][numCols - 1], grid[numRows - 1][j], grid[i][0], grid[0][j]);\\n                }\\n\\n\\n            }\\n        }\\n\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int diff(int onesrow, int onescol, int zeroesrow, int zeroescol) {\\n\\n        return onesrow + onescol - zeroesrow - zeroescol;\\n\\n    }\\n\\n\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        \\n        int numRows = grid.size();\\n        int numCols = grid[0].size();\\n\\n        vector<vector<int>> ans(numRows, vector<int>(numCols, 0));\\n\\n        if(numRows == 1 && numCols == 1) {\\n            \\n            if(grid[0][0] == 1) {\\n                ans[0][0] = 2;\\n            }\\n            else {\\n                ans[0][0] = -2;\\n            }\\n\\n            return ans;\\n\\n        }\\n\\n        if(numRows == 1) {\\n\\n            int rowsones = 0;\\n            int rowszeroes = 0;\\n\\n            for(int j = 0 ; j < numCols; j++) {\\n                if(grid[0][j] == 1) {\\n                    rowsones++;\\n                } else {\\n                    rowszeroes++;\\n                }\\n            }\\n\\n\\n            for(int j = 0; j < numCols; j++) {\\n\\n                int columnzeroes = 0;\\n                int columnones = 0;\\n\\n                if(grid[0][j] == 0) columnzeroes++;\\n                else columnones++;\\n\\n                ans[0][j] = diff(rowsones, columnones, rowszeroes, columnzeroes);\\n            }\\n\\n\\n            return ans;\\n\\n        }\\n\\n\\n        if(numCols == 1) {\\n\\n            int colsones = 0;\\n            int colszeroes = 0;\\n\\n            for(int i = 0; i < numRows; i++) {\\n                if(grid[i][0] == 1) {\\n                    colsones++;\\n                } else {\\n                    colszeroes++;\\n                }\\n            }\\n\\n            for(int i = 0; i < numRows; i++) {\\n                \\n                int rowszeroes = 0;\\n                int rowsones = 0;\\n\\n                if(grid[i][0] == 1) rowsones++;\\n                else rowszeroes++;\\n\\n                ans[i][0] = diff(rowsones, colsones, rowszeroes, colszeroes);\\n\\n            }\\n\\n            return ans;\\n        }\\n\\n        int zerocolumnzeroes = 0;\\n        int zerocolumnones = 0;\\n        int lastcolumnzeroes = 0;\\n        int lastcolumnones = 0;\\n\\n        for(int i = 0; i < numRows; i++) {\\n            if(grid[i][0] == 1) {\\n                zerocolumnones++;\\n            } else {\\n                zerocolumnzeroes++;\\n            }\\n        }\\n\\n        for(int i = 0; i < numRows; i++) {\\n            if(grid[i][numCols - 1] == 1) {\\n                lastcolumnones++;\\n            } else {\\n                lastcolumnzeroes++;\\n            }\\n        }\\n\\n        for(int i = 0; i < numRows; i++) {\\n            \\n            int ithrowzeroes = 0;\\n            int ithrowones = 0;\\n\\n            for(int j = 0; j < numCols; j++) {\\n                if(grid[i][j] == 1) {\\n                    ithrowones++;\\n                } else {\\n                    ithrowzeroes++;\\n                }\\n            }\\n\\n            grid[i][0] = ithrowzeroes;\\n            grid[i][numCols - 1] = ithrowones;\\n\\n        }\\n\\n        for(int j = 1; j < numCols - 1; j++) {\\n\\n            int jthcolumnzeroes = 0;\\n            int jthcolumnones = 0;\\n\\n            for(int i = 0 ; i < numRows; i++) {\\n                if(grid[i][j] == 1) {\\n                    jthcolumnones++;\\n                } else {\\n                    jthcolumnzeroes++;\\n                }\\n            }\\n\\n            grid[0][j] = jthcolumnzeroes;\\n            grid[numRows - 1][j] = jthcolumnones;\\n\\n        }\\n\\n        for(int i = 0; i < numRows; i++) {\\n            for(int j = 0; j < numCols; j++) {\\n                \\n                if(j == 0) {\\n                    ans[i][j] = diff(grid[i][numCols - 1], zerocolumnones, grid[i][0], zerocolumnzeroes);\\n                } else if(j == numCols - 1) {\\n                    ans[i][j] = diff(grid[i][numCols - 1], lastcolumnones, grid[i][0], lastcolumnzeroes);\\n                } else {\\n                    ans[i][j] = diff(grid[i][numCols - 1], grid[numRows - 1][j], grid[i][0], grid[0][j]);\\n                }\\n\\n\\n            }\\n        }\\n\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921771,
                "title": "simple-2-1d-vectors-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int m=  grid.size();\\n        int n = grid[0].size();\\n        vector<int>row(m,0);\\n        vector<int>col(n,0);\\n        for(int i=0;i<m;i++)\\n        {\\n            int onesrows=0,zerosrows=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                 if(grid[i][j]==0)\\n                  zerosrows++;\\n                else\\n                  onesrows++;\\n            }\\n            row[i]=onesrows-zerosrows;\\n        }\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int onescol=0,zeroscol=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                 if(grid[j][i]==0)\\n                  zeroscol++;\\n                else\\n                  onescol++;\\n            }\\n            col[i]=onescol-zeroscol;\\n        }\\n        for(auto a : row)\\n          cout<<a<<\" \";\\n\\n        for(auto b:col)\\n          cout<<b<<\" \";\\n\\n          for(int i=0;i<m;i++)\\n          {\\n            for(int j=0;j<n;j++)\\n            {\\n              grid[i][j]=row[i]+col[j];\\n            }\\n          }\\nreturn grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) \\n    {\\n        int m=  grid.size();\\n        int n = grid[0].size();\\n        vector<int>row(m,0);\\n        vector<int>col(n,0);\\n        for(int i=0;i<m;i++)\\n        {\\n            int onesrows=0,zerosrows=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                 if(grid[i][j]==0)\\n                  zerosrows++;\\n                else\\n                  onesrows++;\\n            }\\n            row[i]=onesrows-zerosrows;\\n        }\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int onescol=0,zeroscol=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                 if(grid[j][i]==0)\\n                  zeroscol++;\\n                else\\n                  onescol++;\\n            }\\n            col[i]=onescol-zeroscol;\\n        }\\n        for(auto a : row)\\n          cout<<a<<\" \";\\n\\n        for(auto b:col)\\n          cout<<b<<\" \";\\n\\n          for(int i=0;i<m;i++)\\n          {\\n            for(int j=0;j<n;j++)\\n            {\\n              grid[i][j]=row[i]+col[j];\\n            }\\n          }\\nreturn grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3921725,
                "title": "easy-to-understand-python-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def onesMinusZeros(self, grid):\\n        row,row1,col,col1,g=[],[],[],[],[]\\n        for i in range(len(grid)):\\n            row.append(grid[i].count(0))\\n            row1.append(grid[i].count(1))\\n        for i in range(len(grid[0])):\\n            c,c1=0,0\\n            for j in range(len(grid)):\\n                if(grid[j][i]==0): c+=1\\n                else: c1+=1\\n            col.append(c)\\n            col1.append(c1)\\n        for i in range(len(grid)):\\n            g1=[]\\n            for j in range(len(grid[0])):\\n                g1.append(row1[i]+col1[j]-row[i]-col[j])\\n            g.append(g1)\\n        return g\\n\\n\\n                \\n```\\nPLEASE DO UPVOTE :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def onesMinusZeros(self, grid):\\n        row,row1,col,col1,g=[],[],[],[],[]\\n        for i in range(len(grid)):\\n            row.append(grid[i].count(0))\\n            row1.append(grid[i].count(1))\\n        for i in range(len(grid[0])):\\n            c,c1=0,0\\n            for j in range(len(grid)):\\n                if(grid[j][i]==0): c+=1\\n                else: c1+=1\\n            col.append(c)\\n            col1.append(c1)\\n        for i in range(len(grid)):\\n            g1=[]\\n            for j in range(len(grid[0])):\\n                g1.append(row1[i]+col1[j]-row[i]-col[j])\\n            g.append(g1)\\n        return g\\n\\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921523,
                "title": "c-avoiding-having-separate-row-column-vectors",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> diff(m, vector<int>(n, - (m + n)));\\n\\n        for (int i = 0; i < m; ++i) {\\n            int cnt = 0;\\n            for (int j = 0; j < n; ++j)\\n                cnt += grid[i][j];\\n            for (int j = 0; j < n; ++j)\\n                diff[i][j] += 2*cnt;\\n        }\\n\\n        for (int j = 0; j < n; ++j) {\\n            int cnt = 0;\\n            for (int i = 0; i < m; ++i)\\n                cnt += grid[i][j];\\n            for (int i = 0; i < m; ++i)\\n                diff[i][j] += 2*cnt;\\n        }\\n        return diff;\\n    }\\n};\\n\\n/*\\nr + c - n + r - m + c\\n2(r + c) - (n + m)\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> diff(m, vector<int>(n, - (m + n)));\\n\\n        for (int i = 0; i < m; ++i) {\\n            int cnt = 0;\\n            for (int j = 0; j < n; ++j)\\n                cnt += grid[i][j];\\n            for (int j = 0; j < n; ++j)\\n                diff[i][j] += 2*cnt;\\n        }\\n\\n        for (int j = 0; j < n; ++j) {\\n            int cnt = 0;\\n            for (int i = 0; i < m; ++i)\\n                cnt += grid[i][j];\\n            for (int i = 0; i < m; ++i)\\n                diff[i][j] += 2*cnt;\\n        }\\n        return diff;\\n    }\\n};\\n\\n/*\\nr + c - n + r - m + c\\n2(r + c) - (n + m)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921507,
                "title": "matrix-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> onesRow(n, 0);\\n        vector<int> onesCol(m, 0);\\n        vector<int> zeroRow(n, 0);\\n        vector<int> zeroCol(m, 0);\\n\\n        for(int i = 0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 0){\\n                    zeroRow[i]++;\\n                    zeroCol[j]++;\\n                }\\n                else{\\n                    onesCol[j]++;\\n                    onesRow[i]++;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> diff(n , vector<int> (m, 0));\\n        for(int i = 0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                diff[i][j] = onesRow[i] + onesCol[j] - zeroRow[i] - zeroCol[j];\\n            }\\n        }\\n\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> onesRow(n, 0);\\n        vector<int> onesCol(m, 0);\\n        vector<int> zeroRow(n, 0);\\n        vector<int> zeroCol(m, 0);\\n\\n        for(int i = 0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 0){\\n                    zeroRow[i]++;\\n                    zeroCol[j]++;\\n                }\\n                else{\\n                    onesCol[j]++;\\n                    onesRow[i]++;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> diff(n , vector<int> (m, 0));\\n        for(int i = 0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                diff[i][j] = onesRow[i] + onesCol[j] - zeroRow[i] - zeroCol[j];\\n            }\\n        }\\n\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921424,
                "title": "single-traversal-o-m-x-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        vector<int>row1(m,0);\\n        vector<int>col1(n,0);\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1){\\n                    row1[i]++;\\n                    col1[j]++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n            {\\n                grid[i][j]=(row1[i]+col1[j])-(m+n-row1[i]-col1[j]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        vector<int>row1(m,0);\\n        vector<int>col1(n,0);\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1){\\n                    row1[i]++;\\n                    col1[j]++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n            {\\n                grid[i][j]=(row1[i]+col1[j])-(m+n-row1[i]-col1[j]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921331,
                "title": "easiest-java-calculate-diff-for-each-row-col-separately",
                "content": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[] rowDiff = new int[n];\\n        int[] colDiff = new int[m];\\n        updateDiffArrays(grid, rowDiff, colDiff);\\n\\n        int[][] diff = new int[n][m];\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                diff[i][j] = rowDiff[i] + colDiff[j];\\n            }\\n        }\\n\\n        return diff;\\n    }\\n\\n    private void updateDiffArrays(int[][] grid, int[] rowDiff, int[] colDiff) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                if(grid[i][j] == 1) {\\n                    rowDiff[i]++;\\n                    colDiff[j]++;\\n                } else {\\n                    rowDiff[i]--;\\n                    colDiff[j]--;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[] rowDiff = new int[n];\\n        int[] colDiff = new int[m];\\n        updateDiffArrays(grid, rowDiff, colDiff);\\n\\n        int[][] diff = new int[n][m];\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                diff[i][j] = rowDiff[i] + colDiff[j];\\n            }\\n        }\\n\\n        return diff;\\n    }\\n\\n    private void updateDiffArrays(int[][] grid, int[] rowDiff, int[] colDiff) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                if(grid[i][j] == 1) {\\n                    rowDiff[i]++;\\n                    colDiff[j]++;\\n                } else {\\n                    rowDiff[i]--;\\n                    colDiff[j]--;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921200,
                "title": "2482-difference-between-ones-and-zeros-in-row-and-column-python-solution",
                "content": "# Complexity\\n- Time complexity: **O(m * n)**\\n\\n- Space complexity: **O(m * n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        onesRow, onesCol, zerosRow, zerosCol = list(), list(), list(), list()\\n        \\n        for r in range(m):\\n            ones = zeros = 0\\n            for c in range(n):\\n                if grid[r][c] == 0:\\n                    zeros += 1\\n                else:\\n                    ones += 1\\n            onesRow.append(ones)\\n            zerosRow.append(zeros)\\n\\n        for c in range(n):\\n            ones = zeros = 0\\n            for r in range(m):\\n                if grid[r][c] == 0:\\n                    zeros += 1\\n                else:\\n                    ones += 1\\n            onesCol.append(ones)\\n            zerosCol.append(zeros)\\n\\n        diff = [[0 for _ in range(n)] for _ in range(m)]\\n\\n        for r in range(m):\\n            for c in range(n):\\n                diff[r][c] = onesRow[r] + onesCol[c] - zerosRow[r] - zerosCol[c]\\n        \\n        return diff\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        onesRow, onesCol, zerosRow, zerosCol = list(), list(), list(), list()\\n        \\n        for r in range(m):\\n            ones = zeros = 0\\n            for c in range(n):\\n                if grid[r][c] == 0:\\n                    zeros += 1\\n                else:\\n                    ones += 1\\n            onesRow.append(ones)\\n            zerosRow.append(zeros)\\n\\n        for c in range(n):\\n            ones = zeros = 0\\n            for r in range(m):\\n                if grid[r][c] == 0:\\n                    zeros += 1\\n                else:\\n                    ones += 1\\n            onesCol.append(ones)\\n            zerosCol.append(zeros)\\n\\n        diff = [[0 for _ in range(n)] for _ in range(m)]\\n\\n        for r in range(m):\\n            for c in range(n):\\n                diff[r][c] = onesRow[r] + onesCol[c] - zerosRow[r] - zerosCol[c]\\n        \\n        return diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921014,
                "title": "beginner-friendly-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n   O(M*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>df;\\n        for(int i=0;i<n;i++){\\n            int t=0;\\n            for(int j=0;j<m;j++){\\n                  if(grid[i][j]) t++;\\n                  else t--;\\n            }\\n            vector<int>v(m,t);\\n            df.push_back(v);\\n        }\\n        for(int j=0;j<m;j++){\\n            int t=0;\\n            for(int i=0;i<n;i++){\\n                 if(grid[i][j]) t++;\\n                 else t--;\\n            }\\n            for(int i=0;i<n;i++) df[i][j]+=t;\\n        }\\n        return df;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>df;\\n        for(int i=0;i<n;i++){\\n            int t=0;\\n            for(int j=0;j<m;j++){\\n                  if(grid[i][j]) t++;\\n                  else t--;\\n            }\\n            vector<int>v(m,t);\\n            df.push_back(v);\\n        }\\n        for(int j=0;j<m;j++){\\n            int t=0;\\n            for(int i=0;i<n;i++){\\n                 if(grid[i][j]) t++;\\n                 else t--;\\n            }\\n            for(int i=0;i<n;i++) df[i][j]+=t;\\n        }\\n        return df;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920834,
                "title": "90-easy-python-solution-double-traversal",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCreate array for column and row counts:\\nSecond traversal access both Arrays overlapping our grid using the equation given.\\nDONT make a result grid since it\\'s a waste of space \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        \\n        #colMap = [0,0] \\n        #rowMap = defaultdict(list)\\n        ROW, COL = len(grid), len(grid[0])\\n        colMap = [[0,0] for _ in range(COL)]   #zero, one [[0,0], [0,0], [0,0]]\\n        rowMap = [[0,0] for _ in range(ROW)] \\n        for i in range(ROW):\\n            for j in range(COL):\\n                if grid[i][j] == 0:\\n                    rowMap[i][0] += 1\\n                    colMap[j][0] += 1\\n                \\n                if grid[i][j] == 1:\\n                    rowMap[i][1] += 1\\n                    colMap[j][1] += 1\\n    \\n        # dont need to make new map\\n        for i in range(ROW):\\n            for j in range(COL):\\n                grid[i][j] = rowMap[i][1] + colMap[j][1] - rowMap[i][0] - colMap[j][0]\\n        \\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        \\n        #colMap = [0,0] \\n        #rowMap = defaultdict(list)\\n        ROW, COL = len(grid), len(grid[0])\\n        colMap = [[0,0] for _ in range(COL)]   #zero, one [[0,0], [0,0], [0,0]]\\n        rowMap = [[0,0] for _ in range(ROW)] \\n        for i in range(ROW):\\n            for j in range(COL):\\n                if grid[i][j] == 0:\\n                    rowMap[i][0] += 1\\n                    colMap[j][0] += 1\\n                \\n                if grid[i][j] == 1:\\n                    rowMap[i][1] += 1\\n                    colMap[j][1] += 1\\n    \\n        # dont need to make new map\\n        for i in range(ROW):\\n            for j in range(COL):\\n                grid[i][j] = rowMap[i][1] + colMap[j][1] - rowMap[i][0] - colMap[j][0]\\n        \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920823,
                "title": "c-hash-map-simulation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        map<int,int> oR;\\n        map<int,int> oc;\\n        map<int,int> zr;\\n        map<int,int> zc;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int cnt1 = 0,cnt0 = 0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                cnt1++;\\n                else\\n                cnt0++;\\n            }\\n            oR[i] = cnt1;\\n            zr[i] = cnt0;\\n        }\\n        for(int j=0;j<m;j++)\\n        {\\n            int cnt1 = 0,cnt0 = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(grid[i][j]==1)\\n                cnt1++;\\n                else\\n                cnt0++;\\n            }\\n            oc[j] = cnt1;\\n            zc[j] = cnt0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                grid[i][j] = oR[i]+oc[j]-zr[i]-zc[j];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        map<int,int> oR;\\n        map<int,int> oc;\\n        map<int,int> zr;\\n        map<int,int> zc;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int cnt1 = 0,cnt0 = 0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                cnt1++;\\n                else\\n                cnt0++;\\n            }\\n            oR[i] = cnt1;\\n            zr[i] = cnt0;\\n        }\\n        for(int j=0;j<m;j++)\\n        {\\n            int cnt1 = 0,cnt0 = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(grid[i][j]==1)\\n                cnt1++;\\n                else\\n                cnt0++;\\n            }\\n            oc[j] = cnt1;\\n            zc[j] = cnt0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                grid[i][j] = oR[i]+oc[j]-zr[i]-zc[j];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920822,
                "title": "c-o-m-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> r(m,0);\\n        vector<int> c(n,0);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    r[i]++;\\n                    c[j]++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j] = r[i]+c[j]-(n-r[i])-(m-c[j]);\\n            }\\n        }       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> r(m,0);\\n        vector<int> c(n,0);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    r[i]++;\\n                    c[j]++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j] = r[i]+c[j]-(n-r[i])-(m-c[j]);\\n            }\\n        }       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914333,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& g) {\\n\\n        int row=g.size(),col=g[0].size();\\n        vector<vector<int>>ans(row,vector<int>(col,0));\\n        vector<int>r1,r0,c1,c0;\\n        for(int i=0;i<row;i++){\\n            int one=0,zero=0;\\n            for(int j=0;j<col;j++){\\n                (g[i][j]==1) ? one++ : zero++;\\n            }\\n            r1.push_back(one);\\n            r0.push_back(zero);\\n        }\\n\\n        for(int i=0;i<col;i++){\\n            int one=0,zero=0;\\n            for(int j=0;j<row;j++){\\n               (g[j][i]==1) ? one++ : zero++;\\n            }\\n            c1.push_back(one);\\n            c0.push_back(zero);\\n        }\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                ans[i][j]=r1[i]+c1[j]-r0[i]-c0[j];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& g) {\\n\\n        int row=g.size(),col=g[0].size();\\n        vector<vector<int>>ans(row,vector<int>(col,0));\\n        vector<int>r1,r0,c1,c0;\\n        for(int i=0;i<row;i++){\\n            int one=0,zero=0;\\n            for(int j=0;j<col;j++){\\n                (g[i][j]==1) ? one++ : zero++;\\n            }\\n            r1.push_back(one);\\n            r0.push_back(zero);\\n        }\\n\\n        for(int i=0;i<col;i++){\\n            int one=0,zero=0;\\n            for(int j=0;j<row;j++){\\n               (g[j][i]==1) ? one++ : zero++;\\n            }\\n            c1.push_back(one);\\n            c0.push_back(zero);\\n        }\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                ans[i][j]=r1[i]+c1[j]-r0[i]-c0[j];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903966,
                "title": "java-solution-with-four-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int rows=grid.length;\\n        int cols=grid[0].length;\\n        int result[][]=new int[rows][cols];\\n        int left=0;\\n        int right=cols-1;\\n        int top=0;\\n        int bottom=rows-1;\\n        int top_dummy=0;\\n        int left_dummy=0;\\n\\n        int arr[][]=new int[rows][2];\\n        while(top<=bottom)\\n        {\\n            int zero=0;\\n            int one=0;\\n            for(int x=left;x<=right;x++)\\n            {\\n                if(grid[top][x]==0)\\n                {\\n                    zero++;\\n                }\\n                else{\\n                    one++;\\n                }\\n            }\\n            arr[top][0]=zero;\\n            arr[top][1]=one;\\n            top++;\\n        }\\n       \\n       top=0;\\n        int arr1[][]=new int[cols][2];\\n        while(left<=right)\\n        {\\n            int zero=0;\\n            int one=0;\\n            for(int x=top;x<=bottom;x++)\\n            {\\n                if(grid[x][left]==0)\\n                {\\n                    zero++;\\n                }\\n                else{\\n                    one++;\\n                }\\n            }\\n            arr1[left][0]=zero;\\n            arr1[left][1]=one;\\n            left++;\\n        }\\n\\n        for(int i=top_dummy;i<=bottom;i++)\\n        {\\n            for(int j=left_dummy;j<=right;j++)\\n            {\\n                result[i][j]=arr[i][1]+arr1[j][1]-arr[i][0]-arr1[j][0];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int rows=grid.length;\\n        int cols=grid[0].length;\\n        int result[][]=new int[rows][cols];\\n        int left=0;\\n        int right=cols-1;\\n        int top=0;\\n        int bottom=rows-1;\\n        int top_dummy=0;\\n        int left_dummy=0;\\n\\n        int arr[][]=new int[rows][2];\\n        while(top<=bottom)\\n        {\\n            int zero=0;\\n            int one=0;\\n            for(int x=left;x<=right;x++)\\n            {\\n                if(grid[top][x]==0)\\n                {\\n                    zero++;\\n                }\\n                else{\\n                    one++;\\n                }\\n            }\\n            arr[top][0]=zero;\\n            arr[top][1]=one;\\n            top++;\\n        }\\n       \\n       top=0;\\n        int arr1[][]=new int[cols][2];\\n        while(left<=right)\\n        {\\n            int zero=0;\\n            int one=0;\\n            for(int x=top;x<=bottom;x++)\\n            {\\n                if(grid[x][left]==0)\\n                {\\n                    zero++;\\n                }\\n                else{\\n                    one++;\\n                }\\n            }\\n            arr1[left][0]=zero;\\n            arr1[left][1]=one;\\n            left++;\\n        }\\n\\n        for(int i=top_dummy;i<=bottom;i++)\\n        {\\n            for(int j=left_dummy;j<=right;j++)\\n            {\\n                result[i][j]=arr[i][1]+arr1[j][1]-arr[i][0]-arr1[j][0];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902307,
                "title": "easy-python3-solution-with-some-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/fb5b4c5b-34ce-4623-b919-b433840905c2_1691905194.684687.png)\\n\\n- We can get better space complexity if we directly modify the grid table.\\n# Time complexity: O(mn)\\n\\n\\n# Code\\n```\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        ## -- diff value in i row and j col\\n        ## ---- Count total number of value 1 in i row and j col and sum them.\\n        ## ---- Count total number of value 0 in i row and j col and sum them.\\n        ## ---- diff[i][j] = (number of value 1) - (number of value 0)\\n\\n        rowLen = len(grid)\\n        colLen = len(grid[0])\\n        ttl_1_rowList = []\\n        ttl_1_colList = [0] * colLen\\n        ## ---- Actully, we don\\'t need to calculate total number of value 0 here.\\n        ## ---- Just calculate when we construct the answer diff table.\\n        #ttl_0_rowList = []\\n        #ttl_0_colList = [0] * colLen\\n\\n        ## -- Count total number of value 1 and 0 in each row and col.\\n        for i in range(0, rowLen):\\n            ttl_1_rowList.append(sum(grid[i]))\\n            for j in range(0, colLen):\\n                if grid[i][j] == 1:\\n                    ttl_1_colList[j] += 1\\n\\n        ## -- Construct the answer list refer to the diff rule in question description.\\n        ## -- We can get better space complexity if we directly modify grid table.\\n        ans = []\\n        for i in range(0, rowLen):\\n            rowList = []\\n            for j in range(0, colLen):\\n                ttl_1 = ttl_1_rowList[i]+ttl_1_colList[j]\\n                ttl_0 = colLen + rowLen - ttl_1\\n                rowList.append(ttl_1 - ttl_0)\\n            ans.append(rowList)\\n            \\n        return ans\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\\n        ## -- diff value in i row and j col\\n        ## ---- Count total number of value 1 in i row and j col and sum them.\\n        ## ---- Count total number of value 0 in i row and j col and sum them.\\n        ## ---- diff[i][j] = (number of value 1) - (number of value 0)\\n\\n        rowLen = len(grid)\\n        colLen = len(grid[0])\\n        ttl_1_rowList = []\\n        ttl_1_colList = [0] * colLen\\n        ## ---- Actully, we don\\'t need to calculate total number of value 0 here.\\n        ## ---- Just calculate when we construct the answer diff table.\\n        #ttl_0_rowList = []\\n        #ttl_0_colList = [0] * colLen\\n\\n        ## -- Count total number of value 1 and 0 in each row and col.\\n        for i in range(0, rowLen):\\n            ttl_1_rowList.append(sum(grid[i]))\\n            for j in range(0, colLen):\\n                if grid[i][j] == 1:\\n                    ttl_1_colList[j] += 1\\n\\n        ## -- Construct the answer list refer to the diff rule in question description.\\n        ## -- We can get better space complexity if we directly modify grid table.\\n        ans = []\\n        for i in range(0, rowLen):\\n            rowList = []\\n            for j in range(0, colLen):\\n                ttl_1 = ttl_1_rowList[i]+ttl_1_colList[j]\\n                ttl_0 = colLen + rowLen - ttl_1\\n                rowList.append(ttl_1 - ttl_0)\\n            ans.append(rowList)\\n            \\n        return ans\\n\\n\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3899374,
                "title": "java-very-easy-and-understandable-line-by-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int onesrow[]=new int[n];//ones in rows\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            onesrow[i]=count;\\n        }\\n        int onescol[]=new int[m];// ones in column\\n        for(int j=0;j<m;j++)\\n        {\\n            int count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            onescol[j]=count;\\n        }\\n         int zerosrow[]=new int[n];//zeros in rows\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            zerosrow[i]=count;\\n        }\\n        int zeroscol[]=new int[m];// zeros in column\\n        for(int j=0;j<m;j++)\\n        {\\n            int count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            zeroscol[j]=count;\\n        }\\n        int ans[][]=new int[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans[i][j]=onesrow[i]+onescol[j]-zerosrow[i]-zeroscol[j];\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int onesrow[]=new int[n];//ones in rows\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            onesrow[i]=count;\\n        }\\n        int onescol[]=new int[m];// ones in column\\n        for(int j=0;j<m;j++)\\n        {\\n            int count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            onescol[j]=count;\\n        }\\n         int zerosrow[]=new int[n];//zeros in rows\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            zerosrow[i]=count;\\n        }\\n        int zeroscol[]=new int[m];// zeros in column\\n        for(int j=0;j<m;j++)\\n        {\\n            int count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            zeroscol[j]=count;\\n        }\\n        int ans[][]=new int[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans[i][j]=onesrow[i]+onescol[j]-zerosrow[i]-zeroscol[j];\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896241,
                "title": "easy-and-simple-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  $$O(M*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M + N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> counter(m + n);\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++) {\\n                counter[i] += grid[i][j];\\n                counter[m + j] += grid[i][j];\\n            }\\n\\n        /*\\n            count_0_i_row = n - count_1_i_row;\\n            count_0_j_column = m - count_1_j_column;\\n        */\\n\\n         for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                grid[i][j] = 2 * (counter[i] + counter[m + j]) - m - n;\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> counter(m + n);\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++) {\\n                counter[i] += grid[i][j];\\n                counter[m + j] += grid[i][j];\\n            }\\n\\n        /*\\n            count_0_i_row = n - count_1_i_row;\\n            count_0_j_column = m - count_1_j_column;\\n        */\\n\\n         for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                grid[i][j] = 2 * (counter[i] + counter[m + j]) - m - n;\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894751,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<int> o(m,0);\\n        vector<int> oc(n,0);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    o[i]++;\\n                    oc[j]++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=2*(o[i]+oc[j])-(n+m);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<int> o(m,0);\\n        vector<int> oc(n,0);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    o[i]++;\\n                    oc[j]++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=2*(o[i]+oc[j])-(n+m);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881087,
                "title": "java-keep-track-of-zeros-ones",
                "content": "# Intuition\\n1. keep track of zeros and ones in each row & columns. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    static class ZeroOne {\\n        int zeros;\\n        int ones;\\n    }\\n\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        Map<Integer, ZeroOne> rows = new HashMap<>();\\n        Map<Integer, ZeroOne> columns = new HashMap<>();\\n\\n        // rows compute\\n        for(int row=0; row<grid.length; row++){\\n            ZeroOne zeroOne = new ZeroOne();\\n            for(int column=0; column<grid[row].length; column++){\\n                int value = grid[row][column];\\n                if(value == 0){\\n                    zeroOne.zeros = zeroOne.zeros + 1;\\n                }else{\\n                    zeroOne.ones = zeroOne.ones + 1;\\n                }\\n            }\\n\\n            rows.put(row, zeroOne);\\n        }\\n\\n        // columns compute\\n        for(int column=0; column<grid[0].length; column++){\\n            ZeroOne zeroOne = new ZeroOne();\\n            for(int row=0; row<grid.length; row++){\\n                int value = grid[row][column];\\n                if(value == 0){\\n                    zeroOne.zeros = zeroOne.zeros + 1;\\n                }else{\\n                    zeroOne.ones = zeroOne.ones + 1;\\n                }\\n            }\\n\\n            columns.put(column, zeroOne);\\n        }\\n\\n        int[][] diffGrid = new int[grid.length][grid[0].length];\\n\\n        for(int row=0; row<grid.length; row++){\\n            for(int column=0; column<grid[row].length; column++){\\n                int diff = rows.get(row).ones + columns.get(column).ones - \\n                           rows.get(row).zeros - columns.get(column).zeros;\\n                diffGrid[row][column] = diff;\\n            }\\n        }\\n\\n        return diffGrid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static class ZeroOne {\\n        int zeros;\\n        int ones;\\n    }\\n\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        Map<Integer, ZeroOne> rows = new HashMap<>();\\n        Map<Integer, ZeroOne> columns = new HashMap<>();\\n\\n        // rows compute\\n        for(int row=0; row<grid.length; row++){\\n            ZeroOne zeroOne = new ZeroOne();\\n            for(int column=0; column<grid[row].length; column++){\\n                int value = grid[row][column];\\n                if(value == 0){\\n                    zeroOne.zeros = zeroOne.zeros + 1;\\n                }else{\\n                    zeroOne.ones = zeroOne.ones + 1;\\n                }\\n            }\\n\\n            rows.put(row, zeroOne);\\n        }\\n\\n        // columns compute\\n        for(int column=0; column<grid[0].length; column++){\\n            ZeroOne zeroOne = new ZeroOne();\\n            for(int row=0; row<grid.length; row++){\\n                int value = grid[row][column];\\n                if(value == 0){\\n                    zeroOne.zeros = zeroOne.zeros + 1;\\n                }else{\\n                    zeroOne.ones = zeroOne.ones + 1;\\n                }\\n            }\\n\\n            columns.put(column, zeroOne);\\n        }\\n\\n        int[][] diffGrid = new int[grid.length][grid[0].length];\\n\\n        for(int row=0; row<grid.length; row++){\\n            for(int column=0; column<grid[row].length; column++){\\n                int diff = rows.get(row).ones + columns.get(column).ones - \\n                           rows.get(row).zeros - columns.get(column).zeros;\\n                diffGrid[row][column] = diff;\\n            }\\n        }\\n\\n        return diffGrid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881045,
                "title": "simple-rust-with-iterators",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn ones_minus_zeros(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let m = grid.len() as i32;\\n        let n = grid[0].len() as i32;\\n\\n        let counts_on_rows = grid\\n            .iter()\\n            .map(|row| {\\n                let number_of_zeros_on_row = row\\n                    .iter()\\n                    .filter(|&&val| {\\n                        val == 0\\n                    })\\n                    .count() as i32;\\n                vec![number_of_zeros_on_row, n - number_of_zeros_on_row]\\n            })\\n            .collect::<Vec<Vec<i32>>>();\\n        \\n        let counts_on_cols = (0..n as usize)\\n            .map(|col_index| {\\n                let number_of_zeros_on_col = grid\\n                    .iter()\\n                    .map(|row| {\\n                        row[col_index]\\n                    })\\n                    .filter(|&val| {\\n                        val == 0\\n                    })\\n                    .count() as i32;\\n                vec![number_of_zeros_on_col, m - number_of_zeros_on_col]\\n            })\\n            .collect::<Vec<Vec<i32>>>();\\n\\n        (0..m as usize)\\n            .map(|row_index| {\\n                (0..n as usize)\\n                    .map(|col_index| {\\n                        counts_on_rows[row_index][1] + counts_on_cols[col_index][1] - counts_on_rows[row_index][0] - counts_on_cols[col_index][0]\\n                    })\\n                    .collect::<Vec<i32>>()\\n            })\\n            .collect::<Vec<Vec<i32>>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn ones_minus_zeros(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let m = grid.len() as i32;\\n        let n = grid[0].len() as i32;\\n\\n        let counts_on_rows = grid\\n            .iter()\\n            .map(|row| {\\n                let number_of_zeros_on_row = row\\n                    .iter()\\n                    .filter(|&&val| {\\n                        val == 0\\n                    })\\n                    .count() as i32;\\n                vec![number_of_zeros_on_row, n - number_of_zeros_on_row]\\n            })\\n            .collect::<Vec<Vec<i32>>>();\\n        \\n        let counts_on_cols = (0..n as usize)\\n            .map(|col_index| {\\n                let number_of_zeros_on_col = grid\\n                    .iter()\\n                    .map(|row| {\\n                        row[col_index]\\n                    })\\n                    .filter(|&val| {\\n                        val == 0\\n                    })\\n                    .count() as i32;\\n                vec![number_of_zeros_on_col, m - number_of_zeros_on_col]\\n            })\\n            .collect::<Vec<Vec<i32>>>();\\n\\n        (0..m as usize)\\n            .map(|row_index| {\\n                (0..n as usize)\\n                    .map(|col_index| {\\n                        counts_on_rows[row_index][1] + counts_on_cols[col_index][1] - counts_on_rows[row_index][0] - counts_on_cols[col_index][0]\\n                    })\\n                    .collect::<Vec<i32>>()\\n            })\\n            .collect::<Vec<Vec<i32>>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3868916,
                "title": "tricky-but-easy-presence-of-mind-needed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> onesRowi(n), zerosRowi(n), onesColj(m), zerosColj(m); \\n\\n        for(int i=0; i<n; i++){\\n            int zeros = 0;\\n            int ones = 0;\\n\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 1){\\n                    ones ++;\\n                }\\n                else{\\n                    zeros ++;\\n                }\\n            }\\n\\n            onesRowi[i] = ones;\\n            zerosRowi[i] = zeros;\\n        }\\n\\n\\n\\n\\n        for(int i=0; i<m; i++){\\n            int zeros = 0;\\n            int ones = 0;\\n\\n            for(int j=0; j<n; j++){\\n                if(grid[j][i] == 1){\\n                    ones ++;\\n                }\\n                else{\\n                    zeros ++;\\n                }\\n            }\\n\\n            onesColj[i] = ones;\\n            zerosColj[i] = zeros;\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                grid[i][j]=onesRowi[i]- zerosRowi[i] + onesColj[j] - zerosColj[j];\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> onesRowi(n), zerosRowi(n), onesColj(m), zerosColj(m); \\n\\n        for(int i=0; i<n; i++){\\n            int zeros = 0;\\n            int ones = 0;\\n\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 1){\\n                    ones ++;\\n                }\\n                else{\\n                    zeros ++;\\n                }\\n            }\\n\\n            onesRowi[i] = ones;\\n            zerosRowi[i] = zeros;\\n        }\\n\\n\\n\\n\\n        for(int i=0; i<m; i++){\\n            int zeros = 0;\\n            int ones = 0;\\n\\n            for(int j=0; j<n; j++){\\n                if(grid[j][i] == 1){\\n                    ones ++;\\n                }\\n                else{\\n                    zeros ++;\\n                }\\n            }\\n\\n            onesColj[i] = ones;\\n            zerosColj[i] = zeros;\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                grid[i][j]=onesRowi[i]- zerosRowi[i] + onesColj[j] - zerosColj[j];\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853290,
                "title": "c-keeping-track-of-1-s-in-row-and-col",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we keep track of the number of 1\\'s in each row and column by summing up the numbers. The number of zeroes in each row and column can be found by (size of row or col) - (number of 1\\'s in row or col)\\n```rowZeros = rowSize - rowOnes```\\n```colZeros = colSize - colOnes```\\n\\nThe question requires us to find \\n```rowOnes + colOnes - rowZeros - colZeros```\\n\\nwhich can be rewritten as \\n```rowOnes + colOnes - (rowSize - rowOnes) - (colSize - colOnes)```\\n\\nand can be simplified to \\n```2 * rowOnes - rowSize + 2 * colOnes - colSize```\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** onesMinusZeros(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = gridSize;\\n    *returnColumnSizes = calloc(gridSize, sizeof(int));\\n\\n    for (int i = 0; i < gridSize; i++){\\n        (*returnColumnSizes)[i] = *gridColSize;\\n    }\\n\\n    // Keeping track of the number of 1\\'s in each row and column\\n    int rowOnes[gridSize];\\n    int colOnes[*gridColSize];\\n    memset(rowOnes, 0, gridSize * sizeof(int));\\n    memset(colOnes, 0, *gridColSize * sizeof(int));\\n\\n    for (int row = 0; row < gridSize; row++){\\n        for (int col = 0; col < *gridColSize; col++){\\n            if (grid[row][col] == 1){\\n                rowOnes[row]++;\\n                colOnes[col]++;\\n            }\\n        }\\n    }\\n\\n    for (int row = 0; row < gridSize; row++){\\n        for (int col = 0; col < *gridColSize; col++){\\n            grid[row][col] = rowOnes[row] * 2 - gridSize + colOnes[col] * 2 - *gridColSize;\\n        }\\n    }\\n\\n    return grid;\\n}\\n```\\n\\nHope this helps!",
                "solutionTags": [
                    "C"
                ],
                "code": "```rowZeros = rowSize - rowOnes```\n```colZeros = colSize - colOnes```\n```rowOnes + colOnes - rowZeros - colZeros```\n```rowOnes + colOnes - (rowSize - rowOnes) - (colSize - colOnes)```\n```2 * rowOnes - rowSize + 2 * colOnes - colSize```\n```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** onesMinusZeros(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = gridSize;\\n    *returnColumnSizes = calloc(gridSize, sizeof(int));\\n\\n    for (int i = 0; i < gridSize; i++){\\n        (*returnColumnSizes)[i] = *gridColSize;\\n    }\\n\\n    // Keeping track of the number of 1\\'s in each row and column\\n    int rowOnes[gridSize];\\n    int colOnes[*gridColSize];\\n    memset(rowOnes, 0, gridSize * sizeof(int));\\n    memset(colOnes, 0, *gridColSize * sizeof(int));\\n\\n    for (int row = 0; row < gridSize; row++){\\n        for (int col = 0; col < *gridColSize; col++){\\n            if (grid[row][col] == 1){\\n                rowOnes[row]++;\\n                colOnes[col]++;\\n            }\\n        }\\n    }\\n\\n    for (int row = 0; row < gridSize; row++){\\n        for (int col = 0; col < *gridColSize; col++){\\n            grid[row][col] = rowOnes[row] * 2 - gridSize + colOnes[col] * 2 - *gridColSize;\\n        }\\n    }\\n\\n    return grid;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1697145,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1868530,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1931808,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1928918,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1742008,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 2018305,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1985384,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1783357,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1761544,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1720732,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1697145,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1868530,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1931808,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1928918,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1742008,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 2018305,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1985384,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1783357,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1761544,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            },
            {
                "id": 1720732,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "it\\'s quite a good question tests your basics of  vectors"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice question, It was a challenge for my brain lol "
                    },
                    {
                        "username": "xaocccc",
                        "content": "You can call this problem Time Limit Exceeded."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koi sawal hi nhi uthta TLE aane ka"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "*Are these the best possible complexities?*\\n**Time Complexity : O(Row*Col + Row*Col + Row*Col)**\\n**Space Complexity : O(Row + Col + Row*Col)**"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Yes, in my code, the TC is O(m*n) and SC and only (row+col)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> Oner(m),Onec(n);\\n\\n        for(int i=0; i<m; i++){\\n            int one = 0;\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]){\\n                    one++;\\n                    Onec[j]++;\\n                }\\n            }\\n            Oner[i] = one;\\n        }\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = Oner[i] + Onec[j] - (m-Oner[i]) - (n-Onec[j]);\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};```"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: instead of brute force, use auxiliary arrays to reduce counting work:)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can solve this question using two 1D vectors only with (m*n) TC and SC (m+n) only, TRY IT!!"
                    },
                    {
                        "username": "user0463au",
                        "content": "Using two 1D arrays to record (number of ones - number of zeros).\\nMoreover, you can even reduce the space complexity to only one 1D array.\\n(If space is critical, choose the smaller size to init an 1D auxiliary array)\\nSpace: $$O(min(m, n))$$ and Time: $$O(m * n)$$"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "You can do it using only two 1D vectors only,\n\n\nSolution:\n[leetcode](https://leetcode.com)https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/submissions/1003313074/"
                    },
                    {
                        "username": "adarsh_shahi",
                        "content": "I am getting TLE can anyone improve its time complexity\n\n\n\n  class Solution {\n      public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n\n        for(int i = 0; i < diff.length; i++){\n             int oneRow = countOneRow(grid[i]);\n            int zeroRow = grid[i].length - oneRow;\n            for(int j = 0; j < diff[i].length; j++){\n               \n\n                int oneCol = countOneCol(grid, j);\n                int zeroCol = grid.length - oneCol;\n                \n                diff[i][j] = oneRow + oneCol - zeroRow - zeroCol;\n\n            }\n        }\n        return diff;\n\n    }\n    int countOneRow(int[] g){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i] == 1)\n                count++;\n        }\n        return count;\n    }\n    int countOneCol(int[][] g, int c){\n        int count = 0;\n        for(int i = 0; i < g.length; i++){\n            if(g[i][c] == 1) count++;\n        }\n        return count;\n    }\n} "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2482_Diff_Betw_1_and_0_in_Row_and_Col.CPP"
                    },
                    {
                        "username": "Pockerman20",
                        "content": "Best way to learn more about matrix in  C/Java/C++"
                    }
                ]
            }
        ]
    }
]