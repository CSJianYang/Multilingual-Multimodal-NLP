[
    {
        "title": "Find the Score of All Prefixes of an Array",
        "question_content": "We define the conversion array conver of an array arr as follows:\n\n\tconver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.\n\nWe also define the score of an array arr as the sum of the values of the conversion array of arr.\nGiven a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,7,5,10]\nOutput: [4,10,24,36,56]\nExplanation: \nFor the prefix [2], the conversion array is [4] hence the score is 4\nFor the prefix [2, 3], the conversion array is [4, 6] hence the score is 10\nFor the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24\nFor the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36\nFor the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56\n\nExample 2:\n\nInput: nums = [1,1,2,4,8,16]\nOutput: [2,4,8,16,32,64]\nExplanation: \nFor the prefix [1], the conversion array is [2] hence the score is 2\nFor the prefix [1, 1], the conversion array is [2, 2] hence the score is 4\nFor the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8\nFor the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16\nFor the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32\nFor the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 3420109,
                "title": "c-python3-prefix-sum",
                "content": "\\n# Intuition\\nFirst find `conver` array and then find its prefix sum\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python3**:\\n```\\ndef findPrefixScore(self, nums: List[int]) -> List[int]:\\n    m, conver = 0, []\\n    for x in nums:\\n        m = max(m, x)\\n        conver.append(x + m)\\n    return accumulate(conver)\\n```\\n1 liner credits [@SunnyvaleCA](https://leetcode.com/SunnyvaleCA/):\\n```\\ndef findPrefixScore(self, A):\\n    return accumulate(n+maxN for n,maxN in zip(A, accumulate(A,max)))\\n\\n```\\n\\n**C++**:\\n```\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n      vector<long long> pre;\\n      long long m = 0, s = 0;\\n      for(int x : nums) {\\n          m = max(m, (long long)x);\\n          s += x + m;\\n          pre.push_back(s);\\n      }\\n      return pre;\\n  }",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\ndef findPrefixScore(self, nums: List[int]) -> List[int]:\\n    m, conver = 0, []\\n    for x in nums:\\n        m = max(m, x)\\n        conver.append(x + m)\\n    return accumulate(conver)\\n```\n```\\ndef findPrefixScore(self, A):\\n    return accumulate(n+maxN for n,maxN in zip(A, accumulate(A,max)))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420907,
                "title": "c-easiest-approach-easy-to-understand-simple-logic-with-comments",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nO(n)\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nO(n)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\r\\n        vector<long long> b;  \\r\\n        vector<long long> ans;\\r\\n        int n = nums.size();\\r\\n        int mm= INT_MIN;\\r\\n        long long aa = 0;\\r\\n        for(int  i = 0 ; i < n; i++){        //0, 1...\\r\\n            long long a  = 0;\\r\\n            mm = max(mm, nums[i]);        // 2 , 3...\\r\\n            a = nums[i] + mm;             //2+2 = 4, 3+3  = 6, ..\\r\\n            b.push_back(a);               // b=[4,6,]...\\r\\n            aa += b[i];                   //0+4 = 4, 4+6 = 10,...  \\r\\n            ans.push_back(aa);            //ans = [4,10,...]\\r\\n        }\\r\\n        return ans;                      \\r\\n    }\\r\\n};\\r\\n\\r\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\r\\npublic:\\r\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\r\\n        vector<long long> b;  \\r\\n        vector<long long> ans;\\r\\n        int n = nums.size();\\r\\n        int mm= INT_MIN;\\r\\n        long long aa = 0;\\r\\n        for(int  i = 0 ; i < n; i++){        //0, 1...\\r\\n            long long a  = 0;\\r\\n            mm = max(mm, nums[i]);        // 2 , 3...\\r\\n            a = nums[i] + mm;             //2+2 = 4, 3+3  = 6, ..\\r\\n            b.push_back(a);               // b=[4,6,]...\\r\\n            aa += b[i];                   //0+4 = 4, 4+6 = 10,...  \\r\\n            ans.push_back(aa);            //ans = [4,10,...]\\r\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3420302,
                "title": "prefix-sum-very-simple-easy-to-understand-solution",
                "content": "<b> Please Up Vote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum = 0, mx = 0;\\n        for(auto n: nums){\\n            if(mx < n) mx = n;\\n            sum += n + mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum = 0, mx = 0;\\n        for(auto n: nums){\\n            if(mx < n) mx = n;\\n            sum += n + mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420254,
                "title": "c-prefix-sum-easy-to-understand-superfast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use the prefix sum approach to make a `conver` vector and then `ans` vector by applying prefix sum approach on `conver` message.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Store `2*nums[0]` in `conver[0]`.\\n- Then run a loop and assign `conver[i] = nums[i] +0ll+ mx`, where `mx` is variable having the maximum running number.\\n- Then, at last simply make a prefix sum array `ans` of `conver` vector and return it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        vector<long long> conver(n);\\n        conver[0] = 2*nums[0];\\n        int mx = nums[0];\\n        for(int i=1; i<n; i++){\\n            mx = max(mx, nums[i]);\\n            conver[i] = nums[i] +0ll+ mx;\\n        }\\n        ans[0]=conver[0];\\n        for(int i=1; i<n; i++){\\n            ans[i] = ans[i-1] + 0ll+conver[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n//  PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        vector<long long> conver(n);\\n        conver[0] = 2*nums[0];\\n        int mx = nums[0];\\n        for(int i=1; i<n; i++){\\n            mx = max(mx, nums[i]);\\n            conver[i] = nums[i] +0ll+ mx;\\n        }\\n        ans[0]=conver[0];\\n        for(int i=1; i<n; i++){\\n            ans[i] = ans[i-1] + 0ll+conver[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n//  PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420062,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420024,
                "title": "java-python-3-1-pass-codes",
                "content": "\\n\\n```java\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] score = new long[n + 1];\\n        for (int i = 0, max = 0; i < n; ++i) {\\n            max = Math.max(max, nums[i]);\\n            score[i + 1] += score[i] + max + nums[i];\\n        }\\n        return Arrays.copyOfRange(score, 1, n + 1);        \\n    }\\n```\\n```python\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        score, mx = [0], 0\\n        for num in nums:\\n            mx = max(mx, num)\\n            score.append(score[-1] + num + mx)\\n        return score[1 :]\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] score = new long[n + 1];\\n        for (int i = 0, max = 0; i < n; ++i) {\\n            max = Math.max(max, nums[i]);\\n            score[i + 1] += score[i] + max + nums[i];\\n        }\\n        return Arrays.copyOfRange(score, 1, n + 1);        \\n    }\\n```\n```python\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        score, mx = [0], 0\\n        for num in nums:\\n            mx = max(mx, num)\\n            score.append(score[-1] + num + mx)\\n        return score[1 :]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3419972,
                "title": "c-java-python-intuition-with-explanation-simple-prefix-sum-time-o-n",
                "content": "# Intuition\\n$conver[i] = nums[i] + \\\\displaystyle\\\\max_{0 \\\\le j \\\\le i} (nums[j])$\\n$score(nums) = \\\\sum conver(nums)$\\n\\n$ans[i] = score(nums[0...i])$\\n$ans[i] = \\\\sum conver(nums[0...i])$\\n\\n$ans[i]$ is the the prefix sum of $conver[i]$\\n\\n$ans[i] = \\\\left(\\\\displaystyle\\\\sum conver(nums[0...i-1])\\\\right) + conver[i]$\\n$ans[i] = ans[i - 1] + conver[i]$\\n$ans[i] = ans[i - 1] + nums[i] + \\\\displaystyle\\\\max_{0 \\\\le j \\\\le i} (nums[j])$\\n\\n# Approach\\nMaintain $maximum$ value till current index.\\n$ans[i] = ans[i - 1] + nums[i] + maximum$\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(), maximum = nums[0];\\n        vector<long long> result(n);\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, maximum = nums[0];\\n        long[] result = new long[n];\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = Math.max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        result = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            result.append(result[i - 1] + nums[i] + maximum)\\n        return result\\n```\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(), maximum = nums[0];\\n        vector<long long> result(n);\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, maximum = nums[0];\\n        long[] result = new long[n];\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = Math.max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        result = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            result.append(result[i - 1] + nums[i] + maximum)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420214,
                "title": "explained-simple-and-clear-python-code",
                "content": "# Intuition\\nTo calculate the score of each prefix of the input array nums, we need to calculate the conversion array conver for each prefix, and then sum up the elements of the conversion array to get the prefix score. To calculate the conver array for each prefix, we need to find the maximum value of the input array up to that index, and then add it to each element of the prefix.\\n\\n\\n# Approach\\n1. Initialize an array ans of length n with all elements initialized to 0.\\n2. Initialize a variable max_val to negative infinity.\\n3. Loop through the input array nums:\\na. Update the max_val variable to the maximum value seen so far.\\nb. Calculate the conversion value conver for the current index by adding the current element of the input array to the max_val.\\nc. Update the corresponding element of the ans array with the conver value.\\n4. Initialize an array res of length n with all elements initialized to 0.\\n5. Initialize a variable s to 0.\\n6. Loop through the ans array:\\na. Add the current element to the s variable.\\nb. Update the corresponding element of the res array with the current value of s.\\n7. Return the res array.\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input array nums. We need to loop through the array twice, once to calculate the ans array and once to calculate the res array, both of which take O(n) time.\\n- Space complexity:\\nO(n), we need to use two arrays of length n, ans and res, which take O(n) space in total. Additionally, we use a few constant variables, which take O(1) space.\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420127,
                "title": "clean-and-simple-solution-using-heap-100-faster",
                "content": "```class Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        heap = [-nums[0]]\\n        result = []\\n        runningSum = 0\\n        for num in nums:\\n            maxSum = max(num, -1 * heapq.heappop(heap))\\n            result.append(runningSum + num + maxSum)\\n            runningSum += maxSum+num\\n            heappush(heap,- maxSum)\\n        return result\\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        heap = [-nums[0]]\\n        result = []\\n        runningSum = 0\\n        for num in nums:\\n            maxSum = max(num, -1 * heapq.heappop(heap))\\n            result.append(runningSum + num + maxSum)\\n            runningSum += maxSum+num\\n            heappush(heap,- maxSum)\\n        return result\\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3420054,
                "title": "short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            max = Math.max(max,nums[i]);\\n            res[i] = nums[i] + max + (i==0 ? 0 : res[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            max = Math.max(max,nums[i]);\\n            res[i] = nums[i] + max + (i==0 ? 0 : res[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420279,
                "title": "c-o-n-prefix-sum-clean-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n,-1);\\n        long long l=nums[0];\\n        //calculating the conver[i]\\n        for(int i=0;i<n;++i){\\n            if(l<nums[i])l = nums[i];\\n            ans[i]=nums[i]+l;\\n        }\\n        //taking the prefix sum\\n        for(int i=1;i<n;++i)ans[i]+=ans[i-1];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n,-1);\\n        long long l=nums[0];\\n        //calculating the conver[i]\\n        for(int i=0;i<n;++i){\\n            if(l<nums[i])l = nums[i];\\n            ans[i]=nums[i]+l;\\n        }\\n        //taking the prefix sum\\n        for(int i=1;i<n;++i)ans[i]+=ans[i-1];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420129,
                "title": "cpp-prefix-sum",
                "content": "```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        vector<ll> ans;\\n        ll mx = 0LL, s = 0LL;\\n        for(int x : v) {\\n            mx = max(mx,(ll)x);\\n            s += (x + mx);\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        vector<ll> ans;\\n        ll mx = 0LL, s = 0LL;\\n        for(int x : v) {\\n            mx = max(mx,(ll)x);\\n            s += (x + mx);\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421148,
                "title": "c-easy-prefix-sum",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& a) {\\n        vector<long long>v;\\n        v.push_back(a[0]+a[0]);\\n        long long mx=a[0];\\n        for(int i=1;i<a.size();i++){\\n            long long an=a[i];\\n            if(mx<a[i])mx=a[i];\\n            an+=mx;\\n            long long h=v[i-1]+an;\\n            v.push_back(h);\\n        }\\n        return v;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/fcf80d18-7665-46c4-a0fb-5038ce657498_1681589962.770271.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& a) {\\n        vector<long long>v;\\n        v.push_back(a[0]+a[0]);\\n        long long mx=a[0];\\n        for(int i=1;i<a.size();i++){\\n            long long an=a[i];\\n            if(mx<a[i])mx=a[i];\\n            an+=mx;\\n            long long h=v[i-1]+an;\\n            v.push_back(h);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420130,
                "title": "simple-prefix-sum",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        max_, sum_ = 0, 0\\n        res = []\\n        for num in nums:\\n            max_ = max(max_, num)\\n            res.append(num + max_)\\n        last = 0\\n        for i, val in enumerate(res):\\n            res[i] += last\\n            last += val\\n        return res\\n```\\nUpVote, if you like it **:)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        max_, sum_ = 0, 0\\n        res = []\\n        for num in nums:\\n            max_ = max(max_, num)\\n            res.append(num + max_)\\n        last = 0\\n        for i, val in enumerate(res):\\n            res[i] += last\\n            last += val\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554506,
                "title": "c-time-o-n-space-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> v(n,0);\\n        v[0] += nums[0]*2;\\n        long long mx = nums[0];\\n        for(int i = 1; i < n; i++){\\n            mx = max(nums[i]*1LL,mx);\\n            v[i] = mx+nums[i];\\n            v[i] += v[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> v(n,0);\\n        v[0] += nums[0]*2;\\n        long long mx = nums[0];\\n        for(int i = 1; i < n; i++){\\n            mx = max(nums[i]*1LL,mx);\\n            v[i] = mx+nums[i];\\n            v[i] += v[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438048,
                "title": "short-and-crisp-beginner-friendly-one-pass-o-n-time-complexity",
                "content": "\\n\\n# Approach\\nJust keep track of maximum element before i+1 index and to take on prefix array to store values at same time.\\n\\n# Complexity\\n- Time complexity:\\no(n);\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n =  nums.size();\\n        vector<long long > ans(n,0);//prefix Array to return\\n        int maxi =  nums[0];\\n        ans[0] = 2*nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            maxi = max(maxi,nums[i]); //track of maxi before i+1 index\\n            nums[i]+=maxi; \\n            ans[i]+=ans[i-1]+nums[i];//Making prefix array to return\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n =  nums.size();\\n        vector<long long > ans(n,0);//prefix Array to return\\n        int maxi =  nums[0];\\n        ans[0] = 2*nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            maxi = max(maxi,nums[i]); //track of maxi before i+1 index\\n            nums[i]+=maxi; \\n            ans[i]+=ans[i-1]+nums[i];//Making prefix array to return\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423547,
                "title": "c-easiest-approach-prefix-sum-beginner-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use Prefix-Sum method here to find maximum element till every i\\'th index.\\nThen we will add out prefix_max at i\\'th position to our original vector at i\\'th position.\\nAt last we will take sum upto every i\\'th index and push it into our answer vector.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        \\n        vector<long long> prefix_max;\\n        int max_current=nums[0];\\n        prefix_max.push_back(max_current);\\n        for(int i=1;i<n;i++)\\n        {\\n            max_current=max(max_current,nums[i]);\\n            prefix_max.push_back(max_current);\\n        }\\n        \\n        vector<long long> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]+=prefix_max[i];\\n        }\\n        \\n        long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n![2ddedd60-39d6-4167-9b77-88e10400f044_1673586388.8794823.jpeg](https://assets.leetcode.com/users/images/ca1f0d37-8838-454f-b4e8-dc22323e3ed3_1681647899.5235333.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        \\n        vector<long long> prefix_max;\\n        int max_current=nums[0];\\n        prefix_max.push_back(max_current);\\n        for(int i=1;i<n;i++)\\n        {\\n            max_current=max(max_current,nums[i]);\\n            prefix_max.push_back(max_current);\\n        }\\n        \\n        vector<long long> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]+=prefix_max[i];\\n        }\\n        \\n        long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421177,
                "title": "one-liner",
                "content": "**Python3**\\n```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420325,
                "title": "c-o-n-solution",
                "content": "\\n# Approach: Prefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the answer array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long maxy = 0, conver = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            maxy = nums[i] > maxy ? nums[i] : maxy;\\n            conver = maxy + nums[i];\\n            sum += conver;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long maxy = 0, conver = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            maxy = nums[i] > maxy ? nums[i] : maxy;\\n            conver = maxy + nums[i];\\n            sum += conver;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420219,
                "title": "simple-o-n",
                "content": "# Intuition\\nUse memoization\\n\\n# Approach\\nIterate the initial array. Store both max so far and score of i-1. For ith element max(i) = max(max(i-1), nums(i)), score(i) = score(i-1) + max(i) + nums(i).\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let sum = 0\\n    let max = nums[0]\\n    \\n    let res = []\\n    for(let i = 0; i < nums.length; i++){\\n        max = Math.max(nums[i], max);\\n        sum += (max + nums[i])\\n        res.push(sum);\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let sum = 0\\n    let max = nums[0]\\n    \\n    let res = []\\n    for(let i = 0; i < nums.length; i++){\\n        max = Math.max(nums[i], max);\\n        sum += (max + nums[i])\\n        res.push(sum);\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3419995,
                "title": "python-1-liner-solution",
                "content": "# **Explanation**\\nGet the accumulate max array of  `pre_max`\\nAnd return the accumulate sum of `A + max_acc`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n\\n**Python**\\n```py\\n    def findPrefixScore(self, A: List[int]) -> List[int]:\\n        acc_max = accumulate(A, max)\\n        return list(accumulate(map(sum, zip(A, acc_max))))\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def findPrefixScore(self, A: List[int]) -> List[int]:\\n        acc_max = accumulate(A, max)\\n        return list(accumulate(map(sum, zip(A, acc_max))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3443265,
                "title": "c-o-n-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHello guys, Here you just have to simply iterate the array and keep a max count  till  ith index.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Here I am explaining my approach :\\n1.) Simply iterate the array from 1st index to last.\\n2.) Keep a max to keep account of maximum till the ith index. \\n3.) Simply add this max to current index to get the value.\\n4.) Now you have sum the elements of this ans array to get final result.\\n5.) Taken a cur pointer and with the help of it added them , this cur contains sum till (i-1)th index.\\n6.)Keep in mind to take long long variable otherwise you will get TLE\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N+N) \\ni.e. O(2*N) ~ O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2*N) [for sum and ans array]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        vector<long long > ans,sum;\\n        int n = nums.size();\\n\\n        long long max = nums[0];\\n        sum.push_back(2*nums[0]);\\n        ans.push_back(2*nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>max) max = nums[i];\\n\\n            sum.push_back(nums[i]+max);\\n        }\\n        \\n        long long cur = sum[0];\\n        \\n        for(int i=1;i<n;i++){\\n            long long summ =0;\\n            summ = sum[i]+cur;\\n            ans.push_back(summ);\\n            cur = summ;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        vector<long long > ans,sum;\\n        int n = nums.size();\\n\\n        long long max = nums[0];\\n        sum.push_back(2*nums[0]);\\n        ans.push_back(2*nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>max) max = nums[i];\\n\\n            sum.push_back(nums[i]+max);\\n        }\\n        \\n        long long cur = sum[0];\\n        \\n        for(int i=1;i<n;i++){\\n            long long summ =0;\\n            summ = sum[i]+cur;\\n            ans.push_back(summ);\\n            cur = summ;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420212,
                "title": "simple-c-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long > temp(n);\\n        int maxval=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n             maxval=max(maxval,nums[i]);\\n             temp[i]=nums[i]+maxval;\\n            if(i>0)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n           \\n            \\n        }\\n \\n        \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long > temp(n);\\n        int maxval=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n             maxval=max(maxval,nums[i]);\\n             temp[i]=nums[i]+maxval;\\n            if(i>0)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n           \\n            \\n        }\\n \\n        \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420118,
                "title": "c-prefix-sum-short-sweet-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        vector<long long int> mx(n),dp(n);\\n        dp[0] = 2*nums[0],mx[0] = nums[0];\\n        for(i = 1; i < n; i++){\\n            mx[i] = max(mx[i-1],nums[i]*1LL);\\n        }\\n        for(i = 1; i < n; i++){\\n            dp[i] = nums[i]+dp[i-1]+mx[i];\\n        }\\n        return dp;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        vector<long long int> mx(n),dp(n);\\n        dp[0] = 2*nums[0],mx[0] = nums[0];\\n        for(i = 1; i < n; i++){\\n            mx[i] = max(mx[i-1],nums[i]*1LL);\\n        }\\n        for(i = 1; i < n; i++){\\n            dp[i] = nums[i]+dp[i-1]+mx[i];\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420032,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<ll> ans;\\n        int n = nums.size();\\n        ll sum = 0,maxVal=0,val;\\n        for(int i=0;i<n;i++){\\n            maxVal = max(maxVal, (ll)nums[i]);\\n            val = nums[i] + maxVal;\\n            sum += val;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<ll> ans;\\n        int n = nums.size();\\n        ll sum = 0,maxVal=0,val;\\n        for(int i=0;i<n;i++){\\n            maxVal = max(maxVal, (ll)nums[i]);\\n            val = nums[i] + maxVal;\\n            sum += val;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966852,
                "title": "fastest-efficient-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        long long  prevMax = -1 ;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            prevMax = max(prevMax, (long long)nums[i]) ;\\n            if(i == 0){\\n                conver.push_back(prevMax + nums[i]) ;\\n            }else{\\n                conver.push_back(prevMax + nums[i] + conver.back()) ;\\n            }\\n        }\\n        return conver ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        long long  prevMax = -1 ;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            prevMax = max(prevMax, (long long)nums[i]) ;\\n            if(i == 0){\\n                conver.push_back(prevMax + nums[i]) ;\\n            }else{\\n                conver.push_back(prevMax + nums[i] + conver.back()) ;\\n            }\\n        }\\n        return conver ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920265,
                "title": "o-n-approach",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\nFor storing the answer\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> conver(n);\\n        vector<long long> score(n);\\n        \\n        \\n        \\n        long long prefixMax = nums[0];\\n        conver[0] = nums[0] + prefixMax;\\n        score[0] = conver[0];\\n        long long prefixSum = conver[0];\\n        \\n        for(int i=1;i<n;i++) {\\n            prefixMax = max(static_cast<long long>(nums[i]), prefixMax);  // Use long long here\\n            conver[i] = static_cast<long long>(nums[i]) + prefixMax;      // Use long long here\\n            \\n            \\n            prefixSum += conver[i];\\n            \\n            score[i] = prefixSum;\\n            \\n            \\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> conver(n);\\n        vector<long long> score(n);\\n        \\n        \\n        \\n        long long prefixMax = nums[0];\\n        conver[0] = nums[0] + prefixMax;\\n        score[0] = conver[0];\\n        long long prefixSum = conver[0];\\n        \\n        for(int i=1;i<n;i++) {\\n            prefixMax = max(static_cast<long long>(nums[i]), prefixMax);  // Use long long here\\n            conver[i] = static_cast<long long>(nums[i]) + prefixMax;      // Use long long here\\n            \\n            \\n            prefixSum += conver[i];\\n            \\n            score[i] = prefixSum;\\n            \\n            \\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849823,
                "title": "simple-code-with-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe simply iterate over array keeping track of maximum value and also storing the total sum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif the array is is less than or eqaul maxi then simply add the maxi to that element and store it ,if not add the same maxi twice and push\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        int maxi=nums[0];\\n        long long tot=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=maxi){\\n                tot+=nums[i]+maxi;\\n                ans.push_back(tot);\\n            }\\n            else{\\n                 maxi=nums[i];\\n                 tot+=2*maxi;\\n                 ans.push_back(tot);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        int maxi=nums[0];\\n        long long tot=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=maxi){\\n                tot+=nums[i]+maxi;\\n                ans.push_back(tot);\\n            }\\n            else{\\n                 maxi=nums[i];\\n                 tot+=2*maxi;\\n                 ans.push_back(tot);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849219,
                "title": "beats-99-80-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n         int n=nums.size();\\n        vector<long long>ans(n);\\n        ans[0]=2*nums[0];\\n       long long maxi=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            maxi=nums[i];\\n            ans[i]=ans[i-1]+nums[i]+maxi;\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n         int n=nums.size();\\n        vector<long long>ans(n);\\n        ans[0]=2*nums[0];\\n       long long maxi=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            maxi=nums[i];\\n            ans[i]=ans[i-1]+nums[i]+maxi;\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590130,
                "title": "simple-solution-o-n-time-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr= new long[nums.length];\\n        long max=nums[0];\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            max=max<=nums[i]?nums[i]:max;\\n            sum=sum+nums[i]+max;\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr= new long[nums.length];\\n        long max=nums[0];\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            max=max<=nums[i]?nums[i]:max;\\n            sum=sum+nums[i]+max;\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519543,
                "title": "easy-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply traverse the array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep track of max and sum as you go ahead\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nIf you find it helpful then please upvote (thanks)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n = nums.size();\\n       vector<long long> score;\\n       long long max = INT_MIN;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]>max)max = nums[i];\\n           sum += max+nums[i];\\n           score.push_back(sum);\\n       }\\n       return score; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n = nums.size();\\n       vector<long long> score;\\n       long long max = INT_MIN;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]>max)max = nums[i];\\n           sum += max+nums[i];\\n           score.push_back(sum);\\n       }\\n       return score; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444609,
                "title": "java-fastest-runtime-easy-and-elegant-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n     long a = 0;\\n        long max = nums[0];\\n        long[] k = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            k[i] = a + nums[i] + max;\\n            a = k[i];\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n     long a = 0;\\n        long max = nums[0];\\n        long[] k = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            k[i] = a + nums[i] + max;\\n            a = k[i];\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425978,
                "title": "max-val-in-prefix-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        //we will do some precomputation to find the max in the range\\n        vector<int>prefix(nums.size(),-1);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int ele = max(prefix[i-1],nums[i]);\\n            prefix[i] = ele;\\n        }\\n        //we are going to make the ans vector\\n        vector<long long>ans;\\n\\n        //now making ans for the every index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            long long ele = nums[i];\\n            long long tillmax = prefix[i];\\n\\n            if(ans.size() == 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax));\\n                ans.push_back(result);\\n            }\\n            else if(ans.size() > 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax)) + (0LL + ans.back());\\n                ans.push_back(result);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        //we will do some precomputation to find the max in the range\\n        vector<int>prefix(nums.size(),-1);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int ele = max(prefix[i-1],nums[i]);\\n            prefix[i] = ele;\\n        }\\n        //we are going to make the ans vector\\n        vector<long long>ans;\\n\\n        //now making ans for the every index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            long long ele = nums[i];\\n            long long tillmax = prefix[i];\\n\\n            if(ans.size() == 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax));\\n                ans.push_back(result);\\n            }\\n            else if(ans.size() > 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax)) + (0LL + ans.back());\\n                ans.push_back(result);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424772,
                "title": "easy-c-solution-prefix-array",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<long long> conver,score(n,0);\\n        int maxi= INT_MIN;\\n        for (int i=0; i<n; i++){\\n            maxi= max(maxi,nums[i]);\\n            conver.push_back((long long)(nums[i])+maxi);\\n            \\n        }\\n        score[0]= conver[0];\\n        for (int i=1; i<n; i++){\\n            score[i]= score[i-1]+conver[i];\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<long long> conver,score(n,0);\\n        int maxi= INT_MIN;\\n        for (int i=0; i<n; i++){\\n            maxi= max(maxi,nums[i]);\\n            conver.push_back((long long)(nums[i])+maxi);\\n            \\n        }\\n        score[0]= conver[0];\\n        for (int i=1; i<n; i++){\\n            score[i]= score[i-1]+conver[i];\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424575,
                "title": "do-exactly-what-the-question-has-asked",
                "content": "# Solution:\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        // fill the conversion array\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n        }\\n        // define the scores in the same array (prefix sum)\\n        for (int i = 1; i < n; i++) {\\n            c[i] += c[i - 1];\\n        }\\n        return c;\\n    }\\n}\\n```\\n---\\n## Single loop:\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n            if (i > 0) {\\n                c[i] += c[i - 1];\\n            }\\n        }        \\n        return c;\\n    }\\n}\\n```\\n---\\n### Time complexity: $$O(n)$$\\n### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        // fill the conversion array\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n        }\\n        // define the scores in the same array (prefix sum)\\n        for (int i = 1; i < n; i++) {\\n            c[i] += c[i - 1];\\n        }\\n        return c;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n            if (i > 0) {\\n                c[i] += c[i - 1];\\n            }\\n        }        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424010,
                "title": "c-easy-solution-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main catch here is if you are using *max_element() for finding out the max element then the code will give TLE, as *max_element() function takes $$O(n)$$ and the overall complexity turns out to be O(n<sup>2</sup>).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long max1 = nums[0];\\n        ans.push_back(2*nums[0]);\\n        long long sum1 = 2*nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>=max1){\\n                max1 = nums[i];\\n                sum1 = sum1+(2*nums[i]);\\n                ans.push_back(sum1);\\n            }else{\\n                sum1 = sum1+(nums[i]+max1);\\n                ans.push_back(sum1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote_cat.jpeg](https://assets.leetcode.com/users/images/f87692e8-d2b3-42f0-89a2-44e236bc72d7_1681659029.549422.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long max1 = nums[0];\\n        ans.push_back(2*nums[0]);\\n        long long sum1 = 2*nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>=max1){\\n                max1 = nums[i];\\n                sum1 = sum1+(2*nums[i]);\\n                ans.push_back(sum1);\\n            }else{\\n                sum1 = sum1+(nums[i]+max1);\\n                ans.push_back(sum1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423148,
                "title": "c-easy-4-lines-only-o-n-faster-96",
                "content": "```c++\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n    vector<long long> res;\\n    long long max_so_far = 0, prev = 0;\\n    for (auto num: nums) {\\n        max_so_far = max(max_so_far, 1LL * num);\\n        res.push_back(0LL + num + max_so_far + prev);\\n        prev = res.back();\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```c++\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n    vector<long long> res;\\n    long long max_so_far = 0, prev = 0;\\n    for (auto num: nums) {\\n        max_so_far = max(max_so_far, 1LL * num);\\n        res.push_back(0LL + num + max_so_far + prev);\\n        prev = res.back();\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422816,
                "title": "c-very-very-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        ans.push_back(nums[0]+nums[0]);\\n        int maxi=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            ans.push_back(nums[i]+maxi);\\n        }\\n        \\n        for(int i=1;i<ans.size();i++){\\n            ans[i]=ans[i-1]+ans[i]; \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        ans.push_back(nums[0]+nums[0]);\\n        int maxi=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            ans.push_back(nums[i]+maxi);\\n        }\\n        \\n        for(int i=1;i<ans.size();i++){\\n            ans[i]=ans[i-1]+ans[i]; \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422758,
                "title": "easy-to-undersatnd-cpp-solution",
                "content": "![UPvote.jpg](https://assets.leetcode.com/users/images/f5aa6015-14a7-4eb6-b0d6-1c39cb83a85c_1681631343.6630116.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> res;\\n        long long sum = 0;\\n        int n = nums.size();\\n        int max_elem = nums[0];\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > max_elem) max_elem = nums[i];\\n            sum += max_elem + nums[i];\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> res;\\n        long long sum = 0;\\n        int n = nums.size();\\n        int max_elem = nums[0];\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > max_elem) max_elem = nums[i];\\n            sum += max_elem + nums[i];\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422289,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long[] ans=new long[n];\\n        long max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            max=Math.max(max>nums[i]?max:nums[i],max);\\n            ans[i]=nums[i]+max;\\n        }\\n        \\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            ans[i]=sum;\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n//         int n=nums.length;\\n//         long conver[]=new long[n];\\n        \\n//         for(int i=0;i<nums.length;i++){\\n//             conver[i] = nums[i];\\n//             long max=0;\\n//             for(int j=0;j<=i;j++){\\n//                 if(nums[j]>max){\\n//                     max=nums[j];\\n//                 }\\n                \\n//             }\\n//             conver[i]=conver[i]+max;\\n//         }\\n        \\n//         for(int i=1;i<n;i++){\\n//             conver[i]=conver[i]+conver[i-1];\\n//         }\\n//         return conver;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long[] ans=new long[n];\\n        long max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            max=Math.max(max>nums[i]?max:nums[i],max);\\n            ans[i]=nums[i]+max;\\n        }\\n        \\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            ans[i]=sum;\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n//         int n=nums.length;\\n//         long conver[]=new long[n];\\n        \\n//         for(int i=0;i<nums.length;i++){\\n//             conver[i] = nums[i];\\n//             long max=0;\\n//             for(int j=0;j<=i;j++){\\n//                 if(nums[j]>max){\\n//                     max=nums[j];\\n//                 }\\n                \\n//             }\\n//             conver[i]=conver[i]+max;\\n//         }\\n        \\n//         for(int i=1;i<n;i++){\\n//             conver[i]=conver[i]+conver[i-1];\\n//         }\\n//         return conver;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422073,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422068,
                "title": "c-brute-force",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422067,
                "title": "c-brute-force",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421994,
                "title": "optimized-java-solution-easy-structured-with-comments-and-approach",
                "content": "# Approach\\nThe key to solving the problem is literally by writing the arrays on a paper and figuring out where to add what. The given formula is `conver[i] = arr[i] + max(arr[0..i]) `.\\n\\nNow, with this we can understand that conversion array will contain sum of element at i and maximum element till i. Hence, we need to keep track of maximum element till i and check for it first when we iterate. \\n\\nNext, we do not want to return the conversion array!  We are asked to return array of sums from 0 to i of conversion array. Hence, we\\'ll keep track of sum and store that in the array to return it.\\n\\nIn the given solution, conversion array is not stored as it will just take extra space. But for understanding purposes, you can get to conversion array first and then iterate another loop to get sum/ans array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        // array of sums till i\\n        long ans[]=new long[nums.length];\\n        long sum=0;\\n        int max=nums[0];\\n        for (int i=0;i<nums.length;i++){\\n            // updating max\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            // conversion array value = nums[i]+max\\n            // ans array = sum of all till i\\n            sum = sum + nums[i] + max;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        // array of sums till i\\n        long ans[]=new long[nums.length];\\n        long sum=0;\\n        int max=nums[0];\\n        for (int i=0;i<nums.length;i++){\\n            // updating max\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            // conversion array value = nums[i]+max\\n            // ans array = sum of all till i\\n            sum = sum + nums[i] + max;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420828,
                "title": "python-greedy-6-lines-100-beats",
                "content": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        s, m, a = 0, 0, []\\n\\n        for n in nums:\\n            m = max(m, n)\\n            s += n + m\\n            a.append(s)\\n\\n        return a\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        s, m, a = 0, 0, []\\n\\n        for n in nums:\\n            m = max(m, n)\\n            s += n + m\\n            a.append(s)\\n\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420591,
                "title": "explained-with-code-c-easy-to-understand-and-implement",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need a maxium from the 0th index to current index so we can just get it using\\n`max_i = max(max_i,nums[i])`\\nit will the the latest maximum number\\n`ans[1] = nums[1] + max_i + ans[0]`(which is a prefix sum until now)\\n\\n# Complexity\\n## - Time complexity: O(n)\\n\\n## - Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        ans[0] = nums[0] + nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            ans[i] = nums[i] + max_i + ans[i-1];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        ans[0] = nums[0] + nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            ans[i] = nums[i] + max_i + ans[i-1];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420382,
                "title": "c-well-explained-8-line-code-prefix-sum-o-n-time",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        for(auto it : nums) ans.push_back(it);\\n        long long maxi = 0;\\n        for(int i=0; i<ans.size(); i++) {\\n            maxi = max(maxi, ans[i]);\\n            ans[i] += maxi;\\n        }\\n        for(int i=1; i<ans.size(); i++) ans[i] += ans[i-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        for(auto it : nums) ans.push_back(it);\\n        long long maxi = 0;\\n        for(int i=0; i<ans.size(); i++) {\\n            maxi = max(maxi, ans[i]);\\n            ans[i] += maxi;\\n        }\\n        for(int i=1; i<ans.size(); i++) ans[i] += ans[i-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420243,
                "title": "c-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        int max = 0;\\n        for(int i=0;i<nums.size();i++){\\nif(nums[i] > max) {\\n    max = nums[i];\\n}\\n            ans.push_back(max+nums[i]);\\n}\\n    long sum = ans[0];\\n        for(int i = 1; i < nums.size(); i++) {\\nsum += ans[i];\\n            ans[i] = sum;\\n            \\n}\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        int max = 0;\\n        for(int i=0;i<nums.size();i++){\\nif(nums[i] > max) {\\n    max = nums[i];\\n}\\n            ans.push_back(max+nums[i]);\\n}\\n    long sum = ans[0];\\n        for(int i = 1; i < nums.size(); i++) {\\nsum += ans[i];\\n            ans[i] = sum;\\n            \\n}\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420238,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            \\n            arr[i] = nums[i] + max;\\n        }\\n        \\n        long sum = arr[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            sum += arr[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            \\n            arr[i] = nums[i] + max;\\n        }\\n        \\n        long sum = arr[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            sum += arr[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420211,
                "title": "easy-c",
                "content": "# Intuition\\nIf you see pattern here then it is like \\nfor example [2,3,7,5,10]\\nanswer is \\nans[0] = 2 + max(2) + 0\\nans[1] = 3 + max(2,3) + ans[0];\\nans[2] = 7 + max(2,3,7) + ans[1];\\nans[3] = 5 + max(2,3,7,5) + ans[2];\\nans[4] = 10 + max(2,3,7,5,10) + ans[3];\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans(nums.size(),0);\\n        \\n        long long sum = nums[0];\\n        long long maxi = nums[0];\\n        \\n        ans[0] = sum+maxi;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            maxi = max((long long) nums[i],maxi);\\n            ans[i] = maxi + (long long)nums[i] + ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans(nums.size(),0);\\n        \\n        long long sum = nums[0];\\n        long long maxi = nums[0];\\n        \\n        ans[0] = sum+maxi;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            maxi = max((long long) nums[i],maxi);\\n            ans[i] = maxi + (long long)nums[i] + ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420190,
                "title": "c-simple-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use a loop to iterate over the elements of the array and update the maximum element seen so far. Then, calculate the prefix score for the current element by adding it to the maximum element seen so far. Finally, store the prefix score for each element in a vector and returns the vector as the result. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long>ans(n);\\n        int max_till=0;\\n        for(int i=0;i<n;++i){\\n            max_till=max(arr[i],max_till);\\n            long long curr=arr[i]+max_till;\\n            if(i==0){\\n                ans[i]=curr;\\n            }\\n            else ans[i]=ans[i-1]+curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long>ans(n);\\n        int max_till=0;\\n        for(int i=0;i<n;++i){\\n            max_till=max(arr[i],max_till);\\n            long long curr=arr[i]+max_till;\\n            if(i==0){\\n                ans[i]=curr;\\n            }\\n            else ans[i]=ans[i-1]+curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420156,
                "title": "c-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n = size(nums);\\n        \\n        vector<long long> prefix;\\n        \\n        long long mx = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mx = max(mx,0LL+nums[i]);\\n            if(prefix.empty())prefix.push_back(nums[i]+mx);\\n            else prefix.push_back(0ll+prefix.back()+nums[i]+mx);\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n = size(nums);\\n        \\n        vector<long long> prefix;\\n        \\n        long long mx = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mx = max(mx,0LL+nums[i]);\\n            if(prefix.empty())prefix.push_back(nums[i]+mx);\\n            else prefix.push_back(0ll+prefix.back()+nums[i]+mx);\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420152,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        acc_max=accumulate(nums,max)\\n        return list(accumulate(map(sum,zip(nums,acc_max))))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        acc_max=accumulate(nums,max)\\n        return list(accumulate(map(sum,zip(nums,acc_max))))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420115,
                "title": "java-prefix-sum-easiest-o-n-self-explanatory",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, max = -1;\\n        long[] conv = new long[n];\\n        \\n        for(int i=0;i<n;i++){\\n          max = Math.max(max, nums[i]);\\n          conv[i] = nums[i] + max;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            conv[i] = conv[i-1] + conv[i];\\n        }\\n        \\n        return conv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, max = -1;\\n        long[] conv = new long[n];\\n        \\n        for(int i=0;i<n;i++){\\n          max = Math.max(max, nums[i]);\\n          conv[i] = nums[i] + max;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            conv[i] = conv[i-1] + conv[i];\\n        }\\n        \\n        return conv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420089,
                "title": "c-2-lines-easy-solution-o-n",
                "content": "# Approach\\nThe prefix score of an element at index i is the sum of the maximum element from index 0 to i and the element at index i itself. This prefix score is calculated for all elements in the input vector and returned in the output vector.\\n\\n# Complexity\\n- Time complexity:\\nThe function iterates through the input vector once, so the time complexity is O(n), where n is the size of the input vector.\\n\\n- Space complexity:\\nThe function creates a new vector to store the prefix scores, so the space complexity is also O(n), where n is the size of the input vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        int maks=nums[0];\\n        long long hence=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maks = max(maks,nums[i]);\\n            hence+=maks+nums[i];\\n            conver.push_back(hence);\\n        }\\n       \\n        return conver;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        int maks=nums[0];\\n        long long hence=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maks = max(maks,nums[i]);\\n            hence+=maks+nums[i];\\n            conver.push_back(hence);\\n        }\\n       \\n        return conver;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420067,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    const ans = [];\\n    let max = 0, sum = 0;\\n    for (const n of nums) {\\n        max = Math.max(max, n);\\n        sum += n + max;\\n        ans.push(sum);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    const ans = [];\\n    let max = 0, sum = 0;\\n    for (const n of nums) {\\n        max = Math.max(max, n);\\n        sum += n + max;\\n        ans.push(sum);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420037,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long sum = 0;\\n        long max = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n            sum += nums[i] + max;\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long sum = 0;\\n        long max = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n            sum += nums[i] + max;\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420028,
                "title": "1-loop-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int t = 0, n = nums.size(); \\n        vector<long long> ans(n, 0);\\n        \\n        for(int i=0; i<n; i++){\\n            t = max(t, nums[i]); \\n            ans[i] = nums[i] + t; \\n            if(i>0) ans[i] += ans[i-1];\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int t = 0, n = nums.size(); \\n        vector<long long> ans(n, 0);\\n        \\n        for(int i=0; i<n; i++){\\n            t = max(t, nums[i]); \\n            ans[i] = nums[i] + t; \\n            if(i>0) ans[i] += ans[i-1];\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420027,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution{\\n    typedef long long ll;\\npublic:\\n    vector<ll> findPrefixScore(const vector<int>&v){\\n        ll n=v.size();\\n        vector<ll>ans(n), pref(n); // Convers\\n        pref[0]=ans[0]=2*v[0];\\n        for(ll i=1, mx=v[0]; i<n; ++i){\\n            mx=max(mx, ll(v[i])); // max so far\\n            pref[i]=v[i]+mx;\\n            ans[i]=ans[i-1]+pref[i]; // sum of Convers, i.e., the cur score\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution{\\n    typedef long long ll;\\npublic:\\n    vector<ll> findPrefixScore(const vector<int>&v){\\n        ll n=v.size();\\n        vector<ll>ans(n), pref(n); // Convers\\n        pref[0]=ans[0]=2*v[0];\\n        for(ll i=1, mx=v[0]; i<n; ++i){\\n            mx=max(mx, ll(v[i])); // max so far\\n            pref[i]=v[i]+mx;\\n            ans[i]=ans[i-1]+pref[i]; // sum of Convers, i.e., the cur score\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419998,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long x = nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(x<nums[i]) x = nums[i];\\n            nums[i] += x;\\n        }\\n        vector<long long> ans(nums.size());\\n        ans[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans[i] += (nums[i]+ans[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long x = nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(x<nums[i]) x = nums[i];\\n            nums[i] += x;\\n        }\\n        vector<long long> ans(nums.size());\\n        ans[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans[i] += (nums[i]+ans[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419983,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = nums[0];\\n       \\n        for(int i =0 ;i < nums.length;i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n             System.out.println(max);\\n            long sum = max + nums[i];\\n            arr[i] = sum;\\n        }\\n        for(int i =1 ;i<arr.length;i++){\\n            arr[i] = arr[i] + arr[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = nums[0];\\n       \\n        for(int i =0 ;i < nums.length;i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n             System.out.println(max);\\n            long sum = max + nums[i];\\n            arr[i] = sum;\\n        }\\n        for(int i =1 ;i<arr.length;i++){\\n            arr[i] = arr[i] + arr[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101062,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long arr[] = new long[nums.length];\\n        long max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long arr[] = new long[nums.length];\\n        long max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088059,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        res = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            res.append(res[i - 1] + nums[i] + maximum)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        res = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            res.append(res[i - 1] + nums[i] + maximum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081077,
                "title": "easy-to-understand-c-o-n-beats-94-59",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> v;\\n        int m = 0;\\n        long long sum = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n            m = max(m, nums[i]);\\n            nums[i] = nums[i] + m;\\n            sum += nums[i];\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> v;\\n        int m = 0;\\n        long long sum = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n            m = max(m, nums[i]);\\n            nums[i] = nums[i] + m;\\n            sum += nums[i];\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072916,
                "title": "java-solution-100-faster-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int[] conver = new int[nums.length];\\n        int max = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            conver[i] = nums[i]+max;\\n        }\\n\\n        long[] ans = new long[nums.length];\\n\\n        ans[0] = conver[0];\\n\\n        for(int i = 1; i < nums.length; i++)\\n            ans[i] = ans[i-1]+conver[i];\\n\\n        return ans;   \\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int[] conver = new int[nums.length];\\n        int max = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            conver[i] = nums[i]+max;\\n        }\\n\\n        long[] ans = new long[nums.length];\\n\\n        ans[0] = conver[0];\\n\\n        for(int i = 1; i < nums.length; i++)\\n            ans[i] = ans[i-1]+conver[i];\\n\\n        return ans;   \\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069449,
                "title": "very-easy-using-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069443,
                "title": "very-easy-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066305,
                "title": "c-really-easy-and-clean-solution",
                "content": "\\'\\'\\'\\n\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int N=nums.size();\\n        vector<long long> res(N);\\n        vector<long long> conv(N);\\n        long long score=0, maxVal=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            maxVal = max(maxVal, (long long)nums[i]);\\n            conv[i] = nums[i] + maxVal;\\n            score += conv[i];\\n            res[i] = score;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int N=nums.size();\\n        vector<long long> res(N);\\n        vector<long long> conv(N);\\n        long long score=0, maxVal=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            maxVal = max(maxVal, (long long)nums[i]);\\n            conv[i] = nums[i] + maxVal;\\n            score += conv[i];\\n            res[i] = score;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 4063799,
                "title": "python-elegant-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the `accumulate(nums, max)` to keep track of the running maximum, \\n`map(add, nums, accumulate(nums, max))` to add the running maxima to the elements of the input list, and finally `accumulate` all that to get the desired result.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - we bascially do what amounts to a single iteration over the source list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ - it\\'s all iterators inside, no temporary lists are ever allocated.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051688,
                "title": "simple-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int max=INT_MIN;\\n        vector<long long> ans;\\n        long long score =0;\\n        int idx=0;\\n\\n        while(idx<nums.size())\\n        {\\n            if (max <nums[idx])\\n            {\\n                max = nums[idx];\\n            }\\n            score = score + nums[idx] + max;\\n            ans.push_back(score);\\n            idx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int max=INT_MIN;\\n        vector<long long> ans;\\n        long long score =0;\\n        int idx=0;\\n\\n        while(idx<nums.size())\\n        {\\n            if (max <nums[idx])\\n            {\\n                max = nums[idx];\\n            }\\n            score = score + nums[idx] + max;\\n            ans.push_back(score);\\n            idx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043158,
                "title": "beats-99-68-runtime-most-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        vector<long long>conver;\\n        int ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ma=max(ma,nums[i]);\\n            conver.push_back(nums[i]+ma);\\n        }\\n        vector<long long>ans;\\n        long long res=0;\\n        for(int i=0;i<conver.size();i++)\\n        {\\n            res+=conver[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        vector<long long>conver;\\n        int ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ma=max(ma,nums[i]);\\n            conver.push_back(nums[i]+ma);\\n        }\\n        vector<long long>ans;\\n        long long res=0;\\n        for(int i=0;i<conver.size();i++)\\n        {\\n            res+=conver[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040810,
                "title": "prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int ax=1;\\n        long long p=0;\\n        vector<long long>ans;\\n        for(int i=0;i<size(nums);i++){\\n            ax=max(ax,nums[i]);\\n            p+=ax+nums[i];\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int ax=1;\\n        long long p=0;\\n        vector<long long>ans;\\n        for(int i=0;i<size(nums);i++){\\n            ax=max(ax,nums[i]);\\n            p+=ax+nums[i];\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038388,
                "title": "easy-o-n-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefix = new long[nums.length];\\n        long[] res = new long[nums.length];\\n        int prev = nums[0];\\n        res[0] = prev + nums[0];\\n        for (int i = 1; i < prefix.length; i++) {\\n            prev = Math.max(prev, nums[i]);\\n            long curr = prev + nums[i];\\n            res[i] = curr + res[i - 1];\\n        }\\n        return res;\\n    }\\n}\\n/**\\n2, 2 -> 4\\n\\n2 3 -> 4 6 -> 10\\n\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefix = new long[nums.length];\\n        long[] res = new long[nums.length];\\n        int prev = nums[0];\\n        res[0] = prev + nums[0];\\n        for (int i = 1; i < prefix.length; i++) {\\n            prev = Math.max(prev, nums[i]);\\n            long curr = prev + nums[i];\\n            res[i] = curr + res[i - 1];\\n        }\\n        return res;\\n    }\\n}\\n/**\\n2, 2 -> 4\\n\\n2 3 -> 4 6 -> 10\\n\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037276,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> findPrefixScore(List<int> nums) {\\n      final List<int> res = [0];\\n      var prevMax = 0;\\n      for (int i = 0; i < nums.length; i++) {\\n          prevMax = max(prevMax, nums[i]);\\n          final totalAtIndex = prevMax + nums[i];\\n          final total = totalAtIndex + res.last;\\n          res.add(total);\\n      }\\n\\n      return res.sublist(1);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> findPrefixScore(List<int> nums) {\\n      final List<int> res = [0];\\n      var prevMax = 0;\\n      for (int i = 0; i < nums.length; i++) {\\n          prevMax = max(prevMax, nums[i]);\\n          final totalAtIndex = prevMax + nums[i];\\n          final total = totalAtIndex + res.last;\\n          res.add(total);\\n      }\\n\\n      return res.sublist(1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035243,
                "title": "step-by-step-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] ans = new long[nums.length];\\n\\n        //This maxArray will store the max value till ith position\\n        int [] maxArray = new int[nums.length];\\n        int[] conversion =  new int[nums.length];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i<nums.length;i++){\\n            max = Math.max(max,nums[i]);\\n            maxArray[i] = max;\\n        }\\n        for(int i = 0 ; i<nums.length;i++){\\n            conversion[i] = nums[i] + maxArray[i];\\n            System.out.println(conversion[i]);\\n        }\\n        ans[0] = conversion[0];\\n        for(int i = 1; i<nums.length;i++){\\n            ans[i] = (long)(conversion[i] + ans[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] ans = new long[nums.length];\\n\\n        //This maxArray will store the max value till ith position\\n        int [] maxArray = new int[nums.length];\\n        int[] conversion =  new int[nums.length];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i<nums.length;i++){\\n            max = Math.max(max,nums[i]);\\n            maxArray[i] = max;\\n        }\\n        for(int i = 0 ; i<nums.length;i++){\\n            conversion[i] = nums[i] + maxArray[i];\\n            System.out.println(conversion[i]);\\n        }\\n        ans[0] = conversion[0];\\n        for(int i = 1; i<nums.length;i++){\\n            ans[i] = (long)(conversion[i] + ans[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020332,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] r = new long[nums.length];\\n        int max = nums[0];\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            int conv = nums[i] + max;\\n            if (i == 0) {\\n                r[i] = conv;\\n            }\\n            else {\\n                r[i] = conv + r[i - 1];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] r = new long[nums.length];\\n        int max = nums[0];\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            int conv = nums[i] + max;\\n            if (i == 0) {\\n                r[i] = conv;\\n            }\\n            else {\\n                r[i] = conv + r[i - 1];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017769,
                "title": "easiest-solution-in-single-traversal-95-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum=0;\\n        int maxi=0;\\n        for(auto i:nums){\\n            maxi=max(maxi,i);\\n            sum=sum+i+maxi;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum=0;\\n        int maxi=0;\\n        for(auto i:nums){\\n            maxi=max(maxi,i);\\n            sum=sum+i+maxi;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016660,
                "title": "short-code-easiest-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>&n){\\n        vector<long long>ans;\\n        long long mx=0 , sum=0;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]>mx){\\n                mx=n[i];\\n            }\\n            sum+=n[i]+mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>&n){\\n        vector<long long>ans;\\n        long long mx=0 , sum=0;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]>mx){\\n                mx=n[i];\\n            }\\n            sum+=n[i]+mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999361,
                "title": "java-straightforward",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int  maxd =  nums[0] ;\\n        long res[] = new long[nums.length];\\n        res[0] = maxd*2 ;\\n        for(int i = 1; i< nums.length ; i++){\\n            \\n            maxd = Math.max(nums[i] , maxd);\\n            res[i] = maxd + nums[i] + res[i-1]; \\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int  maxd =  nums[0] ;\\n        long res[] = new long[nums.length];\\n        res[0] = maxd*2 ;\\n        for(int i = 1; i< nums.length ; i++){\\n            \\n            maxd = Math.max(nums[i] , maxd);\\n            res[i] = maxd + nums[i] + res[i-1]; \\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996249,
                "title": "c-easy-and-understandable",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long >ans;\\n        vector<int>v;\\n        int mx=nums[0];\\n        v.push_back(mx+nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            mx=max(nums[i],mx);\\n            v.push_back(nums[i]+mx);\\n        }\\n        long long  k=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans.push_back(1LL*(k+v[i]));\\n            k=ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long >ans;\\n        vector<int>v;\\n        int mx=nums[0];\\n        v.push_back(mx+nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            mx=max(nums[i],mx);\\n            v.push_back(nums[i]+mx);\\n        }\\n        long long  k=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans.push_back(1LL*(k+v[i]));\\n            k=ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994065,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] arr = new long[n];\\n        long prefix =0,max=0;\\n\\n        for(int i=0;i<n;i++){\\n           max =  Math.max(max,nums[i]);\\n           arr[i] = nums[i] + max + prefix;\\n           prefix = arr[i];\\n     }\\n       return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] arr = new long[n];\\n        long prefix =0,max=0;\\n\\n        for(int i=0;i<n;i++){\\n           max =  Math.max(max,nums[i]);\\n           arr[i] = nums[i] + max + prefix;\\n           prefix = arr[i];\\n     }\\n       return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992531,
                "title": "how-can-this-question-be-of-medium-level-difficulty-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvector<long long> findPrefixScore(vector<int>& nums) \\n{\\n        vector<long long> ans;\\n        long long curr=0;\\n        int mx=-100;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mx=max(mx,nums[i]); // max number till current index\\n            curr+= (mx+nums[i]); // addition of currnumber with max number till curr index and storing the sum\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<long long> findPrefixScore(vector<int>& nums) \\n{\\n        vector<long long> ans;\\n        long long curr=0;\\n        int mx=-100;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mx=max(mx,nums[i]); // max number till current index\\n            curr+= (mx+nums[i]); // addition of currnumber with max number till curr index and storing the sum\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989319,
                "title": "find-the-score-of-all-prefixes-of-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        arr[0] = nums[0]+max;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            arr[i] = nums[i]+arr[i-1]+max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        arr[0] = nums[0]+max;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            arr[i] = nums[i]+arr[i-1]+max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988324,
                "title": "python-simple-python-solution-prefix-sum-98-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 409 ms, faster than 98.17% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n# Memory Usage: 38.9 MB, less than 81.41% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n![image](https://assets.leetcode.com/users/images/b2a7499e-0801-4f5b-943e-b4e4fa283cc2_1693569893.2199633.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tcurrent_max = nums[0]\\n\\n\\t\\t\\tresult.append(nums[0] * 2)\\n\\n\\t\\t\\tfor num in nums[1:]:\\n\\n\\t\\t\\t\\tcurrent_max = max(current_max , num)\\n\\n\\t\\t\\t\\tresult.append(result[-1] + num + current_max)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 409 ms, faster than 98.17% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n# Memory Usage: 38.9 MB, less than 81.41% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n![image](https://assets.leetcode.com/users/images/b2a7499e-0801-4f5b-943e-b4e4fa283cc2_1693569893.2199633.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tcurrent_max = nums[0]\\n\\n\\t\\t\\tresult.append(nums[0] * 2)\\n\\n\\t\\t\\tfor num in nums[1:]:\\n\\n\\t\\t\\t\\tcurrent_max = max(current_max , num)\\n\\n\\t\\t\\t\\tresult.append(result[-1] + num + current_max)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3986671,
                "title": "very-easy-approach-using-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n\\n        vector<long long> output;\\n\\n        long long sum = 0;\\n        long int temp;\\n        output.push_back(nums[0]*2);\\n        sum = nums[0]*2;\\n        long int maxele = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n\\n            // if(nums[i-1] > nums[i]){\\n            //     temp = nums[i-1]+nums[i];\\n            // }else{\\n            //     temp = nums[i]*2;\\n            // }\\n\\n            if(maxele <= nums[i]){\\n                maxele = nums[i];\\n            }\\n            temp=maxele + nums[i];\\n\\n            sum+=temp;\\n\\n            output.push_back(sum);\\n\\n            \\n        }\\n        return output;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n\\n        vector<long long> output;\\n\\n        long long sum = 0;\\n        long int temp;\\n        output.push_back(nums[0]*2);\\n        sum = nums[0]*2;\\n        long int maxele = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n\\n            // if(nums[i-1] > nums[i]){\\n            //     temp = nums[i-1]+nums[i];\\n            // }else{\\n            //     temp = nums[i]*2;\\n            // }\\n\\n            if(maxele <= nums[i]){\\n                maxele = nums[i];\\n            }\\n            temp=maxele + nums[i];\\n\\n            sum+=temp;\\n\\n            output.push_back(sum);\\n\\n            \\n        }\\n        return output;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980151,
                "title": "prefixsum-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefixSum Java Easy Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefixSum Java Easy Solution\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefixSum = new long[nums.length];\\n\\n        prefixSum[0] = nums[0] + nums[0];\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n            prefixSum[i] = prefixSum[i-1] + nums[i] + max;\\n        }\\n\\n        return prefixSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefixSum = new long[nums.length];\\n\\n        prefixSum[0] = nums[0] + nums[0];\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n            prefixSum[i] = prefixSum[i-1] + nums[i] + max;\\n        }\\n\\n        return prefixSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975237,
                "title": "beats-98-23-o-n-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) -> since we need to return vector.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       vector<long long> pre(nums.size());\\n       int maxi=nums[0];\\n       pre[0]=maxi+nums[0];\\n       for(int i=1; i<nums.size(); i++) {\\n           maxi=max(maxi, nums[i]);\\n           pre[i]=nums[i]+pre[i-1]+maxi;\\n       }\\n       return pre;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       vector<long long> pre(nums.size());\\n       int maxi=nums[0];\\n       pre[0]=maxi+nums[0];\\n       for(int i=1; i<nums.size(); i++) {\\n           maxi=max(maxi, nums[i]);\\n           pre[i]=nums[i]+pre[i-1]+maxi;\\n       }\\n       return pre;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966494,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        int maxi=0;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            long long val=maxi+nums[i];\\n            sum=sum+val;;\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        int maxi=0;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            long long val=maxi+nums[i];\\n            sum=sum+val;;\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963370,
                "title": "swift-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findPrefixScore(_ nums: [Int]) -> [Int] {\\n    var maxVal = 0\\n    var result = [Int]()\\n    \\n    for num in nums {\\n        maxVal = max(maxVal, num)\\n        result.append(num + maxVal)\\n    }\\n    var arr = [Int]()\\n    var cur = 0\\n    for i in result {\\n        cur += i\\n        arr.append(cur)\\n    }\\n    return arr\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findPrefixScore(_ nums: [Int]) -> [Int] {\\n    var maxVal = 0\\n    var result = [Int]()\\n    \\n    for num in nums {\\n        maxVal = max(maxVal, num)\\n        result.append(num + maxVal)\\n    }\\n    var arr = [Int]()\\n    var cur = 0\\n    for i in result {\\n        cur += i\\n        arr.append(cur)\\n    }\\n    return arr\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962597,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957803,
                "title": "easy-and-well-explained",
                "content": "\\n\\n# Approach\\nmaintain a maxi variable to store the maximum till the current element.\\nInitialise a pre variable to store the score of previous elements.\\nUpdate the pre variable every time .\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=-1;\\n        long long pre=0;\\n        long long curr;\\n        vector<long long>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            maxi=max(maxi,nums[i]);\\n\\n             curr=maxi+nums[i];\\n\\n            ans.push_back(curr+pre);\\n            pre=curr+pre;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=-1;\\n        long long pre=0;\\n        long long curr;\\n        vector<long long>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            maxi=max(maxi,nums[i]);\\n\\n             curr=maxi+nums[i];\\n\\n            ans.push_back(curr+pre);\\n            pre=curr+pre;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951346,
                "title": "c-prefix-sum-simple-code",
                "content": "\\n\\n# Code\\n```\\n// #define int long long\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        long long max = v[0];\\n        vector<long long> ans;\\n        ans.push_back(v[0]*2);\\n        for(int i = 1; i<v.size(); i++){\\n            if(v[i]>max) max=v[i];\\n            long long x = v[i] + max;\\n            ans.push_back(ans[i-1]+x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// #define int long long\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        long long max = v[0];\\n        vector<long long> ans;\\n        ans.push_back(v[0]*2);\\n        for(int i = 1; i<v.size(); i++){\\n            if(v[i]>max) max=v[i];\\n            long long x = v[i] + max;\\n            ans.push_back(ans[i-1]+x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944076,
                "title": "elegant-solution-java-beats-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int max= Integer.MIN_VALUE;\\n        long [] conArr = new long[nums.length];\\n        long [] conArrAns = new long[nums.length];\\n\\n        for(int i=0;i<nums.length;i++)\\n        {   \\n            int j=0;\\n            if(nums[i]>max)\\n            max=nums[i];\\n            conArr[i] = nums[i]+max;     \\n        }\\n        long sum=0;\\n        for(int i=0;i<conArr.length;i++)\\n        {\\n            sum =sum +conArr[i];\\n            conArrAns[i]=sum;\\n        }\\n        return conArrAns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int max= Integer.MIN_VALUE;\\n        long [] conArr = new long[nums.length];\\n        long [] conArrAns = new long[nums.length];\\n\\n        for(int i=0;i<nums.length;i++)\\n        {   \\n            int j=0;\\n            if(nums[i]>max)\\n            max=nums[i];\\n            conArr[i] = nums[i]+max;     \\n        }\\n        long sum=0;\\n        for(int i=0;i<conArr.length;i++)\\n        {\\n            sum =sum +conArr[i];\\n            conArrAns[i]=sum;\\n        }\\n        return conArrAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943782,
                "title": "soooooooooooooo-much-easyyyyyyyyyyyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        maxi=nums[0]\\n        count=0\\n        for i in nums:\\n            if i>=maxi:\\n                count = count +(i+i)\\n                maxi=i\\n            else:\\n                count=count+(i+maxi)\\n            ans.append(count)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        maxi=nums[0]\\n        count=0\\n        for i in nums:\\n            if i>=maxi:\\n                count = count +(i+i)\\n                maxi=i\\n            else:\\n                count=count+(i+maxi)\\n            ans.append(count)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931863,
                "title": "elixir-solution-use-enum-reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 285ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 85MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec find_prefix_score(nums :: [integer]) :: [integer]\\n  def find_prefix_score(nums) do\\n    Enum.reduce(nums, {0, [0]}, fn num, {t_max, ans} ->\\n      t_max = max(t_max, num)\\n      {t_max, [num + t_max + (ans |> hd) | ans]}\\n    end) |> elem(1) |> Enum.reverse() |> tl\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_prefix_score(nums :: [integer]) :: [integer]\\n  def find_prefix_score(nums) do\\n    Enum.reduce(nums, {0, [0]}, fn num, {t_max, ans} ->\\n      t_max = max(t_max, num)\\n      {t_max, [num + t_max + (ans |> hd) | ans]}\\n    end) |> elem(1) |> Enum.reverse() |> tl\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3926316,
                "title": "python-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maxx=nums[0]\\n        nums[0]=nums[0]*2\\n        \\n        sum=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]>maxx:\\n                maxx=nums[i]\\n            nums[i]+=maxx\\n            sum+=nums[i]\\n            nums[i]=sum\\n            \\n        return nums\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maxx=nums[0]\\n        nums[0]=nums[0]*2\\n        \\n        sum=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]>maxx:\\n                maxx=nums[i]\\n            nums[i]+=maxx\\n            sum+=nums[i]\\n            nums[i]=sum\\n            \\n        return nums\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926266,
                "title": "c-code-beats-100-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int max = 0;\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (max < nums[i])\\n                {\\n                    max = nums[i];\\n                }\\n\\n                nums[i] += max;\\n            }\\n\\n            long[] answer = new long[nums.Length];\\n            answer[0] = nums[0];\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                answer[i] = answer[i - 1] + nums[i];\\n            }\\n            return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int max = 0;\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (max < nums[i])\\n                {\\n                    max = nums[i];\\n                }\\n\\n                nums[i] += max;\\n            }\\n\\n            long[] answer = new long[nums.Length];\\n            answer[0] = nums[0];\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                answer[i] = answer[i - 1] + nums[i];\\n            }\\n            return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913564,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        maxx=-1\\n        cnt=0\\n        for i in range(len(nums)):\\n            if maxx<nums[i]:\\n                maxx=nums[i]\\n            cnt+=nums[i]+maxx\\n            res.append(cnt)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        maxx=-1\\n        cnt=0\\n        for i in range(len(nums)):\\n            if maxx<nums[i]:\\n                maxx=nums[i]\\n            cnt+=nums[i]+maxx\\n            res.append(cnt)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910941,
                "title": "python-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = []\\n        sum = 0\\n        max = nums[0]\\n        for i in range(0,len(nums)):\\n            if nums[i]>max:\\n                max = nums[i]\\n            sum = sum + max + nums[i]\\n            a.append(sum)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = []\\n        sum = 0\\n        max = nums[0]\\n        for i in range(0,len(nums)):\\n            if nums[i]>max:\\n                max = nums[i]\\n            sum = sum + max + nums[i]\\n            a.append(sum)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904134,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] result=new long[nums.length];\\n        int max=nums[0];\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            max=Math.max(max,nums[j]);\\n            nums[j]=max+nums[j];\\n        }\\n\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            result[i]=sum;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] result=new long[nums.length];\\n        int max=nums[0];\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            max=Math.max(max,nums[j]);\\n            nums[j]=max+nums[j];\\n        }\\n\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            result[i]=sum;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903415,
                "title": "straight-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        current_max = nums[0]\\n        conver = [0]*len(nums)\\n        conver[0] = 2*current_max\\n\\n        for i in range(1, len(nums)):\\n            current_max = max(current_max, nums[i])\\n            conver[i] = conver[i-1] + nums[i] + current_max\\n        return conver\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        current_max = nums[0]\\n        conver = [0]*len(nums)\\n        conver[0] = 2*current_max\\n\\n        for i in range(1, len(nums)):\\n            current_max = max(current_max, nums[i])\\n            conver[i] = conver[i-1] + nums[i] + current_max\\n        return conver\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902615,
                "title": "java-straight-forward-easy-to-understand-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n = nums.length;\\n        long[] scores = new long[n];\\n\\n        long score = 0;\\n\\n        long maxVal = nums[0];\\n\\n        int index = 0;\\n\\n        for(int val : nums){\\n            maxVal = Math.max(maxVal, val);\\n            score += val + maxVal;\\n            scores[index++] = score;\\n        }\\n        return scores;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n = nums.length;\\n        long[] scores = new long[n];\\n\\n        long score = 0;\\n\\n        long maxVal = nums[0];\\n\\n        int index = 0;\\n\\n        for(int val : nums){\\n            maxVal = Math.max(maxVal, val);\\n            score += val + maxVal;\\n            scores[index++] = score;\\n        }\\n        return scores;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901008,
                "title": "java-easy-prefix-sum-100-beats",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long conver[]=new long[nums.length];\\n        long arr[]=new long[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           max=Math.max(max,nums[i]);\\n           conver[i]=nums[i]+max;\\n        }\\n\\n        arr[0]=conver[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            arr[i]=arr[i-1]+conver[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long conver[]=new long[nums.length];\\n        long arr[]=new long[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           max=Math.max(max,nums[i]);\\n           conver[i]=nums[i]+max;\\n        }\\n\\n        arr[0]=conver[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            arr[i]=arr[i-1]+conver[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892092,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### Use for loop to go through the nums array.\\n##### Keep a variable max to keep track of the maximum element till i\\n##### Add max to the current nums[i] now you got the conversion array value\\n##### After finding the value we have to add to final_temp which gives score at index i of our solution array.\\n\\n# Complexity\\n## - Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n##### O(n) where n is length of nums array.\\n\\n## - Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n##### O(n) as we are storing the result in an array res of length n.\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long res[]=new long[n];\\n        long max=0;\\n        long final_temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<nums[i])\\n                max=nums[i];\\n            long temp=nums[i]+max;\\n            final_temp+=temp;\\n            res[i]=final_temp;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long res[]=new long[n];\\n        long max=0;\\n        long final_temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<nums[i])\\n                max=nums[i];\\n            long temp=nums[i]+max;\\n            final_temp+=temp;\\n            res[i]=final_temp;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887877,
                "title": "golang-o-n-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc findPrefixScore(nums []int) []int64 {\\n\\tprevMax := nums[0]\\n\\tans := make([]int64, len(nums))\\n\\tans[0]=int64(nums[0]*2)\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tprevMax = max(nums[i], prevMax)\\n\\t\\tans[i] = int64(nums[i] + prevMax)+ans[i-1]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findPrefixScore(nums []int) []int64 {\\n\\tprevMax := nums[0]\\n\\tans := make([]int64, len(nums))\\n\\tans[0]=int64(nums[0]*2)\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tprevMax = max(nums[i], prevMax)\\n\\t\\tans[i] = int64(nums[i] + prevMax)+ans[i-1]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878745,
                "title": "efficient-solution-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        lenNum=len(nums)\\n        ans=[]\\n        sum=0\\n        maxnum=-9999\\n        for i in range(lenNum):\\n            if maxnum < nums[i]:\\n                maxnum=nums[i]\\n            sum +=maxnum+nums[i]\\n            ans.append(sum)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        lenNum=len(nums)\\n        ans=[]\\n        sum=0\\n        maxnum=-9999\\n        for i in range(lenNum):\\n            if maxnum < nums[i]:\\n                maxnum=nums[i]\\n            sum +=maxnum+nums[i]\\n            ans.append(sum)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874890,
                "title": "c-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Keep track of max and previous score when iterating\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int maxValue = 0;\\n        long prevScore = 0;\\n        long[] ret = new long[nums.Length];\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] > maxValue)\\n                maxValue = nums[i];\\n\\n            ret[i] = prevScore + nums[i] + maxValue;\\n\\n            prevScore = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int maxValue = 0;\\n        long prevScore = 0;\\n        long[] ret = new long[nums.Length];\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] > maxValue)\\n                maxValue = nums[i];\\n\\n            ret[i] = prevScore + nums[i] + maxValue;\\n\\n            prevScore = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862678,
                "title": "c-o-n-time-space-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find prefix max of all elements in array\\nThen find arr[i]+prefixMax[i] its conversion array\\nNow find prefix sum of conversion array\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>maxPrefix(nums.size());\\n        //Step:1 finding prefix max of array\\n        maxPrefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=max((long long)nums[i],maxPrefix[i-1]);\\n        }\\n        //ZStep-2 converting maxPrefix array to conversion array\\n        for(int i=0;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+nums[i];\\n        }\\n        //Step:3 now calculating prefix sum of conversion array\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+maxPrefix[i-1];\\n        }\\n        return maxPrefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>maxPrefix(nums.size());\\n        //Step:1 finding prefix max of array\\n        maxPrefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=max((long long)nums[i],maxPrefix[i-1]);\\n        }\\n        //ZStep-2 converting maxPrefix array to conversion array\\n        for(int i=0;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+nums[i];\\n        }\\n        //Step:3 now calculating prefix sum of conversion array\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+maxPrefix[i-1];\\n        }\\n        return maxPrefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859012,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nimplementation\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        long long temp=0;\\n        int mx=0;\\n        for(auto i:nums){\\n            mx=max(mx,i);\\n            ans.push_back(temp+mx+i);\\n            temp+=mx+i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        long long temp=0;\\n        int mx=0;\\n        for(auto i:nums){\\n            mx=max(mx,i);\\n            ans.push_back(temp+mx+i);\\n            temp+=mx+i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852180,
                "title": "c-shortest-o-n-space-time",
                "content": "# Approach\\n\\nSince vector elements are always default-initialized but we wouldn\\'t care about its default values here, let\\'s put it at least to some use and pass as \"default value\" the one that should be in the first element, i.e. `largest \\xD7 2`. This would allow us to 1) skip first cycle 2) get rid of `i` boundary check in the cycle.\\n\\nOther than that, the code is straigtforward: we go through `nums` vector and compute each element according to the task description.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```C++\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(const vector<int>& nums) {\\n        int largest = nums[0];\\n        vector<long long> answer(nums.size(), largest * 2);\\n        for (size_t i = 1; i < nums.size(); ++i) {\\n            largest = max(largest, nums[i]);\\n            answer[i] = largest + nums[i] +  answer[i-1];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(const vector<int>& nums) {\\n        int largest = nums[0];\\n        vector<long long> answer(nums.size(), largest * 2);\\n        for (size_t i = 1; i < nums.size(); ++i) {\\n            largest = max(largest, nums[i]);\\n            answer[i] = largest + nums[i] +  answer[i-1];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841137,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        long long maxi=nums[0];\\n        vector<long long>ans(n);\\n        ans[0]=maxi+nums[0];\\n        for (int i=1;i<n;i++)\\n        {\\n           if (nums[i]>maxi) maxi=nums[i];\\n            ans[i]=1LL*nums[i]+maxi+ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        long long maxi=nums[0];\\n        vector<long long>ans(n);\\n        ans[0]=maxi+nums[0];\\n        for (int i=1;i<n;i++)\\n        {\\n           if (nums[i]>maxi) maxi=nums[i];\\n            ans[i]=1LL*nums[i]+maxi+ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838349,
                "title": "javascript-you-got-it-mate",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let conv = []\\n    let max = 0\\n    let sum = 0\\n    for(let i=0;i<nums.length;i++){\\n        max = Math.max(max,nums[i])\\n        conv[i] = max + nums[i]\\n        sum += conv[i]\\n        nums[i] = sum\\n    }\\n\\n    return nums\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let conv = []\\n    let max = 0\\n    let sum = 0\\n    for(let i=0;i<nums.length;i++){\\n        max = Math.max(max,nums[i])\\n        conv[i] = max + nums[i]\\n        sum += conv[i]\\n        nums[i] = sum\\n    }\\n\\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3834572,
                "title": "linear-python",
                "content": "# Intuition\\nSince the formula for converting each element only relies on the maximum among prior elements, and the formula for score only relies on summing prior sub-arrays, we can probably do this in linear time with a single pass while keeping track of maximum and score.\\n\\n# Approach\\nLoop through the array calculating conversion value and score along the way.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ ; we only traverse the array once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ ; we allocate one extra array to hold the answer which is the same length as the input\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        score = 0\\n        scores = [None] * len(nums)\\n        for idx, i in enumerate(nums):\\n            if i > m:\\n                m = i\\n            score += (i + m)\\n            scores[idx] = score\\n        return scores\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        score = 0\\n        scores = [None] * len(nums)\\n        for idx, i in enumerate(nums):\\n            if i > m:\\n                m = i\\n            score += (i + m)\\n            scores[idx] = score\\n        return scores\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832694,
                "title": "c-beats-100-users-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n, 0);\\n        int maxi = nums[0];\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            ans[i] = nums[i]+maxi;\\n        }\\n        vector<long long> res(n, 0);\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n, 0);\\n        int maxi = nums[0];\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            ans[i] = nums[i]+maxi;\\n        }\\n        vector<long long> res(n, 0);\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823424,
                "title": "javascript-100-runtime",
                "content": "```javascript\\nconst findPrefixScore = (nums) => {\\n  let prefix = 0;\\n  let max = 0;\\n  return nums.map((num) => {\\n    max = Math.max(max, num);\\n    prefix += num + max;\\n    return prefix;\\n  });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst findPrefixScore = (nums) => {\\n  let prefix = 0;\\n  let max = 0;\\n  return nums.map((num) => {\\n    max = Math.max(max, num);\\n    prefix += num + max;\\n    return prefix;\\n  });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3803091,
                "title": "python3-3-lines-o-n-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse the accumulate() and map() functions to create intermediary lists efficiently.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        a = list(itertools.accumulate(nums, max))\\n        a = list(map(add, nums, a))\\n        return list(itertools.accumulate(a))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        a = list(itertools.accumulate(nums, max))\\n        a = list(map(add, nums, a))\\n        return list(itertools.accumulate(a))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799998,
                "title": "python3-one-pass-beats-99-52",
                "content": "\\tclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        mx=nums[0]\\n        cumsum=0\\n        ls=[]\\n        for i in nums:\\n            if i>mx:\\n                mx=i\\n            conver=i+mx\\n            cumsum+=conver\\n            ls.append(cumsum)\\n        \\n        return ls\\n![image](https://assets.leetcode.com/users/images/158e8585-19fb-4f54-bd3c-6af9944dc537_1690014678.3895664.png)\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        mx=nums[0]\\n        cumsum=0\\n        ls=[]\\n        for i in nums:\\n            if i>mx:\\n                mx=i\\n            conver=i+mx\\n            cumsum+=conver\\n            ls.append(cumsum)\\n        \\n        return ls\\n![image](https://assets.leetcode.com/users/images/158e8585-19fb-4f54-bd3c-6af9944dc537_1690014678.3895664.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3779535,
                "title": "simple-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- cv is vector storing the max element upto i th element\\n- mx is vector storing the sum , the convert array \\n ( mx[i] = nums[i] + max(nums[0....i]) ) upto i th element\\n- the loop iterates over nums and with each itertion cv stores the max element upto i\\n- mx stores the sum of num arrays with max element making the conversion array making the resultant array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![leet.jpeg](https://assets.leetcode.com/users/images/efc6a9a0-bdef-4071-80c9-79274758646e_1689612916.0885437.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> cv(nums.size(),0);  //stores max element\\n        vector<long long> mx(nums.size(),0);    //stores sum upto i th element making the convert array\\n        cv[0]=nums[0];\\n        mx[0]=nums[0]+cv[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            cv[i]=max(nums[i],cv[i-1]);\\n            mx[i]=nums[i]+cv[i]+mx[i-1];\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> cv(nums.size(),0);  //stores max element\\n        vector<long long> mx(nums.size(),0);    //stores sum upto i th element making the convert array\\n        cv[0]=nums[0];\\n        mx[0]=nums[0]+cv[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            cv[i]=max(nums[i],cv[i-1]);\\n            mx[i]=nums[i]+cv[i]+mx[i-1];\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760113,
                "title": "o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Observation. `ans` store cummulative sum of elements of `conver` of whole `nums`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRather than calculating `conver` for whole `nums`, As we want to store cummulative sum as we iterate through `conver` in `ans`.\\n`conver[i] = nums[i] + maxi`, so rather than storing `conver`,\\ntake a variable `sum` we stores cummulative sum of elements of `conver` on each iteration, and store the value in the corresponding `ans[i]`.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n);\\n        int maxi = -1e9;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            sum += nums[i] + maxi;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n);\\n        int maxi = -1e9;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            sum += nums[i] + maxi;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743854,
                "title": "c-easy-to-understand-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        vector<int> store;\\n        int a=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>a)\\n                a=nums[i];\\n            int push=a+nums[i];\\n            store.push_back(push);\\n        }\\n        long long sum=0;\\n        for(int i=0;i<store.size();i++){\\n            sum+=(long long)store[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        vector<int> store;\\n        int a=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>a)\\n                a=nums[i];\\n            int push=a+nums[i];\\n            store.push_back(push);\\n        }\\n        long long sum=0;\\n        for(int i=0;i<store.size();i++){\\n            sum+=(long long)store[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741585,
                "title": "typescript-solution-beats-speed-100-memory-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nfunction findPrefixScore(nums: number[]): number[] {\\n    \\n    const n: number = nums.length;\\n    let result: number[] = [...Array(n+1)].fill(0);\\n    let maxResult: number = 0;\\n    for(let i=0; i<nums.length; i++) {\\n       maxResult = Math.max(nums[i], maxResult);\\n       result[i+1] = result[i] + maxResult + nums[i];\\n    }\\n    result = result.slice(1);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findPrefixScore(nums: number[]): number[] {\\n    \\n    const n: number = nums.length;\\n    let result: number[] = [...Array(n+1)].fill(0);\\n    let maxResult: number = 0;\\n    for(let i=0; i<nums.length; i++) {\\n       maxResult = Math.max(nums[i], maxResult);\\n       result[i+1] = result[i] + maxResult + nums[i];\\n    }\\n    result = result.slice(1);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3717471,
                "title": "optimal-solution-o-n-time",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        currMax = 0\\n        ans = []\\n\\n        for n in nums:\\n            currMax = max(currMax, n)\\n            if not ans:\\n                ans.append(currMax + n)\\n            else:\\n                ans.append(currMax + n + ans[-1])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        currMax = 0\\n        ans = []\\n\\n        for n in nums:\\n            currMax = max(currMax, n)\\n            if not ans:\\n                ans.append(currMax + n)\\n            else:\\n                ans.append(currMax + n + ans[-1])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708003,
                "title": "easily-understandable-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> v(n);\\n        long long sum=0;\\n        v[0]=2*nums[0];\\n        int m=nums[0];\\n        sum+=v[0];\\n        for(int i=1;i<n;i++){\\n            m=max(m,nums[i]);\\n            long long p=nums[i]+m;\\n            sum+=p;\\n            v[i]=sum;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> v(n);\\n        long long sum=0;\\n        v[0]=2*nums[0];\\n        int m=nums[0];\\n        sum+=v[0];\\n        for(int i=1;i<n;i++){\\n            m=max(m,nums[i]);\\n            long long p=nums[i]+m;\\n            sum+=p;\\n            v[i]=sum;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701913,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefix sum\\n\\n# Approach\\nCreate an empty array ( or an array having an filler value). Create a  ```max_till_now``` variable to store the max value of the the array at that instant while traversing the loop. Add the value of max_till-now to the the iterator and append the value to the ```ans``` array.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans = [0]\\n        max_till_now = nums[0]\\n\\n        # ans = []\\n        for num in nums:\\n            max_till_now = max(max_till_now, num)\\n            n = num + max_till_now\\n            ans.append(ans[-1] + n )\\n\\n            # print(ans)  \\n        return ans[1:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```max_till_now```\n```ans```\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans = [0]\\n        max_till_now = nums[0]\\n\\n        # ans = []\\n        for num in nums:\\n            max_till_now = max(max_till_now, num)\\n            n = num + max_till_now\\n            ans.append(ans[-1] + n )\\n\\n            # print(ans)  \\n        return ans[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698236,
                "title": "python-prefix-sum",
                "content": "```\\nclass Solution:\\n    def findPrefixScore(self, nums):\\n        maxPrefix = [nums[0]]\\n        for i in range(1, len(nums)):\\n            maxPrefix.append(max(maxPrefix[-1], nums[i]))\\n        ans = [maxPrefix[0] + nums[0]]\\n        for i in range(1, len(maxPrefix)):\\n            ans.append(ans[-1] + maxPrefix[i] + nums[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums):\\n        maxPrefix = [nums[0]]\\n        for i in range(1, len(nums)):\\n            maxPrefix.append(max(maxPrefix[-1], nums[i]))\\n        ans = [maxPrefix[0] + nums[0]]\\n        for i in range(1, len(maxPrefix)):\\n            ans.append(ans[-1] + maxPrefix[i] + nums[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697048,
                "title": "prefix-sum-one-pass-simple-java-solution-o-n-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n    long ans[]=new long[nums.length];\\n    long max=Long.MIN_VALUE;\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        max=Math.max(max,nums[i]);\\n        ans[i]=nums[i]+max;\\n        if(i!=0)\\n            ans[i]+=ans[i-1];\\n    }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n    long ans[]=new long[nums.length];\\n    long max=Long.MIN_VALUE;\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        max=Math.max(max,nums[i]);\\n        ans[i]=nums[i]+max;\\n        if(i!=0)\\n            ans[i]+=ans[i-1];\\n    }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696796,
                "title": "c-clean-code-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> v=nums;\\n        vector<long long int> a;\\n        int m=v[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m=max(m,v[i]);\\n            v[i]=m;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        a.push_back(v[i]+nums[i]);\\n        long long int c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            c+=a[i];\\n            a[i]=c;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> v=nums;\\n        vector<long long int> a;\\n        int m=v[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m=max(m,v[i]);\\n            v[i]=m;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        a.push_back(v[i]+nums[i]);\\n        long long int c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            c+=a[i];\\n            a[i]=c;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688982,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long int res=0, mx = 0;\\n        vector<long long int> ans;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mx = max(mx, (long long)nums[i]);\\n            res += mx + (long long)nums[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long int res=0, mx = 0;\\n        vector<long long int> ans;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mx = max(mx, (long long)nums[i]);\\n            res += mx + (long long)nums[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688538,
                "title": "explaination-in-hindi-and-easy-to-understand-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n        // is problem me hamko current element aur 0 to i range tk k maximum value find krna hai.\\n// aur current element aur largest value(0-i range) k sum find krna hai \\n// aur us sum ko ek  new array me dalna hai.\\n// uske bad prefix sum find krna hai \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\n\\n\\n\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n       // long data type use karege kyoki return type long diya hua hai \\n        int n  = nums.length;\\n        long prefix1[] = new long[n];\\n        long prefix2[] = new long[n];\\n        int largest = Integer.MIN_VALUE;\\n        for(int i =0; i<n ;i++)\\n        {\\n    // largest number find kr rhe hai yha pr 0 to i range tk \\n            if(nums[i]>largest)\\n            {\\n                largest = nums[i];\\n            }\\n // new prefix Array me ham current element aur largest element k sum dalege \\n            prefix1[i] = nums[i]+largest;\\n        }\\n        long  m = prefix1.length;\\n   // simple yha pr jaise PREFIX SUM find krte hai wo find krna hai \\n        prefix2[0] = prefix1[0];\\n        for(int i=1;i<m;i++)\\n        {\\n            prefix2[i] = prefix2[i-1]+prefix1[i];\\n        }\\n // last me ham prefix2 array ko  return kr dege\\n        return prefix2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n       // long data type use karege kyoki return type long diya hua hai \\n        int n  = nums.length;\\n        long prefix1[] = new long[n];\\n        long prefix2[] = new long[n];\\n        int largest = Integer.MIN_VALUE;\\n        for(int i =0; i<n ;i++)\\n        {\\n    // largest number find kr rhe hai yha pr 0 to i range tk \\n            if(nums[i]>largest)\\n            {\\n                largest = nums[i];\\n            }\\n // new prefix Array me ham current element aur largest element k sum dalege \\n            prefix1[i] = nums[i]+largest;\\n        }\\n        long  m = prefix1.length;\\n   // simple yha pr jaise PREFIX SUM find krte hai wo find krna hai \\n        prefix2[0] = prefix1[0];\\n        for(int i=1;i<m;i++)\\n        {\\n            prefix2[i] = prefix2[i-1]+prefix1[i];\\n        }\\n // last me ham prefix2 array ko  return kr dege\\n        return prefix2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683940,
                "title": "using-stack-and-logic-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore max value in a variable rather than to find max value for each iteration\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse nums and find converse use stack to find score\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        stack=[0]\\n\\n        m=nums[0]\\n\\n        for i in range(0,len(nums)):\\n            if nums[i]>m:\\n                m=nums[i]\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n            else:\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n        \\n        stack.remove(stack[0])\\n        return stack\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        stack=[0]\\n\\n        m=nums[0]\\n\\n        for i in range(0,len(nums)):\\n            if nums[i]>m:\\n                m=nums[i]\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n            else:\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n        \\n        stack.remove(stack[0])\\n        return stack\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671148,
                "title": "python3-solution-with-using-prefix-sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        conver = [0] * len(nums)\\n\\n        cur_max = 0\\n        for idx in range(len(nums)):\\n            cur_max = max(cur_max, nums[idx])\\n            conver[idx] = cur_max + nums[idx]\\n\\n        for idx in range(1, len(conver)):\\n            conver[idx] += conver[idx - 1]\\n        \\n        return conver\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        conver = [0] * len(nums)\\n\\n        cur_max = 0\\n        for idx in range(len(nums)):\\n            cur_max = max(cur_max, nums[idx])\\n            conver[idx] = cur_max + nums[idx]\\n\\n        for idx in range(1, len(conver)):\\n            conver[idx] += conver[idx - 1]\\n        \\n        return conver\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669194,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        mx=0\\n        for num in nums:\\n            mx=max(num,mx)\\n            if len(ans)>0:\\n                ans.append(mx+num+ans[-1])\\n            else:\\n                ans.append(mx+num)\\n\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        mx=0\\n        for num in nums:\\n            mx=max(num,mx)\\n            if len(ans)>0:\\n                ans.append(mx+num+ans[-1])\\n            else:\\n                ans.append(mx+num)\\n\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667211,
                "title": "one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            nums[i] += m\\n            if i >0:\\n                nums[i]+=nums[i-1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            nums[i] += m\\n            if i >0:\\n                nums[i]+=nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665090,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int m = 0;\\n        int[] max = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            max[i] = Math.max(m, nums[i]);\\n            m = max[i];\\n        }\\n\\n        long n = 0;\\n        long[] result = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            result[i] = nums[i] + max[i] + n;\\n            n = result[i];\\n        }\\n        return result;   \\n    }\\n}\\n```\\nIf you made it this far please upvote.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int m = 0;\\n        int[] max = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            max[i] = Math.max(m, nums[i]);\\n            m = max[i];\\n        }\\n\\n        long n = 0;\\n        long[] result = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            result[i] = nums[i] + max[i] + n;\\n            n = result[i];\\n        }\\n        return result;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664357,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] score = new long[nums.length];\\n        int max  = Integer.MIN_VALUE;\\n        long conver = 0; long i_score =0;\\n        for(int i =0;i <nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            conver = nums[i]+max;\\n            i_score += conver;\\n            score[i] = i_score;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] score = new long[nums.length];\\n        int max  = Integer.MIN_VALUE;\\n        long conver = 0; long i_score =0;\\n        for(int i =0;i <nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            conver = nums[i]+max;\\n            i_score += conver;\\n            score[i] = i_score;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659176,
                "title": "c-solution-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> arr;\\n        int max = nums[0];\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr.push_back(sum);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> arr;\\n        int max = nums[0];\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr.push_back(sum);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659174,
                "title": "java-solution-o-n-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        long sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        long sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657727,
                "title": "easy-solution-straight-forward-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>res(nums.size());\\n    \\n        int maxi=nums[0],x;\\n        for(int i=0;i<nums.size();i++){\\n              if(nums[i]>maxi){\\n                  maxi=nums[i];\\n              }\\n              x=nums[i]+maxi;\\n              if(i==0){\\n                res[i]=x;\\n              }else{\\n                 res[i]=res[i-1]+x;\\n              }\\n        }\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>res(nums.size());\\n    \\n        int maxi=nums[0],x;\\n        for(int i=0;i<nums.size();i++){\\n              if(nums[i]>maxi){\\n                  maxi=nums[i];\\n              }\\n              x=nums[i]+maxi;\\n              if(i==0){\\n                res[i]=x;\\n              }else{\\n                 res[i]=res[i-1]+x;\\n              }\\n        }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652788,
                "title": "2-ms-runtime-beats-100-simple-observation-java",
                "content": "# Intuition\\nNotice from example 1 the differences between each array of the answer. The first difference is 6 which is the sum of the current max, 3, and the current element 3. Notice the third difference 12, which is the sum of the current max, 7, and the current element 5. \\n\\n# Approach\\nIf we calculate these differences and add them to the previous element, we can get the next element in our output array. Gang!\\n# Complexity\\nThe time complexity is O(N) - we traverse the array just once. \\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = nums[0];\\n        long[] out = new long[nums.length];\\n        out[0] = nums[0] + max;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            out[i] = nums[i] + out[i-1] + max;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = nums[0];\\n        long[] out = new long[nums.length];\\n        out[0] = nums[0] + max;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            out[i] = nums[i] + out[i-1] + max;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652005,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        int[] t=new int[n];\\n        int max=Integer.MIN_VALUE;\\n        long[] res=new long[n];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,nums[i]);\\n            t[i]=max;\\n        }\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            res[i]=nums[i]+t[i]+sum;\\n            sum=res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        int[] t=new int[n];\\n        int max=Integer.MIN_VALUE;\\n        long[] res=new long[n];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,nums[i]);\\n            t[i]=max;\\n        }\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            res[i]=nums[i]+t[i]+sum;\\n            sum=res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642587,
                "title": "98-11-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nauto _ = []()\\n{\\n    std::cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>a;\\n        a.push_back(nums[0]);\\n        for(int i = 1 ; i<nums.size();i++){\\n            if(nums[i]>a[a.size()-1]){\\n                a.push_back(nums[i]);\\n            }\\n            else{\\n                a.push_back(a[a.size()-1]);\\n            }\\n        }\\n        for(int i = 0 ; i<nums.size();i++){\\n            a[i] = a[i] + nums[i];\\n        }\\n        for(int i = 1 ; i<a.size() ; i++){\\n            a[i] = a[i-1] + a[i];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nauto _ = []()\\n{\\n    std::cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>a;\\n        a.push_back(nums[0]);\\n        for(int i = 1 ; i<nums.size();i++){\\n            if(nums[i]>a[a.size()-1]){\\n                a.push_back(nums[i]);\\n            }\\n            else{\\n                a.push_back(a[a.size()-1]);\\n            }\\n        }\\n        for(int i = 0 ; i<nums.size();i++){\\n            a[i] = a[i] + nums[i];\\n        }\\n        for(int i = 1 ; i<a.size() ; i++){\\n            a[i] = a[i-1] + a[i];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637272,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep record of sum of convertion array till each element\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore max and sum of convertion array for each element and add converted array element for that index \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        s=0\\n        m=0\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            s=s+nums[i]+m\\n            l.append(s)\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        s=0\\n        m=0\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            s=s+nums[i]+m\\n            l.append(s)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618344,
                "title": "beginner-freindly-approach-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long>mx(n);\\n        mx[0] = nums[0];\\n        int mxe = nums[0];\\n        for(int i=1; i<n; i++){\\n            mxe = max(mxe, nums[i]);\\n            mx[i]=mxe;\\n\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            mx[i] = mx[i]+nums[i];\\n        }\\n        for(int i=1; i<n; i++){\\n            mx[i] = mx[i]+mx[i-1];\\n        }\\n        return mx;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long>mx(n);\\n        mx[0] = nums[0];\\n        int mxe = nums[0];\\n        for(int i=1; i<n; i++){\\n            mxe = max(mxe, nums[i]);\\n            mx[i]=mxe;\\n\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            mx[i] = mx[i]+nums[i];\\n        }\\n        for(int i=1; i<n; i++){\\n            mx[i] = mx[i]+mx[i-1];\\n        }\\n        return mx;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586372,
                "title": "beat-100-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int max = 0;\\n        long[] result = new long[nums.length];\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            if(i == 0){\\n                result[i] = nums[i] + max;\\n            }\\n            else{\\n            result[i] = result[i-1]+nums[i] + max;\\n        \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int max = 0;\\n        long[] result = new long[nums.length];\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            if(i == 0){\\n                result[i] = nums[i] + max;\\n            }\\n            else{\\n            result[i] = result[i-1]+nums[i] + max;\\n        \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582084,
                "title": "java-easy-solution",
                "content": "# Intuition\\nMaximum is fixed and direct implementation of given formula\\n\\n# Approach\\nDynamic programming\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] conver = new long[nums.length];\\n        conver[0] = nums[0]*2;\\n        int maxi = nums[0];\\n        for(int i = 1;nums.length>i;i++){\\n            maxi = Math.max(maxi,nums[i]);\\n            conver[i] = maxi+nums[i]+conver[i-1];\\n        }\\n        return conver;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] conver = new long[nums.length];\\n        conver[0] = nums[0]*2;\\n        int maxi = nums[0];\\n        for(int i = 1;nums.length>i;i++){\\n            maxi = Math.max(maxi,nums[i]);\\n            conver[i] = maxi+nums[i]+conver[i-1];\\n        }\\n        return conver;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581187,
                "title": "java-simple-solution-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = 0;\\n        long sum = 0;\\n        long[] ans = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            sum += nums[i] + max;\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = 0;\\n        long sum = 0;\\n        long[] ans = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            sum += nums[i] + max;\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571029,
                "title": "simple-solution-in-a-single-loop-prefix-sum",
                "content": "# Intuition\\n<a href=\"https://ibb.co/mDwk4pt\"><img src=\"https://i.ibb.co/BzxbBkj/null-1.png\" alt=\"null-1\" border=\"0\"></a><br />\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int len = nums.size();\\n        vector<long long int> prefix(len,0);\\n        int mx(0);\\n\\n        for(int i  = 0; i < len; i++){\\n            mx = max(mx,nums[i]);\\n\\n            prefix[i] = (nums[i] + mx);\\n\\n            if(i > 0){\\n                prefix[i] += prefix[i - 1];\\n            }\\n        }\\n\\n        return prefix;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int len = nums.size();\\n        vector<long long int> prefix(len,0);\\n        int mx(0);\\n\\n        for(int i  = 0; i < len; i++){\\n            mx = max(mx,nums[i]);\\n\\n            prefix[i] = (nums[i] + mx);\\n\\n            if(i > 0){\\n                prefix[i] += prefix[i - 1];\\n            }\\n        }\\n\\n        return prefix;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567821,
                "title": "simple-java-solution-using-array-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO( N )<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO( N )<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n=nums.length;\\n        long[] ans=new long[n]; //for final ans\\n        long[] max=new long[n]; //for calculating sum of element and max\\n                                // before it\\n\\n        max[0]=2*nums[0];\\n        long temp=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>temp){\\n                max[i]=2*nums[i];\\n                temp=nums[i]; //Here we have calculted the max value before\\n                             //it and sum of that element.\\n            }\\n            else max[i]=temp+nums[i];\\n        }\\n        \\n        ans[0]=max[0];\\n\\n        for(int i=1;i<n;i++){\\n            ans[i]=ans[i-1]+max[i]; //we calculated the prefix sum using\\n                                    // max array.\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n=nums.length;\\n        long[] ans=new long[n]; //for final ans\\n        long[] max=new long[n]; //for calculating sum of element and max\\n                                // before it\\n\\n        max[0]=2*nums[0];\\n        long temp=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>temp){\\n                max[i]=2*nums[i];\\n                temp=nums[i]; //Here we have calculted the max value before\\n                             //it and sum of that element.\\n            }\\n            else max[i]=temp+nums[i];\\n        }\\n        \\n        ans[0]=max[0];\\n\\n        for(int i=1;i<n;i++){\\n            ans[i]=ans[i-1]+max[i]; //we calculated the prefix sum using\\n                                    // max array.\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567125,
                "title": "using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nfirst calculating the prefix sum then calculating the score. for calculating prefix sum used priority queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n), where n is size of nums.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>pref,ans; \\n        priority_queue<long long>pq;  \\n       // pq.push(nums[0]);\\n        for(int i=0;i<nums.size();i++) \\n        { \\n             pq.push(nums[i]);\\n           pref.push_back(nums[i]+pq.top()); \\n          \\n        } \\n        ans.push_back(pref[0]); \\n        for(int i=1;i<pref.size();i++) \\n        {\\n            ans.push_back(ans[i-1]+pref[i]);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>pref,ans; \\n        priority_queue<long long>pq;  \\n       // pq.push(nums[0]);\\n        for(int i=0;i<nums.size();i++) \\n        { \\n             pq.push(nums[i]);\\n           pref.push_back(nums[i]+pq.top()); \\n          \\n        } \\n        ans.push_back(pref[0]); \\n        for(int i=1;i<pref.size();i++) \\n        {\\n            ans.push_back(ans[i-1]+pref[i]);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566507,
                "title": "c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvector<long long> Get_converted(vector<int> &nums)\\n{\\n    vector<long long> ans = {};\\n    long long maximum = nums[0];\\n    for(int i = 0; i<nums.size(); i++)\\n    {\\n        maximum = max((long long)nums[i], maximum);\\n        int x = nums[i] + maximum;\\n        ans.push_back(x);\\n    }\\n    return ans;\\n}\\nvoid Get_added(vector<long long> &ans)\\n{\\n    long long sum = 0;\\n    for(int i = 0; i<ans.size(); i++)\\n    {\\n        sum = sum + ans[i];\\n        ans[i] = sum;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        // Cancel as answer differs after sorting -> sort(nums.begin(), nums.end());\\n        // We got the conversion array\\n        vector<long long> ans = Get_converted(nums);\\n        Get_added(ans);\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<long long> Get_converted(vector<int> &nums)\\n{\\n    vector<long long> ans = {};\\n    long long maximum = nums[0];\\n    for(int i = 0; i<nums.size(); i++)\\n    {\\n        maximum = max((long long)nums[i], maximum);\\n        int x = nums[i] + maximum;\\n        ans.push_back(x);\\n    }\\n    return ans;\\n}\\nvoid Get_added(vector<long long> &ans)\\n{\\n    long long sum = 0;\\n    for(int i = 0; i<ans.size(); i++)\\n    {\\n        sum = sum + ans[i];\\n        ans[i] = sum;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        // Cancel as answer differs after sorting -> sort(nums.begin(), nums.end());\\n        // We got the conversion array\\n        vector<long long> ans = Get_converted(nums);\\n        Get_added(ans);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1864501,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1880976,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1868316,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864344,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1974599,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1938215,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1876746,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1865483,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864439,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864351,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864501,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1880976,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1868316,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864344,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1974599,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1938215,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1876746,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1865483,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864439,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864351,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            }
        ]
    },
    {
        "title": "Design Cancellable Function",
        "question_content": "<p>Sometimes you have a long running task, and you may wish to cancel it before it completes. To help with this goal, write a function&nbsp;<code>cancellable</code> that accepts a generator object and returns an array of two values: a <strong>cancel function</strong> and a <strong>promise</strong>.</p>\n\n<p>You may assume the generator function will only&nbsp;yield promises. It is your function&#39;s responsibility to pass the values resolved by the promise back to the generator. If the promise rejects, your function should throw that&nbsp;error back to the generator.</p>\n\n<p>If the cancel callback is called before the generator is done, your function should throw an error back to the generator. That error should be the string&nbsp;<code>&quot;Cancelled&quot;</code>&nbsp;(Not an <code>Error</code>&nbsp;object). If the error was caught, the returned&nbsp;promise should resolve with the next value that was yielded or returned. Otherwise, the promise should reject with the thrown error. No more code should be executed.</p>\n\n<p>When the generator is done, the promise your function returned should resolve the value the generator returned. If, however, the generator throws an error, the returned promise should reject with the error.</p>\n\n<p>An example of how your code would be used:</p>\n\n<pre>\nfunction* tasks() {\n  const val = yield new Promise(resolve =&gt; resolve(2 + 2));\n  yield new Promise(resolve =&gt; setTimeout(resolve, 100));\n  return val + 1; // calculation shouldn&#39;t be done.\n}\nconst [cancel, promise] = cancellable(tasks());\nsetTimeout(cancel, 50);\npromise.catch(console.log); // logs &quot;Cancelled&quot; at t=50ms\n</pre>\n\n<p>If&nbsp;instead&nbsp;<code>cancel()</code> was not called or was called after <code>t=100ms</code>, the promise would&nbsp;have resolved&nbsp;<code>5</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; return 42; \n}\ncancelledAt = 100\n<strong>Output:</strong> {&quot;resolved&quot;: 42}\n<strong>Explanation:</strong>\nconst generator = generatorFunction();\nconst [cancel, promise] = cancellable(generator);\nsetTimeout(cancel, 100);\npromise.then(console.log); // resolves 42 at t=0ms\n\nThe generator immediately yields 42 and finishes. Because of that, the returned promise immediately resolves 42. Note that cancelling a finished generator does nothing.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong>\ngeneratorFunction = function*() { \n&nbsp; const msg = yield new Promise(res =&gt; res(&quot;Hello&quot;)); \n&nbsp; throw `Error: ${msg}`; \n}\ncancelledAt = null\n<strong>Output:</strong> {&quot;rejected&quot;: &quot;Error: Hello&quot;}\n<strong>Explanation:</strong>\nA promise is yielded. The function handles this by waiting for it to resolve and then passes the resolved value back to the generator. Then an error is thrown which has the effect of causing the promise to reject with the same thrown error.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 200)); \n&nbsp; return &quot;Success&quot;; \n}\ncancelledAt = 100\n<strong>Output:</strong> {&quot;rejected&quot;: &quot;Cancelled&quot;}\n<strong>Explanation:</strong>\nWhile the function is waiting for the yielded promise to resolve, cancel() is called. This causes an error message to be sent back to the generator. Since this error is uncaught, the returned promise rejected with this error.\n</pre>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong>\ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100));\n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; return result;\n}\ncancelledAt = null\n<strong>Output:</strong> {&quot;resolved&quot;: 2}\n<strong>Explanation:</strong>\n4 promises are yielded. Two of those promises have their values added to the result. After 200ms, the generator finishes with a value of 2, and that value is resolved by the returned promise.\n</pre>\n\n<p><strong class=\"example\">Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; try { \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp; } catch(e) { \n&nbsp;   return result; \n&nbsp; } \n&nbsp; return result; \n}\ncancelledAt = 150\n<strong>Output:</strong> {&quot;resolved&quot;: 1}\n<strong>Explanation:</strong>\nThe first two yielded promises resolve and cause the result to increment. However, at t=150ms, the generator is cancelled. The error sent to the generator is caught and the result is returned and finally resolved by the returned promise.\n</pre>\n\n<p><strong class=\"example\">Example 6:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; try { \n&nbsp;   yield new Promise((resolve, reject) =&gt; reject(&quot;Promise Rejected&quot;)); \n&nbsp; } catch(e) { \n&nbsp;   let a = yield new Promise(resolve =&gt; resolve(2));\n    let b = yield new Promise(resolve =&gt; resolve(2)); \n&nbsp;   return a + b; \n&nbsp; }; \n}\ncancelledAt = null\n<strong>Output:</strong> {&quot;resolved&quot;: 4}\n<strong>Explanation:</strong>\nThe first yielded promise immediately rejects. This error is caught. Because the generator hasn&#39;t been cancelled, execution continues as usual. It ends up resolving 2 + 2 = 4.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>cancelledAt == null or 0 &lt;= cancelledAt &lt;= 1000</code></li>\n\t<li><code>generatorFunction</code> returns a generator object</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3440923,
                "title": "simple-solution-with-async-and-promise-race",
                "content": "# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    var cancel;\\n    const cancelPromise = new Promise((_, reject) => { cancel = () => reject(\"Cancelled\"); });\\n    // Every Promise rejection has to be caught.\\n    cancelPromise.catch(()=>{});\\n\\n    const promise = (async () => {\\n        let next = generator.next();\\n        while (!next.done) {\\n            try {\\n                next = generator.next(await Promise.race([next.value, cancelPromise]));\\n            } catch (e) {\\n                next = generator.throw(e);\\n            }\\n        }\\n        return next.value;\\n    })();\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    var cancel;\\n    const cancelPromise = new Promise((_, reject) => { cancel = () => reject(\"Cancelled\"); });\\n    // Every Promise rejection has to be caught.\\n    cancelPromise.catch(()=>{});\\n\\n    const promise = (async () => {\\n        let next = generator.next();\\n        while (!next.done) {\\n            try {\\n                next = generator.next(await Promise.race([next.value, cancelPromise]));\\n            } catch (e) {\\n                next = generator.throw(e);\\n            }\\n        }\\n        return next.value;\\n    })();\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443563,
                "title": "javascript-typescript-simple-solution-with-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nBased on the given code snippet, the `cancellable` function seems to wrap a generator function in a way that allows it to be cancelled using a returned function. The generator function is executed asynchronously using promises and `await`, and the cancellation is implemented by rejecting a cancellation promise that is created inside the `cancellable` function.\\n\\nTo solve this problem, one could start by understanding how generators work in JavaScript/TypeScript and how to use the `Generator` type. Then, one could analyze the given code snippet and try to understand how it works, and what are the roles of the `cancel` function and the `cancelPromise`. Finally, one could try to replicate the same functionality in a different way or extend the existing code to fit a specific use case.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngeneral approach that one use to solve a problem:\\n\\n1. Understand the problem: Read and analyze the problem statement, requirements, and constraints. Ensure that you understand the problem\\'s scope, expected output, and any input constraints.\\n\\n2. Research: Look for relevant information, algorithms, libraries, and tools that could help solve the problem. Check for any existing solutions, and learn from their approaches.\\n\\n3. Plan and design: Based on your understanding of the problem and the available resources, plan your approach and design your solution. Break down the problem into smaller sub-problems and identify the key components and functions that you need.\\n\\n4. Implement: Start implementing your solution in code. Follow best practices, write clean, modular, and maintainable code. Test your code frequently and make adjustments as needed.\\n\\n5. Test and validate: Test your code thoroughly, both manually and using automated tests. Validate your code\\'s output against the problem requirements and ensure that it meets the expected results.\\n\\n6. Optimize and improve: Once you have a working solution, look for ways to optimize and improve it. Consider factors such as performance, scalability, security, and usability.\\n\\n7. Document and share: Document your code, including its purpose, usage, and any dependencies. Share your code with others, and contribute to the community by sharing your insights, solutions, and experiences.\\n# Complexity\\nThe time and space complexity of the `cancellable` function depend on the implementation details and the behavior of the generator function passed as a parameter. However, we can analyze the time and space complexity of the `cancellable` function itself:\\n- Time complexity: The `cancellable` function creates a new promise and uses the `Promise.race` method to race between the generator\\'s next value and the cancellation promise. The `Promise.race` method has a time complexity of O(n), where n is the number of promises passed as arguments. The generator function is executed synchronously until it reaches the first `yield` statement, so its time complexity depends on its implementation. Therefore, the time complexity of the `cancellable` function is at least O(1) and at most O(n), where n is the number of promises involved in the race.\\n\\n- Space complexity: The `cancellable` function creates two promises: the cancellation promise and the promise returned by the async function. It also creates a `cancel` function and a `next` variable used to iterate over the generator function. The space complexity of the `cancellable` function is therefore O(1), as the amount of memory used by the function does not depend on the input size. However, the space complexity of the generator function may be higher, depending on its implementation and the amount of data it processes.\\n\\n```javascript []\\nconst cancellable = (generator) => {\\n  let cancel;\\n  const cancelPromise = new Promise((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async () => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n```\\n```TypeScript []\\nconst cancellable = <T>(generator: Generator): [() => void, Promise<T>] => {\\n  let cancel: () => void;\\n  const cancelPromise = new Promise<never>((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async (): Promise<T> => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\nconst cancellable = (generator) => {\\n  let cancel;\\n  const cancelPromise = new Promise((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async () => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564498,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let resolve;\\n  let reject;\\n  let isCancelled = false;\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const cancel = () => {\\n    isCancelled = true;\\n    try {\\n      const obj = generator.throw(\"Cancelled\");\\n      resolve(obj.value);\\n    } catch (e) {\\n      reject(e);\\n    }\\n  };\\n\\n  function helper(val, err) {\\n    if (isCancelled) return;\\n    try {\\n      const obj = err ? generator.throw(err) : generator.next(val);\\n      if (obj.done) {\\n        resolve(obj.value);\\n      } else {\\n        Promise.resolve(obj.value)\\n          .then((result) => helper(result))\\n          .catch((e) => helper(undefined, e));\\n      }\\n    } catch (e) {\\n      reject(e);\\n    }\\n  }\\n  helper();\\n\\n  return [cancel, promise]; \\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let resolve;\\n  let reject;\\n  let isCancelled = false;\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const cancel = () => {\\n    isCancelled = true;\\n    try {\\n      const obj = generator.throw(\"Cancelled\");\\n      resolve(obj.value);\\n    } catch (e) {\\n      reject(e);\\n    }\\n  };\\n\\n  function helper(val, err) {\\n    if (isCancelled) return;\\n    try {\\n      const obj = err ? generator.throw(err) : generator.next(val);\\n      if (obj.done) {\\n        resolve(obj.value);\\n      } else {\\n        Promise.resolve(obj.value)\\n          .then((result) => helper(result))\\n          .catch((e) => helper(undefined, e));\\n      }\\n    } catch (e) {\\n      reject(e);\\n    }\\n  }\\n  helper();\\n\\n  return [cancel, promise]; \\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608553,
                "title": "design-cancellable-function-compact-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let canceled = false;\\n\\n    return [\\n        () => canceled = true,\\n        (async () => {\\n            let next = generator.next();\\n\\n            while(!next.done){\\n                try {\\n                    let nextValue = await next.value;\\n                    next = canceled ? generator.throw(\"Cancelled\") : generator.next(nextValue);\\n                } catch (e) {\\n                    next = generator.throw(e);\\n                }\\n            }\\n\\n            return next.value;\\n        })()\\n    ]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let canceled = false;\\n\\n    return [\\n        () => canceled = true,\\n        (async () => {\\n            let next = generator.next();\\n\\n            while(!next.done){\\n                try {\\n                    let nextValue = await next.value;\\n                    next = canceled ? generator.throw(\"Cancelled\") : generator.next(nextValue);\\n                } catch (e) {\\n                    next = generator.throw(e);\\n                }\\n            }\\n\\n            return next.value;\\n        })()\\n    ]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442426,
                "title": "easy-to-understand",
                "content": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let resolve;\\n    let reject;\\n    let isCancelled = false;\\n    \\n    const promise = new Promise((res, rej) => {\\n        resolve = res;\\n        reject = rej;\\n    });\\n    \\n    const cancel = () => {\\n        isCancelled = true;\\n        try {\\n        \\tconst obj = generator.throw(\"Cancelled\");\\n            resolve(obj.value)\\n        } catch (e) {\\n            reject(e);\\n        }\\n    }\\n    \\n    function helper(val, err) {\\n        if (isCancelled) return;\\n        try {\\n            const obj = err ? generator.throw(err) : generator.next(val);\\n            if (obj.done) {\\n                resolve(obj.value)\\n            } else {\\n                obj.value.then(helper).catch(e => helper(undefined, e))\\n            }\\n        } catch (e) {\\n            reject(e)\\n        }\\n    }\\n    helper();\\n\\n    return [cancel, promise];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let resolve;\\n    let reject;\\n    let isCancelled = false;\\n    \\n    const promise = new Promise((res, rej) => {\\n        resolve = res;\\n        reject = rej;\\n    });\\n    \\n    const cancel = () => {\\n        isCancelled = true;\\n        try {\\n        \\tconst obj = generator.throw(\"Cancelled\");\\n            resolve(obj.value)\\n        } catch (e) {\\n            reject(e);\\n        }\\n    }\\n    \\n    function helper(val, err) {\\n        if (isCancelled) return;\\n        try {\\n            const obj = err ? generator.throw(err) : generator.next(val);\\n            if (obj.done) {\\n                resolve(obj.value)\\n            } else {\\n                obj.value.then(helper).catch(e => helper(undefined, e))\\n            }\\n        } catch (e) {\\n            reject(e)\\n        }\\n    }\\n    helper();\\n\\n    return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445591,
                "title": "a-support-request-to-leetcode",
                "content": "# To Leetcode team\\n\\nHi, so I have a solution that has a bug which manages to pass all the given testcases in the description. However, when I submit it as a solution, it fails and the evaluator says 0 testcases passed. This is not true because if I add logs I can see that most testcases are passing. There seems to be some error in figuring out which testcases are failing for this kind of question. If you have someone available can you look at why that happens with this submission:\\n\\nThing to check:\\n1. Paste this submission\\n2. Run button says all 7 testcases passed\\n3. Submit and the evaluator will say 0 testcases passed\\n\\nNote that I know where the bug is and how to fix it. I have already submitted another solution which fixes the problem. However, I was troubled by the evaluator reporting 0 cases passing. Note also that yo can return the function that is getting assigned to `cancellable` from inside an IIFE to ensure even more isolation but the problem stays.\\n\\n```\\nvar cancellable = function(generator) {\\n    let isCancelled = false;\\n    let cancelledWithValue = false;\\n    let postCancellationValue;\\n    \\n    async function processGen(lastValue) {\\n        if (isCancelled) {\\n            return new Promise((res, rej) => { debugger; rej(\"Cancelled\") });\\n        } \\n        else if (cancelledWithValue) {\\n            return new Promise((res, rej) => { debugger; res(postCancellationValue) });\\n        }\\n        else \\n        {\\n            try {\\n                debugger\\n                const genyield = generator.next(lastValue);\\n                debugger\\n                if (!genyield.done) {\\n                    const promise = new Promise((res, rej) => {\\n                        genyield.value\\n                            .then((result) => {debugger; res(processGen(result))})\\n                            .catch(err => {\\n                                // console.log(err); \\n                                debugger\\n                                const genyield = generator.throw(err);\\n                                if (genyield.done) {\\n                                    genyield.value.then(res).catch(res);\\n                                } else {\\n                                    res(genyield.value.then(result => processGen(result)));\\n                                }\\n                            });\\n                    });\\n                    return promise;\\n                } else {\\n                    return genyield.value;\\n                }\\n            } catch (err) {\\n                // console.log(\"Catch cancel error\", err);\\n                return new Promise((res, rej) => { debugger; rej(err) })\\n            }\\n        }\\n    }\\n\\n    return [\\n        () => { \\n            try {\\n                const genyield = generator.throw(new Error(\"Cancellinig\"));\\n                cancelledWithValue = true;\\n                postCancellationValue = genyield.value;\\n                debugger\\n                console.log(genyield);\\n            } catch (err) {\\n                isCancelled = true;\\n                // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n            }\\n        }, \\n        processGen()\\n    ];\\n}\\n```\\n\\n# Actual solution that works\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let isCancelled = false;\\n  let cancelledWithValue = false;\\n  let postCancellationValue;\\n\\n  async function processGen(lastPromise) {\\n    if (isCancelled) {\\n      return new Promise((res, rej) => { rej(\"Cancelled\") });\\n    } \\n    else if (cancelledWithValue) {\\n      return new Promise((res, rej) => { res(postCancellationValue) });\\n    }\\n    else \\n    {\\n      let lastValue;\\n      let genyield;\\n      try {\\n        lastValue = await lastPromise;\\n        genyield = generator.next(lastValue);\\n      } catch (err) {\\n        lastValue = err;\\n        genyield = generator.throw(lastValue);\\n        console.log(\"Last promise did not resolve!\");\\n      }\\n\\n      try {\\n        if (!genyield.done && !isCancelled && !cancelledWithValue) {\\n            return processGen(genyield.value);\\n        } else if (isCancelled) {\\n            return Promise.reject(\"Cancelled\");\\n        } else if (cancelledWithValue) {\\n            return Promise.resolve(postCancellationValue);\\n        } else {\\n          return genyield.value;\\n        }\\n      } catch (err) {\\n        // console.log(\"Catch cancel error\", err);\\n        return new Promise((res, rej) => { rej(err) })\\n      }\\n    }\\n  }\\n\\n  return [\\n    () => { \\n      try {\\n        const genyield = generator.throw(\"Cancelled\");\\n        cancelledWithValue = true;\\n        postCancellationValue = genyield.value;\\n        console.log(genyield);\\n      } catch (err) {\\n        isCancelled = true;\\n        // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n      }\\n    }, \\n    processGen()\\n  ];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(generator) {\\n    let isCancelled = false;\\n    let cancelledWithValue = false;\\n    let postCancellationValue;\\n    \\n    async function processGen(lastValue) {\\n        if (isCancelled) {\\n            return new Promise((res, rej) => { debugger; rej(\"Cancelled\") });\\n        } \\n        else if (cancelledWithValue) {\\n            return new Promise((res, rej) => { debugger; res(postCancellationValue) });\\n        }\\n        else \\n        {\\n            try {\\n                debugger\\n                const genyield = generator.next(lastValue);\\n                debugger\\n                if (!genyield.done) {\\n                    const promise = new Promise((res, rej) => {\\n                        genyield.value\\n                            .then((result) => {debugger; res(processGen(result))})\\n                            .catch(err => {\\n                                // console.log(err); \\n                                debugger\\n                                const genyield = generator.throw(err);\\n                                if (genyield.done) {\\n                                    genyield.value.then(res).catch(res);\\n                                } else {\\n                                    res(genyield.value.then(result => processGen(result)));\\n                                }\\n                            });\\n                    });\\n                    return promise;\\n                } else {\\n                    return genyield.value;\\n                }\\n            } catch (err) {\\n                // console.log(\"Catch cancel error\", err);\\n                return new Promise((res, rej) => { debugger; rej(err) })\\n            }\\n        }\\n    }\\n\\n    return [\\n        () => { \\n            try {\\n                const genyield = generator.throw(new Error(\"Cancellinig\"));\\n                cancelledWithValue = true;\\n                postCancellationValue = genyield.value;\\n                debugger\\n                console.log(genyield);\\n            } catch (err) {\\n                isCancelled = true;\\n                // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n            }\\n        }, \\n        processGen()\\n    ];\\n}\\n```\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let isCancelled = false;\\n  let cancelledWithValue = false;\\n  let postCancellationValue;\\n\\n  async function processGen(lastPromise) {\\n    if (isCancelled) {\\n      return new Promise((res, rej) => { rej(\"Cancelled\") });\\n    } \\n    else if (cancelledWithValue) {\\n      return new Promise((res, rej) => { res(postCancellationValue) });\\n    }\\n    else \\n    {\\n      let lastValue;\\n      let genyield;\\n      try {\\n        lastValue = await lastPromise;\\n        genyield = generator.next(lastValue);\\n      } catch (err) {\\n        lastValue = err;\\n        genyield = generator.throw(lastValue);\\n        console.log(\"Last promise did not resolve!\");\\n      }\\n\\n      try {\\n        if (!genyield.done && !isCancelled && !cancelledWithValue) {\\n            return processGen(genyield.value);\\n        } else if (isCancelled) {\\n            return Promise.reject(\"Cancelled\");\\n        } else if (cancelledWithValue) {\\n            return Promise.resolve(postCancellationValue);\\n        } else {\\n          return genyield.value;\\n        }\\n      } catch (err) {\\n        // console.log(\"Catch cancel error\", err);\\n        return new Promise((res, rej) => { rej(err) })\\n      }\\n    }\\n  }\\n\\n  return [\\n    () => { \\n      try {\\n        const genyield = generator.throw(\"Cancelled\");\\n        cancelledWithValue = true;\\n        postCancellationValue = genyield.value;\\n        console.log(genyield);\\n      } catch (err) {\\n        isCancelled = true;\\n        // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n      }\\n    }, \\n    processGen()\\n  ];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440819,
                "title": "design-cancellable-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let reject = null, resolve = null;\\n\\n    let n, value;\\n    let promise = new Promise<T>(async (res,rej) => {\\n        reject = rej;\\n        resolve = res;\\n        try {\\n            for (n = generator.next(); !n.done; n = generator.next(value)) {\\n                value = await n.value;\\n            }\\n\\n            res(n.value);\\n\\n        } catch(err) {\\n            await handleError(err);\\n        }\\n    });\\n\\n    async function handleError(err) {\\n        try {\\n            console.log(\\'in handle err\\');\\n\\n            try {\\n                n = generator.throw(err);\\n            } catch(e) {\\n                reject(err);\\n                return;\\n            }\\n\\n            value = await n.value;\\n\\n            while(!n.done) {\\n                n = generator.next(value);\\n                value = await n.value;\\n                console.log(value, n.done);\\n            }\\n            value != void 0 ? resolve(value) : reject(err);\\n        } catch(e) {\\n            console.log(e, value);\\n\\n            await handleError(err)\\n        }\\n    }\\n\\n    const cancel = async () => {\\n        try {\\n            n = generator.throw(value);\\n            value = await n.value;\\n            resolve(value != void 0 ? value : \"Cancelled\");\\n        } catch(err) {\\n            reject(\"Cancelled\");\\n        }\\n\\n    }\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let reject = null, resolve = null;\\n\\n    let n, value;\\n    let promise = new Promise<T>(async (res,rej) => {\\n        reject = rej;\\n        resolve = res;\\n        try {\\n            for (n = generator.next(); !n.done; n = generator.next(value)) {\\n                value = await n.value;\\n            }\\n\\n            res(n.value);\\n\\n        } catch(err) {\\n            await handleError(err);\\n        }\\n    });\\n\\n    async function handleError(err) {\\n        try {\\n            console.log(\\'in handle err\\');\\n\\n            try {\\n                n = generator.throw(err);\\n            } catch(e) {\\n                reject(err);\\n                return;\\n            }\\n\\n            value = await n.value;\\n\\n            while(!n.done) {\\n                n = generator.next(value);\\n                value = await n.value;\\n                console.log(value, n.done);\\n            }\\n            value != void 0 ? resolve(value) : reject(err);\\n        } catch(e) {\\n            console.log(e, value);\\n\\n            await handleError(err)\\n        }\\n    }\\n\\n    const cancel = async () => {\\n        try {\\n            n = generator.throw(value);\\n            value = await n.value;\\n            resolve(value != void 0 ? value : \"Cancelled\");\\n        } catch(err) {\\n            reject(\"Cancelled\");\\n        }\\n\\n    }\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025306,
                "title": "recursive-solution-and-easy-to-understand",
                "content": "# Intuition\\n1. Ready the doc of Generator before you start to read or write the code:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw\\n2. Fully underatand how Promise works is the required skill\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let reject = null\\n    let accept = null\\n    let promise = new Promise((r, j) => {\\n        reject = j\\n        accept = r\\n        \\n        // A recursion to process generator.next()\\n        function process(value, done) {\\n          const g = generator.next(value)\\n          const valuePromise = Promise.resolve(g.value)\\n          if (g.done) {\\n            valuePromise.then(done).catch(reject)\\n            return\\n          }\\n\\n          // A recursion to process nested try catch in the generator function\\n          function processCatch(value) {\\n            try {\\n                const result = generator.throw(new Error(\\'Cancelled\\'))\\n                if (result.done) {\\n                  Promise.resolve(value).then(accept)\\n                } else {\\n                  Promise.resolve(result.value).then((v) => {\\n                    process(v, done)\\n                  }).catch((v) => {\\n                    processCatch(v)\\n                  })\\n                }\\n            } catch (err) {\\n              reject(value)\\n            }\\n          }\\n          valuePromise.then((value) => {\\n            process(value, done)\\n          }).catch(processCatch)\\n        }\\n        process(null, accept)\\n    })\\n    return [function() {\\n      try {\\n        const result = generator.throw(\\'Cancelled\\')\\n         if (result.done) {\\n            accept(result.value)\\n        } else {\\n            reject(\\'Cancelled\\')\\n        }\\n      } catch (err) {\\n        reject(err)\\n        return\\n      }\\n     \\n    }, promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let reject = null\\n    let accept = null\\n    let promise = new Promise((r, j) => {\\n        reject = j\\n        accept = r\\n        \\n        // A recursion to process generator.next()\\n        function process(value, done) {\\n          const g = generator.next(value)\\n          const valuePromise = Promise.resolve(g.value)\\n          if (g.done) {\\n            valuePromise.then(done).catch(reject)\\n            return\\n          }\\n\\n          // A recursion to process nested try catch in the generator function\\n          function processCatch(value) {\\n            try {\\n                const result = generator.throw(new Error(\\'Cancelled\\'))\\n                if (result.done) {\\n                  Promise.resolve(value).then(accept)\\n                } else {\\n                  Promise.resolve(result.value).then((v) => {\\n                    process(v, done)\\n                  }).catch((v) => {\\n                    processCatch(v)\\n                  })\\n                }\\n            } catch (err) {\\n              reject(value)\\n            }\\n          }\\n          valuePromise.then((value) => {\\n            process(value, done)\\n          }).catch(processCatch)\\n        }\\n        process(null, accept)\\n    })\\n    return [function() {\\n      try {\\n        const result = generator.throw(\\'Cancelled\\')\\n         if (result.done) {\\n            accept(result.value)\\n        } else {\\n            reject(\\'Cancelled\\')\\n        }\\n      } catch (err) {\\n        reject(err)\\n        return\\n      }\\n     \\n    }, promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951692,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Code\\n```\\nconst cancellable = (generator) => {\\n  let resolve = () => {};\\n  let reject = () => {};\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const handleError = (e, shouldResolve) => {\\n    try {\\n      if (!shouldResolve) return generator.throw(e);\\n      resolve(generator.throw(e).value);\\n    } catch (err) {\\n      reject(err);\\n    }\\n  };\\n\\n  const handleLoop = (cur) => {\\n    if (!cur) return;\\n    if (cur.done) return resolve(cur.value);\\n    cur.value\\n      .then((val) => handleLoop(generator.next(val)))\\n      .catch((err) => handleLoop(handleError(err, false)));\\n  };\\n\\n  handleLoop({\\n    value: Promise.resolve(),\\n    done: false,\\n  });\\n\\n  return [() => handleError(\"Cancelled\", true), promise];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = (generator) => {\\n  let resolve = () => {};\\n  let reject = () => {};\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const handleError = (e, shouldResolve) => {\\n    try {\\n      if (!shouldResolve) return generator.throw(e);\\n      resolve(generator.throw(e).value);\\n    } catch (err) {\\n      reject(err);\\n    }\\n  };\\n\\n  const handleLoop = (cur) => {\\n    if (!cur) return;\\n    if (cur.done) return resolve(cur.value);\\n    cur.value\\n      .then((val) => handleLoop(generator.next(val)))\\n      .catch((err) => handleLoop(handleError(err, false)));\\n  };\\n\\n  handleLoop({\\n    value: Promise.resolve(),\\n    done: false,\\n  });\\n\\n  return [() => handleError(\"Cancelled\", true), promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847351,
                "title": "posted-my-first-solution-on-leetcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    let isCancelled = false\\n    \\n    function cancelFunction() {\\n        isCancelled = true\\n    }\\n    \\n    const promise = new Promise(async (resolve, reject) => {\\n        let resolvedValue\\n        try {\\n let { done, value: pr } = generator.next()\\n        if(done) {\\n            resolvedValue = pr\\n            resolve(resolvedValue)\\n        }\\n            while(done === false) {\\n                try {\\n                const value = await pr\\n                let d, v\\n                if(isCancelled) {\\n                    const { done: d1, value: v1 } = generator.throw(\\'Cancelled\\')\\n                    d = d1\\n                    v = v1\\n                }\\n                else {\\n                    const { done: d2, value: v2 } = generator.next(value)\\n                    d = d2\\n                    v = v2\\n                }\\n                resolvedValue = v\\n                done = d\\n                pr = v\\n                if(done) {\\n                    resolvedValue = pr\\n                    resolve(resolvedValue)\\n                }\\n            }\\n            catch(err) {\\n                try {\\n                    const { done: d1, value: v1 } = generator.throw(err)\\n                    if(d1) {\\n                        done = true\\n                        resolve(err)\\n                    }\\n                    else {\\n                        done = d1\\n                        pr = v1\\n                    }\\n                }\\n                catch (err) {\\n                    done = true\\n                    reject(err)\\n                }\\n            }\\n        }\\n        }\\n\\n        catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancelFunction, promise]\\n    \\n}\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    let isCancelled = false\\n    \\n    function cancelFunction() {\\n        isCancelled = true\\n    }\\n    \\n    const promise = new Promise(async (resolve, reject) => {\\n        let resolvedValue\\n        try {\\n let { done, value: pr } = generator.next()\\n        if(done) {\\n            resolvedValue = pr\\n            resolve(resolvedValue)\\n        }\\n            while(done === false) {\\n                try {\\n                const value = await pr\\n                let d, v\\n                if(isCancelled) {\\n                    const { done: d1, value: v1 } = generator.throw(\\'Cancelled\\')\\n                    d = d1\\n                    v = v1\\n                }\\n                else {\\n                    const { done: d2, value: v2 } = generator.next(value)\\n                    d = d2\\n                    v = v2\\n                }\\n                resolvedValue = v\\n                done = d\\n                pr = v\\n                if(done) {\\n                    resolvedValue = pr\\n                    resolve(resolvedValue)\\n                }\\n            }\\n            catch(err) {\\n                try {\\n                    const { done: d1, value: v1 } = generator.throw(err)\\n                    if(d1) {\\n                        done = true\\n                        resolve(err)\\n                    }\\n                    else {\\n                        done = d1\\n                        pr = v1\\n                    }\\n                }\\n                catch (err) {\\n                    done = true\\n                    reject(err)\\n                }\\n            }\\n        }\\n        }\\n\\n        catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancelFunction, promise]\\n    \\n}\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742714,
                "title": "recursive-solution-without-using-async-await",
                "content": "# Approach\\nI solved this problem without using async/await. Recursive `iterator` sets and reads a closure variable `rejected` and routes the value back to the iterator.\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function (generator) {\\n    // this is a boilerplate to get a cancel function that rejects a `Promise` captured in the function closure.\\n    let cancelFn;\\n    const cancelPromise = new Promise((_, reject) => {\\n        cancelFn = () => reject(\"Cancelled\");\\n    });\\n    cancelPromise.catch(() => { });\\n\\n    let rejected = false\\n\\n    // helper functions used in promise chaining \\n    function reject(val) {\\n        rejected = true\\n        return val\\n    }\\n    function accept(val) {\\n        rejected = false\\n        return val\\n    }\\n\\n\\n    // recursive iterator\\n    function iterator(lastVal) {\\n        let res\\n        if (rejected) {\\n            res = generator.throw(lastVal)\\n        } else {\\n            try {\\n                res = generator.next(lastVal)\\n            } catch (e) {\\n                return Promise.reject(e)\\n            }\\n        }\\n        // once iterator is done just resolve it\\'s value\\n        if (res.done) {\\n            return Promise.resolve(res.value)\\n        }\\n        \\n        return Promise\\n            .race([Promise.resolve(res.value), cancelPromise]) // while iterator is not done, race it with cancel function\\n            .then(accept, reject) // set rejected true of false\\n            .then(iterator, iterator) // recursive call for resolved and rejected promise\\n    }\\n\\n    return [cancelFn, iterator()]\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Approach\\nI solved this problem without using async/await. Recursive `iterator` sets and reads a closure variable `rejected` and routes the value back to the iterator.\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function (generator) {\\n    // this is a boilerplate to get a cancel function that rejects a `Promise` captured in the function closure.\\n    let cancelFn;\\n    const cancelPromise = new Promise((_, reject) => {\\n        cancelFn = () => reject(\"Cancelled\");\\n    });\\n    cancelPromise.catch(() => { });\\n\\n    let rejected = false\\n\\n    // helper functions used in promise chaining \\n    function reject(val) {\\n        rejected = true\\n        return val\\n    }\\n    function accept(val) {\\n        rejected = false\\n        return val\\n    }\\n\\n\\n    // recursive iterator\\n    function iterator(lastVal) {\\n        let res\\n        if (rejected) {\\n            res = generator.throw(lastVal)\\n        } else {\\n            try {\\n                res = generator.next(lastVal)\\n            } catch (e) {\\n                return Promise.reject(e)\\n            }\\n        }\\n        // once iterator is done just resolve it\\'s value\\n        if (res.done) {\\n            return Promise.resolve(res.value)\\n        }\\n        \\n        return Promise\\n            .race([Promise.resolve(res.value), cancelPromise]) // while iterator is not done, race it with cancel function\\n            .then(accept, reject) // set rejected true of false\\n            .then(iterator, iterator) // recursive call for resolved and rejected promise\\n    }\\n\\n    return [cancelFn, iterator()]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3672778,
                "title": "faster-and-easier-solution-to-undestand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAnother quick and simple solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let isCancelled = false\\n    function cancel() {\\n        isCancelled = true\\n    }\\n\\n    const promise = new Promise<T>(async (resolve, reject) => {\\n        try {\\n            let lastYielded = generator.next()\\n            while (!lastYielded.done) {\\n                try {\\n                    const res = await lastYielded.value\\n                    lastYielded = isCancelled ? generator.throw(\"Cancelled\") : generator.next(res)\\n                } catch(err) {\\n                    lastYielded = generator.throw(err)\\n                }\\n            }\\n            resolve(lastYielded.value)\\n        } catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancel, promise]\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let isCancelled = false\\n    function cancel() {\\n        isCancelled = true\\n    }\\n\\n    const promise = new Promise<T>(async (resolve, reject) => {\\n        try {\\n            let lastYielded = generator.next()\\n            while (!lastYielded.done) {\\n                try {\\n                    const res = await lastYielded.value\\n                    lastYielded = isCancelled ? generator.throw(\"Cancelled\") : generator.next(res)\\n                } catch(err) {\\n                    lastYielded = generator.throw(err)\\n                }\\n            }\\n            resolve(lastYielded.value)\\n        } catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancel, promise]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3632981,
                "title": "brief-explanation-in-typescript-using-try-catch-syntax",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`genCall` is a function which calls the next yielding element and if it is not done yielding it keeps calling itself in turns to the point of resolution.\\nSame functionality is needed when we throw something to generator which is handled by explicitThrow param which is by default false.\\nwhile cancelling we simply call `genCall( \"Cancelled\",true);` that handles the rest for us.\\n\\nNote within `genCall` there are two try catch blocks, first one simply rejects as, if there is some error that is now handled and happens during generator function execution it should be rejected. While in the second one we are seeking if there is some error thrown from the promise that is returned in that case we simply chain that value to next call. \\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let res,rej,done=false;  \\n    let promise: Promise<T> = new Promise(async (rs,rj)=>{\\n        rej=rj;\\n        res=rs\\n    })\\n    async function genCall(val?:any,explicitThrow:boolean=false){\\n     let genData;\\n     try{\\n     genData = explicitThrow?generator.throw(val): generator.next(val);\\n    }catch(err){\\n        rej(err);\\n        return;\\n    }\\n     try{\\n        if(genData.done){\\n            let result= await genData.value\\n            done=true;\\n            res(result);\\n            return;\\n        }\\n        else{\\n              let result= await genData.value\\n              genCall(result);\\n        }\\n     }\\n     catch(err){\\n                  genCall( err,true);\\n     }\\n\\n    }\\n    genCall();\\n    return [()=>{    \\n                try {\\n                    genCall( \"Cancelled\",true);\\n                } \\n                catch (e) {\\n                    rej(e);\\n                }\\n    },promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let res,rej,done=false;  \\n    let promise: Promise<T> = new Promise(async (rs,rj)=>{\\n        rej=rj;\\n        res=rs\\n    })\\n    async function genCall(val?:any,explicitThrow:boolean=false){\\n     let genData;\\n     try{\\n     genData = explicitThrow?generator.throw(val): generator.next(val);\\n    }catch(err){\\n        rej(err);\\n        return;\\n    }\\n     try{\\n        if(genData.done){\\n            let result= await genData.value\\n            done=true;\\n            res(result);\\n            return;\\n        }\\n        else{\\n              let result= await genData.value\\n              genCall(result);\\n        }\\n     }\\n     catch(err){\\n                  genCall( err,true);\\n     }\\n\\n    }\\n    genCall();\\n    return [()=>{    \\n                try {\\n                    genCall( \"Cancelled\",true);\\n                } \\n                catch (e) {\\n                    rej(e);\\n                }\\n    },promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3622155,
                "title": "using-recursion",
                "content": "# Intuition\\nSolution using recursion\\n\\n\\n# Code\\n```\\n// A RECURSIVE VERSION\\n\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    var promiseResolve;\\n    var promiseReject\\n\\n    var handleNextPromise = function({ value, done}) {\\n        if(done) promiseResolve(value);\\n        else value\\n        .then( resolved => handleNextPromise(generator.next(resolved)))\\n        .catch(err => {\\n            try { handleNextPromise(generator.throw(err)) }\\n            catch {promiseReject(err)}\\n        });\\n    }\\n\\n    var promise = new Promise(\\n        (resolve, reject) => {\\n            promiseResolve = resolve;\\n            promiseReject = reject;\\n            handleNextPromise(generator.next(undefined));\\n        }\\n    );\\n\\n    var cancel = () => {\\n        try {\\n            var {value: lastValue, done: lastDone} = generator.throw(\"Cancelled\");\\n            promiseResolve(lastValue)\\n        } catch(generatorError) {\\n            promiseReject(generatorError);\\n        }\\n    }\\n\\n    return [cancel, promise];\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// A RECURSIVE VERSION\\n\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    var promiseResolve;\\n    var promiseReject\\n\\n    var handleNextPromise = function({ value, done}) {\\n        if(done) promiseResolve(value);\\n        else value\\n        .then( resolved => handleNextPromise(generator.next(resolved)))\\n        .catch(err => {\\n            try { handleNextPromise(generator.throw(err)) }\\n            catch {promiseReject(err)}\\n        });\\n    }\\n\\n    var promise = new Promise(\\n        (resolve, reject) => {\\n            promiseResolve = resolve;\\n            promiseReject = reject;\\n            handleNextPromise(generator.next(undefined));\\n        }\\n    );\\n\\n    var cancel = () => {\\n        try {\\n            var {value: lastValue, done: lastDone} = generator.throw(\"Cancelled\");\\n            promiseResolve(lastValue)\\n        } catch(generatorError) {\\n            promiseReject(generatorError);\\n        }\\n    }\\n\\n    return [cancel, promise];\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3606837,
                "title": "efficient-cancellable-promises-in-typescript-achieving-control-and-flexibility-in-asynchronous",
                "content": "# Intuition\\nThe code is implementing a cancellable promise in JavaScript. It makes use of generators and promises to achieve this. The `cancellable` function takes a generator as an argument. This generator is expected to yield promises. The `cancellable` function returns a pair consisting of a cancel function and a promise. When the cancel function is called, the promise gets rejected with the reason \\'Cancelled\\'.\\n\\n# Approach\\nThe `cancellable` function starts by initializing some variables. It then creates a promise which will be returned and used for the computation. This promise is handled by an `async` function which is immediately invoked. This function calls `next` on the generator and enters a loop. Inside the loop, it waits for the promise yielded by the generator to be fulfilled or for the cancel promise to be fulfilled, whichever happens first. If the cancel promise is fulfilled, an error is thrown which is caught and rethrown to the generator. The loop continues until the generator is done.\\n\\nIf the cancel function is called, it rejects the cancel promise, which causes the promise race to resolve with an error. This error is then propagated through the generator, causing the computation to be cancelled.\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n), where n is the number of promises yielded by the generator. This is because we\\'re going through each yielded promise one by one.\\n- Space complexity: The space complexity is O(1), as we\\'re only using a constant amount of space. No matter the number of promises yielded by the generator, we\\'re only storing a constant amount of variables.\\n\\n# Code\\n\\n```typescript\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let cancelRequested = false;\\n    let resolveFunc: (value: T | PromiseLike<T>) => void;\\n    let rejectFunc: (reason?: any) => void;\\n    let cancelFunc: () => void;\\n\\n    const promise = new Promise<T>((resolve, reject) => {\\n        resolveFunc = resolve;\\n        rejectFunc = reject;\\n\\n        const cancelPromise = new Promise((_, reject) => {\\n            cancelFunc = () => reject(\\'Cancelled\\');\\n        });\\n\\n        const run = async () => {\\n            try {\\n                let result = generator.next();\\n                while (true) {\\n                    if (result.done) {\\n                        resolveFunc(result.value);\\n                        return;\\n                    }\\n                    try {\\n                        const value = await Promise.race([result.value, cancelPromise]);\\n                        result = generator.next(value);\\n                    } catch (err) {\\n                        result = generator.throw(err);\\n                    }\\n                }\\n            } catch (err) {\\n                rejectFunc(err);\\n            }\\n        };\\n\\n        run();\\n    });\\n\\n    const cancel = () => {\\n        cancelRequested = true;\\n        cancelFunc();\\n    };\\n\\n    return [cancel, promise];\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let cancelRequested = false;\\n    let resolveFunc: (value: T | PromiseLike<T>) => void;\\n    let rejectFunc: (reason?: any) => void;\\n    let cancelFunc: () => void;\\n\\n    const promise = new Promise<T>((resolve, reject) => {\\n        resolveFunc = resolve;\\n        rejectFunc = reject;\\n\\n        const cancelPromise = new Promise((_, reject) => {\\n            cancelFunc = () => reject(\\'Cancelled\\');\\n        });\\n\\n        const run = async () => {\\n            try {\\n                let result = generator.next();\\n                while (true) {\\n                    if (result.done) {\\n                        resolveFunc(result.value);\\n                        return;\\n                    }\\n                    try {\\n                        const value = await Promise.race([result.value, cancelPromise]);\\n                        result = generator.next(value);\\n                    } catch (err) {\\n                        result = generator.throw(err);\\n                    }\\n                }\\n            } catch (err) {\\n                rejectFunc(err);\\n            }\\n        };\\n\\n        run();\\n    });\\n\\n    const cancel = () => {\\n        cancelRequested = true;\\n        cancelFunc();\\n    };\\n\\n    return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1877960,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            },
            {
                "id": 1886735,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            },
            {
                "id": 1941911,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Counter II",
        "question_content": "<p>Write a function&nbsp;<code>createCounter</code>. It should accept an initial integer&nbsp;<code>init</code>. It should return an object with three functions.</p>\n\n<p>The three functions are:</p>\n\n<ul>\n\t<li><code>increment()</code>&nbsp;increases&nbsp;the current value by 1 and then returns it.</li>\n\t<li><code>decrement()</code>&nbsp;reduces the current value by 1 and then returns it.</li>\n\t<li><code>reset()</code>&nbsp;sets the current value to&nbsp;<code>init</code>&nbsp;and then returns it.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> init = 5, calls = [&quot;increment&quot;,&quot;reset&quot;,&quot;decrement&quot;]\n<strong>Output:</strong> [6,5,4]\n<strong>Explanation:</strong>\nconst counter = createCounter(5);\ncounter.increment(); // 6\ncounter.reset(); // 5\ncounter.decrement(); // 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> init = 0, calls = [&quot;increment&quot;,&quot;increment&quot;,&quot;decrement&quot;,&quot;reset&quot;,&quot;reset&quot;]\n<strong>Output:</strong> [1,2,1,0,0]\n<strong>Explanation:</strong>\nconst counter = createCounter(0);\ncounter.increment(); // 1\ncounter.increment(); // 2\ncounter.decrement(); // 1\ncounter.reset(); // 0\ncounter.reset(); // 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-1000 &lt;= init &lt;= 1000</code></li>\n\t<li><code>0 &lt;= calls.length &lt;= 1000</code></li>\n\t<li><code>calls[i]</code> is one of &quot;increment&quot;, &quot;decrement&quot; and&nbsp;&quot;reset&quot;</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3494650,
                "title": "day3-o-1-solving-it-in-3-different-ways-and-which-one-is-the-best-way",
                "content": "From the question we can decipher that we need to have three functions `increment(), decrement() and reset()`. Now let\\'s think which one will be appropriate method to solve this question.\\n***\\n## 1. Using Traditional Function\\n* A **traditional function** is defined using the `function` keyword. It can be a **named function** or an **anonymous function** assigned to a variable. \\n* In the following code we have created three functions  `increment()`, `decrement()` and `reset()` using the `function` keyword. Inside this function we need to do the appropriate operation that was instructed in the question i.e. for `increment()` we need to return the `currentvalue+1`, similarly in `decrement()` we need to return the `currentvalue-1` and in `reset()` we need to assign `originalvalue` to the `currentvalue`.\\n```\\nvar createCounter = function(init) {\\n  let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n```\\n**Time and Space: O(1)**\\n***\\n## 2. Using Arrow Function\\n* An **arrow function** is a shorter syntax for defining functions, introduced in ES6. \\n* It uses the **=> syntax** instead of the function keyword, and has some differences in behavior compared to traditional functions, such as **inheriting** the `this` value from the **surrounding context**\\n* For better understanding please read this posts : **Arrow function**(6min read) by **[@Jatin](https://leetcode.com/problems/create-hello-world-function/discuss/3486895/DAY(O(1))-Why-you-should-prefer-arrow-function-syntax!)** and **Closure on Counter-1**(8min read) problem by **[@Jatin](https://leetcode.com/problems/counter/discuss/3491300/Day2O(1)greaterUnderstanding-Closure-in-easy-way-and-its-practical-uses!!)**\\n\\n```\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n```\\n**Time and Space: O(1)**\\n***\\n## 3. Using Class\\n* A **class** is a template for creating objects with a set of properties and methods.\\n* In `ES6`, `classes` were introduced as syntactic sugar over the prototype-based inheritance model but shortly after that It **provided a way to support inheritance and can have static methods and properties, getters and setters, and more**. Thus they provided a way to write object-oriented code in a more concise and organized way.\\n\\n* In the following example the `Couter` is the name of the class.\\n\\t*  The constructor method is a special method that is called when an **object is created based on the class**.\\n\\t*  It initializes the object with properties `init` and `presentCount`. The `increment()`, `decrement()`and `reset()` method are regular methods that can be **called on an instance** of the `Counter` class to get the output\\n\\t* To create an object based on a class we use the `new` operator i.e. we create an object called `createCounter` based on the `Counter` class, passing in the `init` value as **arguments to the constructor**.\\n\\n```\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.presentCount = init;\\n  }\\n\\n  increment() {\\n    this.presentCount += 1;\\n    return this.presentCount;\\n  }\\n\\n  decrement() {\\n    this.presentCount -= 1;\\n    return this.presentCount;\\n  }\\n\\n  reset() {\\n    this.presentCount = this.init;\\n    return this.presentCount;\\n  }\\n}\\n\\nvar createCounter = function(init) {\\n  return new Counter(init);\\n};\\n```\\n**Time and Space: O(1)**\\n***\\n## In conclusion which one is the better way??\\n* **Classes** are useful for creating objects with shared behavior.\\n*  **Traditional functions** are useful for reusable chunks of code\\n*   **Arrow functions** are useful for short, concise functions or when preserving the value of `this` is important.\\n* Thus, I believe that classes are the best way to implement this types of problems in real life as they give flexibility of scaling with the shared behaviour properties. \\n***\\nYou can support this article by upvoitng \\u2B06\\u2B06!!\\n***\\nHere\\'s my [github link](https://github.com/Jatin-Shihora) where I keep my solutions.\\n***",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n  let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n```\n```\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n```\n```\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.presentCount = init;\\n  }\\n\\n  increment() {\\n    this.presentCount += 1;\\n    return this.presentCount;\\n  }\\n\\n  decrement() {\\n    this.presentCount -= 1;\\n    return this.presentCount;\\n  }\\n\\n  reset() {\\n    this.presentCount = this.init;\\n    return this.presentCount;\\n  }\\n}\\n\\nvar createCounter = function(init) {\\n  return new Counter(init);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495319,
                "title": "2665-counter-ii-level-up-your-javascript-skills-with-these-intuitive-implementations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>The `createCounter` function creates a counter object that can be used to keep track of a count and perform operations on it. The returned object has three methods: `increment`, `decrement`, and `reset`, which respectively increase the count by 1, decrease the count by 1, and reset the count to its initial value.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>The `createCounter` function uses a closure to create a private `count` variable that is initialized to either the provided `init` value or 0 if no value is provided. It then defines three inner functions (`increment`, `decrement`, and `reset`) that operate on this count variable and return its new value. Finally, it returns an object containing these three functions as properties, providing a public interface for manipulating the count.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>The `createCounter` function has a space complexity of O(1) as it creates a fixed number of variables (count, increment, decrement, reset) that are not dependent on the size of the input\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>Each instance of the counter object created by `createCounter` has a space complexity of O(1) as well, as it only contains three function properties and the count variable, which are all fixed-size.\\n\\n\\n# Code\\n```Javascript []\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let count = init || 0; // initialize count to 0 or given value\\n\\n  const increment = function() {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = function() {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = function() {\\n    count = init || 0;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n``` typescript []\\ninterface Counter {\\n  increment(): number;\\n  decrement(): number;\\n  reset(): number;\\n}\\n\\nconst createCounter = (init: number = 0): Counter => {\\n  let count: number = init;\\n\\n  const increment = (): number => {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = (): number => {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = (): number => {\\n    count = init;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\nconst counter: Counter = createCounter(5);\\n\\nconsole.log(counter.increment()); // 6\\nconsole.log(counter.reset()); // 5\\nconsole.log(counter.decrement()); // 4\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n> ##### There are several ways to implement a counter object with increment, decrement, and reset functionality in JavaScript. Here are a few alternative approaches:\\n\\n1. Using an ES6 class\\n```\\nclass Counter {\\n  constructor(init = 0) {\\n    this.count = init;\\n  }\\n\\n  increment() {\\n    return ++this.count;\\n  }\\n\\n  decrement() {\\n    return --this.count;\\n  }\\n\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n}\\n```\\n>Here, we define a `Counter` class with a constructor that takes an optional `init` parameter (defaulting to 0). We also define three methods (`increment`, `decrement`, and `reset`) that modify the `count` property and return its new value.\\n\\n\\n2. Using an object literal\\n```\\nconst counter = {\\n  count: 0,\\n  increment() {\\n    return ++this.count;\\n  },\\n  decrement() {\\n    return --this.count;\\n  },\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n};\\n\\n```\\n>Here, we define an object literal with a `count` property and three methods (`increment`, `decrement`, and `reset`) that modify the `count` property and return its new value.\\n3. Using a factory function\\n```\\nfunction createCounter(init = 0) {\\n  let count = init;\\n\\n  return {\\n    increment() {\\n      return ++count;\\n    },\\n    decrement() {\\n      return --count;\\n    },\\n    reset() {\\n      count = 0;\\n      return count;\\n    }\\n  };\\n}\\n```\\n>Here, we define a `createCounter` factory function that returns an object with three methods (`increment`, `decrement`, and `reset`) that modify a private `count` variable and return its new value.\\n\\n# Important topic to Learn\\n```\\n1. Closures: A closure is a function that has access to variables in\\n its outer lexical environment. The original implementation of the \\n`createCounter` function uses a closure to create a private `count`\\n variable that is shared by the `increment`, `decrement`, and `reset`\\n functions. Understanding closures is essential for writing clean \\nand efficient JavaScript code.\\n\\n2. Object-oriented programming (OOP): OOP is a programming paradigm \\nthat uses objects and classes to encapsulate data and behavior. The \\nES6 class-based implementation of the counter object demonstrates\\nhow to define a class with properties and methods, while the object \\nliteral and factory function approaches use object-based programming \\nto define a set of related methods.\\n\\n3. JavaScript syntax: Understanding basic JavaScript syntax is \\nessential for writing clean and readable code. The original \\nimplementation and alternative approaches use different syntax \\nelements, such as arrow functions, default parameter values, and \\nobject destructuring, that are common in modern JavaScript code.\\n\\n4. DOM manipulation: If you\\'re interested in front-end web \\ndevelopment, you\\'ll need to learn how to manipulate the Document \\nObject Model (DOM) using JavaScript. You can use a counter object to \\nupdate the text content or attributes of a HTML element in response \\nto user events, such as button clicks or key presses.\\n\\n```\\n\\n\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```Javascript []\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let count = init || 0; // initialize count to 0 or given value\\n\\n  const increment = function() {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = function() {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = function() {\\n    count = init || 0;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\n``` typescript []\\ninterface Counter {\\n  increment(): number;\\n  decrement(): number;\\n  reset(): number;\\n}\\n\\nconst createCounter = (init: number = 0): Counter => {\\n  let count: number = init;\\n\\n  const increment = (): number => {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = (): number => {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = (): number => {\\n    count = init;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\nconst counter: Counter = createCounter(5);\\n\\nconsole.log(counter.increment()); // 6\\nconsole.log(counter.reset()); // 5\\nconsole.log(counter.decrement()); // 4\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```\\nclass Counter {\\n  constructor(init = 0) {\\n    this.count = init;\\n  }\\n\\n  increment() {\\n    return ++this.count;\\n  }\\n\\n  decrement() {\\n    return --this.count;\\n  }\\n\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n}\\n```\n```\\nconst counter = {\\n  count: 0,\\n  increment() {\\n    return ++this.count;\\n  },\\n  decrement() {\\n    return --this.count;\\n  },\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n};\\n\\n```\n```\\nfunction createCounter(init = 0) {\\n  let count = init;\\n\\n  return {\\n    increment() {\\n      return ++count;\\n    },\\n    decrement() {\\n      return --count;\\n    },\\n    reset() {\\n      count = 0;\\n      return count;\\n    }\\n  };\\n}\\n```\n```\\n1. Closures: A closure is a function that has access to variables in\\n its outer lexical environment. The original implementation of the \\n`createCounter` function uses a closure to create a private `count`\\n variable that is shared by the `increment`, `decrement`, and `reset`\\n functions. Understanding closures is essential for writing clean \\nand efficient JavaScript code.\\n\\n2. Object-oriented programming (OOP): OOP is a programming paradigm \\nthat uses objects and classes to encapsulate data and behavior. The \\nES6 class-based implementation of the counter object demonstrates\\nhow to define a class with properties and methods, while the object \\nliteral and factory function approaches use object-based programming \\nto define a set of related methods.\\n\\n3. JavaScript syntax: Understanding basic JavaScript syntax is \\nessential for writing clean and readable code. The original \\nimplementation and alternative approaches use different syntax \\nelements, such as arrow functions, default parameter values, and \\nobject destructuring, that are common in modern JavaScript code.\\n\\n4. DOM manipulation: If you\\'re interested in front-end web \\ndevelopment, you\\'ll need to learn how to manipulate the Document \\nObject Model (DOM) using JavaScript. You can use a counter object to \\nupdate the text content or attributes of a HTML element in response \\nto user events, such as button clicks or key presses.\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494506,
                "title": "solutions-in-javascript-and-typescript",
                "content": "# Approach\\n- You can use Prefix Increment/Decrement syntax to replace += 1 and -= 1. This syntax allows you to increment or decrement a number and return it at the same time.\\n- To combine the initialization of currentCount and its return, you can assign its initial value in the same line that you return it. In JavaScript, when you assign a value to a variable, it returns that value automatically. \\n- To make the code more concise, you can switch from function syntax to arrow syntax when defining the functions.\\n# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/RbpZLA8F/shared\" frameBorder=\"0\" width=\"700\" height=\"300\"></iframe>",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# Approach\\n- You can use Prefix Increment/Decrement syntax to replace += 1 and -= 1. This syntax allows you to increment or decrement a number and return it at the same time.\\n- To combine the initialization of currentCount and its return, you can assign its initial value in the same line that you return it. In JavaScript, when you assign a value to a variable, it returns that value automatically. \\n- To make the code more concise, you can switch from function syntax to arrow syntax when defining the functions.\\n# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/RbpZLA8F/shared\" frameBorder=\"0\" width=\"700\" height=\"300\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3485377,
                "title": "closure-3-lines",
                "content": "# Approach\\n```\\nfunction createCounter(init) {\\n    let value = init;\\n\\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init,\\n    }\\n};\\n```\\n\\n**NOTE #1:** Using the prefix increment/decrement updates `value` befure returing it.\\n\\n**NOTE #2:** When assigmnent used as return value, assignment is performed first, then the value of the variable to the left is returned.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ on each call\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction createCounter(init) {\\n    let value = init;\\n\\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484246,
                "title": "straight-forward-o-1",
                "content": "# Intuition\\nJust do it.\\n\\n# Approach\\nJust do it.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    c = i = init\\n\\n    function increment() {\\n        return ++c\\n    }\\n\\n    function decrement() {\\n        return --c\\n    }\\n\\n    function reset() {\\n        return c = i\\n    }\\n    return {increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    c = i = init\\n\\n    function increment() {\\n        return ++c\\n    }\\n\\n    function decrement() {\\n        return --c\\n    }\\n\\n    function reset() {\\n        return c = i\\n    }\\n    return {increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494507,
                "title": "closure-counter-object-in-javascript",
                "content": "The `createCounter` function returns an object with three methods: `increment`, `decrement`, and `reset`.\\n\\nWhen `createCounter` is called with an initial value init, it creates a closure over a local variable count, which is initialized to init.\\n\\nThe increment method increases the value of count by `1`, and then returns the new value of count. The decrement method decreases the value of count by `1`, and then returns the new value of `count`. The `reset` method sets the value of count back to the initial value init, and then returns the new value of count.\\n\\nBecause each method is defined within the same closure, they all have access to the same `count` variable, and can modify it as needed.\\n\\nThis implementation allows you to create multiple independent counters, each with their own initial value and independent count variable.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n  let count = init;\\n\\n  return {\\n    increment: () => {\\n      count++;\\n      return count;\\n    },\\n\\n    decrement: () => {\\n      count--;\\n      return count;\\n    },\\n\\n    reset: () => {\\n      count = init;\\n      return count;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n  let count = init;\\n\\n  return {\\n    increment: () => {\\n      count++;\\n      return count;\\n    },\\n\\n    decrement: () => {\\n      count--;\\n      return count;\\n    },\\n\\n    reset: () => {\\n      count = init;\\n      return count;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494783,
                "title": "o-1-easy-solution-98-commented-with-examples",
                "content": "This code defines a function createCounter that takes an initial value init as a parameter and returns an object that contains three methods: **increment**, **decrement**, and **reset**.\\n\\nThe ans variable is initialized with the value of init. This variable is defined inside the **createCounter** function, so it is only accessible within the scope of the returned object.\\n\\n\\n* The  **increment**  method is an arrow function that **increments** the ans variable and returns its new value. The decrement method is also an arrow function that decrements the ans variable and returns its new value. Both these methods use the increment and decrement operators ++ and --, respectively.\\n\\n* The **reset** method is an arrow function that assigns the ans variable the value of init, effectively resetting the counter to its original value.\\n\\n* The **returned** object contains these three methods, and these methods can be used to manipulate the ans variable in different ways. For example, you can use the **increment** and **decrement** methods to increase or ***decrease*** the value of the counter, respectively, while the reset method can be used to reset the counter to its initial value.\\n\\nYou can create multiple counter objects with different initial values by calling the **createCounter** function with different init values.\\n\\n***Here is an example of it*** \\n```\\n// create a counter object starting from 5\\nconst counter = createCounter(5);\\n\\n// increment the counter by 1\\nconsole.log(counter.increment()); // output: 6\\n\\n// decrement the counter by 2\\nconsole.log(counter.decrement()); // output: 5\\nconsole.log(counter.decrement()); // output: 4\\n\\n// reset the counter to its initial value\\ncounter.reset();\\nconsole.log(counter.increment()); // output: 5\\n\\n```\\nIn this example, we create a counter object starting from the value 5 using the ***createCounter function***. We then use the increment method to increase the counter by 1 and print the result to the console, which outputs 6. We then use the ***decrement*** method twice to decrease the counter by 2 and print the results to the console, which outputs 5 and 4, respectively. Finally, we use the reset method to reset the counter to its initial value and then use the ***increment method*** to increase the counter by 1 and print the result to the console, which outputs 5.\\n\\n```\\n\\nvar createCounter = function(init) {\\n    var ans = init;\\n\\n    return {\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init,\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// create a counter object starting from 5\\nconst counter = createCounter(5);\\n\\n// increment the counter by 1\\nconsole.log(counter.increment()); // output: 6\\n\\n// decrement the counter by 2\\nconsole.log(counter.decrement()); // output: 5\\nconsole.log(counter.decrement()); // output: 4\\n\\n// reset the counter to its initial value\\ncounter.reset();\\nconsole.log(counter.increment()); // output: 5\\n\\n```\n```\\n\\nvar createCounter = function(init) {\\n    var ans = init;\\n\\n    return {\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init,\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493336,
                "title": "my-createcounter",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const counter = {\\n    c: init,\\n    t: init,\\n    increment() {\\n      return ++this.c;\\n    },\\n    reset() {\\n      this.c = this.t;\\n      return this.c;\\n    },\\n    decrement() {\\n      return --this.c;\\n    }\\n  };\\n  \\n  return counter;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const counter = {\\n    c: init,\\n    t: init,\\n    increment() {\\n      return ++this.c;\\n    },\\n    reset() {\\n      this.c = this.t;\\n      return this.c;\\n    },\\n    decrement() {\\n      return --this.c;\\n    }\\n  };\\n  \\n  return counter;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495296,
                "title": "easy-to-understand-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return{\\n        increment:function(){\\n            c++;\\n          return c;\\n        },\\n       decrement:function(){\\n           c--;\\n           return c;\\n       },\\n       reset:function(){\\n           c=init;\\n           return c;\\n       }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return{\\n        increment:function(){\\n            c++;\\n          return c;\\n        },\\n       decrement:function(){\\n           c--;\\n           return c;\\n       },\\n       reset:function(){\\n           c=init;\\n           return c;\\n       }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495271,
                "title": "javascript-day-3-of-30-days-challange",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    let resetVal = init;\\n\\n    let obj = {\\n        increment : () => ++counter,\\n        decrement : () => --counter,\\n        reset : () => counter = resetVal\\n    }\\n\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    let resetVal = init;\\n\\n    let obj = {\\n        increment : () => ++counter,\\n        decrement : () => --counter,\\n        reset : () => counter = resetVal\\n    }\\n\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596195,
                "title": "easiest-full-explanation",
                "content": "# Intuition\\nYou\\'re probbably thinking , damn that\\'s an easy problem. I just have to return 3 objects in a function. Well , not really .\\n\\nThe following leetcode problem is a practice on whats called\\n# Factory Method ( FM ) Design Pattern .\\nKeep reading I\\'ll explain in Depth and provide a solution\\n\\n# Approach\\nLet\\'s Solve this Problem using FM.\\n\\n# **Definition : What\\'s with the Factory Method ?**\\n1. It\\'s a creational Design Pattern : It allows us to create and return different objects\\n2. It provides a way to encapsulate the object creation process within a function.\\n# Use Cases : Why do we need it and what\\'s its advantages ?\\n\\n- To Organize our Code\\n- To provide Flexibility\\n- Saves time and the effort of duplication\\n\\n# STILL CONFUSED ? LET\\'S BREAK IT DOWN EVEN MORE AND LOOK AT OUR EXAMPLE IN THIS LEETCODE PROBLEM\\n\\nIn our code snippet , the \\'createCounter\\' function is a factory method . This factory method creates a counter object , let\\'s explore what\\'s happening :\\n\\n- When we call createCounter and pass an initial value, it returns an object.\\n- The returned object allows us to perform operations on the counter, such as incrementing, decrementing, and resetting its value.\\n- This way, we can create multiple independent counters by invoking the createCounter function with different initial values.\\n# NOW IT\\'S TIME FOR A RECAP\\n\\nThe factory method is like a special function that creates and gives you objects. Instead of directly creating objects yourself, you use this function, which knows how to create the objects you need.\\nThe factory function knows how to create the objects and returns them to you.\\n\\n# To create and use the Factory Method Design pattern we :\\n- Define a factory function\\n- Create a new instance of the desired object inside our function\\n- Return the created object\\n\\n\\nNow that\\'s it , hope you liked my explanation . Remmember to always look deep behind the problem itself and understand the entire Concept Hope I helped , Kindly upvote If I did : )\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497509,
                "title": "javascript-object-simplest-solution",
                "content": "```\\nvar createCounter = function(init) {\\n  var count = init;\\n  return {\\n    increment: () => {return ++count}, \\n    decrement: () => {return --count}, \\n    reset: () => {return count = init}\\n  };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n  var count = init;\\n  return {\\n    increment: () => {return ++count}, \\n    decrement: () => {return --count}, \\n    reset: () => {return count = init}\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494911,
                "title": "sort-easy-and-conscise-solution-using-closure-property-of-javascript",
                "content": "# Code\\n```\\nvar createCounter = function(init) {\\n    let curr = init;\\n    return { increment:()=>++curr, reset:()=>curr=init, decrement:()=>--curr};\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    let curr = init;\\n    return { increment:()=>++curr, reset:()=>curr=init, decrement:()=>--curr};\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494625,
                "title": "easily-explained-in-3-step-javascript",
                "content": "# Intuition\\nIncrese and Decrese the value by `+1` and `-1`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) In increment function use pre-increment function to increment the value at that step.\\n2) In decrement function use pre-decrement function to decrement the value ar that step.\\n3) Reset function is very important -> You should save your `init` value in a `variable`. When calling reset function make sure you first reset your `init` and then return.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` JavaSript []\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JavaSript []\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494525,
                "title": "direct-solution-beats-96",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return{\\n        increment :()=>++count,\\n        decrement :()=> --count,\\n        reset : ()=>count = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return{\\n        increment :()=>++count,\\n        decrement :()=> --count,\\n        reset : ()=>count = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497875,
                "title": "day-3-30-days-js-challenge-best-editorial-everything-explained-easy-to-understand",
                "content": "# Intuition\\nThe intuition behind this code is to create a counter object that allows you to perform three actions: $$increment$$ the counter by $$1$$, $$decrement$$ the counter by $$1$$, and $$reset$$ the counter to its initial value.\\n\\n# Approach\\nThe approach used in the code is to create a closure. The variable $$ans$$ is declared within the $$createCounter()$$ function and is assigned the initial value $$init$$. The returned object contains three functions that have access to this $$ans$$ variable through closure.\\n\\nHere\\'s an explanation of each function:\\n\\n1.$$increment()$$: This function increments the $$ans$$ variable by $$1$$ using the pre-increment operator $$(++)$$. It returns the incremented value of $$ans$$.\\n2.$$decrement()$$: This function decrements the $$ans$$ variable by $$1$$ using the pre-decrement operator $$(--)$$. It returns the decremented value of $$ans$$.\\n3.$$reset()$$: This function assigns the $$init$$ value to the $$ans$$ variable, effectively resetting it to its initial value. It does not return any value.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the $$increment()$$ and $$decrement()$$ functions is $$O(1)$$ because they only involve a single arithmetic operation. The $$reset()$$ function also has a time complexity of $$O(1)$$ as it simply assigns a value to a variable.\\n\\n- Space complexity:\\nThe space complexity of the code is $$O(1)$$ because it does not use any additional data structures that grow with the input. The $$ans$$ variable and the returned object are the only variables created, and they occupy constant space regardless of the input value.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    //creating ans variable\\n    var ans = init;\\n    //returning object to a function\\n    return{\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n$$Please \\\\space Upvote \\\\space the \\\\space Solution \\\\space if \\\\space you \\\\space liked \\\\space it...$$\\n![abc.png](https://assets.leetcode.com/users/images/8a68ea47-48e3-4005-965a-37385eb8b506_1683488530.294573.png)\\n\\n$$Thank \\\\space you \\\\space so \\\\space much...$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    //creating ans variable\\n    var ans = init;\\n    //returning object to a function\\n    return{\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497177,
                "title": "js-simplest-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param { number } init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let state = init\\n    return {\\n        increment: () => ++state,\\n        decrement: () => --state,\\n        reset: () => state = init,\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param { number } init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let state = init\\n    return {\\n        increment: () => ++state,\\n        decrement: () => --state,\\n        reset: () => state = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495324,
                "title": "beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let count = init;\\n\\n  return {\\n    increment() {\\n      count += 1;\\n      return count;\\n    },\\n    decrement() {\\n      count -= 1;\\n      return count;\\n    },\\n    reset() {\\n      count = init;\\n      return count;\\n    }\\n  };  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let count = init;\\n\\n  return {\\n    increment() {\\n      count += 1;\\n      return count;\\n    },\\n    decrement() {\\n      count -= 1;\\n      return count;\\n    },\\n    reset() {\\n      count = init;\\n      return count;\\n    }\\n  };  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494774,
                "title": "java-script-solution-for-counter-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe createCounter function initializes and returns a new Counter object with an initial value passed as a parameter.\\n\\nThe Counter class has the following methods:\\n\\nincrement(): Increases the current count by 1 and returns the updated count.\\ndecrement(): Decreases the current count by 1 and returns the updated count.\\nreset(): Resets the current count to the initial value and returns the new count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The createCounter function takes an initial value as a parameter and returns a new instance of the Counter class, initializing it with the initial value.\\n- The Counter class maintains two properties: init, which stores the initial value passed to the constructor, and currentCount, which stores the current count.\\n- The increment method increases the currentCount by 1 and returns the updated count.\\n- The decrement method decreases the currentCount by 1 and returns the updated count.\\n- The reset method resets the currentCount to the init value and returns the new count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of each method (increment, decrement, reset) is O(1) since the operations involve simple arithmetic and assignment, which take constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because the counter object stores a constant number of variables (init and currentCount), regardless of the number of operations performed.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.currentCount = init;\\n  }\\n\\n  increment() {\\n    this.currentCount += 1;\\n    return this.currentCount;\\n  }\\n\\n  decrement() {\\n    this.currentCount -= 1;\\n    return this.currentCount;\\n  }\\n\\n  reset() {\\n    this.currentCount = this.init;\\n    return this.currentCount;\\n  }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.currentCount = init;\\n  }\\n\\n  increment() {\\n    this.currentCount += 1;\\n    return this.currentCount;\\n  }\\n\\n  decrement() {\\n    this.currentCount -= 1;\\n    return this.currentCount;\\n  }\\n\\n  reset() {\\n    this.currentCount = this.init;\\n    return this.currentCount;\\n  }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494538,
                "title": "simple-solution-create-functions-and-return-object-of-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n// let val= init;\\nvar createCounter = function(init) {\\n    i=init;\\n    function increment(){\\n        i++;\\n        return i;\\n    }\\n    function decrement(){\\n        i--;\\n        return i;\\n    }\\n    function reset(){\\n        i=init;\\n        return i;\\n    }\\n    let obj={\\n        increment,\\n        decrement,\\n        reset\\n    };\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n// let val= init;\\nvar createCounter = function(init) {\\n    i=init;\\n    function increment(){\\n        i++;\\n        return i;\\n    }\\n    function decrement(){\\n        i--;\\n        return i;\\n    }\\n    function reset(){\\n        i=init;\\n        return i;\\n    }\\n    let obj={\\n        increment,\\n        decrement,\\n        reset\\n    };\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3886292,
                "title": "short-and-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835122,
                "title": "easy-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init;\\n    \\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init;\\n    \\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823102,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3640241,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const value=init;\\n    return {\\n        increment: ()=> {\\n            return ++init\\n        },\\n        decrement: ()=>{\\n           return --init\\n        },\\n        reset: ()=> {\\n            init=value\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const value=init;\\n    return {\\n        increment: ()=> {\\n            return ++init\\n        },\\n        decrement: ()=>{\\n           return --init\\n        },\\n        reset: ()=> {\\n            init=value\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567010,
                "title": "day-3-of-js-challenge-beats-92-04-easy-solution-using-arrow-functions",
                "content": "# Intuition\\nWe use arrow function inorder to print the output according to the different functions given.\\nIncrement - we add 1 to the value\\nDecrement - we subtract 1 from the value\\nreset - we print the original value\\n\\n# Approach\\nwe have declared 3 arrow functions that perform the necessary action and return the value.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    return{\\n    increment: () => { current+=1; return current;},\\n    decrement: () => { current-=1; return current;},\\n    reset: () => { current=init; return current},\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\nKindly upvote if you found it helpful! Happy learning!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    return{\\n    increment: () => { current+=1; return current;},\\n    decrement: () => { current-=1; return current;},\\n    reset: () => { current=init; return current},\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504421,
                "title": "typescript-very-fast-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Beats 90%. -->\\n\\n# Approach\\n<!-- Beats 90%. -->\\n\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let _init = init;\\n    return {\\n        increment: () => ++_init,\\n        decrement: () => --_init,\\n        reset: () => _init = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let _init = init;\\n    return {\\n        increment: () => ++_init,\\n        decrement: () => --_init,\\n        reset: () => _init = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501381,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n let current = init;\\n\\n  function increment() {\\n    return ++current;\\n  }\\n\\n  function decrement() {\\n    return --current;\\n  }\\n\\n  function reset() {\\n    current = init;\\n    return current;\\n  }\\n\\n  return { increment, decrement, reset };    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n let current = init;\\n\\n  function increment() {\\n    return ++current;\\n  }\\n\\n  function decrement() {\\n    return --current;\\n  }\\n\\n  function reset() {\\n    current = init;\\n    return current;\\n  }\\n\\n  return { increment, decrement, reset };    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496974,
                "title": "easy-javascript-solution",
                "content": "# Approach\\nThe createCounter function returns an object with three functions: increment, decrement, and reset. These functions have access to a count variable that is initialized to the value of init. Each function modifies the count variable and returns the new value.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment: function(){\\n            count++;\\n            return count;\\n        },\\n        decrement: function(){\\n            count--;\\n            return count;\\n        },\\n        reset: function(){\\n            count = init;\\n            return count;\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment: function(){\\n            count++;\\n            return count;\\n        },\\n        decrement: function(){\\n            count--;\\n            return count;\\n        },\\n        reset: function(){\\n            count = init;\\n            return count;\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496313,
                "title": "javascript-beats-81-4-if-you-believe-leetcode",
                "content": "# Intuition\\n\\nIt is based on LeetCode hint. LeetCode Hint tells you directly that you need to return the JavaScript object. Based on this knowledge I have decided to try to return JSON that will have an arrow functions depending on the keywords. \\n\\nAnd that was the solution! :)\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n\\n\\n    return {\\n        increment: () => {\\n            num++;\\n            return num;\\n        },\\n        reset: () => {\\n            num = init;\\n            return num;\\n        },\\n        decrement: () => {\\n            num--;\\n            return num;\\n        }\\n    }    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n\\n\\n    return {\\n        increment: () => {\\n            num++;\\n            return num;\\n        },\\n        reset: () => {\\n            num = init;\\n            return num;\\n        },\\n        decrement: () => {\\n            num--;\\n            return num;\\n        }\\n    }    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496058,
                "title": "closure-3-lines-in-javascript-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        \\n        let count = init\\n        return{increment: () => ++count,\\n        decrement: () => --count,\\n        reset: () => count = init,\\n        }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        \\n        let count = init\\n        return{increment: () => ++count,\\n        decrement: () => --count,\\n        reset: () => count = init,\\n        }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495786,
                "title": "easy-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var n=init\\n    return{\\n        increment:()=>++n,\\n        decrement:()=>--n,\\n        reset:()=>n=init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var n=init\\n    return{\\n        increment:()=>++n,\\n        decrement:()=>--n,\\n        reset:()=>n=init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495385,
                "title": "js-o-o",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init\\n    return {\\n        increment: function() {\\n            currentCount += 1;\\n            return currentCount;\\n        },\\n        decrement: function() {\\n            currentCount -= 1;\\n            return currentCount;\\n        },\\n        reset: function() {\\n            currentCount = init;\\n            return currentCount;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init\\n    return {\\n        increment: function() {\\n            currentCount += 1;\\n            return currentCount;\\n        },\\n        decrement: function() {\\n            currentCount -= 1;\\n            return currentCount;\\n        },\\n        reset: function() {\\n            currentCount = init;\\n            return currentCount;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495368,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIncrement, increases the value and return it,\\nDecrement, decreases the value and return it,\\nReset, return the actual value\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495310,
                "title": "easy-simple-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter = init;\\n    return {\\n        increment : ()=>{\\n            counter++;\\n            return counter;\\n        },\\n        decrement : ()=>{\\n            counter--;\\n            return counter;\\n        },\\n        reset : ()=> {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter = init;\\n    return {\\n        increment : ()=>{\\n            counter++;\\n            return counter;\\n        },\\n        decrement : ()=>{\\n            counter--;\\n            return counter;\\n        },\\n        reset : ()=> {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494785,
                "title": "day-3-happy-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n//  * @param {integer} init\\n//  * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    function increment(){\\n        count++;\\n        return count;\\n    }\\n    function decrement(){\\n        count--;\\n        return count;\\n    }\\n    function reset(){\\n        count = init;\\n        return count;\\n    }\\n    return { increment, decrement, reset };\\n};\\n    \\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n//  * @param {integer} init\\n//  * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    function increment(){\\n        count++;\\n        return count;\\n    }\\n    function decrement(){\\n        count--;\\n        return count;\\n    }\\n    function reset(){\\n        count = init;\\n        return count;\\n    }\\n    return { increment, decrement, reset };\\n};\\n    \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494767,
                "title": "how-to-approach-this-problem-three-line-typescript-code-o-1-closure",
                "content": "# Intuition\\nFor solving thing problem we are going to use closure concept. As we go through the problem, two thing is sure ->\\n\\nWe need to store starting init value in variable because when we implement reset function we need them that value.\\n\\nAnd also store current value, which will change when we call increment or decrement or reset function.\\n\\n# Approach\\n1. We are going to create two variable which will store init value and current value.\\n2. After that we will create three function increment, decrement, rest.\\n3. return these function.\\n\\n# Complexity\\n- Time complexity:\\nWe are not performing any special type of operation which depend on user input. Then we can say Time Complexity is $$O(1)$$\\n\\n- Space complexity:\\nWe are just creating two variable and it\\'s not depend user how many time call this function. Then we can Space Complexity is $$O(1)$$\\n\\n# Code\\nJavascript\\n```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    let value = init;\\n    const increment = () => ++value;\\n    const decrement = () => --value;\\n    const reset = () => (value = resetValue);\\n    return {increment,decrement,reset};\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\nTypescript\\n```typescript\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const resetValue = init;\\n    let currentValue = init;\\n    return {\\n        increment: (): number => ++currentValue,\\n        decrement: (): number => --currentValue,\\n        reset: (): number => currentValue = resetValue,\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    let value = init;\\n    const increment = () => ++value;\\n    const decrement = () => --value;\\n    const reset = () => (value = resetValue);\\n    return {increment,decrement,reset};\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\n```typescript\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const resetValue = init;\\n    let currentValue = init;\\n    return {\\n        increment: (): number => ++currentValue,\\n        decrement: (): number => --currentValue,\\n        reset: (): number => currentValue = resetValue,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494668,
                "title": "simple-easy-solution-with-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou can take a temp variable, assign it to the value of init. Then write 3 function as increment() which will increment the value by 1, reset() the will reset the value back to original, and decrement() which will decrement the value by 1. And then finaly return the temp variable; \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n      let temp=init;\\n    return {\\n        increment(){\\n            return ++temp;\\n        },\\n        decrement(){\\n            return --temp;\\n        },\\n        reset(){\\n            temp=init;\\n            return temp;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n      let temp=init;\\n    return {\\n        increment(){\\n            return ++temp;\\n        },\\n        decrement(){\\n            return --temp;\\n        },\\n        reset(){\\n            temp=init;\\n            return temp;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494562,
                "title": "easy-js-solution-with-explain-closure",
                "content": "# Intuition\\nThe goal of the problem is to create a constructor function that returns an object with methods for incrementing, decrementing, and resetting a counter value. Closures allow maintaining state between function calls.\\n\\n# Approach\\n1. Create a createCounter function with an init argument, which will initialize the starting value of the counter.\\n2. Inside the createCounter function, create a counter variable and set its value equal to init.\\n3. Return an object with increment, decrement, and reset methods, which modify the counter value accordingly and return it.\\n4. Use closure to retain the counter value between function calls.\\n\\n# Complexity\\n- Time and space complexity:\\n- O(1) - bcs it\\'s just simple math\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function () {\\n            return ++counter;\\n        },\\n        decrement: function () {\\n            return --counter;\\n        },\\n        reset: function () {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function () {\\n            return ++counter;\\n        },\\n        decrement: function () {\\n            return --counter;\\n        },\\n        reset: function () {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494501,
                "title": "closure-easy-to-understand-implementation",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {increment, decrement, reset};\\n\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {increment, decrement, reset};\\n\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3488461,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return {\\n        increment(){\\n            return ++count;\\n        },\\n        decrement(){\\n            return --count;\\n        },\\n        reset(){\\n            count=init;\\n            return count;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return {\\n        increment(){\\n            return ++count;\\n        },\\n        decrement(){\\n            return --count;\\n        },\\n        reset(){\\n            count=init;\\n            return count;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486119,
                "title": "class-based-implementation",
                "content": "\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n class Counter {\\n     constructor(init){\\n         this.initVal = init;\\n         this.val = this.initVal;\\n     }\\n\\n     increment(){\\n         return this.val+=1;\\n     }\\n\\n     decrement(){\\n         return this.val-=1;\\n     }\\n\\n     reset(){\\n         return this.val = this.initVal;\\n     }\\n }\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n class Counter {\\n     constructor(init){\\n         this.initVal = init;\\n         this.val = this.initVal;\\n     }\\n\\n     increment(){\\n         return this.val+=1;\\n     }\\n\\n     decrement(){\\n         return this.val-=1;\\n     }\\n\\n     reset(){\\n         return this.val = this.initVal;\\n     }\\n }\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484840,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const original = init\\n  const increment = () => ++init\\n  const decrement = () => --init\\n  const reset = () => init = original\\n\\n  return { increment, decrement, reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const original = init\\n  const increment = () => ++init\\n  const decrement = () => --init\\n  const reset = () => init = original\\n\\n  return { increment, decrement, reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098752,
                "title": "clean-and-easy-approach-step-wise-explanation",
                "content": "# Intuition\\nStep 1 : First read the question.\\nStep 2 : It says return an object so we use \"return {}\", curly braces are symbol of object literals.\\nStep 3 : Now an object consists of key-value pairs so, our \\'key\\' will be the \\'function name\\' and value will be the function implementation.\\nStep 4 : For the code of function implementation just follow what question demands like increment, decrement or reset.\\n\\n# Code\\n```\\nvar createCounter = function(init) {\\n    var temp = init;\\n    return {\\n        increment : function(){\\n            return ++temp;\\n        },\\n        decrement : function(){\\n            return --temp;\\n        },\\n        reset : function(){\\n            temp = init;\\n            return temp;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    var temp = init;\\n    return {\\n        increment : function(){\\n            return ++temp;\\n        },\\n        decrement : function(){\\n            return --temp;\\n        },\\n        reset : function(){\\n            temp = init;\\n            return temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097956,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var x=init;\\n    var calls={\\n         reset:function(){\\n             init=x;\\n            return init;\\n        },\\n        increment:function(){\\n    init++;\\n          return init;\\n        },\\n        decrement:function(){\\n           init--;\\n            return init;\\n        },\\n    }\\n    return calls;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var x=init;\\n    var calls={\\n         reset:function(){\\n             init=x;\\n            return init;\\n        },\\n        increment:function(){\\n    init++;\\n          return init;\\n        },\\n        decrement:function(){\\n           init--;\\n            return init;\\n        },\\n    }\\n    return calls;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096443,
                "title": "counter-ii-javascript-solution-by-bharadwaj",
                "content": "# Approach\\nFunctional\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095973,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const initialValue = init;\\n    let currentValue = init;\\n    const increment = ()  => {\\n      currentValue += 1;\\n      return currentValue;\\n    }\\n    const decrement = ()  => {\\n      currentValue -= 1;\\n      return currentValue;\\n    }\\n    const reset = ()  => {\\n      currentValue = initialValue;\\n      return currentValue;\\n    }\\n\\n    return {increment,decrement,reset};\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const initialValue = init;\\n    let currentValue = init;\\n    const increment = ()  => {\\n      currentValue += 1;\\n      return currentValue;\\n    }\\n    const decrement = ()  => {\\n      currentValue -= 1;\\n      return currentValue;\\n    }\\n    const reset = ()  => {\\n      currentValue = initialValue;\\n      return currentValue;\\n    }\\n\\n    return {increment,decrement,reset};\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094618,
                "title": "operation-counter-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const currentNum = init\\n   return {\\n    increment: ()=>{\\n        return init+=1\\n    },\\n    decrement: ()=>{\\n        return init-=1\\n    },\\n    reset: ()=>{\\n        return init = currentNum\\n    }\\n   }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const currentNum = init\\n   return {\\n    increment: ()=>{\\n        return init+=1\\n    },\\n    decrement: ()=>{\\n        return init-=1\\n    },\\n    reset: ()=>{\\n        return init = currentNum\\n    }\\n   }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094075,
                "title": "simple-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- understanding sub functions much better\\n- had to use temp: function() {} instead of temp: () => {}\\n- maybe it has something to do with arrow functions not taking in this.x?\\n\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = (init) => {\\n    return {\\n        x : init,\\n        increment: function() {\\n            this.x++;\\n            return this.x;\\n        },\\n        decrement: function()  {\\n            this.x--;\\n            return this.x;\\n        },\\n        reset: function() {\\n            this.x = init;\\n            return init;\\n        }\\n\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = (init) => {\\n    return {\\n        x : init,\\n        increment: function() {\\n            this.x++;\\n            return this.x;\\n        },\\n        decrement: function()  {\\n            this.x--;\\n            return this.x;\\n        },\\n        reset: function() {\\n            this.x = init;\\n            return init;\\n        }\\n\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091297,
                "title": "counter-ii",
                "content": "# Intuition\\nhere is a JavaScript function to create a counter object with three functions: increment(), decrement(), and reset():\\n# Approach\\nTo use the createCounter() function, simply pass in the initial value of the counter as an argument. The function will return a counter object with three functions: increment(), decrement(), and reset().\\n\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n  class Counter {\\n    constructor(init) {\\n      this.value = init;\\n    }\\n\\n    increment() {\\n      this.value += 1;\\n      return this.value;\\n    }\\n\\n    decrement() {\\n      this.value -= 1;\\n      return this.value;\\n    }\\n\\n    reset() {\\n      this.value = init;\\n      return this.value;\\n    }\\n  }\\n\\n  return new Counter(init);\\n}\\n\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n\\nFor example, the following code creates a counter object with an initial value of 5:\\n\\n```\\n const counter = createCounter(5)\\n```\\nYou can then use the increment(), decrement(), and reset() functions to modify the value of the counter:\\n\\n```\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n  class Counter {\\n    constructor(init) {\\n      this.value = init;\\n    }\\n\\n    increment() {\\n      this.value += 1;\\n      return this.value;\\n    }\\n\\n    decrement() {\\n      this.value -= 1;\\n      return this.value;\\n    }\\n\\n    reset() {\\n      this.value = init;\\n      return this.value;\\n    }\\n  }\\n\\n  return new Counter(init);\\n}\\n\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\n```\\n const counter = createCounter(5)\\n```\n```\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090026,
                "title": "short-and-easy-approach",
                "content": "\\n```\\nvar createCounter = function(init) {\\n    var initialVal = init;\\n    var currVal = init;\\n    return {\\n        increment : function(){\\n            return ++currVal;\\n        },\\n        decrement : function(){\\n            return --currVal;\\n        },\\n        reset : function(){\\n            currVal = initialVal;\\n            return currVal;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    var initialVal = init;\\n    var currVal = init;\\n    return {\\n        increment : function(){\\n            return ++currVal;\\n        },\\n        decrement : function(){\\n            return --currVal;\\n        },\\n        reset : function(){\\n            currVal = initialVal;\\n            return currVal;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088922,
                "title": "counter2-with-constraints",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088908,
                "title": "counter-with-constraints",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let count= init\\n        if (-1000 <= init <= 1000){\\n             return {\\n                 increment:()=> ++count,\\n                 reset:()=> count=init,\\n                 decrement:()=>--count\\n             }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let count= init\\n        if (-1000 <= init <= 1000){\\n             return {\\n                 increment:()=> ++count,\\n                 reset:()=> count=init,\\n                 decrement:()=>--count\\n             }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088021,
                "title": "easy-and-the-shortest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function (init) {\\n  // Creating variable\\n  let currentCount = init;\\n  // return an object\\n  return {\\n    // increment\\n    increment: () => (currentCount += 1),\\n    // decrement\\n    decrement: () => (currentCount -= 1),\\n    // reset\\n    reset: () => (currentCount = init),\\n  };\\n};\\n\\nconst counter = createCounter(5);\\nconsole.log(\\n  counter.increment(), // 6\\n  counter.reset(), // 5\\n  counter.decrement()\\n); // 4;\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function (init) {\\n  // Creating variable\\n  let currentCount = init;\\n  // return an object\\n  return {\\n    // increment\\n    increment: () => (currentCount += 1),\\n    // decrement\\n    decrement: () => (currentCount -= 1),\\n    // reset\\n    reset: () => (currentCount = init),\\n  };\\n};\\n\\nconst counter = createCounter(5);\\nconsole.log(\\n  counter.increment(), // 6\\n  counter.reset(), // 5\\n  counter.decrement()\\n); // 4;\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087506,
                "title": "neercode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084932,
                "title": "my-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let val = init;\\n    return {\\n      increment: () => ++val,\\n       decrement: () => --val,\\n       reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let val = init;\\n    return {\\n      increment: () => ++val,\\n       decrement: () => --val,\\n       reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083797,
                "title": "counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment(){\\n        return ++count;\\n    }\\n\\n    function decrement(){\\n        return --count;\\n    }\\n\\n    function reset() {\\n        count = init;\\n        return count;\\n    }\\n\\n    return{\\n        increment : increment,\\n        decrement : decrement,\\n        reset : reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment(){\\n        return ++count;\\n    }\\n\\n    function decrement(){\\n        return --count;\\n    }\\n\\n    function reset() {\\n        count = init;\\n        return count;\\n    }\\n\\n    return{\\n        increment : increment,\\n        decrement : decrement,\\n        reset : reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077733,
                "title": "counter2-simple-solution",
                "content": "# Intuition\\nThe goal of this problem is to create a counter object that has three functions: increment(), decrement(), and reset(). These functions should manipulate and return the current value of the counter based on an initial value provided when creating the counter object.\\n\\n# Approach\\nThe approach involves creating a counter object using a JavaScript function. This function takes an initial value init as a parameter and returns an object with three methods:\\n\\n-increment(): This method increases the current value of the counter by 1 and then returns the updated value.\\n\\n-decrement(): This method decreases the current value of the counter by 1 and then returns the updated value.\\n\\n-reset(): This method resets the current value of the counter to its initial value provided during object creation and returns the initial value.\\n\\nTo achieve this, we store the initial value in a separate variable (initial) inside the closure of the returned object, and the other methods (increment, decrement, and reset) manipulate and access this init value.\\n\\n# Complexity\\nThe time complexity of the increment() and decrement() methods is O(1) since they only involve simple arithmetic operations.\\n\\nThe reset() method is also O(1) because it involves a single assignment operation.\\n\\n# Space complexity:\\nThe space complexity is O(1) as we\\'re only storing a constant number of variables (init and initial) regardless of the input size.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var initial = init;\\n  return {\\n    increment: function() {\\n      init++;\\n      return init;\\n    },\\n\\n    decrement: function() {\\n      init--;\\n      return init;\\n    },\\n\\n    reset: function() {\\n      init = initial\\n      return init;\\n    }\\n  };\\n};\\n \\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var initial = init;\\n  return {\\n    increment: function() {\\n      init++;\\n      return init;\\n    },\\n\\n    decrement: function() {\\n      init--;\\n      return init;\\n    },\\n\\n    reset: function() {\\n      init = initial\\n      return init;\\n    }\\n  };\\n};\\n \\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077426,
                "title": "i-love-this-tests",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init;\\n    \\n    function increment(){\\n         count++;\\n         return count;\\n    }\\n\\n     function decrement(){\\n          count--;\\n         return  count;\\n    }\\n\\n    function reset(){\\n         count= init;\\n     return count\\n    }\\n\\nreturn {\\n    increment,\\n    decrement,\\n    reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init;\\n    \\n    function increment(){\\n         count++;\\n         return count;\\n    }\\n\\n     function decrement(){\\n          count--;\\n         return  count;\\n    }\\n\\n    function reset(){\\n         count= init;\\n     return count\\n    }\\n\\nreturn {\\n    increment,\\n    decrement,\\n    reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074243,
                "title": "it-is-solve-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072862,
                "title": "counter-problem-in-java-script-use-method-channing",
                "content": "# Intuition\\nIn this proble we have to make the three method \\n\\n# Approach\\nhere we return and object of method which have properties of function \\n\\n# Complexity\\n- Time complexity:  O(1)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return {\\n        no: init,\\n        increment : function(){\\n            this.no +=1;\\n            return this.no\\n        },\\n        decrement : function(){\\n            this.no -=1;\\n            return this.no\\n        },\\nreset : function(){\\n    this.no = init\\n     return this.no\\n        }\\n    }\\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return {\\n        no: init,\\n        increment : function(){\\n            this.no +=1;\\n            return this.no\\n        },\\n        decrement : function(){\\n            this.no -=1;\\n            return this.no\\n        },\\nreset : function(){\\n    this.no = init\\n     return this.no\\n        }\\n    }\\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072359,
                "title": "2665-counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar createCounter = function(init) {\\n    const resetVal = init;\\n    return {\\n        increment : () => ++init,\\n        decrement: () => --init,\\n        reset: () => init = resetVal,\\n    }\\n};\\nconst counter = createCounter(5)\\n console.log(counter.increment()); // 6\\n console.log(counter.reset()); // 5\\n console.log(counter.decrement()); // 4\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    const resetVal = init;\\n    return {\\n        increment : () => ++init,\\n        decrement: () => --init,\\n        reset: () => init = resetVal,\\n    }\\n};\\nconst counter = createCounter(5)\\n console.log(counter.increment()); // 6\\n console.log(counter.reset()); // 5\\n console.log(counter.decrement()); // 4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069493,
                "title": "2665-counter-ii-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var currentVal = init;\\n    const objThree = {\\n      increment: (() => {\\n        return init = init + 1\\n      }),\\n      decrement: (() => {\\n        return init = init - 1\\n      }),\\n      reset: (() => {\\n        return init = currentVal\\n      }), \\n    }\\n    \\n    return objThree;\\n};\\n\\n\\n\\nconst counter = createCounter(5)\\ncounter.increment(); // 6\\ncounter.reset(); // 5\\ncounter.decrement(); // 4\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var currentVal = init;\\n    const objThree = {\\n      increment: (() => {\\n        return init = init + 1\\n      }),\\n      decrement: (() => {\\n        return init = init - 1\\n      }),\\n      reset: (() => {\\n        return init = currentVal\\n      }), \\n    }\\n    \\n    return objThree;\\n};\\n\\n\\n\\nconst counter = createCounter(5)\\ncounter.increment(); // 6\\ncounter.reset(); // 5\\ncounter.decrement(); // 4\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069044,
                "title": "counter-ii-js-solution",
                "content": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    function increment(){\\n        num += 1\\n        return num\\n    }\\n    function reset(){\\n        num = init\\n        return num\\n    }\\n    function decrement(){\\n        num -= 1\\n        return num\\n    }\\n    return { increment, reset, decrement }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    function increment(){\\n        num += 1\\n        return num\\n    }\\n    function reset(){\\n        num = init\\n        return num\\n    }\\n    function decrement(){\\n        num -= 1\\n        return num\\n    }\\n    return { increment, reset, decrement }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 4068200,
                "title": "2-easy-ways",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   \\n    let count = init;\\n\\n    // const increment = () => ++count\\n    // const decrement = () => --count\\n    // const reset = () => {\\n    //   count = init\\n    //   return init\\n    // }\\n    // return { increment, decrement, reset}\\n\\n    \\n    //*****OR**** */\\n\\n    return {\\n      increment: () => ++count,\\n      decrement: () => --count,\\n      reset: () => count = init\\n      }\\n\\n  }\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   \\n    let count = init;\\n\\n    // const increment = () => ++count\\n    // const decrement = () => --count\\n    // const reset = () => {\\n    //   count = init\\n    //   return init\\n    // }\\n    // return { increment, decrement, reset}\\n\\n    \\n    //*****OR**** */\\n\\n    return {\\n      increment: () => ++count,\\n      decrement: () => --count,\\n      reset: () => count = init\\n      }\\n\\n  }\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067001,
                "title": "beginner-friendly-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let value = init;\\n        return {\\n        increment: () => {\\n            return ++value;\\n        },\\n        decrement: () => {\\n            return --value;\\n        },\\n        reset: () => {\\n            value = init;\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let value = init;\\n        return {\\n        increment: () => {\\n            return ++value;\\n        },\\n        decrement: () => {\\n            return --value;\\n        },\\n        reset: () => {\\n            value = init;\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062017,
                "title": "counter-ii-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init\\n    return {\\n            reset : () =>{\\n            return x = init;\\n        },\\n        increment : () =>{\\n            return ++x ;\\n        },\\n        decrement : () =>{\\n            return --x ;\\n        }, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init\\n    return {\\n            reset : () =>{\\n            return x = init;\\n        },\\n        increment : () =>{\\n            return ++x ;\\n        },\\n        decrement : () =>{\\n            return --x ;\\n        }, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060644,
                "title": "arrow-function-to-createcounter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init;\\n    return {\\n        increment: () => currentCount += 1,\\n        decrement: () => currentCount -= 1,\\n        reset: () => currentCount = init\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init;\\n    return {\\n        increment: () => currentCount += 1,\\n        decrement: () => currentCount -= 1,\\n        reset: () => currentCount = init\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060321,
                "title": "74-beats",
                "content": "# Intuition\\n74% beats\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let numbers = init;\\n    return{\\n        increment: ()=>{\\n            // numbers++;\\n            return ++numbers;\\n        },\\n        decrement: ()=>{\\n            // numbers--;\\n            return --numbers;\\n        },\\n        reset: ()=>{\\n            // numbers = init;\\n            return (numbers = init);\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let numbers = init;\\n    return{\\n        increment: ()=>{\\n            // numbers++;\\n            return ++numbers;\\n        },\\n        decrement: ()=>{\\n            // numbers--;\\n            return --numbers;\\n        },\\n        reset: ()=>{\\n            // numbers = init;\\n            return (numbers = init);\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057660,
                "title": "good-to-remember-the-difference-between-pre-post-increment-decrement",
                "content": "# Code\\n```\\nconst createCounter = (init) => {\\n  let CurrentInit = init;\\n  return {\\n    increment: () => ++CurrentInit,\\n    decrement: () => --CurrentInit,\\n    reset: () => CurrentInit = init,\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst createCounter = (init) => {\\n  let CurrentInit = init;\\n  return {\\n    increment: () => ++CurrentInit,\\n    decrement: () => --CurrentInit,\\n    reset: () => CurrentInit = init,\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055906,
                "title": "solution-with-easy-peasy-explanation",
                "content": "# Intuition\\nFor the very basic steps, you know that you need to increment init, decrement init and then have it stored in another variable so you can reset it.\\n\\n# Approach\\n2 concepts are useful here. First is closure, which means that when a function is called from inside another function, the variables of the outer functions are retained in further calls, in simpler terms, it will remember. So here, you can be carefree about accessing init variable. \\n\\nNext is Pass by Value, by default in JS, primitive data types are passed by value, so you can easily create a new variable called \"og\" (stand for original) in this case and use that to reset init. There you go, easy peasy now that you know the concepts. Happy Coding!\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nlet createCounter = function(init) {\\n    const og = init\\n    return {\\n        increment : function(){\\n            init++\\n            return init\\n        },\\n        decrement : ()=>{\\n             init--\\n             return init\\n            \\n        },\\n        reset : ()=>{\\n            init = og\\n            return init\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nlet createCounter = function(init) {\\n    const og = init\\n    return {\\n        increment : function(){\\n            init++\\n            return init\\n        },\\n        decrement : ()=>{\\n             init--\\n             return init\\n            \\n        },\\n        reset : ()=>{\\n            init = og\\n            return init\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055875,
                "title": "2665-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let curent = init;\\n    return{\\n        increment:() => ++init,\\n        decrement:() => --init,\\n        reset:() =>  init = curent\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let curent = init;\\n    return{\\n        increment:() => ++init,\\n        decrement:() => --init,\\n        reset:() =>  init = curent\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055237,
                "title": "counter-object-implementation-with-javascript",
                "content": "# Intuition\\nThe problem is to create a counter object that can be initialized with an initial value and provides methods to increment, decrement, and reset the counter.\\n\\n# Approach\\nI have implemented a closure-based approach to create the counter object. The `createCounter` function takes an initial value (`init`) and returns an object with three methods: `increment`, `decrement`, and `reset`. These methods allow manipulating the counter value as per the requirements.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity for each of the methods (`increment`, `decrement`, and `reset`) is O(1) because they involve simple arithmetic operations and assignment, which take constant time.\\n\\n\\n- Space complexity:\\nThe space complexity of the counter object created by `createCounter` is O(1). It only stores the current counter value and a few functions, which do not depend on the size of the input.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n\\n  return {\\n    increment: () => ++current,\\n    decrement: () => --current,\\n    reset: () => {\\n      current = init;\\n      return current;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n\\n  return {\\n    increment: () => ++current,\\n    decrement: () => --current,\\n    reset: () => {\\n      current = init;\\n      return current;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054209,
                "title": "easy-approch",
                "content": "# Intuition\\nThe problem is asking us to create a counter object that can increment, decrement, and reset a value. The initial value of the counter is provided as an argument when creating the counter object.\\n\\n# Approach\\nWe can approach this problem by creating a closure in JavaScript. We initialize a variable `num` with the provided initial value (`init`) and return an object with three functions: `increment`, `decrement`, and `reset`. These functions modify and return the `num` variable accordingly.\\n\\n- `increment` function: This function increments the `num` variable by 1 and returns the new value.\\n- `decrement` function: This function decrements the `num` variable by 1 and returns the new value.\\n- `reset` function: This function sets the `num` variable back to its initial value (`init`) and returns that value.\\n\\n# Complexity\\n- Time complexity: All three operations (increment, decrement, reset) have a time complexity of O(1) because they involve simple arithmetic operations on a single variable.\\n- Space complexity: The space complexity is O(1) as we only use a single variable `num` and a few function references.\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: function() {\\n            return ++num;\\n        },\\n        decrement: function() {\\n            return --num;\\n        },\\n        reset: function() {\\n            num = init;\\n            return num;\\n        }\\n    }\\n};\\n\\n/**\\n * Example usage:\\n * const counter = createCounter(5);\\n * console.log(counter.increment()); // Output: 6\\n * console.log(counter.reset());     // Output: 5\\n * console.log(counter.decrement()); // Output: 4\\n */\\n```\\n\\nYou can create a counter object with an initial value, use the `increment`, `decrement`, and `reset` functions as shown in the example usage, and observe how the counter behaves.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: function() {\\n            return ++num;\\n        },\\n        decrement: function() {\\n            return --num;\\n        },\\n        reset: function() {\\n            num = init;\\n            return num;\\n        }\\n    }\\n};\\n\\n/**\\n * Example usage:\\n * const counter = createCounter(5);\\n * console.log(counter.increment()); // Output: 6\\n * console.log(counter.reset());     // Output: 5\\n * console.log(counter.decrement()); // Output: 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047863,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init\\n    return {\\n        increment:() => {\\n            count++\\n            return count\\n        },\\n        decrement:() => {\\n            count--\\n            return count\\n        },\\n        reset:() => {\\n            count = init\\n            return count\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init\\n    return {\\n        increment:() => {\\n            count++\\n            return count\\n        },\\n        decrement:() => {\\n            count--\\n            return count\\n        },\\n        reset:() => {\\n            count = init\\n            return count\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046850,
                "title": "creating-a-counter-object-in-javascript-with-pre-increment-pre-decrement-and-reset-functions",
                "content": "# Intuition\\n<!-- Provide a brief description of your initial thoughts and strategies for solving this problem. -->\\n\\nThe goal of this problem is to create a counter object that can be incremented, decremented, and reset to its initial value. To achieve this, we can use a closure in JavaScript to encapsulate the current value of the counter.\\n\\n# Approach\\n<!-- Describe the approach you took to solve the problem. -->\\n\\nI used a closure to create a `createCounter` function that takes an initial value and returns an object with three methods:\\n1. `increment`: Increments the counter by 1 using pre-increment.\\n2. `decrement`: Decrements the counter by 1 using pre-decrement.\\n3. `reset`: Resets the counter to its initial value and returns the reset value.\\n\\nUsing pre-increment and pre-decrement ensures that the counter is updated before returning the new value, providing the desired behavior.\\n\\nAdditionally, I chose to reset the counter to its initial value first and then return the reset value in the `reset` method. This design choice simplifies the usage of the `reset` function. By resetting first, you can immediately access the reset value without the need for additional steps. This aligns with the principle of making functions as straightforward and predictable as possible.\\n\\n# Complexity\\n- Time complexity: O(1)\\n  - The time complexity of each method (increment, decrement, and reset) is O(1) because they involve simple arithmetic operations that take a constant amount of time.\\n\\n- Space complexity: O(1)\\n  - The space complexity of the `createCounter` function is O(1) because it only creates a single object with three methods and a single variable (`currentValue`) regardless of the input.\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init - The initial value of the counter.\\n * @return {Object} - An object with increment, decrement, and reset methods.\\n */\\nvar createCounter = function (init) {\\n    let currentValue = init; // Initialize the currentValue with the provided initial value.\\n    return {\\n        increment: () => ++currentValue, // Increment the currentValue and return the new value using pre-increment.\\n        decrement: () => --currentValue, // Decrement the currentValue and return the new value using pre-decrement.\\n        reset: () => {\\n            currentValue = init; // Reset the currentValue to the initial value first.\\n            return currentValue; // Return the reset value.\\n        }\\n    }\\n};\\n\\n// Example usage:\\nconst counter = createCounter(5);\\nconsole.log(counter.increment()); // Output: 6\\nconsole.log(counter.reset()); // Output: 5\\nconsole.log(counter.decrement()); // Output: 4\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\n<!-- Provide a brief description of your initial thoughts and strategies for solving this problem. -->\\n\\nThe goal of this problem is to create a counter object that can be incremented, decremented, and reset to its initial value. To achieve this, we can use a closure in JavaScript to encapsulate the current value of the counter.\\n\\n# Approach\\n<!-- Describe the approach you took to solve the problem. -->\\n\\nI used a closure to create a `createCounter` function that takes an initial value and returns an object with three methods:\\n1. `increment`: Increments the counter by 1 using pre-increment.\\n2. `decrement`: Decrements the counter by 1 using pre-decrement.\\n3. `reset`: Resets the counter to its initial value and returns the reset value.\\n\\nUsing pre-increment and pre-decrement ensures that the counter is updated before returning the new value, providing the desired behavior.\\n\\nAdditionally, I chose to reset the counter to its initial value first and then return the reset value in the `reset` method. This design choice simplifies the usage of the `reset` function. By resetting first, you can immediately access the reset value without the need for additional steps. This aligns with the principle of making functions as straightforward and predictable as possible.\\n\\n# Complexity\\n- Time complexity: O(1)\\n  - The time complexity of each method (increment, decrement, and reset) is O(1) because they involve simple arithmetic operations that take a constant amount of time.\\n\\n- Space complexity: O(1)\\n  - The space complexity of the `createCounter` function is O(1) because it only creates a single object with three methods and a single variable (`currentValue`) regardless of the input.\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init - The initial value of the counter.\\n * @return {Object} - An object with increment, decrement, and reset methods.\\n */\\nvar createCounter = function (init) {\\n    let currentValue = init; // Initialize the currentValue with the provided initial value.\\n    return {\\n        increment: () => ++currentValue, // Increment the currentValue and return the new value using pre-increment.\\n        decrement: () => --currentValue, // Decrement the currentValue and return the new value using pre-decrement.\\n        reset: () => {\\n            currentValue = init; // Reset the currentValue to the initial value first.\\n            return currentValue; // Return the reset value.\\n        }\\n    }\\n};\\n\\n// Example usage:\\nconst counter = createCounter(5);\\nconsole.log(counter.increment()); // Output: 6\\nconsole.log(counter.reset()); // Output: 5\\nconsole.log(counter.decrement()); // Output: 4\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4044929,
                "title": "counter-ii-using-pre-increment",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Take an object as return statement\\n2. Have three **Key:Value** pairs, having names increment, decrement, reset\\n3. Use **Pre increment to first execute the operation and then return value** rather than preincrement\\n\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentVal = init\\n    return {\\n        increment: () => ++presentVal,\\n        decrement: () => --presentVal,\\n        reset: () => presentVal = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentVal = init\\n    return {\\n        increment: () => ++presentVal,\\n        decrement: () => --presentVal,\\n        reset: () => presentVal = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041750,
                "title": "easy-approach",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init\\n    \\n    return {\\n        reset: () => value = init,\\n        increment: () => ++value,\\n        decrement: () => --value\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init\\n    \\n    return {\\n        reset: () => value = init,\\n        increment: () => ++value,\\n        decrement: () => --value\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040316,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentVal = init;\\n    return {\\n        increment: () => {\\n            return ++currentVal;\\n        },\\n        decrement: () => {\\n            return --currentVal;\\n        },\\n        reset: () => {\\n            currentVal = init;\\n            return currentVal;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentVal = init;\\n    return {\\n        increment: () => {\\n            return ++currentVal;\\n        },\\n        decrement: () => {\\n            return --currentVal;\\n        },\\n        reset: () => {\\n            currentVal = init;\\n            return currentVal;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039671,
                "title": "counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n   var createCounter = function(init) {\\n       let i = init;\\n  return {\\n      increment() {\\n          return ++i;\\n      },\\ndecrement() {\\n          return --i;\\n      },\\n       reset(){\\n            i = init;\\n            return i;\\n        }\\n\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n   var createCounter = function(init) {\\n       let i = init;\\n  return {\\n      increment() {\\n          return ++i;\\n      },\\ndecrement() {\\n          return --i;\\n      },\\n       reset(){\\n            i = init;\\n            return i;\\n        }\\n\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038154,
                "title": "simple-and-easy-to-understand",
                "content": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  let n = init;\\n  return {\\n    increment: () => {\\n      return ++n;\\n    },\\n    decrement: () => {\\n      return --n;\\n    },\\n    reset: () => {\\n      n = init;\\n      return n;\\n    }\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  let n = init;\\n  return {\\n    increment: () => {\\n      return ++n;\\n    },\\n    decrement: () => {\\n      return --n;\\n    },\\n    reset: () => {\\n      n = init;\\n      return n;\\n    }\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037426,
                "title": "javascript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original = init\\n    return {\\n        increment() {\\n            init++\\n            return init\\n        },\\n        reset() {\\n            init = original\\n            return init\\n        },\\n        decrement() {\\n            init--\\n            return init\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original = init\\n    return {\\n        increment() {\\n            init++\\n            return init\\n        },\\n        reset() {\\n            init = original\\n            return init\\n        },\\n        decrement() {\\n            init--\\n            return init\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037329,
                "title": "easy-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init;\\n    function increment() {\\n        x = x+1;\\n        return x\\n    };\\n    function decrement() {\\n        x = x-1;\\n        return x\\n    };\\n\\n    function reset(){\\n        x = init;\\n        return x\\n    };\\n\\n    return { increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init;\\n    function increment() {\\n        x = x+1;\\n        return x\\n    };\\n    function decrement() {\\n        x = x-1;\\n        return x\\n    };\\n\\n    function reset(){\\n        x = init;\\n        return x\\n    };\\n\\n    return { increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035108,
                "title": "simple-js-solution",
                "content": "```\\nvar createCounter = function(init) {\\n    var val = init;\\n    return {\\n        increment: () => {\\n            return ++val;\\n        },\\n        decrement: () => {\\n            return --val;\\n        },\\n        reset: () => {\\n            val = init;\\n            return val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    var val = init;\\n    return {\\n        increment: () => {\\n            return ++val;\\n        },\\n        decrement: () => {\\n            return --val;\\n        },\\n        reset: () => {\\n            val = init;\\n            return val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034990,
                "title": "much-easiest-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a=init;\\n    function increment(){\\n        return ++a\\n    }\\n    function decrement(){\\n        return --a\\n    }\\n    function reset(){\\n        return a=init\\n    }\\n    return{increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a=init;\\n    function increment(){\\n        return ++a\\n    }\\n    function decrement(){\\n        return --a\\n    }\\n    function reset(){\\n        return a=init\\n    }\\n    return{increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034374,
                "title": "js-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n    let startNumber = init;\\n\\n    return {\\n        increment: () => startNumber += 1,\\n        decrement: () => startNumber -= 1,\\n        reset: () => startNumber = init,\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n    let startNumber = init;\\n\\n    return {\\n        increment: () => startNumber += 1,\\n        decrement: () => startNumber -= 1,\\n        reset: () => startNumber = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034021,
                "title": "js-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    const x = init;\\n    return {\\n        increment: function() {\\n            return ++init;\\n        },\\n        decrement: function() {\\n            return --init;\\n        },\\n        reset: function() {\\n            init = x;\\n            return init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    const x = init;\\n    return {\\n        increment: function() {\\n            return ++init;\\n        },\\n        decrement: function() {\\n            return --init;\\n        },\\n        reset: function() {\\n            init = x;\\n            return init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033889,
                "title": "counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original=init\\n    let value=init\\n    return {\\n        increment:()=>{\\n            value+=1\\n            return value\\n        },\\n        reset:()=>{\\n            value=original\\n            return value\\n        },\\n        decrement:()=>{\\n            value-=1\\n            return value\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original=init\\n    let value=init\\n    return {\\n        increment:()=>{\\n            value+=1\\n            return value\\n        },\\n        reset:()=>{\\n            value=original\\n            return value\\n        },\\n        decrement:()=>{\\n            value-=1\\n            return value\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029317,
                "title": "outplay-99-69-memory",
                "content": "# Approach\\n`inc` increased and returned init\\n`dec` decreased and returned init\\n`reset` converted init to the og value\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return {\\n        increment:()=> ++init,\\n        decrement:()=>--init,\\n        reset:()=>init=c\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return {\\n        increment:()=> ++init,\\n        decrement:()=>--init,\\n        reset:()=>init=c\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027377,
                "title": "best-js-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let num = init;\\n    return {\\n        \"increment\": () => ++num,\\n        \"decrement\": () => --num,\\n        \"reset\": () => {num = init; return init}\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let num = init;\\n    return {\\n        \"increment\": () => ++num,\\n        \"decrement\": () => --num,\\n        \"reset\": () => {num = init; return init}\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025475,
                "title": "counter",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let currVal = init;\\n    return {\\n        increment: () => {\\n            currVal++;\\n            return currVal;\\n        },\\n        reset: () => {\\n            currVal = init;\\n            return currVal;\\n        },\\n        decrement: () => {\\n            currVal--;\\n            return currVal;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let currVal = init;\\n    return {\\n        increment: () => {\\n            currVal++;\\n            return currVal;\\n        },\\n        reset: () => {\\n            currVal = init;\\n            return currVal;\\n        },\\n        decrement: () => {\\n            currVal--;\\n            return currVal;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022641,
                "title": "counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021430,
                "title": "simple-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return {\\n        increment: () => {\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: () => {\\n            currentValue = currentValue - 1;\\n            return currentValue;\\n        },\\n        reset: () => {\\n            currentValue = init;\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return {\\n        increment: () => {\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: () => {\\n            currentValue = currentValue - 1;\\n            return currentValue;\\n        },\\n        reset: () => {\\n            currentValue = init;\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021108,
                "title": "best-way-for-reset-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a= init;\\n    return{\\n        increment : function(){\\n            return ++a;\\n        },\\n        reset : function(){\\n            a= init;\\n            return a;\\n        },\\n        decrement : function(){\\n            return --a;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a= init;\\n    return{\\n        increment : function(){\\n            return ++a;\\n        },\\n        reset : function(){\\n            a= init;\\n            return a;\\n        },\\n        decrement : function(){\\n            return --a;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020985,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    class Count {\\n            constructor() {\\n                this.init = init;\\n            }\\n\\n            increment() {\\n                this.init++;\\n                return this.init;\\n            }\\n\\n            decrement() {\\n                this.init--;\\n                return this.init;\\n            }\\n\\n            reset() {\\n                this.init = init;\\n                return this.init;\\n            }\\n        }\\n\\n    return new Count;\\n};\\n\\nconst counter = new createCounter(10);\\nconsole.log(counter.increment());\\nconsole.log(counter.reset());\\nconsole.log(counter.decrement());\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    class Count {\\n            constructor() {\\n                this.init = init;\\n            }\\n\\n            increment() {\\n                this.init++;\\n                return this.init;\\n            }\\n\\n            decrement() {\\n                this.init--;\\n                return this.init;\\n            }\\n\\n            reset() {\\n                this.init = init;\\n                return this.init;\\n            }\\n        }\\n\\n    return new Count;\\n};\\n\\nconst counter = new createCounter(10);\\nconsole.log(counter.increment());\\nconsole.log(counter.reset());\\nconsole.log(counter.decrement());\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020606,
                "title": "solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter=init;\\n    return{\\n        increment:function(){\\n            return ++counter;\\n        },\\n        reset:function(){\\n            counter=init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            return --counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter=init;\\n    return{\\n        increment:function(){\\n            return ++counter;\\n        },\\n        reset:function(){\\n            counter=init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            return --counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020054,
                "title": "counter-using-ts-and-js-fully-explained",
                "content": "# Approach\\n1- capture init (integer) and store it in a new variable\\n2- storing in new variable helps you reset the state to orignal else you will end up in getting the wring answer.\\n3- then on each function return the expected result \\n4- for information newVal+=1 === newVal++\\n5- REad the commented code also\\n6- there you see how we are storing simple integer in array\\n7- thats it...\\n\\n# TYPESCRIPT\\n\\n# Code\\n```ts\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let newVal = init;\\n    function increment (){\\n        return newVal +=1\\n    }\\n    function decrement (){\\n        return newVal -=1\\n    }\\n    function reset (){\\n        newVal = init;\\n        return newVal\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n```\\n\\n# JAVASCRIPT\\n\\n# Code\\n```js\\nconst createCounter = (init) => {\\n  let newVal  = init\\n  function increase() {    \\n    return newVal+=1;\\n  }\\n  function decrease() {\\n    return newVal-=1;\\n  }\\n  function reset() {    \\n    newVal= init\\n    return init;\\n  }\\n\\n  return {\\n    increase,\\n    decrease,\\n    reset,\\n  };\\n};\\n/*\\nconst init = 0;\\nconst counter = createCounter(init);\\nconst result = [];\\nresult.push(counter.increase());\\nresult.push(counter.increase());\\nresult.push(counter.decrease());\\nresult.push(counter.reset());\\nresult.push(counter.reset());\\nconsole.log(\"\\uD83D\\uDE80 ~ file: app.js:26 ~ result:\", result) -->\\n*/\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let newVal = init;\\n    function increment (){\\n        return newVal +=1\\n    }\\n    function decrement (){\\n        return newVal -=1\\n    }\\n    function reset (){\\n        newVal = init;\\n        return newVal\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n```\n```js\\nconst createCounter = (init) => {\\n  let newVal  = init\\n  function increase() {    \\n    return newVal+=1;\\n  }\\n  function decrease() {\\n    return newVal-=1;\\n  }\\n  function reset() {    \\n    newVal= init\\n    return init;\\n  }\\n\\n  return {\\n    increase,\\n    decrease,\\n    reset,\\n  };\\n};\\n/*\\nconst init = 0;\\nconst counter = createCounter(init);\\nconst result = [];\\nresult.push(counter.increase());\\nresult.push(counter.increase());\\nresult.push(counter.decrease());\\nresult.push(counter.reset());\\nresult.push(counter.reset());\\nconsole.log(\"\\uD83D\\uDE80 ~ file: app.js:26 ~ result:\", result) -->\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016831,
                "title": "simplest-code",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    \\n    function reset () {\\n        counter = init\\n        return counter\\n    }\\n\\n    return {\\n        increment: ()=> ++counter,\\n        decrement: ()=> --counter,\\n        reset: ()=> reset()\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    \\n    function reset () {\\n        counter = init\\n        return counter\\n    }\\n\\n    return {\\n        increment: ()=> ++counter,\\n        decrement: ()=> --counter,\\n        reset: ()=> reset()\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014396,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {\\n       increment,\\n       decrement,\\n       reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {\\n       increment,\\n       decrement,\\n       reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013390,
                "title": "javascript-detailed-explaination-easy-to-understand",
                "content": "# Intuition\\nThe `createCounter` function is designed to create a counter object with an initial value `init`. This counter object has three methods: `increment`, `decrement`, and `reset`, which respectively increase the value by 1, decrease the value by 1, and reset the value to the initial `init`.\\n\\n# Approach\\nWe have implemented the `createCounter` function that returns an object with three methods:\\n1. `increment()`: This method increments the `value` property of the counter object by 1 and then returns the updated value.\\n\\n2. `decrement()`: This method decrements the `value` property of the counter object by 1 and then returns the updated value.\\n\\n3. `reset()`: This method sets the `value` property of the counter object back to the initial `init` value and then returns the updated value.\\n\\nWe\\'ve used the `this` keyword to access the `value` property within each method.\\n\\n# Complexity\\n- Time complexity: All three methods, `increment`, `decrement`, and `reset`, have constant time complexity, i.e., O(1), as they perform simple value updates.\\n\\n- Space complexity: The `createCounter` function returns an object with three methods, but their memory usage is negligible. Therefore, the space complexity is also O(1).\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init\\n * @return {Object}\\n */\\nvar createCounter = function(init) {\\n    return {\\n        value: init,\\n        increment() {\\n            return ++this.value;\\n        },\\n        decrement() {\\n            return --this.value;\\n        },\\n        reset() {\\n            this.value = init;\\n            return this.value;\\n        }\\n    };\\n};\\n\\n// Example usages:\\nconst counter1 = createCounter(5);\\nconsole.log(counter1.increment()); // 6\\nconsole.log(counter1.reset()); // 5\\nconsole.log(counter1.decrement()); // 4\\n\\nconst counter2 = createCounter(0);\\nconsole.log(counter2.increment()); // 1\\nconsole.log(counter2.increment()); // 2\\nconsole.log(counter2.decrement()); // 1\\nconsole.log(counter2.reset()); // 0\\nconsole.log(counter2.reset()); // 0\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {integer} init\\n * @return {Object}\\n */\\nvar createCounter = function(init) {\\n    return {\\n        value: init,\\n        increment() {\\n            return ++this.value;\\n        },\\n        decrement() {\\n            return --this.value;\\n        },\\n        reset() {\\n            this.value = init;\\n            return this.value;\\n        }\\n    };\\n};\\n\\n// Example usages:\\nconst counter1 = createCounter(5);\\nconsole.log(counter1.increment()); // 6\\nconsole.log(counter1.reset()); // 5\\nconsole.log(counter1.decrement()); // 4\\n\\nconst counter2 = createCounter(0);\\nconsole.log(counter2.increment()); // 1\\nconsole.log(counter2.increment()); // 2\\nconsole.log(counter2.decrement()); // 1\\nconsole.log(counter2.reset()); // 0\\nconsole.log(counter2.reset()); // 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012651,
                "title": "counter-ii-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let rs = init, curr = init;\\n    var op = {\\n        \"increment\": function() {\\n            return ++curr;\\n        },\\n        \"decrement\": function() {\\n            return --curr;\\n        },\\n        \"reset\": function() {\\n            curr = rs;\\n            return curr;\\n        }\\n    };\\n    return op;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let rs = init, curr = init;\\n    var op = {\\n        \"increment\": function() {\\n            return ++curr;\\n        },\\n        \"decrement\": function() {\\n            return --curr;\\n        },\\n        \"reset\": function() {\\n            curr = rs;\\n            return curr;\\n        }\\n    };\\n    return op;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010139,
                "title": "object-return",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let restore=init;\\n    return {\\n        increment:()=>{\\n        return restore+=1;\\n        },\\n        decrement:()=>{\\n         return restore-=1;\\n        },\\n        reset:()=>{\\n         return restore=init;\\n\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let restore=init;\\n    return {\\n        increment:()=>{\\n        return restore+=1;\\n        },\\n        decrement:()=>{\\n         return restore-=1;\\n        },\\n        reset:()=>{\\n         return restore=init;\\n\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009954,
                "title": "simple-solution-with-explanation",
                "content": "# Explanation\\n\\nBy Looking at the example, we know createCounter should return an object that has three attributes i.e. `increment`, `decrement`, and `reset`. Since `reset` has to reset the value to the initial value passed, we should create a reference to the initial value before we increase or decrease.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let initVal = init;\\n\\n  return {\\n    increment: () => {\\n      return ++initVal;\\n    },\\n    reset: () => {\\n      initVal = init;\\n      return initVal;\\n    },\\n    decrement: () => {\\n      return --initVal;\\n    },\\n  };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let initVal = init;\\n\\n  return {\\n    increment: () => {\\n      return ++initVal;\\n    },\\n    reset: () => {\\n      initVal = init;\\n      return initVal;\\n    },\\n    decrement: () => {\\n      return --initVal;\\n    },\\n  };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006921,
                "title": "easy-must-check-this",
                "content": "# Intuition\\nWe need function that  returns an object with three methods: increment, decrement, and reset. When you call these methods, they perform the respective operations and return the updated current value.\\n\\n# Approach\\nThis function returns an object with three methods: increment, decrement, and reset. When you call these methods, they perform the respective operations and return the updated current value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let currentValue = init;\\n return {\\n    increment: function () {\\n      currentValue++;\\n      return currentValue;\\n    },\\n    decrement: function () {\\n      currentValue--;\\n      return currentValue;\\n    },\\n    reset: function () {\\n      currentValue = init;\\n      return currentValue;\\n    },\\n\\n   } \\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n![killlakill-upvote.gif](https://assets.leetcode.com/users/images/ef409f66-3cf5-4d30-a804-afa8f9af9870_1693939067.415885.gif)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let currentValue = init;\\n return {\\n    increment: function () {\\n      currentValue++;\\n      return currentValue;\\n    },\\n    decrement: function () {\\n      currentValue--;\\n      return currentValue;\\n    },\\n    reset: function () {\\n      currentValue = init;\\n      return currentValue;\\n    },\\n\\n   } \\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006827,
                "title": "2-simple-and-easy-javascript-solution",
                "content": "# Code\\n1st approach -->\\n```\\n// Runtime 59ms Beats 67.12% of users\\n// Memory 44.28MB Beats 81.87% of users\\nvar createCounter = function(init) {\\n    let num = init;\\n    let obj = {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n    \\n    return obj;\\n};\\n\\n```\\n2nd approach -->\\n```\\n// Runtime 50ms Beats 94.63% of users\\n// Memory 44.10MB Beats 91.99% of users\\nlet createCounter = function(init) {\\n    let i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Runtime 59ms Beats 67.12% of users\\n// Memory 44.28MB Beats 81.87% of users\\nvar createCounter = function(init) {\\n    let num = init;\\n    let obj = {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n    \\n    return obj;\\n};\\n\\n```\n```\\n// Runtime 50ms Beats 94.63% of users\\n// Memory 44.10MB Beats 91.99% of users\\nlet createCounter = function(init) {\\n    let i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005439,
                "title": "this-is-simple-here-we-are-setting-a-value-and-then-increment-and-decrement-using-arrow-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let i=0;\\n     return{\\n          increment:()=>init + ++i,\\n          decrement:()=>init + --i,\\n          reset:()=> {i=0;\\n          return init ;\\n          }\\n          \\n     }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let i=0;\\n     return{\\n          increment:()=>init + ++i,\\n          decrement:()=>init + --i,\\n          reset:()=> {i=0;\\n          return init ;\\n          }\\n          \\n     }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004243,
                "title": "counter-using-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    //store the initial value on another value in case of reset function\\n\\n    let initval = init\\n\\n    //the required functions \\n\\n    return {\\n        increment: ()=> ++init,\\n        decrement : () => --init,\\n        reset: ()=> init = initval\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    //store the initial value on another value in case of reset function\\n\\n    let initval = init\\n\\n    //the required functions \\n\\n    return {\\n        increment: ()=> ++init,\\n        decrement : () => --init,\\n        reset: ()=> init = initval\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000896,
                "title": "javascript-method-chaining",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->can Do using method chaining approach.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let newInt = init;\\n    return {\\n        increment: ()=> {\\nnewInt+=1;\\n            return newInt;\\n        },\\n        reset:()=>{\\n           newInt=init;\\n            return newInt;\\n        },\\n        decrement: ()=>{\\n            newInt-=1;\\n            return newInt;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let newInt = init;\\n    return {\\n        increment: ()=> {\\nnewInt+=1;\\n            return newInt;\\n        },\\n        reset:()=>{\\n           newInt=init;\\n            return newInt;\\n        },\\n        decrement: ()=>{\\n            newInt-=1;\\n            return newInt;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999105,
                "title": "normal-day-in-developers-life",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let cnt = init ;\\n    return {\\n        increment(){\\n            return ++cnt\\n        },\\n        decrement(){\\n            return --cnt\\n        },\\n        reset(){\\n            return cnt = init\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let cnt = init ;\\n    return {\\n        increment(){\\n            return ++cnt\\n        },\\n        decrement(){\\n            return --cnt\\n        },\\n        reset(){\\n            return cnt = init\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998338,
                "title": "3-lines-javascript-code-for-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let temp = init;\\n    return{\\n        increment: () => init+=1,\\n        decrement:() => init-=1,\\n        reset: () => init = temp\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let temp = init;\\n    return{\\n        increment: () => init+=1,\\n        decrement:() => init-=1,\\n        reset: () => init = temp\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998099,
                "title": "to-the-point-and-straight-to-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n=init; \\n    let count={increment : function inc(){\\n       return ++n;\\n    },decrement : function dec(){\\n     return --n;\\n\\n    },\\n    reset : function reset(){\\n        return (n=init);\\n    }}\\n    return count;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n=init; \\n    let count={increment : function inc(){\\n       return ++n;\\n    },decrement : function dec(){\\n     return --n;\\n\\n    },\\n    reset : function reset(){\\n        return (n=init);\\n    }}\\n    return count;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997967,
                "title": "counter-ii-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current_count =init;\\n    return {\\n        increment:function(){\\n            return ++current_count;\\n        },\\n        decrement:function(){\\n            return --current_count;\\n        },\\n        reset:function(){\\n            return (current_count =init);\\n        }\\n\\n    }\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current_count =init;\\n    return {\\n        increment:function(){\\n            return ++current_count;\\n        },\\n        decrement:function(){\\n            return --current_count;\\n        },\\n        reset:function(){\\n            return (current_count =init);\\n        }\\n\\n    }\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996340,
                "title": "ok",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    \\n    let counter= init;\\n    const object = {\\n        \\n        increment:function(){\\n            counter++;\\n            return counter;\\n        },\\n        reset:function(){\\n            counter= init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            counter--;\\n            return counter;\\n        }\\n    \\n    }\\n        \\n      return object;  \\n    \\n};\\n\\ntry{\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n counter.reset(); // 5\\n  counter.decrement(); // 4\\n}catch(e){\\n    console.log(e.message)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    \\n    let counter= init;\\n    const object = {\\n        \\n        increment:function(){\\n            counter++;\\n            return counter;\\n        },\\n        reset:function(){\\n            counter= init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            counter--;\\n            return counter;\\n        }\\n    \\n    }\\n        \\n      return object;  \\n    \\n};\\n\\ntry{\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n counter.reset(); // 5\\n  counter.decrement(); // 4\\n}catch(e){\\n    console.log(e.message)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996231,
                "title": "javascript-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let initialValue = init;\\n    return {\\n        increment: ()=>{\\n            init = init+1\\n            return init \\n        },\\n        decrement: ()=> {\\n            init = init-1\\n            return init \\n        },\\n        reset: ()=> {\\n            init = initialValue\\n            return init \\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let initialValue = init;\\n    return {\\n        increment: ()=>{\\n            init = init+1\\n            return init \\n        },\\n        decrement: ()=> {\\n            init = init-1\\n            return init \\n        },\\n        reset: ()=> {\\n            init = initialValue\\n            return init \\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990723,
                "title": "easy-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num+1,\\n        reset: () => num = init,\\n        decrement: () => num = num-1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num+1,\\n        reset: () => num = init,\\n        decrement: () => num = num-1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985409,
                "title": "ans-2665",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment () {\\n        return ++count\\n\\n    }\\n    function decrement() {\\n         return --count\\n\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }   \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment () {\\n        return ++count\\n\\n    }\\n    function decrement() {\\n         return --count\\n\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }   \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985110,
                "title": "counter-ii",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let current = init\\n    return {\\n        increment: function () {\\n            current += 1;\\n            return current;\\n        },\\n        decrement: function () {\\n            current -= 1;\\n            return current;\\n        },\\n        reset: function () {\\n            current = init;\\n            return current;\\n        }\\n    }\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math"
                ],
                "code": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let current = init\\n    return {\\n        increment: function () {\\n            current += 1;\\n            return current;\\n        },\\n        decrement: function () {\\n            current -= 1;\\n            return current;\\n        },\\n        reset: function () {\\n            current = init;\\n            return current;\\n        }\\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3982547,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have to keep the `init` value for `reset`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, I stored the `init` value in `n`. And I implement three functions. In particular, I include initialization process in `reset()`.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    let n = init;\\n\\n    return {\\n        increment(){\\n            return ++n;\\n        },\\n        decrement(){\\n            return --n;\\n        },\\n        reset(){\\n            return n = init;\\n        }\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    let n = init;\\n\\n    return {\\n        increment(){\\n            return ++n;\\n        },\\n        decrement(){\\n            return --n;\\n        },\\n        reset(){\\n            return n = init;\\n        }\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982004,
                "title": "use-the-some-variable-for-the-storing-the-value-before-the-return-statement",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    general=init\\n    return {\\n        increment: () => {\\n            general++\\n            return general;\\n        }, reset : ()=>{\\n            general=init;\\n            return general;\\n        },\\n        decrement: () => {\\n              general--\\n             \\n             return general\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    general=init\\n    return {\\n        increment: () => {\\n            general++\\n            return general;\\n        }, reset : ()=>{\\n            general=init;\\n            return general;\\n        },\\n        decrement: () => {\\n              general--\\n             \\n             return general\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981724,
                "title": "js-beats-78-of-coders-simplest-easiest-optimal-solution-using-arrow-function",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let pre = init;\\n    return {\\n        increment: () => ++pre,\\n        decrement: () => --pre,\\n        reset: () => pre = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let pre = init;\\n    return {\\n        increment: () => ++pre,\\n        decrement: () => --pre,\\n        reset: () => pre = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979308,
                "title": "johnny",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    let totalCalls = 0;\\n    const initFix = init;\\n    if(-1000 <= init || init <= 1000){\\n        if(++totalCalls > 1000){ return \"total calls not to exceed 1000\"; }\\n        return {\\n            increment: function(){\\n                return ++current;\\n            }, \\n            decrement: function(){\\n                return --current;\\n            }, \\n            reset: function (){\\n                current = initFix;\\n                return current;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    let totalCalls = 0;\\n    const initFix = init;\\n    if(-1000 <= init || init <= 1000){\\n        if(++totalCalls > 1000){ return \"total calls not to exceed 1000\"; }\\n        return {\\n            increment: function(){\\n                return ++current;\\n            }, \\n            decrement: function(){\\n                return --current;\\n            }, \\n            reset: function (){\\n                current = initFix;\\n                return current;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978873,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let r=init;\\n    return {\\n        increment:function(){\\n            return ++r;\\n        },\\n        reset:function(){\\n            r=init;\\n            return r;\\n        },\\n        decrement:function(){\\n            return --r;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let r=init;\\n    return {\\n        increment:function(){\\n            return ++r;\\n        },\\n        reset:function(){\\n            r=init;\\n            return r;\\n        },\\n        decrement:function(){\\n            return --r;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978183,
                "title": "nice",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nlet i = init\\n    return {\\n    increment: ()=>{\\n   return ++i\\n    },\\n    decrement: ()=>{\\n    return --i\\n    },\\n    reset: ()=>{\\n    return i = init\\n    }}};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nlet i = init\\n    return {\\n    increment: ()=>{\\n   return ++i\\n    },\\n    decrement: ()=>{\\n    return --i\\n    },\\n    reset: ()=>{\\n    return i = init\\n    }}};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977579,
                "title": "counter-ii-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977571,
                "title": "counter-ii-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973195,
                "title": "concept-of-closures-and-objects-in-js",
                "content": "# Intuition\\nremember:\\nIn closures we have the referece to the parent variables.\\nwithin the object in three methods one by one, we are not copying the value and making the change,instead the change is made to the original value, as we are pointing to the same varibale.\\n\\nNeed to make two variables to keep track of the values, one for the reset value, at any  point of time, we can reset the current value to reset value.\\n```\\nlet resetVal = init;\\nlet value = resetVal;\\n// manipulate the value , increment it, decrement, whatever logic you perform, once there is a need to reset it to its initial ,\\nsimply // do this\\nvalue = resetVal;\\n```\\n# Approach\\ndefine three methods:\\n```\\nfunction increment (){...}\\nfunction decrement (){...}\\nfunction reset (){...}\\n```\\nand just return the object with these three methods:\\n```\\nreturn {\\nincrement: increment,\\ndecrement: decrement,\\nreset: reset\\n};\\n```\\ndo not be confuse here, because we are just passing the reference to the methods in the object.\\n\\nHope it helps, if yes, please upvote.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let resetVal = init; \\n    let value = resetVal; \\n\\n    function increment(){\\n        return ++value;    \\n    }\\n    function reset(){\\n        value = resetVal; \\n        return value; \\n    }\\n    function decrement(){\\n        return --value; \\n    }\\n    return {\\n        increment: increment,\\n        decrement: decrement,\\n        reset: reset\\n    };\\n};\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet resetVal = init;\\nlet value = resetVal;\\n// manipulate the value , increment it, decrement, whatever logic you perform, once there is a need to reset it to its initial ,\\nsimply // do this\\nvalue = resetVal;\\n```\n```\\nfunction increment (){...}\\nfunction decrement (){...}\\nfunction reset (){...}\\n```\n```\\nreturn {\\nincrement: increment,\\ndecrement: decrement,\\nreset: reset\\n};\\n```\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let resetVal = init; \\n    let value = resetVal; \\n\\n    function increment(){\\n        return ++value;    \\n    }\\n    function reset(){\\n        value = resetVal; \\n        return value; \\n    }\\n    function decrement(){\\n        return --value; \\n    }\\n    return {\\n        increment: increment,\\n        decrement: decrement,\\n        reset: reset\\n    };\\n};\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972407,
                "title": "clean-easy-solution",
                "content": "# Approach\\nStore the original variable separately which will be called upon reset.\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    let val = init\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    let val = init\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972132,
                "title": "solution-using-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n\\treturn {\\n\\t\\tinit: init,\\n\\t\\tincrement: function () {\\n\\t\\t\\treturn (this.init = this.init + 1)\\n\\t\\t},\\n\\t\\treset: function () {\\n\\t\\t\\treturn (this.init = init)\\n\\t\\t},\\n\\t\\tdecrement: function () {\\n\\t\\t\\treturn (this.init = this.init - 1)\\n\\t\\t},\\n\\t}\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n\\treturn {\\n\\t\\tinit: init,\\n\\t\\tincrement: function () {\\n\\t\\t\\treturn (this.init = this.init + 1)\\n\\t\\t},\\n\\t\\treset: function () {\\n\\t\\t\\treturn (this.init = init)\\n\\t\\t},\\n\\t\\tdecrement: function () {\\n\\t\\t\\treturn (this.init = this.init - 1)\\n\\t\\t},\\n\\t}\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968582,
                "title": "js-solution-with-prefix-increment-and-decrement",
                "content": "\\n# Code\\n```\\nvar createCounter = function(init) {\\n    let result = init;\\n    return {\\n        increment: function() {\\n            return ++result;\\n        },\\n        decrement: function() {\\n            return --result;\\n        },\\n        reset: function() {\\n            result = init;\\n            return result;   \\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    let result = init;\\n    return {\\n        increment: function() {\\n            return ++result;\\n        },\\n        decrement: function() {\\n            return --result;\\n        },\\n        reset: function() {\\n            result = init;\\n            return result;   \\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966413,
                "title": "concise-and-modern-code",
                "content": "# Intuition\\nThe Thought was simple to use as minimum statements as possible.\\n\\n# Approach\\nUsed the modern arrow function syntax with increment operators.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = resetValue;\\n            return init;\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = resetValue;\\n            return init;\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964317,
                "title": "counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    return {\\n   increment: () => num = num + 1,\\n    reset: () => num = init,\\n    decrement: () => num = num - 1\\n}\\n};\\n\\n\\n const counter = createCounter(5)\\n counter.increment(); // 6\\n counter.reset(); // 5\\n counter.decrement(); // 4\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    return {\\n   increment: () => num = num + 1,\\n    reset: () => num = init,\\n    decrement: () => num = num - 1\\n}\\n};\\n\\n\\n const counter = createCounter(5)\\n counter.increment(); // 6\\n counter.reset(); // 5\\n counter.decrement(); // 4\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963953,
                "title": "simple-ts",
                "content": "# Code\\n```\\ninterface ReturnObj {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    const initCopy = init\\n\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = initCopy\\n            return init\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ninterface ReturnObj {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    const initCopy = init\\n\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = initCopy\\n            return init\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963436,
                "title": "solution",
                "content": "# Intuition\\nmy first leetcode code that actually worked lol, i am sorry if its not upto the mark\\n# Code\\n\\nvar createCounter = function(init,cur) {\\n    cur=init\\n    return{\\n        increment: ()=>{\\n            return init=init+1;\\n        },\\n        decrement: ()=>{\\n            return init=init-1;\\n        },\\n        reset: ()=>{\\n            return init= cur;\\n        }\\n\\n    }\\n    \\n};\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\nmy first leetcode code that actually worked lol, i am sorry if its not upto the mark\\n# Code\\n\\nvar createCounter = function(init,cur) {\\n    cur=init\\n    return{\\n        increment: ()=>{\\n            return init=init+1;\\n        },\\n        decrement: ()=>{\\n            return init=init-1;\\n        },\\n        reset: ()=>{\\n            return init= cur;\\n        }\\n\\n    }\\n    \\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3959373,
                "title": "simple-solution-to-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val = init;\\n    return {\\n        increment : () => {\\n            return ++val;\\n        },\\n        decrement : () => {\\n            return --val;\\n        },\\n        reset : () => {\\n            return val = init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val = init;\\n    return {\\n        increment : () => {\\n            return ++val;\\n        },\\n        decrement : () => {\\n            return --val;\\n        },\\n        reset : () => {\\n            return val = init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957960,
                "title": "counter-ii-solution",
                "content": "# Intuition\\nincrement(): Increase the current value by 1 and then return it.\\ndecrement(): Decrease the current value by 1 and then return it.\\nreset(): Set the current value to the initial value (init) and then return it.\\nKeeping these actions in mind, it\\'s important to note that the initial value of init needs to be preserved for the reset() operation. To achieve this, we can initialize a separate variable, count, with the initial value. This variable will be used to maintain the current value during the increment and decrement operations.\\n\\nBefore seeing the solution keep in mind the this Intution part and try again you can do it. it\\'s easy \\n\\n\\n# Approach\\nTo approach this problem, it\\'s helpful to read the provided instructions carefully and translate them into a step-by-step process for each of the required methods: increment(), decrement(), and reset().\\n\\n\\n# Complexity\\nTime complexity: O(1) - Each method performs a constant number of operations regardless of the input value.\\n\\nSpace complexity: O(1) - The additional space used is independent of the input and remains constant.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\nlet createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment(){\\n            return ++count;\\n\\n        },\\n        decrement(){\\n            return --count;\\n\\n        },\\n        reset(){\\n          count = init;\\n          return count;\\n         \\n        },\\n    }\\n\\n    \\n     \\n };\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\nlet createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment(){\\n            return ++count;\\n\\n        },\\n        decrement(){\\n            return --count;\\n\\n        },\\n        reset(){\\n          count = init;\\n          return count;\\n         \\n        },\\n    }\\n\\n    \\n     \\n };\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949017,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947272,
                "title": "solution-using-es6-style",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter=init\\n    const increment=()=>{\\n        counter+=1;\\n    return counter\\n    }\\n    const decrement=()=>{\\n        counter-=1;\\n        return counter}\\n    const reset=()=>{counter=init\\n    return counter}\\n    return {increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter=init\\n    const increment=()=>{\\n        counter+=1;\\n    return counter\\n    }\\n    const decrement=()=>{\\n        counter-=1;\\n        return counter}\\n    const reset=()=>{counter=init\\n    return counter}\\n    return {increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945454,
                "title": "easy-approach",
                "content": "# Intuition\\n If you know chaining it would be child play really\\n# Approach\\nApproach see down what its actually asking then accordingly you do the task\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const originalValue = init;\\n    return{\\n        increment: ()=>{\\n            return ++init;\\n        },\\n        reset: ()=>{\\n            return init = originalValue; \\n        },\\n        decrement: ()=>{\\n            return --init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const originalValue = init;\\n    return{\\n        increment: ()=>{\\n            return ++init;\\n        },\\n        reset: ()=>{\\n            return init = originalValue; \\n        },\\n        decrement: ()=>{\\n            return --init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944911,
                "title": "counter-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let totalcount = init;\\n    increment = () => {\\n        totalcount++;\\n        return totalcount;\\n    }\\n    decrement = () => {\\n        totalcount--;\\n        return totalcount;\\n    }\\n     \\n    reset =() => {\\n        totalcount = init;\\n        return totalcount;\\n    }\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let totalcount = init;\\n    increment = () => {\\n        totalcount++;\\n        return totalcount;\\n    }\\n    decrement = () => {\\n        totalcount--;\\n        return totalcount;\\n    }\\n     \\n    reset =() => {\\n        totalcount = init;\\n        return totalcount;\\n    }\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944645,
                "title": "test",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const start = init;\\n    return {\\n        increment: () => {\\n            init += 1\\n            return init\\n        },\\n        decrement: () => {\\n            return init -= 1\\n        },\\n        reset: () => {\\n            init = start\\n             return init\\n        }\\n    }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const start = init;\\n    return {\\n        increment: () => {\\n            init += 1\\n            return init\\n        },\\n        decrement: () => {\\n            return init -= 1\\n        },\\n        reset: () => {\\n            init = start\\n             return init\\n        }\\n    }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944435,
                "title": "30-days-of-javascript-counter-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var curr = init;\\n    return{\\n        increment: function(){\\n            curr = curr + 1;\\n            return curr;\\n        },\\n        decrement: function(){\\n            curr--;\\n            return curr;\\n        },\\n        reset: function(){\\n            curr = init;\\n            return curr;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n**PLEASE UpVOTE**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var curr = init;\\n    return{\\n        increment: function(){\\n            curr = curr + 1;\\n            return curr;\\n        },\\n        decrement: function(){\\n            curr--;\\n            return curr;\\n        },\\n        reset: function(){\\n            curr = init;\\n            return curr;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943389,
                "title": "easy-to-understand-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let i = init;\\n  reset=()=>{\\n    i = init\\n    return i;\\n  }\\n  \\n  increment = () => ++i;\\n  decrement = () => --i;\\n  \\n  return {increment,decrement,reset};  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let i = init;\\n  reset=()=>{\\n    i = init\\n    return i;\\n  }\\n  \\n  increment = () => ++i;\\n  decrement = () => --i;\\n  \\n  return {increment,decrement,reset};  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942062,
                "title": "simplest-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const original = init;\\n    let value = init;\\n\\n    return {\\n        increment: function() {\\n            return ++value;\\n        },\\n        decrement: function() {\\n            return --value;\\n        },\\n        reset: function() {\\n            value = original;\\n            return original;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const original = init;\\n    let value = init;\\n\\n    return {\\n        increment: function() {\\n            return ++value;\\n        },\\n        decrement: function() {\\n            return --value;\\n        },\\n        reset: function() {\\n            value = original;\\n            return original;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940454,
                "title": "clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let current = Number(init);\\n\\n    const increment = () => ++current;\\n\\n    const decrement = () => --current;\\n\\n    const reset = () => {\\n        current = Number(init);\\n        return init;\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let current = Number(init);\\n\\n    const increment = () => ++current;\\n\\n    const decrement = () => --current;\\n\\n    const reset = () => {\\n        current = Number(init);\\n        return init;\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937735,
                "title": "2665-javascript-solution-for-counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val=init;\\n    function increment(){\\n        val++;\\n        return val\\n    }\\n    function decrement(){\\n        val--;\\n        return val\\n    }\\n    function reset(){\\n        val=init;\\n        return val\\n    }\\n    return{\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val=init;\\n    function increment(){\\n        val++;\\n        return val\\n    }\\n    function decrement(){\\n        val--;\\n        return val\\n    }\\n    function reset(){\\n        val=init;\\n        return val\\n    }\\n    return{\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936285,
                "title": "30-days-of-javascript-counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore a copy of initial value into a variable and update according to the functions requirments.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) First Make a Variable named currentValue to store initial value\\n2) in functions return block, create three function increment, decrement and reset.\\n3) Now Follow The Problem requirment and update and return currentValue in functions.\\n4) In reset, Reset the currentValue to it\\'s initial value\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return{\\n        increment: function(){\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: function(){\\n            currentValue--;\\n            return currentValue;\\n        },\\n        reset: function(){\\n            currentValue = init\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return{\\n        increment: function(){\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: function(){\\n            currentValue--;\\n            return currentValue;\\n        },\\n        reset: function(){\\n            currentValue = init\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924517,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init                                \\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    // let val = init\\n    // let count = 0\\n    // console.log(count++)\\n    let val = init\\n   return{\\n       increment:()=>{\\n           return ++init\\n       },\\n       decrement:()=>{\\n           return --init\\n       },\\n       reset:()=>{\\n           return init = val\\n       }\\n   }\\n\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init                                \\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    // let val = init\\n    // let count = 0\\n    // console.log(count++)\\n    let val = init\\n   return{\\n       increment:()=>{\\n           return ++init\\n       },\\n       decrement:()=>{\\n           return --init\\n       },\\n       reset:()=>{\\n           return init = val\\n       }\\n   }\\n\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923237,
                "title": "typescript-minimalistic-code",
                "content": "# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let val = init;\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let val = init;\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3920972,
                "title": "beginner-friendly-approach",
                "content": "# Intuition\\nuse a const to store value of init for reset function. we can directly increment or decrement the value of init and reset the value using the const we declared.\\n# Complexity\\nbeats 80% in both time complexity and space complexity.\\n# Code\\n```\\n\\nvar createCounter = function(init) {\\n    const a=init;\\n    return{\\n        increment: ()=> ++init,\\n        reset: ()=> init=a,\\n        decrement: ()=>--init\\n        }\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\nuse a const to store value of init for reset function. we can directly increment or decrement the value of init and reset the value using the const we declared.\\n# Complexity\\nbeats 80% in both time complexity and space complexity.\\n# Code\\n```\\n\\nvar createCounter = function(init) {\\n    const a=init;\\n    return{\\n        increment: ()=> ++init,\\n        reset: ()=> init=a,\\n        decrement: ()=>--init\\n        }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3916749,
                "title": "shortest-and-easiest-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar createCounter = function(init) {\\n let num = init;\\n   return {\\n       increment: ()=>{\\n           return ++num ;\\n       },\\n       reset: ()=>{\\n           return num = init;\\n       },\\n         decrement: ()=>{\\n           return --num;\\n       },\\n         \\n   } \\n};\\n\\n\\n  const counter = createCounter(5)\\n counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar createCounter = function(init) {\\n let num = init;\\n   return {\\n       increment: ()=>{\\n           return ++num ;\\n       },\\n       reset: ()=>{\\n           return num = init;\\n       },\\n         decrement: ()=>{\\n           return --num;\\n       },\\n         \\n   } \\n};\\n\\n\\n  const counter = createCounter(5)\\n counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916350,
                "title": "easy-javascript-solution",
                "content": "> If you like vote up\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let i=init;\\n    function increment(){\\n        i++\\n        return i;\\n    }\\n    function reset(){\\n        i=init\\n        return init\\n    }\\n    function decrement(){\\n        i--\\n        return i\\n    }\\n    return {\"increment\":increment,\"reset\":reset,\"decrement\":decrement}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let i=init;\\n    function increment(){\\n        i++\\n        return i;\\n    }\\n    function reset(){\\n        i=init\\n        return init\\n    }\\n    function decrement(){\\n        i--\\n        return i\\n    }\\n    return {\"increment\":increment,\"reset\":reset,\"decrement\":decrement}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1882561,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885855,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886327,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2037503,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886326,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886103,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885727,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2069468,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2024731,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2003921,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1882561,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885855,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886327,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2037503,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886326,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886103,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885727,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2069468,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2024731,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2003921,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1989045,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1984897,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1976245,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1966499,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1936923,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1915150,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1912508,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1886460,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1886012,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1885922,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            }
        ]
    },
    {
        "title": "Array of Objects to Matrix",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1902848,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903293,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903150,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1891351,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902985,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903197,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903309,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902757,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902979,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1905253,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902848,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903293,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903150,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1891351,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902985,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903197,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903309,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902757,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902979,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1905253,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count the Number of Complete Components",
        "question_content": "<p>You are given an integer <code>n</code>. There is an <strong>undirected</strong> graph with <code>n</code> vertices, numbered from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>\n\n<p>Return <em>the number of <strong>complete connected components</strong> of the graph</em>.</p>\n\n<p>A <strong>connected component</strong> is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.</p>\n\n<p>A connected component is said to be <b>complete</b> if there exists an edge between every pair of its vertices.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong class=\"example\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-31-23.png\" style=\"width: 671px; height: 270px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> From the picture above, one can see that all of the components of this graph are complete.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong class=\"example\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-32-00.png\" style=\"width: 671px; height: 270px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>There are no repeated edges.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3521922,
                "title": "dfs-to-count-the-number-of-nodes-and-edges",
                "content": "# Intuition\\nDFS\\n\\n# Approach\\nDFS\\n\\n# Complexity\\n- Time complexity:\\nO(n + m)\\n\\n- Space complexity:\\nO(n + m)\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int x, const vector<vector<int>> &con, vector<bool> &mark, int &a, int &b) {\\n        if (mark[x]) {\\n            return;\\n        }\\n        mark[x] = true;\\n        ++a;\\n        b += con[x].size();\\n        for (int y : con[x]) {\\n            dfs(y, con, mark, a, b);\\n        }\\n    }\\n    \\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> con(n);\\n        for (const auto& e : edges) {\\n            con[e[0]].push_back(e[1]);\\n            con[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> mark(n);\\n        int r = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (!mark[i]) {\\n                int x = 0, y = 0;\\n                dfs(i, con, mark, x, y);\\n                r += x * (x - 1) == y;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int x, const vector<vector<int>> &con, vector<bool> &mark, int &a, int &b) {\\n        if (mark[x]) {\\n            return;\\n        }\\n        mark[x] = true;\\n        ++a;\\n        b += con[x].size();\\n        for (int y : con[x]) {\\n            dfs(y, con, mark, a, b);\\n        }\\n    }\\n    \\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> con(n);\\n        for (const auto& e : edges) {\\n            con[e[0]].push_back(e[1]);\\n            con[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> mark(n);\\n        int r = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (!mark[i]) {\\n                int x = 0, y = 0;\\n                dfs(i, con, mark, x, y);\\n                r += x * (x - 1) == y;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521887,
                "title": "explained-dsu-very-simple-easy-to-understand",
                "content": "<b>Up vote if you like the solution</b>\\n\\n# Approach \\n1. Using DSU find the connected component \\n2. While finding the connected component, keep tracking the number of edges &\\n    number of nodes associated with the connected component\\n3. At the end check if the a connected component with N node has N*(N-1)/2 number of \\n    edges, then increament ans.\\n    \\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> par, edgeCount, nodeCount;\\n    int find(int i){\\n        if(par[i] == -1) return i;\\n        return find(par[i]);\\n    }\\n    \\n    void unionPair(int a, int b ){\\n        int pa = find(a), pb = find(b);\\n        edgeCount[pa] += 1;\\n        if(pa != pb){\\n            par[pb] = pa;\\n            edgeCount[pa] += edgeCount[pb];\\n            nodeCount[pa] += nodeCount[pb];\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        par.resize(n, -1);   edgeCount.resize(n, 0);    nodeCount.resize(n, 1);\\n        for(auto e: edges) unionPair(e[0], e[1]);\\n        for(int i = 0; i < n; ++i){\\n            if(nodeCount[i] && par[i] == -1  && ( nodeCount[i] * (nodeCount[i] - 1)/2 == edgeCount[i] ) ) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> par, edgeCount, nodeCount;\\n    int find(int i){\\n        if(par[i] == -1) return i;\\n        return find(par[i]);\\n    }\\n    \\n    void unionPair(int a, int b ){\\n        int pa = find(a), pb = find(b);\\n        edgeCount[pa] += 1;\\n        if(pa != pb){\\n            par[pb] = pa;\\n            edgeCount[pa] += edgeCount[pb];\\n            nodeCount[pa] += nodeCount[pb];\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        par.resize(n, -1);   edgeCount.resize(n, 0);    nodeCount.resize(n, 1);\\n        for(auto e: edges) unionPair(e[0], e[1]);\\n        for(int i = 0; i < n; ++i){\\n            if(nodeCount[i] && par[i] == -1  && ( nodeCount[i] * (nodeCount[i] - 1)/2 == edgeCount[i] ) ) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521885,
                "title": "cpp-dfs",
                "content": "### Intuition\\nCount number of connected nodes and connecting edges and use `nodes*(nodes - 1) == connectingEdges`\\n\\n### TIme Complexity : `O(n)`\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int currNode,vector<bool> &vis,int &nodeCount,int &edgeCount) {\\n        vis[currNode] = true;\\n        nodeCount += 1;\\n        edgeCount += graph[currNode].size();\\n        for(int nextNode : graph[currNode]) {\\n            if(!vis[nextNode]) {\\n                dfs(graph,nextNode,vis,nodeCount,edgeCount);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for(vector<int> &edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int ans = 0;\\n        vector<bool> vis(n);\\n        for(int i = 0; i < n; i += 1) {\\n            int nodeCount = 0,edgeCount = 0;\\n            if(!vis[i]) {\\n                dfs(graph,i,vis,nodeCount,edgeCount);\\n                if(nodeCount*(nodeCount - 1) == edgeCount) ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int currNode,vector<bool> &vis,int &nodeCount,int &edgeCount) {\\n        vis[currNode] = true;\\n        nodeCount += 1;\\n        edgeCount += graph[currNode].size();\\n        for(int nextNode : graph[currNode]) {\\n            if(!vis[nextNode]) {\\n                dfs(graph,nextNode,vis,nodeCount,edgeCount);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for(vector<int> &edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int ans = 0;\\n        vector<bool> vis(n);\\n        for(int i = 0; i < n; i += 1) {\\n            int nodeCount = 0,edgeCount = 0;\\n            if(!vis[i]) {\\n                dfs(graph,i,vis,nodeCount,edgeCount);\\n                if(nodeCount*(nodeCount - 1) == edgeCount) ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521878,
                "title": "c-java-python3-union-find-with-count",
                "content": "\\n# Intuition\\nUsing union find we can find all components. If the size of the component that `x` is a part of is not equal to number of edges connected to `x` + 1, the component is not complete. \\n\\n# Approach\\n* Use union find to find all the components first\\n* In the `DSU` class we add a method called `size_of_group_that_x_is_a_part_of`. This will return the size of the groupd that x is part of. The number of edges connected to x must be one less than this.\\n* Use a counter to count edges connected to each node\\n* Use a set `groups` to find the number of unique groups/components in the graph. \\n* Then just find the `size_of_group_that_x_is_a_part_of` and make sure that the number of edges connected to `x` is one less than this. If it is not the group/component x is a part of is not complete.\\n\\n# Complexity\\n- Time complexity: O(max(n, len(edges)))\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python3**:\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n))\\n        self.rank = [0] * n\\n        self.count = [1] * n\\n    def find(self, x):\\n        if x != self.p[x]:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    def union(self, x, y):\\n        xx, yy = self.find(x), self.find(y)\\n        if xx == yy: return\\n        self.count[xx] = self.count[yy] = self.count[xx] + self.count[yy]\\n        if self.rank[xx] < self.rank[yy]: self.p[xx] = yy\\n        else: self.p[yy] = xx\\n        if self.rank[xx] == self.rank[yy]: self.rank[xx] += 1\\n    def size_of_group_that_x_is_a_part_of(self, x):\\n        return self.count[self.find(x)]\\n\\nclass Solution:\\n    def countCompleteComponents(self, n, edges):\\n        uf, counter = DSU(n), Counter()\\n        for x, y in edges: \\n            uf.union(x, y)\\n            counter[x] += 1\\n            counter[y] += 1\\n\\n        groups = set(uf.find(i) for i in range(n))\\n\\n        for i in range(n):\\n            if uf.size_of_group_that_x_is_a_part_of(i) != counter[i] + 1:\\n                groups.discard(uf.find(i))\\n\\n        return len(groups)\\n```\\n\\n**C++**:\\n```\\nclass DSU {\\nprivate:\\n    vector<int> p, rank, count;\\npublic:\\n    DSU(int n) {\\n        p.resize(n), rank.resize(n), count.resize(n, 1);\\n        for (int i = 0; i < n; ++i) p[i] = i;\\n    }\\n    int find(int x) {\\n        if (x != p[x]) p[x] = find(p[x]);\\n        return p[x];\\n    }\\n    void union_set(int x, int y) {\\n        int xx = find(x), yy = find(y);\\n        if (xx == yy) return;\\n        count[xx] = count[yy] = count[xx] + count[yy];\\n        if (rank[xx] < rank[yy]) p[xx] = yy;\\n        else p[yy] = xx;\\n        if (rank[xx] == rank[yy]) ++rank[xx];\\n    }\\n    int sizeOfGroupThatXIsAPartOf(int x) {\\n        return count[find(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU uf(n);\\n        set<int> groups;\\n        vector<int> counter(n, 0);\\n        for (auto& e : edges) {\\n            uf.union_set(e[0], e[1]);\\n            ++counter[e[0]], ++counter[e[1]];\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n            groups.insert(uf.find(i));\\n\\n        for (int i = 0; i < n; ++i)\\n            if (uf.sizeOfGroupThatXIsAPartOf(i) != counter[i] + 1) \\n                groups.erase(uf.find(i));\\n\\n        return groups.size();\\n    }\\n};\\n\\n```\\n\\n**Java**:\\n```\\npublic class DSU {\\n    private int[] p, rank, count;\\n\\n    public DSU(int n) {\\n        p = new int[n];\\n        rank = new int[n];\\n        count = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            p[i] = i;\\n            count[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (x != p[x])\\n            p[x] = find(p[x]);\\n        return p[x];\\n    }\\n\\n    public void unionSet(int x, int y) {\\n        int xx = find(x), yy = find(y);\\n        if (xx == yy) return;\\n        count[xx] = count[yy] = count[xx] + count[yy];\\n        if (rank[xx] < rank[yy]) p[xx] = yy;\\n        else p[yy] = xx;\\n        if (rank[xx] == rank[yy]) rank[xx]++;\\n    }\\n\\n    public int sizeOfGroupThatXIsAPartOf(int x) {\\n        return count[find(x)];\\n    }\\n}\\n\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        DSU uf = new DSU(n);\\n        Set<Integer> groups = new HashSet<>();\\n        int[] counter = new int[n];\\n        for (int[] e : edges) {\\n            uf.unionSet(e[0], e[1]);\\n            counter[e[0]]++; counter[e[1]]++;\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n            groups.add(uf.find(i));\\n\\n        for (int i = 0; i < n; i++)\\n            if (uf.sizeOfGroupThatXIsAPartOf(i) != counter[i] + 1)\\n                groups.remove(uf.find(i));\\n\\n        return groups.size();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n))\\n        self.rank = [0] * n\\n        self.count = [1] * n\\n    def find(self, x):\\n        if x != self.p[x]:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    def union(self, x, y):\\n        xx, yy = self.find(x), self.find(y)\\n        if xx == yy: return\\n        self.count[xx] = self.count[yy] = self.count[xx] + self.count[yy]\\n        if self.rank[xx] < self.rank[yy]: self.p[xx] = yy\\n        else: self.p[yy] = xx\\n        if self.rank[xx] == self.rank[yy]: self.rank[xx] += 1\\n    def size_of_group_that_x_is_a_part_of(self, x):\\n        return self.count[self.find(x)]\\n\\nclass Solution:\\n    def countCompleteComponents(self, n, edges):\\n        uf, counter = DSU(n), Counter()\\n        for x, y in edges: \\n            uf.union(x, y)\\n            counter[x] += 1\\n            counter[y] += 1\\n\\n        groups = set(uf.find(i) for i in range(n))\\n\\n        for i in range(n):\\n            if uf.size_of_group_that_x_is_a_part_of(i) != counter[i] + 1:\\n                groups.discard(uf.find(i))\\n\\n        return len(groups)\\n```\n```\\nclass DSU {\\nprivate:\\n    vector<int> p, rank, count;\\npublic:\\n    DSU(int n) {\\n        p.resize(n), rank.resize(n), count.resize(n, 1);\\n        for (int i = 0; i < n; ++i) p[i] = i;\\n    }\\n    int find(int x) {\\n        if (x != p[x]) p[x] = find(p[x]);\\n        return p[x];\\n    }\\n    void union_set(int x, int y) {\\n        int xx = find(x), yy = find(y);\\n        if (xx == yy) return;\\n        count[xx] = count[yy] = count[xx] + count[yy];\\n        if (rank[xx] < rank[yy]) p[xx] = yy;\\n        else p[yy] = xx;\\n        if (rank[xx] == rank[yy]) ++rank[xx];\\n    }\\n    int sizeOfGroupThatXIsAPartOf(int x) {\\n        return count[find(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU uf(n);\\n        set<int> groups;\\n        vector<int> counter(n, 0);\\n        for (auto& e : edges) {\\n            uf.union_set(e[0], e[1]);\\n            ++counter[e[0]], ++counter[e[1]];\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n            groups.insert(uf.find(i));\\n\\n        for (int i = 0; i < n; ++i)\\n            if (uf.sizeOfGroupThatXIsAPartOf(i) != counter[i] + 1) \\n                groups.erase(uf.find(i));\\n\\n        return groups.size();\\n    }\\n};\\n\\n```\n```\\npublic class DSU {\\n    private int[] p, rank, count;\\n\\n    public DSU(int n) {\\n        p = new int[n];\\n        rank = new int[n];\\n        count = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            p[i] = i;\\n            count[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (x != p[x])\\n            p[x] = find(p[x]);\\n        return p[x];\\n    }\\n\\n    public void unionSet(int x, int y) {\\n        int xx = find(x), yy = find(y);\\n        if (xx == yy) return;\\n        count[xx] = count[yy] = count[xx] + count[yy];\\n        if (rank[xx] < rank[yy]) p[xx] = yy;\\n        else p[yy] = xx;\\n        if (rank[xx] == rank[yy]) rank[xx]++;\\n    }\\n\\n    public int sizeOfGroupThatXIsAPartOf(int x) {\\n        return count[find(x)];\\n    }\\n}\\n\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        DSU uf = new DSU(n);\\n        Set<Integer> groups = new HashSet<>();\\n        int[] counter = new int[n];\\n        for (int[] e : edges) {\\n            uf.unionSet(e[0], e[1]);\\n            counter[e[0]]++; counter[e[1]]++;\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n            groups.add(uf.find(i));\\n\\n        for (int i = 0; i < n; i++)\\n            if (uf.sizeOfGroupThatXIsAPartOf(i) != counter[i] + 1)\\n                groups.remove(uf.find(i));\\n\\n        return groups.size();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522091,
                "title": "python-bfs-solution",
                "content": "# **Explanation**\\nBFS node `i` and find out all it\\'s connected nodes.\\nCheck the number of edgesd for each connnected nodes.\\n<br>\\n\\n# **Complexity**\\nTime `O(edges)`\\nSpace `O(edges)`\\n<br>\\n\\n**Python**\\n```py\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        G = [[] for i in range(n)]\\n        for i,j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        seen = [0] * n\\n\\n        res = 0\\n        for i in range(n):\\n            if seen[i]: continue\\n            bfs = [i]\\n            seen[i] = 1\\n            for j in bfs:\\n                for k in G[j]:\\n                    if seen[k] == 0:\\n                        bfs.append(k)\\n                        seen[k] = 1\\n            if all(len(G[j]) == len(bfs) - 1 for j in bfs):\\n                res += 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        G = [[] for i in range(n)]\\n        for i,j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        seen = [0] * n\\n\\n        res = 0\\n        for i in range(n):\\n            if seen[i]: continue\\n            bfs = [i]\\n            seen[i] = 1\\n            for j in bfs:\\n                for k in G[j]:\\n                    if seen[k] == 0:\\n                        bfs.append(k)\\n                        seen[k] = 1\\n            if all(len(G[j]) == len(bfs) - 1 for j in bfs):\\n                res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3522591,
                "title": "using-dsu-java-solution",
                "content": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int parent[]=new int[n];\\n        int size[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            size[i]=1;\\n           \\n        }\\n        for(int p[]:edges){\\n            int u=p[0];\\n            int v=p[1];\\n            int u1=findPar(u,parent);\\n            int v1=findPar(v,parent);\\n            if(u1!=v1)union(u1,v1,size,parent);\\n        }\\n        int z=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i){\\n              int z1=size[i];\\n                //checking for complete graph\\n                if(bfs(i,edges,parent)==(z1*(z1-1)/2)){\\n                    z++;\\n                }\\n            }\\n        }\\n        return z;\\n    }\\n    //finding ultimate parent\\n    public int findPar(int node,int parent[]){\\n        if(node==parent[node])return node;\\n        return parent[node]=findPar(parent[node],parent);\\n    }\\n    //union by size\\n    public void union(int u,int v,int size[],int parent[]){\\n        if(size[u]<size[v]){\\n            parent[u]=v;\\n            size[v]+=size[u];\\n        }\\n        else{\\n            parent[v]=u;\\n            size[u]+=size[v];\\n        }\\n    }\\n    //counting no of edges in a connected component\\n    public int bfs(int n,int edges[][],int parent[]){\\n        int c1=0;\\n        for(int p[]:edges){\\n            int u=p[0];\\n            int v=p[1];\\n            if(findPar(u,parent)==findPar(v,parent) && findPar(u,parent)==n)c1++;\\n        }\\n        return c1;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int parent[]=new int[n];\\n        int size[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            size[i]=1;\\n           \\n        }\\n        for(int p[]:edges){\\n            int u=p[0];\\n            int v=p[1];\\n            int u1=findPar(u,parent);\\n            int v1=findPar(v,parent);\\n            if(u1!=v1)union(u1,v1,size,parent);\\n        }\\n        int z=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i){\\n              int z1=size[i];\\n                //checking for complete graph\\n                if(bfs(i,edges,parent)==(z1*(z1-1)/2)){\\n                    z++;\\n                }\\n            }\\n        }\\n        return z;\\n    }\\n    //finding ultimate parent\\n    public int findPar(int node,int parent[]){\\n        if(node==parent[node])return node;\\n        return parent[node]=findPar(parent[node],parent);\\n    }\\n    //union by size\\n    public void union(int u,int v,int size[],int parent[]){\\n        if(size[u]<size[v]){\\n            parent[u]=v;\\n            size[v]+=size[u];\\n        }\\n        else{\\n            parent[v]=u;\\n            size[u]+=size[v];\\n        }\\n    }\\n    //counting no of edges in a connected component\\n    public int bfs(int n,int edges[][],int parent[]){\\n        int c1=0;\\n        for(int p[]:edges){\\n            int u=p[0];\\n            int v=p[1];\\n            if(findPar(u,parent)==findPar(v,parent) && findPar(u,parent)==n)c1++;\\n        }\\n        return c1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522369,
                "title": "python3-clean-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        \\n        \\n        adj=defaultdict(list)\\n        \\n        for a,b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        \\n        \\n        def dfs(i):\\n            \\n            component.add(i)\\n            for child in adj[i]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    dfs(child)\\n        \\n        \\n        ans=0\\n        visited=set()\\n        \\n        for i in range(n):\\n            if i not in visited:\\n                component=set()\\n                visited.add(i)\\n                dfs(i)\\n                if all(len(adj[node]) == len(component)-1 for node in component):\\n                    ans+=1\\n                    \\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        \\n        \\n        adj=defaultdict(list)\\n        \\n        for a,b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        \\n        \\n        def dfs(i):\\n            \\n            component.add(i)\\n            for child in adj[i]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    dfs(child)\\n        \\n        \\n        ans=0\\n        visited=set()\\n        \\n        for i in range(n):\\n            if i not in visited:\\n                component=set()\\n                visited.add(i)\\n                dfs(i)\\n                if all(len(adj[node]) == len(component)-1 for node in component):\\n                    ans+=1\\n                    \\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522744,
                "title": "no-union-find-no-dfs-no-bfs-just-simple-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor Complete Components, each node has an edge to all its adjancent node, e.g., if we regard the node itself as an \"adjancent node\", all those node has the same adjancent node list.\\n\\nFor example, for node 0,1,2,3. If it is an complete component, we have adjancency matrix as:\\n0 -> 0,1,2,3\\n1 -> 0,1,2,3\\n2 -> 0,1,2,3\\n3 -> 0,1,2,3\\n\\nWe could first find the adjancency matrix, then count the values. If the occurance of a value is the same as the length of the adjancency list, it is a complete component.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        adj2 = {}\\n        for e1, e2 in edges:\\n            adj[e1].append(e2)\\n            adj[e2].append(e1)\\n        for i in range(n):\\n            # add the node itself\\n            adj[i].append(i)\\n            adj[i].sort()\\n            adj2[i] = tuple(adj[i])\\n        \\n        res = 0\\n        for k, v in Counter(adj2.values()).items():\\n            res += 1 if len(k) == v else 0\\n        \\n        return res\\n        \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        adj2 = {}\\n        for e1, e2 in edges:\\n            adj[e1].append(e2)\\n            adj[e2].append(e1)\\n        for i in range(n):\\n            # add the node itself\\n            adj[i].append(i)\\n            adj[i].sort()\\n            adj2[i] = tuple(adj[i])\\n        \\n        res = 0\\n        for k, v in Counter(adj2.values()).items():\\n            res += 1 if len(k) == v else 0\\n        \\n        return res\\n        \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522363,
                "title": "dfs",
                "content": "For some reason, this problem was easier for me than all other problems in the contest.\\n\\nI initially got excited because I though it\\'s the famous clique problem. Clique is a fully-connected subgraph, not an isolated component.\\n\\n> The limit `n <= 50` is confusing as it implies that the expected solution is harder than quadratic. \\n\\nWe run DFS to identify all connected nodes in a subgraph.\\n\\nIf we have a subgraph with `m` nodes, it is connected if all `m` nodes have `m - 1` edges.\\n\\n**C++**\\n```cpp\\nvoid dfs(int i, vector<vector<int>> &al, unordered_set<int> &s) {\\n    if (s.insert(i).second)\\n        for (int j : al[i])\\n            dfs(j, al, s);\\n}\\nint countCompleteComponents(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(n);\\n    int res = 0;\\n    for (const auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    unordered_set<int> ms;\\n    for (int i = 0; i < n; ++i) {\\n        if (ms.count(i) == 0) {\\n            unordered_set<int> s;\\n            dfs(i, al, s);\\n            res += all_of(begin(s), end(s), [&](int i){ return al[i].size() == s.size() - 1; });\\n            ms.insert(begin(s), end(s));\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvoid dfs(int i, vector<vector<int>> &al, unordered_set<int> &s) {\\n    if (s.insert(i).second)\\n        for (int j : al[i])\\n            dfs(j, al, s);\\n}\\nint countCompleteComponents(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(n);\\n    int res = 0;\\n    for (const auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    unordered_set<int> ms;\\n    for (int i = 0; i < n; ++i) {\\n        if (ms.count(i) == 0) {\\n            unordered_set<int> s;\\n            dfs(i, al, s);\\n            res += all_of(begin(s), end(s), [&](int i){ return al[i].size() == s.size() - 1; });\\n            ms.insert(begin(s), end(s));\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526270,
                "title": "c-dfs-clean-codes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid dfs(int node, vector<int> &vis, vector<int> adj[], int &nodes, int &edges){\\n    vis[node]=1;\\n    nodes++;\\n    edges+=adj[node].size();\\n    for(auto x:adj[node]){\\n        if(!vis[x]){\\n            dfs(x,vis,adj,nodes,edges);\\n        } \\n    }\\n}\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        if(edges.size()==0) return n;\\n        int components=0;\\n        vector<int> vis(n,0);\\n        vector<int> adj[n];\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int errors=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                components++;\\n                int nodes=0;\\n                int edges=0;\\n                dfs(i,vis,adj,nodes,edges);\\n                if(edges!=(nodes*(nodes-1))) errors++;\\n            }\\n        }\\n        return components-errors;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid dfs(int node, vector<int> &vis, vector<int> adj[], int &nodes, int &edges){\\n    vis[node]=1;\\n    nodes++;\\n    edges+=adj[node].size();\\n    for(auto x:adj[node]){\\n        if(!vis[x]){\\n            dfs(x,vis,adj,nodes,edges);\\n        } \\n    }\\n}\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        if(edges.size()==0) return n;\\n        int components=0;\\n        vector<int> vis(n,0);\\n        vector<int> adj[n];\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int errors=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                components++;\\n                int nodes=0;\\n                int edges=0;\\n                dfs(i,vis,adj,nodes,edges);\\n                if(edges!=(nodes*(nodes-1))) errors++;\\n            }\\n        }\\n        return components-errors;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538690,
                "title": "python-3-6-lines-counter-t-m-91-97",
                "content": "Here\\'s the intuition:\\n\\n*Fig 1* shows a connected component with four nodes. It should be clear that each node has edges to all the other three nodes if and only if this connected component is complete.\\n![Untitled 5.jpg](https://assets.leetcode.com/users/images/7035cecd-26bc-4ded-9fd1-101e7841c838_1684424734.1980107.jpeg)\\n\\nIt should also be clear that if we add \"self-edges\" (*Fig 2*), then each node has the edge list [0,1,2,3] if and only if this connected component is complete.\\n\\nHere\\'s the plan:\\n\\n1. We initialize the graph dict`g`with the self-edges.\\n2. We build the graph.\\n2. We sort the lists, convert to tuples (to be hashable), and build a`Counter` with the tuples of edges as keys.\\n3. It follows directly from above that for each`edgeList`for which `len(edgeList) == vals[edgeList]` is true, there exists a complete connected component, so we count those occurrences and return that count as the answer. \\n\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        g = {i:[i] for i in range(n)}               # <-- 1)\\n        ans, conv = 0, lambda x: tuple(sorted(x))\\n\\n        for a, b in edges:                          # <-- 2)\\n            g[a].append(b) ; g[b].append(a)         #\\n\\n        vals = Counter(map(conv, g.values()))       # <-- 3)\\n        \\n        return sum(len(edgeList) == vals[edgeList]  # <-- 4)\\n                            for edgeList in vals)   #\\n```\\n[https://leetcode.com/problems/count-the-number-of-complete-components/submissions/952760551/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*+*E*) and space complexity is *O*(*N*), in which *N* ~ count of nodes and *E* ~ count of edges.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        g = {i:[i] for i in range(n)}               # <-- 1)\\n        ans, conv = 0, lambda x: tuple(sorted(x))\\n\\n        for a, b in edges:                          # <-- 2)\\n            g[a].append(b) ; g[b].append(a)         #\\n\\n        vals = Counter(map(conv, g.values()))       # <-- 3)\\n        \\n        return sum(len(edgeList) == vals[edgeList]  # <-- 4)\\n                            for edgeList in vals)   #\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522019,
                "title": "java-dfs-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + edges.length)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<Integer>[] adj;\\n  boolean[] seen;\\n  int cnt = -1;\\n  int nodes = 0;\\n  \\n  private boolean helper(int i) {\\n    seen[i] = true;\\n    nodes++;\\n    var edges = 0;\\n    var ret = true;\\n    \\n    for (var neighbor : adj[i]) {\\n      edges++;\\n      \\n      if (!seen[neighbor])\\n        ret &= helper(neighbor);\\n    }\\n    if (cnt == -1) cnt = edges;\\n    return cnt == edges && ret;\\n  }\\n  \\n  public int countCompleteComponents(int n, int[][] edges) {\\n    adj = new ArrayList[n];\\n    \\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n    \\n    for (var e : edges) {\\n      adj[e[0]].add(e[1]);\\n      adj[e[1]].add(e[0]);\\n    }\\n    seen = new boolean[n];\\n    var ans = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (!seen[i]) {\\n        cnt = -1;\\n        nodes = 0;\\n        \\n        if (helper(i) && cnt == nodes-1) ans++;\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n  List<Integer>[] adj;\\n  boolean[] seen;\\n  int cnt = -1;\\n  int nodes = 0;\\n  \\n  private boolean helper(int i) {\\n    seen[i] = true;\\n    nodes++;\\n    var edges = 0;\\n    var ret = true;\\n    \\n    for (var neighbor : adj[i]) {\\n      edges++;\\n      \\n      if (!seen[neighbor])\\n        ret &= helper(neighbor);\\n    }\\n    if (cnt == -1) cnt = edges;\\n    return cnt == edges && ret;\\n  }\\n  \\n  public int countCompleteComponents(int n, int[][] edges) {\\n    adj = new ArrayList[n];\\n    \\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n    \\n    for (var e : edges) {\\n      adj[e[0]].add(e[1]);\\n      adj[e[1]].add(e[0]);\\n    }\\n    seen = new boolean[n];\\n    var ans = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (!seen[i]) {\\n        cnt = -1;\\n        nodes = 0;\\n        \\n        if (helper(i) && cnt == nodes-1) ans++;\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521967,
                "title": "connected-components-with-hashset",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n        for(int[] edge : edges)\\n        {\\n            int x = edge[0], y = edge[1];\\n            graph[x].add(y);\\n            graph[y].add(x);\\n        }\\n        \\n        boolean[] vis = new boolean[n];\\n        int ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                HashSet<Integer> set = new HashSet<>();\\n                int count = dfs(i, vis, graph, set);\\n                if(set.size() == 1 && set.contains(count - 1))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int dfs(int src, boolean[] vis, ArrayList<Integer>[] graph, HashSet<Integer> set)\\n    {\\n        vis[src] = true;\\n        set.add(graph[src].size());\\n        int ans = 1;\\n        for(int nbr : graph[src])\\n        {\\n            if(!vis[nbr])\\n            {\\n                ans+= dfs(nbr, vis, graph, set);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n        for(int[] edge : edges)\\n        {\\n            int x = edge[0], y = edge[1];\\n            graph[x].add(y);\\n            graph[y].add(x);\\n        }\\n        \\n        boolean[] vis = new boolean[n];\\n        int ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                HashSet<Integer> set = new HashSet<>();\\n                int count = dfs(i, vis, graph, set);\\n                if(set.size() == 1 && set.contains(count - 1))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int dfs(int src, boolean[] vis, ArrayList<Integer>[] graph, HashSet<Integer> set)\\n    {\\n        vis[src] = true;\\n        set.add(graph[src].size());\\n        int ans = 1;\\n        for(int nbr : graph[src])\\n        {\\n            if(!vis[nbr])\\n            {\\n                ans+= dfs(nbr, vis, graph, set);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522514,
                "title": "java-simple-bfs-then-count-neighs-of-each-node",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1, build graph to store all neighbors of each node, by loop the edge.\\n2, Do BFS and check for each islands, res++ if complete.\\n3, Check if complete is simple, iff each node\\'s cnt of neighbors are CntOfNodesInIsland - 1;\\n# Code\\n```\\nclass Solution {\\n    Set<Integer> vis = new HashSet<>();\\n    Map<Integer, Set<Integer>> nodes;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //build graph to store all neighbors of each node, by loop the edge.\\n        nodes = buidGraph(edges);\\n        //Do BFS and check for each islands, res++ if complete.\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (vis.contains(i)) continue;\\n            if (bfs(i)) result++;\\n        }\\n        return result;\\n    }\\n\\n    private Map<Integer, Set<Integer>> buidGraph(int[][] edges) {\\n        Map<Integer, Set<Integer>> nodes = new HashMap<>();\\n        for (int[] e : edges) {\\n            nodes.putIfAbsent(e[0], new HashSet<>());\\n            nodes.putIfAbsent(e[1], new HashSet<>());\\n            nodes.get(e[0]).add(e[1]);\\n            nodes.get(e[1]).add(e[0]);\\n        }\\n        return nodes;\\n    }\\n\\n    private boolean bfs(int i) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(i);\\n        vis.add(i);\\n        int cntOfNeighs = nodes.getOrDefault(i, new HashSet<>()).size(), numOfNodes = 0;\\n        boolean result = true;\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();\\n            numOfNodes++;\\n            if (nodes.getOrDefault(curr, new HashSet<>()).size() != cntOfNeighs) result = false;\\n            for (int neig : nodes.getOrDefault(curr, new HashSet<>())) {\\n                if (vis.contains(neig)) continue;\\n                vis.add(neig);\\n                q.offer(neig);\\n            }\\n        }\\n        return result && cntOfNeighs == numOfNodes - 1;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Set<Integer> vis = new HashSet<>();\\n    Map<Integer, Set<Integer>> nodes;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //build graph to store all neighbors of each node, by loop the edge.\\n        nodes = buidGraph(edges);\\n        //Do BFS and check for each islands, res++ if complete.\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (vis.contains(i)) continue;\\n            if (bfs(i)) result++;\\n        }\\n        return result;\\n    }\\n\\n    private Map<Integer, Set<Integer>> buidGraph(int[][] edges) {\\n        Map<Integer, Set<Integer>> nodes = new HashMap<>();\\n        for (int[] e : edges) {\\n            nodes.putIfAbsent(e[0], new HashSet<>());\\n            nodes.putIfAbsent(e[1], new HashSet<>());\\n            nodes.get(e[0]).add(e[1]);\\n            nodes.get(e[1]).add(e[0]);\\n        }\\n        return nodes;\\n    }\\n\\n    private boolean bfs(int i) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(i);\\n        vis.add(i);\\n        int cntOfNeighs = nodes.getOrDefault(i, new HashSet<>()).size(), numOfNodes = 0;\\n        boolean result = true;\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();\\n            numOfNodes++;\\n            if (nodes.getOrDefault(curr, new HashSet<>()).size() != cntOfNeighs) result = false;\\n            for (int neig : nodes.getOrDefault(curr, new HashSet<>())) {\\n                if (vis.contains(neig)) continue;\\n                vis.add(neig);\\n                q.offer(neig);\\n            }\\n        }\\n        return result && cntOfNeighs == numOfNodes - 1;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522172,
                "title": "python-3-simple-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf a Group of N vertices are connected, it will be a complete connected if number of edges is equal: $$1 + 2 + ... + N - 1 = (N - 1) * N / 2$$. Thus we have to find connected components - Union Find. Find find whether the edges in this connected component equal to $$(N - 1) * N / 2$$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n    \\n    def __init__(self, n: int):\\n        self.root = list(range(n))\\n        self.rank = [1 for _ in range(n)]\\n        self.edges = [0 for _ in range(n)]\\n        self.group = [1 for _ in range(n)]\\n        \\n    def find(self, x: int) -> int:\\n        if x != self.root[x]: self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x == root_y:\\n            self.edges[root_x] += 1\\n            return\\n        if self.rank[root_x] > self.rank[root_y]:\\n            self.root[root_y] = root_x\\n            self.edges[root_x] += self.edges[root_y] + 1\\n            self.group[root_x] += self.group[root_y]\\n        elif self.rank[root_x] < self.rank[root_y]:\\n            self.root[root_x] = root_y\\n            self.edges[root_y] += self.edges[root_x] + 1\\n            self.group[root_y] += self.group[root_x]\\n        else:\\n            self.root[root_y] = root_x\\n            self.rank[root_x] += 1\\n            self.edges[root_x] += self.edges[root_y] + 1\\n            self.group[root_x] += self.group[root_y]\\n    \\n    def are_connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n            \\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        uf = UnionFind(n)\\n        g = collections.defaultdict(set)\\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)\\n            uf.union(u, v)\\n        for i in range(n):\\n            uf.find(i)\\n        \\n        s = set(uf.root)\\n        res = 0\\n        for x in s:\\n            v = uf.group[x]\\n            if uf.edges[x] == (v - 1) * v // 2: res += 1\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass UnionFind:\\n    \\n    def __init__(self, n: int):\\n        self.root = list(range(n))\\n        self.rank = [1 for _ in range(n)]\\n        self.edges = [0 for _ in range(n)]\\n        self.group = [1 for _ in range(n)]\\n        \\n    def find(self, x: int) -> int:\\n        if x != self.root[x]: self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x == root_y:\\n            self.edges[root_x] += 1\\n            return\\n        if self.rank[root_x] > self.rank[root_y]:\\n            self.root[root_y] = root_x\\n            self.edges[root_x] += self.edges[root_y] + 1\\n            self.group[root_x] += self.group[root_y]\\n        elif self.rank[root_x] < self.rank[root_y]:\\n            self.root[root_x] = root_y\\n            self.edges[root_y] += self.edges[root_x] + 1\\n            self.group[root_y] += self.group[root_x]\\n        else:\\n            self.root[root_y] = root_x\\n            self.rank[root_x] += 1\\n            self.edges[root_x] += self.edges[root_y] + 1\\n            self.group[root_x] += self.group[root_y]\\n    \\n    def are_connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n            \\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        uf = UnionFind(n)\\n        g = collections.defaultdict(set)\\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)\\n            uf.union(u, v)\\n        for i in range(n):\\n            uf.find(i)\\n        \\n        s = set(uf.root)\\n        res = 0\\n        for x in s:\\n            v = uf.group[x]\\n            if uf.edges[x] == (v - 1) * v // 2: res += 1\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521888,
                "title": "n-n-1-2",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int e=0,v=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for (int[] edge: edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                dfs(visited, i, adj);\\n                e/=2;\\n                if(e==(v*(v-1))/2)count++;\\n            }\\n            e=v=0;\\n        }\\n        return count;\\n    }\\n    \\n     private void dfs(boolean[] visited, int from, List<List<Integer>> adj) {\\n        visited[from] = true;\\n        v++;\\n        for (int to : adj.get(from)) {\\n            e++;\\n            if (!visited[to]) {\\n                dfs(visited, to, adj);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int e=0,v=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for (int[] edge: edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                dfs(visited, i, adj);\\n                e/=2;\\n                if(e==(v*(v-1))/2)count++;\\n            }\\n            e=v=0;\\n        }\\n        return count;\\n    }\\n    \\n     private void dfs(boolean[] visited, int from, List<List<Integer>> adj) {\\n        visited[from] = true;\\n        v++;\\n        for (int to : adj.get(from)) {\\n            e++;\\n            if (!visited[to]) {\\n                dfs(visited, to, adj);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760467,
                "title": "bfs-complete-graph-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is completely similar to **\"Calculating connected components of an undirected graph\".** But the difference is that here we will **counting only fully connected components**.\\n\\n**Completely Connected Components:-** A connected component is said to be complete if there exists an edge between every pair of its vertices.\\n\\n**Note:-**\\n**Mathematical term for complete graph:-**\\nIf number of nodes in the graph = **n** and number of edges = **m**\\n               **`m = n*(n-1)/2`**\\n**If the above condition is true then the graph is complete.**\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void BFS(vector<int> adj[],vector<int> &vis,int n,int src)\\n    {\\n        queue<int> q;\\n        q.push(src);\\n        vis[src] = 1;\\n        int nodecount = 0,edgecount = 0;\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            nodecount++;\\n            for(auto x : adj[node])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    q.push(x);\\n                    vis[x] = 1;\\n                }\\n                edgecount++;\\n            }\\n        }\\n        if(nodecount*(nodecount-1)==edgecount) ans++;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n        for(int i = 0;i<e.size();i++)\\n        {\\n        adj[e[i][0]].push_back(e[i][1]);\\n        adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        for(int i = 0;i<n;i++)\\n        if(vis[i]==0) BFS(adj,vis,n,i);\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/57f59c18-a89a-4316-8da9-5915b5f352f1_1689269226.963718.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void BFS(vector<int> adj[],vector<int> &vis,int n,int src)\\n    {\\n        queue<int> q;\\n        q.push(src);\\n        vis[src] = 1;\\n        int nodecount = 0,edgecount = 0;\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            nodecount++;\\n            for(auto x : adj[node])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    q.push(x);\\n                    vis[x] = 1;\\n                }\\n                edgecount++;\\n            }\\n        }\\n        if(nodecount*(nodecount-1)==edgecount) ans++;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n        for(int i = 0;i<e.size();i++)\\n        {\\n        adj[e[i][0]].push_back(e[i][1]);\\n        adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        for(int i = 0;i<n;i++)\\n        if(vis[i]==0) BFS(adj,vis,n,i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531447,
                "title": "easy-to-understand-approach-connected-components",
                "content": "\\n\\n# Approach\\nTraverse each connected component and check whether every node has N-1 vertices in it\\'s adjacency list. If yes, then it is a complete connected component. Else, ignore it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(vector<int> &edge:edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int> vis(n,0);\\n        int cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            if(!vis[i]) {\\n                vector<int> nodes;\\n                dfs(i,adj,vis,nodes);\\n                bool isComplete = true;\\n                for(int &u:nodes) {\\n                    if(adj[u].size() != nodes.size()-1) {\\n                        isComplete = false;\\n                        break;\\n                    }\\n                }\\n                if(isComplete) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(int u, vector<vector<int>> &adj, vector<int> &vis, vector<int> &nodes) {\\n        nodes.push_back(u);\\n        vis[u] = 1;\\n\\n        for(int &v:adj[u]) {\\n            if(!vis[v]) {\\n                dfs(v,adj,vis,nodes);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(vector<int> &edge:edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int> vis(n,0);\\n        int cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            if(!vis[i]) {\\n                vector<int> nodes;\\n                dfs(i,adj,vis,nodes);\\n                bool isComplete = true;\\n                for(int &u:nodes) {\\n                    if(adj[u].size() != nodes.size()-1) {\\n                        isComplete = false;\\n                        break;\\n                    }\\n                }\\n                if(isComplete) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(int u, vector<vector<int>> &adj, vector<int> &vis, vector<int> &nodes) {\\n        nodes.push_back(u);\\n        vis[u] = 1;\\n\\n        for(int &v:adj[u]) {\\n            if(!vis[v]) {\\n                dfs(v,adj,vis,nodes);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526051,
                "title": "dfs-solution-easy-understanding-java",
                "content": "\\n# Approach\\nCount number of components and for every component count the number of edges and nodes.\\nif edges == (node)*(node-1)/2 then we can say that the it is a complete component.\\n\\n# Complexity\\n- Time complexity: O(E+N)\\n    where E=number of edges\\n          N=number of nodes\\n\\n\\n- Space complexity: O(N+E)\\n\\n# Code\\n```\\nclass Solution {\\n    int edge=0,ncount=0;\\n\\n    public boolean isComplete(int e,int nc){\\n        int ans=nc*(nc-1)/2;\\n        if(ans==e)\\n            return true;\\n        return false;\\n    }\\n    public void dfs(int node,ArrayList<ArrayList<Integer>> adj , int[] vis){\\n\\n        vis[node]=1;\\n        edge+=adj.get(node).size();\\n\\n        for(int i=0;i<adj.get(node).size();i++)\\n        {\\n            if(vis[adj.get(node).get(i)] == 0)\\n            {\\n                dfs(adj.get(node).get(i),adj,vis);\\n            }\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        int[] vis=new int[n];\\n        \\n        int count=0;\\n        int prev=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            if(vis[i] == 0)\\n            {\\n                //edge=adj.get(i).size();\\n                dfs(i,adj,vis);\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(vis[j]==1)\\n                        c+=1;\\n                }\\n                ncount=c-prev;\\n                prev=c;\\n                //System.out.println(edge/2 +\" \"+ncount);\\n                if(isComplete(edge/2,ncount))\\n                    count+=1;\\n                edge=0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int edge=0,ncount=0;\\n\\n    public boolean isComplete(int e,int nc){\\n        int ans=nc*(nc-1)/2;\\n        if(ans==e)\\n            return true;\\n        return false;\\n    }\\n    public void dfs(int node,ArrayList<ArrayList<Integer>> adj , int[] vis){\\n\\n        vis[node]=1;\\n        edge+=adj.get(node).size();\\n\\n        for(int i=0;i<adj.get(node).size();i++)\\n        {\\n            if(vis[adj.get(node).get(i)] == 0)\\n            {\\n                dfs(adj.get(node).get(i),adj,vis);\\n            }\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        int[] vis=new int[n];\\n        \\n        int count=0;\\n        int prev=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            if(vis[i] == 0)\\n            {\\n                //edge=adj.get(i).size();\\n                dfs(i,adj,vis);\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(vis[j]==1)\\n                        c+=1;\\n                }\\n                ncount=c-prev;\\n                prev=c;\\n                //System.out.println(edge/2 +\" \"+ncount);\\n                if(isComplete(edge/2,ncount))\\n                    count+=1;\\n                edge=0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523739,
                "title": "easy-bfs-based-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\n\\t\\tbool bfs(vector<vector<int>> &adj, int node, vector<int> &vis)\\n\\t\\t{\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tq.push(node);\\n\\t\\t\\tint vertices = 0;\\n\\t\\t\\tset<string> st;\\n\\t\\t\\tvis[node] = 1;\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint t = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tvertices++;\\n\\n\\n\\t\\t\\t\\tfor(int i = 0; i < adj[t].size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(vis[adj[t][i]] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tq.push(adj[t][i]);\\n\\t\\t\\t\\t\\t\\tvis[adj[t][i]] = 1;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstring str = to_string(t) + \" - \" + to_string(adj[t][i]);\\n\\t\\t\\t\\t\\tst.insert(str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint count = st.size()/2;\\n\\t\\t\\tint req = (vertices * (vertices-1)) / 2;\\n\\n\\t\\t\\tif(req == count)\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\n\\t\\tint countCompleteComponents(int n, vector<vector<int>>& edges) \\n\\t\\t{\\n\\t\\t\\tvector<vector<int> > adj(n);\\n\\n\\t\\t\\tfor(int i = 0; i < edges.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint u = edges[i][0];\\n\\t\\t\\t\\tint v = edges[i][1];\\n\\n\\t\\t\\t\\tadj[u].push_back(v);\\n\\t\\t\\t\\tadj[v].push_back(u);\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tvector<int> vis(n, 0);\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vis[i] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(bfs(adj, i, vis))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\n\\t\\tbool bfs(vector<vector<int>> &adj, int node, vector<int> &vis)\\n\\t\\t{\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tq.push(node);\\n\\t\\t\\tint vertices = 0;\\n\\t\\t\\tset<string> st;\\n\\t\\t\\tvis[node] = 1;\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint t = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tvertices++;\\n\\n\\n\\t\\t\\t\\tfor(int i = 0; i < adj[t].size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(vis[adj[t][i]] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tq.push(adj[t][i]);\\n\\t\\t\\t\\t\\t\\tvis[adj[t][i]] = 1;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3522698,
                "title": "optimised-dfs-c-easy-to-understnad",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void get(int s,vector<vector<int>> &g,int &y,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        y++;\\n        for(auto &i: g[s]){\\n            get(i,g,y,v);\\n        }\\n    }\\n    void solve(int s,vector<vector<int>> &g,int &x,int &y,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            if(g[i].size() != y)x = 0;\\n            solve(i,g,x,y,v);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        vector<bool> v1(n,false),v2(n,false);\\n        for(auto &i: edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        int y = 0,x=0,ans=0;\\n        for(int i = 0; i < n; i++){\\n            if(!v1[i]){\\n                y = -1;\\n                get(i,g,y,v1);\\n                x = 1;\\n                solve(i,g,x,y,v2);\\n                ans += x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void get(int s,vector<vector<int>> &g,int &y,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        y++;\\n        for(auto &i: g[s]){\\n            get(i,g,y,v);\\n        }\\n    }\\n    void solve(int s,vector<vector<int>> &g,int &x,int &y,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            if(g[i].size() != y)x = 0;\\n            solve(i,g,x,y,v);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        vector<bool> v1(n,false),v2(n,false);\\n        for(auto &i: edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        int y = 0,x=0,ans=0;\\n        for(int i = 0; i < n; i++){\\n            if(!v1[i]){\\n                y = -1;\\n                get(i,g,y,v1);\\n                x = 1;\\n                solve(i,g,x,y,v2);\\n                ans += x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522438,
                "title": "easy-dfs-c-solution",
                "content": "# Approach\\nIn complete connected components e = nodes*(nodes-1)/2;\\ne = no. of edges in the component\\nnodes = no. of nodes in the component\\n\\nUsing dfs we can find e and nodes in each components.\\n\\nIn the dfs function every edge will be counted twice.\\nSo the final condition will be\\ne/2 == nodes*(nodes-1)/2\\ne == nodes*(nodes-1)\\n\\n# Complexity\\n- Time complexity: $$O(E + N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {    \\n    void dfs(vector<vector<int>>& adj, vector<bool>& vis, int i, int& nodes, int& e)\\n    {\\n        nodes++;\\n        vis[i] = true;\\n        for(auto j: adj[i])\\n        {\\n            e++;\\n            if(!vis[j]) dfs(adj, vis, j, nodes, e);\\n        }\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n        for(auto e: edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                int nodes = 0, e = 0;\\n                dfs(adj, vis, i, nodes, e);\\n                // cout << nodes << \" \" << e << endl;\\n                if(e == (nodes*(nodes-1))) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {    \\n    void dfs(vector<vector<int>>& adj, vector<bool>& vis, int i, int& nodes, int& e)\\n    {\\n        nodes++;\\n        vis[i] = true;\\n        for(auto j: adj[i])\\n        {\\n            e++;\\n            if(!vis[j]) dfs(adj, vis, j, nodes, e);\\n        }\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n        for(auto e: edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                int nodes = 0, e = 0;\\n                dfs(adj, vis, i, nodes, e);\\n                // cout << nodes << \" \" << e << endl;\\n                if(e == (nodes*(nodes-1))) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3521959,
                "title": "c-dfs-easy",
                "content": "\\n```\\nclass Solution {\\n    void dfs(int src, vector<vector<int>>& g, vector<int>& nodes, vector<int>& vis) {\\n        if(vis[src])return;\\n        vis[src] = 1;\\n        \\n        nodes.push_back(src);\\n        \\n        for(auto &x: g[src])dfs(x,g,nodes,vis);\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> g(n);\\n        \\n        for(auto &x: edges) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        \\n        vector<int> vis(n);\\n        int res = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(vis[i] == 0) {\\n                vector<int> path;\\n                dfs(i,g,path,vis);\\n                \\n                int count = 0;\\n                \\n                for(int j = 0; j < path.size(); j++) {\\n                    if(g[path[j]].size() >= path.size()-1)count++;\\n                }\\n                \\n                if(count == path.size())res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int src, vector<vector<int>>& g, vector<int>& nodes, vector<int>& vis) {\\n        if(vis[src])return;\\n        vis[src] = 1;\\n        \\n        nodes.push_back(src);\\n        \\n        for(auto &x: g[src])dfs(x,g,nodes,vis);\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> g(n);\\n        \\n        for(auto &x: edges) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        \\n        vector<int> vis(n);\\n        int res = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(vis[i] == 0) {\\n                vector<int> path;\\n                dfs(i,g,path,vis);\\n                \\n                int count = 0;\\n                \\n                for(int j = 0; j < path.size(); j++) {\\n                    if(g[path[j]].size() >= path.size()-1)count++;\\n                }\\n                \\n                if(count == path.size())res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534855,
                "title": "c-finding-connected-component-with-slight-change",
                "content": "# Intuition\\nAnswer is possible when nodecount*nodecount-1 == edgecount in a connected component.\\n\\nTo visualise this you can easily take a complete graph of nodesize 3 and 4 and varify it manually.\\n\\n# Approach\\n\\nsimple finding connected component with finding nodecount and edgecount. then verify and increase the answer\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n\\n    void dfs(int node, vector<int> adj[], int &nodeCount, int &edgeCount,vector<int> &visit){\\n\\n        visit[node]=1;\\n        nodeCount++;\\n        edgeCount+=adj[node].size();\\n\\n        for(auto i:adj[node]){\\n            if(!visit[i]) dfs(i,adj,nodeCount,edgeCount,visit);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        int ans=0;\\n        vector<int> visit(n,0);\\n        for(int i=0;i<n;++i){\\n            if(visit[i]) continue;\\n            \\n            int nodeCount=0,edgeCount=0;\\n            dfs(i,adj,nodeCount,edgeCount,visit);\\n            if(nodeCount * (nodeCount-1) == edgeCount) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    void dfs(int node, vector<int> adj[], int &nodeCount, int &edgeCount,vector<int> &visit){\\n\\n        visit[node]=1;\\n        nodeCount++;\\n        edgeCount+=adj[node].size();\\n\\n        for(auto i:adj[node]){\\n            if(!visit[i]) dfs(i,adj,nodeCount,edgeCount,visit);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        int ans=0;\\n        vector<int> visit(n,0);\\n        for(int i=0;i<n;++i){\\n            if(visit[i]) continue;\\n            \\n            int nodeCount=0,edgeCount=0;\\n            dfs(i,adj,nodeCount,edgeCount,visit);\\n            if(nodeCount * (nodeCount-1) == edgeCount) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531156,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(v + e)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        # init graph\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        \\n        # dfs check connected component\\n        def dfs(i):\\n            connected.add(i)\\n            for adj in g[i]:\\n                if adj not in visited:\\n                    visited.add(adj)\\n                    dfs(adj)\\n        \\n        # count numbers of connected components\\n        res, visited = 0, set()\\n        for i in range(n):\\n            if i not in visited:\\n                connected = set()\\n                visited.add(i)\\n                dfs(i)\\n                if all(len(g[node]) == len(connected) - 1 for node in connected):\\n                    res += 1\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        # init graph\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        \\n        # dfs check connected component\\n        def dfs(i):\\n            connected.add(i)\\n            for adj in g[i]:\\n                if adj not in visited:\\n                    visited.add(adj)\\n                    dfs(adj)\\n        \\n        # count numbers of connected components\\n        res, visited = 0, set()\\n        for i in range(n):\\n            if i not in visited:\\n                connected = set()\\n                visited.add(i)\\n                dfs(i)\\n                if all(len(g[node]) == len(connected) - 1 for node in connected):\\n                    res += 1\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524551,
                "title": "easy-and-intuitive-solution-connected-components-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn a connected graph or sub-graph(component), $$|E| = v*(v-1) / 2$$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse DFS in a the same way as to find connected components. Additionally, during each DFS pass for a component check if in that component sum of all the edges taken twice is equal to n*(n-1) or not i.e, \\n\\n$$|E|*2 == v*(v-1)$$\\n# Complexity\\n- Time complexity:$$O(n+E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n+E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &G, int i, vector<int> &visited, int &v, int&ce) {\\n        \\n        visited[i] = 1;\\n\\n        //Keeping count of vertices and edges in a component\\n        v++, ce += G[i].size();\\n\\n        for (auto nbr : G[i]){\\n            if(!(visited[nbr])) dfs(G, nbr, visited, v, ce);\\n        }  \\n    }\\n    \\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> G(n, vector<int>());\\n        \\n        for (auto edge : edges){\\n            int u = edge[0], v = edge[1];\\n            G[u].push_back(v);\\n            G[v].push_back(u);\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        \\n        int ccc =0;\\n        for (int i=0; i<n; i++) {\\n            if (!(visited[i])) {\\n                int v = 0, ce = 0;\\n                dfs(G, i, visited, v, ce);\\n                \\n                if (ce == v * (v-1)) ccc++;      \\n            }\\n        }\\n        \\n        return ccc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &G, int i, vector<int> &visited, int &v, int&ce) {\\n        \\n        visited[i] = 1;\\n\\n        //Keeping count of vertices and edges in a component\\n        v++, ce += G[i].size();\\n\\n        for (auto nbr : G[i]){\\n            if(!(visited[nbr])) dfs(G, nbr, visited, v, ce);\\n        }  \\n    }\\n    \\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> G(n, vector<int>());\\n        \\n        for (auto edge : edges){\\n            int u = edge[0], v = edge[1];\\n            G[u].push_back(v);\\n            G[v].push_back(u);\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        \\n        int ccc =0;\\n        for (int i=0; i<n; i++) {\\n            if (!(visited[i])) {\\n                int v = 0, ce = 0;\\n                dfs(G, i, visited, v, ce);\\n                \\n                if (ce == v * (v-1)) ccc++;      \\n            }\\n        }\\n        \\n        return ccc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522140,
                "title": "c-dfs-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], vector<int>& vis, int i, vector<int>& vect){\\n        vect.push_back(i);\\n        vis[i]=1;\\n        for (auto val: adj[i]){\\n            if (!vis[val])dfs(adj,vis,val,vect);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for (auto val: edges){\\n            adj[val[0]].push_back(val[1]);\\n            adj[val[1]].push_back(val[0]);\\n        }\\n        int cnt=0;\\n        vector<int> vis(n,0);\\n        for (int i=0; i<n; i++){\\n            if (!vis[i]){\\n                bool flag=1;\\n                vector<int> vect;\\n                dfs(adj,vis,i,vect);\\n                int m= vect.size()-1;\\n                for (auto el: vect){\\n                    if (adj[el].size()!= m){\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                cnt+= flag;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], vector<int>& vis, int i, vector<int>& vect){\\n        vect.push_back(i);\\n        vis[i]=1;\\n        for (auto val: adj[i]){\\n            if (!vis[val])dfs(adj,vis,val,vect);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for (auto val: edges){\\n            adj[val[0]].push_back(val[1]);\\n            adj[val[1]].push_back(val[0]);\\n        }\\n        int cnt=0;\\n        vector<int> vis(n,0);\\n        for (int i=0; i<n; i++){\\n            if (!vis[i]){\\n                bool flag=1;\\n                vector<int> vect;\\n                dfs(adj,vis,i,vect);\\n                int m= vect.size()-1;\\n                for (auto el: vect){\\n                    if (adj[el].size()!= m){\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                cnt+= flag;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521993,
                "title": "dfs-c",
                "content": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<int> &nodes) {\\n        vis[node] = 1;\\n        nodes.push_back(node);\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, nodes);\\n        }\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> vis(n);\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) {\\n                vector<int> nodes;\\n                dfs(i, adj, vis, nodes);\\n                int f = 1;\\n                \\n                for(int i : nodes) {\\n                    unordered_set<int> s(adj[i].begin(), adj[i].end());\\n                    for(int j : nodes) {\\n                        if(i == j) continue;\\n                        if(s.find(j) == s.end()) {\\n                            f = 0;\\n                            break;\\n                        }\\n                    }\\n                }  \\n                ans += f;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<int> &nodes) {\\n        vis[node] = 1;\\n        nodes.push_back(node);\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, nodes);\\n        }\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> vis(n);\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) {\\n                vector<int> nodes;\\n                dfs(i, adj, vis, nodes);\\n                int f = 1;\\n                \\n                for(int i : nodes) {\\n                    unordered_set<int> s(adj[i].begin(), adj[i].end());\\n                    for(int j : nodes) {\\n                        if(i == j) continue;\\n                        if(s.find(j) == s.end()) {\\n                            f = 0;\\n                            break;\\n                        }\\n                    }\\n                }  \\n                ans += f;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521924,
                "title": "dfs-bfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector <int> ar[1000];\\n    int vis[1000];\\n    void dfs(int node, vector <int>&v) {\\n        vis[node] = 1;\\n        v.push_back(node);\\n        for (auto child : ar[node]) {\\n            if (!vis[child]) dfs(child, v);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& a) \\n    {\\n        for (auto i : a) {\\n            ar[i[0]].push_back(i[1]);\\n            ar[i[1]].push_back(i[0]);\\n        }\\n        int c = 0;\\n        for (int i = 0; i < n; i++) \\n        {\\n            if (!vis[i]) \\n            {\\n                vector <int> v;\\n                dfs(i, v);\\n                if (v.size() <= 2) c++;\\n                else \\n                {\\n                    bool f = true;\\n                    for (int j = 0; j < v.size(); j++)\\n                    {\\n                        int sz = ar[v[j]].size();\\n                        if (sz != v.size()-1) f = false;\\n                    }\\n                    if (f == true) c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> ar[1000];\\n    int vis[1000];\\n    void dfs(int node, vector <int>&v) {\\n        vis[node] = 1;\\n        v.push_back(node);\\n        for (auto child : ar[node]) {\\n            if (!vis[child]) dfs(child, v);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& a) \\n    {\\n        for (auto i : a) {\\n            ar[i[0]].push_back(i[1]);\\n            ar[i[1]].push_back(i[0]);\\n        }\\n        int c = 0;\\n        for (int i = 0; i < n; i++) \\n        {\\n            if (!vis[i]) \\n            {\\n                vector <int> v;\\n                dfs(i, v);\\n                if (v.size() <= 2) c++;\\n                else \\n                {\\n                    bool f = true;\\n                    for (int j = 0; j < v.size(); j++)\\n                    {\\n                        int sz = ar[v[j]].size();\\n                        if (sz != v.size()-1) f = false;\\n                    }\\n                    if (f == true) c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957403,
                "title": "python-solution-using-disjoint-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. \\n-->\\nA graph is said to be complete if it has $$(n * (n - 1)) / 2$$ edges where n is the number of nodes. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a Disjoint Set, the edges will be added one by one to the graph and while adding the edges to the graph, we will keep a count of edges and number of nodes for each graph.\\n\\nLastly, when checking the parent of the each graph, we will get the count of nodes and the number of edges and it must satisfy the property mentioned in the Intuition Section. if it satisfies then we increase the count by 1 for the complete graph. At the end, we will return the total count from the method.\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/254f0d29-0c66-4c4e-ba3d-6e756a2fd77e_1692946563.711879.png)\\n\\n\\n# Code\\n```\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1 for i in range(n)]\\n        self.edges = [0 for i in range(n)]\\n    \\n    def GetParent(self, node):\\n        if node == self.parent[node]:\\n            return node\\n\\n        self.parent[node] = self.GetParent(self.parent[node])\\n        return self.parent[node]\\n    \\n    def UnionBySize(self, u, v):\\n        ulp_u = self.GetParent(u)\\n        ulp_v = self.GetParent(v)\\n\\n        if ulp_u == ulp_v:\\n            self.edges[ulp_u] += 1\\n            return\\n\\n        if self.size[ulp_u] < self.size[ulp_v]:\\n            self.parent[ulp_u] = ulp_v\\n            self.size[ulp_v] += self.size[ulp_u]\\n            self.edges[ulp_v] += 1 + self.edges[ulp_u]\\n        else:\\n            self.parent[ulp_v] = ulp_u\\n            self.size[ulp_u] += self.size[ulp_v]\\n            self.edges[ulp_u] += 1 + self.edges[ulp_v]\\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        ds = DisjointSet(n)\\n        count = 0\\n\\n        for edge in edges:\\n            u = edge[0]\\n            v = edge[1]\\n\\n            ds.UnionBySize(u, v)\\n                \\n        for i in range(n):\\n            if i == ds.parent[i]:\\n                n = ds.size[i]\\n                no_of_edges = (n * (n - 1)) // 2\\n\\n                if no_of_edges == ds.edges[i]:\\n                    count += 1\\n\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1 for i in range(n)]\\n        self.edges = [0 for i in range(n)]\\n    \\n    def GetParent(self, node):\\n        if node == self.parent[node]:\\n            return node\\n\\n        self.parent[node] = self.GetParent(self.parent[node])\\n        return self.parent[node]\\n    \\n    def UnionBySize(self, u, v):\\n        ulp_u = self.GetParent(u)\\n        ulp_v = self.GetParent(v)\\n\\n        if ulp_u == ulp_v:\\n            self.edges[ulp_u] += 1\\n            return\\n\\n        if self.size[ulp_u] < self.size[ulp_v]:\\n            self.parent[ulp_u] = ulp_v\\n            self.size[ulp_v] += self.size[ulp_u]\\n            self.edges[ulp_v] += 1 + self.edges[ulp_u]\\n        else:\\n            self.parent[ulp_v] = ulp_u\\n            self.size[ulp_u] += self.size[ulp_v]\\n            self.edges[ulp_u] += 1 + self.edges[ulp_v]\\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        ds = DisjointSet(n)\\n        count = 0\\n\\n        for edge in edges:\\n            u = edge[0]\\n            v = edge[1]\\n\\n            ds.UnionBySize(u, v)\\n                \\n        for i in range(n):\\n            if i == ds.parent[i]:\\n                n = ds.size[i]\\n                no_of_edges = (n * (n - 1)) // 2\\n\\n                if no_of_edges == ds.edges[i]:\\n                    count += 1\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938891,
                "title": "java-solution-using-dfs",
                "content": "# Intuition\\nConnected components can be found using simple DFS/BFS.\\nWe only need to count number of `complete connected` components.\\n`Complete connected` components are those where every node is connected to every other nodes.\\nSo for given numner of nodes in a component (say `n`), numnber of edges would be = n * (n - 1) / 2\\n\\n**How?**\\n(n : nodes) - connected with (n-1 : other nodes) -> total edes = n * (n-1)\\nEach edge have been counted twice since this is an undirected graph.\\nSo effective total edges = n * (n-1) / 2\\n\\nEg of complete conected component with n = 4\\n\\n```\\n1 --- 2\\n|  X  |\\n4 --- 3\\n```\\nHere each node is connected with every other nodes.\\n\\n# Approach\\n* Follow the DFS traversal.\\n* For each of the connected component, check if that component is complete connected using above formulae \\n* increment the counter if above is true\\n\\n# Complexity\\n- Time complexity: `O(V+E)`\\n\\n- Space complexity: For Adjacency list: `O(V+2*E)`\\n\\n# Code\\n```java\\nclass Solution {\\n    private void dfs(List<List<Integer>> adj, boolean[] visited, int u, Set<Integer> vertices) {\\n      visited[u] = true;\\n      vertices.add(u);\\n\\n      for (int v: adj.get(u)) {\\n        if (!visited[v]) {\\n          dfs(adj, visited, v, vertices);\\n          }\\n      }\\n    }\\n\\n    private boolean isSubGraphComplete(List<List<Integer>> adj, Set<Integer> vertices) {\\n      int n = vertices.size();\\n      int countEdges = 0;\\n      for (int v : vertices) {\\n        countEdges += adj.get(v).size();\\n      }\\n\\n      int edges = countEdges/2;\\n      return (edges == n * (n-1) / 2);\\n    }\\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n      // Create adj list\\n      List<List<Integer>> adj = new ArrayList<>();\\n      for (int i=0; i<n; ++i) {\\n        adj.add(new ArrayList<Integer>());\\n      }\\n      \\n      for (int[] edge: edges) {\\n        adj.get(edge[0]).add(edge[1]);\\n        adj.get(edge[1]).add(edge[0]);\\n      }\\n      \\n      // Count number of connected components using dfs/bfs (dfs in this case)\\n      boolean[] visited = new boolean[n];\\n      int count = 0;\\n      for (int i=0; i<n; ++i) {\\n        Set<Integer> verticesList = new HashSet<>();\\n        if (!visited[i]) {\\n          dfs(adj, visited, i, verticesList);\\n\\n          // increase the component count only if this component is complete\\n          if (isSubGraphComplete(adj, verticesList)) {\\n            count++;\\n          }\\n        }\\n      }\\n      \\n      return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n1 --- 2\\n|  X  |\\n4 --- 3\\n```\n```java\\nclass Solution {\\n    private void dfs(List<List<Integer>> adj, boolean[] visited, int u, Set<Integer> vertices) {\\n      visited[u] = true;\\n      vertices.add(u);\\n\\n      for (int v: adj.get(u)) {\\n        if (!visited[v]) {\\n          dfs(adj, visited, v, vertices);\\n          }\\n      }\\n    }\\n\\n    private boolean isSubGraphComplete(List<List<Integer>> adj, Set<Integer> vertices) {\\n      int n = vertices.size();\\n      int countEdges = 0;\\n      for (int v : vertices) {\\n        countEdges += adj.get(v).size();\\n      }\\n\\n      int edges = countEdges/2;\\n      return (edges == n * (n-1) / 2);\\n    }\\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n      // Create adj list\\n      List<List<Integer>> adj = new ArrayList<>();\\n      for (int i=0; i<n; ++i) {\\n        adj.add(new ArrayList<Integer>());\\n      }\\n      \\n      for (int[] edge: edges) {\\n        adj.get(edge[0]).add(edge[1]);\\n        adj.get(edge[1]).add(edge[0]);\\n      }\\n      \\n      // Count number of connected components using dfs/bfs (dfs in this case)\\n      boolean[] visited = new boolean[n];\\n      int count = 0;\\n      for (int i=0; i<n; ++i) {\\n        Set<Integer> verticesList = new HashSet<>();\\n        if (!visited[i]) {\\n          dfs(adj, visited, i, verticesList);\\n\\n          // increase the component count only if this component is complete\\n          if (isSubGraphComplete(adj, verticesList)) {\\n            count++;\\n          }\\n        }\\n      }\\n      \\n      return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794041,
                "title": "easy-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair<T,U>{\\n        T first;\\n        U second;\\n        Pair()\\n        {\\n\\n        }\\n        Pair(T a, U b)\\n        {\\n            first = a;\\n            second = b;\\n        }\\n    }\\n\\n    Pair<Integer, Integer> dfs(int node, List<List<Integer>> adj, boolean[] vis){\\n        vis[node] = true;\\n        int vertices = 1;\\n        int edges= adj.get(node).size();\\n        for(Integer a: adj.get(node))\\n        {\\n            if(!vis[a])\\n            {\\n             Pair<Integer, Integer> temp = dfs(a,adj,vis);\\n            vertices+=temp.first;\\n            edges+=temp.second;\\n            }\\n        }\\n        return new Pair<>(vertices,edges);\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int res = 0;\\n        boolean[] vis = new boolean[n];\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i =0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i =0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        for(int i =0;i<adj.size();i++)\\n        {\\n            if(!vis[i])\\n            {\\n                Pair<Integer, Integer> temp = dfs(i,adj,vis);\\n                if(temp.first*(temp.first-1)==temp.second)\\n            {\\n                res++;\\n            }\\n            }\\n\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair<T,U>{\\n        T first;\\n        U second;\\n        Pair()\\n        {\\n\\n        }\\n        Pair(T a, U b)\\n        {\\n            first = a;\\n            second = b;\\n        }\\n    }\\n\\n    Pair<Integer, Integer> dfs(int node, List<List<Integer>> adj, boolean[] vis){\\n        vis[node] = true;\\n        int vertices = 1;\\n        int edges= adj.get(node).size();\\n        for(Integer a: adj.get(node))\\n        {\\n            if(!vis[a])\\n            {\\n             Pair<Integer, Integer> temp = dfs(a,adj,vis);\\n            vertices+=temp.first;\\n            edges+=temp.second;\\n            }\\n        }\\n        return new Pair<>(vertices,edges);\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int res = 0;\\n        boolean[] vis = new boolean[n];\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i =0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i =0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        for(int i =0;i<adj.size();i++)\\n        {\\n            if(!vis[i])\\n            {\\n                Pair<Integer, Integer> temp = dfs(i,adj,vis);\\n                if(temp.first*(temp.first-1)==temp.second)\\n            {\\n                res++;\\n            }\\n            }\\n\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786214,
                "title": "bfs-solution",
                "content": "\\nA Graph is said to be connected if \\n--->  NumberOfEdge=(node*(node-1))\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int result=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n\\n        //first store the graph\\n        List<List<Integer>>li=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            li.add(new ArrayList<>());\\n        }\\n        for(int []edge:edges)\\n        {\\n            int first=edge[0];\\n            int second=edge[1];\\n            li.get(first).add(second);\\n            li.get(second).add(first);\\n\\n        }\\n\\n      boolean visited[]=new boolean[n];\\n      Queue<Integer>q=new LinkedList<>();\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n          if(!visited[i])\\n          {\\n              bfs(li,visited,i,q);\\n          }\\n      }\\n       return result;\\n        \\n    }\\n    public void bfs(List<List<Integer>>li,boolean visited[],int s,Queue<Integer>q)\\n    {\\n        int countEdge=0;\\n        int countNode=0;\\n        q.add(s);\\n        visited[s]=true;\\n        while(!q.isEmpty())\\n        {\\n            int u=q.poll();\\n            countNode++;\\n            for(int v:li.get(u))\\n            {\\n               countEdge++;\\n                if(!visited[v])\\n                {\\n                    visited[v]=true;\\n                    q.add(v);\\n                    \\n                }\\n            }\\n        }\\n//since it is undirected graph hence countEdge should be divide by 2\\n        if(countEdge/2==(countNode*(countNode-1))/2){\\n            result++;\\n        }\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int result=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n\\n        //first store the graph\\n        List<List<Integer>>li=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            li.add(new ArrayList<>());\\n        }\\n        for(int []edge:edges)\\n        {\\n            int first=edge[0];\\n            int second=edge[1];\\n            li.get(first).add(second);\\n            li.get(second).add(first);\\n\\n        }\\n\\n      boolean visited[]=new boolean[n];\\n      Queue<Integer>q=new LinkedList<>();\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n          if(!visited[i])\\n          {\\n              bfs(li,visited,i,q);\\n          }\\n      }\\n       return result;\\n        \\n    }\\n    public void bfs(List<List<Integer>>li,boolean visited[],int s,Queue<Integer>q)\\n    {\\n        int countEdge=0;\\n        int countNode=0;\\n        q.add(s);\\n        visited[s]=true;\\n        while(!q.isEmpty())\\n        {\\n            int u=q.poll();\\n            countNode++;\\n            for(int v:li.get(u))\\n            {\\n               countEdge++;\\n                if(!visited[v])\\n                {\\n                    visited[v]=true;\\n                    q.add(v);\\n                    \\n                }\\n            }\\n        }\\n//since it is undirected graph hence countEdge should be divide by 2\\n        if(countEdge/2==(countNode*(countNode-1))/2){\\n            result++;\\n        }\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784438,
                "title": "easy-c-dfs-calculate-node-and-edges",
                "content": "# Approach:\\n \\nWe use a depth-first search (DFS) traversal to visit all the nodes in the graph and count the number of complete connected components. To check if a connected component is complete, we compare the count of nodes (nodeCount) with the count of edges (edgeCount) within that component. If the component is complete (i.e., nodeCount * (nodeCount - 1) equals edgeCount), we increment the answer.\\n\\n# Time complexity: \\nO(n + m), where n is the number of vertices and m is the number of edges. We traverse each node and edge exactly once during the DFS traversal.\\n\\n# Space complexity: \\nO(n), where n is the number of vertices. We use additional space to store the visited array of size n and the adjacency list representation of the graph.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(int node, vector<vector<int>>& adj, vector<bool>& visited) {\\n        visited[node] = true;\\n        pair<int, int> counts = {1, adj[node].size()};\\n\\n        for (int neighbor : adj[node]) {\\n            if (!visited[neighbor]) {\\n                pair<int, int> subCounts = dfs(neighbor, adj, visited);\\n                counts.first += subCounts.first;\\n                counts.second += subCounts.second;\\n            }\\n        }\\n\\n        return counts;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for (const auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        vector<bool> visited(n, false);\\n        int completeComponents = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i]) {\\n                pair<int, int> counts = dfs(i, adj, visited);\\n                if (counts.first * (counts.first - 1) == counts.second) {\\n                    completeComponents++;\\n                }\\n            }\\n        }\\n\\n        return completeComponents;\\n    }\\n};\\n\\n```\\n\\nPlease Upvote if you liked it!",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(int node, vector<vector<int>>& adj, vector<bool>& visited) {\\n        visited[node] = true;\\n        pair<int, int> counts = {1, adj[node].size()};\\n\\n        for (int neighbor : adj[node]) {\\n            if (!visited[neighbor]) {\\n                pair<int, int> subCounts = dfs(neighbor, adj, visited);\\n                counts.first += subCounts.first;\\n                counts.second += subCounts.second;\\n            }\\n        }\\n\\n        return counts;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for (const auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        vector<bool> visited(n, false);\\n        int completeComponents = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i]) {\\n                pair<int, int> counts = dfs(i, adj, visited);\\n                if (counts.first * (counts.first - 1) == counts.second) {\\n                    completeComponents++;\\n                }\\n            }\\n        }\\n\\n        return completeComponents;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773777,
                "title": "simple-dfs-and-count",
                "content": "Simply traverse graph and count vertices and edges and check for complete graph formulae: \\n(nodes)\\\\*(nodes-1) = 2*(edges)\\n\\nChek out this [link](https://math.stackexchange.com/questions/17747/why-a-complete-graph-has-fracnn-12-edges) for simple explanation.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,unordered_map<int,vector<int>> adj,unordered_map<int,bool>& visited,int& edgesCount,int& verticesCount){\\n        visited[node]=true;\\n        verticesCount++;\\n        for(int adjNode : adj[node]){\\n            edgesCount++;\\n            if(!visited[adjNode]){\\n                dfs(adjNode,adj,visited,edgesCount,verticesCount);\\n            }   \\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        unordered_map<int,vector<int>> adj;\\n        unordered_map<int,bool> visited;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int edgesCount=0;\\n            int verticesCount=0;\\n            if(!visited[i]) {\\n                dfs(i,adj,visited,edgesCount,verticesCount);\\n                if(verticesCount*(verticesCount-1)==edgesCount) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,unordered_map<int,vector<int>> adj,unordered_map<int,bool>& visited,int& edgesCount,int& verticesCount){\\n        visited[node]=true;\\n        verticesCount++;\\n        for(int adjNode : adj[node]){\\n            edgesCount++;\\n            if(!visited[adjNode]){\\n                dfs(adjNode,adj,visited,edgesCount,verticesCount);\\n            }   \\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        unordered_map<int,vector<int>> adj;\\n        unordered_map<int,bool> visited;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int edgesCount=0;\\n            int verticesCount=0;\\n            if(!visited[i]) {\\n                dfs(i,adj,visited,edgesCount,verticesCount);\\n                if(verticesCount*(verticesCount-1)==edgesCount) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721656,
                "title": "java-optimized-solution-dfs-easy-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that a component is complete only if it contains (n-1)+f(n-1) number of edges where n= number of nodes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. call the dfs and get nodes count and total edges count of each component.\\n2. if it satisfies the condition of the complete component, increse the count by 1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ncount=0;int ecount=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList());\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int c=0;\\n        boolean vis[]=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==false){\\n                dfs(i, vis, adj);\\n                if(ecount/2==numEdges(ncount))\\n                    c++;\\n                ecount=0;\\n                ncount=0;\\n            }\\n        }\\n        return c;\\n    }\\n    //ecount-> total edges in a component\\n    //ncount-> total nodes in a component\\n    public void dfs(int node, boolean vis[], List<List<Integer>> adj){\\n        vis[node]=true;\\n        ncount++;\\n        ecount= ecount+adj.get(node).size();\\n        for(int i=0;i<adj.get(node).size();i++){\\n            if(vis[adj.get(node).get(i)]==false){\\n                dfs(adj.get(node).get(i) , vis , adj);\\n            }\\n        }\\n    }\\n    //a component is complete only if it contains (n-1)+f(n-1) number of edges where n= number of nodes\\n    public int numEdges(int n){\\n        if(n==1)\\n            return 0;\\n        if(n==2)\\n            return 1;\\n        if(n==3)\\n            return 3;\\n        return (n-1)+numEdges(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int ncount=0;int ecount=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList());\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int c=0;\\n        boolean vis[]=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==false){\\n                dfs(i, vis, adj);\\n                if(ecount/2==numEdges(ncount))\\n                    c++;\\n                ecount=0;\\n                ncount=0;\\n            }\\n        }\\n        return c;\\n    }\\n    //ecount-> total edges in a component\\n    //ncount-> total nodes in a component\\n    public void dfs(int node, boolean vis[], List<List<Integer>> adj){\\n        vis[node]=true;\\n        ncount++;\\n        ecount= ecount+adj.get(node).size();\\n        for(int i=0;i<adj.get(node).size();i++){\\n            if(vis[adj.get(node).get(i)]==false){\\n                dfs(adj.get(node).get(i) , vis , adj);\\n            }\\n        }\\n    }\\n    //a component is complete only if it contains (n-1)+f(n-1) number of edges where n= number of nodes\\n    public int numEdges(int n){\\n        if(n==1)\\n            return 0;\\n        if(n==2)\\n            return 1;\\n        if(n==3)\\n            return 3;\\n        return (n-1)+numEdges(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638515,
                "title": "unique-solution-using-the-d-f-s-dfs",
                "content": "# Intuition\\nThe provided code counts the number of complete components in a graph using depth-first search (DFS). It maintains a vector of visited nodes to keep track of which nodes have been visited during the DFS traversal. The `dfs` function recursively visits the nodes and adds them to the corresponding component vector.\\n\\nThe main logic is as follows:\\n\\n1. Create an adjacency list representation of the graph using the given edges.\\n2. Initialize a vector `vis` of size `n` to keep track of visited nodes. Initially, all nodes are marked as unvisited (0).\\n3. Initialize an empty vector of vectors `comp` to store the components.\\n4. Iterate through each node in the graph. If the node has not been visited yet, create a new component vector and perform a DFS from that node, adding all visited nodes to the component vector.\\n5. Increment the component count `c` after each DFS.\\n6. After completing the DFS traversal and collecting all components, iterate through each component. Check if the number of edges for each node in the component is equal to the size of the component minus one. If not, decrement the component count `c` by 1.\\n7. Finally, return the component count `c`.\\n\\nThe code looks correct and follows the intuition of counting complete components in a graph. However, it would be helpful to provide a specific input or example to test the code and validate its correctness.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve the problem of counting complete components in a graph, we can follow the following approach:\\n\\n1. Create an adjacency list representation of the graph using the given edges. This can be done using a vector of vectors or any other suitable data structure.\\n\\n2. Initialize a vector `vis` of size `n` to keep track of visited nodes. Initially, all nodes are marked as unvisited (0).\\n\\n3. Initialize an empty vector of vectors `comp` to store the components. Each component will be represented by a separate vector.\\n\\n4. Implement a DFS (Depth-First Search) function `dfs` that takes a starting node, the adjacency list, the `vis` vector, the `comp` vector, and the component index `c` as parameters.\\n\\n5. Inside the `dfs` function, mark the current node as visited by setting `vis[node]` to 1. Add the current node to the component vector `comp[c]`.\\n\\n6. Iterate through the adjacent nodes of the current node using the adjacency list. For each adjacent node, check if it has not been visited (`vis[it] == 0`). If it is unvisited, recursively call the `dfs` function with the adjacent node, updating the `vis`, `comp`, and `c` parameters.\\n\\n7. In the main function `countCompleteComponents`, initialize a variable `c` to keep track of the component count, starting at 0.\\n\\n8. Iterate through each node in the graph. If the node has not been visited (`vis[i] == 0`), create a new component vector `comp[c]` and perform a DFS from that node using the `dfs` function. After the DFS, increment the component count `c` by 1.\\n\\n9. After completing the DFS traversal and collecting all components, iterate through each component in the `comp` vector. For each component, iterate through its nodes. Check if the number of edges for each node in the component is equal to the size of the component minus one. If the condition is not satisfied, decrement the component count `c` by 1.\\n\\n10. Finally, return the component count `c`, which represents the number of complete components in the graph.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(V + E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(V + E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(int node,vector<int>adj[],vector<int>&vis, vector<vector<int>>&comp,int c){\\n    \\n       vis[node]=1;\\n       int ans=true;\\n       comp[c].push_back(node);\\n       for(auto it:adj[node]){\\n           if(!vis[it]){\\n               dfs(it,adj,vis,comp,c);\\n           }\\n       }\\n    \\n   }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int c=0;\\n        vector<int>vis(n,0);\\n         vector<vector<int>>comp;\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                comp.push_back(vector<int>());\\n              dfs(i,adj,vis,comp,c);\\n              c++;\\n            }\\n        }\\n        for (int i = 0; i < comp.size(); i++) {\\n            for (int j = 0; j < comp[i].size(); j++) {\\n                if (adj[comp[i][j]].size() != comp[i].size() - 1) {\\n                    c--;\\n                    break;\\n                }\\n            }\\n            \\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(int node,vector<int>adj[],vector<int>&vis, vector<vector<int>>&comp,int c){\\n    \\n       vis[node]=1;\\n       int ans=true;\\n       comp[c].push_back(node);\\n       for(auto it:adj[node]){\\n           if(!vis[it]){\\n               dfs(it,adj,vis,comp,c);\\n           }\\n       }\\n    \\n   }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int c=0;\\n        vector<int>vis(n,0);\\n         vector<vector<int>>comp;\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                comp.push_back(vector<int>());\\n              dfs(i,adj,vis,comp,c);\\n              c++;\\n            }\\n        }\\n        for (int i = 0; i < comp.size(); i++) {\\n            for (int j = 0; j < comp[i].size(); j++) {\\n                if (adj[comp[i][j]].size() != comp[i].size() - 1) {\\n                    c--;\\n                    break;\\n                }\\n            }\\n            \\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591836,
                "title": "2685-count-the-number-of-complete-components",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n        main idea is that we are counting number of nodes in each component,\\n        and according to that , suppose if there n nodes in a component, for that \\n        component to be completely connected, n * (n-1) / 2 edges must be there.\\n        So now if we can count the number of edges each of the vertices have \\n        in a particular component then that sum / 2 should be equal \\n        to n * (n-1) / 2 for it to be a completely connected component.\\n        So, the bfs function here starts with a vertex, and visits all the\\n        vertices in that component and returns a vector of those vertices.\\n        Then on returning, we calculate the number of adjacents each vertex\\n        in this vector has, this sum divided by 2 will give actual number of edges,\\n        so if this equals (n * (n-1)) / 2, where n is the size of that vector,\\n        that is, number of elements in this particular component, then this\\n        component should be counted.\\n    */\\n\\n\\n    vector<int> bfs(int s, vector<int>& vis, vector<int> adj[]){\\n\\n        vector<int> nodes;\\n\\n        nodes.push_back(s);\\n        vis[s] = 1;\\n\\n        queue<int> q;\\n        q.push(s);\\n\\n\\n        while(!q.empty()){\\n\\n            int node = q.front(); q.pop();\\n\\n            for(auto it : adj[node]){\\n\\n                if(vis[it] == 0){\\n\\n                    q.push(it);\\n                    vis[it] = 1;\\n                    nodes.push_back(it);\\n                }\\n\\n            }\\n\\n        }\\n\\n\\n        return nodes;\\n\\n    }\\n\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n\\n        vector<int> adj[n];\\n\\n        for(auto& it : edges){\\n\\n            int u = it[0];\\n            int v = it[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        vector<int> vis (n, 0);\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < n; i++){\\n\\n            if(vis[i] == 0){\\n\\n                vector<int> nodes = bfs(i, vis, adj);\\n\\n                int nodeCount = nodes.size();\\n\\n                int edgeCount = 0;\\n\\n                for(int& node : nodes){\\n\\n                    edgeCount += adj[node].size();\\n\\n                }\\n\\n                int requiredEdges = (nodeCount) * (nodeCount - 1) / 2;\\n\\n                if(requiredEdges == (edgeCount / 2))\\n                    count++;\\n                \\n\\n            }\\n\\n        }\\n\\n\\n        return count;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        main idea is that we are counting number of nodes in each component,\\n        and according to that , suppose if there n nodes in a component, for that \\n        component to be completely connected, n * (n-1) / 2 edges must be there.\\n        So now if we can count the number of edges each of the vertices have \\n        in a particular component then that sum / 2 should be equal \\n        to n * (n-1) / 2 for it to be a completely connected component.\\n        So, the bfs function here starts with a vertex, and visits all the\\n        vertices in that component and returns a vector of those vertices.\\n        Then on returning, we calculate the number of adjacents each vertex\\n        in this vector has, this sum divided by 2 will give actual number of edges,\\n        so if this equals (n * (n-1)) / 2, where n is the size of that vector,\\n        that is, number of elements in this particular component, then this\\n        component should be counted.\\n    */\\n\\n\\n    vector<int> bfs(int s, vector<int>& vis, vector<int> adj[]){\\n\\n        vector<int> nodes;\\n\\n        nodes.push_back(s);\\n        vis[s] = 1;\\n\\n        queue<int> q;\\n        q.push(s);\\n\\n\\n        while(!q.empty()){\\n\\n            int node = q.front(); q.pop();\\n\\n            for(auto it : adj[node]){\\n\\n                if(vis[it] == 0){\\n\\n                    q.push(it);\\n                    vis[it] = 1;\\n                    nodes.push_back(it);\\n                }\\n\\n            }\\n\\n        }\\n\\n\\n        return nodes;\\n\\n    }\\n\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n\\n        vector<int> adj[n];\\n\\n        for(auto& it : edges){\\n\\n            int u = it[0];\\n            int v = it[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        vector<int> vis (n, 0);\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < n; i++){\\n\\n            if(vis[i] == 0){\\n\\n                vector<int> nodes = bfs(i, vis, adj);\\n\\n                int nodeCount = nodes.size();\\n\\n                int edgeCount = 0;\\n\\n                for(int& node : nodes){\\n\\n                    edgeCount += adj[node].size();\\n\\n                }\\n\\n                int requiredEdges = (nodeCount) * (nodeCount - 1) / 2;\\n\\n                if(requiredEdges == (edgeCount / 2))\\n                    count++;\\n                \\n\\n            }\\n\\n        }\\n\\n\\n        return count;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567167,
                "title": "c-solution-with-comments",
                "content": "# Complexity\\n- Time complexity:\\n    0(V+E)\\n\\n- Space complexity:\\n    0(V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum; // to store no of edges in graph\\n    int c; // to store no of nodes in graph\\n    void dfs(int node , vector<int>adj[],vector<int> &vis){\\n        vis[node] = 1;\\n        c++;\\n        sum+=adj[node].size();\\n\\n        for(auto it : adj[node]){\\n            if(vis[it] == 0){\\n                dfs(it,adj,vis);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        //create graph from input\\n        for(auto it : edges){\\n            int u =it[0];\\n            int v =it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int ans=0;\\n        int res=0;\\n        vector<int>vis(n,0);\\n    //now u need to know little bit about graph theory before moving on\\n    // if no of nodes in connected graph =n then no of edges = n*(n-1)/2\\n    //no how to find no of edges ? by handshaking lemma we can say that no of edges = sum of all indegrees \\n\\n    //we are using the same logic \\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                c=0,sum=0; //initialising with zero so that we get our count start from zero when we count for every component\\n                dfs(i,adj,vis);\\n                cout<<c<<\" \"<<sum<<endl;\\n                int edges = sum/2;\\n                if(c*(c-1)/2 == edges)\\n                    res++;\\n    }\\n}\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum; // to store no of edges in graph\\n    int c; // to store no of nodes in graph\\n    void dfs(int node , vector<int>adj[],vector<int> &vis){\\n        vis[node] = 1;\\n        c++;\\n        sum+=adj[node].size();\\n\\n        for(auto it : adj[node]){\\n            if(vis[it] == 0){\\n                dfs(it,adj,vis);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        //create graph from input\\n        for(auto it : edges){\\n            int u =it[0];\\n            int v =it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int ans=0;\\n        int res=0;\\n        vector<int>vis(n,0);\\n    //now u need to know little bit about graph theory before moving on\\n    // if no of nodes in connected graph =n then no of edges = n*(n-1)/2\\n    //no how to find no of edges ? by handshaking lemma we can say that no of edges = sum of all indegrees \\n\\n    //we are using the same logic \\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                c=0,sum=0; //initialising with zero so that we get our count start from zero when we count for every component\\n                dfs(i,adj,vis);\\n                cout<<c<<\" \"<<sum<<endl;\\n                int edges = sum/2;\\n                if(c*(c-1)/2 == edges)\\n                    res++;\\n    }\\n}\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3560054,
                "title": "python-dfs",
                "content": "Approch:\\n\\t- basically question is saying `Find some` \\n* \\t **component(connected nodes)** `that are` **complete graphs** \\n\\n\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        def dfs(i): \\n            component.add(i)\\n            \\n            for neighbour in graph[i]:\\n                if neighbour not in visited:\\n                    visited.add(neighbour)\\n                    dfs(neighbour)\\n\\t\\t\\t\\t\\t\\n        visited = set() \\n        res = 0 \\n        for i in range(n):\\n            if i not in visited:\\n                component = set() #this set will carry our connected components after the `dfs(i)`\\n                visited.add(i)\\n                dfs(i)\\n                # this is the part that we check if the length of the components\\n\\t\\t\\t\\t# are equal with the number of current number neghibhours in the graph\\n                if all(len(graph[node]) == len(component)-1 for node in component):\\n                       res += 1 \\n        return res\\n        \\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        def dfs(i): \\n            component.add(i)\\n            \\n            for neighbour in graph[i]:\\n                if neighbour not in visited:\\n                    visited.add(neighbour)\\n                    dfs(neighbour)\\n\\t\\t\\t\\t\\t\\n        visited = set() \\n        res = 0 \\n        for i in range(n):\\n            if i not in visited:\\n                component = set() #this set will carry our connected components after the `dfs(i)`\\n                visited.add(i)\\n                dfs(i)\\n                # this is the part that we check if the length of the components\\n\\t\\t\\t\\t# are equal with the number of current number neghibhours in the graph\\n                if all(len(graph[node]) == len(component)-1 for node in component):\\n                       res += 1 \\n        return res\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558119,
                "title": "c-basic-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>> &adj,vector<int> &vis,int &vertices,int &noofedges){\\n        if(vis[node]) return;\\n        vis[node]=1;\\n        vertices++;\\n        noofedges+=adj[node].size();\\n        for(auto it:adj[node]){\\n            dfs(it,adj,vis,vertices,noofedges);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n);\\n        int ccompo=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int x=0,y=0;\\n                dfs(i,adj,vis,x,y);\\n                if(x*(x-1)==y) ccompo++;\\n            }\\n        }\\n        return ccompo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>> &adj,vector<int> &vis,int &vertices,int &noofedges){\\n        if(vis[node]) return;\\n        vis[node]=1;\\n        vertices++;\\n        noofedges+=adj[node].size();\\n        for(auto it:adj[node]){\\n            dfs(it,adj,vis,vertices,noofedges);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n);\\n        int ccompo=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int x=0,y=0;\\n                dfs(i,adj,vis,x,y);\\n                if(x*(x-1)==y) ccompo++;\\n            }\\n        }\\n        return ccompo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546074,
                "title": "easy-c-sol-dfs-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\npair<int,int>dfs(int src,vector<int>adj[],vector<int>&vis){\\n        vis[src]=1;\\n        int vertices=1;\\n        int edges=adj[src].size();\\n        \\n        for(auto i:adj[src] ){\\n            if(!vis[i]){\\n               pair<int,int>temp= dfs(i,adj,vis);\\n               vertices+=temp.first;\\n                edges+=temp.second;\\n        }\\n}\\n        return {vertices,edges};\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n                vector<int>adj[n];\\n        \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n             pair<int,int>temp= dfs(i,adj,vis);\\n             int ver=temp.first;\\n                int edges=temp.second;\\n             if(ver*(ver-1)==edges)ans++;\\n            \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\npair<int,int>dfs(int src,vector<int>adj[],vector<int>&vis){\\n        vis[src]=1;\\n        int vertices=1;\\n        int edges=adj[src].size();\\n        \\n        for(auto i:adj[src] ){\\n            if(!vis[i]){\\n               pair<int,int>temp= dfs(i,adj,vis);\\n               vertices+=temp.first;\\n                edges+=temp.second;\\n        }\\n}\\n        return {vertices,edges};\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n                vector<int>adj[n];\\n        \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n             pair<int,int>temp= dfs(i,adj,vis);\\n             int ver=temp.first;\\n                int edges=temp.second;\\n             if(ver*(ver-1)==edges)ans++;\\n            \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538285,
                "title": "c-bfs-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat is needed to be doein the task in simple words?\\n* we have graph\\n* we need to find amount of the components (component is a set of nodes that are connected by edges)\\n* all of the nodes in such component also should be connected with the rest of it (like if we have graph `{0, 1, 2}` => there should be edges `{{0, 2}, {0, 3}, {1, 2}}`). This means that the number of edges of this node should be `component.size() - 1`.\\n\\nYou can use different approaches for it, but my fav is BFS .\\n*Yeah, maybe the best match here is DSU, but I don\\'t like it XD*\\n\\nPlease, study BFS on your own, I don\\'t want to take you time here to explain it.\\n\\nBut why BFS? What thoughts led me to this?\\nThe answer is simple - in this problem (as I hope you can see) was asked to traverse the graph, so you have several options here and I like to do BFS. That\\'s it =)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are going to make BFS for each node in `[0, ..., n - 1]`, mark what we have visit already, to note iterate one more time.\\n\\nBut to count the components that we are looking for we need to track which nodes are in this component. For this I gonna use `std::unordered_set` - it\\'s simple to use use and fast enough.\\n\\nSo, how we will find the component:\\n1. Run BFS for some node.\\n2. Save nodes of this component to set.\\n3. Iterate over set and check if this node has `set.size() - 1` edges.\\n\\nFor more about algo, please see the code\\n\\n> Please upvote if you like it!\\n\\n# Complexity\\n- Time complexity: $$ O(n^{(n + E)}) $$. This is because we have one main `for` ($$O(n)$$), than inside we have two additional loops:\\n    1. First for BFS with $$O(E)$$, where `E` is amount of edges in component.\\n    2. Second for iterating of the nodes in component with $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + E)$$. This is because `graph` is the biggest memory structure.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        // convert to something more usable\\n        std::vector<std::vector<int>> graph(n);\\n        for(const auto& edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // to mark each node that was visited\\n        std::vector<bool> visited(n);\\n        int result = 0;\\n\\n        for(int i = 0; i < n; ++i) {\\n            // no need to iterate one more time\\n            if(visited[i]) {\\n                continue;\\n            }\\n\\n            // to store one component\\n            std::unordered_set<int> localGraph;\\n\\n            // BFS start\\n            std::queue<int> q;\\n            q.push(i);\\n            visited[i] = true;\\n            localGraph.insert(i);\\n\\n            while(!q.empty()) {\\n                auto current = q.front();\\n                q.pop();\\n\\n                for(auto next: graph[current]) {\\n                    if(!visited[next]) {\\n                        visited[next] = true;\\n                        localGraph.insert(next);\\n                        q.push(next);\\n                    }\\n                }\\n            }\\n\\n            // to check if each node of component meets the requirements\\n            bool isComplete = true;\\n            for(const auto node: localGraph) {\\n                if(graph[node].size() != localGraph.size() - 1) {\\n                    isComplete = false;\\n                    break;\\n                }\\n            }\\n\\n            // if yes, that is component we are looking for\\n            if(isComplete) {\\n                ++result;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        // convert to something more usable\\n        std::vector<std::vector<int>> graph(n);\\n        for(const auto& edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // to mark each node that was visited\\n        std::vector<bool> visited(n);\\n        int result = 0;\\n\\n        for(int i = 0; i < n; ++i) {\\n            // no need to iterate one more time\\n            if(visited[i]) {\\n                continue;\\n            }\\n\\n            // to store one component\\n            std::unordered_set<int> localGraph;\\n\\n            // BFS start\\n            std::queue<int> q;\\n            q.push(i);\\n            visited[i] = true;\\n            localGraph.insert(i);\\n\\n            while(!q.empty()) {\\n                auto current = q.front();\\n                q.pop();\\n\\n                for(auto next: graph[current]) {\\n                    if(!visited[next]) {\\n                        visited[next] = true;\\n                        localGraph.insert(next);\\n                        q.push(next);\\n                    }\\n                }\\n            }\\n\\n            // to check if each node of component meets the requirements\\n            bool isComplete = true;\\n            for(const auto node: localGraph) {\\n                if(graph[node].size() != localGraph.size() - 1) {\\n                    isComplete = false;\\n                    break;\\n                }\\n            }\\n\\n            // if yes, that is component we are looking for\\n            if(isComplete) {\\n                ++result;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530665,
                "title": "simple-dsu-is-required-naive-solution-gets-98-efficiency-both-in-time-and-space",
                "content": "# Basic DSU\\nJust count the number of edges in each set and compare it with (edgeCount*(edgeCount-1))/2 if its true then increment else go on.\\n```\\nclass Solution {\\npublic:\\n    vector<int> par;\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        par.resize(n,-1);\\n        vector<int> cnt(n,0);\\n        for(vector<int>& x:e){\\n            int u=x[0],v=x[1];\\n            Union(u,v);\\n            int t=find(u);\\n            cnt[t]+=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int x=-1*par[i];\\n            if((par[i]<0 && cnt[i]==(x*(x-1))/2) || par[i]==-1) ans++;\\n        }\\n        return ans;\\n    }\\n    int find(int a){\\n        if(par[a]<0) return a;\\n        return par[a] = find(par[a]);\\n    }\\n    void Union(int a,int b){\\n        int x=find(a);\\n        int y=find(b);\\n        \\n        if(x==y) return;\\n        if(par[x]<par[y]){\\n            par[x] += par[y];\\n            par[y] = x;\\n        }\\n        else{\\n            par[y] += par[x];\\n            par[x] = y;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> par;\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        par.resize(n,-1);\\n        vector<int> cnt(n,0);\\n        for(vector<int>& x:e){\\n            int u=x[0],v=x[1];\\n            Union(u,v);\\n            int t=find(u);\\n            cnt[t]+=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int x=-1*par[i];\\n            if((par[i]<0 && cnt[i]==(x*(x-1))/2) || par[i]==-1) ans++;\\n        }\\n        return ans;\\n    }\\n    int find(int a){\\n        if(par[a]<0) return a;\\n        return par[a] = find(par[a]);\\n    }\\n    void Union(int a,int b){\\n        int x=find(a);\\n        int y=find(b);\\n        \\n        if(x==y) return;\\n        if(par[x]<par[y]){\\n            par[x] += par[y];\\n            par[y] = x;\\n        }\\n        else{\\n            par[y] += par[x];\\n            par[x] = y;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524728,
                "title": "best-c-solution-simple-bfs-very-basic-and-understandable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(map<int,vector<int>> mp, vector<bool> &vis, int i){\\n        \\n        vis[i] = 1;\\n        // map<int,vector<int>> store;\\n        \\n        // vis[0] = 1; \\n        queue<int> q; \\n        \\n        q.push(i); \\n        set<int> bfs; \\n        \\n        while(!q.empty()) {\\n            \\n            int node = q.front(); \\n            q.pop(); \\n            bfs.insert(node); \\n             \\n            for(auto it : mp[node]) {\\n                 \\n                if(!vis[it]) {\\n                    vis[it] = 1; \\n                    q.push(it); \\n                }\\n            }\\n        }\\n        \\n        int size = bfs.size();\\n        for(auto it: bfs){\\n            if(mp[it].size() != size-1) return false;\\n        }\\n        return true; \\n        \\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        map<int,vector<int>> mp;\\n        for(int i=0;i<edges.size();i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            mp[a].push_back(b);\\n            mp[b].push_back(a);\\n        }\\n        // adj list ban gyi\\n        \\n        vector<bool> vis(n,0);\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                // naya component hai\\n                // check karo complete hai ya nahi\\n                int val = solve(mp,vis,i);\\n                ans += val;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(map<int,vector<int>> mp, vector<bool> &vis, int i){\\n        \\n        vis[i] = 1;\\n        // map<int,vector<int>> store;\\n        \\n        // vis[0] = 1; \\n        queue<int> q; \\n        \\n        q.push(i); \\n        set<int> bfs; \\n        \\n        while(!q.empty()) {\\n            \\n            int node = q.front(); \\n            q.pop(); \\n            bfs.insert(node); \\n             \\n            for(auto it : mp[node]) {\\n                 \\n                if(!vis[it]) {\\n                    vis[it] = 1; \\n                    q.push(it); \\n                }\\n            }\\n        }\\n        \\n        int size = bfs.size();\\n        for(auto it: bfs){\\n            if(mp[it].size() != size-1) return false;\\n        }\\n        return true; \\n        \\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        map<int,vector<int>> mp;\\n        for(int i=0;i<edges.size();i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            mp[a].push_back(b);\\n            mp[b].push_back(a);\\n        }\\n        // adj list ban gyi\\n        \\n        vector<bool> vis(n,0);\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                // naya component hai\\n                // check karo complete hai ya nahi\\n                int val = solve(mp,vis,i);\\n                ans += val;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523979,
                "title": "c-using-dsu-compression-by-size-and-using-the-degree-of-node-for-counting-edges-for-each-node",
                "content": "# Approach\\nFor a component to be completely connected, each node of the component must be having an edge to each other node of that component, means if the size of the component is n then the no of edges in that component must be n-1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findparent(int i, vector<int>&parent){\\n        if(parent[i]==i)return i;\\n        return parent[i] = findparent(parent[i],parent);\\n    }\\n\\n    void unionthem(int i, int j, vector<int>&parent, vector<int>&size){\\n        i = findparent(i,parent);\\n        j = findparent(j, parent);\\n        if(i == j)return;\\n        if(size[i]>size[j]){\\n            parent[j] = i;\\n            size[i]+=size[j];\\n        }\\n\\n        else{\\n            parent[i] = j;\\n            size[j]+=size[i];\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>parent(n);\\n        iota(parent.begin(),parent.end(),0);\\n\\n        vector<int>size(n,1);\\n\\n        vector<int>degree(n);\\n        for(auto x: edges){\\n            int u = x[0];\\n            int v = x[1];\\n            unionthem(u,v,parent,size);\\n            degree[x[0]]++;\\n            degree[x[1]]++;\\n        }\\n\\n        unordered_set<int>mp;\\n        unordered_set<int>us;\\n\\n        for(int i = 0; i<n; i++){\\n            int currpar = findparent(i,parent);\\n            us.insert(currpar);\\n            if(degree[i]!=size[currpar]-1){\\n                mp.insert(currpar);\\n            }\\n        }\\n\\n        return us.size()-mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findparent(int i, vector<int>&parent){\\n        if(parent[i]==i)return i;\\n        return parent[i] = findparent(parent[i],parent);\\n    }\\n\\n    void unionthem(int i, int j, vector<int>&parent, vector<int>&size){\\n        i = findparent(i,parent);\\n        j = findparent(j, parent);\\n        if(i == j)return;\\n        if(size[i]>size[j]){\\n            parent[j] = i;\\n            size[i]+=size[j];\\n        }\\n\\n        else{\\n            parent[i] = j;\\n            size[j]+=size[i];\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>parent(n);\\n        iota(parent.begin(),parent.end(),0);\\n\\n        vector<int>size(n,1);\\n\\n        vector<int>degree(n);\\n        for(auto x: edges){\\n            int u = x[0];\\n            int v = x[1];\\n            unionthem(u,v,parent,size);\\n            degree[x[0]]++;\\n            degree[x[1]]++;\\n        }\\n\\n        unordered_set<int>mp;\\n        unordered_set<int>us;\\n\\n        for(int i = 0; i<n; i++){\\n            int currpar = findparent(i,parent);\\n            us.insert(currpar);\\n            if(degree[i]!=size[currpar]-1){\\n                mp.insert(currpar);\\n            }\\n        }\\n\\n        return us.size()-mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523038,
                "title": "bfs-variation-of-number-of-islands",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>comp;\\n    void bfs(int i,vector<int>&vis, vector<vector<int>>&graph)\\n    {\\n        queue<int>q;\\n        q.push(i);\\n        vector<int>v;\\n        v.push_back(i);\\n        vis[i]=1;\\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            for(auto ele:graph[x])\\n            {\\n                if(!vis[ele])\\n                {\\n                    v.push_back(ele);\\n                    vis[ele]=1;\\n                    q.push(ele);\\n                }\\n            }\\n        }\\n        comp.push_back(v);\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>vis(n,0);\\n        vector<vector<int>>graph(n);\\n        map<pair<int,int>,int>m;\\n        \\n        for(auto ele:edges)\\n        {\\n            m[{ele[0],ele[1]}]=1;\\n            graph[ele[0]].push_back(ele[1]);\\n            graph[ele[1]].push_back(ele[0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i]) bfs(i,vis,graph);\\n        }\\n        int cnt=0;\\n        \\n        \\n        for(auto ele:comp)\\n        {\\n            int flag=1;\\n            for(int i=0;i<ele.size();i++)\\n            {\\n                for(int j=i+1;j<ele.size();j++)\\n                {\\n                    if(m[{ele[i],ele[j]}]==0 && m[{ele[j],ele[i]}]==0)\\n                    {\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                if(flag==0)\\n                    break;\\n            }\\n            if(flag) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>comp;\\n    void bfs(int i,vector<int>&vis, vector<vector<int>>&graph)\\n    {\\n        queue<int>q;\\n        q.push(i);\\n        vector<int>v;\\n        v.push_back(i);\\n        vis[i]=1;\\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            for(auto ele:graph[x])\\n            {\\n                if(!vis[ele])\\n                {\\n                    v.push_back(ele);\\n                    vis[ele]=1;\\n                    q.push(ele);\\n                }\\n            }\\n        }\\n        comp.push_back(v);\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>vis(n,0);\\n        vector<vector<int>>graph(n);\\n        map<pair<int,int>,int>m;\\n        \\n        for(auto ele:edges)\\n        {\\n            m[{ele[0],ele[1]}]=1;\\n            graph[ele[0]].push_back(ele[1]);\\n            graph[ele[1]].push_back(ele[0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i]) bfs(i,vis,graph);\\n        }\\n        int cnt=0;\\n        \\n        \\n        for(auto ele:comp)\\n        {\\n            int flag=1;\\n            for(int i=0;i<ele.size();i++)\\n            {\\n                for(int j=i+1;j<ele.size();j++)\\n                {\\n                    if(m[{ele[i],ele[j]}]==0 && m[{ele[j],ele[i]}]==0)\\n                    {\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                if(flag==0)\\n                    break;\\n            }\\n            if(flag) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522904,
                "title": "bfs-adjacency-list-union-find",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<int[]>> al = new ArrayList<>();\\n        Set<Integer> globalSet = new HashSet<>();\\n\\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int i = 0; i < n; i++) adjList.put(i, new ArrayList<>());\\n\\n        for (int[] edge : edges) {\\n            globalSet.add(edge[0]);\\n            globalSet.add(edge[1]);\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n\\n        for (int vertex : adjList.keySet()) {\\n            if (!adjList.get(vertex).isEmpty()) {\\n                al.add(bfs(adjList, vertex));\\n            }\\n        }\\n        int count = 0;\\n\\n        for (List<int[]> l : al) {\\n            if (isCompleteConnectedComponent(l)) count++;\\n        }\\n        for (int i = 0; i < n; i++) if (!globalSet.contains(i)) count++;\\n        return count;\\n    }\\n\\n    private boolean isCompleteConnectedComponent(List<int[]> edges) {\\n        // Create a set of all vertices in the component\\n        Set<Integer> vertices = new HashSet<>();\\n        for (int[] edge : edges) {\\n            vertices.add(edge[0]);\\n            vertices.add(edge[1]);\\n        }\\n\\n        // Check if all pairs of vertices are connected by an edge\\n        for (int u : vertices) {\\n            for (int v : vertices) {\\n                if (u != v && !hasEdge(edges, u, v)) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private boolean hasEdge(List<int[]> edges, int u, int v) {\\n        for (int[] edge : edges) {\\n            if ((edge[0] == u && edge[1] == v) || (edge[0] == v && edge[1] == u)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private List<int[]> bfs(Map<Integer, List<Integer>> adjList, int start) {\\n        List<int[]> ans = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(start);\\n        while (!q.isEmpty()) {\\n            int u = q.poll();\\n            for (int v : adjList.get(u)) {\\n                ans.add(new int[]{u, v});\\n                q.offer(v);\\n                adjList.get(v).remove(Integer.valueOf(u));\\n            }\\n            adjList.get(u).clear();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<int[]>> al = new ArrayList<>();\\n        Set<Integer> globalSet = new HashSet<>();\\n\\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int i = 0; i < n; i++) adjList.put(i, new ArrayList<>());\\n\\n        for (int[] edge : edges) {\\n            globalSet.add(edge[0]);\\n            globalSet.add(edge[1]);\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n\\n        for (int vertex : adjList.keySet()) {\\n            if (!adjList.get(vertex).isEmpty()) {\\n                al.add(bfs(adjList, vertex));\\n            }\\n        }\\n        int count = 0;\\n\\n        for (List<int[]> l : al) {\\n            if (isCompleteConnectedComponent(l)) count++;\\n        }\\n        for (int i = 0; i < n; i++) if (!globalSet.contains(i)) count++;\\n        return count;\\n    }\\n\\n    private boolean isCompleteConnectedComponent(List<int[]> edges) {\\n        // Create a set of all vertices in the component\\n        Set<Integer> vertices = new HashSet<>();\\n        for (int[] edge : edges) {\\n            vertices.add(edge[0]);\\n            vertices.add(edge[1]);\\n        }\\n\\n        // Check if all pairs of vertices are connected by an edge\\n        for (int u : vertices) {\\n            for (int v : vertices) {\\n                if (u != v && !hasEdge(edges, u, v)) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private boolean hasEdge(List<int[]> edges, int u, int v) {\\n        for (int[] edge : edges) {\\n            if ((edge[0] == u && edge[1] == v) || (edge[0] == v && edge[1] == u)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private List<int[]> bfs(Map<Integer, List<Integer>> adjList, int start) {\\n        List<int[]> ans = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(start);\\n        while (!q.isEmpty()) {\\n            int u = q.poll();\\n            for (int v : adjList.get(u)) {\\n                ans.add(new int[]{u, v});\\n                q.offer(v);\\n                adjList.get(v).remove(Integer.valueOf(u));\\n            }\\n            adjList.get(u).clear();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522861,
                "title": "beginner-friendly-dfs-solution-and-union-find-solution-with-comments-python",
                "content": "**Idea**: Find connected components, and check completeness.\\n\\nFor `finding connected components`, typically two types of methods: 1. `traversal`; 2. `Union-Find`.\\n\\nThis is a TRAVERSAL solution. \\n\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        # 1. build graph\\n        graph = {i: set() for i in range(n)}\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        \\n        # 2. util fn to find connected componnet\\n        def dfs(src):\\n            visited = set()\\n            s = [src]\\n            while s:\\n                node = s.pop()\\n                if node not in visited:\\n                    visited.add(node)\\n                    for nb in graph[node]:\\n                        if nb not in visited:\\n                            s.append(nb)\\n            return visited\\n        \\n        # 3. call dfs to get the connected components\\n        visited = set()\\n        \\n        clusters = []\\n        for i in range(n):\\n            if i not in visited:\\n                c = dfs(i)\\n                clusters.append(c)\\n                visited |= c\\n        \\n        \\n        # 4. util fn to check completeness\\n        def complete(c):\\n            for i in c:\\n                for j in c:\\n                    if j == i:\\n                        continue\\n                    if j not in graph[i]:\\n                        return 0\\n            return 1\\n        \\n        # 5. return\\n        return sum(complete(c) for c in clusters)\\n```\\n\\nThis is a `Union-Find` solution:\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        # 1. union-find \\n        \\n        root = {i:i for i in range(n)}\\n        rank = {i:1 for i in range(n)}\\n        \\n        def find(i):\\n            res = i\\n            while res != root[res]:\\n                root[res] = root[root[res]]\\n                res = root[res]\\n            return res\\n        \\n        def union(i, j):\\n            root_i, root_j = find(i), find(j)\\n            if root_i != root_j:\\n                if rank[root_i] >= rank[root_j]:\\n                    root[root_j] = root_i\\n                    rank[root_i] += rank[root_j]\\n                else:\\n                    root[root_i] = root_j\\n                    rank[root_j] += rank[root_i]\\n                    \\n        def get_clusters():\\n            d = {}\\n            for node, p in root.items():\\n                r = find(p)\\n                if r not in d:\\n                    d[r] = {node}\\n                else:\\n                    d[r].add(node)\\n            return d\\n        \\n        # 2. problem logic\\n        for u, v in edges:\\n            union(u, v)\\n        clusters = get_clusters().values()\\n                    \\n                \\n        \\n        # 3. util fn to check completeness\\n        graph_edges = {tuple(edge) for edge in edges}\\n        def complete(c):\\n            for i in c:\\n                for j in c:\\n                    if j == i:\\n                        continue\\n                    if ((i, j) not in graph_edges) and ((j, i) not in graph_edges):\\n                        return 0\\n            return 1\\n        \\n        # 4. return\\n        return sum(complete(c) for c in clusters)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        # 1. build graph\\n        graph = {i: set() for i in range(n)}\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        \\n        # 2. util fn to find connected componnet\\n        def dfs(src):\\n            visited = set()\\n            s = [src]\\n            while s:\\n                node = s.pop()\\n                if node not in visited:\\n                    visited.add(node)\\n                    for nb in graph[node]:\\n                        if nb not in visited:\\n                            s.append(nb)\\n            return visited\\n        \\n        # 3. call dfs to get the connected components\\n        visited = set()\\n        \\n        clusters = []\\n        for i in range(n):\\n            if i not in visited:\\n                c = dfs(i)\\n                clusters.append(c)\\n                visited |= c\\n        \\n        \\n        # 4. util fn to check completeness\\n        def complete(c):\\n            for i in c:\\n                for j in c:\\n                    if j == i:\\n                        continue\\n                    if j not in graph[i]:\\n                        return 0\\n            return 1\\n        \\n        # 5. return\\n        return sum(complete(c) for c in clusters)\\n```\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        # 1. union-find \\n        \\n        root = {i:i for i in range(n)}\\n        rank = {i:1 for i in range(n)}\\n        \\n        def find(i):\\n            res = i\\n            while res != root[res]:\\n                root[res] = root[root[res]]\\n                res = root[res]\\n            return res\\n        \\n        def union(i, j):\\n            root_i, root_j = find(i), find(j)\\n            if root_i != root_j:\\n                if rank[root_i] >= rank[root_j]:\\n                    root[root_j] = root_i\\n                    rank[root_i] += rank[root_j]\\n                else:\\n                    root[root_i] = root_j\\n                    rank[root_j] += rank[root_i]\\n                    \\n        def get_clusters():\\n            d = {}\\n            for node, p in root.items():\\n                r = find(p)\\n                if r not in d:\\n                    d[r] = {node}\\n                else:\\n                    d[r].add(node)\\n            return d\\n        \\n        # 2. problem logic\\n        for u, v in edges:\\n            union(u, v)\\n        clusters = get_clusters().values()\\n                    \\n                \\n        \\n        # 3. util fn to check completeness\\n        graph_edges = {tuple(edge) for edge in edges}\\n        def complete(c):\\n            for i in c:\\n                for j in c:\\n                    if j == i:\\n                        continue\\n                    if ((i, j) not in graph_edges) and ((j, i) not in graph_edges):\\n                        return 0\\n            return 1\\n        \\n        # 4. return\\n        return sum(complete(c) for c in clusters)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522700,
                "title": "c-dfs",
                "content": "```\\nvoid dfs(int node, vector<int> adjLs[], vector<int> &vis, vector<int> &nodes)\\n    {\\n        vis[node] = 1;\\n        nodes.push_back(node);\\n        for(auto a : adjLs[node])\\n        {\\n            if(!vis[a]) dfs(a, adjLs, vis, nodes);\\n        }\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int> vis(n, 0);\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                vector<int> nodes;\\n                dfs(i, adj, vis, nodes);\\n                int f=0;\\n                for(int j=0;j<nodes.size();j++)\\n                {\\n                    if(adj[nodes[j]].size() != nodes.size()-1)\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(f==0) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid dfs(int node, vector<int> adjLs[], vector<int> &vis, vector<int> &nodes)\\n    {\\n        vis[node] = 1;\\n        nodes.push_back(node);\\n        for(auto a : adjLs[node])\\n        {\\n            if(!vis[a]) dfs(a, adjLs, vis, nodes);\\n        }\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int> vis(n, 0);\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                vector<int> nodes;\\n                dfs(i, adj, vis, nodes);\\n                int f=0;\\n                for(int j=0;j<nodes.size();j++)\\n                {\\n                    if(adj[nodes[j]].size() != nodes.size()-1)\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(f==0) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522633,
                "title": "go-union-find-o-n-logn-blazingly-fast",
                "content": "# Intuition\\n\\n### Union Find\\n\\n# Approach\\n1. Add all edges to union find struct\\n2. On union increase the edge count & rank count on parent node, notice that **rank count == number on nodes in the given subgraph** while  **edge count == number of edges in subgraph**\\n3. Check all parent nodes and verify that this component is complete by the formula **edge count == (rank count * (rank count -1) / 2)**, if the result is true, means that this subgraph is complete.\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(n * logn)**\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\ntype UnionFind struct {\\n    n int // nodes count\\n    p []int // parent arary\\n    r []int // number of nodes in subgraph\\n    e []int // number of edges in subgraph\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n    p := make([]int, n)\\n    r := make([]int, n)\\n    e := make([]int, n)\\n    for i := 0; i < n; i++ { \\n        p[i] = i\\n        r[i] = 1\\n    }\\n    return &UnionFind{n: n, p: p, r: r, e: e}\\n}\\n\\nfunc (uf *UnionFind) Find(x int) int {\\n    if uf.p[x] == x {\\n        return x\\n    }\\n    return uf.Find(uf.p[x])\\n}\\n\\nfunc (uf *UnionFind) Union(i, j int) {\\n    i = uf.Find(i)\\n    j = uf.Find(j)\\n    \\n    if i != j {\\n        if uf.r[i] > uf.r[j] {\\n            uf.p[j] = i\\n            uf.r[i] += uf.r[j]\\n            uf.e[i] += uf.e[j] + 1\\n        } else {\\n            uf.p[i] = j\\n            uf.r[j] += uf.r[i]\\n            uf.e[j] += uf.e[i] + 1\\n        }\\n    } else {\\n        uf.e[i]++\\n    }\\n}\\n\\nfunc (uf *UnionFind) CountComponents() int {\\n    var x int\\n    for i := 0; i < uf.n; i++ {\\n        if uf.p[i] == i { // parent node\\n            if uf.e[i] == (uf.r[i] * (uf.r[i]-1) / 2) { // n * (n-1) / 2\\n                x++\\n            }\\n        }\\n    }\\n    return x\\n}\\n\\nfunc countCompleteComponents(n int, edges [][]int) int {\\n    uf := NewUnionFind(n)\\n    for _, e := range edges {\\n        uf.Union(e[0], e[1])\\n    }\\n    return uf.CountComponents()\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\ntype UnionFind struct {\\n    n int // nodes count\\n    p []int // parent arary\\n    r []int // number of nodes in subgraph\\n    e []int // number of edges in subgraph\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n    p := make([]int, n)\\n    r := make([]int, n)\\n    e := make([]int, n)\\n    for i := 0; i < n; i++ { \\n        p[i] = i\\n        r[i] = 1\\n    }\\n    return &UnionFind{n: n, p: p, r: r, e: e}\\n}\\n\\nfunc (uf *UnionFind) Find(x int) int {\\n    if uf.p[x] == x {\\n        return x\\n    }\\n    return uf.Find(uf.p[x])\\n}\\n\\nfunc (uf *UnionFind) Union(i, j int) {\\n    i = uf.Find(i)\\n    j = uf.Find(j)\\n    \\n    if i != j {\\n        if uf.r[i] > uf.r[j] {\\n            uf.p[j] = i\\n            uf.r[i] += uf.r[j]\\n            uf.e[i] += uf.e[j] + 1\\n        } else {\\n            uf.p[i] = j\\n            uf.r[j] += uf.r[i]\\n            uf.e[j] += uf.e[i] + 1\\n        }\\n    } else {\\n        uf.e[i]++\\n    }\\n}\\n\\nfunc (uf *UnionFind) CountComponents() int {\\n    var x int\\n    for i := 0; i < uf.n; i++ {\\n        if uf.p[i] == i { // parent node\\n            if uf.e[i] == (uf.r[i] * (uf.r[i]-1) / 2) { // n * (n-1) / 2\\n                x++\\n            }\\n        }\\n    }\\n    return x\\n}\\n\\nfunc countCompleteComponents(n int, edges [][]int) int {\\n    uf := NewUnionFind(n)\\n    for _, e := range edges {\\n        uf.Union(e[0], e[1])\\n    }\\n    return uf.CountComponents()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522631,
                "title": "just-3-main-steps-dfs-connected-graph-check-adjlist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Get the number of connected graphs.\\n2. For each connected graph, each element should be present in other\\'s adjacency list. \\n3. If the 2nd step becomes correct, increment count by 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.  Make the adjacency list using map.\\n2.  dfs approach to get the list of connected nodes.\\n3.  Check whether each node has edges to other in the connected graph.\\n -->take the adjency list and add itself to its adjency list.\\n -->If adjency list == connectedNode list (for each node in the connected graph), count it.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    List<Integer> dfs(List<Integer>list,Map<Integer,List<Integer>>map,int key,int[] vis){\\n        //visted again means traversal completed for a given connected chunk of nodes\\n        if(vis[key]==1)return list;\\n        //mark node as visted\\n        vis[key]=1;\\n        //store list in new list\\n        List<Integer>li=new ArrayList<>(list);\\n        li.add(key);\\n        for(int i=0;i<map.get(key).size();i++){\\n            //dfs call for each not visited adjacent node\\n            int adjNode=map.get(key).get(i);\\n            if(vis[adjNode]==0)li=dfs(li,map,adjNode,vis);\\n        }\\n        return li;\\n    }\\n    int conn(List<Integer>list,Map<Integer,List<Integer>>adjList){\\n        int cnt=0;\\n         for(Integer i:list){\\n             //if a node can visit to all other node\\n             //means adj list just lack itself\\n             //if we add it to its own adjacency list, \\n             //adj will be equal to list.\\n             List<Integer>adj=new ArrayList<>(adjList.get(i));\\n             adj.add(i);\\n             Collections.sort(adj);\\n             if(list.equals(adj))cnt++;\\n         }\\n        return cnt==list.size()?1:0;\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //make adjacency list using map\\n        Map<Integer,List<Integer>>map=new HashMap<>();\\n        for(int i=0;i<edges.length;i++){\\n            //undirected graph so, store both nodes in each other \\n            map.putIfAbsent(edges[i][0],new ArrayList<>());\\n            map.get(edges[i][0]).add(edges[i][1]);\\n            map.putIfAbsent(edges[i][1],new ArrayList<>());\\n            map.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            //empty adjacency list for single nodes\\n            map.putIfAbsent(i,new ArrayList<>());\\n        }\\n        int[] vis=new int[map.size()];\\n        int sum=0;\\n        for(Map.Entry<Integer,List<Integer>>m:map.entrySet()){\\n            if(vis[m.getKey()]==0){\\n                List<Integer>list=new ArrayList<>();\\n                //get the list of connected nodes\\n                list=dfs(list,map,m.getKey(),vis);\\n                \\n                if(list.size()==1)sum++;\\n                else{\\n                    //sort it to match with the adjacency list of particular nodes.\\n                    Collections.sort(list);\\n                    sum+=conn(list,map);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n**If you find anything to add here, feel free to share. Happy coding :)**\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> dfs(List<Integer>list,Map<Integer,List<Integer>>map,int key,int[] vis){\\n        //visted again means traversal completed for a given connected chunk of nodes\\n        if(vis[key]==1)return list;\\n        //mark node as visted\\n        vis[key]=1;\\n        //store list in new list\\n        List<Integer>li=new ArrayList<>(list);\\n        li.add(key);\\n        for(int i=0;i<map.get(key).size();i++){\\n            //dfs call for each not visited adjacent node\\n            int adjNode=map.get(key).get(i);\\n            if(vis[adjNode]==0)li=dfs(li,map,adjNode,vis);\\n        }\\n        return li;\\n    }\\n    int conn(List<Integer>list,Map<Integer,List<Integer>>adjList){\\n        int cnt=0;\\n         for(Integer i:list){\\n             //if a node can visit to all other node\\n             //means adj list just lack itself\\n             //if we add it to its own adjacency list, \\n             //adj will be equal to list.\\n             List<Integer>adj=new ArrayList<>(adjList.get(i));\\n             adj.add(i);\\n             Collections.sort(adj);\\n             if(list.equals(adj))cnt++;\\n         }\\n        return cnt==list.size()?1:0;\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //make adjacency list using map\\n        Map<Integer,List<Integer>>map=new HashMap<>();\\n        for(int i=0;i<edges.length;i++){\\n            //undirected graph so, store both nodes in each other \\n            map.putIfAbsent(edges[i][0],new ArrayList<>());\\n            map.get(edges[i][0]).add(edges[i][1]);\\n            map.putIfAbsent(edges[i][1],new ArrayList<>());\\n            map.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            //empty adjacency list for single nodes\\n            map.putIfAbsent(i,new ArrayList<>());\\n        }\\n        int[] vis=new int[map.size()];\\n        int sum=0;\\n        for(Map.Entry<Integer,List<Integer>>m:map.entrySet()){\\n            if(vis[m.getKey()]==0){\\n                List<Integer>list=new ArrayList<>();\\n                //get the list of connected nodes\\n                list=dfs(list,map,m.getKey(),vis);\\n                \\n                if(list.size()==1)sum++;\\n                else{\\n                    //sort it to match with the adjacency list of particular nodes.\\n                    Collections.sort(list);\\n                    sum+=conn(list,map);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522523,
                "title": "c-bfs-indegree-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>v(n, 0);\\n        vector<int>adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans=0;\\n        vector<int>indeg(n, 0);\\n        for(int i=0; i<n; i++){\\n            for(auto it: adj[i]){\\n                indeg[it]++;\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            if(!v[i]){\\n                v[i]=1;\\n                vector<int>vec;\\n                queue<int>q;\\n                q.push(i);\\n                while(!q.empty()){\\n                    int x=q.front();\\n                    //cout<<x<<\" hi\"<<endl;\\n                    vec.push_back(x);\\n                    q.pop();\\n                    for(auto it: adj[x]){\\n                        //cout<<it<<\" hi\"<<endl;\\n                        if(!v[it]){\\n                            //cout<<it<<\" chk\"<<endl;\\n                            v[it]=1;\\n                            q.push(it);\\n                        }\\n                    }\\n                }\\n                int chk=1;\\n                for(int j=0; j<vec.size(); j++){\\n                    //cout<<vec[j]<<\" \"<<indeg[vec[j]]<<endl;\\n                    if(indeg[vec[j]]!=vec.size()-1){\\n                        chk=-1; break;\\n                    }\\n                }\\n                //cout<<endl;\\n                if(chk==1){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>v(n, 0);\\n        vector<int>adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans=0;\\n        vector<int>indeg(n, 0);\\n        for(int i=0; i<n; i++){\\n            for(auto it: adj[i]){\\n                indeg[it]++;\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            if(!v[i]){\\n                v[i]=1;\\n                vector<int>vec;\\n                queue<int>q;\\n                q.push(i);\\n                while(!q.empty()){\\n                    int x=q.front();\\n                    //cout<<x<<\" hi\"<<endl;\\n                    vec.push_back(x);\\n                    q.pop();\\n                    for(auto it: adj[x]){\\n                        //cout<<it<<\" hi\"<<endl;\\n                        if(!v[it]){\\n                            //cout<<it<<\" chk\"<<endl;\\n                            v[it]=1;\\n                            q.push(it);\\n                        }\\n                    }\\n                }\\n                int chk=1;\\n                for(int j=0; j<vec.size(); j++){\\n                    //cout<<vec[j]<<\" \"<<indeg[vec[j]]<<endl;\\n                    if(indeg[vec[j]]!=vec.size()-1){\\n                        chk=-1; break;\\n                    }\\n                }\\n                //cout<<endl;\\n                if(chk==1){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3522504,
                "title": "c-dsu-union-find",
                "content": "# Intuition\\nA component of graph can be imagined as all the nodes in the sub graph having same representive.\\nFor this subgrah to be fully connected, the number of edges in the sub graph should be n*(n-1)/2 where n is the number of nodes in the graph (All the edges are unique).\\n\\nThe representatives, number of edges and members in graph can be easily maintained in DSU.\\n# Approach\\n1.) For all edges, take union of vertices of an edge, as they would be in same subgraph\\n2.) Now vertices are represented by their representatives in the subgraph, number of edges of each sub graph can be counted.\\n3.) Take any vertice of an edge and add 1 to count of edges of the family.\\n4.) Now for each representative check if edges = (vertices * (vertices-1))/2, if it is, add 1 to ans.\\n5.) Return ans.\\n\\n# Complexity\\ne is the number of edges and n is the number of nodes in the whole graph\\n- Time complexity:\\n    Union operation is $O(1)$ and it is done e number of times ,i.e,\\n    $O(e)$ , then adding edges is also $O(1)$ done e times, i.e. $O(e)$. Then the families function iterates over all nodes in graph and checks for valid number of edges, $O(n)$\\n\\n    Total\\n    $O(e + e+n)$\\n    ==> $O(e+n)$\\n- Space complexity: 4 arrays of size n is maintained.\\n- $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class DSU{\\n        public:\\n        vector<int> P;\\n        vector<int> rank;\\n        vector<int> cnt_edge;\\n        vector<int> cnt_members;\\n        int n;\\n        \\n        DSU(int N){\\n            n = N;\\n            rank = vector<int>(n,0);\\n            cnt_edge = vector<int>(n,0);\\n            cnt_members = vector<int>(n,1);\\n            for(int i=0;i<n;i++){\\n                P.push_back(i);\\n            }\\n        }\\n        \\n        int Find(int x){\\n            if(P[x]!=x) return P[x] = Find(P[x]);\\n            return x;\\n        }\\n        \\n        void Union(int a, int b){\\n            int x = Find(a);\\n            int y = Find(b);\\n            if(x!=y){\\n                if(rank[x]>rank[y]){\\n                    P[y] = x;\\n                    cnt_members[x]+=cnt_members[y];\\n                }\\n                else if(rank[y]>rank[x]){\\n                    P[x] = y;\\n                    cnt_members[y]+=cnt_members[x];\\n                }\\n                else{\\n                    rank[y]++;\\n                    P[x] = y;\\n                    cnt_members[y]+=cnt_members[x];\\n                }\\n            }\\n        }\\n        void addEdges(int u){\\n            cnt_edge[Find(u)]++;\\n        }\\n        int Families(){\\n            int ans = 0;\\n            for(int i=0;i<n;i++){\\n                if(P[i]==i){\\n                    int e = cnt_edge[i];\\n                    int v = cnt_members[i];\\n                    if(e == v*(v-1)/2) ans++;\\n                }\\n            }\\n            return ans;\\n        }\\n    };\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU dsu(n);\\n        for(auto&edge:edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            dsu.Union(u,v);\\n        }\\n        for(auto&edge:edges){\\n            int u = edge[0];\\n            dsu.addEdges(u);\\n        }\\n        \\n        return dsu.Families();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class DSU{\\n        public:\\n        vector<int> P;\\n        vector<int> rank;\\n        vector<int> cnt_edge;\\n        vector<int> cnt_members;\\n        int n;\\n        \\n        DSU(int N){\\n            n = N;\\n            rank = vector<int>(n,0);\\n            cnt_edge = vector<int>(n,0);\\n            cnt_members = vector<int>(n,1);\\n            for(int i=0;i<n;i++){\\n                P.push_back(i);\\n            }\\n        }\\n        \\n        int Find(int x){\\n            if(P[x]!=x) return P[x] = Find(P[x]);\\n            return x;\\n        }\\n        \\n        void Union(int a, int b){\\n            int x = Find(a);\\n            int y = Find(b);\\n            if(x!=y){\\n                if(rank[x]>rank[y]){\\n                    P[y] = x;\\n                    cnt_members[x]+=cnt_members[y];\\n                }\\n                else if(rank[y]>rank[x]){\\n                    P[x] = y;\\n                    cnt_members[y]+=cnt_members[x];\\n                }\\n                else{\\n                    rank[y]++;\\n                    P[x] = y;\\n                    cnt_members[y]+=cnt_members[x];\\n                }\\n            }\\n        }\\n        void addEdges(int u){\\n            cnt_edge[Find(u)]++;\\n        }\\n        int Families(){\\n            int ans = 0;\\n            for(int i=0;i<n;i++){\\n                if(P[i]==i){\\n                    int e = cnt_edge[i];\\n                    int v = cnt_members[i];\\n                    if(e == v*(v-1)/2) ans++;\\n                }\\n            }\\n            return ans;\\n        }\\n    };\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU dsu(n);\\n        for(auto&edge:edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            dsu.Union(u,v);\\n        }\\n        for(auto&edge:edges){\\n            int u = edge[0];\\n            dsu.addEdges(u);\\n        }\\n        \\n        return dsu.Families();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522467,
                "title": "easy-c-solution-disjoint-set-union-dsu-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Store the number of edges for each node.\\n- Find the number of disjoint components using DSU, it will be the max possible ans\\n- Find parent of every node and store all the child nodes of each parent in a hashmap `map<int,vector<int>>`\\n- Update the `DsuSize[i]` size of every node to make it equal to the size of `DsuSize[parent]`, so that `DsuSize[node]` of every node denotes the size of the component that node is a part of.\\n- Now iterate the hashmap and check if `DsuSize[node]-1` is equal to `m[node]` (edges connected to that node), if not then subtract one from `ans` (number of disjoint components) to remove that component from the answer\\n- Check this for the every component.\\n\\n# Complexity\\n- Time complexity: O(N * logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nconst int N=1e6;\\nint DsuParent[N];\\nint DsuSize[N];\\n\\nvoid make(int v)\\n{\\n    DsuParent[v] = v;\\n    DsuSize[v] = 1;\\n}\\n\\nint parentFind(int v)\\n{\\n    if (DsuParent[v] == v)\\n        return v;\\n    return DsuParent[v] = parentFind(DsuParent[v]);\\n}\\n\\nvoid Union(int a, int b)\\n{\\n    a = parentFind(a);\\n    b = parentFind(b);\\n\\n    if (a != b)\\n    {\\n        if (DsuSize[a] < DsuSize[b])\\n            swap(a, b);\\n        DsuParent[b] = a;\\n        DsuSize[a] += DsuSize[b];\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int si = edges.size();\\n//Intialize DSU array\\n        for(int i=0;i<n;++i){\\n\\t\\t\\tmake(i);\\n\\t\\t}\\n        \\n\\t\\tmap<int,int>m;\\n// Count connected edges for each node\\n// Union the connected nodes\\n\\t\\tfor(int i=0;i<si;++i){\\n\\t\\t\\tm[edges[i][0]]++;\\n\\t\\t\\tm[edges[i][1]]++;\\n            Union(edges[i][0],edges[i][1]);\\n\\t\\t}\\n\\n        set<int>s;\\n\\t\\tmap<int,vector<int>>p;\\n\\t\\tfor(int i=0;i<n;++i){\\n\\t\\t\\tint x = parentFind(i);\\n// Store all nodes connected to the parent node\\n\\t\\t\\tp[x].push_back(i); \\n            s.insert(x);\\n\\t\\t}\\n\\n\\t\\tint ans=s.size();\\n\\n//Update the size of component for every node\\n        for (auto it:p){\\n\\t\\t\\tint x=DsuSize[it.first];\\n\\t\\t\\tfor(auto i:it.second){\\n\\t\\t\\t\\tDsuSize[i]=x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n// Check if number of edges and size of components are note equal then remove those components from the ans\\n\\t\\tfor(auto it:p){\\n\\t\\t\\tfor(auto i:it.second){\\n\\t\\t\\t\\tif(DsuSize[i]-1 != m[i]){\\n\\t\\t\\t\\t\\tans--;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N=1e6;\\nint DsuParent[N];\\nint DsuSize[N];\\n\\nvoid make(int v)\\n{\\n    DsuParent[v] = v;\\n    DsuSize[v] = 1;\\n}\\n\\nint parentFind(int v)\\n{\\n    if (DsuParent[v] == v)\\n        return v;\\n    return DsuParent[v] = parentFind(DsuParent[v]);\\n}\\n\\nvoid Union(int a, int b)\\n{\\n    a = parentFind(a);\\n    b = parentFind(b);\\n\\n    if (a != b)\\n    {\\n        if (DsuSize[a] < DsuSize[b])\\n            swap(a, b);\\n        DsuParent[b] = a;\\n        DsuSize[a] += DsuSize[b];\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int si = edges.size();\\n//Intialize DSU array\\n        for(int i=0;i<n;++i){\\n\\t\\t\\tmake(i);\\n\\t\\t}\\n        \\n\\t\\tmap<int,int>m;\\n// Count connected edges for each node\\n// Union the connected nodes\\n\\t\\tfor(int i=0;i<si;++i){\\n\\t\\t\\tm[edges[i][0]]++;\\n\\t\\t\\tm[edges[i][1]]++;\\n            Union(edges[i][0],edges[i][1]);\\n\\t\\t}\\n\\n        set<int>s;\\n\\t\\tmap<int,vector<int>>p;\\n\\t\\tfor(int i=0;i<n;++i){\\n\\t\\t\\tint x = parentFind(i);\\n// Store all nodes connected to the parent node\\n\\t\\t\\tp[x].push_back(i); \\n            s.insert(x);\\n\\t\\t}\\n\\n\\t\\tint ans=s.size();\\n\\n//Update the size of component for every node\\n        for (auto it:p){\\n\\t\\t\\tint x=DsuSize[it.first];\\n\\t\\t\\tfor(auto i:it.second){\\n\\t\\t\\t\\tDsuSize[i]=x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n// Check if number of edges and size of components are note equal then remove those components from the ans\\n\\t\\tfor(auto it:p){\\n\\t\\t\\tfor(auto i:it.second){\\n\\t\\t\\t\\tif(DsuSize[i]-1 != m[i]){\\n\\t\\t\\t\\t\\tans--;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522315,
                "title": "easy-to-understand-c-solution-using-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n  void dfs(unordered_map<int, list<int>> &adj, vector<bool> &vis, int node, int &edge, int &c) {\\n        vis[node] = true;\\n        c++;\\n        edge += adj[node].size();\\n        for(auto nbr: adj[node]) {\\n            if(!vis[nbr]) {\\n                dfs(adj, vis, nbr, edge, c);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        unordered_map<int, list<int>> adj;\\n        vector<bool> vis(n, false);\\n        for(auto edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(vis[i] == false) {\\n                int count = 0;\\n                int edge = 0;\\n                dfs(adj, vis, i,  edge, count);\\n                if(edge == count * (count-1)) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void dfs(unordered_map<int, list<int>> &adj, vector<bool> &vis, int node, int &edge, int &c) {\\n        vis[node] = true;\\n        c++;\\n        edge += adj[node].size();\\n        for(auto nbr: adj[node]) {\\n            if(!vis[nbr]) {\\n                dfs(adj, vis, nbr, edge, c);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        unordered_map<int, list<int>> adj;\\n        vector<bool> vis(n, false);\\n        for(auto edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(vis[i] == false) {\\n                int count = 0;\\n                int edge = 0;\\n                dfs(adj, vis, i,  edge, count);\\n                if(edge == count * (count-1)) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522311,
                "title": "c-best-solution-dfs-easy-to-understand",
                "content": "\\n# Code\\n```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    void dfs(int n, int x, vvi& adjMat, vi& vis, vi& comp)  {\\n        vis[x] = 1;\\n        comp.pb(x);\\n        \\n        for(int i=0; i<n; i++)  \\n            if(!vis[i] && adjMat[i][x]) dfs(n, i, adjMat, vis, comp);\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vvi adjMat(n, vi(n, 0));\\n        for(auto it : edges)    {\\n            adjMat[it[0]][it[1]] = 1;\\n            adjMat[it[1]][it[0]] = 1;\\n        }\\n        vi vis(n, 0);\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++)  {\\n            if(!vis[i]) {\\n                vi comp;\\n                dfs(n, i, adjMat, vis, comp);\\n                int flag = 1;\\n                for(int j=0; j<comp.size(); j++)    {\\n                    for(int k=j+1; k<comp.size(); k++)  {\\n                        if( !adjMat[comp[j]][comp[k]])   flag = 0;\\n                    }\\n                }\\n                if(flag)    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    void dfs(int n, int x, vvi& adjMat, vi& vis, vi& comp)  {\\n        vis[x] = 1;\\n        comp.pb(x);\\n        \\n        for(int i=0; i<n; i++)  \\n            if(!vis[i] && adjMat[i][x]) dfs(n, i, adjMat, vis, comp);\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vvi adjMat(n, vi(n, 0));\\n        for(auto it : edges)    {\\n            adjMat[it[0]][it[1]] = 1;\\n            adjMat[it[1]][it[0]] = 1;\\n        }\\n        vi vis(n, 0);\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++)  {\\n            if(!vis[i]) {\\n                vi comp;\\n                dfs(n, i, adjMat, vis, comp);\\n                int flag = 1;\\n                for(int j=0; j<comp.size(); j++)    {\\n                    for(int k=j+1; k<comp.size(); k++)  {\\n                        if( !adjMat[comp[j]][comp[k]])   flag = 0;\\n                    }\\n                }\\n                if(flag)    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522107,
                "title": "java-union-find-solution",
                "content": "```\\nclass Solution {\\n    int[] count;\\n    int len;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        if(edges.length==0) return n;\\n        len = n;\\n        count = new int[n];\\n        DisjointUnionSets set = new DisjointUnionSets(n);\\n        for(int[] x:edges){\\n            int u = x[0];\\n            int v = x[1];\\n            count[u]++;\\n            count[v]++;\\n            set.union(u,v);\\n        }\\n        return set.connected();\\n    }\\n    class DisjointUnionSets {\\n    int[] rank, parent;\\n    int n;\\n  \\n    public DisjointUnionSets(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        this.n = n;\\n        makeSet();\\n    }\\n  \\n    void makeSet()\\n    {\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n  \\n    int find(int x)\\n    {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);\\n        }\\n  \\n        return parent[x];\\n    }\\n  \\n    void union(int x, int y)\\n    {\\n        // Find representatives of two sets\\n        int xRoot = find(x), yRoot = find(y);\\n  \\n        if (xRoot == yRoot)\\n            return;\\n  \\n        if (rank[xRoot] < rank[yRoot])\\n            parent[xRoot] = yRoot;\\n  \\n        else if (rank[yRoot] < rank[xRoot])\\n  \\n            parent[yRoot] = xRoot;\\n  \\n        else \\n        {\\n             parent[yRoot] = xRoot;\\n            rank[xRoot] = rank[xRoot] + 1;\\n        }\\n    }\\n        \\n    //customised function to get required answer\\n    int connected(){\\n        int out = 0;\\n        //for each parent\\n        for(int i=0; i<n; i++){\\n            HashSet<Integer> set = new HashSet<>();\\n            //select nodes belonging to the parent\\n            for(int j=0; j<n; j++){\\n                if(find(j)==i) set.add(j);\\n            }\\n            int total = 0;\\n            //count total edges for the set\\n            for(int x:set){\\n                total+=count[x];\\n            }\\n            int size = set.size();\\n            //add if equation  matches i.e no of edges == n*(n-1)\\n            if(size>0 && total==size*(size-1))\\n                out++;\\n            //size 1 is always connected\\n            else if(size==1) out++;\\n        }\\n        return out;\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] count;\\n    int len;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        if(edges.length==0) return n;\\n        len = n;\\n        count = new int[n];\\n        DisjointUnionSets set = new DisjointUnionSets(n);\\n        for(int[] x:edges){\\n            int u = x[0];\\n            int v = x[1];\\n            count[u]++;\\n            count[v]++;\\n            set.union(u,v);\\n        }\\n        return set.connected();\\n    }\\n    class DisjointUnionSets {\\n    int[] rank, parent;\\n    int n;\\n  \\n    public DisjointUnionSets(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        this.n = n;\\n        makeSet();\\n    }\\n  \\n    void makeSet()\\n    {\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n  \\n    int find(int x)\\n    {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);\\n        }\\n  \\n        return parent[x];\\n    }\\n  \\n    void union(int x, int y)\\n    {\\n        // Find representatives of two sets\\n        int xRoot = find(x), yRoot = find(y);\\n  \\n        if (xRoot == yRoot)\\n            return;\\n  \\n        if (rank[xRoot] < rank[yRoot])\\n            parent[xRoot] = yRoot;\\n  \\n        else if (rank[yRoot] < rank[xRoot])\\n  \\n            parent[yRoot] = xRoot;\\n  \\n        else \\n        {\\n             parent[yRoot] = xRoot;\\n            rank[xRoot] = rank[xRoot] + 1;\\n        }\\n    }\\n        \\n    //customised function to get required answer\\n    int connected(){\\n        int out = 0;\\n        //for each parent\\n        for(int i=0; i<n; i++){\\n            HashSet<Integer> set = new HashSet<>();\\n            //select nodes belonging to the parent\\n            for(int j=0; j<n; j++){\\n                if(find(j)==i) set.add(j);\\n            }\\n            int total = 0;\\n            //count total edges for the set\\n            for(int x:set){\\n                total+=count[x];\\n            }\\n            int size = set.size();\\n            //add if equation  matches i.e no of edges == n*(n-1)\\n            if(size>0 && total==size*(size-1))\\n                out++;\\n            //size 1 is always connected\\n            else if(size==1) out++;\\n        }\\n        return out;\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522046,
                "title": "easy-dfs-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& temp, vector<bool>& vis, vector<vector<bool>>& adj){\\n        vis[i] = 1;\\n        temp.push_back(i);\\n        for (int j = 0; j < adj[i].size(); j++){\\n            if(adj[i][j] && !vis[j]){\\n                solve(j, temp, vis, adj);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<vector<bool>> adj(n, vector<bool>(n, 0));\\n        for (int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]][edges[i][1]] = 1;\\n            adj[edges[i][1]][edges[i][0]] = 1;\\n        }\\n        vector<int> temp;\\n        for (int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                solve(i, temp, vis, adj);\\n                bool f = 1;\\n                for (int i = 0; i < temp.size(); i++){\\n                    for (int j = i + 1; j < temp.size(); j++){\\n                        if(!adj[temp[i]][temp[j]]){\\n                            f = 0;\\n                            break;\\n                        }\\n                    }\\n                    if(!f){\\n                        break;\\n                    }\\n                }\\n                if(f){\\n                    count++;\\n                }\\n                temp.clear();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& temp, vector<bool>& vis, vector<vector<bool>>& adj){\\n        vis[i] = 1;\\n        temp.push_back(i);\\n        for (int j = 0; j < adj[i].size(); j++){\\n            if(adj[i][j] && !vis[j]){\\n                solve(j, temp, vis, adj);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<vector<bool>> adj(n, vector<bool>(n, 0));\\n        for (int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]][edges[i][1]] = 1;\\n            adj[edges[i][1]][edges[i][0]] = 1;\\n        }\\n        vector<int> temp;\\n        for (int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                solve(i, temp, vis, adj);\\n                bool f = 1;\\n                for (int i = 0; i < temp.size(); i++){\\n                    for (int j = i + 1; j < temp.size(); j++){\\n                        if(!adj[temp[i]][temp[j]]){\\n                            f = 0;\\n                            break;\\n                        }\\n                    }\\n                    if(!f){\\n                        break;\\n                    }\\n                }\\n                if(f){\\n                    count++;\\n                }\\n                temp.clear();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521994,
                "title": "java-ez-2-understand",
                "content": "first write a simple dfs to get the number of vertices in a particular component. \\nNow for complete graph the number of neighbor vertices = number of vertices in that component-1\\n\\n\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        for(int edge[]:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                count++;\\n                int c=dfs(i, visited, adj);\\n                if(!chk(i,adj,new boolean[n],c))\\n                    count--;\\n            }\\n        }\\n        return count;\\n    }\\n    boolean chk(int u,List<List<Integer>> adj,boolean vis[],int c){\\n        vis[u]=true;\\n        if(adj.get(u).size()!=c-1)\\n            return false;\\n        boolean ans=true;\\n        for(int nbr:adj.get(u)){\\n            if(!vis[nbr])\\n                ans&=chk(nbr,adj,vis,c);\\n        }\\n        //System.out.println(u+\" \"+c);\\n        return ans;\\n            \\n    }\\n    int dfs(int u, boolean[] visited, List<List<Integer>> adj) {\\n        visited[u] = true;\\n        int c=1;\\n        for (int v : adj.get(u)) {\\n            if (!visited[v]) {\\n                c+=dfs(v, visited, adj);\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        for(int edge[]:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3521969,
                "title": "rust-solution-with-collecting-edge-count-node-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_complete_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let mut graph = vec![vec![]; n];\\n        \\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n        \\n        let mut ret = 0;\\n        let mut flag = vec![0; n];\\n        \\n        for u in 0 .. n {\\n            if flag[u] == 1 { continue }\\n            \\n            let mut s = HashSet::new();\\n            let mut count = 0;\\n            Self::dfs(u, &graph, &mut flag, &mut s, &mut count);\\n            if count * (count - 1) == s.len() * 2 { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n    \\n    fn dfs(u: usize, graph: &Vec<Vec<usize>>, flag: &mut Vec<i32>, s: &mut HashSet<usize>, count: &mut usize) {\\n        flag[u] = 1;\\n        *count += 1;\\n        \\n        for v in &graph[u] {\\n            let v = *v;\\n            s.insert(u.min(v) * flag.len() + u.max(v));\\n            if flag[v] == 1 { continue }\\n            \\n            Self::dfs(v, graph, flag, s, count);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_complete_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let mut graph = vec![vec![]; n];\\n        \\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n        \\n        let mut ret = 0;\\n        let mut flag = vec![0; n];\\n        \\n        for u in 0 .. n {\\n            if flag[u] == 1 { continue }\\n            \\n            let mut s = HashSet::new();\\n            let mut count = 0;\\n            Self::dfs(u, &graph, &mut flag, &mut s, &mut count);\\n            if count * (count - 1) == s.len() * 2 { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n    \\n    fn dfs(u: usize, graph: &Vec<Vec<usize>>, flag: &mut Vec<i32>, s: &mut HashSet<usize>, count: &mut usize) {\\n        flag[u] = 1;\\n        *count += 1;\\n        \\n        for v in &graph[u] {\\n            let v = *v;\\n            s.insert(u.min(v) * flag.len() + u.max(v));\\n            if flag[v] == 1 { continue }\\n            \\n            Self::dfs(v, graph, flag, s, count);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521953,
                "title": "2685-count-the-number-of-complete-components-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n       int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }    \\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int parentU = find(parent, u);\\n            int parentV = find(parent, v);\\n            if (parentU != parentV) {\\n                parent[parentV] = parentU;\\n            }\\n        }  \\n        Map<Integer, Set<Integer>> groups = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int group = find(parent, i);\\n            groups.computeIfAbsent(group, k -> new HashSet<>()).add(i);\\n        }\\n        \\n        int count = 0;\\n        for (Set<Integer> group : groups.values()) {\\n            boolean isComplete = true;\\n            for (int i : group) {\\n                for (int j : group) {\\n                    if (i != j && !hasEdge(edges, i, j)) {\\n                        isComplete = false;\\n                        break;\\n                    }\\n                }\\n                if (!isComplete) {\\n                    break;\\n                }\\n            }\\n            if (isComplete) {\\n                count++;\\n            }\\n        }    \\n        return count;\\n    }\\n    private int find(int[] parent, int node) {\\n        if (parent[node] != node) {\\n            parent[node] = find(parent, parent[node]);\\n        }\\n        return parent[node];\\n    }\\n    \\n    private boolean hasEdge(int[][] edges, int u, int v) {\\n        for (int[] edge : edges) {\\n            if ((edge[0] == u && edge[1] == v) || (edge[0] == v && edge[1] == u)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n       int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }    \\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int parentU = find(parent, u);\\n            int parentV = find(parent, v);\\n            if (parentU != parentV) {\\n                parent[parentV] = parentU;\\n            }\\n        }  \\n        Map<Integer, Set<Integer>> groups = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int group = find(parent, i);\\n            groups.computeIfAbsent(group, k -> new HashSet<>()).add(i);\\n        }\\n        \\n        int count = 0;\\n        for (Set<Integer> group : groups.values()) {\\n            boolean isComplete = true;\\n            for (int i : group) {\\n                for (int j : group) {\\n                    if (i != j && !hasEdge(edges, i, j)) {\\n                        isComplete = false;\\n                        break;\\n                    }\\n                }\\n                if (!isComplete) {\\n                    break;\\n                }\\n            }\\n            if (isComplete) {\\n                count++;\\n            }\\n        }    \\n        return count;\\n    }\\n    private int find(int[] parent, int node) {\\n        if (parent[node] != node) {\\n            parent[node] = find(parent, parent[node]);\\n        }\\n        return parent[node];\\n    }\\n    \\n    private boolean hasEdge(int[][] edges, int u, int v) {\\n        for (int[] edge : edges) {\\n            if ((edge[0] == u && edge[1] == v) || (edge[0] == v && edge[1] == u)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521889,
                "title": "python-dfs-count-edges-in-every-subgraph",
                "content": "```\\nclass Solution:\\n    def dfs(self, cur, graph, seen, node_count, elements):\\n        seen[cur] = True\\n        node_count[0] += 1\\n        elements.add(cur)\\n        for neighbor in graph[cur]:\\n            if seen[neighbor] == False:\\n                self.dfs(neighbor, graph, seen, node_count, elements)\\n    \\n    def subcheck(self, elements, graph, node_count):\\n        for element in elements:\\n            edge_count = len(graph[element])\\n            if edge_count != node_count[0] - 1:\\n                return False\\n        return True\\n    \\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            \\n        seen = [False]*n\\n        answer = 0\\n        for node in range(n):\\n            if seen[node] == False:\\n                node_count = [0]\\n                elements = set()\\n                self.dfs(node, graph, seen, node_count, elements)\\n                # Subgraph check\\n                is_complete = self.subcheck(elements, graph, node_count)\\n                if is_complete:\\n                    answer += 1\\n                \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, cur, graph, seen, node_count, elements):\\n        seen[cur] = True\\n        node_count[0] += 1\\n        elements.add(cur)\\n        for neighbor in graph[cur]:\\n            if seen[neighbor] == False:\\n                self.dfs(neighbor, graph, seen, node_count, elements)\\n    \\n    def subcheck(self, elements, graph, node_count):\\n        for element in elements:\\n            edge_count = len(graph[element])\\n            if edge_count != node_count[0] - 1:\\n                return False\\n        return True\\n    \\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            \\n        seen = [False]*n\\n        answer = 0\\n        for node in range(n):\\n            if seen[node] == False:\\n                node_count = [0]\\n                elements = set()\\n                self.dfs(node, graph, seen, node_count, elements)\\n                # Subgraph check\\n                is_complete = self.subcheck(elements, graph, node_count)\\n                if is_complete:\\n                    answer += 1\\n                \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521877,
                "title": "bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> AList(n);\\n        \\n        for(vector<int>& edge : edges) {\\n            AList[edge[0]].push_back(edge[1]);\\n            AList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        \\n        function<bool(int)> bfs = [&](int i) {\\n            int nodes = 0;\\n            int edges = 0;\\n            visited[i] = true;\\n            queue<int> queue;\\n            queue.push(i);\\n            \\n            while(not queue.empty()) {\\n                int u = queue.front();\\n                queue.pop();\\n                \\n                nodes++;\\n                edges += AList[u].size();\\n                \\n                for(int v : AList[u]) {\\n                    if(not visited[v]) {\\n                        visited[v] = true;\\n                        queue.push(v);\\n                    }\\n                }\\n            }\\n            \\n            edges /= 2;\\n            if(((nodes*(long long)(nodes-1))/2) == edges) return true;\\n            return false;\\n        };\\n        \\n        \\n        int result = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(not visited[i]) {\\n                result += bfs(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> AList(n);\\n        \\n        for(vector<int>& edge : edges) {\\n            AList[edge[0]].push_back(edge[1]);\\n            AList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        \\n        function<bool(int)> bfs = [&](int i) {\\n            int nodes = 0;\\n            int edges = 0;\\n            visited[i] = true;\\n            queue<int> queue;\\n            queue.push(i);\\n            \\n            while(not queue.empty()) {\\n                int u = queue.front();\\n                queue.pop();\\n                \\n                nodes++;\\n                edges += AList[u].size();\\n                \\n                for(int v : AList[u]) {\\n                    if(not visited[v]) {\\n                        visited[v] = true;\\n                        queue.push(v);\\n                    }\\n                }\\n            }\\n            \\n            edges /= 2;\\n            if(((nodes*(long long)(nodes-1))/2) == edges) return true;\\n            return false;\\n        };\\n        \\n        \\n        int result = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(not visited[i]) {\\n                result += bfs(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521863,
                "title": "c-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nUnion Find\\n\\nEdge by edge, we union the nodes and increase the number of edges.\\nFinally, we check every group and see if the expected number of edges is equal to the actual number of edges.\\n\\nIf there are k nodes within a group, to be a complete connected components,\\nthere should be k*(k-1)/2 edges such that there exists an edge between every pair of its vertices.\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> group; // group[i] >= 0 means it belongs to another; otherwise i is the group leader and abs(group[i]) is the number of members within the group\\n    vector<int> count; // number of edges in group i\\n    \\n    int Parent(int i) {\\n        return group[i]<0?i:group[i]=Parent(group[i]);\\n    }\\n    void Union(int i, int j) {\\n        i = Parent(i);\\n        j = Parent(j);\\n        if( i != j) {\\n            // union groups\\n            group[i] += group[j];\\n            // accumulate edges\\n            count[i] += count[j];\\n            group[j] = i;\\n            \\n        } \\n        // increment the number of edge after adding a pair\\n        count[i]++;\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        group.resize(n, -1);\\n        count.resize(n, 0);\\n        for(vector<int>& edge: edges) {\\n            int a = edge[0], b = edge[1];\\n            Union(a, b);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(group[i]<0) {\\n                // if there are k nodes, there should be k*(k-1)/2 edges to be the complete connected components\\n                int k = -group[i];\\n                if(k*(k-1)/2==count[i])\\n                    ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> group; // group[i] >= 0 means it belongs to another; otherwise i is the group leader and abs(group[i]) is the number of members within the group\\n    vector<int> count; // number of edges in group i\\n    \\n    int Parent(int i) {\\n        return group[i]<0?i:group[i]=Parent(group[i]);\\n    }\\n    void Union(int i, int j) {\\n        i = Parent(i);\\n        j = Parent(j);\\n        if( i != j) {\\n            // union groups\\n            group[i] += group[j];\\n            // accumulate edges\\n            count[i] += count[j];\\n            group[j] = i;\\n            \\n        } \\n        // increment the number of edge after adding a pair\\n        count[i]++;\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        group.resize(n, -1);\\n        count.resize(n, 0);\\n        for(vector<int>& edge: edges) {\\n            int a = edge[0], b = edge[1];\\n            Union(a, b);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(group[i]<0) {\\n                // if there are k nodes, there should be k*(k-1)/2 edges to be the complete connected components\\n                int k = -group[i];\\n                if(k*(k-1)/2==count[i])\\n                    ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098960,
                "title": "using-bfs",
                "content": "# Approach\\nCreate the graph using adjacency matrix. Iterate thru all the vertices and check if visited or not. If not visited then perform bfs on that vertex and count the number of edges and nodes in the component. For the component to be connected nodes * (nodes - 1) == edges. If this case is true then update the result by 1. Return the result after all the vertices are explored.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        res = 0\\n        visited = set()\\n\\n        for src, dest in edges:\\n            graph[src].append(dest)\\n            graph[dest].append(src)\\n\\n        for i in range(n):\\n            if i not in visited:\\n                queue = [i]\\n                visited.add(i)\\n                nodes, edges = 0, 0\\n\\n                while queue:\\n                    curr_node = queue.pop(0)\\n                    nodes += 1\\n                    edges += len(graph[curr_node])\\n\\n                    for nei in graph[curr_node]:\\n                        if nei not in visited:\\n                            queue.append(nei)\\n                            visited.add(nei)\\n\\n                if nodes * (nodes - 1) == edges:\\n                    res += 1\\n        \\n        return res\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        res = 0\\n        visited = set()\\n\\n        for src, dest in edges:\\n            graph[src].append(dest)\\n            graph[dest].append(src)\\n\\n        for i in range(n):\\n            if i not in visited:\\n                queue = [i]\\n                visited.add(i)\\n                nodes, edges = 0, 0\\n\\n                while queue:\\n                    curr_node = queue.pop(0)\\n                    nodes += 1\\n                    edges += len(graph[curr_node])\\n\\n                    for nei in graph[curr_node]:\\n                        if nei not in visited:\\n                            queue.append(nei)\\n                            visited.add(nei)\\n\\n                if nodes * (nodes - 1) == edges:\\n                    res += 1\\n        \\n        return res\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097281,
                "title": "bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool bfs(int node, vector<int> adj[], vector<int> &visited)\\n{\\n    visited[node] = 1;\\n    int totNodes = 0;\\n    int totEdges = 0;\\n\\n    queue<int> q;\\n    q.push(node);\\n\\n    while (!q.empty())\\n    {\\n        int x = q.front();\\n        q.pop();\\n        totNodes++;\\n        totEdges += adj[x].size();\\n\\n        for (auto adjNode : adj[x])\\n        {\\n            if (!visited[adjNode])\\n            {\\n                q.push(adjNode);\\n                visited[adjNode] = 1;\\n            }\\n        }\\n    }\\n    totEdges /= 2;\\n    return totEdges == (totNodes * (totNodes - 1)) / 2;\\n}\\n\\nint countCompleteComponents(int n, vector<vector<int>> &edges)\\n{\\n    vector<int> adj[n];\\n    for (auto it : edges)\\n    {\\n        int u = it[0];\\n        int v = it[1];\\n        adj[u].push_back(v);\\n        adj[v].push_back(u);\\n    }\\n\\n    int count = 0;\\n    vector<int> visited(n, 0);\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (!visited[i])\\n        {\\n            if (bfs(i, adj, visited))\\n            {\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool bfs(int node, vector<int> adj[], vector<int> &visited)\\n{\\n    visited[node] = 1;\\n    int totNodes = 0;\\n    int totEdges = 0;\\n\\n    queue<int> q;\\n    q.push(node);\\n\\n    while (!q.empty())\\n    {\\n        int x = q.front();\\n        q.pop();\\n        totNodes++;\\n        totEdges += adj[x].size();\\n\\n        for (auto adjNode : adj[x])\\n        {\\n            if (!visited[adjNode])\\n            {\\n                q.push(adjNode);\\n                visited[adjNode] = 1;\\n            }\\n        }\\n    }\\n    totEdges /= 2;\\n    return totEdges == (totNodes * (totNodes - 1)) / 2;\\n}\\n\\nint countCompleteComponents(int n, vector<vector<int>> &edges)\\n{\\n    vector<int> adj[n];\\n    for (auto it : edges)\\n    {\\n        int u = it[0];\\n        int v = it[1];\\n        adj[u].push_back(v);\\n        adj[v].push_back(u);\\n    }\\n\\n    int count = 0;\\n    vector<int> visited(n, 0);\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (!visited[i])\\n        {\\n            if (bfs(i, adj, visited))\\n            {\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096352,
                "title": "c-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(n*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint total2=0;\\nint dfs(int i,vector<vector<int>>&adj,vector<int>&vis){\\n    vis[i]=1;\\n    int ans=0;\\n    for(auto j:adj[i]){\\n        if(vis[j]==0){\\n            ans+=1+dfs(j,adj,vis);\\n        }\\n        total2++;\\n    }\\n    return ans;\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n            int total=1+dfs(i,adj,vis);\\n            if(total*(total-1)==total2){\\n                ans++;\\n            }\\n            total2=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint total2=0;\\nint dfs(int i,vector<vector<int>>&adj,vector<int>&vis){\\n    vis[i]=1;\\n    int ans=0;\\n    for(auto j:adj[i]){\\n        if(vis[j]==0){\\n            ans+=1+dfs(j,adj,vis);\\n        }\\n        total2++;\\n    }\\n    return ans;\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n            int total=1+dfs(i,adj,vis);\\n            if(total*(total-1)==total2){\\n                ans++;\\n            }\\n            total2=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094008,
                "title": "best-c-solution-with-dfs-and-degree-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<int> &visited, map<int,vector<int>> &mp,vector<int> &v)\\n    {\\n        visited[i]=1;\\n        v.push_back(i);\\n        for(auto j:mp[i])\\n        {\\n            if(visited[j]==0)\\n            {\\n                dfs(j,visited,mp,v);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        map<int,vector<int>>mp;\\n        vector<int>visited(n,0);\\n        vector<int>degree(n,0);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            degree[edges[i][0]]++;\\n            degree[edges[i][1]]++;\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>v;\\n        vector<vector<int>>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                dfs(i,visited,mp,v);\\n                m.push_back(v);\\n                v.clear();\\n            }\\n        }\\n        int count=0,c=0;\\n        for(auto i:m)\\n        {\\n            vector<int>p=i;\\n            int t=p.size();\\n            for(int j=0;j<t;j++)\\n            {\\n                if(degree[p[j]]==t-1)c++;\\n            }\\n            if(c==t)count++;\\n            c=0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<int> &visited, map<int,vector<int>> &mp,vector<int> &v)\\n    {\\n        visited[i]=1;\\n        v.push_back(i);\\n        for(auto j:mp[i])\\n        {\\n            if(visited[j]==0)\\n            {\\n                dfs(j,visited,mp,v);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        map<int,vector<int>>mp;\\n        vector<int>visited(n,0);\\n        vector<int>degree(n,0);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            degree[edges[i][0]]++;\\n            degree[edges[i][1]]++;\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>v;\\n        vector<vector<int>>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                dfs(i,visited,mp,v);\\n                m.push_back(v);\\n                v.clear();\\n            }\\n        }\\n        int count=0,c=0;\\n        for(auto i:m)\\n        {\\n            vector<int>p=i;\\n            int t=p.size();\\n            for(int j=0;j<t;j++)\\n            {\\n                if(degree[p[j]]==t-1)c++;\\n            }\\n            if(c==t)count++;\\n            c=0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077865,
                "title": "simple-c-union-find-solution-beats-98-time-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially noticing that the problem revolved around finding subgraphs in an undirected graph lead me to use the Disjoint Set Union Find approach. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe disjoint set datastructure describes a graph by the parent of each node. If two nodes have the same parent they are connected. As described in the problem statement, a connected component is a graph where an edge exists between any pair of nodes. This means that a given node will have n - 1 connections. Once Union Find determines the subgraphs, the size of this subgraph can be found by counting the number of nodes with the same parent. Once the size of the subgraph is determined, a final loop through each of the nodes in the subgraph can be preformed to check if the subgraph is connected by comparing the number of connections to the size of the subgraph. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> par;\\n\\n    int find(int x) {\\n        if (par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        par.resize(n);\\n        for (int i = 0; i < n; i++) par[i] = i;\\n\\n        vector<int> conn(n);\\n        for (auto& a : edges) {\\n            conn[a[0]]++;\\n            conn[a[1]]++;\\n\\n            int x = find(a[0]);\\n            int y = find(a[1]);\\n\\n            par[x] = y;\\n        }\\n\\n        vector<int> psz(n);\\n        for (auto& a : par) {\\n            a = find(a);\\n            psz[a]++;\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (psz[par[i]] - 1 != conn[i]) \\n                psz[par[i]] = 0;\\n        }\\n\\n        for (auto& a : psz) if (a) res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> par;\\n\\n    int find(int x) {\\n        if (par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        par.resize(n);\\n        for (int i = 0; i < n; i++) par[i] = i;\\n\\n        vector<int> conn(n);\\n        for (auto& a : edges) {\\n            conn[a[0]]++;\\n            conn[a[1]]++;\\n\\n            int x = find(a[0]);\\n            int y = find(a[1]);\\n\\n            par[x] = y;\\n        }\\n\\n        vector<int> psz(n);\\n        for (auto& a : par) {\\n            a = find(a);\\n            psz[a]++;\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (psz[par[i]] - 1 != conn[i]) \\n                psz[par[i]] = 0;\\n        }\\n\\n        for (auto& a : psz) if (a) res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059744,
                "title": "each-line-explained-easy-dfs",
                "content": "DFS\\n# Code\\n```\\nclass Solution {\\n    // Depth-First Search function to traverse the connected components\\n    void dfs(int node, const vector<vector<int>> &adjacencyList, vector<bool> &visited, int &componentSize, int &totalEdges) {\\n        // Check if the current node has already been visited\\n        if (visited[node]) {\\n            return; // If visited, no need to process it again\\n        }\\n\\n        visited[node] = true; // Mark the current node as visited\\n        ++componentSize; // Increment the size of the current connected component\\n        totalEdges += adjacencyList[node].size(); // Count the total number of edges connected to this component\\n\\n        // Recursively visit all connected nodes in the component\\n        for (int neighbor : adjacencyList[node]) {\\n            // Call dfs recursively for each neighboring node to explore the component\\n            dfs(neighbor, adjacencyList, visited, componentSize, totalEdges);\\n        }\\n    }\\n\\npublic:\\n    // Function to count the number of complete connected components in a graph\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        // Create an adjacency list to represent the graph\\n        vector<vector<int>> adjacencyList(n);\\n        for (const auto& edge : edges) {\\n            adjacencyList[edge[0]].push_back(edge[1]);\\n            adjacencyList[edge[1]].push_back(edge[0]);\\n        }\\n\\n        vector<bool> visited(n); // Create a boolean array to track visited nodes\\n        int completeComponents = 0; // Initialize the count of complete connected components\\n\\n        // Traverse the graph and count complete components\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i]) {\\n                int componentSize = 0; // Initialize the size of the current component\\n                int totalEdges = 0; // Initialize the total edges connected to the component\\n                dfs(i, adjacencyList, visited, componentSize, totalEdges);\\n\\n                // Check if the component is complete (meets the condition)\\n                if (componentSize * (componentSize - 1) == totalEdges) {\\n                    ++completeComponents; // If complete, increment the count of complete components\\n                }\\n            }\\n        }\\n        return completeComponents; // Return the total count of complete components in the graph\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // Depth-First Search function to traverse the connected components\\n    void dfs(int node, const vector<vector<int>> &adjacencyList, vector<bool> &visited, int &componentSize, int &totalEdges) {\\n        // Check if the current node has already been visited\\n        if (visited[node]) {\\n            return; // If visited, no need to process it again\\n        }\\n\\n        visited[node] = true; // Mark the current node as visited\\n        ++componentSize; // Increment the size of the current connected component\\n        totalEdges += adjacencyList[node].size(); // Count the total number of edges connected to this component\\n\\n        // Recursively visit all connected nodes in the component\\n        for (int neighbor : adjacencyList[node]) {\\n            // Call dfs recursively for each neighboring node to explore the component\\n            dfs(neighbor, adjacencyList, visited, componentSize, totalEdges);\\n        }\\n    }\\n\\npublic:\\n    // Function to count the number of complete connected components in a graph\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        // Create an adjacency list to represent the graph\\n        vector<vector<int>> adjacencyList(n);\\n        for (const auto& edge : edges) {\\n            adjacencyList[edge[0]].push_back(edge[1]);\\n            adjacencyList[edge[1]].push_back(edge[0]);\\n        }\\n\\n        vector<bool> visited(n); // Create a boolean array to track visited nodes\\n        int completeComponents = 0; // Initialize the count of complete connected components\\n\\n        // Traverse the graph and count complete components\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i]) {\\n                int componentSize = 0; // Initialize the size of the current component\\n                int totalEdges = 0; // Initialize the total edges connected to the component\\n                dfs(i, adjacencyList, visited, componentSize, totalEdges);\\n\\n                // Check if the component is complete (meets the condition)\\n                if (componentSize * (componentSize - 1) == totalEdges) {\\n                    ++completeComponents; // If complete, increment the count of complete components\\n                }\\n            }\\n        }\\n        return completeComponents; // Return the total count of complete components in the graph\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056585,
                "title": "simple-dfs-keep-track-of-edges-and-nodes-in-each-component",
                "content": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \"\"\"\\n        count the edges in each component.\\n        if number of edges == n * (n-1) / 2 then\\n        it\\'s a complete connected component else not\\n        \"\"\"\\n        edge_map = {i: set() for i in range(n)}\\n        for edge in edges:\\n            edge_map[edge[0]].add(edge[1])\\n            edge_map[edge[1]].add(edge[0])\\n\\n        def dfs(node, dfs_visited):\\n            dfs_visited.add(node)\\n            for nei in edge_map[node]:\\n                if nei not in dfs_visited:\\n                    dfs(nei, dfs_visited)\\n        \\n        self.comp_map = {}\\n        self.comp_count_map = {}\\n        comp_count = 0\\n        for i in range(n):\\n            if i not in self.comp_map:\\n                dfs_visited = set()\\n                dfs(i, dfs_visited)\\n                for node in dfs_visited:\\n                    self.comp_map[node] = comp_count\\n                self.comp_count_map[comp_count] = len(dfs_visited)\\n                comp_count+=1\\n        self.edge_map = collections.defaultdict(int)\\n        for edge in edges:\\n            self.edge_map[self.comp_map[edge[0]]]+=1\\n        \\n        # if there are nodes with zero edges then they won\\'t be present in\\n        # edge map. Those are actually complete connected components, hence \\n        # we will add that to answer towards the end\\n\\n        complete_count = 0\\n        for key in self.edge_map:\\n            edge_cnt = self.edge_map[key]\\n            node_cnt = self.comp_count_map[key]\\n            if node_cnt * (node_cnt-1)/2 == edge_cnt:\\n                complete_count+=1\\n\\n        #print(comp_count)\\n        #print(self.comp_count_map)\\n        #print(self.comp_map)\\n        #print(self.edge_map)\\n        return complete_count + len(self.comp_count_map) - len(self.edge_map)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \"\"\"\\n        count the edges in each component.\\n        if number of edges == n * (n-1) / 2 then\\n        it\\'s a complete connected component else not\\n        \"\"\"\\n        edge_map = {i: set() for i in range(n)}\\n        for edge in edges:\\n            edge_map[edge[0]].add(edge[1])\\n            edge_map[edge[1]].add(edge[0])\\n\\n        def dfs(node, dfs_visited):\\n            dfs_visited.add(node)\\n            for nei in edge_map[node]:\\n                if nei not in dfs_visited:\\n                    dfs(nei, dfs_visited)\\n        \\n        self.comp_map = {}\\n        self.comp_count_map = {}\\n        comp_count = 0\\n        for i in range(n):\\n            if i not in self.comp_map:\\n                dfs_visited = set()\\n                dfs(i, dfs_visited)\\n                for node in dfs_visited:\\n                    self.comp_map[node] = comp_count\\n                self.comp_count_map[comp_count] = len(dfs_visited)\\n                comp_count+=1\\n        self.edge_map = collections.defaultdict(int)\\n        for edge in edges:\\n            self.edge_map[self.comp_map[edge[0]]]+=1\\n        \\n        # if there are nodes with zero edges then they won\\'t be present in\\n        # edge map. Those are actually complete connected components, hence \\n        # we will add that to answer towards the end\\n\\n        complete_count = 0\\n        for key in self.edge_map:\\n            edge_cnt = self.edge_map[key]\\n            node_cnt = self.comp_count_map[key]\\n            if node_cnt * (node_cnt-1)/2 == edge_cnt:\\n                complete_count+=1\\n\\n        #print(comp_count)\\n        #print(self.comp_count_map)\\n        #print(self.comp_map)\\n        #print(self.edge_map)\\n        return complete_count + len(self.comp_count_map) - len(self.edge_map)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049198,
                "title": "java-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    Map<Integer, List<Integer>> m = new HashMap();\\n    List<Set> connectedComponents = new ArrayList();\\n    boolean[] processed;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        processed = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            m.put(i, new ArrayList());\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            m.get(edges[i][0]).add(edges[i][1]);\\n            m.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!processed[i])\\n            connectedComponents.add(helper(i, new HashSet()));\\n        }\\n\\n        int completeConnectedCount = 0;\\n        for (Set<Integer> graph : connectedComponents) {\\n            int numNodes = graph.size();\\n            boolean isComplete = true;\\n            for (int node : graph) {\\n                if (m.get(node).size() != numNodes - 1) {\\n                    isComplete = false;\\n                    break;\\n                };\\n            }\\n            if (isComplete) completeConnectedCount++;\\n        }\\n\\n\\n        return completeConnectedCount;\\n    }\\n\\n    private Set<Integer> helper(int vertex, Set<Integer> set) {\\n        processed[vertex] = true;\\n        set.add(vertex);\\n        List<Integer> connections = m.get(vertex);\\n        for (int connection : connections) {\\n            if (!processed[connection]) {\\n                helper(connection, set);\\n            }\\n        }\\n        return set;\\n    }\\n}\\n\\n/*\\ncreate a map of vertex to its connections (adj lists)\\n\\n0 - 1, 2\\n1 - 0, 2\\n2 - 1, 0\\n\\nfor a graph to be completely connected, \\neach node should have numNodes in graph - 1 number of edges.\\n\\nform sets of nodes\\nfor each node in a set, find number of edges. each node should have n - 1 edges\\n\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    Map<Integer, List<Integer>> m = new HashMap();\\n    List<Set> connectedComponents = new ArrayList();\\n    boolean[] processed;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        processed = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            m.put(i, new ArrayList());\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            m.get(edges[i][0]).add(edges[i][1]);\\n            m.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!processed[i])\\n            connectedComponents.add(helper(i, new HashSet()));\\n        }\\n\\n        int completeConnectedCount = 0;\\n        for (Set<Integer> graph : connectedComponents) {\\n            int numNodes = graph.size();\\n            boolean isComplete = true;\\n            for (int node : graph) {\\n                if (m.get(node).size() != numNodes - 1) {\\n                    isComplete = false;\\n                    break;\\n                };\\n            }\\n            if (isComplete) completeConnectedCount++;\\n        }\\n\\n\\n        return completeConnectedCount;\\n    }\\n\\n    private Set<Integer> helper(int vertex, Set<Integer> set) {\\n        processed[vertex] = true;\\n        set.add(vertex);\\n        List<Integer> connections = m.get(vertex);\\n        for (int connection : connections) {\\n            if (!processed[connection]) {\\n                helper(connection, set);\\n            }\\n        }\\n        return set;\\n    }\\n}\\n\\n/*\\ncreate a map of vertex to its connections (adj lists)\\n\\n0 - 1, 2\\n1 - 0, 2\\n2 - 1, 0\\n\\nfor a graph to be completely connected, \\neach node should have numNodes in graph - 1 number of edges.\\n\\nform sets of nodes\\nfor each node in a set, find number of edges. each node should have n - 1 edges\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045228,
                "title": "simple-dfs-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**See we just need to find number of nodes in a component and we have to check if each node of that component is connected to every other node of that component. We can use DFS to mark all node of a particular component but how can we check if each node is connected to eveery other node of that component , it is simple we can store every node of a component in a vector lets say \"cnt\" and we can iterate the cnt vector and check the the size of every node in the adjacency list if it not equal to (cnt.size() - 1) then it won\\'t add to answer.**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<int> &cnt){\\n        vis[node] = 1;\\n        cnt.push_back(node);\\n        for(auto it : adj[node]){\\n            if(!vis[it]){\\n                dfs(it, adj, vis, cnt);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        vector<int> adj[n];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                vector<int> cnt;\\n                dfs(i, adj, vis, cnt);\\n                bool flag = true;\\n                for(int j = 0; j < cnt.size(); j++){\\n                    if(adj[cnt[j]].size() != cnt.size() - 1){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<int> &cnt){\\n        vis[node] = 1;\\n        cnt.push_back(node);\\n        for(auto it : adj[node]){\\n            if(!vis[it]){\\n                dfs(it, adj, vis, cnt);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        vector<int> adj[n];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                vector<int> cnt;\\n                dfs(i, adj, vis, cnt);\\n                bool flag = true;\\n                for(int j = 0; j < cnt.size(); j++){\\n                    if(adj[cnt[j]].size() != cnt.size() - 1){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045175,
                "title": "java-easy-code-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /* Step 1: construct a graph\\n    Step 2: applying dfs on graph to find number of components & no. of nodes in each subgraphs\\n    Step 3: comparing no.of edges with no. of edges needed for CCC */\\n\\n    public void dfs(ArrayList<ArrayList<Integer>> graph, boolean visited[], int curr, int em[]) {\\n        visited[curr] = true; // marking visited\\n\\n        for(int nbr: graph.get(curr)) {\\n            if(!visited[nbr]) {\\n                dfs(graph, visited, nbr, em); // traversing to next node if not visited\\n                em[0]++;\\n            }\\n            em[1]++;\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>(); // graph schema\\n\\n        for(int i = 0; i < n; i++) \\n            graph.add(new ArrayList<Integer>());\\n\\n        for(int edge[]: edges) { // constructing graph\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n\\n        boolean visited[] = new boolean[n]; // to track position while traversing\\n        int components = 0; // count of all components\\n        int em[] = new int[2]; // to keep count of edges & nodes\\n        em[0] = 1; // starting point is a node\\n\\n        for(int i = 0; i < n; i++) \\n            if(!visited[i]) {\\n                dfs(graph, visited, i, em); // applying dfs to traverse through graph\\n                if(em[0]*(em[0]-1)/2 == em[1]/2) components++; // checking is subgraph a CCC\\n                em[0] = 1; // updating for new subgraph\\n                em[1] = 0; // updating for new subgraph\\n            } \\n        \\n        return components;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /* Step 1: construct a graph\\n    Step 2: applying dfs on graph to find number of components & no. of nodes in each subgraphs\\n    Step 3: comparing no.of edges with no. of edges needed for CCC */\\n\\n    public void dfs(ArrayList<ArrayList<Integer>> graph, boolean visited[], int curr, int em[]) {\\n        visited[curr] = true; // marking visited\\n\\n        for(int nbr: graph.get(curr)) {\\n            if(!visited[nbr]) {\\n                dfs(graph, visited, nbr, em); // traversing to next node if not visited\\n                em[0]++;\\n            }\\n            em[1]++;\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>(); // graph schema\\n\\n        for(int i = 0; i < n; i++) \\n            graph.add(new ArrayList<Integer>());\\n\\n        for(int edge[]: edges) { // constructing graph\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n\\n        boolean visited[] = new boolean[n]; // to track position while traversing\\n        int components = 0; // count of all components\\n        int em[] = new int[2]; // to keep count of edges & nodes\\n        em[0] = 1; // starting point is a node\\n\\n        for(int i = 0; i < n; i++) \\n            if(!visited[i]) {\\n                dfs(graph, visited, i, em); // applying dfs to traverse through graph\\n                if(em[0]*(em[0]-1)/2 == em[1]/2) components++; // checking is subgraph a CCC\\n                em[0] = 1; // updating for new subgraph\\n                em[1] = 0; // updating for new subgraph\\n            } \\n        \\n        return components;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045124,
                "title": "cpp-solution-easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i , int parent , int &nodeCount , int &edgeCount , vector<vector<bool>> &edgeVisited , vector<bool> &visited , vector<vector<int>> &adj)\\n    {\\n        if((parent != -1 && edgeVisited[i][parent])) return;\\n        if(parent != -1)\\n        { \\n            edgeCount++;\\n            edgeVisited[i][parent] = edgeVisited[parent][i] = true;\\n        }\\n        if(visited[i]) return;\\n        nodeCount++;\\n        visited[i] = true;\\n        for(auto node : adj[i])\\n        {\\n            dfs(node , i , nodeCount , edgeCount , edgeVisited , visited , adj);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<vector<bool>> edgeVisited(n , vector<bool> (n , false));\\n        vector<bool> visited(n , false);\\n        int answer = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int nodeCount = 0;\\n                int edgeCount = 0;\\n                dfs(i , -1 , nodeCount , edgeCount , edgeVisited , visited , adj);\\n                if(edgeCount == (nodeCount*(nodeCount-1))/2) answer++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i , int parent , int &nodeCount , int &edgeCount , vector<vector<bool>> &edgeVisited , vector<bool> &visited , vector<vector<int>> &adj)\\n    {\\n        if((parent != -1 && edgeVisited[i][parent])) return;\\n        if(parent != -1)\\n        { \\n            edgeCount++;\\n            edgeVisited[i][parent] = edgeVisited[parent][i] = true;\\n        }\\n        if(visited[i]) return;\\n        nodeCount++;\\n        visited[i] = true;\\n        for(auto node : adj[i])\\n        {\\n            dfs(node , i , nodeCount , edgeCount , edgeVisited , visited , adj);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<vector<bool>> edgeVisited(n , vector<bool> (n , false));\\n        vector<bool> visited(n , false);\\n        int answer = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int nodeCount = 0;\\n                int edgeCount = 0;\\n                dfs(i , -1 , nodeCount , edgeCount , edgeVisited , visited , adj);\\n                if(edgeCount == (nodeCount*(nodeCount-1))/2) answer++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040556,
                "title": "c-code-simple-count-component-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(int s,vector<int>*adj,vector<bool>&visited,int&chk,vector<int>&t){\\n        queue<int>q;\\n        q.push(s);\\n        visited[s]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(int x:adj[u]){\\n                if(!visited[x]){\\n                    t.push_back(x);\\n                    visited[x]=true;\\n                    q.push(x);\\n                    chk++;\\n                }\\n            }\\n        }\\n        \\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        //creation of graph\\n        vector<int>adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int compo=0;\\n        vector<bool>visited(n,false);\\n        //vector<bool>visi(n,false);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                int chk=0;\\n                vector<int>t;\\n                t.push_back(i);\\n                bfs(i,adj,visited,chk,t);\\n                int fg=0;\\n                for(int x:t){\\n                    if(adj[x].size()!=chk){fg=1;break;}\\n                }\\n                if(fg==0)compo++;\\n               \\n            }\\n        }\\n        return compo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bfs(int s,vector<int>*adj,vector<bool>&visited,int&chk,vector<int>&t){\\n        queue<int>q;\\n        q.push(s);\\n        visited[s]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(int x:adj[u]){\\n                if(!visited[x]){\\n                    t.push_back(x);\\n                    visited[x]=true;\\n                    q.push(x);\\n                    chk++;\\n                }\\n            }\\n        }\\n        \\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        //creation of graph\\n        vector<int>adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int compo=0;\\n        vector<bool>visited(n,false);\\n        //vector<bool>visi(n,false);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                int chk=0;\\n                vector<int>t;\\n                t.push_back(i);\\n                bfs(i,adj,visited,chk,t);\\n                int fg=0;\\n                for(int x:t){\\n                    if(adj[x].size()!=chk){fg=1;break;}\\n                }\\n                if(fg==0)compo++;\\n               \\n            }\\n        }\\n        return compo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039490,
                "title": "simple-c-solution-using-dfs-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that for an fully connected Graph Maximum edges are => \\nE = N * (N-1);\\nE -> number of edges in Connected graph \\nN -> number of nodes in Connected graph\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<int> &visit,vector<int> adj[],int &node_count,int &edge_count){\\n        visit[i] = 1;\\n        node_count++; \\n        edge_count += adj[i].size();\\n\\n        for(auto x:adj[i]){\\n            if(!visit[x]) dfs(x,visit,adj,node_count,edge_count);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> visit(n,0);\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int res = 0;\\n        for(int i=0;i<n;i++){\\n            if(!visit[i]){\\n                int node_count = 0, edge_count = 0; \\n                dfs(i,visit,adj,node_count,edge_count);\\n\\n                if(edge_count == node_count * (node_count-1)) \\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<int> &visit,vector<int> adj[],int &node_count,int &edge_count){\\n        visit[i] = 1;\\n        node_count++; \\n        edge_count += adj[i].size();\\n\\n        for(auto x:adj[i]){\\n            if(!visit[x]) dfs(x,visit,adj,node_count,edge_count);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> visit(n,0);\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int res = 0;\\n        for(int i=0;i<n;i++){\\n            if(!visit[i]){\\n                int node_count = 0, edge_count = 0; \\n                dfs(i,visit,adj,node_count,edge_count);\\n\\n                if(edge_count == node_count * (node_count-1)) \\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025927,
                "title": "using-dfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the Graph: Create an adjacency list representation of the graph using a 2D vector graph, where graph[i] contains the neighbors of node i. This is done by iterating through the edges vector and adding each edge to the graph.\\n\\n2. Initialize Variables: Initialize a variable res to keep track of the number of complete components. Also, create a boolean vector visited of size n to keep track of visited nodes.\\n\\n3. Iterate Through Nodes: Iterate through all nodes in the graph from 0 to n-1.\\n\\n4. DFS (Depth-First Search):\\n\\n    - If the current node has not been visited (!visited[i]), initiate a DFS from this node.\\n    - In the DFS, the dfs function is called, which:\\n      Marks the current node as visited.\\n    - Increments the node count (number of nodes in the current component).\\n    - Increments the edge_c count by the number of neighbors (edges) of the current node.\\n    - Recursively explores unvisited neighbors.\\n    - Check for Complete Component:\\n\\n5. After the DFS, check if the current component is complete. A component is considered complete if the number of nodes (node) multiplied by (node-1) equals the number of edges (edge_c). If this condition is met, increment the res count.\\nReturn the Result:\\n\\n6. After iterating through all nodes, the function returns the total count of complete components, which is stored in the res variable.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&graph,int curr, vector<bool>&visited, int &node,int &edge_c){\\n        visited[curr]=true;\\n        node+=1;\\n        edge_c+=graph[curr].size();\\n        for(int nex: graph[curr]){\\n            if(!visited[nex]){\\n                dfs(graph,nex,visited,node,edge_c);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for(auto edge: edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);        \\n        }int res=0;\\n        vector<bool> visited(n);\\n        for(int i=0;i<n;i++){\\n            int node=0,edge_c=0;\\n            if(!visited[i]){\\n                dfs(graph,i,visited,node,edge_c);\\n                if(node*(node-1)==edge_c){ res+=1;}\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&graph,int curr, vector<bool>&visited, int &node,int &edge_c){\\n        visited[curr]=true;\\n        node+=1;\\n        edge_c+=graph[curr].size();\\n        for(int nex: graph[curr]){\\n            if(!visited[nex]){\\n                dfs(graph,nex,visited,node,edge_c);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for(auto edge: edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);        \\n        }int res=0;\\n        vector<bool> visited(n);\\n        for(int i=0;i<n;i++){\\n            int node=0,edge_c=0;\\n            if(!visited[i]){\\n                dfs(graph,i,visited,node,edge_c);\\n                if(node*(node-1)==edge_c){ res+=1;}\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015890,
                "title": "easy-cpp-dfs-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart DFS from each and every unvisited node of the graph.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart DFS from each and every unvisited node of the graph and then put the node values in a list and then check if there exist a edge between all the pairs of nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(vector<std::vector<int>> &edgelst,vector<int>& subans,vector<bool>& visited,int startver)\\n{  \\n    if(visited[startver]==true)\\n    {\\n        return;\\n    }\\n     subans.push_back(startver);\\n     visited[startver]=true;\\n    for(int i=0;i<edgelst[startver].size();i++)\\n    {\\n           // visited[edgelst[startver][i]]==true;\\n            dfs(edgelst,subans,visited,edgelst[startver][i]);\\n        \\n    }\\n    return;\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<bool>visited;\\n        for(int i=0;i<n;i++)\\n        {\\n            visited.push_back(false);\\n        }\\n      std::vector<std::vector<int>> edgelst(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            edgelst[edges[i][0]].push_back(edges[i][1]);\\n            edgelst[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<visited.size();i++)\\n        {\\n            if(visited[i]==false)\\n            {\\n                vector<int>subans;\\n                dfs(edgelst,subans,visited,i);\\n             \\n                cout<<endl;\\n                bool flag=true;\\n                for(int i=0;i<subans.size();i++)\\n                {\\n                    for(int j=i+1;j<subans.size();j++)\\n                    {\\n                        if (!(std::find(edgelst[subans[i]].begin(), edgelst[subans[i]].end(), subans[j]) != edgelst[subans[i]].end())) {\\n                           flag=false;\\n                        }\\n                    }\\n                }\\n                if(flag==true)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<std::vector<int>> &edgelst,vector<int>& subans,vector<bool>& visited,int startver)\\n{  \\n    if(visited[startver]==true)\\n    {\\n        return;\\n    }\\n     subans.push_back(startver);\\n     visited[startver]=true;\\n    for(int i=0;i<edgelst[startver].size();i++)\\n    {\\n           // visited[edgelst[startver][i]]==true;\\n            dfs(edgelst,subans,visited,edgelst[startver][i]);\\n        \\n    }\\n    return;\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<bool>visited;\\n        for(int i=0;i<n;i++)\\n        {\\n            visited.push_back(false);\\n        }\\n      std::vector<std::vector<int>> edgelst(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            edgelst[edges[i][0]].push_back(edges[i][1]);\\n            edgelst[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<visited.size();i++)\\n        {\\n            if(visited[i]==false)\\n            {\\n                vector<int>subans;\\n                dfs(edgelst,subans,visited,i);\\n             \\n                cout<<endl;\\n                bool flag=true;\\n                for(int i=0;i<subans.size();i++)\\n                {\\n                    for(int j=i+1;j<subans.size();j++)\\n                    {\\n                        if (!(std::find(edgelst[subans[i]].begin(), edgelst[subans[i]].end(), subans[j]) != edgelst[subans[i]].end())) {\\n                           flag=false;\\n                        }\\n                    }\\n                }\\n                if(flag==true)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4002576,
                "title": "dfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(E+V)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(E+V)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        from collections import deque,defaultdict\\n        adj = defaultdict(list)\\n        visited = [False]*(n)\\n        count = 0\\n        for i in edges:\\n            adj[i[0]]+=[i[1]]\\n            adj[i[1]]+=[i[0]]\\n        for i in range(n):\\n            v = 0\\n            ce = 0\\n            if not visited[i]:\\n                q = deque()\\n                q.append(i)\\n                visited[i] = True\\n                while q:\\n                    \\n                    node = q.popleft()\\n                    v+=1\\n                    ce+=len(adj[node])\\n                    for x in adj[node]:\\n                        if not visited[x]:\\n                            q.append(x)\\n                            visited[x] = True\\n                if ce == v*(v-1):\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        from collections import deque,defaultdict\\n        adj = defaultdict(list)\\n        visited = [False]*(n)\\n        count = 0\\n        for i in edges:\\n            adj[i[0]]+=[i[1]]\\n            adj[i[1]]+=[i[0]]\\n        for i in range(n):\\n            v = 0\\n            ce = 0\\n            if not visited[i]:\\n                q = deque()\\n                q.append(i)\\n                visited[i] = True\\n                while q:\\n                    \\n                    node = q.popleft()\\n                    v+=1\\n                    ce+=len(adj[node])\\n                    for x in adj[node]:\\n                        if not visited[x]:\\n                            q.append(x)\\n                            visited[x] = True\\n                if ce == v*(v-1):\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998432,
                "title": "c-simple-traversal-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int start, vector<int> &vis, vector<int> adj[], vector<int> &temp){\\n    vis[start] = 1;\\n    temp.push_back(start);\\n    for(auto it : adj[start]){\\n        if(vis[it]==0){\\n            dfs(it, vis, adj, temp);\\n        }\\n    }\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                vector<int> temp;\\n                dfs(i, vis, adj, temp);\\n                int count = 0;\\n                for(int i=0;i<temp.size();i++){\\n                    if(adj[temp[i]].size()==temp.size()-1){\\n                        count++;\\n                    }\\n                }\\n                if(count==temp.size()) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int start, vector<int> &vis, vector<int> adj[], vector<int> &temp){\\n    vis[start] = 1;\\n    temp.push_back(start);\\n    for(auto it : adj[start]){\\n        if(vis[it]==0){\\n            dfs(it, vis, adj, temp);\\n        }\\n    }\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                vector<int> temp;\\n                dfs(i, vis, adj, temp);\\n                int count = 0;\\n                for(int i=0;i<temp.size();i++){\\n                    if(adj[temp[i]].size()==temp.size()-1){\\n                        count++;\\n                    }\\n                }\\n                if(count==temp.size()) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989666,
                "title": "using-bfs-beats-97-of-users",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool BFSUtils(vector<vector<int>>& adjList, int v, vector<int> &visited){\\n        int count_edges = 0;\\n        int count_nodes = 0;\\n        queue<int> q;\\n        q.push(v);\\n        visited[v] = 1;\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n\\n            count_edges += adjList[front].size();\\n            count_nodes++;\\n\\n            for(auto x : adjList[front]){\\n                if(visited[x] == 0){\\n                    q.push(x);\\n                    visited[x] = 1;\\n                }\\n            }\\n        }\\n        count_edges = count_edges/2;\\n        if(count_edges ==  ((count_nodes*(count_nodes-1))/2))\\n           return true;\\n\\n        return false;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adjList(n);\\n\\n        for(int i=0 ; i<edges.size() ; ++i){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adjList[u].push_back(v);\\n            adjList[v].push_back(u);\\n        }\\n\\n        vector<int> visited(n, 0);\\n        int ans = 0;\\n        for(int v=0 ; v<n ; v++){\\n            if(visited[v] == 0){\\n                bool isCompleteComponent = BFSUtils(adjList, v, visited);\\n                if(isCompleteComponent)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool BFSUtils(vector<vector<int>>& adjList, int v, vector<int> &visited){\\n        int count_edges = 0;\\n        int count_nodes = 0;\\n        queue<int> q;\\n        q.push(v);\\n        visited[v] = 1;\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n\\n            count_edges += adjList[front].size();\\n            count_nodes++;\\n\\n            for(auto x : adjList[front]){\\n                if(visited[x] == 0){\\n                    q.push(x);\\n                    visited[x] = 1;\\n                }\\n            }\\n        }\\n        count_edges = count_edges/2;\\n        if(count_edges ==  ((count_nodes*(count_nodes-1))/2))\\n           return true;\\n\\n        return false;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adjList(n);\\n\\n        for(int i=0 ; i<edges.size() ; ++i){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adjList[u].push_back(v);\\n            adjList[v].push_back(u);\\n        }\\n\\n        vector<int> visited(n, 0);\\n        int ans = 0;\\n        for(int v=0 ; v<n ; v++){\\n            if(visited[v] == 0){\\n                bool isCompleteComponent = BFSUtils(adjList, v, visited);\\n                if(isCompleteComponent)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981912,
                "title": "dfs-cpp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool>v1,v2;\\n    vector<vector<int>>g;\\n\\n    void dfs(int ind)\\n    {\\n        if(v1[ind]==true) return;\\n        v1[ind] = true;\\n        v2[ind] = true;\\n        for(auto x : g[ind])\\n        {\\n            dfs(x);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        v1.resize(n,false);\\n        v2.resize(n,false);\\n        g = vector<vector<int>>(n);\\n        vector<int> incount(n,0);\\n\\n        for(auto x : edges)\\n        {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n            incount[x[0]]++;\\n            incount[x[1]]++;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < n ; i++)\\n        {       \\n            if(v1[i]==false)\\n            {\\n                v2.clear();\\n                v2 = vector<bool>(n,false);\\n                dfs(i);\\n                ans = ans + 1;\\n                int total = 0;\\n                for(auto x : v2){if(x==true)total++;}\\n                for(int j = 0; j < n ; j++)\\n                {\\n                    if(v2[j] == true)\\n                    {\\n                        if(incount[j]!=total-1){ans--;break;}\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool>v1,v2;\\n    vector<vector<int>>g;\\n\\n    void dfs(int ind)\\n    {\\n        if(v1[ind]==true) return;\\n        v1[ind] = true;\\n        v2[ind] = true;\\n        for(auto x : g[ind])\\n        {\\n            dfs(x);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        v1.resize(n,false);\\n        v2.resize(n,false);\\n        g = vector<vector<int>>(n);\\n        vector<int> incount(n,0);\\n\\n        for(auto x : edges)\\n        {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n            incount[x[0]]++;\\n            incount[x[1]]++;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < n ; i++)\\n        {       \\n            if(v1[i]==false)\\n            {\\n                v2.clear();\\n                v2 = vector<bool>(n,false);\\n                dfs(i);\\n                ans = ans + 1;\\n                int total = 0;\\n                for(auto x : v2){if(x==true)total++;}\\n                for(int j = 0; j < n ; j++)\\n                {\\n                    if(v2[j] == true)\\n                    {\\n                        if(incount[j]!=total-1){ans--;break;}\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972273,
                "title": "python-clean-and-simple-dsu",
                "content": "```\\nfrom collections import Counter, defaultdict\\nfrom dataclasses import dataclass, field\\nfrom math import comb\\n\\n\\n@dataclass\\nclass Group:\\n    nodes: int = field(init=False, default=0)\\n    edges: int = field(init=False, default=0)\\n\\n    @property\\n    def is_completely_connected(self) -> bool:\\n        return comb(self.nodes, 2) == self.edges // 2\\n\\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: list[list[int]]) -> int:\\n        uf = UF(n)\\n\\n        edge_cnt = Counter()\\n\\n        for a, b in edges:\\n            uf.union(a, b)\\n\\n            edge_cnt[a] += 1\\n            edge_cnt[b] += 1\\n\\n        groups = defaultdict(Group)\\n\\n        for u in range(n):\\n            p = uf.find(u)\\n\\n            g = groups[p]\\n            g.nodes += 1\\n            g.edges += edge_cnt[u]\\n\\n        return sum(g.is_completely_connected for g in groups.values())\\n```\\n\\nDefinition of **UF**,\\n\\n```python\\nfrom dataclasses import dataclass\\nfrom functools import cached_property\\n\\n\\n@dataclass(frozen=True)\\nclass UF:\\n    \"\"\"\\n    Implementing union find algorithm\\n    \"\"\"\\n    node_count: int\\n\\n    def find(self, u: int) -> int:\\n        \"\"\"\\n        :return: representative node of cluster containing node \"u\"\\n        \"\"\"\\n        parent = self._parent\\n\\n        if u != (pu := parent[u]):\\n            parent[u] = self.find(pu)  # path compression\\n\\n        return parent[u]\\n\\n    def union(self, u: int, v: int) -> bool:\\n        \"\"\"\\n        merging clusters containing node \"u\" and node \"v\"\\n        :param u:\\n        :param v:\\n        :return: True if union/merge is needed else False\\n        \"\"\"\\n        root_u, root_v = self.find(u), self.find(v)\\n\\n        if root_u != root_v:\\n            self._merge_roots(root_u, root_v)\\n\\n        return root_u != root_v\\n\\n    def _merge_roots(self, u: int, v: int):\\n        \"\"\"\\n        \"u\" and \"v\" are root nodes of two different clusters and the two\\n        clusters are to be merged. In this function, we determine which\\n        node should be made parent using rank and update parent accordingly.\\n\\n        Node with higher rank is made parent and in case of tie, \"v\" (\"u\" can\\n        also be chosen) node is chosen as parent and its rank is incremented\\n        by 1\\n\\n        :param u:\\n        :param v:\\n        \"\"\"\\n        rank = self._rank\\n\\n        if rank[u] > rank[v]:\\n            self._parent[v] = u\\n        else:\\n            self._parent[u] = v\\n\\n            if rank[u] == rank[v]:\\n                self._rank[v] += 1\\n\\n    @cached_property\\n    def _parent(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is the ith element and value\\n                 is its corresponding parent\\n        \"\"\"\\n        return list(range(self.node_count))\\n\\n    @cached_property\\n    def _rank(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is ith node element and value\\n        is its rank. Rank is used while merging clusters\\n        \"\"\"\\n        return [1] * self.node_count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter, defaultdict\\nfrom dataclasses import dataclass, field\\nfrom math import comb\\n\\n\\n@dataclass\\nclass Group:\\n    nodes: int = field(init=False, default=0)\\n    edges: int = field(init=False, default=0)\\n\\n    @property\\n    def is_completely_connected(self) -> bool:\\n        return comb(self.nodes, 2) == self.edges // 2\\n\\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: list[list[int]]) -> int:\\n        uf = UF(n)\\n\\n        edge_cnt = Counter()\\n\\n        for a, b in edges:\\n            uf.union(a, b)\\n\\n            edge_cnt[a] += 1\\n            edge_cnt[b] += 1\\n\\n        groups = defaultdict(Group)\\n\\n        for u in range(n):\\n            p = uf.find(u)\\n\\n            g = groups[p]\\n            g.nodes += 1\\n            g.edges += edge_cnt[u]\\n\\n        return sum(g.is_completely_connected for g in groups.values())\\n```\n```python\\nfrom dataclasses import dataclass\\nfrom functools import cached_property\\n\\n\\n@dataclass(frozen=True)\\nclass UF:\\n    \"\"\"\\n    Implementing union find algorithm\\n    \"\"\"\\n    node_count: int\\n\\n    def find(self, u: int) -> int:\\n        \"\"\"\\n        :return: representative node of cluster containing node \"u\"\\n        \"\"\"\\n        parent = self._parent\\n\\n        if u != (pu := parent[u]):\\n            parent[u] = self.find(pu)  # path compression\\n\\n        return parent[u]\\n\\n    def union(self, u: int, v: int) -> bool:\\n        \"\"\"\\n        merging clusters containing node \"u\" and node \"v\"\\n        :param u:\\n        :param v:\\n        :return: True if union/merge is needed else False\\n        \"\"\"\\n        root_u, root_v = self.find(u), self.find(v)\\n\\n        if root_u != root_v:\\n            self._merge_roots(root_u, root_v)\\n\\n        return root_u != root_v\\n\\n    def _merge_roots(self, u: int, v: int):\\n        \"\"\"\\n        \"u\" and \"v\" are root nodes of two different clusters and the two\\n        clusters are to be merged. In this function, we determine which\\n        node should be made parent using rank and update parent accordingly.\\n\\n        Node with higher rank is made parent and in case of tie, \"v\" (\"u\" can\\n        also be chosen) node is chosen as parent and its rank is incremented\\n        by 1\\n\\n        :param u:\\n        :param v:\\n        \"\"\"\\n        rank = self._rank\\n\\n        if rank[u] > rank[v]:\\n            self._parent[v] = u\\n        else:\\n            self._parent[u] = v\\n\\n            if rank[u] == rank[v]:\\n                self._rank[v] += 1\\n\\n    @cached_property\\n    def _parent(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is the ith element and value\\n                 is its corresponding parent\\n        \"\"\"\\n        return list(range(self.node_count))\\n\\n    @cached_property\\n    def _rank(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is ith node element and value\\n        is its rank. Rank is used while merging clusters\\n        \"\"\"\\n        return [1] * self.node_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969884,
                "title": "c-easy-fast-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int node,vector<bool> &vis,int &v,int &edge)\\n    {\\n        vis[node]=true;\\n\\n        v++;\\n        edge+=adj[node].size();\\n\\n        for(auto it:adj[node])\\n        {\\n            if(vis[it]==false)\\n            {\\n                dfs(adj,it,vis,v,edge);\\n            }\\n        }\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n];\\n        vector<bool> vis(n,false);\\n        int ans=0;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==false)\\n            {\\n                int v=0,edge=0;\\n                dfs(adj,i,vis,v,edge);\\n                if(edge==v*(v-1))\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int node,vector<bool> &vis,int &v,int &edge)\\n    {\\n        vis[node]=true;\\n\\n        v++;\\n        edge+=adj[node].size();\\n\\n        for(auto it:adj[node])\\n        {\\n            if(vis[it]==false)\\n            {\\n                dfs(adj,it,vis,v,edge);\\n            }\\n        }\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n];\\n        vector<bool> vis(n,false);\\n        int ans=0;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==false)\\n            {\\n                int v=0,edge=0;\\n                dfs(adj,i,vis,v,edge);\\n                if(edge==v*(v-1))\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966826,
                "title": "easy-explanation-simple-dfs-connected-component-complete-graph",
                "content": "# Intuition\\n        \\nFor connected component (acc to Question) \\neach pair of vertices should have edge **(which is somewhat\\\\* to complete graph)**\\n\\nEdge - Vertices Relationship for a Complete Graph : ```|E| = V*(V-1)/2```\\n\\n\\nSince matrix is given for undirected graph so each edge is encountered twice\\n```eg 1 ---- 2 is same as 2 --- 1``` \\n\\nSo now, edge-vertice relationship : ```|E| = V*(V-1)```\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* use dfs to count number of component\\n* simply count the on edges and vertices in a connected component and use the above eqn to check whether the connected component is a complete graph or not.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int node, vector<int>&vis, int& V, int& E){\\n        vis[node]=1;\\n        V++;\\n        for(auto u :adj[node]){\\n            E++;\\n            if(!vis[u]) dfs(adj,u,vis,V,E);\\n        }\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n\\n        vector<int> adj[n];\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int V=0, E=0;\\n                dfs(adj,i, vis, V, E);\\n\\n                if(E == V*(V-1)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```|E| = V*(V-1)/2```\n```eg 1 ---- 2 is same as 2 --- 1```\n```|E| = V*(V-1)```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int node, vector<int>&vis, int& V, int& E){\\n        vis[node]=1;\\n        V++;\\n        for(auto u :adj[node]){\\n            E++;\\n            if(!vis[u]) dfs(adj,u,vis,V,E);\\n        }\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n\\n        vector<int> adj[n];\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int V=0, E=0;\\n                dfs(adj,i, vis, V, E);\\n\\n                if(E == V*(V-1)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966283,
                "title": "java-union-find-clean",
                "content": "# Code\\n```\\nclass Solution {\\n    class DSU {\\n        public int[] roots;\\n        public int[] sizes;\\n        DSU(int n) {\\n            roots = new int[n];\\n            sizes = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                sizes[i] = 1;\\n                roots[i] = i;\\n            }\\n        }\\n        public int find(int v) {\\n            if (roots[v] != v) {\\n                roots[v] = find(roots[v]);\\n            }\\n            return roots[v];\\n        }\\n\\n        public void union(int a, int b) {\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            if (rootA == rootB) {\\n                return;\\n            }\\n            roots[rootB] = rootA;\\n            sizes[rootA] += sizes[rootB];\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        DSU dsu = new DSU(n);\\n        int[] indegree = new int[n];\\n        for (int[] e : edges) {\\n            dsu.union(e[0], e[1]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n\\n        int[] gcount = new int[n];\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int root = dsu.find(i);\\n            if (dsu.sizes[root] == (indegree[i]+1)) {\\n                gcount[root]++;\\n            }\\n            if (gcount[root] == dsu.sizes[root]) {\\n                res++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class DSU {\\n        public int[] roots;\\n        public int[] sizes;\\n        DSU(int n) {\\n            roots = new int[n];\\n            sizes = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                sizes[i] = 1;\\n                roots[i] = i;\\n            }\\n        }\\n        public int find(int v) {\\n            if (roots[v] != v) {\\n                roots[v] = find(roots[v]);\\n            }\\n            return roots[v];\\n        }\\n\\n        public void union(int a, int b) {\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            if (rootA == rootB) {\\n                return;\\n            }\\n            roots[rootB] = rootA;\\n            sizes[rootA] += sizes[rootB];\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        DSU dsu = new DSU(n);\\n        int[] indegree = new int[n];\\n        for (int[] e : edges) {\\n            dsu.union(e[0], e[1]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n\\n        int[] gcount = new int[n];\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int root = dsu.find(i);\\n            if (dsu.sizes[root] == (indegree[i]+1)) {\\n                gcount[root]++;\\n            }\\n            if (gcount[root] == dsu.sizes[root]) {\\n                res++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965908,
                "title": "solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncounting no of edges between the vertices and checking count of edges = (no.of vertices)*(no.of vertices-1)/2\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS and indegree\\n\\n# Complexity\\n- Time complexity:$$$O(n^2)$$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int [] con = new int [n];\\n        boolean [] vis = new boolean [n];\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            int x =edges[i][0];\\n            int y= edges[i][1];\\n\\n            adj.get(x).add(y);\\n            adj.get(y).add(x);\\n            con[x]++;\\n            con[y]++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==false){\\n                ans+= bfs(i,adj,vis,con);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int bfs(int indx,ArrayList<ArrayList<Integer>> adj,boolean [] vis ,int [] con){\\n        int count =0;\\n        int num=0;\\n        Queue<Integer> q= new LinkedList<>();\\n        q.add(indx);\\n        while(!q.isEmpty()){\\n            int curr = q.poll();\\n            if(vis[curr]==false){\\n                num++;\\n                vis[curr]=true;\\n                count += con[curr];\\n                for(int i:adj.get(curr)){\\n                    q.add(i);\\n                }\\n            }  \\n        }\\n        if(count ==(num*(num-1))) return 1;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int [] con = new int [n];\\n        boolean [] vis = new boolean [n];\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            int x =edges[i][0];\\n            int y= edges[i][1];\\n\\n            adj.get(x).add(y);\\n            adj.get(y).add(x);\\n            con[x]++;\\n            con[y]++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==false){\\n                ans+= bfs(i,adj,vis,con);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int bfs(int indx,ArrayList<ArrayList<Integer>> adj,boolean [] vis ,int [] con){\\n        int count =0;\\n        int num=0;\\n        Queue<Integer> q= new LinkedList<>();\\n        q.add(indx);\\n        while(!q.isEmpty()){\\n            int curr = q.poll();\\n            if(vis[curr]==false){\\n                num++;\\n                vis[curr]=true;\\n                count += con[curr];\\n                for(int i:adj.get(curr)){\\n                    q.add(i);\\n                }\\n            }  \\n        }\\n        if(count ==(num*(num-1))) return 1;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962575,
                "title": "well-commented-dfs-solution-one-trivial-optimization-also-included",
                "content": "# Intuition\\nVery simple intuition. Complete component => All nodes should be connected to eachother in a component. So we have to, \\n1. Identify the components\\n2. Check node in the component is connected to every other node\\n\\nSimple!\\n\\n# Approach\\n1. DFS starting from every node\\n2. Accumulate all nodes in a list. This is the \"path\"\\n3. Check if each entry in the path we just found is having connections to every other entry in the path\\n\\n# Complexity\\n- Time complexity:\\nO(n) to do DFS, O(n) INSIDE each DFS to check if path is fully connected \\n=> OVERALL O(n^2) CORRECT ME IF I\\'M WRONG\\n\\n- Space complexity:\\n    O(n) for the stack recursion, O(n) for storing the path, O(n) for the hashSet (optimization)\\n=> OVERALL O(n) since no nesting is occuring. After the entire DFS stack is popped out, we use the stored path to verify completeness.\\n\\nWell commented, read the comments and you\\'ll understand. Hope this helps.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        #region Adjacency List and seen initialization\\n        List<int>[] adjList = new List<int>[n]; bool[] seen = new bool[n];\\n        for(int i = 0; i < n; i++){\\n            adjList[i] = new List<int>();\\n        }\\n        foreach(int[] edge in edges){\\n            adjList[edge[0]].Add(edge[1]); adjList[edge[1]].Add(edge[0]);\\n        }\\n        #endregion\\n\\n        //Start DFS on every element to find all connected components\\n        List<int> path = new(); //Store all elements in a path in path list\\n        int count = 0; //Keep track of connected components\\n        for(int i = 0; i < n; i++){\\n            if(!seen[i]){\\n                DFS(i);\\n                //Increment count based on if path fully is connected\\n                count += CheckIfCompleteComponent(); \\n                path.Clear(); //Start exploring new path\\n            }\\n        }\\n\\n        return count;\\n\\n        //Very simple DFS function, nothing fancy\\n        void DFS(int curr){\\n            if(seen[curr]) return;\\n\\n            seen[curr] = true; path.Add(curr);\\n            foreach(int entry in adjList[curr]){\\n                DFS(entry);\\n            }\\n        }\\n\\n        //Function to check if path accumulated is complete or not\\n        int CheckIfCompleteComponent(){ //Only 2 (1 and 2) criteria\\n            HashSet<int> set = new(); //Quickly creating a hashset for easy lookup\\n            foreach(int entry in path){ set.Add(entry); }\\n\\n            foreach(int pathEntry in path){\\n                //(1) Each member in path should contain connections to all other membes in path\\n                //First we check the count (-1 because it won\\'t contain that starting point itself)\\n                if(adjList[pathEntry].Count != path.Count - 1){ \\n                    return 0; \\n                }\\n                else{ //(2) Checking if each element is contained in it. \\n                    foreach(int adjListEntry in adjList[pathEntry]){\\n                        if(!set.Contains(adjListEntry)){ \\n                            return 0; \\n                        }\\n                    }\\n                }\\n            }\\n            return 1; //If not a valid path, return 0, else return 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        #region Adjacency List and seen initialization\\n        List<int>[] adjList = new List<int>[n]; bool[] seen = new bool[n];\\n        for(int i = 0; i < n; i++){\\n            adjList[i] = new List<int>();\\n        }\\n        foreach(int[] edge in edges){\\n            adjList[edge[0]].Add(edge[1]); adjList[edge[1]].Add(edge[0]);\\n        }\\n        #endregion\\n\\n        //Start DFS on every element to find all connected components\\n        List<int> path = new(); //Store all elements in a path in path list\\n        int count = 0; //Keep track of connected components\\n        for(int i = 0; i < n; i++){\\n            if(!seen[i]){\\n                DFS(i);\\n                //Increment count based on if path fully is connected\\n                count += CheckIfCompleteComponent(); \\n                path.Clear(); //Start exploring new path\\n            }\\n        }\\n\\n        return count;\\n\\n        //Very simple DFS function, nothing fancy\\n        void DFS(int curr){\\n            if(seen[curr]) return;\\n\\n            seen[curr] = true; path.Add(curr);\\n            foreach(int entry in adjList[curr]){\\n                DFS(entry);\\n            }\\n        }\\n\\n        //Function to check if path accumulated is complete or not\\n        int CheckIfCompleteComponent(){ //Only 2 (1 and 2) criteria\\n            HashSet<int> set = new(); //Quickly creating a hashset for easy lookup\\n            foreach(int entry in path){ set.Add(entry); }\\n\\n            foreach(int pathEntry in path){\\n                //(1) Each member in path should contain connections to all other membes in path\\n                //First we check the count (-1 because it won\\'t contain that starting point itself)\\n                if(adjList[pathEntry].Count != path.Count - 1){ \\n                    return 0; \\n                }\\n                else{ //(2) Checking if each element is contained in it. \\n                    foreach(int adjListEntry in adjList[pathEntry]){\\n                        if(!set.Contains(adjListEntry)){ \\n                            return 0; \\n                        }\\n                    }\\n                }\\n            }\\n            return 1; //If not a valid path, return 0, else return 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960232,
                "title": "time-complexity-yes",
                "content": "- Time/Space complexity:\\n$$O(infinity)$$\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n    if not edges:\\n      return n\\n\\n    # visited vertices & edges\\n    visited = set()\\n    visited_edges = set()\\n\\n    # groups\\n    g = defaultdict(int)\\n\\n    # connectivity\\n    c = defaultdict(set)\\n    for edge in edges:\\n      c[edge[0]].add(edge[1])\\n      c[edge[1]].add(edge[0])\\n\\n    def dfs(edge_index, color):\\n      if edge_index in visited_edges:\\n        return\\n      visited_edges.add(edge_index)\\n      try:\\n        if edge_index not in c:\\n          raise IndexError\\n        for vertex in c[edge_index]:\\n          if vertex in visited:\\n            continue\\n          dfs(vertex, color)\\n          visited.add(vertex)\\n          g[vertex] = color\\n      except IndexError:\\n        visited.add(edge_index)\\n        g[edge_index] = color\\n\\n    color = 1\\n\\n    for v in range(n):\\n      if g[v] == 0:\\n        dfs(v, color)\\n        color += 1\\n    \\n    # not filtered groups\\n    allg = set(g.values())\\n    # number of elements in each group\\n    gc = Counter(g.values())\\n\\n    # complete groups filter\\n    invalidated = set()\\n    for gr in allg:\\n      for k,v in c.items():\\n        # if vertex belongs to a group we currently checking &\\n        # this vertex connected to less than group size - 1 neighbors\\n        if g[k] == gr and len(c[k]) < gc[gr]-1:\\n          invalidated.add(gr)\\n    \\n    allg = allg.difference(invalidated)\\n    return len(allg)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n    if not edges:\\n      return n\\n\\n    # visited vertices & edges\\n    visited = set()\\n    visited_edges = set()\\n\\n    # groups\\n    g = defaultdict(int)\\n\\n    # connectivity\\n    c = defaultdict(set)\\n    for edge in edges:\\n      c[edge[0]].add(edge[1])\\n      c[edge[1]].add(edge[0])\\n\\n    def dfs(edge_index, color):\\n      if edge_index in visited_edges:\\n        return\\n      visited_edges.add(edge_index)\\n      try:\\n        if edge_index not in c:\\n          raise IndexError\\n        for vertex in c[edge_index]:\\n          if vertex in visited:\\n            continue\\n          dfs(vertex, color)\\n          visited.add(vertex)\\n          g[vertex] = color\\n      except IndexError:\\n        visited.add(edge_index)\\n        g[edge_index] = color\\n\\n    color = 1\\n\\n    for v in range(n):\\n      if g[v] == 0:\\n        dfs(v, color)\\n        color += 1\\n    \\n    # not filtered groups\\n    allg = set(g.values())\\n    # number of elements in each group\\n    gc = Counter(g.values())\\n\\n    # complete groups filter\\n    invalidated = set()\\n    for gr in allg:\\n      for k,v in c.items():\\n        # if vertex belongs to a group we currently checking &\\n        # this vertex connected to less than group size - 1 neighbors\\n        if g[k] == gr and len(c[k]) < gc[gr]-1:\\n          invalidated.add(gr)\\n    \\n    allg = allg.difference(invalidated)\\n    return len(allg)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958144,
                "title": "99-faster-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n+e)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+e)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,int &v,int &e,vector<bool>&visited,vector<vector<int>>&adj)\\n    {\\n        visited[node]=true;\\n        v++;\\n        e = e + adj[node].size();\\n    \\n        for(auto nbr : adj[node])\\n        {\\n            if(!visited[nbr])\\n            {\\n                dfs(nbr,v,e,visited,adj);\\n            }\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        for (const auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<bool>visited(n,false);\\n        int count = 0;\\n\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int v=0;\\n                int e=0;\\n                dfs(i,v,e,visited,adj);\\n\\n                if(e == v * (v-1) )count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,int &v,int &e,vector<bool>&visited,vector<vector<int>>&adj)\\n    {\\n        visited[node]=true;\\n        v++;\\n        e = e + adj[node].size();\\n    \\n        for(auto nbr : adj[node])\\n        {\\n            if(!visited[nbr])\\n            {\\n                dfs(nbr,v,e,visited,adj);\\n            }\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        for (const auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<bool>visited(n,false);\\n        int count = 0;\\n\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int v=0;\\n                int e=0;\\n                dfs(i,v,e,visited,adj);\\n\\n                if(e == v * (v-1) )count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956134,
                "title": "explained-in-comments-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs( int node, int & size, vector<int> adj[],  vector<int> & vis, vector<int> & all ){\\n        vis[node] = 1;\\n        size ++;\\n        all.push_back(node);\\n\\n        for( auto it : adj[node] ){\\n            if( vis[it] == 0 ) dfs(it, size, adj,vis,all);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n]; // adjacency array\\n        vector<int> vis(n,0); // visited array\\n\\n        for( int i = 0; i<edges.size(); i++ ){ // creating the adjacency array\\n            vector<int> temp = edges[i];\\n            adj[temp[0]].push_back(temp[1]);\\n            adj[temp[1]].push_back(temp[0]);\\n        }\\n\\n\\n        int ans = 0; // to keep a count of the number of complete components\\n\\n        // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat\\n\\n        for( int i = 0; i<n; i++ ){ \\n            if( vis[i] == 0 ) {\\n                // call dfs -> this function will traverse to all the nodes in a component\\n                int size = 0; // to store the number of nodes in that component\\n                vector<int> all; // we need to know who all nodes are there in that component so that we can check if its connected to all others\\n                dfs(i, size, adj,vis, all);\\n                bool check = true; // to check if \"ALL\" the nodes fulfill the requirement\\n                for( int j = 0; j<all.size(); j++ ){\\n                    vector<int> node = adj[all[j]];\\n                    if( node.size() < size-1 ) check = false;\\n                }\\n                if( check == true ) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs( int node, int & size, vector<int> adj[],  vector<int> & vis, vector<int> & all ){\\n        vis[node] = 1;\\n        size ++;\\n        all.push_back(node);\\n\\n        for( auto it : adj[node] ){\\n            if( vis[it] == 0 ) dfs(it, size, adj,vis,all);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n]; // adjacency array\\n        vector<int> vis(n,0); // visited array\\n\\n        for( int i = 0; i<edges.size(); i++ ){ // creating the adjacency array\\n            vector<int> temp = edges[i];\\n            adj[temp[0]].push_back(temp[1]);\\n            adj[temp[1]].push_back(temp[0]);\\n        }\\n\\n\\n        int ans = 0; // to keep a count of the number of complete components\\n\\n        // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat\\n\\n        for( int i = 0; i<n; i++ ){ \\n            if( vis[i] == 0 ) {\\n                // call dfs -> this function will traverse to all the nodes in a component\\n                int size = 0; // to store the number of nodes in that component\\n                vector<int> all; // we need to know who all nodes are there in that component so that we can check if its connected to all others\\n                dfs(i, size, adj,vis, all);\\n                bool check = true; // to check if \"ALL\" the nodes fulfill the requirement\\n                for( int j = 0; j<all.size(); j++ ){\\n                    vector<int> node = adj[all[j]];\\n                    if( node.size() < size-1 ) check = false;\\n                }\\n                if( check == true ) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952790,
                "title": "cpp-solution-using-dfs-traversal",
                "content": "# Complexity\\n- Time complexity:\\nO(V + E)\\n\\n- Space complexity:\\nO(V + E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<int, list<int>> &m, unordered_map<int, bool> &visited, int src, int &node, int &edge)\\n    {\\n        visited[src] = true;\\n        node++;\\n        edge += m[src].size();\\n\\n        for(auto nbr: m[src])\\n        {\\n            if(!visited[nbr])\\n                dfs(m, visited, nbr, node, edge);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, list<int>>m;\\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            m[u].push_back(v);\\n            m[v].push_back(u);\\n        }\\n\\n        unordered_map<int, bool>visited;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int node = 0, edge = 0;\\n                dfs(m, visited, i, node, edge);\\n                edge /= 2;\\n                if(((node * (node - 1)) / 2) == edge)\\n                    ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\nHope you understand the code.",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<int, list<int>> &m, unordered_map<int, bool> &visited, int src, int &node, int &edge)\\n    {\\n        visited[src] = true;\\n        node++;\\n        edge += m[src].size();\\n\\n        for(auto nbr: m[src])\\n        {\\n            if(!visited[nbr])\\n                dfs(m, visited, nbr, node, edge);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, list<int>>m;\\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            m[u].push_back(v);\\n            m[v].push_back(u);\\n        }\\n\\n        unordered_map<int, bool>visited;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int node = 0, edge = 0;\\n                dfs(m, visited, i, node, edge);\\n                edge /= 2;\\n                if(((node * (node - 1)) / 2) == edge)\\n                    ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951650,
                "title": "easy-to-understand-using-dfs",
                "content": "# Intuition\\nDFS\\n\\n# Approach\\nDFS and check number of nodes ond edges.\\n\\n# Complexity\\n- Time complexity:\\n O( N+M )\\n\\n- Space complexity:\\n O( N+M )\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node, vector<bool>&vis,vector<vector<int>>&adj,int &x,int &y){\\n        vis[node]=true;\\n        x+=adj[node].size();\\n         y++;\\n        for(auto child:adj[node]){\\n            if(!vis[child]){\\n               \\n                dfs(child,vis,adj,x,y);\\n            }\\n        }\\n\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        int k=edges.size();\\n        for(int i=0;i<k;i++){\\n           adj[edges[i][0]].push_back(edges[i][1]);\\n           adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<bool>vis(n);\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            int x=0,y=0;\\n            if(!vis[i]){\\n                dfs(i,vis,adj,x,y);\\n                if(x==(y*(y-1)))cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int node, vector<bool>&vis,vector<vector<int>>&adj,int &x,int &y){\\n        vis[node]=true;\\n        x+=adj[node].size();\\n         y++;\\n        for(auto child:adj[node]){\\n            if(!vis[child]){\\n               \\n                dfs(child,vis,adj,x,y);\\n            }\\n        }\\n\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        int k=edges.size();\\n        for(int i=0;i<k;i++){\\n           adj[edges[i][0]].push_back(edges[i][1]);\\n           adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<bool>vis(n);\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            int x=0,y=0;\\n            if(!vis[i]){\\n                dfs(i,vis,adj,x,y);\\n                if(x==(y*(y-1)))cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949059,
                "title": "c-easy-to-understand-solution",
                "content": "class Solution {\\npublic:\\n  void dfs(int node, int size,vector<int>&vis,vector<int>adj[],bool &f,int &number)\\n  {\\n    vis[node]=1;\\n    if(adj[node].size()!=size)\\n      f=0;\\n    number++;\\n    for(auto it:adj[node])\\n    {\\n      if(vis[it]==0)\\n        dfs(it,size,vis,adj,f,number);\\n    }\\n    \\n  }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n       vector<int>adj[n];\\n      \\n      for(int i=0;i<edges.size();i++)\\n      {\\n        adj[edges[i][0]].push_back(edges[i][1]);\\n         adj[edges[i][1]].push_back(edges[i][0]);\\n      }\\n      \\n      vector<int>vis(n);\\n      int c=0;\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n                  \\n        if(vis[i]==0)\\n        {\\n          bool f=1;\\n          int number=0;\\n          int size=adj[i].size();\\n          dfs(i,size,vis,adj,f,number);\\n          if(f==1 && size==number-1)\\n            c++;\\n        }\\n      }\\n      return c;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n  void dfs(int node, int size,vector<int>&vis,vector<int>adj[],bool &f,int &number)\\n  {\\n    vis[node]=1;\\n    if(adj[node].size()!=size)\\n      f=0;\\n    number++;\\n    for(auto it:adj[node])\\n    {\\n      if(vis[it]==0)\\n        dfs(it,size,vis,adj,f,number);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3945695,
                "title": "c-dfs-and-bfs-both-easiest-approach-killer-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# DFS\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\nint nodec=0;\\nint edgec=0;\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        //vector<int> adj[n];\\n        vector<bool> vis(n,false);\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        for(int i = 0; i < n; i += 1) \\n        {\\n            int nodec = 0,edgec = 0;\\n            if(vis[i]==false) \\n            {\\n                dfs(adj,vis,i,nodec,edgec);\\n                if(nodec*(nodec - 1) == edgec) \\n                ans ++;\\n            }\\n        }\\n        return ans;\\n    }\\n    void dfs(vector<vector<int>>  &adj,vector<bool> &vis,int start,int &nodec,int &edgec)\\n    {\\n\\n        vis[start]=true;\\n        nodec++;\\n        edgec+=adj[start].size();\\n        for(auto x: adj[start])\\n        {\\n            if(vis[x]==false)\\n            {\\n                dfs(adj,vis,x,nodec,edgec);\\n            }\\n        }\\n\\n    }\\n};\\n```\\n# BFS\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                bfs(adj,vis,n,i);\\n            }\\n        }\\n        return ans;\\n    }\\n    void bfs(vector<int> adj[],vector<int> &vis,int n,int start)\\n    {\\n        int nodec=0;\\n        int edgec=0;\\n        queue<int> q;\\n        q.push(start);\\n        vis[start]=1;\\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            q.pop();\\n            nodec++;\\n            for(auto x: adj[u])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    vis[x]=1;\\n                    q.push(x);\\n                }\\n                edgec++;\\n            }\\n        }\\n        if(edgec==nodec*(nodec-1))\\n        ans++;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=0;\\nint nodec=0;\\nint edgec=0;\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        //vector<int> adj[n];\\n        vector<bool> vis(n,false);\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        for(int i = 0; i < n; i += 1) \\n        {\\n            int nodec = 0,edgec = 0;\\n            if(vis[i]==false) \\n            {\\n                dfs(adj,vis,i,nodec,edgec);\\n                if(nodec*(nodec - 1) == edgec) \\n                ans ++;\\n            }\\n        }\\n        return ans;\\n    }\\n    void dfs(vector<vector<int>>  &adj,vector<bool> &vis,int start,int &nodec,int &edgec)\\n    {\\n\\n        vis[start]=true;\\n        nodec++;\\n        edgec+=adj[start].size();\\n        for(auto x: adj[start])\\n        {\\n            if(vis[x]==false)\\n            {\\n                dfs(adj,vis,x,nodec,edgec);\\n            }\\n        }\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint ans=0;\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                bfs(adj,vis,n,i);\\n            }\\n        }\\n        return ans;\\n    }\\n    void bfs(vector<int> adj[],vector<int> &vis,int n,int start)\\n    {\\n        int nodec=0;\\n        int edgec=0;\\n        queue<int> q;\\n        q.push(start);\\n        vis[start]=1;\\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            q.pop();\\n            nodec++;\\n            for(auto x: adj[u])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    vis[x]=1;\\n                    q.push(x);\\n                }\\n                edgec++;\\n            }\\n        }\\n        if(edgec==nodec*(nodec-1))\\n        ans++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945686,
                "title": "simple-bfs",
                "content": "# Code\\n```\\n\\nbool f(int src,vector<int>adj[],vector<bool>&visited)\\n{\\n    int count1 = 0;\\n    int count2 = 0;\\n    queue<int>q;\\n    q.push(src);\\n    visited[src] = true;\\n    while(!q.empty())\\n    {\\n        int a = q.front();\\n        q.pop();\\n        count1++;\\n        count2 += adj[a].size();\\n        for(auto x:adj[a])\\n        {\\n            if(!visited[x])\\n            {\\n                visited[x] = true;\\n                q.push(x);\\n            }\\n        }\\n    }\\n    cout<<count1<<\" \"<<count2<<endl;\\n    count1 = count1 * (count1 - 1);\\n    return count1 == count2;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        vector<int>adj[n];\\n        int count = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<bool>visited(n,false);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                if(f(i,adj,visited))\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nbool f(int src,vector<int>adj[],vector<bool>&visited)\\n{\\n    int count1 = 0;\\n    int count2 = 0;\\n    queue<int>q;\\n    q.push(src);\\n    visited[src] = true;\\n    while(!q.empty())\\n    {\\n        int a = q.front();\\n        q.pop();\\n        count1++;\\n        count2 += adj[a].size();\\n        for(auto x:adj[a])\\n        {\\n            if(!visited[x])\\n            {\\n                visited[x] = true;\\n                q.push(x);\\n            }\\n        }\\n    }\\n    cout<<count1<<\" \"<<count2<<endl;\\n    count1 = count1 * (count1 - 1);\\n    return count1 == count2;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        vector<int>adj[n];\\n        int count = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<bool>visited(n,false);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                if(f(i,adj,visited))\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3942208,
                "title": "easy-union-find-solution",
                "content": "https://youtu.be/uYzdVfnx2UY\\n\\n# Code\\n```\\npublic class Solution {\\n    Dictionary<int, List<int>> adj = new();\\n    int[] parent;\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        parent = new int[n];\\n        Dictionary<int, List<int>> groups = new();\\n        \\n        for (var i = 0; i < n; i++) {\\n            parent[i] = i;\\n            adj[i] = new List<int>();\\n        }\\n\\n        foreach (var edge in edges) {\\n            adj[edge[0]].Add(edge[1]);\\n            adj[edge[1]].Add(edge[0]);\\n            union(edge[0], edge[1]);\\n        }\\n\\n        int comp = 0;\\n\\n        for (var i = 0; i < parent.Length; i++) {\\n            var parent = findParent(i);\\n            if (!groups.ContainsKey(parent)) {\\n                groups[parent] = new List<int>();\\n            }\\n            groups[parent].Add(i);\\n        }\\n\\n        foreach (var group in groups) {\\n            if (isComplete(group.Value)) comp++;\\n        }\\n        return comp;\\n    }\\n\\n    private bool isComplete(List<int> vertices) {\\n        foreach (var v in vertices) {\\n            if (adj[v].Count != vertices.Count - 1) return false;\\n        }\\n        return true;\\n    }\\n\\n    private int findParent(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = findParent(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    private void union(int x, int y) {\\n        parent[findParent(x)] = parent[findParent(y)];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    Dictionary<int, List<int>> adj = new();\\n    int[] parent;\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        parent = new int[n];\\n        Dictionary<int, List<int>> groups = new();\\n        \\n        for (var i = 0; i < n; i++) {\\n            parent[i] = i;\\n            adj[i] = new List<int>();\\n        }\\n\\n        foreach (var edge in edges) {\\n            adj[edge[0]].Add(edge[1]);\\n            adj[edge[1]].Add(edge[0]);\\n            union(edge[0], edge[1]);\\n        }\\n\\n        int comp = 0;\\n\\n        for (var i = 0; i < parent.Length; i++) {\\n            var parent = findParent(i);\\n            if (!groups.ContainsKey(parent)) {\\n                groups[parent] = new List<int>();\\n            }\\n            groups[parent].Add(i);\\n        }\\n\\n        foreach (var group in groups) {\\n            if (isComplete(group.Value)) comp++;\\n        }\\n        return comp;\\n    }\\n\\n    private bool isComplete(List<int> vertices) {\\n        foreach (var v in vertices) {\\n            if (adj[v].Count != vertices.Count - 1) return false;\\n        }\\n        return true;\\n    }\\n\\n    private int findParent(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = findParent(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    private void union(int x, int y) {\\n        parent[findParent(x)] = parent[findParent(y)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930943,
                "title": "simple-bfs-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&lis,set<pair<int,int>>&se)\\n    {\\n        for(int i=0;i<lis.size();i++)\\n        {\\n            for(int j=i+1;j<lis.size();j++)\\n            {\\n                int a=min(lis[i],lis[j]);\\n                int b=max(lis[i],lis[j]);\\n                if(se.find({a,b})==se.end())\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n    vector<int>adj[n];\\n    set<pair<int,int>>se;\\n    int res=0;\\n    for(auto x:edges)\\n    {\\n        adj[x[0]].push_back(x[1]);\\n        adj[x[1]].push_back(x[0]);\\n        se.insert({min(x[0],x[1]),max(x[0],x[1])});\\n\\n    }\\n    vector<int>vis(n);\\n   queue<int>q;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(vis[i])\\n        continue;\\n         \\n        q.push(i);\\n        vector<int>lis;\\n        vis[i]++;\\n        lis.push_back(i);\\n        while(q.size())\\n        {\\n            int k=q.front();\\n            q.pop();\\n            for(auto x:adj[k])\\n            {\\n                if(vis[x])\\n                continue;\\n                vis[x]=1;\\n                lis.push_back(x);\\n                q.push(x);\\n            }\\n        }\\n        if(check(lis,se))\\n        res++;\\n    }\\n    return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&lis,set<pair<int,int>>&se)\\n    {\\n        for(int i=0;i<lis.size();i++)\\n        {\\n            for(int j=i+1;j<lis.size();j++)\\n            {\\n                int a=min(lis[i],lis[j]);\\n                int b=max(lis[i],lis[j]);\\n                if(se.find({a,b})==se.end())\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n    vector<int>adj[n];\\n    set<pair<int,int>>se;\\n    int res=0;\\n    for(auto x:edges)\\n    {\\n        adj[x[0]].push_back(x[1]);\\n        adj[x[1]].push_back(x[0]);\\n        se.insert({min(x[0],x[1]),max(x[0],x[1])});\\n\\n    }\\n    vector<int>vis(n);\\n   queue<int>q;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(vis[i])\\n        continue;\\n         \\n        q.push(i);\\n        vector<int>lis;\\n        vis[i]++;\\n        lis.push_back(i);\\n        while(q.size())\\n        {\\n            int k=q.front();\\n            q.pop();\\n            for(auto x:adj[k])\\n            {\\n                if(vis[x])\\n                continue;\\n                vis[x]=1;\\n                lis.push_back(x);\\n                q.push(x);\\n            }\\n        }\\n        if(check(lis,se))\\n        res++;\\n    }\\n    return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929347,
                "title": "c-simple-dfs-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&adj, vector<bool>&vis, int i, int&curr1, int &curr2)\\n    {\\n        vis[i]=true;\\n        curr1++;\\n        for(int x: adj[i])\\n        {\\n            curr2++;\\n            if(vis[x]==false){dfs(adj, vis, x, curr1, curr2);}\\n        }\\n        return ;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges)\\n    {\\n        vector<vector<int>> adj(n);\\n        for(vector<int>&e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> vis(n, false);\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==false)\\n            {\\n                int curr1 = 0;int curr2 = 0;\\n                dfs(adj, vis, i, curr1, curr2);\\n                if(curr2 == curr1*(curr1-1)){ans++;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Counting",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&adj, vector<bool>&vis, int i, int&curr1, int &curr2)\\n    {\\n        vis[i]=true;\\n        curr1++;\\n        for(int x: adj[i])\\n        {\\n            curr2++;\\n            if(vis[x]==false){dfs(adj, vis, x, curr1, curr2);}\\n        }\\n        return ;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges)\\n    {\\n        vector<vector<int>> adj(n);\\n        for(vector<int>&e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> vis(n, false);\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==false)\\n            {\\n                int curr1 = 0;int curr2 = 0;\\n                dfs(adj, vis, i, curr1, curr2);\\n                if(curr2 == curr1*(curr1-1)){ans++;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928899,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int u, vector<vector<int>>& adj,vector<int>&vis,int& nodes,int& sum){\\n        vis[u]=1;\\n        nodes++;\\n        sum=sum+adj[u].size();\\n        for(auto v:adj[u]){\\n            if(vis[v]==0)dfs(v,adj,vis,nodes,sum);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>vis(n,0);\\n        vector<vector<int>>adj(n);\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            int nodes=0,sum=0;\\n            if(vis[i]==0){\\n                dfs(i,adj,vis,nodes,sum);\\n                if((nodes*(nodes-1)/2)==(sum/2))c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int u, vector<vector<int>>& adj,vector<int>&vis,int& nodes,int& sum){\\n        vis[u]=1;\\n        nodes++;\\n        sum=sum+adj[u].size();\\n        for(auto v:adj[u]){\\n            if(vis[v]==0)dfs(v,adj,vis,nodes,sum);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>vis(n,0);\\n        vector<vector<int>>adj(n);\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            int nodes=0,sum=0;\\n            if(vis[i]==0){\\n                dfs(i,adj,vis,nodes,sum);\\n                if((nodes*(nodes-1)/2)==(sum/2))c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912080,
                "title": "simple-dfs-solution-with-full-explanation",
                "content": "# Intuition\\nThe problem asks us to find the number of complete subgraphs within a given graph. Each complete subgraph is a group of nodes where every node is connected to all other nodes in the group, forming a complete graph structure. We can solve this problem using Depth-First Search (DFS) to explore connected components and checking if they are complete.\\n\\n# Approach\\n1. **Adjacency List:** Create an adjacency list representation of the graph using the given edges. This allows efficient traversal of the graph.\\n\\n2. **DFS Exploration:** Iterate through each unvisited node. Perform a DFS traversal starting from that node. During traversal, keep track of the number of visited nodes (nodeCount) and edges traversed (edgeCount).\\n\\n3. **Complete Subgraph Check:** After the DFS traversal completes, check if the component is complete. A complete subgraph with n nodes has precisely n * (n - 1) edges. Compare edgeCount with nodeCount * (nodeCount - 1) to determine if the component is complete.\\n\\n4. **Count Complete Components:** Increment a count whenever a complete component is found.\\n\\n5. **Result:** Return the total count of complete components.\\n\\n# Complexity\\n- Time complexity:\\n**O(N + E)**\\n\\n- Space complexity:\\n**O(N + E)**\\n\\n# Code\\n```\\nclass Solution {\\n    int edgeCount = 0; // Counter for counting edges during DFS traversal\\n    int nodeCount = 0; // Counter for counting nodes during DFS traversal\\n    \\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int count = 0; // Counter for complete components\\n        \\n        // Create an adjacency list representation of the graph\\n        HashMap<Integer, List<Integer>> adjacencyList = prepareAdjacencyList(edges, n);\\n        \\n        HashSet<Integer> visited = new HashSet<>(); // Set to keep track of visited nodes\\n        \\n        // Iterate through each node in the graph\\n        for(int currentNode : adjacencyList.keySet()){\\n            if(visited.contains(currentNode)) continue; // Skip if already visited\\n            \\n            nodeCount = 0; // Reset nodeCount for each component\\n            edgeCount = 0; // Reset edgeCount for each component\\n            \\n            // Explore the current component using DFS and check if it\\'s complete\\n            if(exploreByDfs(currentNode, adjacencyList, visited) == true){\\n                // If the component is complete, check if it\\'s a complete graph\\n                if(edgeCount == nodeCount * (nodeCount-1)){\\n                    // please refer to line no 42-43, as to why\\n                    // we are doing nodeCount * (nodeCount-1)\\n                    count++; // Increment the count of complete components\\n                }\\n            }\\n        }\\n        return count; // Return the total count of complete components\\n    }\\n\\n    // DFS traversal to explore a component and count nodes and edges\\n    private boolean exploreByDfs(int currentNode, HashMap<Integer, List<Integer>> adjacencyList, HashSet<Integer> visited){\\n        if(visited.contains(currentNode)) return false; // Stop if already visited\\n        nodeCount++; // Increment node count for the current component\\n        visited.add(currentNode); // Mark the current node as visited\\n        \\n        // Traverse neighbors of the current node\\n        for(int neighbour : adjacencyList.get(currentNode)){\\n            // as we are doing direct edgeCount++, hence for\\n            // 2 connected nodes, we\\'ll have 2 edges\\n            edgeCount++; // Increment edge count for each edge traversed\\n            exploreByDfs(neighbour, adjacencyList, visited); // Recursive DFS on neighbors\\n        }\\n\\n        return true; // Indicates that the current component is complete\\n    }\\n\\n    // Function to create an adjacency list representation of the graph\\n    private HashMap<Integer, List<Integer>> prepareAdjacencyList(int[][] edges, int n){\\n        HashMap<Integer, List<Integer>> adjacencyList = new HashMap<>(); // Initialize the adjacency list\\n        \\n        // Populate the adjacency list using the given edges\\n        for(int[] edge : edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            \\n            // Add edges for both nodes in the adjacency list\\n            adjacencyList.putIfAbsent(node1, new ArrayList<>());\\n            adjacencyList.get(node1).add(node2);\\n\\n            adjacencyList.putIfAbsent(node2, new ArrayList<>());\\n            adjacencyList.get(node2).add(node1);\\n        }\\n\\n        // Add nodes with no edges as well\\n        for(int node = 0; node < n; node++){\\n            if(!adjacencyList.containsKey(node)){\\n                adjacencyList.putIfAbsent(node, new ArrayList<>());\\n            }\\n        }\\n        return adjacencyList; // Return the prepared adjacency list\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int edgeCount = 0; // Counter for counting edges during DFS traversal\\n    int nodeCount = 0; // Counter for counting nodes during DFS traversal\\n    \\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int count = 0; // Counter for complete components\\n        \\n        // Create an adjacency list representation of the graph\\n        HashMap<Integer, List<Integer>> adjacencyList = prepareAdjacencyList(edges, n);\\n        \\n        HashSet<Integer> visited = new HashSet<>(); // Set to keep track of visited nodes\\n        \\n        // Iterate through each node in the graph\\n        for(int currentNode : adjacencyList.keySet()){\\n            if(visited.contains(currentNode)) continue; // Skip if already visited\\n            \\n            nodeCount = 0; // Reset nodeCount for each component\\n            edgeCount = 0; // Reset edgeCount for each component\\n            \\n            // Explore the current component using DFS and check if it\\'s complete\\n            if(exploreByDfs(currentNode, adjacencyList, visited) == true){\\n                // If the component is complete, check if it\\'s a complete graph\\n                if(edgeCount == nodeCount * (nodeCount-1)){\\n                    // please refer to line no 42-43, as to why\\n                    // we are doing nodeCount * (nodeCount-1)\\n                    count++; // Increment the count of complete components\\n                }\\n            }\\n        }\\n        return count; // Return the total count of complete components\\n    }\\n\\n    // DFS traversal to explore a component and count nodes and edges\\n    private boolean exploreByDfs(int currentNode, HashMap<Integer, List<Integer>> adjacencyList, HashSet<Integer> visited){\\n        if(visited.contains(currentNode)) return false; // Stop if already visited\\n        nodeCount++; // Increment node count for the current component\\n        visited.add(currentNode); // Mark the current node as visited\\n        \\n        // Traverse neighbors of the current node\\n        for(int neighbour : adjacencyList.get(currentNode)){\\n            // as we are doing direct edgeCount++, hence for\\n            // 2 connected nodes, we\\'ll have 2 edges\\n            edgeCount++; // Increment edge count for each edge traversed\\n            exploreByDfs(neighbour, adjacencyList, visited); // Recursive DFS on neighbors\\n        }\\n\\n        return true; // Indicates that the current component is complete\\n    }\\n\\n    // Function to create an adjacency list representation of the graph\\n    private HashMap<Integer, List<Integer>> prepareAdjacencyList(int[][] edges, int n){\\n        HashMap<Integer, List<Integer>> adjacencyList = new HashMap<>(); // Initialize the adjacency list\\n        \\n        // Populate the adjacency list using the given edges\\n        for(int[] edge : edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            \\n            // Add edges for both nodes in the adjacency list\\n            adjacencyList.putIfAbsent(node1, new ArrayList<>());\\n            adjacencyList.get(node1).add(node2);\\n\\n            adjacencyList.putIfAbsent(node2, new ArrayList<>());\\n            adjacencyList.get(node2).add(node1);\\n        }\\n\\n        // Add nodes with no edges as well\\n        for(int node = 0; node < n; node++){\\n            if(!adjacencyList.containsKey(node)){\\n                adjacencyList.putIfAbsent(node, new ArrayList<>());\\n            }\\n        }\\n        return adjacencyList; // Return the prepared adjacency list\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901204,
                "title": "solution-in-java-indegree-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int[] indegree = new int[n];\\n        for (int[] e : edges) {\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n\\n        int result = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!visited.contains(i)) {\\n                Set<Integer> subGraph = new HashSet<>();\\n\\n                fillSubGraph(i, edges, visited, subGraph);\\n                \\n                int edgeCount = subGraph.size() - 1;\\n                for (int v : subGraph) {\\n                    if (indegree[v] != edgeCount) {\\n                        subGraph.clear();\\n                        break;\\n                    }\\n                }\\n                if (!subGraph.isEmpty()) {\\n                    result++;\\n                }           \\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void fillSubGraph(int source, int[][] edges, Set<Integer> visited, Set<Integer> subGraph) {\\n        if (visited.contains(source)) {\\n            return;\\n        }\\n\\n        visited.add(source);\\n        subGraph.add(source);\\n\\n        for (int[] e : edges) {\\n            if (e[0] == source) {\\n                fillSubGraph(e[1], edges, visited, subGraph);\\n            }\\n            if (e[1] == source) {\\n                fillSubGraph(e[0], edges, visited, subGraph);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int[] indegree = new int[n];\\n        for (int[] e : edges) {\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n\\n        int result = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!visited.contains(i)) {\\n                Set<Integer> subGraph = new HashSet<>();\\n\\n                fillSubGraph(i, edges, visited, subGraph);\\n                \\n                int edgeCount = subGraph.size() - 1;\\n                for (int v : subGraph) {\\n                    if (indegree[v] != edgeCount) {\\n                        subGraph.clear();\\n                        break;\\n                    }\\n                }\\n                if (!subGraph.isEmpty()) {\\n                    result++;\\n                }           \\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void fillSubGraph(int source, int[][] edges, Set<Integer> visited, Set<Integer> subGraph) {\\n        if (visited.contains(source)) {\\n            return;\\n        }\\n\\n        visited.add(source);\\n        subGraph.add(source);\\n\\n        for (int[] e : edges) {\\n            if (e[0] == source) {\\n                fillSubGraph(e[1], edges, visited, subGraph);\\n            }\\n            if (e[1] == source) {\\n                fillSubGraph(e[0], edges, visited, subGraph);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900779,
                "title": "c-easy-and-fast-dfs-recursion",
                "content": "TC:O(N  -->number of nodes)\\nSC:O(2 * N) + Auxiliary stack space \\n```\\nclass Solution {\\npublic:\\n    pair<int,int>solve(int node,vector<int>&visited,vector<vector<int>>&adj){\\n    //base case    \\n    //-->this will never happen as we\\'re alreday checking visited in for loop\\n        if(visited[node])return {0,0};\\n        \\n        visited[node]=1;\\n        pair<int,int>ans={1,0};\\n        \\n        for(auto it:adj[node]){\\n            if(!visited[it]){\\n                pair<int,int> temp = solve(it,visited,adj);\\n                ans.first+= temp.first;\\n                ans.second+= 1 + temp.second;\\n            }\\n            else\\n                ans.second+=1;\\n        }\\n        return ans; // {total_nodes in components,2* toltal edges in component}\\n    }\\n        \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>visited(n,0);\\n        vector<vector<int>>adj(n);\\n        int components=0;\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int node=0;node<n;node++){\\n            if(!visited[node]){\\n                pair<int,int> ans = solve(node,visited,adj);\\n                int total_nodes = ans.first;\\n                int total_edges = ans.second/2;\\n                if((total_nodes*(total_nodes-1))/2==total_edges)\\n                    components++;\\n            }\\n        }\\n        return components;\\n    }\\n};\\n\\n\\t//Appraoch: total number of edges in complete component = (n * (n-1))/2\\n\\t// where \\'n\\' is the number of nodes in that component\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int>solve(int node,vector<int>&visited,vector<vector<int>>&adj){\\n    //base case    \\n    //-->this will never happen as we\\'re alreday checking visited in for loop\\n        if(visited[node])return {0,0};\\n        \\n        visited[node]=1;\\n        pair<int,int>ans={1,0};\\n        \\n        for(auto it:adj[node]){\\n            if(!visited[it]){\\n                pair<int,int> temp = solve(it,visited,adj);\\n                ans.first+= temp.first;\\n                ans.second+= 1 + temp.second;\\n            }\\n            else\\n                ans.second+=1;\\n        }\\n        return ans; // {total_nodes in components,2* toltal edges in component}\\n    }\\n        \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>visited(n,0);\\n        vector<vector<int>>adj(n);\\n        int components=0;\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int node=0;node<n;node++){\\n            if(!visited[node]){\\n                pair<int,int> ans = solve(node,visited,adj);\\n                int total_nodes = ans.first;\\n                int total_edges = ans.second/2;\\n                if((total_nodes*(total_nodes-1))/2==total_edges)\\n                    components++;\\n            }\\n        }\\n        return components;\\n    }\\n};\\n\\n\\t//Appraoch: total number of edges in complete component = (n * (n-1))/2\\n\\t// where \\'n\\' is the number of nodes in that component\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894452,
                "title": "dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\nvoid dfs( vector<int> adj[] ,int i , vector<bool> & vis , int nodes, bool & fl , int & cir){\\n    if( vis[i]==true)return ;\\n    cir ++;\\n    if(  cir > nodes+1) fl= true;\\n    vis[i]=true;\\n    for(auto x : adj[i]){\\n        if( adj[x].size()!=nodes )fl=true;\\n        if( vis[x]==false){\\n           \\n            dfs( adj , x, vis , nodes , fl , cir);\\n        }\\n    }\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> adj[n];\\n        for(auto x : e){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int ct=0;\\n        vector<bool> vis( n , false);\\n        for( int i =0; i< n ; i++){\\n            if( vis[i]==false){\\n                int nodes = adj[i].size();\\n                bool fl = false;\\n                int cir =0;\\n                dfs( adj , i , vis  , nodes , fl , cir);\\n                if( fl==false)ct++;\\n            }\\n            \\n        }\\n        return ct;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs( vector<int> adj[] ,int i , vector<bool> & vis , int nodes, bool & fl , int & cir){\\n    if( vis[i]==true)return ;\\n    cir ++;\\n    if(  cir > nodes+1) fl= true;\\n    vis[i]=true;\\n    for(auto x : adj[i]){\\n        if( adj[x].size()!=nodes )fl=true;\\n        if( vis[x]==false){\\n           \\n            dfs( adj , x, vis , nodes , fl , cir);\\n        }\\n    }\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> adj[n];\\n        for(auto x : e){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int ct=0;\\n        vector<bool> vis( n , false);\\n        for( int i =0; i< n ; i++){\\n            if( vis[i]==false){\\n                int nodes = adj[i].size();\\n                bool fl = false;\\n                int cir =0;\\n                dfs( adj , i , vis  , nodes , fl , cir);\\n                if( fl==false)ct++;\\n            }\\n            \\n        }\\n        return ct;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893651,
                "title": "dfs-graph-theory-knowledge-c-solution",
                "content": "# Intuition\\nLooking at this we can find it is a connected component sum and one thing for sure is like we should use DFS in order to find the connected components in the graph.\\n\\nLogic:\\nIf there are `n` vertices in a component, then how many edges should be there if it each and every edge should be connected in the component?\\n\\nAnswer: `(n*(n-1)) - For each vertices it should be connected to n-1 vertices.`\\n\\n# Approach\\nWith the following said, just do a normal DFS and then calculate the number of edges and vertices we have and compare it in order to check whether the component is complete component.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(N+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int idx, vector<int> adj[], vector<int> &vis, int &noOfVertices, int &noOfEdges) {\\n        vis[idx] = 1;\\n        noOfVertices++;\\n        noOfEdges+=adj[idx].size();\\n        for(auto &it:adj[idx]) {\\n            if(!vis[it]) {\\n                dfs(it, adj, vis, noOfVertices, noOfEdges);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int cnt = 0;\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<n;i++) {\\n            if(!vis[i]) {\\n                // cout<<\"YES \"<<i<<\"\\\\n\";\\n                int noOfVertices = 0, noOfEdges = 0;\\n                dfs(i, adj, vis, noOfVertices, noOfEdges);\\n                if(noOfEdges == (noOfVertices*(noOfVertices-1))) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n`Pls Upvote if you understood the solution!!`",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int idx, vector<int> adj[], vector<int> &vis, int &noOfVertices, int &noOfEdges) {\\n        vis[idx] = 1;\\n        noOfVertices++;\\n        noOfEdges+=adj[idx].size();\\n        for(auto &it:adj[idx]) {\\n            if(!vis[it]) {\\n                dfs(it, adj, vis, noOfVertices, noOfEdges);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int cnt = 0;\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<n;i++) {\\n            if(!vis[i]) {\\n                // cout<<\"YES \"<<i<<\"\\\\n\";\\n                int noOfVertices = 0, noOfEdges = 0;\\n                dfs(i, adj, vis, noOfVertices, noOfEdges);\\n                if(noOfEdges == (noOfVertices*(noOfVertices-1))) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3878049,
                "title": "simplest-solution-easy-to-understand-c",
                "content": "# Intuition\\nAdjacency list for all the nodes in a complete component will become same if we insert that node in its respective adjacency list.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<bool>& vis, int curr, vector<vector<int>>& adj){\\n        vis[curr]=true;\\n        for(auto a: adj[curr]){\\n            if(!vis[a])\\n                if(!check(vis, a, adj)) return false;\\n                if(adj[a]!=adj[curr])return false;\\n        }\\n    return true;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n        int count=0;    \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<adj.size();i++){\\n            adj[i].push_back(i);\\n            sort(adj[i].begin(), adj[i].end());\\n        }\\n\\n        for(int i=0;i<vis.size();i++)\\n            if(!vis[i] && check(vis, i, adj))\\n            count++;\\n\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<bool>& vis, int curr, vector<vector<int>>& adj){\\n        vis[curr]=true;\\n        for(auto a: adj[curr]){\\n            if(!vis[a])\\n                if(!check(vis, a, adj)) return false;\\n                if(adj[a]!=adj[curr])return false;\\n        }\\n    return true;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n        int count=0;    \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<adj.size();i++){\\n            adj[i].push_back(i);\\n            sort(adj[i].begin(), adj[i].end());\\n        }\\n\\n        for(int i=0;i<vis.size();i++)\\n            if(!vis[i] && check(vis, i, adj))\\n            count++;\\n\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876965,
                "title": "using-dfs-broken-down-into-steps-easily-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Firstly, In order to find all the connected components we need to do a DFS. \\n After this, the next step is to confirm whether the given component that we traversed is connected or not. \\nFor this, we just run a simple for loop on every node present in the set and check if the degree of the curr node is equal to size of set(i.e all nodes present in the componet) minus 1 it means that the componet is connected\\nAfter this condition has been checked we can now increase our res variable.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isConnected(vector<vector<int>> &AL, unordered_set<int> &s)\\n    {\\n        //comparing degree of each node present in set since every node in a connected component\\n        //has a degree that is equal to total no of nodes in the component - 1\\n        int ExpectedDegree = s.size()-1;\\n        for(auto i : s)\\n        {\\n            if(AL[i].size() != ExpectedDegree)\\n                return false;\\n        }\\n        return true;\\n    }\\n    void DFS(int i, vector<vector<int>>& al, unordered_set<int> &s)\\n    {\\n        if(s.insert(i).second)//the second parameter tells whether the insertion was succesful or not\\n            for(auto j : al[i])\\n                DFS(j, al, s);\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> AL(n);\\n        int res = 0;\\n        //creating adjacency list\\n        for(const auto i : edges)\\n        {\\n            AL[i[0]].push_back(i[1]);\\n            AL[i[1]].push_back(i[0]);\\n        }\\n        //stores all nodes processed in a single DFS iteration\\n        unordered_set<int> ms;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ms.count(i) == 0)\\n            {\\n                unordered_set<int> s;\\n                DFS(i, AL, s);\\n                if(isConnected(AL,s))\\n                    res++;\\n                ms.insert(s.begin(), s.end());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isConnected(vector<vector<int>> &AL, unordered_set<int> &s)\\n    {\\n        //comparing degree of each node present in set since every node in a connected component\\n        //has a degree that is equal to total no of nodes in the component - 1\\n        int ExpectedDegree = s.size()-1;\\n        for(auto i : s)\\n        {\\n            if(AL[i].size() != ExpectedDegree)\\n                return false;\\n        }\\n        return true;\\n    }\\n    void DFS(int i, vector<vector<int>>& al, unordered_set<int> &s)\\n    {\\n        if(s.insert(i).second)//the second parameter tells whether the insertion was succesful or not\\n            for(auto j : al[i])\\n                DFS(j, al, s);\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> AL(n);\\n        int res = 0;\\n        //creating adjacency list\\n        for(const auto i : edges)\\n        {\\n            AL[i[0]].push_back(i[1]);\\n            AL[i[1]].push_back(i[0]);\\n        }\\n        //stores all nodes processed in a single DFS iteration\\n        unordered_set<int> ms;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ms.count(i) == 0)\\n            {\\n                unordered_set<int> s;\\n                DFS(i, AL, s);\\n                if(isConnected(AL,s))\\n                    res++;\\n                ms.insert(s.begin(), s.end());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876218,
                "title": "c-beats-96-51-users",
                "content": "![Screenshot 2023-08-07 at 3.51.38 PM.png](https://assets.leetcode.com/users/images/132c2b51-1c60-41d5-812b-97e0571efb4b_1691403769.3194032.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSave nodes of component in every dfs call, keep tab on the size of component and check if every node has adjacent (component-size - 1 ) neighbours or not, if it does, ans++\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int in,vector<int>& vis,vector<int> adj[],vector<int>& nodes,int &compsize)\\n    {\\n        vis[in]=1;\\n        nodes.push_back(in);\\n        compsize++;\\n        for(auto it : adj[in])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,vis,adj,nodes,compsize);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int x = edges[i][0];\\n            int y = edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int> vis(n,0);\\n        int ans = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                int compsize = 0;\\n                vector<int> nodes;\\n                dfs(i,vis,adj,nodes,compsize);\\n                int flag = 0;\\n                for(auto j : nodes)\\n                {\\n                    if(adj[j].size()!=compsize-1)\\n                        flag=1;\\n                }\\n                if(flag==0)\\n                    ans++;\\n            };\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int in,vector<int>& vis,vector<int> adj[],vector<int>& nodes,int &compsize)\\n    {\\n        vis[in]=1;\\n        nodes.push_back(in);\\n        compsize++;\\n        for(auto it : adj[in])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,vis,adj,nodes,compsize);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int x = edges[i][0];\\n            int y = edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int> vis(n,0);\\n        int ans = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                int compsize = 0;\\n                vector<int> nodes;\\n                dfs(i,vis,adj,nodes,compsize);\\n                int flag = 0;\\n                for(auto j : nodes)\\n                {\\n                    if(adj[j].size()!=compsize-1)\\n                        flag=1;\\n                }\\n                if(flag==0)\\n                    ans++;\\n            };\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870914,
                "title": "solution-using-dfs-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    void dfs(int i, vector<int> &vis, vector<vector<int>>&adj,vector<int>&v){\\n        \\n        vis[i]=1;\\n        v.push_back(i);\\n        for(auto it : adj[i]){\\n            if(vis[it]==0)  dfs(it,vis,adj,v);\\n            \\n        }\\n        return ;\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        \\n        for(auto i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            \\n            if(vis[i]==0){\\n                int count=0;\\n                vector<int>v;\\n                dfs(i,vis,adj,v);\\n                for(auto j : v){\\n                    if(adj[j].size()>=v.size()-1) count++;\\n                }\\n                \\n                if(count == v.size())ans++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if found usefull**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    void dfs(int i, vector<int> &vis, vector<vector<int>>&adj,vector<int>&v){\\n        \\n        vis[i]=1;\\n        v.push_back(i);\\n        for(auto it : adj[i]){\\n            if(vis[it]==0)  dfs(it,vis,adj,v);\\n            \\n        }\\n        return ;\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        \\n        for(auto i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            \\n            if(vis[i]==0){\\n                int count=0;\\n                vector<int>v;\\n                dfs(i,vis,adj,v);\\n                for(auto j : v){\\n                    if(adj[j].size()>=v.size()-1) count++;\\n                }\\n                \\n                if(count == v.size())ans++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869470,
                "title": "using-only-dfs-no-hashing",
                "content": "# Code\\n```\\nclass Solution {\\n    private:\\n    pair<int,int> DFS(int node,vector<int>adj[],vector<int>&vis,int par){\\n        vis[node] = 1;\\n        int nCnt = 1;\\n        int edgCnt = 0;\\n        for(auto it:adj[node]){\\n            if(vis[it] == 0){\\n                edgCnt++;\\n                auto pr = DFS(it,adj,vis,node);\\n                vis[it]=-1;\\n                edgCnt+= pr.second;\\n                nCnt+= pr.first;\\n            }\\n            else if(it!=par && vis[it]!=-1){\\n                edgCnt++;\\n            }\\n        }\\n        return {nCnt,edgCnt};\\n    }\\n\\n    int calNC2(int n){\\n        return n*(n-1)/2;\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n,0);\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                auto pr = DFS(i,adj,vis,-1);\\n                int nc2 = calNC2(pr.first);\\n                if(nc2 == pr.second)cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    pair<int,int> DFS(int node,vector<int>adj[],vector<int>&vis,int par){\\n        vis[node] = 1;\\n        int nCnt = 1;\\n        int edgCnt = 0;\\n        for(auto it:adj[node]){\\n            if(vis[it] == 0){\\n                edgCnt++;\\n                auto pr = DFS(it,adj,vis,node);\\n                vis[it]=-1;\\n                edgCnt+= pr.second;\\n                nCnt+= pr.first;\\n            }\\n            else if(it!=par && vis[it]!=-1){\\n                edgCnt++;\\n            }\\n        }\\n        return {nCnt,edgCnt};\\n    }\\n\\n    int calNC2(int n){\\n        return n*(n-1)/2;\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n,0);\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                auto pr = DFS(i,adj,vis,-1);\\n                int nc2 = calNC2(pr.first);\\n                if(nc2 == pr.second)cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866318,
                "title": "easy-bfs-solution-thoda-different",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a BFS Solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst get all the connected components using BFS and then check for each connected component whether it is completely connected by calculating the total number of edges between the graph.\\nTotal number of edges between the graph should be >= n(n-1)/2. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n\\n    vector<int> bfs(int source,vector<vector<int>> &adj)\\n    {\\n        vector<int> connCom;\\n\\n        vector<bool> curr_visited(adj.size(),false);\\n        queue<int> q;\\n        q.push(source);\\n        curr_visited[source] = true;\\n        \\n\\n        while(!q.empty())\\n        {\\n            //pop the first element;\\n            int fNode = q.front();q.pop();\\n            connCom.push_back(fNode);\\n\\n            for(int k =0;k<adj[fNode].size();k++)\\n            {\\n                int nN = adj[fNode][k];\\n                if( curr_visited[nN]== false)\\n                {\\n                    q.push(nN);\\n                    curr_visited[nN] = true;\\n                }\\n            }\\n\\n        }\\n    return connCom;\\n    }\\n\\n    bool isComponentComplete(vector<int> & graph, vector<vector<int>> &adj)\\n    {\\n        int graphSize = graph.size();\\n\\n        if(graphSize < 2)\\n        {\\n            return true;\\n        }\\n        int totalEdgesCount = 0;\\n\\n        for(int i =0;i<graphSize;i++)\\n        {\\n            // cout<<\" : \"<<graph[i];\\n            totalEdgesCount+=(adj[graph[i]].size());\\n        }\\n        // cout<<endl;\\n\\n        if(totalEdgesCount >= graphSize*(graphSize-1))\\n        {\\n            return true;\\n        }\\n\\n\\n        return false;\\n    }\\n\\n    vector<vector<int>> getAllConnectedComponents(vector<vector<int>> &adj) {\\n        vector<vector<int>> res;\\n\\n        int total_nodes = adj.size();\\n\\n  \\n\\n        vector<int> visited(total_nodes,false);\\n\\n        for(int i =0;i<total_nodes;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                //BFS\\n                vector<int> cC = bfs(i,adj);\\n\\n\\n                for(int j =0;j<cC.size();j++)\\n                {\\n                    visited[cC[j]] = true;\\n                }\\n                res.push_back(cC);\\n            }\\n        }\\n        return res;\\n\\n\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n);\\n        //0...n-1\\n\\n        for(int i =0;i<edges.size();i++)\\n        {\\n            //Add the element to adj\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        //Adj matrix is complete\\n\\n\\n\\n        vector<vector<int>> connectedComponents = getAllConnectedComponents(adj);\\n\\n        //CHECK FOR COMPETENESS;\\n\\n        int fRes = 0;\\n        for(int cCom =0; cCom< connectedComponents.size(); cCom++)\\n        {\\n            if(isComponentComplete(connectedComponents[cCom],adj)){\\n                fRes++;\\n            }\\n        }\\n\\n        return fRes;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n\\n    vector<int> bfs(int source,vector<vector<int>> &adj)\\n    {\\n        vector<int> connCom;\\n\\n        vector<bool> curr_visited(adj.size(),false);\\n        queue<int> q;\\n        q.push(source);\\n        curr_visited[source] = true;\\n        \\n\\n        while(!q.empty())\\n        {\\n            //pop the first element;\\n            int fNode = q.front();q.pop();\\n            connCom.push_back(fNode);\\n\\n            for(int k =0;k<adj[fNode].size();k++)\\n            {\\n                int nN = adj[fNode][k];\\n                if( curr_visited[nN]== false)\\n                {\\n                    q.push(nN);\\n                    curr_visited[nN] = true;\\n                }\\n            }\\n\\n        }\\n    return connCom;\\n    }\\n\\n    bool isComponentComplete(vector<int> & graph, vector<vector<int>> &adj)\\n    {\\n        int graphSize = graph.size();\\n\\n        if(graphSize < 2)\\n        {\\n            return true;\\n        }\\n        int totalEdgesCount = 0;\\n\\n        for(int i =0;i<graphSize;i++)\\n        {\\n            // cout<<\" : \"<<graph[i];\\n            totalEdgesCount+=(adj[graph[i]].size());\\n        }\\n        // cout<<endl;\\n\\n        if(totalEdgesCount >= graphSize*(graphSize-1))\\n        {\\n            return true;\\n        }\\n\\n\\n        return false;\\n    }\\n\\n    vector<vector<int>> getAllConnectedComponents(vector<vector<int>> &adj) {\\n        vector<vector<int>> res;\\n\\n        int total_nodes = adj.size();\\n\\n  \\n\\n        vector<int> visited(total_nodes,false);\\n\\n        for(int i =0;i<total_nodes;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                //BFS\\n                vector<int> cC = bfs(i,adj);\\n\\n\\n                for(int j =0;j<cC.size();j++)\\n                {\\n                    visited[cC[j]] = true;\\n                }\\n                res.push_back(cC);\\n            }\\n        }\\n        return res;\\n\\n\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n);\\n        //0...n-1\\n\\n        for(int i =0;i<edges.size();i++)\\n        {\\n            //Add the element to adj\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        //Adj matrix is complete\\n\\n\\n\\n        vector<vector<int>> connectedComponents = getAllConnectedComponents(adj);\\n\\n        //CHECK FOR COMPETENESS;\\n\\n        int fRes = 0;\\n        for(int cCom =0; cCom< connectedComponents.size(); cCom++)\\n        {\\n            if(isComponentComplete(connectedComponents[cCom],adj)){\\n                fRes++;\\n            }\\n        }\\n\\n        return fRes;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3866123,
                "title": "c-dfs-math",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> G[100];\\n    int vis[1000];\\n    void dfs(int u, int &p, int &q) {\\n        if(vis[u]) return;\\n        vis[u] = 1;\\n        p++;\\n        q += G[u].size();\\n        for(auto &x : G[u]) {\\n            if(x != u) dfs(x, p, q);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        for(auto &x : edges) {\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n        }\\n        int components = 0, p, q;\\n        memset(vis, 0, sizeof(vis));\\n        for(int i = 0; i < n; ++i) {\\n            p = 0, q = 0;\\n            if(!vis[i]) {\\n                dfs(i, p, q);\\n                if(p*(p-1) == q) ++components;\\n            }\\n        }\\n        return components;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> G[100];\\n    int vis[1000];\\n    void dfs(int u, int &p, int &q) {\\n        if(vis[u]) return;\\n        vis[u] = 1;\\n        p++;\\n        q += G[u].size();\\n        for(auto &x : G[u]) {\\n            if(x != u) dfs(x, p, q);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        for(auto &x : edges) {\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n        }\\n        int components = 0, p, q;\\n        memset(vis, 0, sizeof(vis));\\n        for(int i = 0; i < n; ++i) {\\n            p = 0, q = 0;\\n            if(!vis[i]) {\\n                dfs(i, p, q);\\n                if(p*(p-1) == q) ++components;\\n            }\\n        }\\n        return components;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862191,
                "title": "cpp-easy-implemenatation-beats-95-breadth-first-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<bool> visit(n,false);\\n        if(edges.size()==0)return n;\\n        vector<vector<int>> adj(n);\\n        for(auto e: edges){\\n            adj[e[1]].push_back(e[0]);\\n            adj[e[0]].push_back(e[1]);\\n        }\\n        int nas=0;\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(visit[i]==false){\\n                visit[i]=true;\\n                q.push(i);\\n            }\\n            else continue;\\n            int count=0;\\n            int edges=0;\\n            while(!q.empty()){\\n                int n=q.front();\\n                q.pop();\\n                count++;\\n                for(int e: adj[n]){\\n                    edges++;\\n                    if(visit[e]==false){\\n                        visit[e]=true;\\n                        q.push(e);\\n                    }\\n                }\\n            \\n        }\\n        edges/=2;\\n            if(edges == (count-1)*count/2)nas++;\\n        }\\n        return nas;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<bool> visit(n,false);\\n        if(edges.size()==0)return n;\\n        vector<vector<int>> adj(n);\\n        for(auto e: edges){\\n            adj[e[1]].push_back(e[0]);\\n            adj[e[0]].push_back(e[1]);\\n        }\\n        int nas=0;\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(visit[i]==false){\\n                visit[i]=true;\\n                q.push(i);\\n            }\\n            else continue;\\n            int count=0;\\n            int edges=0;\\n            while(!q.empty()){\\n                int n=q.front();\\n                q.pop();\\n                count++;\\n                for(int e: adj[n]){\\n                    edges++;\\n                    if(visit[e]==false){\\n                        visit[e]=true;\\n                        q.push(e);\\n                    }\\n                }\\n            \\n        }\\n        edges/=2;\\n            if(edges == (count-1)*count/2)nas++;\\n        }\\n        return nas;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857802,
                "title": "easy-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void bfs(int node , vector<int> adj[] , vector<int> &vis , int &nodes , int &edges){\\n        queue<int> q;\\n        q.push(node);\\n        vis[node] = 1;\\n        int cnt = 0;\\n\\n        while(!q.empty()){\\n            int f = q.front();\\n            q.pop();\\n\\n            for(int ele : adj[f]){\\n                if(!vis[ele]){\\n                    nodes++;\\n                    q.push(ele);\\n                    vis[ele] = 1;\\n                }\\n                cnt++;\\n            }\\n        }\\n        edges = cnt/2;\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto ele : edges){\\n            adj[ele[0]].push_back(ele[1]);\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n\\n        vector<int> vis(n , 0);\\n\\n        int ans = 0;\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(!vis[i]){\\n                int nodes = 1 , edges = 0;\\n                bfs(i , adj , vis , nodes , edges);\\n\\n                if( edges == (nodes*(nodes-1))/2 ) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void bfs(int node , vector<int> adj[] , vector<int> &vis , int &nodes , int &edges){\\n        queue<int> q;\\n        q.push(node);\\n        vis[node] = 1;\\n        int cnt = 0;\\n\\n        while(!q.empty()){\\n            int f = q.front();\\n            q.pop();\\n\\n            for(int ele : adj[f]){\\n                if(!vis[ele]){\\n                    nodes++;\\n                    q.push(ele);\\n                    vis[ele] = 1;\\n                }\\n                cnt++;\\n            }\\n        }\\n        edges = cnt/2;\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto ele : edges){\\n            adj[ele[0]].push_back(ele[1]);\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n\\n        vector<int> vis(n , 0);\\n\\n        int ans = 0;\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(!vis[i]){\\n                int nodes = 1 , edges = 0;\\n                bfs(i , adj , vis , nodes , edges);\\n\\n                if( edges == (nodes*(nodes-1))/2 ) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854042,
                "title": "simple-logic-each-vertex-have-edges-no-of-vertices-1-for-that-connected-component",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,int& edge,int& v,vector<int>& vis,vector<vector<int>>& adjList){\\n        v++;\\n        vis[node]=1;\\n        for(auto it:adjList[node]){\\n            edge++;\\n            if(vis[it]==0){\\n                dfs(it,edge,v,vis,adjList);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adjList(n);\\n        for(int i=0;i<edges.size();i++){\\n            adjList[edges[i][0]].push_back(edges[i][1]);\\n            adjList[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n              int edge=0,v=0;\\n              if(vis[i]==0){\\n                  dfs(i,edge,v,vis,adjList);\\n                  \\n                  if(edge/v==v-1 ){\\n                      count++;\\n                  }\\n              }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,int& edge,int& v,vector<int>& vis,vector<vector<int>>& adjList){\\n        v++;\\n        vis[node]=1;\\n        for(auto it:adjList[node]){\\n            edge++;\\n            if(vis[it]==0){\\n                dfs(it,edge,v,vis,adjList);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adjList(n);\\n        for(int i=0;i<edges.size();i++){\\n            adjList[edges[i][0]].push_back(edges[i][1]);\\n            adjList[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n              int edge=0,v=0;\\n              if(vis[i]==0){\\n                  dfs(i,edge,v,vis,adjList);\\n                  \\n                  if(edge/v==v-1 ){\\n                      count++;\\n                  }\\n              }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852500,
                "title": "easy-sol-cpp",
                "content": "void dfs(int ver, vector<int> g[], vector<int> &vis, vector<int> &ele)\\n    {\\n        vis[ver]=1;\\n        cout<<ver<<\" \";\\n        ele.push_back(ver);\\n        for(auto child:g[ver])\\n        {\\n            if(vis[child])continue;\\n            vis[child]=1;\\n            dfs(child,g,vis,ele);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int i,ans=0;\\n        vector<int> g[n],vis(n,0);\\n        for(i=0;i<edges.size();i++)\\n        {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // vector<int> ele;\\n        // dfs(5,g,vis,ele);\\n        // cout<<\"\\\\n\"<<ele.size();\\n        for(i=0;i<n;i++)\\n        {\\n            vector<int> ele;\\n            if(vis[i])continue;\\n            dfs(i,g,vis,ele);\\n            // cout<<ele.size();\\n            int f=0;\\n            for(int j=0;j<ele.size();j++)\\n            {\\n                if(g[ele[j]].size()!=ele.size()-1)\\n                {\\n                    f=1;break;\\n                }\\n            }\\n            if(f==0)ans++;\\n        }\\n        return ans;",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "void dfs(int ver, vector<int> g[], vector<int> &vis, vector<int> &ele)\\n    {\\n        vis[ver]=1;\\n        cout<<ver<<\" \";\\n        ele.push_back(ver);\\n        for(auto child:g[ver])\\n        {\\n            if(vis[child])continue;\\n            vis[child]=1;\\n            dfs(child,g,vis,ele);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int i,ans=0;\\n        vector<int> g[n],vis(n,0);\\n        for(i=0;i<edges.size();i++)\\n        {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // vector<int> ele;\\n        // dfs(5,g,vis,ele);\\n        // cout<<\"\\\\n\"<<ele.size();\\n        for(i=0;i<n;i++)\\n        {\\n            vector<int> ele;\\n            if(vis[i])continue;\\n            dfs(i,g,vis,ele);\\n            // cout<<ele.size();\\n            int f=0;\\n            for(int j=0;j<ele.size();j++)\\n            {\\n                if(g[ele[j]].size()!=ele.size()-1)\\n                {\\n                    f=1;break;\\n                }\\n            }\\n            if(f==0)ans++;\\n        }\\n        return ans;",
                "codeTag": "C++"
            },
            {
                "id": 3850472,
                "title": "dfs-which-counts-nodes-and-edges",
                "content": "# Code\\n```\\nclass Solution {\\n    int nodeCountForDFS = 0;\\n    long edgeCountForDFS = 0l;\\n\\n    // TC: O(V+E)\\n    // SC: O(V)\\n    public int countCompleteComponents(final int n,final int[][] edges) {\\n        int count = 0;\\n        boolean[] visited = new boolean[n];\\n        List<List<Integer>> adj = new ArrayList<>();\\n        buildAdj(n,edges,adj);\\n\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                nodeCountForDFS=0;\\n                edgeCountForDFS=0l;\\n                dfs(i,adj,visited);\\n                // as we have undirected graph\\n                if((nodeCountForDFS*(nodeCountForDFS-1))*1l==edgeCountForDFS){\\n                    count++;\\n                    // System.out.println(nodeCountForDFS+\"\"+edgeCountForDFS);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void buildAdj(int n,final int[][] edges,List<List<Integer>> adj){\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] e:edges){\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n    }\\n\\n    private void dfs(final int p,final List<List<Integer>> adj,boolean[] visited){\\n        visited[p] = true;\\n        nodeCountForDFS++;\\n        for(int c:adj.get(p)){\\n            edgeCountForDFS++;\\n            if(!visited[c]){\\n                visited[c] = true;\\n                dfs(c,adj,visited);\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int nodeCountForDFS = 0;\\n    long edgeCountForDFS = 0l;\\n\\n    // TC: O(V+E)\\n    // SC: O(V)\\n    public int countCompleteComponents(final int n,final int[][] edges) {\\n        int count = 0;\\n        boolean[] visited = new boolean[n];\\n        List<List<Integer>> adj = new ArrayList<>();\\n        buildAdj(n,edges,adj);\\n\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                nodeCountForDFS=0;\\n                edgeCountForDFS=0l;\\n                dfs(i,adj,visited);\\n                // as we have undirected graph\\n                if((nodeCountForDFS*(nodeCountForDFS-1))*1l==edgeCountForDFS){\\n                    count++;\\n                    // System.out.println(nodeCountForDFS+\"\"+edgeCountForDFS);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void buildAdj(int n,final int[][] edges,List<List<Integer>> adj){\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] e:edges){\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n    }\\n\\n    private void dfs(final int p,final List<List<Integer>> adj,boolean[] visited){\\n        visited[p] = true;\\n        nodeCountForDFS++;\\n        for(int c:adj.get(p)){\\n            edgeCountForDFS++;\\n            if(!visited[c]){\\n                visited[c] = true;\\n                dfs(c,adj,visited);\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848704,
                "title": "java-using-bfs-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean ans(List<List<Integer>> al,int n,boolean v[],int i,int s){\\n        Deque<Integer> q=new ArrayDeque();\\n        q.addLast(i);\\n        //boolean b=true;\\n        Set<Integer> hs=new HashSet<>();\\n        hs.add(i);\\n        while(q.size()!=0){\\n            int curr=q.getFirst();\\n            q.removeFirst();\\n            v[curr]=true;\\n            for(int ele:al.get(curr)){\\n                if(v[ele]==false){\\n                    q.addLast(ele);\\n                    v[ele]=true;\\n                    hs.add(ele);\\n                    //if(al.get(ele).size()!=s) b=false;\\n                }\\n            }\\n        }\\n        for(int k:hs){\\n            if(al.get(k).size()!=hs.size()-1) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> al=new ArrayList<>();\\n            for(int i=0;i<=n;i++){\\n                List<Integer> l=new ArrayList<>();\\n                al.add(l);\\n            }\\n            for(int i=0;i<edges.length;i++){\\n                    al.get(edges[i][0]).add(edges[i][1]);\\n                    al.get(edges[i][1]).add(edges[i][0]);\\n            }\\n            boolean v[]=new boolean[n];\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i]==false){\\n                v[i]=true;\\n                boolean b=ans(al,n,v,i,al.get(i).size());\\n                System.out.println(b+\" \"+i);\\n                if(b) c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean ans(List<List<Integer>> al,int n,boolean v[],int i,int s){\\n        Deque<Integer> q=new ArrayDeque();\\n        q.addLast(i);\\n        //boolean b=true;\\n        Set<Integer> hs=new HashSet<>();\\n        hs.add(i);\\n        while(q.size()!=0){\\n            int curr=q.getFirst();\\n            q.removeFirst();\\n            v[curr]=true;\\n            for(int ele:al.get(curr)){\\n                if(v[ele]==false){\\n                    q.addLast(ele);\\n                    v[ele]=true;\\n                    hs.add(ele);\\n                    //if(al.get(ele).size()!=s) b=false;\\n                }\\n            }\\n        }\\n        for(int k:hs){\\n            if(al.get(k).size()!=hs.size()-1) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> al=new ArrayList<>();\\n            for(int i=0;i<=n;i++){\\n                List<Integer> l=new ArrayList<>();\\n                al.add(l);\\n            }\\n            for(int i=0;i<edges.length;i++){\\n                    al.get(edges[i][0]).add(edges[i][1]);\\n                    al.get(edges[i][1]).add(edges[i][0]);\\n            }\\n            boolean v[]=new boolean[n];\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i]==false){\\n                v[i]=true;\\n                boolean b=ans(al,n,v,i,al.get(i).size());\\n                System.out.println(b+\" \"+i);\\n                if(b) c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846494,
                "title": "c-easy-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void t(int i,int n,vector<int>& v,vector<vector<int>>& a,vector<int>& r)\\n    {\\n        v[i]=1;\\n        r.push_back(i);\\n        for(auto j: a[i])\\n        {\\n            if(!v[j])\\n                t(j,n,v,a,r);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        int c=0;\\n        vector<vector<int>> a(n);\\n        for(auto i: e)\\n        a[i[0]].push_back(i[1]),a[i[1]].push_back(i[0]);\\n        \\n        vector<int> v(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> r;\\n            if(!v[i])\\n            {\\n            bool b=1;    \\n            t(i,n,v,a,r); \\n            for(auto x: r)\\n             for(auto y: r)\\n              if(find(a[x].begin(),a[x].end(),y)==a[x].end() && x!=y) {\\n                  b=0;break;\\n              }\\n            if(b) \\n            c++;  \\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void t(int i,int n,vector<int>& v,vector<vector<int>>& a,vector<int>& r)\\n    {\\n        v[i]=1;\\n        r.push_back(i);\\n        for(auto j: a[i])\\n        {\\n            if(!v[j])\\n                t(j,n,v,a,r);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        int c=0;\\n        vector<vector<int>> a(n);\\n        for(auto i: e)\\n        a[i[0]].push_back(i[1]),a[i[1]].push_back(i[0]);\\n        \\n        vector<int> v(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> r;\\n            if(!v[i])\\n            {\\n            bool b=1;    \\n            t(i,n,v,a,r); \\n            for(auto x: r)\\n             for(auto y: r)\\n              if(find(a[x].begin(),a[x].end(),y)==a[x].end() && x!=y) {\\n                  b=0;break;\\n              }\\n            if(b) \\n            c++;  \\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844628,
                "title": "using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int cnt=0;\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int edge[]:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n\\n        boolean[] vis=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                cnt++;\\n               int tmp=dfs(i,vis,adj);\\n               System.out.println(tmp);\\n               if(!check(i,adj,new boolean[n],tmp))cnt--;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    public boolean check(int i,List<List<Integer>> adj,boolean vis[],int tmp){\\n        vis[i]=true;\\n        if(adj.get(i).size()!=tmp-1)return false;\\n        boolean ans=true;\\n        for(int neigh : adj.get(i)){\\n            if(!vis[neigh])\\n                ans&=check(neigh,adj,vis,tmp);\\n        }\\n        return ans;  \\n    }\\n\\n    public int dfs(int i,boolean[] vis,List<List<Integer>> adj){\\n        vis[i]=true;\\n        int tmp=1;\\n        for(int neigh : adj.get(i)){\\n            if(!vis[neigh]){\\n               tmp+=dfs(neigh,vis,adj);\\n            }\\n        }\\n        return tmp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int cnt=0;\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int edge[]:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n\\n        boolean[] vis=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                cnt++;\\n               int tmp=dfs(i,vis,adj);\\n               System.out.println(tmp);\\n               if(!check(i,adj,new boolean[n],tmp))cnt--;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    public boolean check(int i,List<List<Integer>> adj,boolean vis[],int tmp){\\n        vis[i]=true;\\n        if(adj.get(i).size()!=tmp-1)return false;\\n        boolean ans=true;\\n        for(int neigh : adj.get(i)){\\n            if(!vis[neigh])\\n                ans&=check(neigh,adj,vis,tmp);\\n        }\\n        return ans;  \\n    }\\n\\n    public int dfs(int i,boolean[] vis,List<List<Integer>> adj){\\n        vis[i]=true;\\n        int tmp=1;\\n        for(int neigh : adj.get(i)){\\n            if(!vis[neigh]){\\n               tmp+=dfs(neigh,vis,adj);\\n            }\\n        }\\n        return tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838234,
                "title": "simple-java-intuition-beginner-friendly-and-different",
                "content": "# Intuition\\nall the strongly connected components are having same edges as parent \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nits a simple strongly connected components\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(E*V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V*V+V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //classic graph data \\n        int[] visited =  new int[n];\\n\\n        //looping\\n        int len = edges.length;\\n        int[][] arr = new int[n][n];\\n        for(int i=0; i<len; i++){\\n            arr[edges[i][0]][edges[i][1]]=1;\\n            arr[edges[i][1]][edges[i][0]]=1;\\n        }\\n        //so that all the peer have the same elements\\n        for(int i=0; i<n; i++){\\n            arr[i][i]=1;\\n        }\\n\\n        //hey! the logic is here\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            if(visited[i]==0){\\n                if(dfsCheck(i,-1,arr,visited)==1) res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static int dfsCheck( int curr, int parent, int[][] arr, int[] visited){\\n        if(visited[curr]==1) return 1;\\n        else if(visited[curr]==2) return 2;\\n        //check parent with all the elements in the current vertix\\n        if(parent!=-1){\\n            for(int i=0; i<arr.length; i++){\\n                if(arr[curr][i]!=arr[parent][i]){\\n                    visited[curr]=2;\\n                    return visited[curr];\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0; i<arr.length; i++){\\n                if(arr[curr][i]==1){\\n                    if(dfsCheck(i,curr,arr,visited)==2){\\n                        visited[curr]=2;\\n                        return visited[curr];\\n                    }\\n                }\\n            }\\n        }\\n        visited[curr]=1;\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //classic graph data \\n        int[] visited =  new int[n];\\n\\n        //looping\\n        int len = edges.length;\\n        int[][] arr = new int[n][n];\\n        for(int i=0; i<len; i++){\\n            arr[edges[i][0]][edges[i][1]]=1;\\n            arr[edges[i][1]][edges[i][0]]=1;\\n        }\\n        //so that all the peer have the same elements\\n        for(int i=0; i<n; i++){\\n            arr[i][i]=1;\\n        }\\n\\n        //hey! the logic is here\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            if(visited[i]==0){\\n                if(dfsCheck(i,-1,arr,visited)==1) res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static int dfsCheck( int curr, int parent, int[][] arr, int[] visited){\\n        if(visited[curr]==1) return 1;\\n        else if(visited[curr]==2) return 2;\\n        //check parent with all the elements in the current vertix\\n        if(parent!=-1){\\n            for(int i=0; i<arr.length; i++){\\n                if(arr[curr][i]!=arr[parent][i]){\\n                    visited[curr]=2;\\n                    return visited[curr];\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0; i<arr.length; i++){\\n                if(arr[curr][i]==1){\\n                    if(dfsCheck(i,curr,arr,visited)==2){\\n                        visited[curr]=2;\\n                        return visited[curr];\\n                    }\\n                }\\n            }\\n        }\\n        visited[curr]=1;\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835197,
                "title": "java-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>>adj=new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        Queue<Integer>q=new LinkedList<>();\\n        for (int[] i :edges) {\\n            int u=i[0];\\n            int v=i[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        int c=0;\\n        Set<Integer>s=new HashSet<>();\\n        for(int i=0;i<n;i++){\\n            \\n            if(!s.contains(i)){\\n              int ed=0;\\n              int node=0;   \\n              q.add(i);\\n              s.add(i);\\n                while(!q.isEmpty()){\\n                int val=q.poll();\\n                \\n                node++;\\n                for(int v:adj.get(val)){\\n                     ed++;\\n                     if(!s.contains(v)){\\n                          s.add(v);\\n                          \\n                          q.add(v);\\n                     }\\n                     \\n                     \\n                } \\n            }\\n             \\n             \\n            if(ed/2==node*(node-1)/2){\\n                c++;\\n            }\\n\\n            }\\n           \\n            \\n             \\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>>adj=new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        Queue<Integer>q=new LinkedList<>();\\n        for (int[] i :edges) {\\n            int u=i[0];\\n            int v=i[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        int c=0;\\n        Set<Integer>s=new HashSet<>();\\n        for(int i=0;i<n;i++){\\n            \\n            if(!s.contains(i)){\\n              int ed=0;\\n              int node=0;   \\n              q.add(i);\\n              s.add(i);\\n                while(!q.isEmpty()){\\n                int val=q.poll();\\n                \\n                node++;\\n                for(int v:adj.get(val)){\\n                     ed++;\\n                     if(!s.contains(v)){\\n                          s.add(v);\\n                          \\n                          q.add(v);\\n                     }\\n                     \\n                     \\n                } \\n            }\\n             \\n             \\n            if(ed/2==node*(node-1)/2){\\n                c++;\\n            }\\n\\n            }\\n           \\n            \\n             \\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828195,
                "title": "dsu-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst make all the components. Any component is said to be complete iff there is an edge from every vertex of that component to every other vertex.\\nSo, maintain an array of count of edges from each vertex. If the size of the component is say X then there should be X-1 edgeCount for each of the vertex that is present in the component.\\n\\n\\n\\n# Code\\n```\\nclass DSU{\\nprivate:\\n    int N;\\n    vector<int> par,sz,edgeCount;\\n    int Find(int u){\\n        if(par[u]==-1){\\n            return u;\\n        }\\n        return par[u]=Find(par[u]);\\n    }\\n    void Union(int u, int v){\\n        //increament the edgeCount\\n        edgeCount[u]++;\\n        edgeCount[v]++;\\n        int s1 = Find(u);\\n        int s2 = Find(v);\\n        if(s1!=s2){\\n            if(sz[s1]>=sz[s2]){\\n                sz[s1]+=sz[s2];\\n                par[s2]=s1;\\n            }else{\\n                sz[s2]+=sz[s1];\\n                par[s1]=s2;\\n            } \\n        }\\n    }\\n    int getCount(){\\n        int cnt = 0;\\n        vector<int> flag(N,true);\\n        for(int i=0;i<N;i++){\\n            int par = Find(i);\\n            int reqSize = (sz[par]-1);\\n            if(flag[par] and edgeCount[i]!=reqSize){\\n                flag[par]=false;\\n            }\\n        }\\n        for(int i=0;i<N;i++){\\n            if(Find(i)==i and flag[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    DSU(int n){\\n        N = n;\\n        par = vector<int>(n,-1);\\n        sz = vector<int>(n,1);\\n        //edgeCount stores the count of edges from a node\\n        edgeCount = vector<int>(n,0);\\n    }\\n    void getUnion(int u,int v){\\n        Union(u,v);\\n    }\\n    int getCountOfComponents(){\\n        return getCount();\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU* D = new DSU(n);\\n        for(auto &e: edges){\\n            D->getUnion(e[0],e[1]);\\n        }\\n        return D->getCountOfComponents();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\nprivate:\\n    int N;\\n    vector<int> par,sz,edgeCount;\\n    int Find(int u){\\n        if(par[u]==-1){\\n            return u;\\n        }\\n        return par[u]=Find(par[u]);\\n    }\\n    void Union(int u, int v){\\n        //increament the edgeCount\\n        edgeCount[u]++;\\n        edgeCount[v]++;\\n        int s1 = Find(u);\\n        int s2 = Find(v);\\n        if(s1!=s2){\\n            if(sz[s1]>=sz[s2]){\\n                sz[s1]+=sz[s2];\\n                par[s2]=s1;\\n            }else{\\n                sz[s2]+=sz[s1];\\n                par[s1]=s2;\\n            } \\n        }\\n    }\\n    int getCount(){\\n        int cnt = 0;\\n        vector<int> flag(N,true);\\n        for(int i=0;i<N;i++){\\n            int par = Find(i);\\n            int reqSize = (sz[par]-1);\\n            if(flag[par] and edgeCount[i]!=reqSize){\\n                flag[par]=false;\\n            }\\n        }\\n        for(int i=0;i<N;i++){\\n            if(Find(i)==i and flag[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    DSU(int n){\\n        N = n;\\n        par = vector<int>(n,-1);\\n        sz = vector<int>(n,1);\\n        //edgeCount stores the count of edges from a node\\n        edgeCount = vector<int>(n,0);\\n    }\\n    void getUnion(int u,int v){\\n        Union(u,v);\\n    }\\n    int getCountOfComponents(){\\n        return getCount();\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU* D = new DSU(n);\\n        for(auto &e: edges){\\n            D->getUnion(e[0],e[1]);\\n        }\\n        return D->getCountOfComponents();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826842,
                "title": "count-the-number-of-complete-components-degree-hashset",
                "content": "A **connected component** is a subgraph of a graph in which there exists **a path between any two vertices**, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.\\n\\nThen in every single component of a graph the degree of every vertex in that component must be **one less then size of the component**\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        int deg[]=new int[n];\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        int vis[]=new int[n];\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0)\\n            {\\n                Set<Integer> hs=new HashSet<>();\\n                dfs(i,adj,vis,hs);\\n                int size=hs.size();\\n                int temp=0;\\n                for(int it:hs)\\n                {\\n                    if(size-1==deg[it])\\n                    {\\n                        temp++;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(temp==size)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int s,ArrayList<ArrayList<Integer>> adj,int[] vis,Set<Integer> hs)\\n    {\\n        vis[s]=1;\\n        hs.add(s);\\n        for(int it:adj.get(s))\\n        {\\n            if(vis[it]==0)\\n            {\\n                dfs(it,adj,vis,hs);\\n            }\\n        }\\n        return ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        int deg[]=new int[n];\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        int vis[]=new int[n];\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0)\\n            {\\n                Set<Integer> hs=new HashSet<>();\\n                dfs(i,adj,vis,hs);\\n                int size=hs.size();\\n                int temp=0;\\n                for(int it:hs)\\n                {\\n                    if(size-1==deg[it])\\n                    {\\n                        temp++;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(temp==size)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int s,ArrayList<ArrayList<Integer>> adj,int[] vis,Set<Integer> hs)\\n    {\\n        vis[s]=1;\\n        hs.add(s);\\n        for(int it:adj.get(s))\\n        {\\n            if(vis[it]==0)\\n            {\\n                dfs(it,adj,vis,hs);\\n            }\\n        }\\n        return ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825484,
                "title": "o-v-e-solution-beats-100",
                "content": "Use dfs to count the no. of edges and vertices of a component and then check if it is complete graph or not , if it is complete graph then increment the count of components otherwise not. \\n# Code\\n```\\nclass Solution:\\n  def __init__(self):\\n    self.mark = []\\n    self.g = [] \\n    self.eds = 0 \\n    self.nodes = 0 \\n\\n  def dfs(self, x:int, degree:int):\\n    self.mark[x] = True \\n    self.nodes += 1 \\n    for i in self.g[x]:\\n      if not self.mark[i]:\\n        self.dfs(i,degree) \\n      self.eds+=1\\n      \\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n    self.g = [[] for _ in range(n)] \\n    self.mark = [False  for _ in range(n)] \\n    ans = 0 \\n    for i in edges: \\n      x = i[0]\\n      y = i[1] \\n      self.g[x].append(y)\\n      self.g[y].append(x) \\n      \\n    for i in range(0,n):\\n      if not self.mark[i]:\\n        self.eds = 0 \\n        self.nodes = 0 \\n        self.dfs(i, len(self.g[i])) \\n        if (self.nodes - 1)*self.nodes == self.eds:\\n          ans+=1\\n        \\n    return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def __init__(self):\\n    self.mark = []\\n    self.g = [] \\n    self.eds = 0 \\n    self.nodes = 0 \\n\\n  def dfs(self, x:int, degree:int):\\n    self.mark[x] = True \\n    self.nodes += 1 \\n    for i in self.g[x]:\\n      if not self.mark[i]:\\n        self.dfs(i,degree) \\n      self.eds+=1\\n      \\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n    self.g = [[] for _ in range(n)] \\n    self.mark = [False  for _ in range(n)] \\n    ans = 0 \\n    for i in edges: \\n      x = i[0]\\n      y = i[1] \\n      self.g[x].append(y)\\n      self.g[y].append(x) \\n      \\n    for i in range(0,n):\\n      if not self.mark[i]:\\n        self.eds = 0 \\n        self.nodes = 0 \\n        self.dfs(i, len(self.g[i])) \\n        if (self.nodes - 1)*self.nodes == self.eds:\\n          ans+=1\\n        \\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823157,
                "title": "super-simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind out the no. of nodes and the no. of edges in all the components.\\nIf in a component, edges >= nodes*(nodes-1), it is a complete connected component.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse DFS to keep track of no. of edges and nodes in every component.\\n\\n# Complexity\\n- Time complexity: O(V + E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int src, vector<vector<int>>& adj, vector<int>& vis, int& nodes, int& edges){\\n        vis[src] = 1;\\n        nodes++;\\n        for(auto it: adj[src]){\\n            edges++;\\n            if(!vis[it]){\\n                dfs(it, adj, vis, nodes, edges);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        vector<vector<int>> adj(n);\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int nodes = 0, eges = 0;\\n        for(int i=0; i<n; i++){\\n            if(!vis[i]){\\n                dfs(i, adj, vis, nodes, eges);\\n                cout<<nodes<<\" \"<<eges<<endl;\\n                if(eges >= nodes*(nodes-1)) ans++;\\n                nodes = 0;\\n                eges = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int src, vector<vector<int>>& adj, vector<int>& vis, int& nodes, int& edges){\\n        vis[src] = 1;\\n        nodes++;\\n        for(auto it: adj[src]){\\n            edges++;\\n            if(!vis[it]){\\n                dfs(it, adj, vis, nodes, edges);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        vector<vector<int>> adj(n);\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int nodes = 0, eges = 0;\\n        for(int i=0; i<n; i++){\\n            if(!vis[i]){\\n                dfs(i, adj, vis, nodes, eges);\\n                cout<<nodes<<\" \"<<eges<<endl;\\n                if(eges >= nodes*(nodes-1)) ans++;\\n                nodes = 0;\\n                eges = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3820511,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThough this might not be a best solution but I had this in my mind when I tried to solve this. There might other better approches, even I will try to look for it, but now lets check this.\\n\\nSo the idea here is if we check the numbers of nodes any vertex is connected to and also insert them in an set, and then check all those nodes if they connected to the same(hence same size also) vertexes or not.\\nAfter exploring one Node, we will traverse it and mark all the connected as visited true. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is little complicated code to explain for me. \\n\\n**Step 1 :** create 2d vector for graph (here g);\\n**Step 2 :** build up an undirected graph\\n**Step 3 :** initialze count to 0, create set and visited vector to all false.\\n**Step 4 :** iterate through all the nodes if not visited.\\n**Step 5 :** insert it in set, then insert all the nodes connected with it in that set.\\n**Step 6 :** for temprary purpose intialize the flag with value true for every iteration of not visited nodes.\\n**Step 7 :** Now iterate through all the nodes and if the size of it is same as set(exclude the index i \\'of iteration\\', hence s.size()-1) and also that size should match with size of the very first node connection (for index i).\\n**Step 8 :** if the all the elements are present in the set and also step 7 is correct then all good, else set flag false;\\n**Step 9 :** if flag is true increment count because this the complete component.\\n**Step 10 :** now considering the ith index as source, traverse the graph and mark all the visited nodes.\\n**Step 11 :** clear the set and go for the next iteration of the loop.\\n**Step 12 :** return count. \\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n***Let me know if anything wrong in this solution***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int s, vector<vector<int>>& g, vector<bool>& visited){\\n        if(!visited[s]){\\n            visited[s] = true;\\n            for(int i = 0; i < g[s].size(); ++i)\\n                dfs( g[s][i], g, visited);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        for(auto edge : edges){\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        int count = 0;\\n        set<int> s;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < n; ++i){\\n            if(!visited[i]){\\n                // cout << i << \" \\\\n\";\\n                // visited[i] = true;\\n                s.insert(i);\\n                for(int j = 0; j < g[i].size(); ++j){\\n                    s.insert(g[i][j]);\\n                }\\n                bool flag = true;\\n                for(auto k = s.begin(); k != s.end(); ++k){\\n                    if(!((s.size()-1 == g[*k].size()) && g[*k].size() == g[i].size())){\\n                        flag = false;\\n                        break;\\n                    }\\n                    for(int x = 0; x < g[*k].size(); ++x){\\n                        if(s.find(g[*k][x]) == s.end()){\\n                            flag = false;\\n                            break;\\n                        } \\n                    }\\n                }\\n                if(flag){\\n                    count++;\\n                }\\n                dfs(i, g, visited);\\n                s.clear();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int s, vector<vector<int>>& g, vector<bool>& visited){\\n        if(!visited[s]){\\n            visited[s] = true;\\n            for(int i = 0; i < g[s].size(); ++i)\\n                dfs( g[s][i], g, visited);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        for(auto edge : edges){\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        int count = 0;\\n        set<int> s;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < n; ++i){\\n            if(!visited[i]){\\n                // cout << i << \" \\\\n\";\\n                // visited[i] = true;\\n                s.insert(i);\\n                for(int j = 0; j < g[i].size(); ++j){\\n                    s.insert(g[i][j]);\\n                }\\n                bool flag = true;\\n                for(auto k = s.begin(); k != s.end(); ++k){\\n                    if(!((s.size()-1 == g[*k].size()) && g[*k].size() == g[i].size())){\\n                        flag = false;\\n                        break;\\n                    }\\n                    for(int x = 0; x < g[*k].size(); ++x){\\n                        if(s.find(g[*k][x]) == s.end()){\\n                            flag = false;\\n                            break;\\n                        } \\n                    }\\n                }\\n                if(flag){\\n                    count++;\\n                }\\n                dfs(i, g, visited);\\n                s.clear();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3820438,
                "title": "easy-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFS and Connected Components\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the connected components of an undirected graph using depth-first search (DFS). For each connected components to be complete, each node of a particular connected components should have edges equal to size of components-1.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int vis[50];\\n    vector<int> graph[51];\\n\\n    void dfs(int node, vector<int>&cc){\\n        vis[node]  = 1;\\n\\n        for(auto child: graph[node]){\\n            if(!vis[child]){\\n                cc.push_back(child);\\n               \\n                dfs(child,cc);\\n            }\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n               \\n\\n                for(int i= 0; i<edges.size(); i++){\\n                    graph[edges[i][0]].push_back(edges[i][1]);\\n                    graph[edges[i][1]].push_back(edges[i][0]);\\n                }\\n\\n                vector<vector<int>> ccs;\\n\\n                int count = 0;\\n\\n                memset(vis,0,sizeof(vis));\\n\\n                bool flag = true;\\n\\n                for(int i=0; i<n;i++){\\n                if(!vis[i]){\\n                vector<int>cc;\\n                cc.push_back(i);\\n                dfs(i,cc);\\n                flag = true;\\n                \\n                for(int j=0; j<cc.size();j++){\\n                    if(graph[cc[j]].size()<cc.size()-1) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n\\n                if(flag != false)count++;                \\n              }\\n              \\n            }\\n\\n            return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[50];\\n    vector<int> graph[51];\\n\\n    void dfs(int node, vector<int>&cc){\\n        vis[node]  = 1;\\n\\n        for(auto child: graph[node]){\\n            if(!vis[child]){\\n                cc.push_back(child);\\n               \\n                dfs(child,cc);\\n            }\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n               \\n\\n                for(int i= 0; i<edges.size(); i++){\\n                    graph[edges[i][0]].push_back(edges[i][1]);\\n                    graph[edges[i][1]].push_back(edges[i][0]);\\n                }\\n\\n                vector<vector<int>> ccs;\\n\\n                int count = 0;\\n\\n                memset(vis,0,sizeof(vis));\\n\\n                bool flag = true;\\n\\n                for(int i=0; i<n;i++){\\n                if(!vis[i]){\\n                vector<int>cc;\\n                cc.push_back(i);\\n                dfs(i,cc);\\n                flag = true;\\n                \\n                for(int j=0; j<cc.size();j++){\\n                    if(graph[cc[j]].size()<cc.size()-1) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n\\n                if(flag != false)count++;                \\n              }\\n              \\n            }\\n\\n            return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819903,
                "title": "java-union-find-complete-connected-components",
                "content": "# Code\\n```\\nclass DisjointSet {\\n    List<Integer> parent=new ArrayList<>();\\n    List<Integer> rank=new ArrayList<>();\\n    public DisjointSet(int n) {\\n        for(int i=0;i<=n-1;++i) {\\n            parent.add(i);\\n            rank.add(0);\\n        }\\n    }\\n    public int findUPar(int node) {\\n        if(node==parent.get(node)) {\\n            return node;\\n        }\\n        int ulp_node=findUPar(parent.get(node));\\n        parent.set(node,ulp_node);\\n        return parent.get(node);\\n    }\\n    public void unionByRank(int u,int v) {\\n        int ulp_u=findUPar(u);\\n        int ulp_v=findUPar(v);\\n        if(ulp_u==ulp_v) {\\n            return;\\n        }\\n        if(rank.get(ulp_u)>rank.get(ulp_v)) {\\n            parent.set(ulp_v,ulp_u);\\n        }\\n        else if(rank.get(ulp_v)>rank.get(ulp_u)) {\\n            parent.set(ulp_u,ulp_v);\\n        }\\n        else {\\n            parent.set(ulp_v,ulp_u);\\n            int rankU=rank.get(ulp_u);\\n            rank.set(ulp_u,rankU+1);\\n        }\\n    }\\n}\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        // T.C. -> O(n*n+edges.length+n+n)\\n        // A.S. -> O(n*n+3*n+n)\\n        \\n        int[][] adjm=new int[n][n];\\n        for(int i=0;i<=n-1;++i) {\\n            for(int j=0;j<=n-1;++j) {\\n                adjm[i][j]=0;\\n            }\\n        }\\n        int m=edges.length;\\n        DisjointSet ds=new DisjointSet(n);\\n        for(int i=0;i<=m-1;++i) {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adjm[u][v]=1;\\n            adjm[v][u]=1;\\n            int ulp_u=ds.findUPar(u);\\n            int ulp_v=ds.findUPar(v);\\n            if(ulp_u!=ulp_v) {\\n                ds.unionByRank(u,v);\\n            }\\n        }\\n        Map<Integer,List<Integer>> mp=new HashMap<>();\\n        for(int i=0;i<=n-1;++i) {\\n            int ulp_i=ds.findUPar(i);\\n            if(mp.containsKey(ulp_i)!=true) {\\n                List<Integer> l=new ArrayList<>();\\n                l.add(i);\\n                mp.put(ulp_i,l);\\n            }\\n            else {\\n                List<Integer> l=mp.get(ulp_i);\\n                l.add(i);\\n                mp.put(ulp_i,l);\\n            }\\n        }\\n        int ans=0;\\n        for(Map.Entry<Integer,List<Integer>> p:mp.entrySet()) {\\n            List<Integer> l=p.getValue();\\n            boolean f=true;\\n            for(int i:l) {\\n                for(int j:l) {\\n                    if(i!=j) {\\n                        if(adjm[i][j]!=1) {\\n                            f=false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(f!=true) {\\n                    break;\\n                }\\n            }\\n            if(f==true) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DisjointSet {\\n    List<Integer> parent=new ArrayList<>();\\n    List<Integer> rank=new ArrayList<>();\\n    public DisjointSet(int n) {\\n        for(int i=0;i<=n-1;++i) {\\n            parent.add(i);\\n            rank.add(0);\\n        }\\n    }\\n    public int findUPar(int node) {\\n        if(node==parent.get(node)) {\\n            return node;\\n        }\\n        int ulp_node=findUPar(parent.get(node));\\n        parent.set(node,ulp_node);\\n        return parent.get(node);\\n    }\\n    public void unionByRank(int u,int v) {\\n        int ulp_u=findUPar(u);\\n        int ulp_v=findUPar(v);\\n        if(ulp_u==ulp_v) {\\n            return;\\n        }\\n        if(rank.get(ulp_u)>rank.get(ulp_v)) {\\n            parent.set(ulp_v,ulp_u);\\n        }\\n        else if(rank.get(ulp_v)>rank.get(ulp_u)) {\\n            parent.set(ulp_u,ulp_v);\\n        }\\n        else {\\n            parent.set(ulp_v,ulp_u);\\n            int rankU=rank.get(ulp_u);\\n            rank.set(ulp_u,rankU+1);\\n        }\\n    }\\n}\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        // T.C. -> O(n*n+edges.length+n+n)\\n        // A.S. -> O(n*n+3*n+n)\\n        \\n        int[][] adjm=new int[n][n];\\n        for(int i=0;i<=n-1;++i) {\\n            for(int j=0;j<=n-1;++j) {\\n                adjm[i][j]=0;\\n            }\\n        }\\n        int m=edges.length;\\n        DisjointSet ds=new DisjointSet(n);\\n        for(int i=0;i<=m-1;++i) {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adjm[u][v]=1;\\n            adjm[v][u]=1;\\n            int ulp_u=ds.findUPar(u);\\n            int ulp_v=ds.findUPar(v);\\n            if(ulp_u!=ulp_v) {\\n                ds.unionByRank(u,v);\\n            }\\n        }\\n        Map<Integer,List<Integer>> mp=new HashMap<>();\\n        for(int i=0;i<=n-1;++i) {\\n            int ulp_i=ds.findUPar(i);\\n            if(mp.containsKey(ulp_i)!=true) {\\n                List<Integer> l=new ArrayList<>();\\n                l.add(i);\\n                mp.put(ulp_i,l);\\n            }\\n            else {\\n                List<Integer> l=mp.get(ulp_i);\\n                l.add(i);\\n                mp.put(ulp_i,l);\\n            }\\n        }\\n        int ans=0;\\n        for(Map.Entry<Integer,List<Integer>> p:mp.entrySet()) {\\n            List<Integer> l=p.getValue();\\n            boolean f=true;\\n            for(int i:l) {\\n                for(int j:l) {\\n                    if(i!=j) {\\n                        if(adjm[i][j]!=1) {\\n                            f=false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(f!=true) {\\n                    break;\\n                }\\n            }\\n            if(f==true) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817413,
                "title": "dfs-count-nodes-and-edges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Edge{\\n        int src;\\n        int dest;\\n\\n        public Edge(int s, int d){\\n            this.src = s;\\n            this.dest = d;\\n        }\\n    }\\n    \\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //create a graph\\n        List<Edge> graph[] = new ArrayList[n];\\n        for(int i=0; i<n; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int ed[] : edges){\\n            graph[ed[0]].add(new Edge(ed[0], ed[1]));\\n            graph[ed[1]].add(new Edge(ed[1], ed[0]));\\n        }\\n        \\n        boolean vis[] = new boolean[n];\\n        List<int[]> components = new ArrayList<>();\\n        //components at 0 will be edges and at 1 will be nodes\\n        \\n        for(int i=0; i<n; i++){\\n            int arr[] = new int[2];\\n            if(!vis[i]){                \\n                dfs(graph, vis, i, arr);\\n                components.add(arr); \\n            }                 \\n        }\\n\\n        int compo = 0; //calculate components using formula m*(m-1)/2\\n        for(int i=0; i<components.size(); i++){\\n            int temp[] = components.get(i);\\n            int edge = temp[1]/2;\\n            int nodes = temp[0];\\n            int cal = (nodes * (nodes-1))/2;\\n            if(edge == cal){\\n                compo++;\\n            }\\n        }\\n        return compo;\\n    }\\n    private void dfs(List<Edge> graph[], boolean vis[], int curr, int arr[]){\\n        vis[curr] = true;\\n        arr[0]++; //nodes increment\\n        for(int i=0; i<graph[curr].size(); i++){\\n            Edge e = graph[curr].get(i);\\n            arr[1]++; //edges increment\\n            if(!vis[e.dest]){                \\n                dfs(graph, vis, e.dest, arr);\\n            }            \\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Edge{\\n        int src;\\n        int dest;\\n\\n        public Edge(int s, int d){\\n            this.src = s;\\n            this.dest = d;\\n        }\\n    }\\n    \\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //create a graph\\n        List<Edge> graph[] = new ArrayList[n];\\n        for(int i=0; i<n; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int ed[] : edges){\\n            graph[ed[0]].add(new Edge(ed[0], ed[1]));\\n            graph[ed[1]].add(new Edge(ed[1], ed[0]));\\n        }\\n        \\n        boolean vis[] = new boolean[n];\\n        List<int[]> components = new ArrayList<>();\\n        //components at 0 will be edges and at 1 will be nodes\\n        \\n        for(int i=0; i<n; i++){\\n            int arr[] = new int[2];\\n            if(!vis[i]){                \\n                dfs(graph, vis, i, arr);\\n                components.add(arr); \\n            }                 \\n        }\\n\\n        int compo = 0; //calculate components using formula m*(m-1)/2\\n        for(int i=0; i<components.size(); i++){\\n            int temp[] = components.get(i);\\n            int edge = temp[1]/2;\\n            int nodes = temp[0];\\n            int cal = (nodes * (nodes-1))/2;\\n            if(edge == cal){\\n                compo++;\\n            }\\n        }\\n        return compo;\\n    }\\n    private void dfs(List<Edge> graph[], boolean vis[], int curr, int arr[]){\\n        vis[curr] = true;\\n        arr[0]++; //nodes increment\\n        for(int i=0; i<graph[curr].size(); i++){\\n            Edge e = graph[curr].get(i);\\n            arr[1]++; //edges increment\\n            if(!vis[e.dest]){                \\n                dfs(graph, vis, e.dest, arr);\\n            }            \\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813968,
                "title": "c-solution-dfs-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(N) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        // Get Adjacency List\\n        IList<IList<int>> adj = GetAdj(n, edges);\\n        int count = 0;\\n        \\n        // Stores Considered Nodes\\n        HashSet<int> considered = new HashSet<int>();\\n\\n        for(int i=0; i<n; i++){\\n            if(considered.Contains(i)){\\n                continue;\\n            }\\n\\n            HashSet<int> graphNodes = new();\\n            GetConnectedGraphNodes(adj, i, graphNodes);\\n            int edgesCount = graphNodes.Count - 1;\\n            bool isConnected = true;\\n\\n            foreach(var node in graphNodes){\\n                considered.Add(node);\\n\\n                if(adj[node].Count != edgesCount){\\n                    isConnected = false;\\n                }\\n            }\\n\\n            if(isConnected){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void GetConnectedGraphNodes(IList<IList<int>> adj, int currentNode, HashSet<int> graphNodes){\\n        if(graphNodes.Contains(currentNode)){\\n            return;\\n        }\\n\\n        graphNodes.Add(currentNode);\\n\\n        foreach(var childNode in  adj[currentNode]){\\n            GetConnectedGraphNodes(adj, childNode, graphNodes);\\n        }\\n    }\\n\\n    private IList<IList<int>> GetAdj(int n, int[][] edges){\\n        IList<IList<int>> adj = new List<IList<int>>();\\n\\n        for(int i=0; i<n; i++){\\n            adj.Add(new List<int>());\\n        }\\n\\n        foreach(var edge in edges){\\n            adj[edge[0]].Add(edge[1]);\\n            adj[edge[1]].Add(edge[0]);\\n        }\\n\\n        return adj;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        // Get Adjacency List\\n        IList<IList<int>> adj = GetAdj(n, edges);\\n        int count = 0;\\n        \\n        // Stores Considered Nodes\\n        HashSet<int> considered = new HashSet<int>();\\n\\n        for(int i=0; i<n; i++){\\n            if(considered.Contains(i)){\\n                continue;\\n            }\\n\\n            HashSet<int> graphNodes = new();\\n            GetConnectedGraphNodes(adj, i, graphNodes);\\n            int edgesCount = graphNodes.Count - 1;\\n            bool isConnected = true;\\n\\n            foreach(var node in graphNodes){\\n                considered.Add(node);\\n\\n                if(adj[node].Count != edgesCount){\\n                    isConnected = false;\\n                }\\n            }\\n\\n            if(isConnected){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void GetConnectedGraphNodes(IList<IList<int>> adj, int currentNode, HashSet<int> graphNodes){\\n        if(graphNodes.Contains(currentNode)){\\n            return;\\n        }\\n\\n        graphNodes.Add(currentNode);\\n\\n        foreach(var childNode in  adj[currentNode]){\\n            GetConnectedGraphNodes(adj, childNode, graphNodes);\\n        }\\n    }\\n\\n    private IList<IList<int>> GetAdj(int n, int[][] edges){\\n        IList<IList<int>> adj = new List<IList<int>>();\\n\\n        for(int i=0; i<n; i++){\\n            adj.Add(new List<int>());\\n        }\\n\\n        foreach(var edge in edges){\\n            adj[edge[0]].Add(edge[1]);\\n            adj[edge[1]].Add(edge[0]);\\n        }\\n\\n        return adj;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812270,
                "title": "elegent-dfs-approach",
                "content": "# Approach\\n- First get all the connected components & then check if those connected components are complete or not.\\n\\n# Complexity\\n- Time complexity:\\nO(N) + O(C^3) Where N is number of vertex & c is number of connected components\\n\\n- Space complexity:\\nO(3N)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    HashSet<int>[] adjList;\\n    bool[] isSeen;\\n    IList<IList<int>> ltComponents;\\n\\n    public int CountCompleteComponents(int n, int[][] edges)\\n    {\\n        adjList = new HashSet<int>[n];\\n        isSeen = new bool[n];\\n        ltComponents = new List<IList<int>>();\\n        for (int i = 0; i < n; i++)\\n            adjList[i] = new HashSet<int>();\\n\\n        //Prepare adjList\\n        foreach (int[] edge in edges)\\n        {\\n            adjList[edge[0]].Add(edge[1]);\\n            adjList[edge[1]].Add(edge[0]);\\n        }\\n\\n        //Get the number of connected components & nodes in them\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (isSeen[i])\\n                continue;\\n\\n            List<int> ltComp = new List<int>();\\n            DFS(i, ltComp);\\n            ltComponents.Add(ltComp);\\n        }\\n\\n        //Check which components are complete\\n        int completeComponents = 0;\\n        foreach (IList<int> component in ltComponents)\\n        {\\n            int verticesCount = component.Count;\\n            bool consider = true;\\n\\n            foreach (int vertex in component)\\n            {\\n                var adjNds = adjList[vertex];\\n                if (adjNds.Count != verticesCount - 1)\\n                {\\n                    consider = false;\\n                    break;\\n                }\\n\\n                foreach (int element in component)\\n                {\\n                    if (element == vertex)\\n                        continue;\\n\\n                    if (!adjNds.Contains(element))\\n                    {\\n                        consider = false;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (consider)\\n                ++completeComponents;\\n        }\\n\\n        return completeComponents;\\n    }\\n\\n    private void DFS(int node, IList<int> ltComp)\\n    {\\n        if (isSeen[node])\\n            return;\\n\\n        isSeen[node] = true;\\n        ltComp.Add(node);\\n\\n        var adjNodes = adjList[node];\\n        foreach (int nd in adjNodes)\\n            DFS(nd, ltComp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic class Solution\\n{\\n    HashSet<int>[] adjList;\\n    bool[] isSeen;\\n    IList<IList<int>> ltComponents;\\n\\n    public int CountCompleteComponents(int n, int[][] edges)\\n    {\\n        adjList = new HashSet<int>[n];\\n        isSeen = new bool[n];\\n        ltComponents = new List<IList<int>>();\\n        for (int i = 0; i < n; i++)\\n            adjList[i] = new HashSet<int>();\\n\\n        //Prepare adjList\\n        foreach (int[] edge in edges)\\n        {\\n            adjList[edge[0]].Add(edge[1]);\\n            adjList[edge[1]].Add(edge[0]);\\n        }\\n\\n        //Get the number of connected components & nodes in them\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (isSeen[i])\\n                continue;\\n\\n            List<int> ltComp = new List<int>();\\n            DFS(i, ltComp);\\n            ltComponents.Add(ltComp);\\n        }\\n\\n        //Check which components are complete\\n        int completeComponents = 0;\\n        foreach (IList<int> component in ltComponents)\\n        {\\n            int verticesCount = component.Count;\\n            bool consider = true;\\n\\n            foreach (int vertex in component)\\n            {\\n                var adjNds = adjList[vertex];\\n                if (adjNds.Count != verticesCount - 1)\\n                {\\n                    consider = false;\\n                    break;\\n                }\\n\\n                foreach (int element in component)\\n                {\\n                    if (element == vertex)\\n                        continue;\\n\\n                    if (!adjNds.Contains(element))\\n                    {\\n                        consider = false;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (consider)\\n                ++completeComponents;\\n        }\\n\\n        return completeComponents;\\n    }\\n\\n    private void DFS(int node, IList<int> ltComp)\\n    {\\n        if (isSeen[node])\\n            return;\\n\\n        isSeen[node] = true;\\n        ltComp.Add(node);\\n\\n        var adjNodes = adjList[node];\\n        foreach (int nd in adjNodes)\\n            DFS(nd, ltComp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799472,
                "title": "c-simple-dfs-connected-component",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<vector<int>>&adj, unordered_set<int>&st, vector<int>&vis)\\n    {\\n        vis[node] = 1;\\n        st.insert(node);\\n        \\n        for(auto j : adj[node])\\n        {\\n            if(!vis[j])\\n            {\\n                dfs(j, adj, st, vis);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int  ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                bool flag = true;\\n                unordered_set<int>st;\\n                dfs(i,adj,st,vis);\\n                int sz = st.size()-1;\\n                for(auto k : st)\\n                {\\n                    if(adj[k].size() != sz)\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag)ans++;\\n                \\n                st.clear();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<vector<int>>&adj, unordered_set<int>&st, vector<int>&vis)\\n    {\\n        vis[node] = 1;\\n        st.insert(node);\\n        \\n        for(auto j : adj[node])\\n        {\\n            if(!vis[j])\\n            {\\n                dfs(j, adj, st, vis);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int  ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                bool flag = true;\\n                unordered_set<int>st;\\n                dfs(i,adj,st,vis);\\n                int sz = st.size()-1;\\n                for(auto k : st)\\n                {\\n                    if(adj[k].size() != sz)\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag)ans++;\\n                \\n                st.clear();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794237,
                "title": "easy-explained-sol-for-newbies",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust a normal bfs or dfs traversal to count the subgraphs.\\n1.Convert the edges into adjacency list for bidirectinal graph.\\n2.Traverse in the graph for every node mark if it is visited.Once the graph is visited completely calculate the vertices and edges at the same time and store it .\\n3.Each time after calculating for a subgraph check if the edges are equal to vertice*(vertices-1)if yeas increment the count.\\n4.Similarly calculate for each graph and check if it is complete.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->TC:-O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> dfs(vector<int> adj[],vector<int>&vis,int node){\\n        vis[node]=1;\\n        int v=1,e=adj[node].size();\\n        for(int x:adj[node]){\\n            if(!vis[x]){\\n              pair<int,int> temp=  dfs(adj,vis,x);\\n              v+=temp.first;\\n              e+=temp.second;\\n            }\\n        }\\n        return {v,e};\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n      vector<int>adj[n];\\n      for(auto x:edges){\\n              adj[x[0]].push_back(x[1]);\\n              adj[x[1]].push_back(x[0]);\\n      }  \\n      vector<int>vis(n,0); \\n      int count=0;\\n      for(int i=0;i<n;i++){\\n          if(!vis[i]){\\n            pair<int,int>tmp=  dfs(adj,vis,i);\\n            int ver=tmp.first;\\n            int edg=tmp.second;\\n            if(ver*(ver-1)==edg){\\n                count++;\\n            }\\n          }\\n      }\\n     return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> dfs(vector<int> adj[],vector<int>&vis,int node){\\n        vis[node]=1;\\n        int v=1,e=adj[node].size();\\n        for(int x:adj[node]){\\n            if(!vis[x]){\\n              pair<int,int> temp=  dfs(adj,vis,x);\\n              v+=temp.first;\\n              e+=temp.second;\\n            }\\n        }\\n        return {v,e};\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n      vector<int>adj[n];\\n      for(auto x:edges){\\n              adj[x[0]].push_back(x[1]);\\n              adj[x[1]].push_back(x[0]);\\n      }  \\n      vector<int>vis(n,0); \\n      int count=0;\\n      for(int i=0;i<n;i++){\\n          if(!vis[i]){\\n            pair<int,int>tmp=  dfs(adj,vis,i);\\n            int ver=tmp.first;\\n            int edg=tmp.second;\\n            if(ver*(ver-1)==edg){\\n                count++;\\n            }\\n          }\\n      }\\n     return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781706,
                "title": "easy-solution-cpp-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing DFS i will count the number of node and edges for each component\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif tot_node*(tot_node-1) == tot_edges(component for corrospoding dfs call) then it is counted in complete component \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*(n-1))// worst case\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*(n-1))+auxiliary space of recursion\\n# Code\\n```\\nclass Solution {\\n    public:\\n    int dfs(int node,vector<vector<int>> &adj, vector<int> &vis,int &edg){\\n        vis[node]=1;\\n      int ct=0;\\n        for(auto it: adj[node]){\\n            edg++;\\n            if(vis[it]!=1) ct+=dfs(it,adj,vis,edg);\\n        }\\n        return ct+1;\\n\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<vector<int>> adj(n);\\n        int m=e.size();\\n        vector<int> vis(n,0);\\n        int ans=0;\\n        for(int i=0; i<m; i++){\\n            adj[e[i][0]].push_back(e[i][1]);\\n            adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(vis[i]!=1){ \\n                int tot_edg=0;\\n                int tot_node=dfs(i,adj,vis,tot_edg);\\n                if(tot_edg==(tot_node*(tot_node-1))) ans++;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    int dfs(int node,vector<vector<int>> &adj, vector<int> &vis,int &edg){\\n        vis[node]=1;\\n      int ct=0;\\n        for(auto it: adj[node]){\\n            edg++;\\n            if(vis[it]!=1) ct+=dfs(it,adj,vis,edg);\\n        }\\n        return ct+1;\\n\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<vector<int>> adj(n);\\n        int m=e.size();\\n        vector<int> vis(n,0);\\n        int ans=0;\\n        for(int i=0; i<m; i++){\\n            adj[e[i][0]].push_back(e[i][1]);\\n            adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(vis[i]!=1){ \\n                int tot_edg=0;\\n                int tot_node=dfs(i,adj,vis,tot_edg);\\n                if(tot_edg==(tot_node*(tot_node-1))) ans++;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781618,
                "title": "dfs-solution-count-edges-and-nodes",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int nodes, edge;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int edge[] : edges) {\\n            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\\n            graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(edge[0]);\\n        }\\n        int ans = 0;\\n        boolean visited[] = new boolean[n];\\n        for (int i = 0 ; i < n ; i ++) {\\n            nodes = 0;\\n            edge = 0;\\n            if (visited[i])\\n                continue;\\n            \\n            dfs(graph,  visited, i);\\n            if ((nodes * (nodes - 1)) == edge)\\n                ans++;\\n            //System.out.println(nodes + \" \" + edge);\\n            int nodes = 0, edge = 0;\\n            visited[i] = true;\\n        }\\n        return ans;\\n    }\\n\\n    public void dfs (Map<Integer, List<Integer>> graph,  boolean visited [], int currNode) {\\n        if (visited[currNode])\\n            return;\\n        visited[currNode] = true;\\n        nodes++;\\n        for (Integer node : graph.getOrDefault(currNode, new ArrayList<>())) {\\n            edge++;\\n            dfs(graph, visited, node);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int nodes, edge;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int edge[] : edges) {\\n            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\\n            graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(edge[0]);\\n        }\\n        int ans = 0;\\n        boolean visited[] = new boolean[n];\\n        for (int i = 0 ; i < n ; i ++) {\\n            nodes = 0;\\n            edge = 0;\\n            if (visited[i])\\n                continue;\\n            \\n            dfs(graph,  visited, i);\\n            if ((nodes * (nodes - 1)) == edge)\\n                ans++;\\n            //System.out.println(nodes + \" \" + edge);\\n            int nodes = 0, edge = 0;\\n            visited[i] = true;\\n        }\\n        return ans;\\n    }\\n\\n    public void dfs (Map<Integer, List<Integer>> graph,  boolean visited [], int currNode) {\\n        if (visited[currNode])\\n            return;\\n        visited[currNode] = true;\\n        nodes++;\\n        for (Integer node : graph.getOrDefault(currNode, new ArrayList<>())) {\\n            edge++;\\n            dfs(graph, visited, node);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778615,
                "title": "c-easy-colution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void prepareList(unordered_map<int,set<int>>&adj,vector<vector<int>>& edges){\\n\\n        for(int i = 0; i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n\\n    }\\n    void dfs(int i,unordered_map<int,bool>&visited,vector<int>&component,unordered_map<int,set<int>>&adj){\\n        if(visited[i]) return;\\n\\n        visited[i] = true;\\n        component.push_back(i);\\n\\n        for(auto &it: adj[i]){\\n            dfs(it,visited,component,adj);\\n        }\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,set<int>>adj;\\n        unordered_map<int,bool>visited;\\n\\n        prepareList(adj,edges);\\n\\n        int count = 0;\\n\\n        for(int i = 0; i<n;i++){\\n            if(!visited[i]){\\n                vector<int>nodes;\\n\\n                dfs(i,visited,nodes,adj);\\n                int res = 0; \\n                for(int j = 0; j<nodes.size();j++){\\n                    if(adj[nodes[j]].size() >= nodes.size()-1) res++;\\n                }\\n\\n                if(res == nodes.size()) count++;\\n\\n            }\\n        }\\n       return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void prepareList(unordered_map<int,set<int>>&adj,vector<vector<int>>& edges){\\n\\n        for(int i = 0; i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n\\n    }\\n    void dfs(int i,unordered_map<int,bool>&visited,vector<int>&component,unordered_map<int,set<int>>&adj){\\n        if(visited[i]) return;\\n\\n        visited[i] = true;\\n        component.push_back(i);\\n\\n        for(auto &it: adj[i]){\\n            dfs(it,visited,component,adj);\\n        }\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,set<int>>adj;\\n        unordered_map<int,bool>visited;\\n\\n        prepareList(adj,edges);\\n\\n        int count = 0;\\n\\n        for(int i = 0; i<n;i++){\\n            if(!visited[i]){\\n                vector<int>nodes;\\n\\n                dfs(i,visited,nodes,adj);\\n                int res = 0; \\n                for(int j = 0; j<nodes.size();j++){\\n                    if(adj[nodes[j]].size() >= nodes.size()-1) res++;\\n                }\\n\\n                if(res == nodes.size()) count++;\\n\\n            }\\n        }\\n       return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778322,
                "title": "intutive-dfs-one-is-for-adjacencylist-size-and-another-for-component-size",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int res=0;\\n        boolean[]visited=new boolean[n];\\n        boolean []vis=new boolean[n];\\n        for(int i=0;i<n;i++) {\\n            if (!visited[i]) {\\n                int size = findingcomponentsize(i, adj, visited) + 1;\\n                if (size != 1) {\\n                    boolean flag = checkingadjlistsize(i, size - 1, adj, vis);\\n                    if (flag) {\\n                        res++;\\n                    }\\n                }\\n                else{\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public int findingcomponentsize(int src,ArrayList<ArrayList<Integer>>adj,boolean[]visited){\\n        visited[src]=true;\\n        int count=0;\\n        for(int element:adj.get(src)){\\n            if (!visited[element]){\\n                count=1+findingcomponentsize(element,adj,visited);\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean checkingadjlistsize(int src,int size,ArrayList<ArrayList<Integer>>adj,boolean[]vis){\\n\\n        vis[src]=true;\\n\\n        if(adj.get(src).size()!=size){\\n            return false;\\n        }\\n        for(int el:adj.get(src)){\\n            if(!vis[el]) {\\n                boolean b = checkingadjlistsize(el, size, adj,vis);\\n                if (!b) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int res=0;\\n        boolean[]visited=new boolean[n];\\n        boolean []vis=new boolean[n];\\n        for(int i=0;i<n;i++) {\\n            if (!visited[i]) {\\n                int size = findingcomponentsize(i, adj, visited) + 1;\\n                if (size != 1) {\\n                    boolean flag = checkingadjlistsize(i, size - 1, adj, vis);\\n                    if (flag) {\\n                        res++;\\n                    }\\n                }\\n                else{\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public int findingcomponentsize(int src,ArrayList<ArrayList<Integer>>adj,boolean[]visited){\\n        visited[src]=true;\\n        int count=0;\\n        for(int element:adj.get(src)){\\n            if (!visited[element]){\\n                count=1+findingcomponentsize(element,adj,visited);\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean checkingadjlistsize(int src,int size,ArrayList<ArrayList<Integer>>adj,boolean[]vis){\\n\\n        vis[src]=true;\\n\\n        if(adj.get(src).size()!=size){\\n            return false;\\n        }\\n        for(int el:adj.get(src)){\\n            if(!vis[el]) {\\n                boolean b = checkingadjlistsize(el, size, adj,vis);\\n                if (!b) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773848,
                "title": "dictionary-of-all-connections-per-element-96-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/0ed60561-e4f3-4f9f-999f-8605ceda001a_1689514900.510338.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        connections = {i: {i} for i in range(n)}\\n        for a, b in edges:\\n            connections[a].add(b)\\n            connections[b].add(a)\\n        nodes = [i for i in range(n)]\\n        nodes.sort(key=lambda i: -len(connections[i]))\\n        eliminated = set()\\n        count = 0\\n        for node in nodes:\\n            if node in eliminated:\\n                continue\\n            group = connections[node]\\n            if all(connections[element] == group for element in group):\\n                count += 1\\n            eliminated.update(group)\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        connections = {i: {i} for i in range(n)}\\n        for a, b in edges:\\n            connections[a].add(b)\\n            connections[b].add(a)\\n        nodes = [i for i in range(n)]\\n        nodes.sort(key=lambda i: -len(connections[i]))\\n        eliminated = set()\\n        count = 0\\n        for node in nodes:\\n            if node in eliminated:\\n                continue\\n            group = connections[node]\\n            if all(connections[element] == group for element in group):\\n                count += 1\\n            eliminated.update(group)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766270,
                "title": "o-n-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUse DFS and every time DFS restarts is a start of a new component \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nTakes $O(n + m)$ time using DFS; going through each component and check if the adjList == m - 1 takes $O(n)$ time because there are n total nodes that we go through and getting the length of a list takes $O(1)$ time\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is $O(n + m)$ to store the components, explored array, adjList. \\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n\\n        adjList = {}\\n\\n        for i in range(n):\\n            adjList[i] = []\\n\\n        for edge in edges:\\n\\n            u = edge[0] \\n\\n            v = edge[1]\\n\\n            adjList[u].append(v)\\n\\n            adjList[v].append(u)\\n\\n        explored = [False for i in range(n)]\\n\\n        components = {}\\n\\n        def search(v, component):\\n\\n            explored[v] = True \\n\\n            components[component].append(v)\\n\\n            for w in adjList[v]:\\n                if not explored[w]:\\n                    search(w, component)\\n\\n        def dfs():\\n            component = 0 \\n            for i in range(n):\\n                if not explored[i]:\\n                    components[component] = []\\n                    search(i, component)\\n                    component += 1 \\n\\n        dfs()\\n\\n        completeCount = 0 \\n        \\n\\n        for k in components:\\n            m = len(components[k])\\n            Complete = True\\n            for node in components[k]:\\n                if len(adjList[node]) != m - 1:\\n                    Complete = False \\n                    break \\n            if Complete == True:\\n                completeCount += 1\\n\\n        return completeCount\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n\\n        adjList = {}\\n\\n        for i in range(n):\\n            adjList[i] = []\\n\\n        for edge in edges:\\n\\n            u = edge[0] \\n\\n            v = edge[1]\\n\\n            adjList[u].append(v)\\n\\n            adjList[v].append(u)\\n\\n        explored = [False for i in range(n)]\\n\\n        components = {}\\n\\n        def search(v, component):\\n\\n            explored[v] = True \\n\\n            components[component].append(v)\\n\\n            for w in adjList[v]:\\n                if not explored[w]:\\n                    search(w, component)\\n\\n        def dfs():\\n            component = 0 \\n            for i in range(n):\\n                if not explored[i]:\\n                    components[component] = []\\n                    search(i, component)\\n                    component += 1 \\n\\n        dfs()\\n\\n        completeCount = 0 \\n        \\n\\n        for k in components:\\n            m = len(components[k])\\n            Complete = True\\n            for node in components[k]:\\n                if len(adjList[node]) != m - 1:\\n                    Complete = False \\n                    break \\n            if Complete == True:\\n                completeCount += 1\\n\\n        return completeCount\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752186,
                "title": "simple-dfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int i,vector<int>&vis,vector<int>&vec)\\n    {\\n        vis[i]=1;\\n        vec.push_back(i);\\n        for(auto it:adj[i])\\n        {   \\n            if(!vis[it])\\n            {\\n                dfs(adj,it,vis,vec);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int cnt=0;\\n        vector<int>vis(n,0);\\n        vector<int>vec;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(adj,i,vis,vec);\\n                int flag=0;\\n                int sz=vec.size()-1;\\n                for(int j=0;j<vec.size();j++)\\n                {\\n                   if(sz!=adj[vec[j]].size())\\n                   {\\n                       flag=1;\\n                       break;\\n                   }                    \\n                }\\n                if(!flag)\\n                cnt++;\\n                vec.clear();\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int i,vector<int>&vis,vector<int>&vec)\\n    {\\n        vis[i]=1;\\n        vec.push_back(i);\\n        for(auto it:adj[i])\\n        {   \\n            if(!vis[it])\\n            {\\n                dfs(adj,it,vis,vec);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int cnt=0;\\n        vector<int>vis(n,0);\\n        vector<int>vec;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(adj,i,vis,vec);\\n                int flag=0;\\n                int sz=vec.size()-1;\\n                for(int j=0;j<vec.size();j++)\\n                {\\n                   if(sz!=adj[vec[j]].size())\\n                   {\\n                       flag=1;\\n                       break;\\n                   }                    \\n                }\\n                if(!flag)\\n                cnt++;\\n                vec.clear();\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749221,
                "title": "easy-c-solution-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,vector<vector<int>>&adj,vector<int>&vis){\\n        vis[i]=1;\\n        for(int k=0;k<adj[i].size();k++){\\n            if(vis[adj[i][k]]==0) solve(adj[i][k],adj,vis);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<e.size();i++){\\n            adj[e[i][0]].push_back(e[i][1]);\\n            adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                solve(i,adj,vis);\\n                int count=0;\\n                bool temp=true;\\n                for(int j=0;j<n;j++){\\n                    if(vis[j]==1) count++;\\n                }\\n                for(int j=0;j<n;j++){\\n                    if(vis[j]==1){\\n                        if(adj[j].size()!=count-1) temp=false;\\n                        vis[j]=2;\\n                    } \\n                }\\n                if(temp) res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,vector<vector<int>>&adj,vector<int>&vis){\\n        vis[i]=1;\\n        for(int k=0;k<adj[i].size();k++){\\n            if(vis[adj[i][k]]==0) solve(adj[i][k],adj,vis);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<e.size();i++){\\n            adj[e[i][0]].push_back(e[i][1]);\\n            adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                solve(i,adj,vis);\\n                int count=0;\\n                bool temp=true;\\n                for(int j=0;j<n;j++){\\n                    if(vis[j]==1) count++;\\n                }\\n                for(int j=0;j<n;j++){\\n                    if(vis[j]==1){\\n                        if(adj[j].size()!=count-1) temp=false;\\n                        vis[j]=2;\\n                    } \\n                }\\n                if(temp) res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738352,
                "title": "beats-98-in-runtime-77-in-memory-dfs-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738351,
                "title": "beats-98-in-runtime-77-in-memory-dfs-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738350,
                "title": "beats-98-in-runtime-77-in-memory-dfs-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734734,
                "title": "dsu-degree-solution",
                "content": "# Complexity\\n- [Time complexity:](https://cp-algorithms.com/data_structures/disjoint_set_union.html#time-complexity) $O(n.\\\\alpha(n))$  \\n\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass DSU {\\npublic:\\n    vector<int> p, r, sz;\\n    int n, cc;\\n\\n    DSU() {\\n        n = 0;\\n    }\\n    \\n    DSU(int _n) {\\n        cc = n = _n;\\n        p = r = sz = vector<int>(n, 1);\\n        for(int i = 0; i < n; i++) p[i] = i;\\n    }\\n    \\n    int find(int x) {\\n        assert(0 <= x and x < n);\\n        int y = x;\\n        while(x != p[x]) x = p[x];\\n        while(y != p[y]) {\\n            int z = p[y];\\n            p[y] = x;\\n            y = z;\\n        }\\n        return x;\\n    }\\n    \\n    void join(int x, int y) {\\n        assert(0 <= x and x < n and 0 <= y and y < n);\\n        x = find(x), y = find(y);\\n        if(x == y) return;\\n        if(r[x] > r[y]) swap(x, y); // for rank heuristics\\n        // if(sz[x] > sz[y]) swap(x, y); // to size heuristics\\n        p[x] = y;\\n        sz[y] += sz[x];\\n        r[y] += r[x] == r[y];\\n        cc--;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU uf(n);\\n        vector<int> deg(n, 0);\\n        for (auto& e: edges) {\\n            int u = e[0], v = e[1];\\n            uf.join(u, v);\\n            deg[u]++, deg[v]++;\\n        }\\n        int ans = 0;\\n        vector<int> cnt(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            int u = uf.find(i);\\n            int sz = uf.sz[u];\\n            if (deg[i] == sz - 1) {\\n                cnt[u]++;\\n                ans += (cnt[u] == sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DSU {\\npublic:\\n    vector<int> p, r, sz;\\n    int n, cc;\\n\\n    DSU() {\\n        n = 0;\\n    }\\n    \\n    DSU(int _n) {\\n        cc = n = _n;\\n        p = r = sz = vector<int>(n, 1);\\n        for(int i = 0; i < n; i++) p[i] = i;\\n    }\\n    \\n    int find(int x) {\\n        assert(0 <= x and x < n);\\n        int y = x;\\n        while(x != p[x]) x = p[x];\\n        while(y != p[y]) {\\n            int z = p[y];\\n            p[y] = x;\\n            y = z;\\n        }\\n        return x;\\n    }\\n    \\n    void join(int x, int y) {\\n        assert(0 <= x and x < n and 0 <= y and y < n);\\n        x = find(x), y = find(y);\\n        if(x == y) return;\\n        if(r[x] > r[y]) swap(x, y); // for rank heuristics\\n        // if(sz[x] > sz[y]) swap(x, y); // to size heuristics\\n        p[x] = y;\\n        sz[y] += sz[x];\\n        r[y] += r[x] == r[y];\\n        cc--;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU uf(n);\\n        vector<int> deg(n, 0);\\n        for (auto& e: edges) {\\n            int u = e[0], v = e[1];\\n            uf.join(u, v);\\n            deg[u]++, deg[v]++;\\n        }\\n        int ans = 0;\\n        vector<int> cnt(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            int u = uf.find(i);\\n            int sz = uf.sz[u];\\n            if (deg[i] == sz - 1) {\\n                cnt[u]++;\\n                ans += (cnt[u] == sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732153,
                "title": "rust-solution-using-union-find",
                "content": "# Code\\n```\\nuse std::collections::*;\\n\\nstruct UnionFind {\\n  parents: Vec<usize>,\\n  sizes: Vec<usize>,\\n  ranks: Vec<usize>\\n}\\n\\nimpl UnionFind {\\n  fn new(n:usize) -> UnionFind {\\n    let mut uf = UnionFind { parents: vec![0;n], sizes:vec![1;n], ranks:vec![0;n] };\\n    for i in 0..n {\\n      uf.parents[i] = i;\\n    }\\n    uf\\n  }\\n\\n  fn root(&mut self, x:usize) -> usize {\\n    let ti = self.parents[x];\\n    if ti == x {\\n      x\\n    } else {\\n      self.parents[x] = self.root(ti);\\n      self.parents[x]\\n    }\\n  }\\n\\n  fn is_same(&mut self, x:usize, y:usize) -> bool {\\n    self.root(x) == self.root(y)\\n  }\\n\\n  fn unite(&mut self, x:usize, y:usize) -> bool {\\n    let rx = self.root(x);\\n    let ry = self.root(y);\\n    if rx == ry { return false }\\n    let (rx, ry) = if self.ranks[rx] < self.ranks[ry] {\\n      (ry, rx)\\n    } else {\\n      (rx, ry)\\n    };\\n    self.parents[ry] = rx;\\n    if self.ranks[rx] == self.ranks[ry] {\\n      self.ranks[rx] += 1;\\n    }\\n\\n    self.sizes[rx] += self.sizes[ry];\\n    true\\n  }\\n\\n  fn group_size(&mut self, x:usize) -> usize {\\n    let i = self.root(x);\\n    self.sizes[i]\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn count_complete_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n    let n = n as usize;\\n    let mut g = vec![vec![];n];\\n    let mut tree = UnionFind::new(n);\\n\\n    for arr in &edges {\\n      let a = arr[0] as usize;\\n      let b = arr[1] as usize;\\n\\n      g[a].push(b);\\n      g[b].push(a);\\n      tree.unite(a, b);\\n    } \\n\\n    let mut map = HashMap::new();\\n    for i in 0..n {\\n      let pi = tree.root(i);\\n      map.entry(pi).or_insert(vec![]).push(i);\\n    }\\n\\n    let mut result = 0;\\n    for (_, nodes) in map {\\n      let need_edge_num = nodes.len() - 1;\\n      let mut success = true;\\n      for i in nodes {\\n        if g[i].len() != need_edge_num {\\n          success = false;\\n          break\\n        }\\n      }\\n      if success {\\n        result += 1;\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Union Find"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nstruct UnionFind {\\n  parents: Vec<usize>,\\n  sizes: Vec<usize>,\\n  ranks: Vec<usize>\\n}\\n\\nimpl UnionFind {\\n  fn new(n:usize) -> UnionFind {\\n    let mut uf = UnionFind { parents: vec![0;n], sizes:vec![1;n], ranks:vec![0;n] };\\n    for i in 0..n {\\n      uf.parents[i] = i;\\n    }\\n    uf\\n  }\\n\\n  fn root(&mut self, x:usize) -> usize {\\n    let ti = self.parents[x];\\n    if ti == x {\\n      x\\n    } else {\\n      self.parents[x] = self.root(ti);\\n      self.parents[x]\\n    }\\n  }\\n\\n  fn is_same(&mut self, x:usize, y:usize) -> bool {\\n    self.root(x) == self.root(y)\\n  }\\n\\n  fn unite(&mut self, x:usize, y:usize) -> bool {\\n    let rx = self.root(x);\\n    let ry = self.root(y);\\n    if rx == ry { return false }\\n    let (rx, ry) = if self.ranks[rx] < self.ranks[ry] {\\n      (ry, rx)\\n    } else {\\n      (rx, ry)\\n    };\\n    self.parents[ry] = rx;\\n    if self.ranks[rx] == self.ranks[ry] {\\n      self.ranks[rx] += 1;\\n    }\\n\\n    self.sizes[rx] += self.sizes[ry];\\n    true\\n  }\\n\\n  fn group_size(&mut self, x:usize) -> usize {\\n    let i = self.root(x);\\n    self.sizes[i]\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn count_complete_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n    let n = n as usize;\\n    let mut g = vec![vec![];n];\\n    let mut tree = UnionFind::new(n);\\n\\n    for arr in &edges {\\n      let a = arr[0] as usize;\\n      let b = arr[1] as usize;\\n\\n      g[a].push(b);\\n      g[b].push(a);\\n      tree.unite(a, b);\\n    } \\n\\n    let mut map = HashMap::new();\\n    for i in 0..n {\\n      let pi = tree.root(i);\\n      map.entry(pi).or_insert(vec![]).push(i);\\n    }\\n\\n    let mut result = 0;\\n    for (_, nodes) in map {\\n      let need_edge_num = nodes.len() - 1;\\n      let mut success = true;\\n      for i in nodes {\\n        if g[i].len() != need_edge_num {\\n          success = false;\\n          break\\n        }\\n      }\\n      if success {\\n        result += 1;\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3729254,
                "title": "python-super-easy-union-find-degree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        parent = {}\\n        def find_parent(i):\\n            if i not in parent or parent[i] == i:\\n                parent[i] = i\\n                return i \\n            \\n            parent[i] = find_parent(parent[i])\\n            return parent[i]\\n        in_degree = collections.defaultdict(int)\\n        for a , b in edges:\\n            p_a = find_parent(a)\\n            p_b = find_parent(b)\\n            in_degree[b] +=1\\n            if p_a != p_b:\\n                parent[p_a] = p_b\\n\\n        group = collections.defaultdict(set)\\n        for i in range(n):\\n            p = find_parent(i)\\n            group[p].add(i)\\n        ans = 0\\n        for p in group:\\n            edges = 0\\n            for n in group[p]:\\n                edges += in_degree[n]\\n            if edges == comb(len(group[p]), 2):\\n                ans +=1        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        parent = {}\\n        def find_parent(i):\\n            if i not in parent or parent[i] == i:\\n                parent[i] = i\\n                return i \\n            \\n            parent[i] = find_parent(parent[i])\\n            return parent[i]\\n        in_degree = collections.defaultdict(int)\\n        for a , b in edges:\\n            p_a = find_parent(a)\\n            p_b = find_parent(b)\\n            in_degree[b] +=1\\n            if p_a != p_b:\\n                parent[p_a] = p_b\\n\\n        group = collections.defaultdict(set)\\n        for i in range(n):\\n            p = find_parent(i)\\n            group[p].add(i)\\n        ans = 0\\n        for p in group:\\n            edges = 0\\n            for n in group[p]:\\n                edges += in_degree[n]\\n            if edges == comb(len(group[p]), 2):\\n                ans +=1        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1893984,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 1898383,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 1939877,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 2023056,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 1893523,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 1893328,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 2028934,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 2022000,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Operations to Make Numbers Non-positive",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Minimum Cost to Make All Characters Equal",
        "question_content": "<p>You are given a <strong>0-indexed</strong> binary string <code>s</code> of length <code>n</code> on which you can apply two types of operations:</p>\n\n<ul>\n\t<li>Choose an index <code>i</code> and invert all characters from&nbsp;index <code>0</code> to index <code>i</code>&nbsp;(both inclusive), with a cost of <code>i + 1</code></li>\n\t<li>Choose an index <code>i</code> and invert all characters&nbsp;from&nbsp;index <code>i</code> to index <code>n - 1</code>&nbsp;(both inclusive), with a cost of <code>n - i</code></li>\n</ul>\n\n<p>Return <em>the <strong>minimum cost </strong>to make all characters of the string <strong>equal</strong></em>.</p>\n\n<p><strong>Invert</strong> a character means&nbsp;if its value is &#39;0&#39; it becomes &#39;1&#39; and vice-versa.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0011&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Apply the second operation with <code>i = 2</code> to obtain <code>s = &quot;0000&quot; for a cost of 2</code>. It can be shown that 2 is the minimum cost to make all characters equal.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;010101&quot;\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> Apply the first operation with i = 2 to obtain s = &quot;101101&quot; for a cost of 3.\nApply the first operation with i = 1 to obtain s = &quot;011101&quot; for a cost of 2. \nApply the first operation with i = 0 to obtain s = &quot;111101&quot; for a cost of 1. \nApply the second operation with i = 4 to obtain s = &quot;111110&quot; for a cost of 2.\nApply the second operation with i = 5 to obtain s = &quot;111111&quot; for a cost of 1. \nThe total cost to make all characters equal is 9. It can be shown that 9 is the minimum cost to make all characters equal.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length == n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3570185,
                "title": "single-pass-iterative-easy-explanation-think-greedy-one-line-clean-code-c",
                "content": "# Intuition\\nDon\\'t worry if you were not able to solve this problem during the contest,\\nLets get into the question:\\n\\n\\nIt says we have to flip all the bits in a Binary string i.e (0,1) to make the string of same bits of:\\n\\n        Take ::  000000100\\n    For this test case first it is feasile to make last two zeroes flip\\n    i.e\\n                000000111\\n    And then make those three one\\'s again flip:\\n                000000000\\n    Total step required : 2+3,\\n\\n\\n# Approach\\n1. start traversing through the array\\n    a. If you encounter different element i.e s[i] != s[i-1]:\\n        check from which side it is feasible for us to take less move to       make it equal min(i,n-i) either from the front or from the back.\\n2. Maintain a variable ans and keep on adding the min value required for us.\\n\\n# Complexity\\n- Time complexity:\\n**Traversing the Array Once - 0(n)**\\n\\n- Space complexity:\\n**No space Requeired - 0(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // Key Observation\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // Key Observation\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570380,
                "title": "java-c-python-check-s-i-s-i-1",
                "content": "# **Explanation**\\nCheck if `s[i] == s[i - 1]`.\\nIf they are different, we need to either:\\n1. change the prefix to from start to `s[i - 1]`, cost `i`.\\n2. change the suffix from `s[i]` to end, cost `n - i`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long minimumCost(String s) {\\n        long res = 0;\\n        for (int i = 1, n = s.length(); i < n; ++i)\\n            if (s.charAt(i) != s.charAt(i - 1))\\n                res += Math.min(i, n - i);\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long minimumCost(string s) {\\n        long long res = 0;\\n        for (int i = 1, n = s.size(); i < n; ++i)\\n            if (s[i] != s[i - 1])\\n                res += min(i, n - i);\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        return sum(min(i, n - i) for i in range(1, n) if s[i] != s[i - 1])\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```java\\n    public long minimumCost(String s) {\\n        long res = 0;\\n        for (int i = 1, n = s.length(); i < n; ++i)\\n            if (s.charAt(i) != s.charAt(i - 1))\\n                res += Math.min(i, n - i);\\n        return res;\\n    }\\n```\n```cpp\\n    long long minimumCost(string s) {\\n        long long res = 0;\\n        for (int i = 1, n = s.size(); i < n; ++i)\\n            if (s[i] != s[i - 1])\\n                res += min(i, n - i);\\n        return res;\\n    }\\n```\n```py\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        return sum(min(i, n - i) for i in range(1, n) if s[i] != s[i - 1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3570183,
                "title": "cpp-prefix-and-suffix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust make a prefix array `ps` and store the cost for making all the elements from `0` to `i` equal to `s[i]`\\n\\nMake a suffix array `ss` and store the cost for making all the elements from `i` to `n - 1` equal to `s[i]`\\n\\nNow your answer will be `min(ps[i] + ss[i])` for all `i` from `0` to `n - 1`\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<ll> ps(n);\\n        ll ss = 0;\\n        for(int i = 1; i < n; i += 1) {\\n            if(s[i - 1] != s[i]) {\\n                ps[i] += (ps[i - 1] + i);\\n            } else ps[i] = ps[i - 1];\\n        }\\n        ll ans = 1e14;\\n        for(int i = n - 2; i >= 0; i -= 1) {\\n            if(s[i] != s[i + 1]) ss += (n - i - 1);\\n            ans = min(ans,ps[i] + ss);\\n        }\\n        return min(ans,ss);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<ll> ps(n);\\n        ll ss = 0;\\n        for(int i = 1; i < n; i += 1) {\\n            if(s[i - 1] != s[i]) {\\n                ps[i] += (ps[i - 1] + i);\\n            } else ps[i] = ps[i - 1];\\n        }\\n        ll ans = 1e14;\\n        for(int i = n - 2; i >= 0; i -= 1) {\\n            if(s[i] != s[i + 1]) ss += (n - i - 1);\\n            ans = min(ans,ps[i] + ss);\\n        }\\n        return min(ans,ss);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570182,
                "title": "simple-iteration-very-simple-easy-to-understand-solution",
                "content": "Up vote if you like the solution \\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted </b>\\n\\n# Approach 1\\n\\n1. Keep traversing from both left and right side\\n2. Where ever we find a miss match of the char with the previous one from left or right just add the index to the ans. ( basically we want to make all equal to the current char )\\n\\nFor ex: \\n10110100. i= 0, j = 0\\n00110100 on second iteration we make the first char as 0, so add 1 to the ans.\\n00110111 on third itration we make the last 2 char equal to 1 which is pointed by j th index and add 2 to the ans\\n...\\n\\nBasicaly we do the following :\\nAdd the ith index if there is a change from the front.\\nAdd the n-jth index -1 if there is a change from the last.\\n\\n# Code\\n```\\nlong long minimumCost(string s) {\\n    long long ans = 0, i = 1, j = s.size()-2;\\n    while(i < j){\\n        if(s[i] != s[i-1]) ans += i; \\n        if(s[j] != s[j+1]) ans += s.size() - j - 1; \\n        i++; j--;\\n    }\\n    if(i != j && s[i-1] != s[j+1]) ans += i;\\n    if(i == j && s[i] != s[i-1]) ans += i;\\n    if(i == j && s[j] != s[j+1]) ans += s.size() - j - 1;\\n    return ans;\\n}\\n```\\n\\n# Approach 2\\nCheck out the following solution which is more consise and stright forward then above solution :\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3570185/single-pass-iterative-easy-explanation-think-greedy-one-line-clean-code-c/\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long minimumCost(string s) {\\n    long long ans = 0, i = 1, j = s.size()-2;\\n    while(i < j){\\n        if(s[i] != s[i-1]) ans += i; \\n        if(s[j] != s[j+1]) ans += s.size() - j - 1; \\n        i++; j--;\\n    }\\n    if(i != j && s[i-1] != s[j+1]) ans += i;\\n    if(i == j && s[i] != s[i-1]) ans += i;\\n    if(i == j && s[j] != s[j+1]) ans += s.size() - j - 1;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570308,
                "title": "all-possible-solution-with-explanation",
                "content": "# Intuition By greedy\\n\\n**Start traversing through the array**\\n1. If you encounter different element i.e s[i] != s[i-1]:\\ncheck from which side it is feasible for us to take less move to make it equal min(i,n-i) either from the front or from the back.\\n2. Maintain a variable ans and keep on adding the min value required for us.\\n```\\nCode block\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // Key Observation\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    }\\n};\\n```\\n\\n\\n# Intuition By prefix array\\nhe code calculates the cost of flipping characters in the string and finds the minimum cost required to make all characters the same. It does this by considering the cost of flipping characters up to each position and then calculating the remaining cost from each position to the end of the string. The overall minimum cost is then determined and returned.\\n\\n# Algo \\n\\n1. First, we initialize some variables and containers to store information.\\n\\n2. We go through the string and calculate the partial sums. These represent the cost of flipping characters up to each position. For example, if we have \"0011\", the partial sums would be [0, 1, 1, 4], indicating the cost of flipping characters up to each position.\\nWe initialize the minimum cost as a very large value.\\n\\n3. Next, we go through the string in reverse order. We calculate the remaining cost by considering the difference between adjacent characters. If the characters are different, we add the remaining cost of flipping the characters from the current position to the end of the string.\\n\\n4. We calculate the current cost by combining the partial sum up to the current position with the remaining cost.\\nWe update the minimum cost if the current cost is lower than the current minimum cost.\\n\\n5. Finally, we return the minimum cost as the result.\\nI hope this simplified explanation helps you understand the algorithm better. Let me know if you have any further questions!\\n\\n# Code\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int length = s.size();  // Get the length of the input string\\n        vector<ll> partialSums(length);  // Store partial sums\\n        ll remainingSum = 0;  // Track the sum of remaining characters\\n\\n        // Calculate partial sums for flipping characters up to each index\\n        for (int i = 1; i < length; i += 1) {\\n            if (s[i - 1] != s[i]) {\\n                partialSums[i] += (partialSums[i - 1] + i);\\n            } else {\\n                partialSums[i] = partialSums[i - 1];\\n            }\\n        }\\n\\n        ll minCost = 1e14;  // Initialize minimum cost to a large value\\n\\n        // Iterate through the string in reverse to calculate the minimum cost\\n        for (int i = length - 2; i >= 0; i -= 1) {\\n            if (s[i] != s[i + 1]) {\\n                remainingSum += (length - i - 1);\\n            }\\n            ll currentCost = partialSums[i] + remainingSum;\\n            minCost = min(minCost, currentCost);\\n        }\\n\\n        // Return the minimum cost\\n        return min(minCost, remainingSum);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nCode block\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // Key Observation\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    }\\n};\\n```\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int length = s.size();  // Get the length of the input string\\n        vector<ll> partialSums(length);  // Store partial sums\\n        ll remainingSum = 0;  // Track the sum of remaining characters\\n\\n        // Calculate partial sums for flipping characters up to each index\\n        for (int i = 1; i < length; i += 1) {\\n            if (s[i - 1] != s[i]) {\\n                partialSums[i] += (partialSums[i - 1] + i);\\n            } else {\\n                partialSums[i] = partialSums[i - 1];\\n            }\\n        }\\n\\n        ll minCost = 1e14;  // Initialize minimum cost to a large value\\n\\n        // Iterate through the string in reverse to calculate the minimum cost\\n        for (int i = length - 2; i >= 0; i -= 1) {\\n            if (s[i] != s[i + 1]) {\\n                remainingSum += (length - i - 1);\\n            }\\n            ll currentCost = partialSums[i] + remainingSum;\\n            minCost = min(minCost, currentCost);\\n        }\\n\\n        // Return the minimum cost\\n        return min(minCost, remainingSum);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570321,
                "title": "fastest-beats-100-0ms-o-n-c-java-python",
                "content": "# Intuition\\n**```Standing at any particular index check what can be minimum cost to make it equal to the next character \\u2705.```**\\n\\n![image.png](https://assets.leetcode.com/users/images/f2e8e6c2-d98b-4e62-b4b9-6ff0313dc08e_1685248470.042611.png)\\n\\n# Approach\\n**```Since we need to minimize the cost, standing at any particular find out what is the minimum number of steps required to make char at the index equal to next character.```**\\n\\n**Lets say in 010101\\nat index 0 : \\nif ```s[0] != s[1] ```\\nthen there 2 ways to make ```s[0] == s[1]```\\neither by reversing all the characters from 0 ... i \\nor by reversing all the character from i + 1 ... n**\\n\\n**After perform operating till ith index the elements in the left half become equal \\ni.e if at i = 4 \\nthe elements would now be \\n1 1 1 1 0 1**\\n\\n# Complexity\\n- Time complexity:\\n```**Since it requires just to traverse the entire string only once the time complexity is: O(N)**```\\n\\n- Space complexity:\\n**```Cost variable is used to store the cost so the space complexity is O(1)```**\\n\\n# Code (C++)\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0, n = s.size();\\n        for (int i = 0; i < s.size() - 1; ++i)\\n        {\\n            if (s[i] != s[i + 1])\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code(Java)\\n``` public class Solution\\n{\\npublic\\n    long minimumCost(String s)\\n    {\\n        long ans = 0;\\n        int n = s.length();\\n        for (int i = 0; i < s.length() - 1; ++i)\\n        {\\n            if (s.charAt(i) != s.charAt(i + 1))\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n# Code(Python)\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        for i in range(n - 1):\\n            if s[i] != s[i + 1]:\\n                if i + 1 <= n - i - 1:\\n                    ans += i + 1\\n                else:\\n                    ans += n - i - 1\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```Standing at any particular index check what can be minimum cost to make it equal to the next character \\u2705.```\n```Since we need to minimize the cost, standing at any particular find out what is the minimum number of steps required to make char at the index equal to next character.```\n```s[0] != s[1] ```\n```s[0] == s[1]```\n```**Since it requires just to traverse the entire string only once the time complexity is: O(N)**```\n```Cost variable is used to store the cost so the space complexity is O(1)```\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0, n = s.size();\\n        for (int i = 0; i < s.size() - 1; ++i)\\n        {\\n            if (s[i] != s[i + 1])\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` public class Solution\\n{\\npublic\\n    long minimumCost(String s)\\n    {\\n        long ans = 0;\\n        int n = s.length();\\n        for (int i = 0; i < s.length() - 1; ++i)\\n        {\\n            if (s.charAt(i) != s.charAt(i + 1))\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        for i in range(n - 1):\\n            if s[i] != s[i + 1]:\\n                if i + 1 <= n - i - 1:\\n                    ans += i + 1\\n                else:\\n                    ans += n - i - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570239,
                "title": "simple-greedy-complete-intuition-explained",
                "content": "Operation-1 : Flip bits towards left\\nOperation-2 : Flip bits towards right\\n \\nJust observe that\\nFor the left indexes like (0, 1..) if we do operation-2 it will be very costly\\nFor the right indexes like (n - 3, n - 2, n - 1\\u2026) if we do operation-1 it will be very costly\\nFor the **mid index (indexes)**, both **operation-1 and operation-2 will be of almost equal cost**\\n\\n\\nSo it would be better to **make all chars equal to \\u2018mid\\u2019 character of string**\\nSo targetCh = s[mid]\\nBy which we can \\n**Apply \\u201COperation-1\\u201D on the left indexes** of mid (if character is not equal to target)\\n**Apply \\u201COperation-2\\u201D on the right indexes** of mid (if character is not equal to target)\\n\\n\\nDo we really need to manually perform the operation by flipping all the bits (left/right)\\nIf not then how do we know what is the correct character at some index after some operations are done on it\\nWe can optimize it\\nWe can keep a count of operations done on both left and right indexes\\n\\nSo if char in string is str = ch\\nop = (operations done on it)\\n**If (op is even) : we flipped ch even no. of times => so no change**\\n**If (op is odd) : we flipped ch odd no, of time => flip ch**\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        int n = s.size();\\n        int mid = n / 2;\\n        long long ans = 0;\\n        char target = s[mid]; \\n        //we will make all chars of string equal to target\\n        \\n        int i = mid - 1, j = mid + 1;\\n        int leftOp = 0, rightOp = 0;\\n        //===============================================================================\\n        while(i >= 0)\\n        {\\n            char ch = s[i];\\n            if (leftOp % 2 != 0) //if odd operations done, FLIP CHAR\\n                ch = (ch == \\'0\\')? \\'1\\' : \\'0\\';\\n            \\n            if (ch != target) \\n            {\\n                leftOp++;\\n                ans += (i + 1);\\n            }\\n            i--;\\n        }\\n        //===============================================================================\\n        while(j < n)\\n        {\\n            char ch = s[j];\\n            if (rightOp % 2 != 0) //if odd operations done, FLIP CHAR\\n                ch = (ch == \\'0\\')? \\'1\\' : \\'0\\';\\n            \\n            if (ch != target)\\n            {\\n                rightOp++; \\n                ans += (n - j);\\n            }\\n            j++;\\n        }\\n        //================================================================================\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        int n = s.size();\\n        int mid = n / 2;\\n        long long ans = 0;\\n        char target = s[mid]; \\n        //we will make all chars of string equal to target\\n        \\n        int i = mid - 1, j = mid + 1;\\n        int leftOp = 0, rightOp = 0;\\n        //===============================================================================\\n        while(i >= 0)\\n        {\\n            char ch = s[i];\\n            if (leftOp % 2 != 0) //if odd operations done, FLIP CHAR\\n                ch = (ch == \\'0\\')? \\'1\\' : \\'0\\';\\n            \\n            if (ch != target) \\n            {\\n                leftOp++;\\n                ans += (i + 1);\\n            }\\n            i--;\\n        }\\n        //===============================================================================\\n        while(j < n)\\n        {\\n            char ch = s[j];\\n            if (rightOp % 2 != 0) //if odd operations done, FLIP CHAR\\n                ch = (ch == \\'0\\')? \\'1\\' : \\'0\\';\\n            \\n            if (ch != target)\\n            {\\n                rightOp++; \\n                ans += (n - j);\\n            }\\n            j++;\\n        }\\n        //================================================================================\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570298,
                "title": "simple-dynamic-programming-solution-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(string &s,int idx,int curr,vector<vector<long long int>>&dp)\\n    {\\n        if(idx==s.size())\\n            return 0;\\n        if(dp[idx][curr]!=-1)\\n            return dp[idx][curr];\\n        \\n        long long int a=0,b=0;\\n        if(curr!=s[idx]-\\'0\\')\\n        {\\n            a=a+((int)s.size()-idx)+solve(s,idx+1,!curr,dp);\\n            b=b+idx+solve(s,idx+1,!curr,dp);\\n            return dp[idx][curr]= min(a,b);\\n        }\\n        else\\n            return dp[idx][curr]= solve(s,idx+1,curr,dp);\\n        \\n    }\\n    long long minimumCost(string s) {\\n        vector<vector<long long int>>dp(s.size()+1,vector<long long int>(2,-1));\\n        vector<vector<long long int>>dp1(s.size()+1,vector<long long int>(2,-1));\\n        return min(solve(s,0,0,dp),solve(s,0,1,dp1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(string &s,int idx,int curr,vector<vector<long long int>>&dp)\\n    {\\n        if(idx==s.size())\\n            return 0;\\n        if(dp[idx][curr]!=-1)\\n            return dp[idx][curr];\\n        \\n        long long int a=0,b=0;\\n        if(curr!=s[idx]-\\'0\\')\\n        {\\n            a=a+((int)s.size()-idx)+solve(s,idx+1,!curr,dp);\\n            b=b+idx+solve(s,idx+1,!curr,dp);\\n            return dp[idx][curr]= min(a,b);\\n        }\\n        else\\n            return dp[idx][curr]= solve(s,idx+1,curr,dp);\\n        \\n    }\\n    long long minimumCost(string s) {\\n        vector<vector<long long int>>dp(s.size()+1,vector<long long int>(2,-1));\\n        vector<vector<long long int>>dp1(s.size()+1,vector<long long int>(2,-1));\\n        return min(solve(s,0,0,dp),solve(s,0,1,dp1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570234,
                "title": "l2r-and-r2l",
                "content": "We go left-to-right first, and, for each position `i`, we track the cost to make string `s[0...i]` equal.\\n\\nIf `s[i - 1]` is not equal to `s[i]`, we flip `i` characters (cost is `i`) to flip. Plus, we need to add cost to make previos `i - 1` characters equal.\\n\\nSo, the transition function is:\\n```cpp\\ndp[i] = dp[i - 1] + (s[i - 1] != s[i] ? i : 0);`\\n```\\n\\nThen, we go right-to-left, and also count the number of operations to make s[i..] characters equal.\\n\\nFinally, we track the minimum cost to make prefix (`s[0..i - 1]`) and suffix (`s[i + 1...]`) equal to `s[i]`.\\n\\n**C++**\\n```cpp\\nlong long minimumCost(const string &s) {\\n    long long dp[100001] = {};\\n    for (int i = 1; i < s.size(); ++i)\\n        dp[i] = dp[i - 1] + (s[i - 1] != s[i] ? i : 0);\\n    long long res = dp[s.size() - 1], right = 0;\\n    for (int i = s.size() - 2; i > 0; --i) {\\n        right += s[i] != s[i + 1] ? s.size() - i - 1 : 0;\\n        res = min(res, dp[i] + right);\\n    }    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\ndp[i] = dp[i - 1] + (s[i - 1] != s[i] ? i : 0);`\\n```\n```cpp\\nlong long minimumCost(const string &s) {\\n    long long dp[100001] = {};\\n    for (int i = 1; i < s.size(); ++i)\\n        dp[i] = dp[i - 1] + (s[i - 1] != s[i] ? i : 0);\\n    long long res = dp[s.size() - 1], right = 0;\\n    for (int i = s.size() - 2; i > 0; --i) {\\n        right += s[i] != s[i + 1] ? s.size() - i - 1 : 0;\\n        res = min(res, dp[i] + right);\\n    }    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570655,
                "title": "visually-explained-intuition-based-greedy-python-easy",
                "content": "# Intuition\\n- First thing to notice in this question is that we only need to find the minimum number of steps required to make string equal.\\n- Whether we make the string all ones or all zeros is not the concern.\\nTherefore we can traverse through the string linearly and check for pairs of adjacent characters.\\n- If the adjacent characters are equal then we need not make any changes. But if they are not we greedily choose either left or right subarray to make the pair equal.\\n- While traversing all the elements indexed from 0 to i(both inclusive) will always stay all 0\\'s or all 1\\'s.\\n\\n# Approach\\n- As we are checking pairs we can either start from index 0 and go upto index n-2 or start from index 1 and go upto index n-1.(I have chosen the first option)\\n- We initiate a \"ans\" varible with 0 and keep on adding the size of smaller subarray(right or left).\\n- The image below shows the pairs and the correspoing sub-array we choose to invert. The green highlighted cells are the one we choose to invert in given step.\\n![leet.jpg](https://assets.leetcode.com/users/images/a48d3ee2-9ac0-4408-9483-5b3573536bd7_1685250782.7351863.jpeg)\\n- The cost is simply calculated by taking the difference between the end and the start index of the sub-array. i.e. end-start+1\\nFor eg. in step 2, i=1 therefore left subarray size = i-0+1 = i+1 =2 and right subarray size = (n-1)-(i+1)+1 = n-i-1=6-1-1=4\\n# Complexity\\n- Time complexity:\\nWe iterate through the array only once. We don\\'t even actually flip the bits. Hence the time complexity is O(N).\\n\\n- Space complexity:\\nWe do not use any extra space. So the space complexity in O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(n-1):\\n            if s[i] != s[i+1]:\\n                ans += min(i+1, n-i-1)\\n        return ans\\n```\\nAlternate option for choosing pairs:\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(1,n):\\n            if s[i] != s[i-1]:\\n                ans += min(i, n-i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(n-1):\\n            if s[i] != s[i+1]:\\n                ans += min(i+1, n-i-1)\\n        return ans\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(1,n):\\n            if s[i] != s[i-1]:\\n                ans += min(i, n-i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574435,
                "title": "one-pass-dp-intuition-for-check-s-i-s-i-1",
                "content": "# Approach 1: Computing prefix and suffix\\n# Intuition\\nFor each index in the string, we can either modify the string before it or coming after it. We calculate the total cost of making the prefix and suffix to index `i` equal to the character at `i`, for each index `i` in s.\\n\\n\\n# Approach\\nWe calculate the prefix and suffix array by iterating over the string once. \\nFor prefix array, at each point where `s[i] != s[i-1]`, the cost to make the prefix string to `s[i]` equal to `s[i]` is given by the cost to make all characters in the prefix equal plus the cost to flip the prefix. \\ni.e `prefix[i] = prefix[i-1] + i`\\n\\nA similar computation is done for the suffix.\\n\\nAt the end, we simply traverse over the prefix and suffix, sum up the cost to make both parts, and choose the minimum.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<long long> pref(n, 0), suff(n, 0);\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] != s[i-1]) pref[i] = i + pref[i-1];\\n            else pref[i] = pref[i-1];\\n\\n            if (s[n-1-i] != s[n-i]) suff[n-1-i] = i + suff[n-i];\\n            else suff[n-1-i] = suff[n-i];\\n        }\\n        long long res = LLONG_MAX;\\n        for (int i = 0; i < n; i++) {\\n            res = min(res, pref[i] + suff[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Approach 2: One pass DP\\n# Intuition\\nThe key intuition here is that flipping any section of the string does not modify the cost. i.e `101` can become `010` but the amount of bit flips remains same. Or in other words, the minimum cost for a binary string `num`, is equal to that for `!num`. \\n\\nTherefore, at each point we can either flip the prefix or the suffix without actually knowing the cost to make all characters in the suffix equal.\\n\\n# Approach\\nConsider a dp array, where dp[i] denotes the minimum cost to make the first `i` characters in the string equal.\\n\\nWe can set `dp[0] = 0` as base case.\\n\\nNow, if we encounter an index `i` such that `s[i] != s[i-1]` then we can either flip the prefix with cost `i` or the suffix with cost `n-i`. We choose the minimum of these two.\\n\\nWe have essentially made the first `i+1` characters equal, while maintaining the cost required to make all characters of the remaining suffix equal. \\n\\nWe thus have the relation,\\n`dp[i] = dp[i-1] + min(i, n-i)` if `s[i] != s[i-1]` \\n`dp[i] = dp[i-1]` otherwise \\n\\nSince, we only rely on the previous value, we can avoid allocating space.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] != s[i-1]) {\\n                ans += min(i, n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nSolve first if you are stuck: https://leetcode.com/problems/flip-string-to-monotone-increasing/\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<long long> pref(n, 0), suff(n, 0);\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] != s[i-1]) pref[i] = i + pref[i-1];\\n            else pref[i] = pref[i-1];\\n\\n            if (s[n-1-i] != s[n-i]) suff[n-1-i] = i + suff[n-i];\\n            else suff[n-1-i] = suff[n-i];\\n        }\\n        long long res = LLONG_MAX;\\n        for (int i = 0; i < n; i++) {\\n            res = min(res, pref[i] + suff[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] != s[i-1]) {\\n                ans += min(i, n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584095,
                "title": "python-3-4-lines-w-explanation-t-m-94-70",
                "content": "Intuition:\\nThe problem can be restated as follows. Given an array of bits, perform this operation any number of times: partition the array in two, then flip all bits in one of those two partitions with the eventual goal of having the bits all of the same parity. Return the minimum number of bits needed to be flipped in total to accomplish this goal.\\n\\nIt should be clear that if two adjacent bits differ in parity, then one of the partitions must separate these two bits. Thus, a flip is required if and only if the partitions separates two adjacent bits differing in parity, and the flip should be executed on the partition with the lesser length. It should also be clear for partitions in the the left half of the string the minimum count of bits is`i`, and in the right half, the minimum count is`n - i`.\\n\\nHere\\'s the code:\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n\\n        n, ans = len(s), 0\\n \\n        for i in range(1,(n+1)//2): ans+= (s[i] != s[i-1])*i\\n        for i in range((n+1)//2,n): ans+= (s[i] != s[i-1])*(n-i)\\n            \\n        return ans \\n```\\n[https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/961289114/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`len(s)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n\\n        n, ans = len(s), 0\\n \\n        for i in range(1,(n+1)//2): ans+= (s[i] != s[i-1])*i\\n        for i in range((n+1)//2,n): ans+= (s[i] != s[i-1])*(n-i)\\n            \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570424,
                "title": "prefix-sum-suffix-sum-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long int ans1 = 0, sum = 0,ans2 = 0;\\n        vector<long long int> tmp1,tmp2;\\n        int i = 0, n = s.length(),j;\\n        while(i<n){\\n            j = i;\\n            while(i<n&&s[i]==s[j]){\\n                i++;\\n            }\\n            ans1 += sum;\\n            tmp1.push_back(ans1);\\n            sum = i;\\n        }\\n        reverse(s.begin(),s.end());\\n        i = 0,sum = 0;\\n        while(i<n){\\n            j = i;\\n            while(i<n&&s[i]==s[j]){\\n                i++;\\n            }\\n            ans2 += sum;\\n            tmp2.push_back(ans2);\\n            sum = i;\\n        }\\n        reverse(tmp2.begin(),tmp2.end());\\n        n = tmp1.size();\\n        long long int ans = LONG_LONG_MAX;\\n        for(i = 0; i <  n; i++){\\n            ans = min(ans,tmp1[i]+tmp2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long int ans1 = 0, sum = 0,ans2 = 0;\\n        vector<long long int> tmp1,tmp2;\\n        int i = 0, n = s.length(),j;\\n        while(i<n){\\n            j = i;\\n            while(i<n&&s[i]==s[j]){\\n                i++;\\n            }\\n            ans1 += sum;\\n            tmp1.push_back(ans1);\\n            sum = i;\\n        }\\n        reverse(s.begin(),s.end());\\n        i = 0,sum = 0;\\n        while(i<n){\\n            j = i;\\n            while(i<n&&s[i]==s[j]){\\n                i++;\\n            }\\n            ans2 += sum;\\n            tmp2.push_back(ans2);\\n            sum = i;\\n        }\\n        reverse(tmp2.begin(),tmp2.end());\\n        n = tmp1.size();\\n        long long int ans = LONG_LONG_MAX;\\n        for(i = 0; i <  n; i++){\\n            ans = min(ans,tmp1[i]+tmp2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570218,
                "title": "c-with-3-line-code-beginner",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1])\\n                ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1])\\n                ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570188,
                "title": "c-solution-5-line-code-100-beat",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574875,
                "title": "minimum-cost-to-make-all-elements-equal-tc-o-n-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        bool first = (s[0]==\\'0\\')? false:true;\\n        int n = s.size(),ctr=0;\\n        long long ans =0;\\n        for(int i=1; i<n; i++){\\n            bool curr = (s[i]==\\'0\\')? false:true;\\n            if(ctr%2)\\n                curr = curr^1;\\n            if(first != curr){\\n                if(i<=n/2)\\n                {\\n                    ans += i;\\n                    first = first^1;\\n                }\\n                else{\\n                    ans += (n-i);\\n                    ctr++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        bool first = (s[0]==\\'0\\')? false:true;\\n        int n = s.size(),ctr=0;\\n        long long ans =0;\\n        for(int i=1; i<n; i++){\\n            bool curr = (s[i]==\\'0\\')? false:true;\\n            if(ctr%2)\\n                curr = curr^1;\\n            if(first != curr){\\n                if(i<=n/2)\\n                {\\n                    ans += i;\\n                    first = first^1;\\n                }\\n                else{\\n                    ans += (n-i);\\n                    ctr++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570719,
                "title": "iterative-dp-prefix-and-suffix-dp-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the $i^{th}$ state, we have the following options:\\n- If the $i^{th}$ character is the same as the previous characters:\\n    1. We can either keep the $s[i]$ same as the previous characters. \\n    2. Or we can change $s[i]$, but then we also have to change the previous $i - 1$ characters.\\n- If the $i^{th}$ character is not the same as the previous characters:\\n    1. We can either change $s[i]$.\\n    2. Or we can change the previous $i - 1$ characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe $dp$ that we calculate using the above algorithm will only give us the optimal answer if we do only prefix operations. But the problems says we are allowed to do suffix operations as well. Hence we have to calculate a $dp2$ using the same algorithm, the only difference being we will calculate it from the end of the string.\\n\\nAfter these $dp$ and $dp2$ arrays are ready, for each $i$, we take the minimum of $dp[i]$ $+$ $dp2[i + 1]$, since we are looking for the most optimal solution. Also, since the characters can be either all $0$ or all $1$, hence the $dp$ and $dp2$ will have $2$ substates at the $i^{th}$ state.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(n, vector<long long>(2, 1e9));\\n        vector<vector<long long>> dp2 = dp;\\n        if(s[0] == \\'0\\'){\\n            dp[0][0] = 0;\\n            dp[0][1] = 1;\\n        }else{\\n            dp[0][0] = 1;\\n            dp[0][1] = 0;\\n        }\\n        \\n        for(int i = 1; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                dp[i][0] = min({dp[i - 1][0], dp[i - 1][1] + i});\\n                dp[i][1] = min({dp[i - 1][1] + 2 * i + 1, dp[i - 1][0] + i + 1});\\n            }else{\\n                dp[i][0] = min({dp[i - 1][0] + 2 * i + 1, dp[i - 1][1] + i + 1});\\n                dp[i][1] = min({dp[i - 1][1], dp[i - 1][0] + i});\\n            }\\n        }\\n        \\n        reverse(s.begin(), s.end());\\n        if(s[0] == \\'0\\'){\\n            dp2[0][0] = 0;\\n            dp2[0][1] = 1;\\n        }else{\\n            dp2[0][0] = 1;\\n            dp2[0][1] = 0;\\n        }\\n        \\n        for(int i = 1; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                dp2[i][0] = min({dp2[i - 1][0], dp2[i - 1][1] + i});\\n                dp2[i][1] = min({dp2[i - 1][1] + 2 * i + 1, dp2[i - 1][0] + i + 1});\\n            }else{\\n                dp2[i][0] = min({dp2[i - 1][0] + 2 * i + 1, dp2[i - 1][1] + i + 1});\\n                dp2[i][1] = min({dp2[i - 1][1], dp2[i - 1][0] + i});\\n            }\\n        }\\n        reverse(dp2.begin(), dp2.end());\\n        long long ans = 1e12;\\n        for(int i = 0; i < n - 1; i++){\\n            ans = min({ans, dp[i][0] + dp2[i + 1][0], dp[i][1] + dp2[i + 1][1]});\\n        }\\n        \\n        return (ans == 1e12 ? 0 : ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(n, vector<long long>(2, 1e9));\\n        vector<vector<long long>> dp2 = dp;\\n        if(s[0] == \\'0\\'){\\n            dp[0][0] = 0;\\n            dp[0][1] = 1;\\n        }else{\\n            dp[0][0] = 1;\\n            dp[0][1] = 0;\\n        }\\n        \\n        for(int i = 1; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                dp[i][0] = min({dp[i - 1][0], dp[i - 1][1] + i});\\n                dp[i][1] = min({dp[i - 1][1] + 2 * i + 1, dp[i - 1][0] + i + 1});\\n            }else{\\n                dp[i][0] = min({dp[i - 1][0] + 2 * i + 1, dp[i - 1][1] + i + 1});\\n                dp[i][1] = min({dp[i - 1][1], dp[i - 1][0] + i});\\n            }\\n        }\\n        \\n        reverse(s.begin(), s.end());\\n        if(s[0] == \\'0\\'){\\n            dp2[0][0] = 0;\\n            dp2[0][1] = 1;\\n        }else{\\n            dp2[0][0] = 1;\\n            dp2[0][1] = 0;\\n        }\\n        \\n        for(int i = 1; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                dp2[i][0] = min({dp2[i - 1][0], dp2[i - 1][1] + i});\\n                dp2[i][1] = min({dp2[i - 1][1] + 2 * i + 1, dp2[i - 1][0] + i + 1});\\n            }else{\\n                dp2[i][0] = min({dp2[i - 1][0] + 2 * i + 1, dp2[i - 1][1] + i + 1});\\n                dp2[i][1] = min({dp2[i - 1][1], dp2[i - 1][0] + i});\\n            }\\n        }\\n        reverse(dp2.begin(), dp2.end());\\n        long long ans = 1e12;\\n        for(int i = 0; i < n - 1; i++){\\n            ans = min({ans, dp[i][0] + dp2[i + 1][0], dp[i][1] + dp2[i + 1][1]});\\n        }\\n        \\n        return (ans == 1e12 ? 0 : ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570174,
                "title": "prefix",
                "content": "\\n**<<<<<Upvote**\\n\\n\\n1st Method\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590804,
                "title": "simple-explanation-of-why-greedy-starting-with-backtracking-python",
                "content": "# Intuition\\nThis problem is the third problem of Weekly Contest 347. Many of you guys might be like me. When you first see it, you might have no idea why we can use this problem using the Greedy approach. So let\\'s start with a simple Backtracking algorithm.\\n\\n# Approach\\nThink of this problem with the backtracking algorithm. Starting from left to right, we can compare the char at each index with the char immediately preceeding it, and assume all chars preceeding it are the same (This is the essential idea behind backtracking). Consider this string ``000101``. At index ``i = 2`` and we compare the the char ``0`` with the char ``0`` before it. They are the same, so we move on to index 3 with the addtional cost ``backtracking(i + 1)``. At index 3, the char ``1`` is different from the char ``0`` before it. According to the question, there are 2 ways to make them the same. The first approach is to flip every char before index ``i`` (since they are the same) to make them equal with the cost ``i - 1 + 1``, and we can move on to the next char. So the total additional cost for this approach is ``i + backtracking(i + 1)``. For the second approach, we can flip the char at index ``i`` and every char behind it with the cost ``n - i`` to make the char at index ``i`` equals to all the char preceeding it, with the additional cost ``n - i + backtracking(i + 1)``. The backtracking code is provide below.\\n\\n```\\ndef minimumCost(self, s: str) -> int:\\n    def backtracking(i):\\n        if i == len(s):\\n            return 0\\n        if s[i] == s[i-1]:\\n            return backtracking(i+1)\\n        leftcost = i + backtracking(i+1)\\n        rightcost = len(s) - i + backtracking(i+1)\\n        return min(leftcost, rightcost)\\n    return backtracking(1)\\n```\\nEssentially, we are calling ``backtracking(i + 1)`` in every step, no matter if the char at ``i`` is equal to the char at ``i - 1`` and what approach we choose to make them equal if they are different. This makes this backtracking approach essentially greedy since the only choice we make on whether to use the first approach or the second approach is to choose the smaller value between ``i`` and ``n - i``, or in Python code, ``min(i, n-i)``. This leads to a simpler, much quicker Greedy code written in the following.\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ where ``n == length of s``. Since we are iterating the string ``s`` once in the greedy approach.\\n\\n- Space complexity:\\n$$O(1)$$ since we are not using any extra memory.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        n = len(s)\\n        for i in range(1, n):\\n            if s[i] != s[i-1]:\\n                cost += min(i, n-i)\\n        return cost\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minimumCost(self, s: str) -> int:\\n    def backtracking(i):\\n        if i == len(s):\\n            return 0\\n        if s[i] == s[i-1]:\\n            return backtracking(i+1)\\n        leftcost = i + backtracking(i+1)\\n        rightcost = len(s) - i + backtracking(i+1)\\n        return min(leftcost, rightcost)\\n    return backtracking(1)\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        n = len(s)\\n        for i in range(1, n):\\n            if s[i] != s[i-1]:\\n                cost += min(i, n-i)\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572043,
                "title": "c-greedy-recursion-memoization-intuition-approach-explained",
                "content": "Please upvote this post if you find it useful\\n# Intuition\\n    0  1  0  1  0  1\\n    i i+1               not matched: ans += min(1, 5) => 1\\n    1  1  0  1  0  1\\n       i i+1            not matched: ans += min(2, 4) => 2\\n    0  0  0  1  0  1\\n          i i+1         not matched: ans += min(3, 3) => 3\\n    1  1  1  1  0  1\\n             i  i+1     not matched: ans += min(4, 2) => 2\\n    1  1  1  1  1  0\\n                i i+1   not matched: ans += min(5, 1) => 1\\n    1  1  1  1  1  1\\n    -----------------   ans = 1+2+3+2+1 = 9\\n\\n---\\n\\n# Approach:\\nSo, see we will go to every index(i) and check whether the character of that index is same as the previous character. If they are same then just go forward, else we have two choices:\\n- flip 0 to the previous index(i-1) that becomes same to s[i]\\n- flip current index(i) to n-1\\n\\nIn case1: cost will be added :  (i-1)+1 = i\\nIn case2: cost will be added :  (n-i)\\n\\nFind the minimum cost using recursion.\\n\\n# Code 1: Recursion + Memoization\\n```\\nclass Solution {\\npublic:\\n    long long helper(int i, int n, string &s, char lastChar, vector<vector<long long>> &dp){\\n        if(i==n){\\n            return 0;\\n        }\\n        if(dp[i][lastChar-\\'0\\'] != -1) return dp[i][lastChar-\\'0\\'];\\n\\n        if(s[i]==lastChar){\\n            return dp[i][lastChar-\\'0\\'] = helper(i+1, n, s, lastChar, dp);\\n        }\\n        else{\\n            return dp[i][lastChar-\\'0\\'] = min(i + helper(i+1, n, s, s[i], dp), n-i + helper(i+1, n, s, s[i], dp));\\n        }\\n    }\\n    long long minimumCost(string s) {\\n        if(s.size()==1){\\n            return 0;\\n        }\\n        int n = s.size();   vector<vector<long long>> dp(n, vector<long long>(2, -1));\\n        return helper(1, s.size(), s, s[0], dp);        \\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code 2: Greedy\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;    int n = s.size();\\n        for(int i=0; i<n-1; i++){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(int i, int n, string &s, char lastChar, vector<vector<long long>> &dp){\\n        if(i==n){\\n            return 0;\\n        }\\n        if(dp[i][lastChar-\\'0\\'] != -1) return dp[i][lastChar-\\'0\\'];\\n\\n        if(s[i]==lastChar){\\n            return dp[i][lastChar-\\'0\\'] = helper(i+1, n, s, lastChar, dp);\\n        }\\n        else{\\n            return dp[i][lastChar-\\'0\\'] = min(i + helper(i+1, n, s, s[i], dp), n-i + helper(i+1, n, s, s[i], dp));\\n        }\\n    }\\n    long long minimumCost(string s) {\\n        if(s.size()==1){\\n            return 0;\\n        }\\n        int n = s.size();   vector<vector<long long>> dp(n, vector<long long>(2, -1));\\n        return helper(1, s.size(), s, s[0], dp);        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;    int n = s.size();\\n        for(int i=0; i<n-1; i++){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571110,
                "title": "java-greedy",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLoop from head, every time you find next bit different with prev one, you have to invert, just invert with the lowest cost.\\n\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic long minimumCost(String s) {\\n    long res = 0l;\\n    for (int i = 1, n = s.length(); i < n; i++) {\\n        if (s.charAt(i) != s.charAt(i - 1)) res += Math.min(i, n - i);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long minimumCost(String s) {\\n    long res = 0l;\\n    for (int i = 1, n = s.length(); i < n; i++) {\\n        if (s.charAt(i) != s.charAt(i - 1)) res += Math.min(i, n - i);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570922,
                "title": "easy-c-solution-o-n-greedy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1]){\\n                int prefix=i+1;\\n                int sufix=s.size()-1-i;\\n                ans+=min(prefix,sufix);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1]){\\n                int prefix=i+1;\\n                int sufix=s.size()-1-i;\\n                ans+=min(prefix,sufix);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570726,
                "title": "prefix-and-suffix-sum-based-c-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n    int length = s.size();  \\n    vector<ll> prefixSums(length, 0);  \\n    vector<ll> suffixSums(length, 0);  \\n    ll ans =LONG_LONG_MAX;\\n    for (int i = 1; i < length; i += 1) {\\n        prefixSums[i] = prefixSums[i - 1] + (s[i - 1] != s[i] ? i : 0);\\n    }\\n    for (int i = length - 2; i >= 0; i -= 1) {\\n        suffixSums[i] = suffixSums[i + 1] + (s[i] != s[i + 1] ? (length - i - 1) : 0);\\n    }\\n\\n    ll res = suffixSums[0];  \\n\\n    // Iterate through the string to calculate the minimum cost\\n    for (int i = 0; i < length; i += 1) {\\n        ans =min(ans, prefixSums[i] + res);\\n        if (i + 1 < length) {\\n            res -= (length - i - 1) * (s[i] != s[i + 1]);\\n        }\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n    int length = s.size();  \\n    vector<ll> prefixSums(length, 0);  \\n    vector<ll> suffixSums(length, 0);  \\n    ll ans =LONG_LONG_MAX;\\n    for (int i = 1; i < length; i += 1) {\\n        prefixSums[i] = prefixSums[i - 1] + (s[i - 1] != s[i] ? i : 0);\\n    }\\n    for (int i = length - 2; i >= 0; i -= 1) {\\n        suffixSums[i] = suffixSums[i + 1] + (s[i] != s[i + 1] ? (length - i - 1) : 0);\\n    }\\n\\n    ll res = suffixSums[0];  \\n\\n    // Iterate through the string to calculate the minimum cost\\n    for (int i = 0; i < length; i += 1) {\\n        ans =min(ans, prefixSums[i] + res);\\n        if (i + 1 < length) {\\n            res -= (length - i - 1) * (s[i] != s[i + 1]);\\n        }\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570220,
                "title": "explained-3-liner-c-easiest-solution",
                "content": "# Approach\\nFor every pair of unequal adjacent characters, we calculate the cost of transforming all characters before or after them to match the adjacent character. \\nThe total cost is accumulated and returned as the minimum cost.\\n# Code\\n```\\nlong long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.length();\\n        for(int i=0;i<s.length()-1;i++) \\n            if(s[i]!=s[i+1]) //If a character is not equal to its adjacent\\n                ans+=min(i+1, n-(i+1)); //Take min to check which operation will be cheaper\\n        return ans;\\n    }\\n```\\n# \\u2B06\\uFE0F **PLEASE UPVOTE IF YOU UNDERSTOOD!** \\u2764\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.length();\\n        for(int i=0;i<s.length()-1;i++) \\n            if(s[i]!=s[i+1]) //If a character is not equal to its adjacent\\n                ans+=min(i+1, n-(i+1)); //Take min to check which operation will be cheaper\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570192,
                "title": "c-easy-to-understand-5-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570181,
                "title": "python-elegant-dp-solution",
                "content": "```\\ndef minimumCost(self, s: str) -> int:\\n\\tdef check(strs):\\n\\t\\tdp0, dp1 = [0]+[float(\\'inf\\')]*(len(strs)), [0]+[float(\\'inf\\')]*(len(strs))\\n\\t\\tfor i in range(len(strs)):\\n\\t\\t\\tif strs[i]==\\'0\\':\\n\\t\\t\\t\\tdp0[i+1] = dp0[i]\\n\\t\\t\\t\\tdp1[i+1] = min(dp1[i+1], dp0[i]+i+1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp0[i+1] = min(dp0[i+1], dp1[i]+i+1)      \\n\\t\\t\\t\\tdp1[i+1] = dp1[i]\\n\\t\\treturn dp0[-1], dp1[-1]\\n\\tx0, x1 = check(s[:len(s)//2])\\n\\ty0, y1 = check(s[len(s)//2:][::-1])\\n\\treturn min(x0+y0, x1+y1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumCost(self, s: str) -> int:\\n\\tdef check(strs):\\n\\t\\tdp0, dp1 = [0]+[float(\\'inf\\')]*(len(strs)), [0]+[float(\\'inf\\')]*(len(strs))\\n\\t\\tfor i in range(len(strs)):\\n\\t\\t\\tif strs[i]==\\'0\\':\\n\\t\\t\\t\\tdp0[i+1] = dp0[i]\\n\\t\\t\\t\\tdp1[i+1] = min(dp1[i+1], dp0[i]+i+1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp0[i+1] = min(dp0[i+1], dp1[i]+i+1)      \\n\\t\\t\\t\\tdp1[i+1] = dp1[i]\\n\\t\\treturn dp0[-1], dp1[-1]\\n\\tx0, x1 = check(s[:len(s)//2])\\n\\ty0, y1 = check(s[len(s)//2:][::-1])\\n\\treturn min(x0+y0, x1+y1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4034749,
                "title": "greedy-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry converting the string to all 1\\'s or all 0\\'s and return the minimum operations required to do so.\\n\\n# Complexity\\n- Time complexity:O(2*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nlong long change_to(string s,char from,char to)\\n{\\n    long long n = s.size(),count = 0,ans = 0;\\n    int i = 0;\\n    while(i<n)\\n    {\\n        while(i<n && s[i]==from)\\n        {\\n            i++;\\n            count++;\\n        }\\n        if((s[i]==to || i>=n-1)&& count>0)\\n        {\\n            int rem = i-count;\\n            ans = ans+i+rem;\\n            count = 0;\\n        }\\n        i++;\\n    }\\n    return ans;\\n}\\nlong long minimumCost(string s)\\n   {\\n       long long n = s.size(),ans1 = 0,ans2 = 0;\\n       long long len = (n)/2;\\n       string s1 = s.substr(0,len),s2 = s.substr(n%2==0 ? n/2 : n/2+1,len);\\n       reverse(s2.begin(),s2.end());\\n\\n        ans1 = change_to(s1,\\'0\\',\\'1\\')+change_to(s2,\\'0\\',\\'1\\');\\n        ans2 = change_to(s1,\\'1\\',\\'0\\')+change_to(s2,\\'1\\',\\'0\\');\\n\\n        if(n%2!=0 && s[n/2]==\\'1\\') ans2+=n;\\n        if(n%2!=0 && s[n/2]==\\'0\\') ans1+=n;\\n        \\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nlong long change_to(string s,char from,char to)\\n{\\n    long long n = s.size(),count = 0,ans = 0;\\n    int i = 0;\\n    while(i<n)\\n    {\\n        while(i<n && s[i]==from)\\n        {\\n            i++;\\n            count++;\\n        }\\n        if((s[i]==to || i>=n-1)&& count>0)\\n        {\\n            int rem = i-count;\\n            ans = ans+i+rem;\\n            count = 0;\\n        }\\n        i++;\\n    }\\n    return ans;\\n}\\nlong long minimumCost(string s)\\n   {\\n       long long n = s.size(),ans1 = 0,ans2 = 0;\\n       long long len = (n)/2;\\n       string s1 = s.substr(0,len),s2 = s.substr(n%2==0 ? n/2 : n/2+1,len);\\n       reverse(s2.begin(),s2.end());\\n\\n        ans1 = change_to(s1,\\'0\\',\\'1\\')+change_to(s2,\\'0\\',\\'1\\');\\n        ans2 = change_to(s1,\\'1\\',\\'0\\')+change_to(s2,\\'1\\',\\'0\\');\\n\\n        if(n%2!=0 && s[n/2]==\\'1\\') ans2+=n;\\n        if(n%2!=0 && s[n/2]==\\'0\\') ans1+=n;\\n        \\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589361,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long firstHalf(string &s , char k){\\n        long long ans = 0;\\n        int n = s.length();\\n        bool flip = false;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == k){\\n                if(flip){\\n                    ans += i+1;\\n                    flip = false;\\n                }\\n            }\\n            else{\\n                if(!flip){\\n                    ans += i+1;\\n                    flip = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    long long secondHalf(string &s , char k, int l, int mid){\\n        long long ans = 0;\\n        int n = s.length();\\n        bool flip = false;\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i] == k){\\n                if(flip){\\n                    ans += (l - (mid+i));\\n                    flip = false;\\n                }\\n            }\\n            else{\\n                if(!flip){\\n                    ans += (l - (mid + i));\\n                    flip = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n\\n        int mid = n/2;\\n        string s1 = s.substr(0,mid);\\n        string s2 = s.substr(mid, n-mid);\\n        // cout << s1 << \" \" << s2 << endl;\\n        long long a = firstHalf(s1, \\'0\\');\\n        long long b = secondHalf(s2, \\'0\\', n , mid);\\n        // cout << a << \" \" << b << endl;\\n        long long c = firstHalf(s1, \\'1\\');\\n        long long d = secondHalf(s2, \\'1\\', n , mid);\\n        // cout << c << \" \" << d << endl;\\n        return min(a+b , c+d);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long firstHalf(string &s , char k){\\n        long long ans = 0;\\n        int n = s.length();\\n        bool flip = false;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == k){\\n                if(flip){\\n                    ans += i+1;\\n                    flip = false;\\n                }\\n            }\\n            else{\\n                if(!flip){\\n                    ans += i+1;\\n                    flip = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    long long secondHalf(string &s , char k, int l, int mid){\\n        long long ans = 0;\\n        int n = s.length();\\n        bool flip = false;\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i] == k){\\n                if(flip){\\n                    ans += (l - (mid+i));\\n                    flip = false;\\n                }\\n            }\\n            else{\\n                if(!flip){\\n                    ans += (l - (mid + i));\\n                    flip = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n\\n        int mid = n/2;\\n        string s1 = s.substr(0,mid);\\n        string s2 = s.substr(mid, n-mid);\\n        // cout << s1 << \" \" << s2 << endl;\\n        long long a = firstHalf(s1, \\'0\\');\\n        long long b = secondHalf(s2, \\'0\\', n , mid);\\n        // cout << a << \" \" << b << endl;\\n        long long c = firstHalf(s1, \\'1\\');\\n        long long d = secondHalf(s2, \\'1\\', n , mid);\\n        // cout << c << \" \" << d << endl;\\n        return min(a+b , c+d);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3577768,
                "title": "simple-iterative-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we need to declare a variable mincost which defines the minimum cost for swaping the elements\\nthen we need to check if  s[i] != s[i+1] then it compares i + 1, representing the distance from the start of the string to the current character, and n - i - 1, representing the distance from the current character from the end of the string. The minimum of these two values represents the minimum cost of the swap.\\nmincost variable is incremented for every swap.\\nthen we need to return the mincost.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        long long mincost = 0;\\n        \\n        for (int i = 0; i < n - 1; ++i) {\\n            if (s[i] != s[i + 1]) {\\n                mincost += min(i + 1, n - i - 1);\\n            }\\n        }\\n        \\n        return mincost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        long long mincost = 0;\\n        \\n        for (int i = 0; i < n - 1; ++i) {\\n            if (s[i] != s[i + 1]) {\\n                mincost += min(i + 1, n - i - 1);\\n            }\\n        }\\n        \\n        return mincost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575708,
                "title": "using-prefix-and-suffix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOverthinking \\nbecause I could not think of a one liner solution\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n1) I created a prefix array which contains the cost i would spend if i change my array from the left end to this element.\\nEx: 01000(1)0110\\nIf i am at the bracket element and i want to change it (using the left side) then it becomes 0 then in the left i would change another 1 to get all the same elements.\\n>Like if i consider that element and want to change it by using the left side then it would change (1 current ele)->(next 0 to the left) -> (next 1 to the left) -> (next 0 to the left) -> so on..\\n>After using the left operation for that element now i would do the same from the same parity element in the right.\\n\\n2) The suffix has the same logic as the prefix but the change i will make would be in the right direction of the array.\\nEx: 0100(1)1000100\\nIf i am at the bracket element and i want to change it (using the right side) then i becomes 0 , then i would change the next 1 to the right , then next 0 to the right and so on...\\n\\n>Inshort:Prefix contains the cost of alternate 0\\'s and 1\\'s (the last occurance) from the current element in the left direction\\nlike 0100(1) cost would be (5th element)+(4th element)+(2nd element)+(1st element)\\nSuffix Contains the cost of alternate 0\\'s and 1\\'s (the first occurance) from the current element in the right direction.\\nlike 10(1)1001 cost would be (3rd + 5th + 7th)\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        int cnt = count(s.begin(),s.end(),\\'0\\');\\n        if(cnt == 0 || cnt == n)return 0;\\n        long long pre[2][n];\\n        long long suf[2][n];\\n        memset(pre,0,sizeof(pre));\\n        memset(suf,0,sizeof(suf));\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'0\\'){\\n                pre[1][i] = i == 0 ? 0:pre[1][i - 1];\\n                pre[0][i] = (i + 1) + pre[1][i];\\n            }\\n            else{\\n                pre[0][i] = i == 0 ? 0:pre[0][i - 1];\\n                pre[1][i] = (i + 1) + pre[0][i];\\n            }\\n        }\\n        \\n        for(int i = n - 1;i>=0;i--){\\n            if(s[i] == \\'0\\'){\\n                suf[1][i] = i == n - 1 ? 0:suf[1][i + 1];\\n                suf[0][i] = (n - i) + suf[1][i];\\n            }\\n            else{\\n                suf[0][i] = i == n - 1 ? 0:suf[0][i + 1];\\n                suf[1][i] = (n - i) + suf[0][i];\\n            }\\n        }\\n        long long ans = LLONG_MAX;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'1\\'){\\n                long long left = pre[1][i] + (i == n - 1 ? 0:suf[1][i + 1]);\\n                long long right = suf[1][i] + (i == 0 ? 0:pre[1][i - 1]);\\n                ans = min({ans,left,right});\\n            }\\n            else{\\n                long long left = pre[0][i] + (i == n - 1 ? 0:suf[0][i + 1]);\\n                long long right = suf[0][i] + (i == 0 ? 0:pre[0][i - 1]);\\n                ans = min({ans,left,right});\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        int cnt = count(s.begin(),s.end(),\\'0\\');\\n        if(cnt == 0 || cnt == n)return 0;\\n        long long pre[2][n];\\n        long long suf[2][n];\\n        memset(pre,0,sizeof(pre));\\n        memset(suf,0,sizeof(suf));\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'0\\'){\\n                pre[1][i] = i == 0 ? 0:pre[1][i - 1];\\n                pre[0][i] = (i + 1) + pre[1][i];\\n            }\\n            else{\\n                pre[0][i] = i == 0 ? 0:pre[0][i - 1];\\n                pre[1][i] = (i + 1) + pre[0][i];\\n            }\\n        }\\n        \\n        for(int i = n - 1;i>=0;i--){\\n            if(s[i] == \\'0\\'){\\n                suf[1][i] = i == n - 1 ? 0:suf[1][i + 1];\\n                suf[0][i] = (n - i) + suf[1][i];\\n            }\\n            else{\\n                suf[0][i] = i == n - 1 ? 0:suf[0][i + 1];\\n                suf[1][i] = (n - i) + suf[0][i];\\n            }\\n        }\\n        long long ans = LLONG_MAX;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'1\\'){\\n                long long left = pre[1][i] + (i == n - 1 ? 0:suf[1][i + 1]);\\n                long long right = suf[1][i] + (i == 0 ? 0:pre[1][i - 1]);\\n                ans = min({ans,left,right});\\n            }\\n            else{\\n                long long left = pre[0][i] + (i == n - 1 ? 0:suf[0][i + 1]);\\n                long long right = suf[0][i] + (i == 0 ? 0:pre[0][i - 1]);\\n                ans = min({ans,left,right});\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571253,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        return sum(min(i,len(s)-i) for i in range(1,len(s)) if s[i]!=s[i-1])\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        return sum(min(i,len(s)-i) for i in range(1,len(s)) if s[i]!=s[i-1])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570946,
                "title": "simple-greedy-solution-with-bonus-1-liner",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        s1, s2 = list(s[:n//2]), list(s[n//2:][::-1])\\n        r = 0\\n        for i in range(len(s1)-1):\\n            if s1[i] != s1[i+1]:\\n                r+=(i+1)\\n                s1[i] = s1[i+1]\\n        for i in range(len(s2)-1):\\n            if s2[i] != s2[i+1]:\\n                r+=(i+1)\\n                s2[i] = s2[i+1]\\n        return r+len(s1) if s1 and s1[-1] != s2[-1] else r\\n```\\nOne-liner (Technically 2 liner but heh):\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        return sum(min(n-i-1, i+1) for i in range(n-1) if s[i] != s[i+1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        s1, s2 = list(s[:n//2]), list(s[n//2:][::-1])\\n        r = 0\\n        for i in range(len(s1)-1):\\n            if s1[i] != s1[i+1]:\\n                r+=(i+1)\\n                s1[i] = s1[i+1]\\n        for i in range(len(s2)-1):\\n            if s2[i] != s2[i+1]:\\n                r+=(i+1)\\n                s2[i] = s2[i+1]\\n        return r+len(s1) if s1 and s1[-1] != s2[-1] else r\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        return sum(min(n-i-1, i+1) for i in range(n-1) if s[i] != s[i+1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570941,
                "title": "easy-java-fast-100",
                "content": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)!=s.charAt(i+1)){\\n                ans+=Math.min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)!=s.charAt(i+1)){\\n                ans+=Math.min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570904,
                "title": "python3-easy-one-pass-greedy-solution-with-clear-readable-explanation",
                "content": "# Intuition\\nAssume the string is all equal up to index i. At index i+1, if the character is different from i, then you either flip all the previous characters up to index i to make it the same as i+1, or flip the string from i+1 onwards to make it equal to index i. Continue this process until you are done.\\n\\nFor example, for the string 0011:\\n\\nAt index 2: there is a discrepancy with index 1 (0). You can either flip all the characters up to index 1 (with cost 2), or flip the suffix from index 2 (with cost 2) to resolve this discrepancy.\\n\\nContinue doing this for all discrepancies. As you iterate to the next index, you have maintained the invariant that all characters are equal up to index i.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution:\\n                \\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        for idx in range(1, len(s)):\\n            if s[idx-1] != s[idx]:\\n                cost += min(idx, len(s) - idx)\\n        return cost\\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n                \\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        for idx in range(1, len(s)):\\n            if s[idx-1] != s[idx]:\\n                cost += min(idx, len(s) - idx)\\n        return cost\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570814,
                "title": "python-single-pass-greedy-approach-with-explanation-o-n-beats-100",
                "content": "## **Approach** :\\n\\nCheck if `s[i-1]` != `s[i]` \\n\\nIf so, you can \\n* either flip the bits in the prefix of i `[0:i+1]` with cost `i`\\n* or flip the bits in the suffix of i `[i:n]` with cost `n-i`\\n \\nto make the adjacent bits equal. Choose minimum cost among them.\\n\\n\\n## **Complexity** : \\n* **Time Complexity** : `O(n)`\\n* **Space Complexity** : `O(1)`\\n\\n## **Solution** :\\nPython\\n```python\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(n-1,0,-1):\\n            if s[i-1] != s[i]: \\n\\t\\t\\t\\tans += min(i,n-i)               \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(n-1,0,-1):\\n            if s[i-1] != s[i]: \\n\\t\\t\\t\\tans += min(i,n-i)               \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570635,
                "title": "very-easy-c-100-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long result = 0;\\n        // Iterate over the string\\n        for (int i = 0; i + 1 < s.size(); i++) {\\n            // Check if the current character is different from the next character\\n            if (s[i] != s[i + 1]) {\\n                // Calculate the cost and add it to the result\\n                result += min(i + 1, (int)s.size() - i - 1);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long result = 0;\\n        // Iterate over the string\\n        for (int i = 0; i + 1 < s.size(); i++) {\\n            // Check if the current character is different from the next character\\n            if (s[i] != s[i + 1]) {\\n                // Calculate the cost and add it to the result\\n                result += min(i + 1, (int)s.size() - i - 1);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570393,
                "title": "1-line-python-solution",
                "content": "# Intuition\\n\\nThe minimum cost can be found using a greedy approach based on each two-character substring.\\n\\n# Approach\\n\\nFocus on one two-character substring at a time. Assume the preceding characters match the first character and the following characters match the second.\\n\\nCase 1: ...000 **00** 000...\\n\\nSince all characters are equal, no operations are required.\\n\\nCase 2: ...000 **01** 111...\\n\\nSince the characters are not equal, an operation must be performed.\\n\\nSuppose the second character, **1**, has index `i`. \\n* The cost to inverse all the 0 bits would be `i - 1 + 1` where `i - 1` gives us the index of the first character, **0**, and the `+ 1` is the cost addend from the problem description.\\n* The cost to inverse all the 1 bits is simply `i`: the cost of inverting `i` to `n - i` as described in the description.\\n\\nThe remaining cases are `\"11\"` which follows the logic of Case 1 and `\"10\"` which follows the logic of Case 2.\\n\\n# Example\\n\\nUsing `\"0011\"` as an example.\\n\\nThe total minimum cost is built independently from the two-character cases described in the **Approach** section.\\n\\nSubstring 1: **00**11\\n\\n* The cost to make the strings equal is 0 as they are already equal.\\n* There are no preceding characters and thus there is no cost to make it equal to the first character, **0**.\\n* The succeeding characters, **11**, will have their cost to make equal to the second character, **0**, computed in the following iterations.\\n\\nSubstring 2: 0**01**1\\n\\n* The cost to make the strings equal is `min(i, len(s) - i) = min(2, 2) = 2`.\\n* The preceding characters, **0** has already had its cost to make equal to the first character, **0**, computed.\\n* As before, the cost to make the succeeding characters, **1**, equal to the second character, **1** will be computed in the following iterations.\\n\\nSubstring 3: 00**11**\\n\\n* Again, the cost to make the strings equal is 0 as they are already equal.\\n* As before the preceding characters, **00**, have had their minmum cost to make equal to the first character, **1**, computed.\\n* There are no following characters and thus have no cost to make equal to the second character, **1**.\\n\\n# Complexity\\n\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n\\nThe minimum cost of each operation on a pair is considered.\\n* Case 1: The pairs that are equal are filtered out.\\n* Case 2: The minimum operation cost to make all characters equal is calculated.\\n  * The first operation type is simplified from `i - 1 + 1` to `i`.\\n\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        return sum(\\n            min(i, len(s) - i)\\n            for i, (a, b) in enumerate(pairwise(s), 1)\\n            if a != b\\n        )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        return sum(\\n            min(i, len(s) - i)\\n            for i, (a, b) in enumerate(pairwise(s), 1)\\n            if a != b\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570388,
                "title": "easy-java-solution-100-faster",
                "content": "- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n     \\n        int len=s.length()-1;\\n        long count=0;\\n        for(int m=0;m<len;m++)\\n        {\\n            if(s.charAt(m)!=s.charAt(m+1)) count+=Math.min(len-m,m+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n     \\n        int len=s.length()-1;\\n        long count=0;\\n        for(int m=0;m<len;m++)\\n        {\\n            if(s.charAt(m)!=s.charAt(m+1)) count+=Math.min(len-m,m+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570387,
                "title": "python-simple-python-solution-100-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 212 ms, faster than 100.00% of Python3 online submissions for Minimum Cost to Make All Characters Equal.\\n# Memory Usage: 17.4 MB, less than 37.50% of Python3 online submissions for Minimum Cost to Make All Characters Equal.\\n![image](https://assets.leetcode.com/users/images/e4eaf582-9bd1-4eb1-86de-aa29bf584f59_1685247274.0060494.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef minimumCost(self, s: str) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tlength = len(s)\\n\\n\\t\\t\\tfor index in range(1 ,  length):\\n\\n\\t\\t\\t\\tif s[index - 1] == s[index]:\\n\\n\\t\\t\\t\\t\\tresult = result + 0\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tresult = result + min(index , length - index)\\n\\n\\t\\t\\treturn result\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 212 ms, faster than 100.00% of Python3 online submissions for Minimum Cost to Make All Characters Equal.\\n# Memory Usage: 17.4 MB, less than 37.50% of Python3 online submissions for Minimum Cost to Make All Characters Equal.\\n![image](https://assets.leetcode.com/users/images/e4eaf582-9bd1-4eb1-86de-aa29bf584f59_1685247274.0060494.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef minimumCost(self, s: str) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tlength = len(s)\\n\\n\\t\\t\\tfor index in range(1 ,  length):\\n\\n\\t\\t\\t\\tif s[index - 1] == s[index]:\\n\\n\\t\\t\\t\\t\\tresult = result + 0\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tresult = result + min(index , length - index)\\n\\n\\t\\t\\treturn result\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3570379,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to determine the minimum cost required to make all characters in the string s equal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code uses a simple approach to calculate the minimum cost. It iterates through the string and checks adjacent character pairs. Whenever a pair of characters is different, it increments the cost by the minimum value between the indices of the characters.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through the string once, so the time complexity is O(n), where n is the length of the string s.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The code uses a constant amount of extra space, so the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        // Iterate over the string\\n        for (int i = 0; i + 1 < s.size(); i++) {\\n            // Check if the current character is different from the next character\\n            if (s[i] != s[i + 1]) {\\n                // Calculate the cost and add it to the answer\\n                ans += min(i + 1, (int)s.size() - i - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        // Iterate over the string\\n        for (int i = 0; i + 1 < s.size(); i++) {\\n            // Check if the current character is different from the next character\\n            if (s[i] != s[i + 1]) {\\n                // Calculate the cost and add it to the answer\\n                ans += min(i + 1, (int)s.size() - i - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570346,
                "title": "python-simple-easy-two-pointer-approach-beat-98",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        mid = (n-1)//2\\n        target = int(s[mid])\\n        left = mid-1; right = mid+1\\n        answer = 0\\n        count = 0\\n        while left >= 0:\\n            if (count + int(s[left])) % 2 != target:\\n                answer += left+1\\n                count += 1\\n            left -= 1\\n        \\n        count = 0\\n        while right < n:\\n            if (count + int(s[right])) % 2 != target:\\n                answer += n-right\\n                count += 1\\n            right += 1\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        mid = (n-1)//2\\n        target = int(s[mid])\\n        left = mid-1; right = mid+1\\n        answer = 0\\n        count = 0\\n        while left >= 0:\\n            if (count + int(s[left])) % 2 != target:\\n                answer += left+1\\n                count += 1\\n            left -= 1\\n        \\n        count = 0\\n        while right < n:\\n            if (count + int(s[right])) % 2 != target:\\n                answer += n-right\\n                count += 1\\n            right += 1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570252,
                "title": "very-easy-solution-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        long long ans=0;\\n        for(int i=0 ; i< n-1 ; i++) {\\n            if(s[i] != s[i+1]) {\\n                ans += min(i+1, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        long long ans=0;\\n        for(int i=0 ; i< n-1 ; i++) {\\n            if(s[i] != s[i+1]) {\\n                ans += min(i+1, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570238,
                "title": "very-inuitive-one-pass-c-o-1-space",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply make all elements till i equal, then 0 to i all elements are same. Now if i and i+1 are not equal, then either flip 0 to i(inclusive) or i+1 till end, whichever is has lesser cost.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string &s) \\n    {\\n        long long flips=0;\\n        \\n        int n=s.size();\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i]!=s[i+1])\\n                flips+=min(i+1,n-i-1);\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string &s) \\n    {\\n        long long flips=0;\\n        \\n        int n=s.size();\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i]!=s[i+1])\\n                flips+=min(i+1,n-i-1);\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570233,
                "title": "detailed-python-explanation-easy-to-understand-simulation-divide-and-conquer",
                "content": "# Intuition\\nLet us understand this by an example. \\nWe take 1110\\nNow if we want to make all 0s\\nWe flip the first 1, \\nNow s becomes 0110\\nNow we flip the second char\\nBut the string becomes 1010\\nThis isn\\'t the most optimal. How about we start flipping from the middle. We have two ways to flip: Either left: towards 0 or right: towards the end\\nWe choose to flip towards the closest end. And since we want to do it optimally, we start from the middle.\\n\\nThere are only two possibilities. Either all 0s or all 1s\\nNow while flipping, if we something even number of times, it becomes same\\n\\n# Approach\\nWe try abd make all 0s or all 1s\\n- Compute the cost of making all 0s \\n- Compute cost of making all 1s\\n- Return the min of both\\n- Let us see the case of making all 0s\\n    - Divide the string into equal halves(left and right)\\n    - For left string, start from the end and process towards the start\\n    - If we encounter a 1, we flip and add index to score\\n    - if we encounter a 1 and number of flips is odd(in which case the number becomes a 0), we can leave that\\n    - And if we encounter a 0 and number of flips is even, we leave that too.\\n    - Now since we are going from right to left, flipping an index\\'d element changes the left elements of it too. So if number of flips is even, it doesn\\'t change, else it changes.\\nNow that we have processed left, we should process the right half too\\n\\n- Similiary we do for all 1s. \\n- Now we find the minimum and return it\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$: n being the length of string\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        p2 = n//2\\n        p1 = p2-1\\n        cp1 = p1\\n        cp2 = p2\\n        c1 = 0\\n        #all 0s\\n        fl = 0\\n        while p1 >= 0:\\n            if (s[p1] == \\'0\\' and fl%2==0) or (s[p1]==\\'1\\' and fl%2==1):\\n                p1 -= 1\\n                continue\\n            fl += 1\\n            c1 += p1+1\\n            p1 -= 1\\n        fl = 0\\n        while p2 < len(s):\\n            if (s[p2] == \\'0\\' and fl%2==0) or (s[p2]==\\'1\\' and fl%2==1):\\n                p2 += 1\\n                continue\\n            fl += 1\\n            c1 += n-p2\\n            p2+=1\\n        #all1s\\n        p1,p2 = cp1,cp2\\n        fl = 0\\n        c2  = 0\\n        while p1 >= 0:\\n            if (s[p1] == \\'1\\' and fl%2==0) or (s[p1]==\\'0\\' and fl%2==1):\\n                p1 -= 1\\n                continue\\n            fl += 1\\n            c2+= p1+1\\n            p1 -= 1\\n        fl = 0\\n        while p2 < len(s):\\n            if (s[p2] == \\'1\\' and fl%2==0) or (s[p2]==\\'0\\' and fl%2==1):\\n                p2 += 1\\n                continue\\n            fl += 1\\n            c2 += n-p2\\n            p2 += 1\\n        return min(c1, c2)\\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        p2 = n//2\\n        p1 = p2-1\\n        cp1 = p1\\n        cp2 = p2\\n        c1 = 0\\n        #all 0s\\n        fl = 0\\n        while p1 >= 0:\\n            if (s[p1] == \\'0\\' and fl%2==0) or (s[p1]==\\'1\\' and fl%2==1):\\n                p1 -= 1\\n                continue\\n            fl += 1\\n            c1 += p1+1\\n            p1 -= 1\\n        fl = 0\\n        while p2 < len(s):\\n            if (s[p2] == \\'0\\' and fl%2==0) or (s[p2]==\\'1\\' and fl%2==1):\\n                p2 += 1\\n                continue\\n            fl += 1\\n            c1 += n-p2\\n            p2+=1\\n        #all1s\\n        p1,p2 = cp1,cp2\\n        fl = 0\\n        c2  = 0\\n        while p1 >= 0:\\n            if (s[p1] == \\'1\\' and fl%2==0) or (s[p1]==\\'0\\' and fl%2==1):\\n                p1 -= 1\\n                continue\\n            fl += 1\\n            c2+= p1+1\\n            p1 -= 1\\n        fl = 0\\n        while p2 < len(s):\\n            if (s[p2] == \\'1\\' and fl%2==0) or (s[p2]==\\'0\\' and fl%2==1):\\n                p2 += 1\\n                continue\\n            fl += 1\\n            c2 += n-p2\\n            p2 += 1\\n        return min(c1, c2)\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570228,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUpvote if you liked it :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUpvote if you liked it :)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long cost = 0;\\n        for(int i=0; i<(n-1); i++) if(s.charAt(i) != s.charAt(i+1)) cost += Math.min(i+1,n-i-1);\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long cost = 0;\\n        for(int i=0; i<(n-1); i++) if(s.charAt(i) != s.charAt(i+1)) cost += Math.min(i+1,n-i-1);\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570190,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe try to make all zero or one, and we split the array in two half to perform operation\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        int k = n/2; // to split in half\\n        \\n        // all zero\\n        vector<char> to = {\\'0\\', \\'1\\'}; \\n        long long res1 = 0; \\n        for(int i = k-1; i>=0; i--){\\n            if(s[i] != to[0]){\\n                res1 += i+1; \\n                swap(to[0], to[1]); \\n            }\\n        }\\n        to = {\\'0\\', \\'1\\'};  \\n        for(int i = k; i<n; i++){\\n            if(s[i] != to[0]){\\n                res1 += n-i; \\n                swap(to[0], to[1]); \\n            }\\n            \\n        }\\n        \\n        // all one\\n        to = {\\'1\\', \\'0\\'};\\n        long long res2 = 0; \\n        for(int i = k-1; i>=0; i--){\\n            if(s[i] != to[0]){\\n                res2 += i+1; \\n                swap(to[0], to[1]); \\n            }\\n        }\\n        to = {\\'1\\', \\'0\\'};\\n        for(int i = k; i<n; i++){\\n            if(s[i] != to[0]){\\n                res2 += n-i; \\n                swap(to[0], to[1]); \\n            }\\n            \\n        }\\n        return min(res1, res2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        int k = n/2; // to split in half\\n        \\n        // all zero\\n        vector<char> to = {\\'0\\', \\'1\\'}; \\n        long long res1 = 0; \\n        for(int i = k-1; i>=0; i--){\\n            if(s[i] != to[0]){\\n                res1 += i+1; \\n                swap(to[0], to[1]); \\n            }\\n        }\\n        to = {\\'0\\', \\'1\\'};  \\n        for(int i = k; i<n; i++){\\n            if(s[i] != to[0]){\\n                res1 += n-i; \\n                swap(to[0], to[1]); \\n            }\\n            \\n        }\\n        \\n        // all one\\n        to = {\\'1\\', \\'0\\'};\\n        long long res2 = 0; \\n        for(int i = k-1; i>=0; i--){\\n            if(s[i] != to[0]){\\n                res2 += i+1; \\n                swap(to[0], to[1]); \\n            }\\n        }\\n        to = {\\'1\\', \\'0\\'};\\n        for(int i = k; i<n; i++){\\n            if(s[i] != to[0]){\\n                res2 += n-i; \\n                swap(to[0], to[1]); \\n            }\\n            \\n        }\\n        return min(res1, res2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047521,
                "title": "greedy-super-simple-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        long long n=s.size();\\n        long long ans=0;\\n        for(int x=0; x<n-1; x++)\\n        {\\n            if(s[x]!=s[x+1]) ans+=(x+1>n-x-1?n-x-1:x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        long long n=s.size();\\n        long long ans=0;\\n        for(int x=0; x<n-1; x++)\\n        {\\n            if(s[x]!=s[x+1]) ans+=(x+1>n-x-1?n-x-1:x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028275,
                "title": "easiest-one-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust iterate the string and if two adjacent characters are not equal then just invert it i.e. add the min value of inversion.\\nmin value of inversion means which operation we are using 1st one or 2nd one.\\n\\nIf you like it please upvote \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n-1; ++i){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1 , n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n-1; ++i){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1 , n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028274,
                "title": "easiest-one-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust iterate the string and if two adjacent characters are not equal then just invert it i.e. add the min value of inversion.\\nmin value of inversion means which operation we are using 1st one or 2nd one.\\n\\nIf you like it please upvote \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n-1; ++i){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1 , n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n-1; ++i){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1 , n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011723,
                "title": "prefix-sum-suffix-sum-dp",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        vector<long long>pre(s.size(),0),suf(s.size(),0);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==s[i-1])pre[i]=pre[i-1];\\n            else pre[i]=i+pre[i-1];\\n            // cout<<pre[i]<<\" \";\\n        }\\n        // return 0;\\n        // cout<<endl;\\n        for(int i=s.size()-2;i>=0;i--){\\n            if(s[i]==s[i+1])suf[i]=suf[i+1];\\n            else suf[i]=s.size()-i-1+suf[i+1];\\n            // cout<<suf[i]<<\" \";\\n        }\\n        // return 0;\\n        // for(int i=0;i<s.size();i++){\\n        //     cout<<pre[i]<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<s.size();i++){\\n        //     cout<<suf[i]<<\" \";\\n        // }\\n        long long ans=1e18;\\n        for(int i=0;i<s.size();i++){\\n            if(i==0)ans=min(ans,suf[i]);\\n            else if(i==s.size()-1)ans=min(ans,pre[i]);\\n            else ans=min(ans,pre[i]+suf[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        vector<long long>pre(s.size(),0),suf(s.size(),0);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==s[i-1])pre[i]=pre[i-1];\\n            else pre[i]=i+pre[i-1];\\n            // cout<<pre[i]<<\" \";\\n        }\\n        // return 0;\\n        // cout<<endl;\\n        for(int i=s.size()-2;i>=0;i--){\\n            if(s[i]==s[i+1])suf[i]=suf[i+1];\\n            else suf[i]=s.size()-i-1+suf[i+1];\\n            // cout<<suf[i]<<\" \";\\n        }\\n        // return 0;\\n        // for(int i=0;i<s.size();i++){\\n        //     cout<<pre[i]<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<s.size();i++){\\n        //     cout<<suf[i]<<\" \";\\n        // }\\n        long long ans=1e18;\\n        for(int i=0;i<s.size();i++){\\n            if(i==0)ans=min(ans,suf[i]);\\n            else if(i==s.size()-1)ans=min(ans,pre[i]);\\n            else ans=min(ans,pre[i]+suf[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4001774,
                "title": "easy-to-understand-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    long long minimumCost(string s) {\\n        long long ans=1e18;\\n        int n=s.length();\\n       \\n        vector<vector<long long>> dpp(n+1,vector<long long> (2,0));\\n                vector<vector<long long>> dps(n+2,vector<long long> (2,0));\\n\\n        \\n        dpp[1][0]=0;\\n        dpp[1][1]=1;\\n        for(int i=2;i<=n;i++){\\n            \\n         if(s[i-1]!=s[i-2]){\\n             dpp[i][0]=dpp[i-1][1];\\n             dpp[i][1]=i+dpp[i-1][1];\\n         }\\n        else{\\n             dpp[i][0]=dpp[i-1][0];\\n            dpp[i][1]=i+dpp[i-1][0];\\n        }\\n            \\n            \\n            \\n\\n        }\\n        \\n        \\n         dps[n][0]=0;\\n        dps[n][1]=1;\\n        for(int i=n-1;i>=1;i--){\\n                if(s[i-1]!=s[i]){\\n             dps[i][0]=dps[i+1][1];\\n             dps[i][1]=n-i+1+dps[i+1][1];\\n         }\\n        else{\\n             dps[i][0]=dps[i+1][0];\\n            dps[i][1]=n-i+1+dps[i+1][0];\\n        }\\n            \\n            \\n        }\\n        \\n        \\n\\n//         for(int i=1;i<=n;i++){\\n//             cout<<i<<\" \"<<dpp[i][0]<<\" \"<<dpp[i][1]<<endl;\\n//         }\\n        \\n//          for(int i=1;i<=n;i++){\\n//             cout<<i<<\" \"<<dps[i][0]<<\" \"<<dps[i][1]<<endl;\\n//         }\\n        \\n//         cout<<ans<<endl;\\n        \\n        \\n        for(int i=1;i<=n;i++){\\n            long long f1=dpp[i][0];\\n            long long f2=dpp[i][1];\\n            if(i!=n and s[i-1]!=s[i]){\\n                f1+=dps[i+1][1];\\n                f2+=dps[i+1][0];\\n            }\\n            else{\\n                  f1+=dps[i+1][0];\\n                f2+=dps[i+1][1];\\n            }\\n            // cout<<min(f2,f2)<<endl;\\n             ans=min(ans,min(f1,f2));\\n            // cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    long long minimumCost(string s) {\\n        long long ans=1e18;\\n        int n=s.length();\\n       \\n        vector<vector<long long>> dpp(n+1,vector<long long> (2,0));\\n                vector<vector<long long>> dps(n+2,vector<long long> (2,0));\\n\\n        \\n        dpp[1][0]=0;\\n        dpp[1][1]=1;\\n        for(int i=2;i<=n;i++){\\n            \\n         if(s[i-1]!=s[i-2]){\\n             dpp[i][0]=dpp[i-1][1];\\n             dpp[i][1]=i+dpp[i-1][1];\\n         }\\n        else{\\n             dpp[i][0]=dpp[i-1][0];\\n            dpp[i][1]=i+dpp[i-1][0];\\n        }\\n            \\n            \\n            \\n\\n        }\\n        \\n        \\n         dps[n][0]=0;\\n        dps[n][1]=1;\\n        for(int i=n-1;i>=1;i--){\\n                if(s[i-1]!=s[i]){\\n             dps[i][0]=dps[i+1][1];\\n             dps[i][1]=n-i+1+dps[i+1][1];\\n         }\\n        else{\\n             dps[i][0]=dps[i+1][0];\\n            dps[i][1]=n-i+1+dps[i+1][0];\\n        }\\n            \\n            \\n        }\\n        \\n        \\n\\n//         for(int i=1;i<=n;i++){\\n//             cout<<i<<\" \"<<dpp[i][0]<<\" \"<<dpp[i][1]<<endl;\\n//         }\\n        \\n//          for(int i=1;i<=n;i++){\\n//             cout<<i<<\" \"<<dps[i][0]<<\" \"<<dps[i][1]<<endl;\\n//         }\\n        \\n//         cout<<ans<<endl;\\n        \\n        \\n        for(int i=1;i<=n;i++){\\n            long long f1=dpp[i][0];\\n            long long f2=dpp[i][1];\\n            if(i!=n and s[i-1]!=s[i]){\\n                f1+=dps[i+1][1];\\n                f2+=dps[i+1][0];\\n            }\\n            else{\\n                  f1+=dps[i+1][0];\\n                f2+=dps[i+1][1];\\n            }\\n            // cout<<min(f2,f2)<<endl;\\n             ans=min(ans,min(f1,f2));\\n            // cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3947691,
                "title": "key-idea-explained-from-dp-to-greedy",
                "content": "**Intuition**\\nFlip left and Flip right operations can not cross each other because othwerwise you are just wasting flips\\nSo all operations might look something like this:\\n`[..L..L..........R..R..]`,\\nwhere `L` is Flip Left, `R` is Flip Right, `.` is where operation wasnt applied\\n\\nThe question to ask now is:\\nHow to find min cost to make 0110011 all 1s assuming you can do ONLY Flip Left?\\nAnswer:\\nYou flip everytime the next char is different, excluding the last substring of all 1s\\n\\n\\n**DP Approach**\\nWe calculate and save the cost of flipping left to right and right to left separately. \\nThen iterate along and find the cheapest cost combination of left flips and right flips. \\n**Time: O(n)\\nSpace: O(n)**\\n```\\ndef minimumCost(self, s: str) -> int:\\n    n = len(s)\\n    def min_cost(s):\\n        zero = one = cost = 0\\n        info = []\\n        for i in range(len(s)):\\n            cost += i + 1\\n            if i and s[i-1] == s[i]:\\n                cost -= i\\n            \\n            zero = 0 if s[i] == \"1\" else i + 1\\n            one = 0 if zero else i + 1\\n            \\n            info.append([zero, one, cost])\\n        return info\\n    \\n    left = min_cost(s)\\n    right = min_cost(s[::-1])[::-1]\\n\\n    ans = right[0][-1] - max(right[0][:-1])\\n\\n    for i in range(n-1):\\n        left_z, left_o, left_c = left[i]\\n        right_z, right_o, right_c = right[i+1]\\n\\n        # convert to all one\\n        ans = min(ans, left_c - left_o + right_c - right_o)\\n        # convert to all zero\\n        ans = min(ans, left_c - left_z + right_c - right_z)\\n        \\n    ans = min(ans, left[-1][-1] - max(left[-1][:-1]))\\n    return ans\\n```\\n\\n**Greedy Approach**\\nIt should be clear that flip operation is needed whenenver adjacent chars are different\\n\\nIf we always choose the `min(i (Flip Left), n - i (Flip Right))`,\\nthen Flip Left and Flip Right will never cross each other,\\nand since we are only flipping when needed, then we must be applying min cost approach\\n\\n**Time: O(n)\\nSpace: O(1)**\\n```\\ndef minimumCost(self, s: str) -> int:\\n    n = len(s)\\n    ans = 0\\n    for i in range(1, n):\\n        if s[i] != s[i-1]:\\n            ans += min(i, n - i)\\n    return ans\\n\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minimumCost(self, s: str) -> int:\\n    n = len(s)\\n    def min_cost(s):\\n        zero = one = cost = 0\\n        info = []\\n        for i in range(len(s)):\\n            cost += i + 1\\n            if i and s[i-1] == s[i]:\\n                cost -= i\\n            \\n            zero = 0 if s[i] == \"1\" else i + 1\\n            one = 0 if zero else i + 1\\n            \\n            info.append([zero, one, cost])\\n        return info\\n    \\n    left = min_cost(s)\\n    right = min_cost(s[::-1])[::-1]\\n\\n    ans = right[0][-1] - max(right[0][:-1])\\n\\n    for i in range(n-1):\\n        left_z, left_o, left_c = left[i]\\n        right_z, right_o, right_c = right[i+1]\\n\\n        # convert to all one\\n        ans = min(ans, left_c - left_o + right_c - right_o)\\n        # convert to all zero\\n        ans = min(ans, left_c - left_z + right_c - right_z)\\n        \\n    ans = min(ans, left[-1][-1] - max(left[-1][:-1]))\\n    return ans\\n```\n```\\ndef minimumCost(self, s: str) -> int:\\n    n = len(s)\\n    ans = 0\\n    for i in range(1, n):\\n        if s[i] != s[i-1]:\\n            ans += min(i, n - i)\\n    return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3888049,
                "title": "dry-run-yourself-you-will-understand-one-pass-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // https://www.youtube.com/watch?v=ybMuZTqQHFY\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n\\n        long long ans = 0;\\n\\n        // current index will make the indices previous to it equal to itself\\n        for(int i =1; i<n; i++){\\n            if(s[i-1] != s[i]){\\n                ans = ans + min(i, n-i);\\n                // cout<<i<<\"->\"<<min(i,n-i)<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // https://www.youtube.com/watch?v=ybMuZTqQHFY\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n\\n        long long ans = 0;\\n\\n        // current index will make the indices previous to it equal to itself\\n        for(int i =1; i<n; i++){\\n            if(s[i-1] != s[i]){\\n                ans = ans + min(i, n-i);\\n                // cout<<i<<\"->\"<<min(i,n-i)<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3871847,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n         int n = s.length();\\n        long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)!=s.charAt(i+1)){\\n                ans+=Math.min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n         int n = s.length();\\n        long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)!=s.charAt(i+1)){\\n                ans+=Math.min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854371,
                "title": "golang-solution-iterate-once-very-simple",
                "content": "# Code\\n```go\\nfunc minimumCost(s string) int64 {\\n\\tcost := 0\\n\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\tif s[i] != s[i+1] {\\n\\t\\t\\tcost += min(i+1, len(s)-i-1)\\n\\t\\t}\\n\\t}\\n\\treturn int64(cost)\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minimumCost(s string) int64 {\\n\\tcost := 0\\n\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\tif s[i] != s[i+1] {\\n\\t\\t\\tcost += min(i+1, len(s)-i-1)\\n\\t\\t}\\n\\t}\\n\\treturn int64(cost)\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853309,
                "title": "leaning-on-the-stl",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    template <typename I>\\n    long long fix(I first, I last, bool make_zero) {\\n        long long cost = 0;\\n        for ( ; first != last; ++first) {\\n            if ((*first == \\'0\\') != make_zero) {\\n                cost += static_cast<long long>(last - first);\\n                make_zero = !make_zero;\\n            }\\n        }\\n        return cost;\\n    }\\n\\n    long long minimumCost(string s) {\\n        auto mid = begin(s) + s.size() / 2;\\n        return fix(make_reverse_iterator(mid), rend(s), *mid == \\'0\\') +\\n               fix(mid, end(s), *mid == \\'0\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    template <typename I>\\n    long long fix(I first, I last, bool make_zero) {\\n        long long cost = 0;\\n        for ( ; first != last; ++first) {\\n            if ((*first == \\'0\\') != make_zero) {\\n                cost += static_cast<long long>(last - first);\\n                make_zero = !make_zero;\\n            }\\n        }\\n        return cost;\\n    }\\n\\n    long long minimumCost(string s) {\\n        auto mid = begin(s) + s.size() / 2;\\n        return fix(make_reverse_iterator(mid), rend(s), *mid == \\'0\\') +\\n               fix(mid, end(s), *mid == \\'0\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809228,
                "title": "step-by-step-explnation-give-a-try",
                "content": "# Intuition\\n\\ns = \"010101\"\\nWe start iterating from index 1, and compare the current character with previous charcter and see if they are equal or not..\\n\\ni=1\\n    s[1]!=s[0]\\n        so we have two choices, either invert from index 0 to i or i to n-1, and among them we choose the operation which cost us minimum\\n\\nso lets try both way, \\n    invertin from 0 to i will cost 1 and make string look something like this\\n    1 1 0 1 0 1\\n\\ninverting from i to n-1 which is from 1 to 5 will cost 5 and make string look like this\\n\\n    0 0 1 0 1 0\\nand among this we choose the first operation ans our ans = 0 +min(1,5) = 1\\n\\n---------------------------\\n\\ni = 2\\n\\nstring is 1 1 0 1 0 1\\n    s[2]!=s[1]\\n\\nagain two choice, so let\\'s invert from 0 to i\\n    0 0 0 1 0 1 ==> with cose of 2\\nlet\\'s invert from i to n-1\\n1 1 1 0 1 0 === with cost of 4\\n\\nso among both these operation minimum is 2, so our ans becomes\\n    ans = 1 +min(2,4) = 3\\n\\nso we keep doing this operation till we reach last index.\\nOne thing which we notice is that , all string before i, are becoming either 0 or 1 after 1st operation.\\n\\n\\n\\n\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    // even after inversion, mismatch at each index remains sames, just their bits changes\\n    long long minimumCost(string s) {\\n        ll ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i]!=s[i-1]){\\n                ans+=min(i,n-i);\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    // even after inversion, mismatch at each index remains sames, just their bits changes\\n    long long minimumCost(string s) {\\n        ll ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i]!=s[i-1]){\\n                ans+=min(i,n-i);\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805156,
                "title": "explanation-for-myself",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![WechatIMG11.jpeg](https://assets.leetcode.com/users/images/9e96f78d-8cfb-49a2-a809-d0dbca16affd_1690106958.2032874.jpeg)\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n=len(s)\\n        res=0\\n        for i in range(1,n):\\n            if s[i]!=s[i-1]:\\n                res+=min(i,n-i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n=len(s)\\n        res=0\\n        for i in range(1,n):\\n            if s[i]!=s[i-1]:\\n                res+=min(i,n-i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747306,
                "title": "java-solution-just-applied-simple-intution-using-mid",
                "content": "# Approach\\nMove from mid to left and then right.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        if(s.length()<=1)return 0;\\n        if(s.length()==2){\\n            if(s.charAt(0)==s.charAt(1))return 0;\\n            else return 1;\\n        }\\n        int x=0,y=0,n=s.length();\\n        for(int i=0;i<s.length();i++)\\n        {\\n           if(s.charAt(i)==\\'1\\'){x=1;}\\n           if(s.charAt(i)==\\'0\\'){y=1;}      \\n        }\\n        if(x==0||y==0)return 0;\\n\\nint m=0;\\nif(n%2==0){m=(n/2)-1;}\\nelse{m=n/2;}\\nlong ans=0;\\nif(s.charAt(m)==\\'0\\'){\\n   int u=m,v=m+1,c=0;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\n}\\n}\\nelse{\\n  int u=m,v=m+1,c=0;\\n  while(u<n&&s.charAt(u)==\\'1\\'){u++;}\\n  u=m-1;v=m;\\n  ans+=u+1;c++;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\n}\\n\\n\\n}\\nlong ans1=0;\\nif(s.charAt(m)==\\'1\\'){\\n  int u=m,v=m+1,c=0;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\n}\\n\\n}\\nelse{\\n     int u=m,v=m+1,c=0;\\n  while(u<n&&s.charAt(u)==\\'0\\'){u++;}\\n  u=m-1;v=m;\\n  ans1+=u+1;c++;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\n}\\n}\\n\\n//System.out.print(ans+\" \"+ans1);\\nreturn Math.min(ans,ans1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        if(s.length()<=1)return 0;\\n        if(s.length()==2){\\n            if(s.charAt(0)==s.charAt(1))return 0;\\n            else return 1;\\n        }\\n        int x=0,y=0,n=s.length();\\n        for(int i=0;i<s.length();i++)\\n        {\\n           if(s.charAt(i)==\\'1\\'){x=1;}\\n           if(s.charAt(i)==\\'0\\'){y=1;}      \\n        }\\n        if(x==0||y==0)return 0;\\n\\nint m=0;\\nif(n%2==0){m=(n/2)-1;}\\nelse{m=n/2;}\\nlong ans=0;\\nif(s.charAt(m)==\\'0\\'){\\n   int u=m,v=m+1,c=0;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\n}\\n}\\nelse{\\n  int u=m,v=m+1,c=0;\\n  while(u<n&&s.charAt(u)==\\'1\\'){u++;}\\n  u=m-1;v=m;\\n  ans+=u+1;c++;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\n}\\n\\n\\n}\\nlong ans1=0;\\nif(s.charAt(m)==\\'1\\'){\\n  int u=m,v=m+1,c=0;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\n}\\n\\n}\\nelse{\\n     int u=m,v=m+1,c=0;\\n  while(u<n&&s.charAt(u)==\\'0\\'){u++;}\\n  u=m-1;v=m;\\n  ans1+=u+1;c++;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\n}\\n}\\n\\n//System.out.print(ans+\" \"+ans1);\\nreturn Math.min(ans,ans1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699247,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        res = 0\\n        for i in range(1, n):\\n            if s[i] != s[i - 1]:\\n                res += min(i, n - i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        res = 0\\n        for i in range(1, n):\\n            if s[i] != s[i - 1]:\\n                res += min(i, n - i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687694,
                "title": "simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans = 0L;\\n        int n = s.length();\\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) != s.charAt(i - 1)) {\\n                ans += Math.min(i, n - i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans = 0L;\\n        int n = s.length();\\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) != s.charAt(i - 1)) {\\n                ans += Math.min(i, n - i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663258,
                "title": "c-greedy-single-pass-98-time-20ms-75-space-12-1mb",
                "content": "This problem is clearly not approachable with a brute force approach, since each character might be flipped to either `\\'0\\'` or `\\'1\\'`, which implies we would have to compute $$2^n$$ different alternatives; it might tempt us into going through some complex DP approach, branching each time we find dissimilar characters, but actually we can proceed in a much easier way:\\n* when we encounter identical consecutive characters, clearly nothing much to be done;\\n* when we encounter different consecutive characters, then we have two options to consider - we either:\\n    * flip all the previous ones (that we can assume either were already homogeneous or we turned them that way with previous flips) for a cost of `i` OR\\n    * flip the current character and all the following ones, for a cost of `len - i`;\\n* regardless of the outcome, we can proceed and know that again all the characters up to the current index (excluded) are now homogeneous.\\n\\nThe beauty of it is that at each step we can proceed knowing that the cheapest move will also be the right one (ie: pure greedy approach); let\\'s assume for example at some point we are in this situation:\\n\\n```cpp\\n...0000000100010101...\\n          ^\\n```\\n\\nWe have made all the characters up to that point homogeneous, but then we found another different character: in that case the best course of action is to either flip all the previous characters to `\\'1\\'` or flip that character and all the following ones; so we will have two alternatives for this scenario:\\n\\n```cpp\\n...1111111100010101... // 1st case, flipping all the previous chars\\n          ^\\n...0000000011101010... // 2nd case, flipping from there onwards\\n          ^\\n```\\n\\nAnd it can be demonstrated that the cheapest option is the right one, since the cost of all the following flips still depends uniquely on how many flips we would need to do and how close to the end of the string we are.\\n\\nNow, to put all of this into code, we can start declaring our usual support variables:\\n* `len` will store the length of `s`;\\n* `res` will be our usual accumulator variable, counting how many flips we did overall.\\n\\nWe will then parse with `i` each character from the second (position `1`) to the last and, when we will find two different adjacent elements (ie: `s[i] != s[i - 1]`), we will update `res`, as explained by adding the minimum between flipping all the element before the current one (with a cost of `i`) or all the others from there onwards (with a cost of `n - i`).\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        // support variables\\n        int len = s.size();\\n        long long res = 0;\\n        // parsing s\\n        for (int i = 1; i < len; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += min(i, len - i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWe can save ourselves the cost of the `min` operation, if we think about it, since we know that taking the `i` will be cheaper in the first half of `s`, and more expensive after that, so we can refactor and split our main loop into two parts:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        // support variables\\n        int len = s.size(), halfLen = len >> 1;\\n        long long res = 0;\\n        // parsing the 1st half of s\\n        for (int i = 1; i <= halfLen; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += i;\\n            }\\n        }\\n        // parsing the 2nd half of s\\n        for (int i = halfLen + 1; i < len; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += len - i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```cpp\\n...0000000100010101...\\n          ^\\n```\n```cpp\\n...1111111100010101... // 1st case, flipping all the previous chars\\n          ^\\n...0000000011101010... // 2nd case, flipping from there onwards\\n          ^\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        // support variables\\n        int len = s.size();\\n        long long res = 0;\\n        // parsing s\\n        for (int i = 1; i < len; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += min(i, len - i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        // support variables\\n        int len = s.size(), halfLen = len >> 1;\\n        long long res = 0;\\n        // parsing the 1st half of s\\n        for (int i = 1; i <= halfLen; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += i;\\n            }\\n        }\\n        // parsing the 2nd half of s\\n        for (int i = halfLen + 1; i < len; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += len - i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651566,
                "title": "8-line-code-o-n-o-1-100-c-basic-greedy-dp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust make all the left of ith to be equal (i.e -> if you are at i==2 , s=\"111..0101\" as you can see till i==2 string contain equal char \\'1\\'. ). To do show we have to check ith char with i+1th char \\n\\ncase 1: if s[i]==s[i+1] just move forward as it is equal to left one.\\n \\ncase 2: if(s[i]!=s[i+1]) just make s[i+1]==s[i] such that your left side string till i must have same char to do so *first_approch-> we can change all char from 0 to i or, *second_approch-> we can change all the char form i+1 to n-1. so you can go with anyone of it but as we have to min the cost take the min of both the approch. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=s[i+1]){\\n                ans+=min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=s[i+1]){\\n                ans+=min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642652,
                "title": "greedy-approach-java-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    long helper(String s,int v){\\n        int len = s.length();\\n        long ans = 0;\\n        int flip = 0;\\n        for(int i = len / 2 - 1;i >= 0;i--){\\n            int c = s.charAt(i) - \\'0\\';\\n            if(c != v && flip % 2 == 0){\\n                ans += i + 1L;\\n                flip++;\\n            }\\n            else if(c == v && flip % 2 != 0){\\n                ans += i + 1L;\\n                flip++;\\n            }\\n        }\\n        flip = 0;\\n        for(int i = len / 2;i < len;i++){\\n            int c = s.charAt(i) - \\'0\\';\\n            if(c != v && flip % 2 == 0){\\n                ans += len - i;\\n                flip++;\\n            }\\n            else if(c == v && flip % 2 != 0){\\n                ans += len - i;\\n                flip++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public long minimumCost(String s) {\\n        long ans0 = helper(s,0);\\n        long ans1 = helper(s,1);\\n        return Math.min(ans0,ans1);\\n    }\\n}\\n```\\n\\n# Upvote if you like it \\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    long helper(String s,int v){\\n        int len = s.length();\\n        long ans = 0;\\n        int flip = 0;\\n        for(int i = len / 2 - 1;i >= 0;i--){\\n            int c = s.charAt(i) - \\'0\\';\\n            if(c != v && flip % 2 == 0){\\n                ans += i + 1L;\\n                flip++;\\n            }\\n            else if(c == v && flip % 2 != 0){\\n                ans += i + 1L;\\n                flip++;\\n            }\\n        }\\n        flip = 0;\\n        for(int i = len / 2;i < len;i++){\\n            int c = s.charAt(i) - \\'0\\';\\n            if(c != v && flip % 2 == 0){\\n                ans += len - i;\\n                flip++;\\n            }\\n            else if(c == v && flip % 2 != 0){\\n                ans += len - i;\\n                flip++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public long minimumCost(String s) {\\n        long ans0 = helper(s,0);\\n        long ans1 = helper(s,1);\\n        return Math.min(ans0,ans1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638398,
                "title": "simplest-approach-beats-97",
                "content": "# Intuition\\n1. Calculate the middle position of the string s\\n2. Starting from both ends moving toward the middle to make all chars on each side the same\\n3. check if s[m-1] = s[m], if not add m to the result. This is because we\\'ve made the left m characters the same, the right n - m character the same. We need flip m chars to make the whole string the same chars. \\n\\nIf you like my approach please upvote!\\n\\n# Approach\\nIterative, one pass scan\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        m = n//2\\n        l, r = 0, 0\\n        for i in range(1, m):\\n            if s[i-1] != s[i]:\\n                l += i\\n        for i in range(n-2, m-1, -1):\\n            if s[i] != s[i+1]:\\n                r += n - i - 1\\n        if s[m-1] != s[m]:\\n            return l + r + m\\n        return l + r\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        m = n//2\\n        l, r = 0, 0\\n        for i in range(1, m):\\n            if s[i-1] != s[i]:\\n                l += i\\n        for i in range(n-2, m-1, -1):\\n            if s[i] != s[i+1]:\\n                r += n - i - 1\\n        if s[m-1] != s[m]:\\n            return l + r + m\\n        return l + r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633977,
                "title": "tc-o-n-sc-o-1",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        \\n        long result = 0;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s.charAt(i) != s.charAt(i - 1)) result += Math.min(i , s.length() - i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        \\n        long result = 0;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s.charAt(i) != s.charAt(i - 1)) result += Math.min(i , s.length() - i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632403,
                "title": "simple-greedy-approch",
                "content": "# Intuition\\n<b>Simple check if([i] !=[i+1]</b> \\nthen we need to change it so choose cost from option 1 or optiom 2 which one is: \\nans+= Math.mim(option 1, option 2))\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:<b>O(1)</b>\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long ans = 0L;\\n        for(int i =0;i<n-1;i++){\\n            if(s.charAt(i) !=s.charAt(i+1)){\\n                ans += (i+1<n-i-1 ? i+1:n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long ans = 0L;\\n        for(int i =0;i<n-1;i++){\\n            if(s.charAt(i) !=s.charAt(i+1)){\\n                ans += (i+1<n-i-1 ? i+1:n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630058,
                "title": "just-the-proof-no-code",
                "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions.\\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].\\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof.",
                "solutionTags": [
                    "C++"
                ],
                "code": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions.\\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].\\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof.",
                "codeTag": "Unknown"
            },
            {
                "id": 3626048,
                "title": "antarnab-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // antarnab solution\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // antarnab solution\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622232,
                "title": "o-n-easy-to-understand-python",
                "content": "# Intuition\\nIt can be done trough looking into two halves of the string from mid\\n\\n# Approach\\nIf next bit is in Left Half: check if it is not same then swap the left part\\nelse next bit is in Right Half : check if it is not same then swap the right part\\n\\n# Complexity \\n- Time complexity: O(n) -> As only one iteration required\\n\\n- Space complexity: O(1) -> Const space is used for variable \\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        mid = n // 2\\n        for i in range(n - 1):\\n            if s[i] != s[i + 1]:\\n                if i + 1 <= mid:\\n                    ans += i + 1\\n                else:\\n                    ans += n - (i+1)\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        mid = n // 2\\n        for i in range(n - 1):\\n            if s[i] != s[i + 1]:\\n                if i + 1 <= mid:\\n                    ans += i + 1\\n                else:\\n                    ans += n - (i+1)\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621112,
                "title": "c-super-easy-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i]!=s[i-1])\\n                {\\n                if(i<s.size()-i)\\n                    ans+=i;\\n                else\\n                    ans+=s.size()-i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i]!=s[i-1])\\n                {\\n                if(i<s.size()-i)\\n                    ans+=i;\\n                else\\n                    ans+=s.size()-i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619458,
                "title": "rust-python-linear-solution-with-detailed-explanation",
                "content": "# Intuition\\n\\nLets look at a restricted problem where we can do change only from one side. And lets also assume that we have an some array:\\n\\n```\\nx, x, x, x, ... X, \\n```\\n\\nfor which the answer is `n` (the values for `x` does not matter and they can be different or equal). Now lets add one more character to our array:\\n\\n```\\nx, x, x, x, ... X, Y\\n```\\n\\nif `Y == X` the answer will be the same as previous array was already changed to have all numbers equal. If they are not the same, you need to flip all the values before Y (doing only one flip as they all have equal values). And that flip will cost us `i`.\\n\\nSo we have the following dp:\\n`dp_lr[i] = dp_lr[i - 1] + (i if s[i - 1] != s[i] else 0)`\\n\\n----------------\\n\\nSo we know how to get results moving from Left to Right. We can do the same doing from Right to Left.\\n\\nAnd to get the resulting answer we can try every position and find the smallest values of `dp_lr[i] + dp_rl[i]`\\n\\n\\n\\n# Complexity\\n\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn minimum_cost(s: String) -> i64 {\\n    let n = s.len();\\n    let s = s.as_bytes();\\n    let mut dp = vec![0i64; n];\\n\\n    for i in 1 .. n {\\n      dp[i] = dp[i - 1];\\n      if s[i] != s[i - 1] {\\n        dp[i] += i as i64;\\n      }\\n    }\\n\\n    let (mut res, mut cnt) = (dp[n - 1] as i64, 0);\\n    for i in (0 .. n - 1).rev() {\\n      if s[i] != s[i + 1] {\\n        cnt += (n - i - 1) as i64;\\n      }\\n      res = res.min(dp[i] + cnt);\\n    }\\n    \\n    return res;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def minimumCost(self, s: str) -> int:\\n    dp, n = [0] * len(s), len(s)\\n    for i in range(1, n):\\n      dp[i] = dp[i - 1] + (i if s[i - 1] != s[i] else 0)\\n    \\n    res, cnt = dp[-1], 0\\n    for i in range(n - 2, -1, -1):\\n      cnt += n - 1 - i if s[i] != s[i + 1] else 0\\n      res = min(res, dp[i] + cnt)\\n\\n    return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```\\nx, x, x, x, ... X, \\n```\n```\\nx, x, x, x, ... X, Y\\n```\n```Rust []\\nimpl Solution {\\n  pub fn minimum_cost(s: String) -> i64 {\\n    let n = s.len();\\n    let s = s.as_bytes();\\n    let mut dp = vec![0i64; n];\\n\\n    for i in 1 .. n {\\n      dp[i] = dp[i - 1];\\n      if s[i] != s[i - 1] {\\n        dp[i] += i as i64;\\n      }\\n    }\\n\\n    let (mut res, mut cnt) = (dp[n - 1] as i64, 0);\\n    for i in (0 .. n - 1).rev() {\\n      if s[i] != s[i + 1] {\\n        cnt += (n - i - 1) as i64;\\n      }\\n      res = res.min(dp[i] + cnt);\\n    }\\n    \\n    return res;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def minimumCost(self, s: str) -> int:\\n    dp, n = [0] * len(s), len(s)\\n    for i in range(1, n):\\n      dp[i] = dp[i - 1] + (i if s[i - 1] != s[i] else 0)\\n    \\n    res, cnt = dp[-1], 0\\n    for i in range(n - 2, -1, -1):\\n      cnt += n - 1 - i if s[i] != s[i + 1] else 0\\n      res = min(res, dp[i] + cnt)\\n\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616040,
                "title": "python-2d-dp-greedy",
                "content": "Before solving this one. https://leetcode.com/problems/flip-string-to-monotone-increasing/ needs to be solved. **Similar greedy idea**.\\n\\n**DP**\\nThis feels like hard when you do it with DP :(\\n\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \"\"\"\\n        dp[v][i] - min cost to make all elements equal v [0...i]\\n        1) s[i] == \\'0\\': 00[0] to 000: -> cost(00) -> 000\\n        2) s[i] == \\'0\\': 11[0] to 111: -> cost(00) + invert(000) -> 111\\n        3) s[i] == \\'1\\': 11[1] to 111: -> cost(11) -> 111\\n        4) s[i] == \\'1\\': 00[1] to 000: -> cost(11) + invert(111) -> 000\\n        \"\"\"\\n        def fill(dp_0, dp_1, s):\\n            for i in range(N):\\n                if s[i] == \\'0\\':\\n                    dp_0[i] = dp_0[i - 1]\\n                    dp_1[i] = dp_0[i - 1] + i + 1\\n                else:\\n                    dp_0[i] = dp_1[i - 1] + i + 1\\n                    dp_1[i] = dp_1[i - 1]\\n\\n        N = len(s)\\n        l2r_dp_0, l2r_dp_1 = [0] * N, [0] * N,\\n        r2l_dp_0, r2l_dp_1, = [0] * (N + 1), [0] * (N + 1)\\n\\n        fill(l2r_dp_0, l2r_dp_1, s)\\n        fill(r2l_dp_0, r2l_dp_1, s[::-1])\\n       \\n        min_cost = float(inf)\\n        for i in range(N):\\n            min_cost = min(min_cost, l2r_dp_0[i] + r2l_dp_0[N - 1 - i])\\n            min_cost = min(min_cost, l2r_dp_1[i] + r2l_dp_1[N - 1 - i])\\n\\n        return min_cost\\n```\\n\\n**Greedy**\\nAt each position we check `s[i-1]` and `s[i]`.\\n`If s[i-1] != s[i]` we need to flip either `[0...i - 1]` or `[i...N]` to make `s[i-1] == s[i]`\\nWe pick minimum number of flips required to make `s[i-1] == s[i]`.\\n\\nDry run example:\\n\\n```\\n|010101\\nwe are good as just 1 element is equal to itself -> no flips needed\\n\\n0|10101\\n0!=1 we need to make a decision - flip left or right sides, which is cheaper?\\n\\nleft: flip 0->1 which costs 1, and make it 1|10101 <-- cheaper: cost <1>\\nor\\nright: flip 10101 which costs 5, and make it 0|01010\\n\\n11|0101\\n1!=0\\n\\nleft: flip 11->00 which costs 2, and make it 00|0101 <-- cheaper: cost <2>\\nor\\nright: flip 0101 which costs 4, and make it 11|1010\\n\\n000|101\\n0!=1\\n\\nleft: flip 000->111 which costs 3, and make it 111|101 <-- cheaper: cost <3>, let\\'g go with this one\\nor\\nright: flip 101 which costs 3, and make it 000|010 <-- cheaper: cost <3>\\n\\n1111|01\\n1!=0\\n\\nleft: flip 1111->0000 which costs 4, and make it 0000|01\\nor\\nright: flip 01 which costs 2, and make it 1111|10 <-- cheaper: cost <2>\\n\\n11111|0\\n0!=1\\n\\nleft: flip 11111->00000 which costs 5, and make it 00000|0\\nor\\nright: flip 0 which costs 1, and make it 11111|1 <-- cheaper: cost <1>\\n\\nTotal cost: 1 + 2 + 3 + 2 + 1 = 9\\n```\\n\\nSource code:\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        N = len(s)\\n        cost = 0\\n        for i in range(N):\\n            if i and s[i - 1] != s[i]:\\n                cost += min(i, N - i)\\n        return cost\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \"\"\"\\n        dp[v][i] - min cost to make all elements equal v [0...i]\\n        1) s[i] == \\'0\\': 00[0] to 000: -> cost(00) -> 000\\n        2) s[i] == \\'0\\': 11[0] to 111: -> cost(00) + invert(000) -> 111\\n        3) s[i] == \\'1\\': 11[1] to 111: -> cost(11) -> 111\\n        4) s[i] == \\'1\\': 00[1] to 000: -> cost(11) + invert(111) -> 000\\n        \"\"\"\\n        def fill(dp_0, dp_1, s):\\n            for i in range(N):\\n                if s[i] == \\'0\\':\\n                    dp_0[i] = dp_0[i - 1]\\n                    dp_1[i] = dp_0[i - 1] + i + 1\\n                else:\\n                    dp_0[i] = dp_1[i - 1] + i + 1\\n                    dp_1[i] = dp_1[i - 1]\\n\\n        N = len(s)\\n        l2r_dp_0, l2r_dp_1 = [0] * N, [0] * N,\\n        r2l_dp_0, r2l_dp_1, = [0] * (N + 1), [0] * (N + 1)\\n\\n        fill(l2r_dp_0, l2r_dp_1, s)\\n        fill(r2l_dp_0, r2l_dp_1, s[::-1])\\n       \\n        min_cost = float(inf)\\n        for i in range(N):\\n            min_cost = min(min_cost, l2r_dp_0[i] + r2l_dp_0[N - 1 - i])\\n            min_cost = min(min_cost, l2r_dp_1[i] + r2l_dp_1[N - 1 - i])\\n\\n        return min_cost\\n```\n```\\n|010101\\nwe are good as just 1 element is equal to itself -> no flips needed\\n\\n0|10101\\n0!=1 we need to make a decision - flip left or right sides, which is cheaper?\\n\\nleft: flip 0->1 which costs 1, and make it 1|10101 <-- cheaper: cost <1>\\nor\\nright: flip 10101 which costs 5, and make it 0|01010\\n\\n11|0101\\n1!=0\\n\\nleft: flip 11->00 which costs 2, and make it 00|0101 <-- cheaper: cost <2>\\nor\\nright: flip 0101 which costs 4, and make it 11|1010\\n\\n000|101\\n0!=1\\n\\nleft: flip 000->111 which costs 3, and make it 111|101 <-- cheaper: cost <3>, let\\'g go with this one\\nor\\nright: flip 101 which costs 3, and make it 000|010 <-- cheaper: cost <3>\\n\\n1111|01\\n1!=0\\n\\nleft: flip 1111->0000 which costs 4, and make it 0000|01\\nor\\nright: flip 01 which costs 2, and make it 1111|10 <-- cheaper: cost <2>\\n\\n11111|0\\n0!=1\\n\\nleft: flip 11111->00000 which costs 5, and make it 00000|0\\nor\\nright: flip 0 which costs 1, and make it 11111|1 <-- cheaper: cost <1>\\n\\nTotal cost: 1 + 2 + 3 + 2 + 1 = 9\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        N = len(s)\\n        cost = 0\\n        for i in range(N):\\n            if i and s[i - 1] != s[i]:\\n                cost += min(i, N - i)\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612711,
                "title": "sweeeeeeeeeet-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int l = 1, r = s.length()-1;\\n        int p = 0, n = 1;\\n        long long count = 0;\\n        while(n != s.length()){\\n\\n            if(s[p] != s[n]){\\n                if(l <= r){\\n                    count += l;\\n                }\\n                else {\\n                    count += r;\\n                }\\n            }\\n            l++; r--; p++; n++;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int l = 1, r = s.length()-1;\\n        int p = 0, n = 1;\\n        long long count = 0;\\n        while(n != s.length()){\\n\\n            if(s[p] != s[n]){\\n                if(l <= r){\\n                    count += l;\\n                }\\n                else {\\n                    count += r;\\n                }\\n            }\\n            l++; r--; p++; n++;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609343,
                "title": "python-easy-to-understand-solution-prefix-sum",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \\n        # going left to right\\n        cost = 0\\n        prev = \\'\\'\\n        ans = float(\\'inf\\')\\n        prefix = []\\n        for i in range(len(s)):\\n            if not prev:\\n                prev = s[i]\\n                prefix.append((cost, s[i]))\\n                continue\\n            if prev != s[i]:\\n                cost += i \\n                prev = s[i]\\n            prefix.append((cost, s[i]))\\n        \\n        # going right to left\\n        \\n        s = s[::-1]\\n        cost = 0\\n        prev = \\'\\'\\n        suffix = []\\n        for i in range(len(s)):\\n            if not prev:\\n                prev = s[i]\\n                suffix.append((cost, s[i]))\\n                continue\\n            if prev != s[i]:\\n                cost += i \\n                prev = s[i]\\n            suffix.append((cost, s[i]))\\n                \\n        suffix = suffix[::-1]\\n        \\n        for i in range(len(prefix)):\\n            if prefix[i][1] == suffix[i][1]:\\n                ans = min(ans, prefix[i][0] + suffix[i][0])\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \\n        # going left to right\\n        cost = 0\\n        prev = \\'\\'\\n        ans = float(\\'inf\\')\\n        prefix = []\\n        for i in range(len(s)):\\n            if not prev:\\n                prev = s[i]\\n                prefix.append((cost, s[i]))\\n                continue\\n            if prev != s[i]:\\n                cost += i \\n                prev = s[i]\\n            prefix.append((cost, s[i]))\\n        \\n        # going right to left\\n        \\n        s = s[::-1]\\n        cost = 0\\n        prev = \\'\\'\\n        suffix = []\\n        for i in range(len(s)):\\n            if not prev:\\n                prev = s[i]\\n                suffix.append((cost, s[i]))\\n                continue\\n            if prev != s[i]:\\n                cost += i \\n                prev = s[i]\\n            suffix.append((cost, s[i]))\\n                \\n        suffix = suffix[::-1]\\n        \\n        for i in range(len(prefix)):\\n            if prefix[i][1] == suffix[i][1]:\\n                ans = min(ans, prefix[i][0] + suffix[i][0])\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605501,
                "title": "c-dynamic-programming-prefix-and-suffix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int sz = s.size();\\n        vector<vector<long long>> prefixDp(s.size()+1,{0,0});\\n        for(int i=1;i<=sz;i++){\\n            if (s[i-1]==\\'0\\'){\\n                prefixDp[i][0]=min(prefixDp[i-1][0],prefixDp[i-1][1]+i-1);\\n                prefixDp[i][1]=min(prefixDp[i-1][0]+i,prefixDp[i-1][1]+i+i-1);\\n            }\\n            else{\\n                prefixDp[i][1]=min(prefixDp[i-1][1],prefixDp[i-1][0]+i-1);\\n                prefixDp[i][0]=min(prefixDp[i-1][1]+i,prefixDp[i-1][0]+i+i-1);\\n            }\\n        }\\n        \\n        \\n        vector<vector<long long>> suffixDp(s.size()+1,{0,0});\\n        for(int i=sz-1;i>=0;i--){\\n            if (s[i]==\\'0\\'){\\n                suffixDp[i][0]=min(suffixDp[i+1][0],suffixDp[i+1][1]+sz-(i+1));\\n                suffixDp[i][1]=min(suffixDp[i+1][0]+sz-i,suffixDp[i+1][1]+sz-(i+1)+sz-i);\\n            }\\n            else{\\n                suffixDp[i][1]=min(suffixDp[i+1][1],suffixDp[i+1][0]+sz-(i+1));\\n                suffixDp[i][0]=min(suffixDp[i+1][1]+sz-i,suffixDp[i+1][0]+sz-(i+1)+sz-i);\\n            }\\n        }\\n        long long ans =1LL*sz*sz;\\n        for(int i=0;i<=sz;i++){\\n            //cout << \"i:\" << i << \" prefix0: \"<< prefixDp[i][0] << \" prefix1: \"<< prefixDp[i][1] << \" suffix0: \"<< suffixDp[i][0] << \" suffix1: \"<< suffixDp[i][1] << endl;\\n            ans = min(ans,min(prefixDp[i][0]+suffixDp[i][0],prefixDp[i][1]+suffixDp[i][1]));\\n            ans = min(ans,prefixDp[i][0]+suffixDp[i][1]+i);\\n            ans = min(ans,prefixDp[i][0]+suffixDp[i][1]+sz-i);\\n            ans = min(ans,prefixDp[i][1]+suffixDp[i][0]+i);\\n            ans = min(ans,prefixDp[i][1]+suffixDp[i][0]+sz-i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int sz = s.size();\\n        vector<vector<long long>> prefixDp(s.size()+1,{0,0});\\n        for(int i=1;i<=sz;i++){\\n            if (s[i-1]==\\'0\\'){\\n                prefixDp[i][0]=min(prefixDp[i-1][0],prefixDp[i-1][1]+i-1);\\n                prefixDp[i][1]=min(prefixDp[i-1][0]+i,prefixDp[i-1][1]+i+i-1);\\n            }\\n            else{\\n                prefixDp[i][1]=min(prefixDp[i-1][1],prefixDp[i-1][0]+i-1);\\n                prefixDp[i][0]=min(prefixDp[i-1][1]+i,prefixDp[i-1][0]+i+i-1);\\n            }\\n        }\\n        \\n        \\n        vector<vector<long long>> suffixDp(s.size()+1,{0,0});\\n        for(int i=sz-1;i>=0;i--){\\n            if (s[i]==\\'0\\'){\\n                suffixDp[i][0]=min(suffixDp[i+1][0],suffixDp[i+1][1]+sz-(i+1));\\n                suffixDp[i][1]=min(suffixDp[i+1][0]+sz-i,suffixDp[i+1][1]+sz-(i+1)+sz-i);\\n            }\\n            else{\\n                suffixDp[i][1]=min(suffixDp[i+1][1],suffixDp[i+1][0]+sz-(i+1));\\n                suffixDp[i][0]=min(suffixDp[i+1][1]+sz-i,suffixDp[i+1][0]+sz-(i+1)+sz-i);\\n            }\\n        }\\n        long long ans =1LL*sz*sz;\\n        for(int i=0;i<=sz;i++){\\n            //cout << \"i:\" << i << \" prefix0: \"<< prefixDp[i][0] << \" prefix1: \"<< prefixDp[i][1] << \" suffix0: \"<< suffixDp[i][0] << \" suffix1: \"<< suffixDp[i][1] << endl;\\n            ans = min(ans,min(prefixDp[i][0]+suffixDp[i][0],prefixDp[i][1]+suffixDp[i][1]));\\n            ans = min(ans,prefixDp[i][0]+suffixDp[i][1]+i);\\n            ans = min(ans,prefixDp[i][0]+suffixDp[i][1]+sz-i);\\n            ans = min(ans,prefixDp[i][1]+suffixDp[i][0]+i);\\n            ans = min(ans,prefixDp[i][1]+suffixDp[i][0]+sz-i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3605379,
                "title": "c-python-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question goal is to minimize the cost , it can be done by using **Greedy Algorithm , Dynamic Programming , Divide and Conquer** etc.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Greedy Approach , Iterating over different pair `01` or `10` and finding minimum cost `cost += min(index,n-index)`.\\n```\\nif (string[index]!=string[index+1]){\\n    cost += min(index+1,n-(index+1));\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long  ans = 0;\\n        int n = s.size();\\n        for (int i=0;i<n-1;i++){\\n            if (s[i]!=s[i+1]){\\n                ans += min( i+1 ,n-i-1);\\n            } \\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n            ans =0\\n            n=len(s)\\n            for i in range(n-1):\\n                if (s[i]!=s[i+1]):\\n                    ans+=min(n-i-1,i+1)\\n            return ans\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nif (string[index]!=string[index+1]){\\n    cost += min(index+1,n-(index+1));\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long  ans = 0;\\n        int n = s.size();\\n        for (int i=0;i<n-1;i++){\\n            if (s[i]!=s[i+1]){\\n                ans += min( i+1 ,n-i-1);\\n            } \\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n            ans =0\\n            n=len(s)\\n            for i in range(n-1):\\n                if (s[i]!=s[i+1]):\\n                    ans+=min(n-i-1,i+1)\\n            return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604007,
                "title": "no-dp-involved",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntraverse through the array and if the ith and next element does not match than there exists 2 cases:\\n1) cost from starting is less than add i+1\\n2) cost from ending is less than add n-i-1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s){\\n        long ans = 0;\\n        int n = s.length();\\n        for (int i = 0; i < s.length() - 1; ++i)\\n        {\\n            if (s.charAt(i) != s.charAt(i + 1))\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s){\\n        long ans = 0;\\n        int n = s.length();\\n        for (int i = 0; i < s.length() - 1; ++i)\\n        {\\n            if (s.charAt(i) != s.charAt(i + 1))\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591086,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) to avoid TLE, we can preprocess the input to reduce the asymptotic bounds of considering all optimal possibilities.  Similar to Kadane\\'s algorithm, we can track the \"best ending/beginning here\" for each `k`<sup>th</sup> ending/beginning value from `0..1` inclusive at each `i`<sup>th</sup> prefix index and each `j`<sup>th</sup> suffix index of the input string `s` formulated from left-to-right and right-to-left as `L` and `R` correspondingly, then we perform a linear scan to consider the cost of each `i`<sup>th</sup> prefix/suffix index candidate as `L[i][k] + R[i][k]` ending/beginning in the value `k = 0..1` inclusive.\\n\\n**\\uD83D\\uDC49 Prefix \\uD83E\\uDD14 Recurrence Relation Details:** For each `k`<sup>th</sup> ending value from `k = 0..1` inclusive, there are two possibilities to consider each each `i`<sup>th</sup> prefix:\\n\\n* **\\uD83D\\uDEAB Case 1:** if `s[i] == k`, then there is **no additional cost** since we do *not* need to flip this bit.  Thus, we set the `i`<sup>th</sup> cost to the previous `i - 1`<sup>th</sup> cost.\\n    * if `s[i] == k` then `L[i][k] = L[i - 1][k]`\\n\\n* **\\u2705 Case 2:** if `s[i] != k`, then the **additional cost** is `i + 1`, ie. the cost to flip the current `i`<sup>th</sup> bit to ending value `k` *plus* the cost of flipping the previous `i - 1`<sup>th</sup> prefix to the *opposite* value of `k`.\\n    * if `s[i] != k` then `L[i][k] = L[i - 1][k ^ 1]`\\n\\n**\\uD83D\\uDC48 Suffix \\uD83E\\uDD14 Recurrence Relation Details:** For each `k`<sup>th</sup> beginning value from `k = 0..1` inclusive, there are two possibilities to consider each each `j`<sup>th</sup> suffix:\\n\\n* **\\uD83D\\uDEAB Case 1:** if `s[j] == k`, then there is **no additional cost** since we do *not* need to flip this bit.  Thus, we set the `j`<sup>th</sup> cost to the previous `j + 1`<sup>th</sup> cost.\\n    * if `s[j] == k` then `R[j][k] = R[j + 1][k]`\\n\\n* **\\u2705 Case 2:** if `s[j] != k`, then the **additional cost** is `N - j`, ie. the cost to flip the current `j`<sup>th</sup> bit to beginning value `k` *plus* the cost of flipping the previous `j + 1`<sup>th</sup> suffix to the *opposite* value of `k`.\\n    * if `s[j] != k` then `R[j][k] = R[j + 1][k ^ 1]`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumCost(s: String): Long {\\n        var A = s.toCharArray().map{ if (it == \\'0\\') 0 else 1 }\\n        var N = s.length\\n        var L = Array(N){ LongArray(2) }\\n        var R = Array(N){ LongArray(2) }\\n        for (i in 0 until N) {\\n            var j = N - 1 - i\\n            for (k in 0..1) {\\n                L[i][k] = if (A[i] == k) { if (0 <= i - 1) L[i - 1][k] else 0 } else { i + 1 + if (0 <= i - 1) L[i - 1][k xor 1] else 0 }\\n                R[j][k] = if (A[j] == k) { if (j + 1 < N) R[j + 1][k] else 0 } else { N - j + if (j + 1 < N) R[j + 1][k xor 1] else 0 }\\n            }\\n        }\\n        return (0 until N).map{ i -> (0..1).map{ k -> L[i][k] + R[i][k] } }.flatten().min()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumCost = (s, N = s.length, L = [...Array(N)].map(_ => Array(2).fill(0)), R = [...Array(N)].map(_ => Array(2).fill(0))) => {\\n    for (let i = 0; i < N; ++i) {\\n        let j = N - 1 - i;\\n        for (let k = 0; k < 2; ++k) {\\n            L[i][k] = Number(s[i]) == k ? (0 <= i - 1 ? L[i - 1][k] : 0) : (i + 1 + (0 <= i - 1 ? L[i - 1][k ^ 1] : 0));\\n            R[j][k] = Number(s[j]) == k ? (j + 1 < N ? R[j + 1][k] : 0) : (N - j + (j + 1 < N ? R[j + 1][k ^ 1] : 0));\\n        }\\n    }\\n    return Math.min(..._.flatten(_.range(0, N).map(i => _.range(0, 2).map(k => L[i][k] + R[i][k]))));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        N = len(s)\\n        L = [[0] * 2 for _ in range(N)]\\n        R = [[0] * 2 for _ in range(N)]\\n        for i in range(N):\\n            j = N - i - 1\\n            for k in range(2):\\n                L[i][k] = (L[i - 1][k] if 0 <= i - 1 else 0) if int(s[i]) == k else (i + 1) + (L[i - 1][k ^ 1] if 0 <= i - 1 else 0)\\n                R[j][k] = (R[j + 1][k] if j + 1 < N else 0) if int(s[j]) == k else (N - j) + (R[j + 1][k ^ 1] if j + 1 < N else 0)\\n        return min(L[i][k] + R[i][k] for k in range(2) for i in range(N))\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_cost(s: String) -> i64 {\\n        let A = s.chars().map(|c| if c == \\'0\\' { 0 } else { 1 }).collect::<Vec<usize>>();\\n        let N = A.len();\\n        let (mut L, mut R) = (vec![vec![0i64; 2]; N], vec![vec![0i64; 2]; N]);\\n        for i in 0..N {\\n            let j = N - 1 - i;\\n            for k in 0..=1 {\\n                L[i][k] = if A[i] == k { if 0 <= i as i32 - 1 { L[i - 1][k] } else { 0 } } else { (i + 1) as i64 + if 0 <= i as i32 - 1 { L[i - 1][k ^ 1] } else { 0 } };\\n                R[j][k] = if A[j] == k { if j + 1 < N { R[j + 1][k] } else { 0 } } else { (N - j) as i64 + if j + 1 < N { R[j + 1][k ^ 1] } else { 0 } };\\n            }\\n        }\\n        let mut best = (1e5 * 1e5) as i64;\\n        for i in 0..N {\\n            for k in 0..=1 {\\n                best = min(best, L[i][k] + R[i][k]);\\n            }\\n        }\\n        best\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VVL = vector<VL>;\\n    LL minimumCost(string s, LL best = LL(1e5) * LL(1e5)) {\\n        int N = s.size();\\n        VVL L(N, VL(2)),\\n            R(N, VL(2));\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto j = N - 1 - i;\\n            for (auto k{ 0 }; k < 2; ++k) {\\n                L[i][k] = s[i] - \\'0\\' == k ? (0 <= i - 1 ? L[i - 1][k] : 0) : (i + 1 + (0 <= i - 1 ? L[i - 1][k ^ 1] : 0));\\n                R[j][k] = s[j] - \\'0\\' == k ? (j + 1 < N ? R[j + 1][k] : 0) : (N - j + (j + 1 < N ? R[j + 1][k ^ 1] : 0));\\n            }\\n        }\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto k{ 0 }; k < 2; ++k)\\n                best = min(best, L[i][k] + R[i][k]);\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumCost(s: String): Long {\\n        var A = s.toCharArray().map{ if (it == \\'0\\') 0 else 1 }\\n        var N = s.length\\n        var L = Array(N){ LongArray(2) }\\n        var R = Array(N){ LongArray(2) }\\n        for (i in 0 until N) {\\n            var j = N - 1 - i\\n            for (k in 0..1) {\\n                L[i][k] = if (A[i] == k) { if (0 <= i - 1) L[i - 1][k] else 0 } else { i + 1 + if (0 <= i - 1) L[i - 1][k xor 1] else 0 }\\n                R[j][k] = if (A[j] == k) { if (j + 1 < N) R[j + 1][k] else 0 } else { N - j + if (j + 1 < N) R[j + 1][k xor 1] else 0 }\\n            }\\n        }\\n        return (0 until N).map{ i -> (0..1).map{ k -> L[i][k] + R[i][k] } }.flatten().min()!!\\n    }\\n}\\n```\n```\\nlet minimumCost = (s, N = s.length, L = [...Array(N)].map(_ => Array(2).fill(0)), R = [...Array(N)].map(_ => Array(2).fill(0))) => {\\n    for (let i = 0; i < N; ++i) {\\n        let j = N - 1 - i;\\n        for (let k = 0; k < 2; ++k) {\\n            L[i][k] = Number(s[i]) == k ? (0 <= i - 1 ? L[i - 1][k] : 0) : (i + 1 + (0 <= i - 1 ? L[i - 1][k ^ 1] : 0));\\n            R[j][k] = Number(s[j]) == k ? (j + 1 < N ? R[j + 1][k] : 0) : (N - j + (j + 1 < N ? R[j + 1][k ^ 1] : 0));\\n        }\\n    }\\n    return Math.min(..._.flatten(_.range(0, N).map(i => _.range(0, 2).map(k => L[i][k] + R[i][k]))));\\n};\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        N = len(s)\\n        L = [[0] * 2 for _ in range(N)]\\n        R = [[0] * 2 for _ in range(N)]\\n        for i in range(N):\\n            j = N - i - 1\\n            for k in range(2):\\n                L[i][k] = (L[i - 1][k] if 0 <= i - 1 else 0) if int(s[i]) == k else (i + 1) + (L[i - 1][k ^ 1] if 0 <= i - 1 else 0)\\n                R[j][k] = (R[j + 1][k] if j + 1 < N else 0) if int(s[j]) == k else (N - j) + (R[j + 1][k ^ 1] if j + 1 < N else 0)\\n        return min(L[i][k] + R[i][k] for k in range(2) for i in range(N))\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_cost(s: String) -> i64 {\\n        let A = s.chars().map(|c| if c == \\'0\\' { 0 } else { 1 }).collect::<Vec<usize>>();\\n        let N = A.len();\\n        let (mut L, mut R) = (vec![vec![0i64; 2]; N], vec![vec![0i64; 2]; N]);\\n        for i in 0..N {\\n            let j = N - 1 - i;\\n            for k in 0..=1 {\\n                L[i][k] = if A[i] == k { if 0 <= i as i32 - 1 { L[i - 1][k] } else { 0 } } else { (i + 1) as i64 + if 0 <= i as i32 - 1 { L[i - 1][k ^ 1] } else { 0 } };\\n                R[j][k] = if A[j] == k { if j + 1 < N { R[j + 1][k] } else { 0 } } else { (N - j) as i64 + if j + 1 < N { R[j + 1][k ^ 1] } else { 0 } };\\n            }\\n        }\\n        let mut best = (1e5 * 1e5) as i64;\\n        for i in 0..N {\\n            for k in 0..=1 {\\n                best = min(best, L[i][k] + R[i][k]);\\n            }\\n        }\\n        best\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VVL = vector<VL>;\\n    LL minimumCost(string s, LL best = LL(1e5) * LL(1e5)) {\\n        int N = s.size();\\n        VVL L(N, VL(2)),\\n            R(N, VL(2));\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto j = N - 1 - i;\\n            for (auto k{ 0 }; k < 2; ++k) {\\n                L[i][k] = s[i] - \\'0\\' == k ? (0 <= i - 1 ? L[i - 1][k] : 0) : (i + 1 + (0 <= i - 1 ? L[i - 1][k ^ 1] : 0));\\n                R[j][k] = s[j] - \\'0\\' == k ? (j + 1 < N ? R[j + 1][k] : 0) : (N - j + (j + 1 < N ? R[j + 1][k ^ 1] : 0));\\n            }\\n        }\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto k{ 0 }; k < 2; ++k)\\n                best = min(best, L[i][k] + R[i][k]);\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591078,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def minimumCost(s: String): Long = {\\n    val n = s.length\\n    (1 until n).foldLeft(0L)((acc, i) =>{\\n      if(s.charAt(i) != s.charAt(i - 1)) acc + (i min n - i)\\n      else acc\\n    })\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def minimumCost(s: String): Long = {\\n    val n = s.length\\n    (1 until n).foldLeft(0L)((acc, i) =>{\\n      if(s.charAt(i) != s.charAt(i - 1)) acc + (i min n - i)\\n      else acc\\n    })\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3590137,
                "title": "rust",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefix sum dp \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_cost(s: String) -> i64 {\\n     \\n        //dp \\n        let s = s.chars().into_iter().collect::<Vec<char>>();\\n        \\n        let n = s.len();\\n        let mut dp1 = vec![vec![0i64; 2]; n];//minimum cost to convert 0 or 1 till 0..i \\n        let mut dp2 = vec![vec![0i64; 2]; n];//minimum cost to convert 0 or 1 till i from right\\n\\n        for i in 0..n{\\n            \\n            let one_cost = if s[i]==\\'1\\' {0} else {1};\\n            let zero_cost = 1-one_cost ; \\n            \\n            if i>0{\\n                if s[i]==\\'0\\'{\\n                    dp1[i][0] = dp1[i-1][0];\\n                }else{\\n                    dp1[i][0] = dp1[i-1][1]+ i as i64+1;\\n                }\\n                \\n                if s[i]==\\'1\\'{\\n                    dp1[i][1] = dp1[i-1][1];\\n                }else{\\n                    dp1[i][1] = dp1[i-1][0]+ i as i64+1;\\n                }\\n            }else{\\n                dp1[0][0] = zero_cost;\\n                dp1[0][1] = one_cost;\\n            }\\n        }\\n        \\n        println!(\"{:?}\", dp1);\\n        let mut ans: i64 =  dp1[n-1][0].min(dp1[n-1][1]);\\n        \\n        for i in (0..n).rev(){\\n            let one_cost = if s[i]==\\'1\\' {0} else {1};\\n            let zero_cost = 1-one_cost ; \\n            \\n            if i<n-1{\\n                if s[i]==\\'0\\'{\\n                    dp2[i][0] = dp2[i+1][0];\\n                }else{\\n                    dp2[i][0] = dp2[i+1][1]+ (n-i) as i64;\\n                }\\n                \\n                if s[i]==\\'1\\'{\\n                    dp2[i][1] = dp2[i+1][1];\\n                }else{\\n                    dp2[i][1] = dp2[i+1][0]+ (n-i) as i64;\\n                }\\n            }else{\\n                dp2[i][0] = zero_cost;\\n                dp2[i][1] = one_cost;\\n            }\\n            \\n        }\\n        \\n        ans = ans.min(dp2[0][0].min(dp2[0][1]));\\n        \\n        for i in 0..n{\\n            if i+1<n{\\n                ans = ans.min(dp1[i][0]+dp2[i+1][0]);\\n                ans = ans.min(dp1[i][1]+dp2[i+1][1]);\\n            }\\n        \\n        }\\n        ans\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_cost(s: String) -> i64 {\\n     \\n        //dp \\n        let s = s.chars().into_iter().collect::<Vec<char>>();\\n        \\n        let n = s.len();\\n        let mut dp1 = vec![vec![0i64; 2]; n];//minimum cost to convert 0 or 1 till 0..i \\n        let mut dp2 = vec![vec![0i64; 2]; n];//minimum cost to convert 0 or 1 till i from right\\n\\n        for i in 0..n{\\n            \\n            let one_cost = if s[i]==\\'1\\' {0} else {1};\\n            let zero_cost = 1-one_cost ; \\n            \\n            if i>0{\\n                if s[i]==\\'0\\'{\\n                    dp1[i][0] = dp1[i-1][0];\\n                }else{\\n                    dp1[i][0] = dp1[i-1][1]+ i as i64+1;\\n                }\\n                \\n                if s[i]==\\'1\\'{\\n                    dp1[i][1] = dp1[i-1][1];\\n                }else{\\n                    dp1[i][1] = dp1[i-1][0]+ i as i64+1;\\n                }\\n            }else{\\n                dp1[0][0] = zero_cost;\\n                dp1[0][1] = one_cost;\\n            }\\n        }\\n        \\n        println!(\"{:?}\", dp1);\\n        let mut ans: i64 =  dp1[n-1][0].min(dp1[n-1][1]);\\n        \\n        for i in (0..n).rev(){\\n            let one_cost = if s[i]==\\'1\\' {0} else {1};\\n            let zero_cost = 1-one_cost ; \\n            \\n            if i<n-1{\\n                if s[i]==\\'0\\'{\\n                    dp2[i][0] = dp2[i+1][0];\\n                }else{\\n                    dp2[i][0] = dp2[i+1][1]+ (n-i) as i64;\\n                }\\n                \\n                if s[i]==\\'1\\'{\\n                    dp2[i][1] = dp2[i+1][1];\\n                }else{\\n                    dp2[i][1] = dp2[i+1][0]+ (n-i) as i64;\\n                }\\n            }else{\\n                dp2[i][0] = zero_cost;\\n                dp2[i][1] = one_cost;\\n            }\\n            \\n        }\\n        \\n        ans = ans.min(dp2[0][0].min(dp2[0][1]));\\n        \\n        for i in 0..n{\\n            if i+1<n{\\n                ans = ans.min(dp1[i][0]+dp2[i+1][0]);\\n                ans = ans.min(dp1[i][1]+dp2[i+1][1]);\\n            }\\n        \\n        }\\n        ans\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589141,
                "title": "c-easy-to-understand-solution",
                "content": "# Please dont forget to UPVOTE\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            //please upvote while loop is executing;\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Please dont forget to UPVOTE",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            //please upvote while loop is executing;\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587803,
                "title": "python-just-check-the-cost-of-change-the-string-to-all-1s-and-to-all-0s",
                "content": "Since the final string can only be all 1s or all 0s, we can simply calculate the cost to change the string to all 1s and to all 0s. Finally, we return the minimum of the cost.\\n\\nAnother trick is doing the flip operations from the middle to both front and end side.\\n\\nsee the code for details:\\n\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        self.len_s = len(s)\\n        # starting from the middle and try to convert the string to 1s or 0s\\n        self.s = s\\n        self.pattern = [\\'0\\', \\'1\\']\\n        if self.len_s % 2:\\n            sidx = self.len_s // 2\\n            if s[sidx] == \\'0\\':\\n                cost0 = self.getCost(sidx - 1, True, 0) + self.getCost(sidx + 1, False , 0)\\n                cost1 = min(self.getCost(sidx, True, 1) + self.getCost(sidx + 1, False, 1), self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1))\\n            else:\\n                cost1 = self.getCost(sidx - 1, True, 1) + self.getCost(sidx + 1, False, 1)\\n                cost0 = min(self.getCost(sidx, True, 0) + self.getCost(sidx + 1, False, 0), self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1))\\n        else:\\n            sidx = self.len_s // 2\\n            cost0 = self.getCost(sidx - 1, True, 0) + self.getCost(sidx, False, 0)\\n            cost1 = self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1)\\n        return min(cost0, cost1)\\n    \\n        \\n    def getCost(self, idx, forward, pat):\\n        cost, curp_idx, cur_pat = 0, pat, self.pattern[pat]\\n        if forward:\\n            while idx >= 0:\\n                if self.s[idx] != cur_pat:\\n                    cost += idx + 1\\n                    curp_idx = (curp_idx + 1) % 2\\n                    cur_pat = self.pattern[curp_idx]\\n                idx -= 1\\n        else:\\n            while idx < self.len_s:\\n                if self.s[idx] != cur_pat:\\n                    cost += (self.len_s - idx)\\n                    curp_idx = (curp_idx + 1) % 2\\n                    cur_pat = self.pattern[curp_idx]\\n                idx += 1\\n        return cost\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        self.len_s = len(s)\\n        # starting from the middle and try to convert the string to 1s or 0s\\n        self.s = s\\n        self.pattern = [\\'0\\', \\'1\\']\\n        if self.len_s % 2:\\n            sidx = self.len_s // 2\\n            if s[sidx] == \\'0\\':\\n                cost0 = self.getCost(sidx - 1, True, 0) + self.getCost(sidx + 1, False , 0)\\n                cost1 = min(self.getCost(sidx, True, 1) + self.getCost(sidx + 1, False, 1), self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1))\\n            else:\\n                cost1 = self.getCost(sidx - 1, True, 1) + self.getCost(sidx + 1, False, 1)\\n                cost0 = min(self.getCost(sidx, True, 0) + self.getCost(sidx + 1, False, 0), self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1))\\n        else:\\n            sidx = self.len_s // 2\\n            cost0 = self.getCost(sidx - 1, True, 0) + self.getCost(sidx, False, 0)\\n            cost1 = self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1)\\n        return min(cost0, cost1)\\n    \\n        \\n    def getCost(self, idx, forward, pat):\\n        cost, curp_idx, cur_pat = 0, pat, self.pattern[pat]\\n        if forward:\\n            while idx >= 0:\\n                if self.s[idx] != cur_pat:\\n                    cost += idx + 1\\n                    curp_idx = (curp_idx + 1) % 2\\n                    cur_pat = self.pattern[curp_idx]\\n                idx -= 1\\n        else:\\n            while idx < self.len_s:\\n                if self.s[idx] != cur_pat:\\n                    cost += (self.len_s - idx)\\n                    curp_idx = (curp_idx + 1) % 2\\n                    cur_pat = self.pattern[curp_idx]\\n                idx += 1\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585342,
                "title": "simple-js-code-with-complete-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n  /** \\n    here what we are going to do is \\n    we are going to itrate through the string \\n    => and check if the value at ith postion is same as value at i-1th postion \\n\\n=> if they are not same we have to make it same \\n=> we can do two operations we can make value upto i-1 same as i or\\nwe can make values of i to n same as the value at i-1th index\\n\\n=>the cost of converting value from 0 to i is i+1 \\nso cost of converting value from o to i-1 is i+1-1==i;\\n\\nso we need to calculate cost as cost+= Math.min(i,s.length-i); \\n     */\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumCost = function(s) {\\n  \\n\\n    let cost = 0;\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]!=s[i-1]){\\n            cost+=Math.min(i,s.length-i);\\n        }\\n    }\\n    return cost;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumCost = function(s) {\\n  \\n\\n    let cost = 0;\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]!=s[i-1]){\\n            cost+=Math.min(i,s.length-i);\\n        }\\n    }\\n    return cost;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585268,
                "title": "a-sad-dp-cuz-my-analytical-skills-suck",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we flip bits, for a prefix only 2 types of strings are possible.\\nSo there is a scope for re-usability of subproblem solution (screaming DP!) [although later i found out a simple greedy exists ;-;]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet inv be the inverse of input string\\ns = \"010101\" => inv = \"101010\"\\n```\\ndp[i][0] = dp[i - 1][0] if s[i] == 0\\nelse\\ndp[i][0] = i + 1 + dp_inv[i - 1][0]\\n```\\nBecause if we flip a character, then entire prefix is flipped and hence we can use solution from the inversed prefix.\\n\\nDivide the strings into two half and for second half only perform suffix ops.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(2 * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        if (n == 1) return 0;\\n        string inv = \"\";\\n        for (int i = 0; i < n; i++) {\\n            inv += (s[i] == \\'0\\' ? \\'1\\' : \\'0\\');\\n        }\\n        // cout << inv << \"\\\\n\";\\n        vector<vector<long long>> cost(n , vector<long long>(2 , 0));\\n        vector<vector<long long>> cost_inv(n , vector<long long>(2 , 0));\\n        cost[0][0] = (s[0] != \\'0\\');\\n        cost[0][1] = (s[0] != \\'1\\');\\n        cost_inv[0][0] = (inv[0] != \\'0\\');\\n        cost_inv[0][1] = (inv[0] != \\'1\\');\\n        int half = (n - 1) / 2;\\n        // cout << half << \"\\\\n\";\\n        for (int i = 1; i <= half; i++) {\\n            if (s[i] == \\'0\\') {\\n                cost[i][0] = cost[i - 1][0];\\n                cost[i][1] = (i + 1) + cost_inv[i - 1][1];\\n                cost_inv[i][0] = (i + 1) + cost[i - 1][0];\\n                cost_inv[i][1] = cost_inv[i - 1][1];\\n            } else {\\n                cost[i][0] = (i + 1) + cost_inv[i - 1][0];\\n                cost[i][1] = cost[i - 1][1];\\n                cost_inv[i][0] = cost_inv[i - 1][0];\\n                cost_inv[i][1] = (i + 1) + cost[i - 1][1];\\n            } \\n        }\\n        cost[n - 1][0] = (s[n - 1] != \\'0\\');\\n        cost[n - 1][1] = (s[n - 1] != \\'1\\');\\n        cost_inv[n - 1][0] = (inv[n - 1] != \\'0\\');\\n        cost_inv[n - 1][1] = (inv[n - 1] != \\'1\\');\\n        for (int i = n - 2; i > half; i--) {\\n          if (s[i] == \\'0\\') {\\n                cost[i][0] = cost[i + 1][0];\\n                cost[i][1] = (n - i) + cost_inv[i + 1][1];\\n                cost_inv[i][0] = (n - i) + cost[i + 1][0];\\n                cost_inv[i][1] = cost_inv[i + 1][1];\\n            } else {\\n                cost[i][0] = (n - i) + cost_inv[i + 1][0];\\n                cost[i][1] = cost[i + 1][1];\\n                cost_inv[i][0] = cost_inv[i + 1][0];\\n                cost_inv[i][1] = (n - i) + cost[i + 1][1];\\n            }  \\n        }\\n        long long one = cost[half][1] + cost[half + 1][1];\\n        // cout << cost[half][1] << \" \" << cost[half + 1][1] << \"\\\\n\";\\n        long long zero = cost[half][0] + cost[half + 1][0];\\n        return min(one , zero);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][0] = dp[i - 1][0] if s[i] == 0\\nelse\\ndp[i][0] = i + 1 + dp_inv[i - 1][0]\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        if (n == 1) return 0;\\n        string inv = \"\";\\n        for (int i = 0; i < n; i++) {\\n            inv += (s[i] == \\'0\\' ? \\'1\\' : \\'0\\');\\n        }\\n        // cout << inv << \"\\\\n\";\\n        vector<vector<long long>> cost(n , vector<long long>(2 , 0));\\n        vector<vector<long long>> cost_inv(n , vector<long long>(2 , 0));\\n        cost[0][0] = (s[0] != \\'0\\');\\n        cost[0][1] = (s[0] != \\'1\\');\\n        cost_inv[0][0] = (inv[0] != \\'0\\');\\n        cost_inv[0][1] = (inv[0] != \\'1\\');\\n        int half = (n - 1) / 2;\\n        // cout << half << \"\\\\n\";\\n        for (int i = 1; i <= half; i++) {\\n            if (s[i] == \\'0\\') {\\n                cost[i][0] = cost[i - 1][0];\\n                cost[i][1] = (i + 1) + cost_inv[i - 1][1];\\n                cost_inv[i][0] = (i + 1) + cost[i - 1][0];\\n                cost_inv[i][1] = cost_inv[i - 1][1];\\n            } else {\\n                cost[i][0] = (i + 1) + cost_inv[i - 1][0];\\n                cost[i][1] = cost[i - 1][1];\\n                cost_inv[i][0] = cost_inv[i - 1][0];\\n                cost_inv[i][1] = (i + 1) + cost[i - 1][1];\\n            } \\n        }\\n        cost[n - 1][0] = (s[n - 1] != \\'0\\');\\n        cost[n - 1][1] = (s[n - 1] != \\'1\\');\\n        cost_inv[n - 1][0] = (inv[n - 1] != \\'0\\');\\n        cost_inv[n - 1][1] = (inv[n - 1] != \\'1\\');\\n        for (int i = n - 2; i > half; i--) {\\n          if (s[i] == \\'0\\') {\\n                cost[i][0] = cost[i + 1][0];\\n                cost[i][1] = (n - i) + cost_inv[i + 1][1];\\n                cost_inv[i][0] = (n - i) + cost[i + 1][0];\\n                cost_inv[i][1] = cost_inv[i + 1][1];\\n            } else {\\n                cost[i][0] = (n - i) + cost_inv[i + 1][0];\\n                cost[i][1] = cost[i + 1][1];\\n                cost_inv[i][0] = cost_inv[i + 1][0];\\n                cost_inv[i][1] = (n - i) + cost[i + 1][1];\\n            }  \\n        }\\n        long long one = cost[half][1] + cost[half + 1][1];\\n        // cout << cost[half][1] << \" \" << cost[half + 1][1] << \"\\\\n\";\\n        long long zero = cost[half][0] + cost[half + 1][0];\\n        return min(one , zero);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3584311,
                "title": "intuitive-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        \\n        string one = \"\";\\n        string zero = \"\";\\n\\n        for (int i = 0; i < n; i++) {\\n            one.push_back(\\'1\\');\\n            zero.push_back(\\'0\\');\\n        }\\n        \\n        if (s == one || s == zero) {\\n            return 0;\\n        }\\n\\n        vector<vector<long long>> pre(2, vector<long long>(n, 0));\\n        vector<vector<long long>> suf(2, vector<long long>(n, 0));\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                pre[0][i] = s[i] == \\'0\\' ? 0 : 1;\\n                pre[1][i] = s[i] == \\'1\\' ? 0 : 1;\\n            } else {\\n                pre[0][i] = s[i] == \\'0\\' ? pre[0][i - 1] : i + 1 + pre[1][i - 1];\\n                pre[1][i] = s[i] == \\'1\\' ? pre[1][i - 1] : i + 1 + pre[0][i - 1];\\n            }\\n\\n            int j = n - i - 1;\\n            if (j == n - 1) {\\n                suf[0][j] = s[j] == \\'0\\' ? 0 : 1;\\n                suf[1][j] = s[j] == \\'1\\' ? 0 : 1;\\n            } else {\\n                suf[0][j] = s[j] == \\'0\\' ? suf[0][j + 1] : n - j + suf[1][j + 1];\\n                suf[1][j] = s[j] == \\'1\\' ? suf[1][j + 1] : n - j + suf[0][j + 1];\\n            }\\n        }    \\n\\n        long long res = LLONG_MAX;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                res = min(res, suf[s[i] - \\'0\\'][i + 1]);\\n            } else if (i == n - 1) {\\n                res = min(res, pre[s[i] - \\'0\\'][i - 1]);\\n            } else {\\n                res = min(res, pre[s[i] - \\'0\\'][i - 1] + suf[s[i] - \\'0\\'][i + 1]);\\n            }\\n        }  \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        \\n        string one = \"\";\\n        string zero = \"\";\\n\\n        for (int i = 0; i < n; i++) {\\n            one.push_back(\\'1\\');\\n            zero.push_back(\\'0\\');\\n        }\\n        \\n        if (s == one || s == zero) {\\n            return 0;\\n        }\\n\\n        vector<vector<long long>> pre(2, vector<long long>(n, 0));\\n        vector<vector<long long>> suf(2, vector<long long>(n, 0));\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                pre[0][i] = s[i] == \\'0\\' ? 0 : 1;\\n                pre[1][i] = s[i] == \\'1\\' ? 0 : 1;\\n            } else {\\n                pre[0][i] = s[i] == \\'0\\' ? pre[0][i - 1] : i + 1 + pre[1][i - 1];\\n                pre[1][i] = s[i] == \\'1\\' ? pre[1][i - 1] : i + 1 + pre[0][i - 1];\\n            }\\n\\n            int j = n - i - 1;\\n            if (j == n - 1) {\\n                suf[0][j] = s[j] == \\'0\\' ? 0 : 1;\\n                suf[1][j] = s[j] == \\'1\\' ? 0 : 1;\\n            } else {\\n                suf[0][j] = s[j] == \\'0\\' ? suf[0][j + 1] : n - j + suf[1][j + 1];\\n                suf[1][j] = s[j] == \\'1\\' ? suf[1][j + 1] : n - j + suf[0][j + 1];\\n            }\\n        }    \\n\\n        long long res = LLONG_MAX;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                res = min(res, suf[s[i] - \\'0\\'][i + 1]);\\n            } else if (i == n - 1) {\\n                res = min(res, pre[s[i] - \\'0\\'][i - 1]);\\n            } else {\\n                res = min(res, pre[s[i] - \\'0\\'][i - 1] + suf[s[i] - \\'0\\'][i + 1]);\\n            }\\n        }  \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584287,
                "title": "c-prefix-sum-and-suffix-sum-initial-approach-to-optimization",
                "content": "\\n# 1) Initially thought \\n```\\nI initally thought to calculate for all indexes , \\nif we want to make all indexes from left to curr index 0 or 1 in prefsum,\\nand from right to curr index in suffsum.\\nand then finally calculate minimum by iteraing through 0-(n-1)\\n```\\n```\\n#define ll long long        \\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        vector<vector<ll>> prefsum(2,vector<ll>(n,0)),suffsum(2,vector<ll>(n,0));\\n\\n        if(s[0]==\\'1\\') prefsum[0][0]=1;\\n        else prefsum[1][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                prefsum[0][i]=prefsum[0][i-1];\\n                prefsum[1][i]=prefsum[0][i-1]+i+1;\\n            }\\n            else{\\n                prefsum[0][i]=prefsum[1][i-1]+i+1;\\n                prefsum[1][i]=prefsum[1][i-1];\\n            }\\n        }\\n\\n        if(s[n-1]==\\'1\\') suffsum[0][n-1]=1;\\n        else suffsum[1][n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                suffsum[0][i]=suffsum[0][i+1];\\n                suffsum[1][i]=suffsum[0][i+1]+n-i;\\n            }\\n            else{\\n                suffsum[0][i]=suffsum[1][i+1]+n-i;\\n                suffsum[1][i]=suffsum[1][i+1];\\n            }\\n        }\\n\\n        ll ans=1e15;\\n        ans=min(ans,min(prefsum[0][n-1],prefsum[1][n-1]));\\n        ans=min(ans,min(suffsum[0][0],suffsum[1][0]));\\n\\n        for(int i=0;i<n-1;i++){\\n            ans=min(ans,prefsum[0][i]+suffsum[0][i+1]);\\n            ans=min(ans,prefsum[1][i]+suffsum[1][i+1]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n```\\n2) optimised the previous code.\\nI just thought that why to calculate if we want to make all index 0 or 1,\\njust look upon the character of curr idx, and calculate to make every element to right and left equal to the curr idx .\\nstore for left-> curr in prefsum, and right->curr in suffsum\\nthen our final answer should be min(prefsum[i]+suffsum[i]) for all i.\\n```\\n```\\n#define ll long long  \\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        if(n==1) return 0;\\n        \\n        vector<ll> prefsum(n,0),suffsum(n,0);\\n        for(int i=1;i<n;i++){\\n            if(s[i]!=s[i-1]) prefsum[i]=prefsum[i-1]+i;\\n            else prefsum[i]=prefsum[i-1];\\n        }\\n\\n        ll ans=1e15;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]!=s[i+1]) suffsum[i]=suffsum[i+1]+(n-1-i);\\n            else suffsum[i]=suffsum[i+1];\\n\\n            ans=min(ans,prefsum[i]+suffsum[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nI initally thought to calculate for all indexes , \\nif we want to make all indexes from left to curr index 0 or 1 in prefsum,\\nand from right to curr index in suffsum.\\nand then finally calculate minimum by iteraing through 0-(n-1)\\n```\n```\\n#define ll long long        \\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        vector<vector<ll>> prefsum(2,vector<ll>(n,0)),suffsum(2,vector<ll>(n,0));\\n\\n        if(s[0]==\\'1\\') prefsum[0][0]=1;\\n        else prefsum[1][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                prefsum[0][i]=prefsum[0][i-1];\\n                prefsum[1][i]=prefsum[0][i-1]+i+1;\\n            }\\n            else{\\n                prefsum[0][i]=prefsum[1][i-1]+i+1;\\n                prefsum[1][i]=prefsum[1][i-1];\\n            }\\n        }\\n\\n        if(s[n-1]==\\'1\\') suffsum[0][n-1]=1;\\n        else suffsum[1][n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                suffsum[0][i]=suffsum[0][i+1];\\n                suffsum[1][i]=suffsum[0][i+1]+n-i;\\n            }\\n            else{\\n                suffsum[0][i]=suffsum[1][i+1]+n-i;\\n                suffsum[1][i]=suffsum[1][i+1];\\n            }\\n        }\\n\\n        ll ans=1e15;\\n        ans=min(ans,min(prefsum[0][n-1],prefsum[1][n-1]));\\n        ans=min(ans,min(suffsum[0][0],suffsum[1][0]));\\n\\n        for(int i=0;i<n-1;i++){\\n            ans=min(ans,prefsum[0][i]+suffsum[0][i+1]);\\n            ans=min(ans,prefsum[1][i]+suffsum[1][i+1]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\n2) optimised the previous code.\\nI just thought that why to calculate if we want to make all index 0 or 1,\\njust look upon the character of curr idx, and calculate to make every element to right and left equal to the curr idx .\\nstore for left-> curr in prefsum, and right->curr in suffsum\\nthen our final answer should be min(prefsum[i]+suffsum[i]) for all i.\\n```\n```\\n#define ll long long  \\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        if(n==1) return 0;\\n        \\n        vector<ll> prefsum(n,0),suffsum(n,0);\\n        for(int i=1;i<n;i++){\\n            if(s[i]!=s[i-1]) prefsum[i]=prefsum[i-1]+i;\\n            else prefsum[i]=prefsum[i-1];\\n        }\\n\\n        ll ans=1e15;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]!=s[i+1]) suffsum[i]=suffsum[i+1]+(n-1-i);\\n            else suffsum[i]=suffsum[i+1];\\n\\n            ans=min(ans,prefsum[i]+suffsum[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583014,
                "title": "ans",
                "content": "# APPROACH 1: \\n\\n**ALGO:**\\n\\n* basically hame saare char equal krne h\\n\\n* i=1 se shuru karo aur har s[i] ko s[i-1] se compare karo\\n\\n* agar ye dono equal h : to iska mtlb ye h ki index 0 se i tk sabhi elements equal h(kyuinki ye procedure ham shuru se krte aa rhe h)\\n\\n* aur agar unequal h to mtlb:\\n\\n\\t\\t\\t\\t\\t0 se i-1 tk to sab equal h because ye procedure ham shuru se krte aa rhe h\\n\\t\\t\\t\\t\\tbut index i-1 aur i pr values different h\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t=> ya to 0 se lekar i-1 tk inversion perform kr do taaki sab i k equal ho jae  (mtlb cost = i ko ans me add kr do)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t=> ya fir i se lekar n-1 tk inversion perform kr do taaki sab i-1 k equal ho jae  (mtlb cost = n-i ko ans me add kr do)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t=>in dono me se jo kam wali cost h us hisab se operation perform karo (GREEDY)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n**CODE :**\\n\\n```\\nlong long minimumCost(string s) {\\n        long long ans =0;\\n\\n        int n= s.length();\\n\\n        for(int i=1 ; i<n ; i++){\\n            if(s[i] != s[i-1]){\\n                ans += min(i,n-i);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n```\\n\\n# APPROACH 2\\n\\nham 2 vectors ka istemal krenge : one for calculating prefix sum and other for suffix sum\\n\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n\\n    \\n    long long minimumCost(string s) {\\n\\n        int n=s.length();\\n\\n\\n        vector<ll> prefix(n,0); \\n\\n        // prefix[i] : total cost if 0 se i-1 index tk same \\n        // char{jo ith index ka char h} krne h \\n        // ( first operation ka hi istemal kr skte h )\\n\\n        // isme left to right evaluate krenge\\n\\n        for(int i=1 ; i<n ; i++){\\n            if(s[i] == s[i-1]){\\n                prefix[i] =  prefix[i-1];\\n            }\\n            else{\\n                ll current_cost = i; // as inverting from 0 to i-1 index\\n                prefix[i] = prefix[i-1] + current_cost;\\n            }\\n        }\\n\\n\\n        vector<ll> suffix(n,0); \\n\\n        // suffix[i] : total cost if i+1 se n-i index tk same \\n        // char{jo ith index ka char h} krne h \\n        // ( first operation ka hi istemal kr skte h )\\n\\n        // isme right to left evaluate krenge\\n\\n\\n        for(int i=n-2 ; i>=0 ; i--){\\n            if(s[i] == s[i+1]){\\n                suffix[i] =  suffix[i+1];\\n            }\\n            else{\\n                ll current_cost = n-i-1; // as inverting from i+1 to n-1 index\\n                suffix[i] = suffix[i+1] + current_cost;\\n            }\\n        }\\n\\n\\n\\n        ll ans =LONG_LONG_MAX;\\n        ll res=suffix[0];\\n\\n        // ab har index pr jaenge ek ek krke\\n\\n        // for every i , hame left walo ko bhi s[i] k equal krna h aur right walo ko bhi\\n        // sabhi possibilities ka minimum hi hamara ans h\\n\\n        for(int i=0;i<n;i++){\\n\\n            ans = min( ans , prefix[i] + res );\\n\\n            if(i+1 < n){\\n                if( s[i] != s[i + 1] ){\\n                    res -= n-i-1;\\n                }\\n            }\\n        }\\n        \\n\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long minimumCost(string s) {\\n        long long ans =0;\\n\\n        int n= s.length();\\n\\n        for(int i=1 ; i<n ; i++){\\n            if(s[i] != s[i-1]){\\n                ans += min(i,n-i);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n```\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n\\n    \\n    long long minimumCost(string s) {\\n\\n        int n=s.length();\\n\\n\\n        vector<ll> prefix(n,0); \\n\\n        // prefix[i] : total cost if 0 se i-1 index tk same \\n        // char{jo ith index ka char h} krne h \\n        // ( first operation ka hi istemal kr skte h )\\n\\n        // isme left to right evaluate krenge\\n\\n        for(int i=1 ; i<n ; i++){\\n            if(s[i] == s[i-1]){\\n                prefix[i] =  prefix[i-1];\\n            }\\n            else{\\n                ll current_cost = i; // as inverting from 0 to i-1 index\\n                prefix[i] = prefix[i-1] + current_cost;\\n            }\\n        }\\n\\n\\n        vector<ll> suffix(n,0); \\n\\n        // suffix[i] : total cost if i+1 se n-i index tk same \\n        // char{jo ith index ka char h} krne h \\n        // ( first operation ka hi istemal kr skte h )\\n\\n        // isme right to left evaluate krenge\\n\\n\\n        for(int i=n-2 ; i>=0 ; i--){\\n            if(s[i] == s[i+1]){\\n                suffix[i] =  suffix[i+1];\\n            }\\n            else{\\n                ll current_cost = n-i-1; // as inverting from i+1 to n-1 index\\n                suffix[i] = suffix[i+1] + current_cost;\\n            }\\n        }\\n\\n\\n\\n        ll ans =LONG_LONG_MAX;\\n        ll res=suffix[0];\\n\\n        // ab har index pr jaenge ek ek krke\\n\\n        // for every i , hame left walo ko bhi s[i] k equal krna h aur right walo ko bhi\\n        // sabhi possibilities ka minimum hi hamara ans h\\n\\n        for(int i=0;i<n;i++){\\n\\n            ans = min( ans , prefix[i] + res );\\n\\n            if(i+1 < n){\\n                if( s[i] != s[i + 1] ){\\n                    res -= n-i-1;\\n                }\\n            }\\n        }\\n        \\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582996,
                "title": "very-easy-cpp-solution",
                "content": "# Intuition & Approach\\nWE traverse in the string if we find the opposite bit then we check which inverse will be mininum so that we choose that number of swaps to add to our ans\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n         long long ans = 0;\\n          int n=s.size();\\n       for(int i=1; i<n; i++){\\n           if(s[i]!=s[i-1])\\n           ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n         long long ans = 0;\\n          int n=s.size();\\n       for(int i=1; i<n; i++){\\n           if(s[i]!=s[i-1])\\n           ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582160,
                "title": "c-5-line-code-easy-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate string with for loop and at its every iteration check the next charcter of string.\\nIf they are not equal add the minimum value of cost of operation to convert them to equal characters.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n= s.length();\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s[i]!=s[i+1]){\\n                ans+=min(n-i-1, i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n= s.length();\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s[i]!=s[i+1]){\\n                ans+=min(n-i-1, i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582016,
                "title": "c-19-ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(const string& s)\\n    {\\n        if(s.size() < 2) return 0;\\n\\n        const int half = s.size()/2;\\n        long long cost = 0;\\n\\n        for(size_t i = 1; i <= half; ++i)\\n            if(s[i] != s[i - 1])\\n                cost += i;\\n\\n        for(size_t i = s.size() - 2; i >= half; --i)\\n            if(s[i] != s[i + 1])\\n                cost += s.size() - 1 - i;\\n\\n        return cost;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(const string& s)\\n    {\\n        if(s.size() < 2) return 0;\\n\\n        const int half = s.size()/2;\\n        long long cost = 0;\\n\\n        for(size_t i = 1; i <= half; ++i)\\n            if(s[i] != s[i - 1])\\n                cost += i;\\n\\n        for(size_t i = s.size() - 2; i >= half; --i)\\n            if(s[i] != s[i + 1])\\n                cost += s.size() - 1 - i;\\n\\n        return cost;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581301,
                "title": "python-simple-solution-with-video-explanation",
                "content": "# Video Explanation\\nWatch my full video explanation [here](https://www.youtube.com/watch?v=nnRiTbiCi8A):\\n\\nhttps://www.youtube.com/watch?v=nnRiTbiCi8A\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        n = len(s)\\n\\n        for i in range(1, n):\\n            if s[i] != s[i - 1]:\\n                cost += min(i, n - i)\\n\\n        return cost\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        n = len(s)\\n\\n        for i in range(1, n):\\n            if s[i] != s[i - 1]:\\n                cost += min(i, n - i)\\n\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580192,
                "title": "python-3-one-line-one-pass",
                "content": "# Intuition\\nIf any adjascent pairs don\\'t equal, you need to flip one without the other.\\n\\nFor each pair, you either have to do operation 1 or operation 2. Do the one that\\'s cheaper.\\n\\n# Approach\\nYou can either do it in two half-passes, or you can do it in one full pass and apply a minimum. I chose the latter approach because it\\'s easier to write in one line.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, one pass\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n  def minimumCost(self, s: str) -> int:\\n    return sum(min(i+1, len(s)-i-1) for i,(a,b) in enumerate(pairwise(s)) if a != b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def minimumCost(self, s: str) -> int:\\n    return sum(min(i+1, len(s)-i-1) for i,(a,b) in enumerate(pairwise(s)) if a != b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579259,
                "title": "shorter-recursive-resolusion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nShorter recursive resolusion\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing fliping target instead to fliping substring\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        int i = (n & 1) ? n / 2 : n / 2 - 1;\\n        long long min0, min1;\\n        min0 = calc(s, i-1, \\'0\\', -1)+calc(s, i, \\'0\\', 1);\\n        min1 = calc(s, i-1, \\'1\\', -1)+calc(s, i, \\'1\\', 1);\\n        return min(min0, min1);\\n    }\\n    \\n    long long calc(string &s, int i, char t, int dir) {\\n        int n = s.size();\\n        for(; i>=0 && i<n && s[i]==t; i+=dir);\\n        if(i<0 || i>=n) return 0;\\n        long long cost = (dir > 0)? n-i: i+1;\\n        cost += (t==\\'0\\')? calc(s, i+dir, \\'1\\', dir): calc(s, i+dir, \\'0\\', dir);\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        int i = (n & 1) ? n / 2 : n / 2 - 1;\\n        long long min0, min1;\\n        min0 = calc(s, i-1, \\'0\\', -1)+calc(s, i, \\'0\\', 1);\\n        min1 = calc(s, i-1, \\'1\\', -1)+calc(s, i, \\'1\\', 1);\\n        return min(min0, min1);\\n    }\\n    \\n    long long calc(string &s, int i, char t, int dir) {\\n        int n = s.size();\\n        for(; i>=0 && i<n && s[i]==t; i+=dir);\\n        if(i<0 || i>=n) return 0;\\n        long long cost = (dir > 0)? n-i: i+1;\\n        cost += (t==\\'0\\')? calc(s, i+dir, \\'1\\', dir): calc(s, i+dir, \\'0\\', dir);\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579101,
                "title": "simple-o-n-time-and-o-n-space-dp-approach",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll minimumCost(string s) {\\n        ll n=s.length();\\n        if(n==1)\\n            return 0;\\n        if(n==2){\\n            if(s[0]!=s[1])\\n                return 1;\\n            return 0;\\n        }\\n        vector<vector<vector<ll>>> dp(2,vector<vector<ll>>(3,vector<ll>(n,-1)));\\n        if(s[0]==\\'0\\'){\\n            dp[0][0][0]=0;\\n            dp[0][1][0]=1;\\n        }else{\\n            dp[0][0][0]=1;\\n            dp[0][1][0]=0;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                dp[0][0][i]=dp[0][0][i-1];\\n                dp[0][1][i]=dp[0][0][i-1]+i+1;\\n            }else{\\n                dp[0][1][i]=dp[0][1][i-1];\\n                dp[0][0][i]=dp[0][1][i-1]+i+1;\\n            }\\n        }\\n        if(s[n-1]==\\'0\\'){\\n            dp[1][0][n-1]=0;\\n            dp[1][1][n-1]=1;\\n        }else{\\n            dp[1][0][n-1]=1;\\n            dp[1][1][n-1]=0;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                dp[1][0][i]=dp[1][0][i+1];\\n                dp[1][1][i]=dp[1][0][i+1]+n-i;\\n            }else{\\n                dp[1][1][i]=dp[1][1][i+1];\\n                dp[1][0][i]=dp[1][1][i+1]+n-i;\\n            }\\n        }\\n        ll ans=min(dp[0][0][0]+dp[1][0][1],dp[0][1][0]+dp[1][1][1]);\\n        for(int i=1;i<n-1;i++)\\n            ans=min({ans,dp[0][0][i]+dp[1][0][i+1],dp[0][1][i]+dp[1][1][i+1]});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll minimumCost(string s) {\\n        ll n=s.length();\\n        if(n==1)\\n            return 0;\\n        if(n==2){\\n            if(s[0]!=s[1])\\n                return 1;\\n            return 0;\\n        }\\n        vector<vector<vector<ll>>> dp(2,vector<vector<ll>>(3,vector<ll>(n,-1)));\\n        if(s[0]==\\'0\\'){\\n            dp[0][0][0]=0;\\n            dp[0][1][0]=1;\\n        }else{\\n            dp[0][0][0]=1;\\n            dp[0][1][0]=0;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                dp[0][0][i]=dp[0][0][i-1];\\n                dp[0][1][i]=dp[0][0][i-1]+i+1;\\n            }else{\\n                dp[0][1][i]=dp[0][1][i-1];\\n                dp[0][0][i]=dp[0][1][i-1]+i+1;\\n            }\\n        }\\n        if(s[n-1]==\\'0\\'){\\n            dp[1][0][n-1]=0;\\n            dp[1][1][n-1]=1;\\n        }else{\\n            dp[1][0][n-1]=1;\\n            dp[1][1][n-1]=0;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                dp[1][0][i]=dp[1][0][i+1];\\n                dp[1][1][i]=dp[1][0][i+1]+n-i;\\n            }else{\\n                dp[1][1][i]=dp[1][1][i+1];\\n                dp[1][0][i]=dp[1][1][i+1]+n-i;\\n            }\\n        }\\n        ll ans=min(dp[0][0][0]+dp[1][0][1],dp[0][1][0]+dp[1][1][1]);\\n        for(int i=1;i<n-1;i++)\\n            ans=min({ans,dp[0][0][i]+dp[1][0][i+1],dp[0][1][i]+dp[1][1][i+1]});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578846,
                "title": "code-explanation-analysis-perfect-guide-for-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to minimize the cost so invert which half is small.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstart from 1st index in the string, is not equal to i-1 then check which half is small.\\n\\nif left half is small just add the cost to res \\n\\nelse right half is small we invert values in right and add cost to res\\n\\nNote:- loop is move in right side so, we need to maintain the invert string so, if flip is true it flip the i and i-1 values so we make sure we pick correct value in the string.\\n\\nDont need to over complete the fliping process we have only 2 values either 1 or 0 so dont think run extra loop and place the invert values in string then proceed further (it cause TLE as well this is brute force approach)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n\\n        boolean flip = false;\\n        long res = 0l, n = s.length();\\n        for(int i = 1; i<n; i++){\\n            char left = s.charAt(i-1);\\n            char curr = s.charAt(i);\\n            if(flip){\\n                if(left == \\'0\\') left = \\'1\\';\\n                else left = \\'0\\';\\n\\n                if(curr == \\'0\\') curr = \\'1\\';\\n                else curr = \\'0\\';\\n            }\\n\\n            if(left != curr)\\n            if(i <= n-i){\\n                res += i;\\n\\n            }\\n            else{\\n                res += (n-i);\\n                flip = !flip;\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n\\n        boolean flip = false;\\n        long res = 0l, n = s.length();\\n        for(int i = 1; i<n; i++){\\n            char left = s.charAt(i-1);\\n            char curr = s.charAt(i);\\n            if(flip){\\n                if(left == \\'0\\') left = \\'1\\';\\n                else left = \\'0\\';\\n\\n                if(curr == \\'0\\') curr = \\'1\\';\\n                else curr = \\'0\\';\\n            }\\n\\n            if(left != curr)\\n            if(i <= n-i){\\n                res += i;\\n\\n            }\\n            else{\\n                res += (n-i);\\n                flip = !flip;\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577401,
                "title": "two-approaches-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /*\\n    Observations:\\n    1. A nice property is, two strings of the same pattern need\\n       same cost to become equal, regardless of the real value.\\n       \"10\"\\n       \"01\" cost = 1\\n\\n       \"011\"\\n       \"100\" cost = 1\\n\\n       \"1001\"\\n       \"0110\" cost = 4\\n\\n       \"101010\"\\n       \"010101\" cost = 9\\n    2. It means if we flip s[0...i-1], the cost to make the flipped\\n       string become equal again is unchanged.\\n            \"00101\"\\n       cost  0025\\n\\n       i = 3, s[2] != s[3] so flip s[0...i-1] -> cost += 3\\n              now \"110\" also takes 2 cost to become \"000\"\\n\\n       So dp[i] = d[i - 1] + (s[i - 1] != s[i] ? i : 0)\\n    3. Another traversal from the back with same idea.\\n       candi = dp[i] + right\\n       ans = min(ans, candi)\\n\\n       O(n) space and time\\n    */\\n    long long minCost2(string s) {\\n        int n = s.size();\\n        // cost to make s[0...i] equal\\n        vector<long long> left(n);\\n        left[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            left[i] = left[i - 1] + (s[i] == s[i - 1] ? 0 : i);\\n        }\\n\\n        long long ans = left[n - 1], right = 0;\\n        for (int i = n - 2; i >= 0; i--) {\\n            right += s[i] == s[i + 1] ? 0 : n - 1 - i;\\n            ans = min(ans, left[i] + right);\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    long long minimumCost(string s) {\\n        return minCost2(s);\\n\\n        int n = s.size();\\n        vector<long long> remain1(n), flip1(n);\\n        int prev = -1;\\n        for (int i = 0; i < n; i++) {\\n            if ((i + 1 < n && s[i] != s[i + 1])) {\\n                remain1[i] = prev == -1 ? 0 : flip1[prev];\\n                flip1[i] = (prev == -1 ? 0 : flip1[prev]) + (i + 1);\\n                prev = i;\\n            }\\n        }\\n        \\n        if (prev == -1) {\\n            return 0;\\n        }\\n        \\n        vector<long long> remain2(n), flip2(n);\\n        prev = -1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if ((i - 1 >= 0 && s[i - 1] != s[i])) {\\n                remain2[i] = prev == -1 ? 0 : flip2[prev];\\n                flip2[i] = (prev == -1 ? 0 : flip2[prev]) + (n - i);\\n                prev = i;\\n            }\\n        }\\n        \\n        long long ans = 1LL * n * (n + 1) / 2;\\n        for (int i = 0; i < n; i++) {\\n            if (i + 1 < n && s[i] != s[i + 1]) {\\n                long long a = remain1[i] + flip2[i + 1];\\n                long long b = flip1[i] + remain2[i + 1];\\n                // std::cout << i << \" \" << a << \" \" << b << std::endl;\\n                ans = min(ans, min(a, b));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    Observations:\\n    1. A nice property is, two strings of the same pattern need\\n       same cost to become equal, regardless of the real value.\\n       \"10\"\\n       \"01\" cost = 1\\n\\n       \"011\"\\n       \"100\" cost = 1\\n\\n       \"1001\"\\n       \"0110\" cost = 4\\n\\n       \"101010\"\\n       \"010101\" cost = 9\\n    2. It means if we flip s[0...i-1], the cost to make the flipped\\n       string become equal again is unchanged.\\n            \"00101\"\\n       cost  0025\\n\\n       i = 3, s[2] != s[3] so flip s[0...i-1] -> cost += 3\\n              now \"110\" also takes 2 cost to become \"000\"\\n\\n       So dp[i] = d[i - 1] + (s[i - 1] != s[i] ? i : 0)\\n    3. Another traversal from the back with same idea.\\n       candi = dp[i] + right\\n       ans = min(ans, candi)\\n\\n       O(n) space and time\\n    */\\n    long long minCost2(string s) {\\n        int n = s.size();\\n        // cost to make s[0...i] equal\\n        vector<long long> left(n);\\n        left[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            left[i] = left[i - 1] + (s[i] == s[i - 1] ? 0 : i);\\n        }\\n\\n        long long ans = left[n - 1], right = 0;\\n        for (int i = n - 2; i >= 0; i--) {\\n            right += s[i] == s[i + 1] ? 0 : n - 1 - i;\\n            ans = min(ans, left[i] + right);\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    long long minimumCost(string s) {\\n        return minCost2(s);\\n\\n        int n = s.size();\\n        vector<long long> remain1(n), flip1(n);\\n        int prev = -1;\\n        for (int i = 0; i < n; i++) {\\n            if ((i + 1 < n && s[i] != s[i + 1])) {\\n                remain1[i] = prev == -1 ? 0 : flip1[prev];\\n                flip1[i] = (prev == -1 ? 0 : flip1[prev]) + (i + 1);\\n                prev = i;\\n            }\\n        }\\n        \\n        if (prev == -1) {\\n            return 0;\\n        }\\n        \\n        vector<long long> remain2(n), flip2(n);\\n        prev = -1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if ((i - 1 >= 0 && s[i - 1] != s[i])) {\\n                remain2[i] = prev == -1 ? 0 : flip2[prev];\\n                flip2[i] = (prev == -1 ? 0 : flip2[prev]) + (n - i);\\n                prev = i;\\n            }\\n        }\\n        \\n        long long ans = 1LL * n * (n + 1) / 2;\\n        for (int i = 0; i < n; i++) {\\n            if (i + 1 < n && s[i] != s[i + 1]) {\\n                long long a = remain1[i] + flip2[i + 1];\\n                long long b = flip1[i] + remain2[i + 1];\\n                // std::cout << i << \" \" << a << \" \" << b << std::endl;\\n                ans = min(ans, min(a, b));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3577167,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun minimumCost(s: String): Long {\\n        val n = s.length\\n        val h = n / 2\\n        val ca = s.toCharArray()\\n        var result = Long.MAX_VALUE\\n\\n        // to 1\\'s\\n        var m = 0L\\n        var inverse = false\\n        for (i in h downTo 0) {\\n            if (inverse) {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = false\\n                    m += i + 1\\n                }\\n            } else {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = true\\n                    m += i + 1\\n                }\\n            }\\n        }\\n\\n        inverse = false\\n        for (i in h + 1 until n) {\\n            if (inverse) {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = false\\n                    m += n - i\\n                }\\n            } else {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = true\\n                    m += n - i\\n                }\\n            }\\n        }\\n\\n        result = m\\n\\n        // to 0\\'s\\n        m = 0L\\n        inverse = false\\n\\n        for (i in h downTo 0) {\\n            if (inverse) {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = false\\n                    m += i + 1\\n                }\\n            } else {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = true\\n                    m += i + 1\\n                }\\n            }\\n        }\\n\\n        inverse = false\\n        for (i in h + 1 until n) {\\n            if (inverse) {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = false\\n                    m += n - i\\n                }\\n            } else {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = true\\n                    m += n - i\\n                }\\n            }\\n        }\\n\\n        result = Math.min(result, m)\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minimumCost(s: String): Long {\\n        val n = s.length\\n        val h = n / 2\\n        val ca = s.toCharArray()\\n        var result = Long.MAX_VALUE\\n\\n        // to 1\\'s\\n        var m = 0L\\n        var inverse = false\\n        for (i in h downTo 0) {\\n            if (inverse) {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = false\\n                    m += i + 1\\n                }\\n            } else {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = true\\n                    m += i + 1\\n                }\\n            }\\n        }\\n\\n        inverse = false\\n        for (i in h + 1 until n) {\\n            if (inverse) {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = false\\n                    m += n - i\\n                }\\n            } else {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = true\\n                    m += n - i\\n                }\\n            }\\n        }\\n\\n        result = m\\n\\n        // to 0\\'s\\n        m = 0L\\n        inverse = false\\n\\n        for (i in h downTo 0) {\\n            if (inverse) {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = false\\n                    m += i + 1\\n                }\\n            } else {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = true\\n                    m += i + 1\\n                }\\n            }\\n        }\\n\\n        inverse = false\\n        for (i in h + 1 until n) {\\n            if (inverse) {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = false\\n                    m += n - i\\n                }\\n            } else {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = true\\n                    m += n - i\\n                }\\n            }\\n        }\\n\\n        result = Math.min(result, m)\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577139,
                "title": "c-check-next",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=size(s);\\n        for(int i=0;i<n-1;++i)\\n            if(s[i]!=s[i+1])ans+=min(i+1,n-i-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=size(s);\\n        for(int i=0;i<n-1;++i)\\n            if(s[i]!=s[i+1])ans+=min(i+1,n-i-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576770,
                "title": "python-left-to-right-counts-and-right-to-left-counts",
                "content": "**Idea:**\\n - Create two arrays `Z = [0]` and `O = [0]`. \\n - For each charater in string if it\\'s the same as before for example it\\'s 0 then just copy to Z its previous element, if it\\'s different 1 then in Z goes O[-1] + i - 1.\\n - Do the same for reversed string\\n - minimize LeftZeros[i] + RightZeros[i] and  LeftOnes[i] + RightOnes[i]\\n\\n```python\\nclass Solution:\\n    def minimumCost(self, S: str) -> int:\\n        def count(s):\\n            Z = [0]\\n            O = [0]\\n            for i,l in enumerate(s):\\n                if l == \\'1\\':\\n                    O.append(O[-1])\\n                    Z.append(O[-1] + i + 1)\\n                else:\\n                    Z.append(Z[-1])\\n                    O.append(Z[-1] + i + 1)\\n                    \\n            return Z[1:],O[1:]\\n        \\n        LZ, LO = count(S)\\n        RZ, RO = count(S[::-1])\\n        ans = inf\\n        for x,y in zip(LZ,RZ[::-1]):\\n            ans = min(ans, x + y)\\n    \\n        for x,y in zip(LO,RO[::-1]):\\n            ans = min(ans, x + y)\\n            \\n        return ans\\n\\n```\\n\\nTime: `O(N)`\\nSpace: `O(N)`\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumCost(self, S: str) -> int:\\n        def count(s):\\n            Z = [0]\\n            O = [0]\\n            for i,l in enumerate(s):\\n                if l == \\'1\\':\\n                    O.append(O[-1])\\n                    Z.append(O[-1] + i + 1)\\n                else:\\n                    Z.append(Z[-1])\\n                    O.append(Z[-1] + i + 1)\\n                    \\n            return Z[1:],O[1:]\\n        \\n        LZ, LO = count(S)\\n        RZ, RO = count(S[::-1])\\n        ans = inf\\n        for x,y in zip(LZ,RZ[::-1]):\\n            ans = min(ans, x + y)\\n    \\n        for x,y in zip(LO,RO[::-1]):\\n            ans = min(ans, x + y)\\n            \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576667,
                "title": "c-greedy-solution-observe-the-change-in-bits",
                "content": "# Intuition\\nSum up the min cost for every change in bit.\\n\\n# Approach\\nFor the first half of the string, for every change in bit, we do first operation\\nFor the other half of the string, for every change in bit, we do second operation\\nAnd magic, the answer is found!!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=0;i<n/2;i++) {\\n            if(s[i]!=s[i+1]) {\\n                ans+=i+1;\\n            }\\n        }\\n        for(int i=n/2;i<n-1;i++) {\\n            if(s[i]!=s[i+1]) {\\n                ans+=n-i-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=0;i<n/2;i++) {\\n            if(s[i]!=s[i+1]) {\\n                ans+=i+1;\\n            }\\n        }\\n        for(int i=n/2;i<n-1;i++) {\\n            if(s[i]!=s[i+1]) {\\n                ans+=n-i-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576191,
                "title": "easy-begineer-friendly-java-code-o-n",
                "content": "# Intuition\\n  After standing on characters from index : 1 to n-1. Check the number of characters that are required to flip in the left portion and right portion. The portion in which less flips are required will be added to the ans.\\n\\n\\n# Complexity\\n  $$O(n)$$ \\n\\n# Space complexity:\\n  $$O(1)$$\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n\\n    public long minimumCost(String s) {\\n        \\n        long ans = 0;\\n        \\n        for (int i = 1 ; i < s.length () ; i++) {\\n            \\n            // Left main kitne flip karne hain aur right main kitne flip karne hain.\\n            // Inme se jo minimum flip lagengye unhe ans main add kardo.        \\n            if (s.charAt(i) != s.charAt(i-1)) {\\n                \\n                ans += Math.min (i , s.length() - i);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n\\n    public long minimumCost(String s) {\\n        \\n        long ans = 0;\\n        \\n        for (int i = 1 ; i < s.length () ; i++) {\\n            \\n            // Left main kitne flip karne hain aur right main kitne flip karne hain.\\n            // Inme se jo minimum flip lagengye unhe ans main add kardo.        \\n            if (s.charAt(i) != s.charAt(i-1)) {\\n                \\n                ans += Math.min (i , s.length() - i);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575822,
                "title": "only-5-lines-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans=0;\\n        int n=s.length();\\n        for(int i=0;i<n-1;i++)\\n            if(s.charAt(i)!=s.charAt(i+1))ans+=Math.min(i+1,n-i-1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans=0;\\n        int n=s.length();\\n        for(int i=0;i<n-1;i++)\\n            if(s.charAt(i)!=s.charAt(i+1))ans+=Math.min(i+1,n-i-1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575400,
                "title": "c-o-n-and-o-1-100-faster-at-time-of-my-submission-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        char tar=s[n/2];\\n        for(int i=n/2;i<n;)\\n        {\\n            while(i<n&&s[i]==tar) i++;\\n            ans+=(long long)(n-i);\\n            if(tar==\\'1\\') tar=\\'0\\';\\n            else tar=\\'1\\';\\n            while(i<n&&s[i]!=tar) i++;\\n        }\\n        tar=s[n/2];\\n        for(int i=n/2;i>=0;)\\n        {\\n            while(i>=0&&s[i]==tar) i--;\\n            ans+=(long long)(i+1);\\n            if(tar==\\'1\\') tar=\\'0\\';\\n            else tar=\\'1\\';\\n            while(i>=0&&s[i]!=tar) i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        char tar=s[n/2];\\n        for(int i=n/2;i<n;)\\n        {\\n            while(i<n&&s[i]==tar) i++;\\n            ans+=(long long)(n-i);\\n            if(tar==\\'1\\') tar=\\'0\\';\\n            else tar=\\'1\\';\\n            while(i<n&&s[i]!=tar) i++;\\n        }\\n        tar=s[n/2];\\n        for(int i=n/2;i>=0;)\\n        {\\n            while(i>=0&&s[i]==tar) i--;\\n            ans+=(long long)(i+1);\\n            if(tar==\\'1\\') tar=\\'0\\';\\n            else tar=\\'1\\';\\n            while(i>=0&&s[i]!=tar) i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575142,
                "title": "always-try-mid",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll solve(string s,int st,int end,int type,char val){\\n        ll ans = 0 ; \\n        if(type == 0){\\n            int x = 0 ; \\n            for(int i = end;i>=st;i--){\\n                if(x%2 != 0){\\n                    if(s[i]==\\'1\\')s[i]=\\'0\\';\\n                    else s[i]=\\'1\\';\\n                }\\n                if(s[i]!= val){\\n                    x++;\\n                    ans = ans + i+1;\\n                }\\n            }\\n        }\\n        if(type == 1){\\n            int x = 0 ; \\n            for(int i = st;i<=end ; i++){\\n                if(x%2 != 0){\\n                    if(s[i]==\\'1\\')s[i]=\\'0\\';\\n                    else s[i]=\\'1\\';\\n                }\\n                if(s[i]!= val){\\n                    x++;\\n                    ans = ans + s.size()-i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        int mid = n/2;\\n        ll zf = solve(s,0,mid,0,\\'0\\');\\n        ll zs = solve(s,mid+1,n-1,1,\\'0\\');\\n        ll of = solve(s,0,mid,0,\\'1\\');\\n        ll os =  solve(s,mid+1,n-1,1,\\'1\\');\\n        return min(zs+zf,os+of);\\n        \\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long \\n    ll solve(string s,int st,int end,int type,char val){\\n        ll ans = 0 ; \\n        if(type == 0){\\n            int x = 0 ; \\n            for(int i = end;i>=st;i--){\\n                if(x%2 != 0){\\n                    if(s[i]==\\'1\\')s[i]=\\'0\\';\\n                    else s[i]=\\'1\\';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3574534,
                "title": "c-easy-solution-t-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1> s[i] != s[i-1];\\n2>min(i, n-i), it will cheak the string from back and front both side\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        long long ans = 0;\\n        for(int i=1; i<n ; i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans+=min(i, n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        long long ans = 0;\\n        for(int i=1; i<n ; i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans+=min(i, n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574490,
                "title": "greedy-algo-dry-run-and-clean-code",
                "content": "# Idea\\n- We can see with example\\n- 0 | 1 0 1 0 1 => 0\\n- 1 | 1 0 1 0 1 => 1\\n- 1 1 | 0 1 0 1 => 2\\n- 0 0 0 | 1 0 1 => 3\\n- 1 1 1 1 | 0 1 => 2\\n- 1 1 1 1 1 | 0 => 1\\n- 1 1 1 1 1 1\\n- 1 + 2 + 3 + 2 + 1 = 9\\n- We pick min no of invertions possible at each time\\n- 0 to i-1 => cost i\\n- i to N-1 => cost N-i\\n- We pick the point of differ and try to either change 0 or 1 to the other one.\\n- GREEDY BEST WAY\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int N = s.length();\\n        ll ans = 0;\\n\\n        for(int i=1; i<N; i++){\\n            if(s[i] != s[i-1]){\\n                //0 to i-1 invert or i to N-1 invert\\n                ans += min(i, N-i);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int N = s.length();\\n        ll ans = 0;\\n\\n        for(int i=1; i<N; i++){\\n            if(s[i] != s[i-1]){\\n                //0 to i-1 invert or i to N-1 invert\\n                ans += min(i, N-i);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574128,
                "title": "java-linear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long minimumCost(String s) {\\n    long fl0 = to_left(s,0);\\n    long fl1 = to_left(s,1);\\n    long fr0 = to_right(s, 0);\\n    long fr1 = to_right(s, 1);\\n\\n    long mini0 = fl0 + fr0, mini1 = fl1 + fr1;  \\n    if( (s.length() & 1) == 0) return Math.min(mini0, mini1);\\n    \\n    int k = s.length()>>1, k0, k1;\\n    if(s.charAt(k) == \\'0\\') mini1 = Math.min(k + fl1 + fr0, k + fl0 + fr1);\\n    else                   mini0 = Math.min(k + fl1 + fr0, k + fl0 + fr1);\\n    \\n    return Math.min(mini0, mini1);\\n  }\\n  \\n  private long to_left(String s, int mark){\\n    long flip = 0;\\n    for(int i = (s.length()>>1) - 1; i >= 0; --i)\\n      if(s.charAt(i) - \\'0\\' != mark){\\n        flip += i+1;\\n        mark ^= 1;\\n      }\\n    \\n    return flip;\\n  }\\n  private long to_right(String s, int mark){\\n    long flip = 0;\\n    for(int i = (s.length()+1)>>1; i != s.length(); ++i)\\n      if(s.charAt(i) - \\'0\\' != mark){\\n        flip += s.length() - i;\\n        mark ^= 1;\\n      }\\n    \\n    return flip;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long minimumCost(String s) {\\n    long fl0 = to_left(s,0);\\n    long fl1 = to_left(s,1);\\n    long fr0 = to_right(s, 0);\\n    long fr1 = to_right(s, 1);\\n\\n    long mini0 = fl0 + fr0, mini1 = fl1 + fr1;  \\n    if( (s.length() & 1) == 0) return Math.min(mini0, mini1);\\n    \\n    int k = s.length()>>1, k0, k1;\\n    if(s.charAt(k) == \\'0\\') mini1 = Math.min(k + fl1 + fr0, k + fl0 + fr1);\\n    else                   mini0 = Math.min(k + fl1 + fr0, k + fl0 + fr1);\\n    \\n    return Math.min(mini0, mini1);\\n  }\\n  \\n  private long to_left(String s, int mark){\\n    long flip = 0;\\n    for(int i = (s.length()>>1) - 1; i >= 0; --i)\\n      if(s.charAt(i) - \\'0\\' != mark){\\n        flip += i+1;\\n        mark ^= 1;\\n      }\\n    \\n    return flip;\\n  }\\n  private long to_right(String s, int mark){\\n    long flip = 0;\\n    for(int i = (s.length()+1)>>1; i != s.length(); ++i)\\n      if(s.charAt(i) - \\'0\\' != mark){\\n        flip += s.length() - i;\\n        mark ^= 1;\\n      }\\n    \\n    return flip;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574023,
                "title": "optimal-solution-c-best-solution-guarenteed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n see , we traverse from either 0 to n-1  / n-1 to 0  \\n    // we have to check for (i , i+1)  , if they are different  \\n    // either we can change ith part with cost (n-i)  or we can change (i+1)th part with cost   n-i-1  , take which is minimum\\n    int n=s.length();\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIN THIS LOGIC  : we have say that if we calculate the cost of any item , other items apart from i and i+1 , if they and there neibhours are equal then after inversion they remains equal \\n\\n and if they are different they remains different even after inversion so traverse from one direction and equaling all previous //elements so that they neither change nor effect in our solution  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n long long minimumCost(string s) {       \\n    \\n    //********************optimal Approach**************************\\n\\n    // LOGIC :  see , we traverse from either 0 to n-1  / n-1 to 0  \\n    // we have to check for (i , i+1)  , if they are different  \\n    // either we can change ith part with cost (n-i)  or we can change (i+1)th part with cost   n-i-1  , take which is minimum\\n    int n=s.length();\\n\\n\\n// \\n     long long cost =0;\\n     \\n    for(int i=0 ;i<n-1;i++)\\n    {\\n        if(s[i] != s[i+1])\\n        {\\n            cost += min(i+1 , n-i-1);\\n        }\\n    }\\n     return cost;\\n     \\n }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n long long minimumCost(string s) {       \\n    \\n    //********************optimal Approach**************************\\n\\n    // LOGIC :  see , we traverse from either 0 to n-1  / n-1 to 0  \\n    // we have to check for (i , i+1)  , if they are different  \\n    // either we can change ith part with cost (n-i)  or we can change (i+1)th part with cost   n-i-1  , take which is minimum\\n    int n=s.length();\\n\\n\\n// \\n     long long cost =0;\\n     \\n    for(int i=0 ;i<n-1;i++)\\n    {\\n        if(s[i] != s[i+1])\\n        {\\n            cost += min(i+1 , n-i-1);\\n        }\\n    }\\n     return cost;\\n     \\n }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573761,
                "title": "python-two-pointers-solution-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor any invert operation, say at index i, we either invert all 0~ith numbers or i~nth numbers. That means numbers on both sides of the string will get inverted more frequently and cannot fix those numbers. Therefore, why not make invert operations to make numbers in the center same first, then work it toward both sides of the string?\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first find the mid index of the string.\\n\\nIf the string is of odd length, we assign l and r pointer to be one index left and right of mid index. If it is of even length, we first check if s[mid] != s[mid+1] to make the first invert operation (to make these two numbers the same)\\n\\nThen, we shift l towards left and r towards right, each iteration by 1. If s[l] != s[l+1] or s[r] != s[r-1], that indicates invert operation is needed to make s[l] == s[l+1] or s[r] == s[r+1], we increase the cost by l+1 or by n-r.\\n# Complexity\\n- Time complexity: $$O(n)$$\\nWe iterate each position only once\\n\\n- Space complexity: $$O(1)$$\\nWe didn\\'t use any extra memory\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        if len(s) == 1:\\n            return 0\\n\\n        n = len(s)\\n        cost = 0\\n\\n        l, r = 0, n-1\\n        mid = int((l+r)/2)\\n        if n % 2:\\n            l, r = mid-1, mid+1\\n        else:\\n            l, r = mid, mid+1\\n            if s[l] != s[r]: cost += l+1\\n            l -= 1\\n            r += 1\\n        \\n        while l >= 0 and r < n:\\n            if s[l] != s[l+1]:\\n                cost += l+1\\n            if s[r] != s[r-1]:\\n                cost += n-r\\n            l -= 1\\n            r += 1\\n        return cost \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        if len(s) == 1:\\n            return 0\\n\\n        n = len(s)\\n        cost = 0\\n\\n        l, r = 0, n-1\\n        mid = int((l+r)/2)\\n        if n % 2:\\n            l, r = mid-1, mid+1\\n        else:\\n            l, r = mid, mid+1\\n            if s[l] != s[r]: cost += l+1\\n            l -= 1\\n            r += 1\\n        \\n        while l >= 0 and r < n:\\n            if s[l] != s[l+1]:\\n                cost += l+1\\n            if s[r] != s[r-1]:\\n                cost += n-r\\n            l -= 1\\n            r += 1\\n        return cost \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573735,
                "title": "prefix-suffix-dp-solution-c-best-solution-for-this-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    using ll = long long;\\npublic:\\n    long long minimumCost(string s) {\\n        int n = size(s);\\n        vector<ll> prefix(n);\\n        vector<ll> suffix(n);\\n        //prefix[i] represent the cost required to make all the charecters from 0th to (i-1)th index equal to the charecter at ith charecter \\n        for(int i=0;i<n;i++){\\n            if(i == 0){\\n                prefix[i] = 0;\\n            }\\n            else{\\n                if(s[i] == s[i-1]){\\n                    prefix[i] = prefix[i-1];\\n                }\\n                else if(s[i]!=s[i-1]){\\n                    prefix[i] = i + prefix[i-1];\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(i == n-1){\\n                suffix[i] = 0;\\n            }\\n            else{\\n                if(s[i] == s[i+1]){\\n                    suffix[i] = suffix[i+1];\\n                }\\n                else{\\n                    suffix[i] = (n-i-1) + suffix[i+1];\\n                }\\n            }\\n        }\\n        ll ans = LONG_LONG_MAX;\\n        for(int i=0;i<n;i++){\\n            ans = min(ans,prefix[i] + suffix[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    using ll = long long;\\npublic:\\n    long long minimumCost(string s) {\\n        int n = size(s);\\n        vector<ll> prefix(n);\\n        vector<ll> suffix(n);\\n        //prefix[i] represent the cost required to make all the charecters from 0th to (i-1)th index equal to the charecter at ith charecter \\n        for(int i=0;i<n;i++){\\n            if(i == 0){\\n                prefix[i] = 0;\\n            }\\n            else{\\n                if(s[i] == s[i-1]){\\n                    prefix[i] = prefix[i-1];\\n                }\\n                else if(s[i]!=s[i-1]){\\n                    prefix[i] = i + prefix[i-1];\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(i == n-1){\\n                suffix[i] = 0;\\n            }\\n            else{\\n                if(s[i] == s[i+1]){\\n                    suffix[i] = suffix[i+1];\\n                }\\n                else{\\n                    suffix[i] = (n-i-1) + suffix[i+1];\\n                }\\n            }\\n        }\\n        ll ans = LONG_LONG_MAX;\\n        for(int i=0;i<n;i++){\\n            ans = min(ans,prefix[i] + suffix[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573680,
                "title": "easy-and-small-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n\\n        long long ans = 0;\\n        \\n        for (int i = 0; i < s.size()-1; i++) {\\n            if(s[i]!=s[i+1])\\n            {\\n                ans += min(i + 1, static_cast<int>(s.size()) - i -1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n\\n        long long ans = 0;\\n        \\n        for (int i = 0; i < s.size()-1; i++) {\\n            if(s[i]!=s[i+1])\\n            {\\n                ans += min(i + 1, static_cast<int>(s.size()) - i -1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573381,
                "title": "python-dp-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        right = [[0]*2 for _ in range(n+1)]\\n        for i in range(n-1,-1,-1):\\n            right[i][0] = right[i+1][1] + (n-i) if s[i] == \\'1\\' else right[i+1][0]\\n            right[i][1] = right[i+1][0] + (n-i) if s[i] == \\'0\\' else right[i+1][1]\\n        left = [0]*2\\n        res = [[0]*2 for _ in range(n)]\\n        for i in range(n):\\n            res[i][0] = left[0]+right[i+1][0] if s[i] == \\'0\\' else min(left[1]+right[i+1][0]+i+1, left[0]+right[i+1][1]+n-i)\\n            res[i][1] = left[1]+right[i+1][1] if s[i] == \\'1\\' else min(left[1]+right[i+1][0]+n-i, left[0]+right[i+1][1]+i+1)\\n            left[0], left[1] = left[0] if s[i] == \\'0\\' else left[1] + i + 1, left[1] if s[i] == \\'1\\' else left[0] + i + 1 \\n        return min(map(min, res))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        right = [[0]*2 for _ in range(n+1)]\\n        for i in range(n-1,-1,-1):\\n            right[i][0] = right[i+1][1] + (n-i) if s[i] == \\'1\\' else right[i+1][0]\\n            right[i][1] = right[i+1][0] + (n-i) if s[i] == \\'0\\' else right[i+1][1]\\n        left = [0]*2\\n        res = [[0]*2 for _ in range(n)]\\n        for i in range(n):\\n            res[i][0] = left[0]+right[i+1][0] if s[i] == \\'0\\' else min(left[1]+right[i+1][0]+i+1, left[0]+right[i+1][1]+n-i)\\n            res[i][1] = left[1]+right[i+1][1] if s[i] == \\'1\\' else min(left[1]+right[i+1][0]+n-i, left[0]+right[i+1][1]+i+1)\\n            left[0], left[1] = left[0] if s[i] == \\'0\\' else left[1] + i + 1, left[1] if s[i] == \\'1\\' else left[0] + i + 1 \\n        return min(map(min, res))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573331,
                "title": "not-greedy-easier-understanding",
                "content": "# Intuition\\n\\nThis code is not as elegant as the other one use Math.min(i, n-i), but it does explain things well.\\n\\nFirst finding, the cost is the number of characters get flipped, from left or right.\\nSecond oberservation, you will always choose rule 1 if index is less than mid point, choose rule 2 if index is greater than mid point.\\n\\nLast, Key point, when there\\'s a char different from the previous one. you have two choices\\nop1: invert all characters before i (not include i) or \\nop2: invert all chars from i (inclusive) to the end\\n\\n\\nHere Math.min just help to solve the obersavation 2 in an elagant way, it also helps once the cost rule get changed in case.\\n\\nBelow solution works as well.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long getCost(String s, int begin, int end, int direction) {\\n        int cost = 0;\\n        for (int i = begin; direction > 0 ? i <= end : i >= end ; i += direction) {\\n            if (s.charAt(i) != s.charAt(i + direction)) {\\n                cost += direction > 0 ? i - begin + 1 : begin - i + 1;\\n            }\\n        }\\n        return cost;\\n    }\\n\\n    public long minimumCost(String s) {\\n        return getCost(s, 0, s.length() / 2 - 1, 1)\\n            + getCost(s, s.length() - 1, s.length() / 2 + 1, -1);           \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long getCost(String s, int begin, int end, int direction) {\\n        int cost = 0;\\n        for (int i = begin; direction > 0 ? i <= end : i >= end ; i += direction) {\\n            if (s.charAt(i) != s.charAt(i + direction)) {\\n                cost += direction > 0 ? i - begin + 1 : begin - i + 1;\\n            }\\n        }\\n        return cost;\\n    }\\n\\n    public long minimumCost(String s) {\\n        return getCost(s, 0, s.length() / 2 - 1, 1)\\n            + getCost(s, s.length() - 1, s.length() / 2 + 1, -1);           \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573182,
                "title": "c-dp-solution",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        //l2r\\n        vector<vector<ll>> l2r(2,vector<ll>(n,0));\\n        l2r[0][0]=(s[0]==\\'0\\')?0:1;\\n        l2r[1][0]=(s[0]==\\'1\\')?0:1;\\n        for(int i=1; i<n; i++){\\n            l2r[0][i]=\\n                s[i]==\\'0\\'?\\n                    l2r[0][i-1]:\\n                    l2r[1][i-1] + i+1;\\n            l2r[1][i]=\\n                s[i]==\\'1\\'?\\n                    l2r[1][i-1]:\\n                    l2r[0][i-1] + i+1;\\n        }\\n        //r2l\\n        vector<vector<ll>> r2l(2,vector<ll>(n,0));\\n        r2l[0][n-1]=(s[n-1]==\\'0\\')?0:1;\\n        r2l[1][n-1]=(s[n-1]==\\'1\\')?0:1;\\n        for(int i=n-2; i>=0; i--){\\n            r2l[0][i]=\\n                s[i]==\\'0\\'?\\n                    r2l[0][i+1]:\\n                    r2l[1][i+1] + n-i;\\n            r2l[1][i]=\\n                s[i]==\\'1\\'?\\n                    r2l[1][i+1]:\\n                    r2l[0][i+1] + n-i;\\n        }\\n        //calcu res\\n        ll res=LLONG_MAX;\\n        for(int i=0; i<=n; i++){\\n           res=min({res,\\n                   (i-1>=0?l2r[0][i-1]:0) + (i<=n-1?r2l[0][i]:0),\\n                   (i-1>=0?l2r[1][i-1]:0) + (i<=n-1?r2l[1][i]:0)\\n                   });\\n        }\\n        return res;\\n    }\\n};\\n\\n/*\\ndp\\nl2r [0][0..i]: cost to convert s[0..i] to all 0s\\n    \\ni: 0...n-1\\nl2r [0][0..i] = \\n    if s[i]==0 dp[0][i-1]\\n    if s[i]==1 dp[1][i-1] + i+1\\n        \\nl2r [1][0..i] = \\n    if s[i]==1 dp[1][i-1]\\n    if s[i]==0 dp[0][i-1] + i+1\\n\\ni: n-1..0        \\nr2l [0][i..n-1] = \\n    if s[i]==0 dp[0][i+1]\\n    if s[i]==1 dp[1][i+1] + n-i\\n        \\nr2l [1][0..i] = \\n    if s[i]==1 dp[1][i+1]\\n    if s[i]==0 dp[0][i+1] + n-i\\n        \\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        //l2r\\n        vector<vector<ll>> l2r(2,vector<ll>(n,0));\\n        l2r[0][0]=(s[0]==\\'0\\')?0:1;\\n        l2r[1][0]=(s[0]==\\'1\\')?0:1;\\n        for(int i=1; i<n; i++){\\n            l2r[0][i]=\\n                s[i]==\\'0\\'?\\n                    l2r[0][i-1]:\\n                    l2r[1][i-1] + i+1;\\n            l2r[1][i]=\\n                s[i]==\\'1\\'?\\n                    l2r[1][i-1]:\\n                    l2r[0][i-1] + i+1;\\n        }\\n        //r2l\\n        vector<vector<ll>> r2l(2,vector<ll>(n,0));\\n        r2l[0][n-1]=(s[n-1]==\\'0\\')?0:1;\\n        r2l[1][n-1]=(s[n-1]==\\'1\\')?0:1;\\n        for(int i=n-2; i>=0; i--){\\n            r2l[0][i]=\\n                s[i]==\\'0\\'?\\n                    r2l[0][i+1]:\\n                    r2l[1][i+1] + n-i;\\n            r2l[1][i]=\\n                s[i]==\\'1\\'?\\n                    r2l[1][i+1]:\\n                    r2l[0][i+1] + n-i;\\n        }\\n        //calcu res\\n        ll res=LLONG_MAX;\\n        for(int i=0; i<=n; i++){\\n           res=min({res,\\n                   (i-1>=0?l2r[0][i-1]:0) + (i<=n-1?r2l[0][i]:0),\\n                   (i-1>=0?l2r[1][i-1]:0) + (i<=n-1?r2l[1][i]:0)\\n                   });\\n        }\\n        return res;\\n    }\\n};\\n\\n/*\\ndp\\nl2r [0][0..i]: cost to convert s[0..i] to all 0s\\n    \\ni: 0...n-1\\nl2r [0][0..i] = \\n    if s[i]==0 dp[0][i-1]\\n    if s[i]==1 dp[1][i-1] + i+1\\n        \\nl2r [1][0..i] = \\n    if s[i]==1 dp[1][i-1]\\n    if s[i]==0 dp[0][i-1] + i+1\\n\\ni: n-1..0        \\nr2l [0][i..n-1] = \\n    if s[i]==0 dp[0][i+1]\\n    if s[i]==1 dp[1][i+1] + n-i\\n        \\nr2l [1][0..i] = \\n    if s[i]==1 dp[1][i+1]\\n    if s[i]==0 dp[0][i+1] + n-i\\n        \\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573173,
                "title": "c-easy-understandable-solution-using-linear-traversal-t-c-o-n-s-c-o-1",
                "content": "# Approach\\nExplained in the code itself\\n\\n# Complexity\\n- Time complexity:\\nO[N]\\n\\n- Space complexity:\\nO[1]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long minimumCost(string s) \\n    {\\n        long long int i, j, len=s.length();\\n        i=(s.length()/2)-1;\\n        long long int chg=0, target, cost0=0, cost1=0;\\n        \\n        // [1] for converting all to 0------------------------------------------------------\\n        \\n        // 1,(a) For conversion of left half to 0 we use first method as it\\'s cheaper than second method\\n        target=0;\\n        while(i>=0)\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost0+=(i+1);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i--;\\n        }\\n        \\n        // 1,(b) For conversion of right half to 0 we use second method as it\\'s cheaper than first method\\n        i=(s.length()/2);\\n        chg=0;\\n        while(i<s.length())\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            \\n            if(val!=target)\\n            {\\n                cost0+=(len-i);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            \\n            i++;\\n        }\\n        \\n        // [2] for converting all to 1------------------------------------------------------\\n        \\n        // 2,(a) For conversion of left half to 1 we use first method as it\\'s cheaper than second method\\n        \\n        // for target= \\'1\\'\\n        i=(s.length()/2)-1;\\n        target=1;\\n        chg=0;\\n        while(i>=0)\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost1+=(i+1);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i--;\\n        }\\n        \\n        // 2,(b) For conversion of right half to 1 we use second method as it\\'s cheaper than first method\\n        \\n        i=(s.length()/2) ;\\n        chg=0;\\n        while(i<s.length())\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost1+=(len-i);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        \\n        return min(cost1, cost0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long minimumCost(string s) \\n    {\\n        long long int i, j, len=s.length();\\n        i=(s.length()/2)-1;\\n        long long int chg=0, target, cost0=0, cost1=0;\\n        \\n        // [1] for converting all to 0------------------------------------------------------\\n        \\n        // 1,(a) For conversion of left half to 0 we use first method as it\\'s cheaper than second method\\n        target=0;\\n        while(i>=0)\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost0+=(i+1);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i--;\\n        }\\n        \\n        // 1,(b) For conversion of right half to 0 we use second method as it\\'s cheaper than first method\\n        i=(s.length()/2);\\n        chg=0;\\n        while(i<s.length())\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            \\n            if(val!=target)\\n            {\\n                cost0+=(len-i);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            \\n            i++;\\n        }\\n        \\n        // [2] for converting all to 1------------------------------------------------------\\n        \\n        // 2,(a) For conversion of left half to 1 we use first method as it\\'s cheaper than second method\\n        \\n        // for target= \\'1\\'\\n        i=(s.length()/2)-1;\\n        target=1;\\n        chg=0;\\n        while(i>=0)\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost1+=(i+1);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i--;\\n        }\\n        \\n        // 2,(b) For conversion of right half to 1 we use second method as it\\'s cheaper than first method\\n        \\n        i=(s.length()/2) ;\\n        chg=0;\\n        while(i<s.length())\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost1+=(len-i);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        \\n        return min(cost1, cost0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573077,
                "title": "c-prefix-sum",
                "content": "# Intuition\\nUse prefix sum.\\n\\n# Approach\\nCreate 2 arrays of type long of size `s.Length` - `left` and `right`. Then fill these arrays from start to finish and from finish to start accordingly:\\n```\\nfor (int i = 0; i < s.Length - 1; i++)\\n{\\n    if (s[i] != s[i + 1])\\n    {\\n        left[i] = i + 1;\\n    }\\n    if (0 < i) left[i] += left[i - 1];\\n}\\n...\\nfor (int i = s.Length - 1; i > 0; i--)\\n{\\n    if (s[i] != s[i - 1])\\n    {\\n        right[i] = s.Length - i;\\n    }\\n    if (i < s.Length - 1) right[i] += right[i + 1];\\n}\\n```\\nIn the final cycle find the minimum result:\\n```\\nfor (int i = 1; i < s.Length - 1; i++)\\n{\\n    var rs0 = left[i - 1] + right[i + 1];\\n    if (rs > rs0) rs = rs0;\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is s.Length.\\n\\n- Space complexity:\\n$$O(n)$$, where n is s.Length.\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinimumCost(string s) {\\n        if (s.Length == 1) return 0;\\n        var left = new long[s.Length];\\n        for (int i = 0; i < s.Length - 1; i++)\\n        {\\n            if (s[i] != s[i + 1])\\n            {\\n                left[i] = i + 1;\\n            }\\n            if (0 < i) left[i] += left[i - 1];\\n        }\\n        var right = new long[s.Length];\\n        for (int i = s.Length - 1; i > 0; i--)\\n        {\\n            if (s[i] != s[i - 1])\\n            {\\n                right[i] = s.Length - i;\\n            }\\n            if (i < s.Length - 1) right[i] += right[i + 1];\\n        }\\n        long rs = Math.Min(left[left.Length - 2], right[1]);\\n        for (int i = 1; i < s.Length - 1; i++)\\n        {\\n            var rs0 = left[i - 1] + right[i + 1];\\n            if (rs > rs0) rs = rs0;\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Prefix Sum"
                ],
                "code": "```\\nfor (int i = 0; i < s.Length - 1; i++)\\n{\\n    if (s[i] != s[i + 1])\\n    {\\n        left[i] = i + 1;\\n    }\\n    if (0 < i) left[i] += left[i - 1];\\n}\\n...\\nfor (int i = s.Length - 1; i > 0; i--)\\n{\\n    if (s[i] != s[i - 1])\\n    {\\n        right[i] = s.Length - i;\\n    }\\n    if (i < s.Length - 1) right[i] += right[i + 1];\\n}\\n```\n```\\nfor (int i = 1; i < s.Length - 1; i++)\\n{\\n    var rs0 = left[i - 1] + right[i + 1];\\n    if (rs > rs0) rs = rs0;\\n}\\n```\n```\\npublic class Solution {\\n    public long MinimumCost(string s) {\\n        if (s.Length == 1) return 0;\\n        var left = new long[s.Length];\\n        for (int i = 0; i < s.Length - 1; i++)\\n        {\\n            if (s[i] != s[i + 1])\\n            {\\n                left[i] = i + 1;\\n            }\\n            if (0 < i) left[i] += left[i - 1];\\n        }\\n        var right = new long[s.Length];\\n        for (int i = s.Length - 1; i > 0; i--)\\n        {\\n            if (s[i] != s[i - 1])\\n            {\\n                right[i] = s.Length - i;\\n            }\\n            if (i < s.Length - 1) right[i] += right[i + 1];\\n        }\\n        long rs = Math.Min(left[left.Length - 2], right[1]);\\n        for (int i = 1; i < s.Length - 1; i++)\\n        {\\n            var rs0 = left[i - 1] + right[i + 1];\\n            if (rs > rs0) rs = rs0;\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572977,
                "title": "c-easy-solution-simple-middle-technique-100-fast",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Start from middle technique for minimum cost\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int mid = s.length() / 2;\\n        for(int i = mid - 1 ; i >= 0 ; i--) {\\n            if(s[i] != s[i + 1]) {\\n                ans += i + 1;\\n            }\\n        }\\n        for(int i = mid + 1 ; i < s.length() ; i++) {\\n            if(s[i] != s[i - 1]) {\\n                ans += s.length() - i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int mid = s.length() / 2;\\n        for(int i = mid - 1 ; i >= 0 ; i--) {\\n            if(s[i] != s[i + 1]) {\\n                ans += i + 1;\\n            }\\n        }\\n        for(int i = mid + 1 ; i < s.length() ; i++) {\\n            if(s[i] != s[i - 1]) {\\n                ans += s.length() - i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572903,
                "title": "java-o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDivide the array into two halves:\\n1. For the first half the cost will be minimum if we take the first operation since all our values lie before our midpoint or at it if we include the midpoint(I have included the midpoint in this approach)\\n2. For the second half all our observations are on the right hand side of the midpoint so the second operation is the choice of inverting the bits \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have two choices on our hands :\\n1. Make all the array elements equal to \\'1\\'\\n2. Make all the array elements equal to \\'0\\'\\nUse a function to solve for both scenarios and the result is taking the min cost of the two possibilities\\n\\n**The main function in question:**\\n\\nAssuming input string :\\'010101\\' and the scenario where we want to make all the characters equal to \\'0\\' aka all the bits are 0\\nstring:\\'0 1 0 1 0 1\\'\\n- Start at the midpoint (n-1)/2 aka index 2 in this case\\n- **Solving for the left half[0 1 0] with cost formula (i+1) for inverting indices (0,i):**\\n        **1)** Initialize  cost=0 \\n             **2)** Since we are solving to make all the bits to \\'0\\' traverse from the mid point 2 towards the left and check if the character is not equal to \\'0\\' aka find the nearest \\'1\\' when traversing from the midpoint towards the left.\\n             **3)** In this scenario the \\'1\\' is at index 1 we invert the characters from (0,1)[1 inclusive] which makes the result : **[1 0 0]** and the cost(for i=1)=**0+(1+1)=2**\\n             **4)** But here comes the catch since we are not modifying the string itself we can still perform the inversion by just inverting the condition we are searching on so instead of checking for \\'1\\' we search for \\'0\\' and our actual string is still:**[0 1 0]** we encounter the first \\'0\\' at index 0 and now the cost(for i=0)=**2+(0+1) =3**\\n             **5)** We have now reached the end of the left half\\n\\n We follow a similar approach for the right half traversing from the midpoint to the end and the cost formula is **(n-i)** with n being the size of the string\\n- **Solving for the right half[1 0 1] with cost formula (n-i) for inverting indices (i,n):**\\n           **1)**  Since we are solving to make all the bits to \\'0\\' traverse from the mid point 2 towards the right and check if the character is not equal to \\'0\\' aka find the first \\'1\\' when traversing from the midpoint towards the left.\\n             **2)** In this scenario the \\'1\\' is at index 3 we invert the characters from (3,5)[5 inclusive] which makes the result : **[0 1 1]** and the cost(for i=1)=**3+(6-3)=6**\\n             **3)** Inverting the condition we are searching on so instead of checking for  \\'1\\' we search for \\'0\\' and our actual string is still:**[1 0 1]** we encounter the  \\'0\\' at index 0 and now the cost(for i=0)=**6+(6-4) =8**\\n             **4)**  Inverting the condition we are searching on so instead of checking for  \\'0\\' we search for \\'1\\' and our actual string is still:**[1 0 1]** we encounter the  \\'1\\' at index 5 and now the cost(for i=0)=**8+(6-5) =9**\\n            **5)** We reach the end of the string \\n**Repeat the above steps with the choice of making all the bits to \\'1\\'**\\n**Take the minimum of the two costs as the final result**\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  \\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        return Math.min(this.solve(s,\\'1\\'),this.solve(s,\\'0\\'));\\n    }\\n    public long solve(String s ,char c){\\n        //left half from mid to index 0(start index)\\n        int mid=(s.length()-1)/2;\\n        int i=mid;\\n        char ch=c;\\n        long cost=0;\\n        while(i>=0){\\n            if(s.charAt(i)!=ch){\\n                cost+=(i+1);\\n                ch=ch==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            i--;\\n        }\\n        //Resetting the search to the original character\\n        ch=c;\\n        //right half from mid to index n-1(end index)\\n        i=mid+1;\\n\\n        while(i<s.length()){\\n            if(s.charAt(i)!=ch){\\n                cost+=(s.length()-i);\\n                ch=ch==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            i++;\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        return Math.min(this.solve(s,\\'1\\'),this.solve(s,\\'0\\'));\\n    }\\n    public long solve(String s ,char c){\\n        //left half from mid to index 0(start index)\\n        int mid=(s.length()-1)/2;\\n        int i=mid;\\n        char ch=c;\\n        long cost=0;\\n        while(i>=0){\\n            if(s.charAt(i)!=ch){\\n                cost+=(i+1);\\n                ch=ch==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            i--;\\n        }\\n        //Resetting the search to the original character\\n        ch=c;\\n        //right half from mid to index n-1(end index)\\n        i=mid+1;\\n\\n        while(i<s.length()){\\n            if(s.charAt(i)!=ch){\\n                cost+=(s.length()-i);\\n                ch=ch==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            i++;\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572872,
                "title": "beats-100-both-space-and-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do as we are being told.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nloop over the entire string\\nIf s[i] != s[i-1] we check which side we could get our answer, i.e. ans += min(i,n-i)\\n\\nwe then return this answer.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1]){\\n                ans+=min(i,n-i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1]){\\n                ans+=min(i,n-i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572765,
                "title": "100-beats-27-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long fun(string s,char ch)\\n  {\\n    long long t=-1,ans=0,n=s.size(),i=0;\\n\\n    while(i<n/2)\\n    {\\n       if(s[i]!=ch){\\n        while(i<n/2 and s[i]!=ch) i++;\\n        ans+=i+t+1;\\n        }\\n        else t=i,i++;\\n    }\\n    i=n-1,t=n;\\n    while(i>=n/2)\\n    {\\n      if(s[i]!=ch){\\n      while(i>=n/2 and s[i]!=ch) i--;\\n      ans+=n-i-1+n-t;\\n      }\\n      else  t=i,i--;\\n    }\\n    return ans;\\n  }\\n    long long minimumCost(string s) {\\n        // for(int i=0;i<s.size();i++) if(s[i]==\\'1\\') o++;else z++;\\n       return min(fun(s,\\'1\\'),fun(s,\\'0\\'));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long fun(string s,char ch)\\n  {\\n    long long t=-1,ans=0,n=s.size(),i=0;\\n\\n    while(i<n/2)\\n    {\\n       if(s[i]!=ch){\\n        while(i<n/2 and s[i]!=ch) i++;\\n        ans+=i+t+1;\\n        }\\n        else t=i,i++;\\n    }\\n    i=n-1,t=n;\\n    while(i>=n/2)\\n    {\\n      if(s[i]!=ch){\\n      while(i>=n/2 and s[i]!=ch) i--;\\n      ans+=n-i-1+n-t;\\n      }\\n      else  t=i,i--;\\n    }\\n    return ans;\\n  }\\n    long long minimumCost(string s) {\\n        // for(int i=0;i<s.size();i++) if(s[i]==\\'1\\') o++;else z++;\\n       return min(fun(s,\\'1\\'),fun(s,\\'0\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572598,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to think greedy either we flip left part or right part\\nleft part contains i elements, right part contains another n-i elements\\nAccording to the given problem cost \\nFor left part cost = (i) and for right part cost=n-i\\nwe\\'ve to take min steps for flip \\ntherefore, flip/take min(leftPart,rightPart) and add it to res \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n         long long ans = 0;\\n          int n=s.size();\\n       for(int i=1; i<n; i++){\\n           if(s[i]!=s[i-1])\\n           ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n         long long ans = 0;\\n          int n=s.size();\\n       for(int i=1; i<n; i++){\\n           if(s[i]!=s[i-1])\\n           ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572534,
                "title": "c-solution-beats-100-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n       long long ans = 0; int n=s.size();\\n       for(int i=1; i<s.size(); i++){\\n           if(s[i]!=s[i-1])ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n       long long ans = 0; int n=s.size();\\n       for(int i=1; i<s.size(); i++){\\n           if(s[i]!=s[i-1])ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572436,
                "title": "very-simple-easy-solution-with-best-explanation",
                "content": "# Approach\\n    In range [L,R] => R-L+1 elements\\n    loop i=1 to n-1      \\n    we\\'re at any ith index and check \\n    left part================================================\\n    We\\'ve already check till ith index \\n    it means that all the character from [0,i-1] are same \\n    total elements in [0,i-1] => (i-1)-(0)+1 => i elements \\n    \\n    right part================================================\\n    total elements in [i,n-1] => (n-1)-(i)+1 => n-i elements\\n\\n    We have to think greedy either we flip left part or right part\\n    left part contains i elements, right part contains another n-i elements\\n    According to the given problem cost \\n    For left part cost = (i) and for right part cost=n-i\\n    we\\'ve to take min steps for flip \\n    therefore, flip/take min(leftPart,rightPart) and add it to res \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long res=0;\\n        int n=s.size();\\n        for(int i=1 ; i<n ; ++i) {\\n            if(s[i]!=s[i-1]) {\\n                res+=min(i,n-i); \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long res=0;\\n        int n=s.size();\\n        for(int i=1 ; i<n ; ++i) {\\n            if(s[i]!=s[i-1]) {\\n                res+=min(i,n-i); \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572303,
                "title": "very-simple-and-easy-to-understand-different-from-other-single-loop-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        int lenMid = s.length()%2;\\n        long long ans = 0;\\n            if(s[s.length()/2] == \\'1\\'){\\n            int mid = s.length()/2;\\n            if(s.length()%2 == 0)mid--;\\n            int x = mid+1;\\n            bool b = false;\\n            while(mid >= 0){\\n                if(s[mid] == \\'0\\' && b == false){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                else if(s[mid] == \\'1\\' && b == true){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                mid--;\\n            }\\n            b = false;\\n            while(x<s.length()){\\n                if(s[x] == \\'0\\' && b == false){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                else if(s[x] == \\'1\\' && b == true){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                x++;\\n            }\\n        }\\n        else {\\n            int mid = s.length()/2;\\n            if(s.length()%2 == 0)mid--;\\n            int x = mid+1;\\n            bool b = false;\\n            while(mid >= 0){\\n                if(s[mid] == \\'1\\' && b == false){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                else if(s[mid] == \\'0\\' && b == true){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                mid--;\\n            }\\n            b = false;\\n            while(x<s.length()){\\n                if(s[x] == \\'1\\' && b == false){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                else if(s[x] == \\'0\\' && b == true){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                x++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        int lenMid = s.length()%2;\\n        long long ans = 0;\\n            if(s[s.length()/2] == \\'1\\'){\\n            int mid = s.length()/2;\\n            if(s.length()%2 == 0)mid--;\\n            int x = mid+1;\\n            bool b = false;\\n            while(mid >= 0){\\n                if(s[mid] == \\'0\\' && b == false){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                else if(s[mid] == \\'1\\' && b == true){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                mid--;\\n            }\\n            b = false;\\n            while(x<s.length()){\\n                if(s[x] == \\'0\\' && b == false){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                else if(s[x] == \\'1\\' && b == true){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                x++;\\n            }\\n        }\\n        else {\\n            int mid = s.length()/2;\\n            if(s.length()%2 == 0)mid--;\\n            int x = mid+1;\\n            bool b = false;\\n            while(mid >= 0){\\n                if(s[mid] == \\'1\\' && b == false){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                else if(s[mid] == \\'0\\' && b == true){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                mid--;\\n            }\\n            b = false;\\n            while(x<s.length()){\\n                if(s[x] == \\'1\\' && b == false){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                else if(s[x] == \\'0\\' && b == true){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                x++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572198,
                "title": "3d-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][2][2];\\n    int n;\\n    long long f(int ind, int prev, string &s, bool inverted){\\n        if(ind >= n) return 0;\\n        if(dp[ind][prev][inverted] != -1)\\n            return dp[ind][prev][inverted];\\n     \\n        //if curr and prev match and inverted is false\\n        if(s[ind] - 48 == prev && !inverted)\\n            return dp[ind][prev][inverted]= f(ind+1, s[ind]-48, s,false);\\n        //if prev and curr match and inverted is true.. then its considered as mismatch\\n        else if(s[ind]-48 == prev and inverted)\\n            return dp[ind][prev][inverted]= min(ind+ f(ind+1,s[ind]-48,s,false), n-ind + f(ind+1,!(s[ind]-48), s,true));\\n       //if prev and curr not match and inverted is true.. then its considered as match\\n        else if(s[ind] - 48 != prev and inverted)\\n            return dp[ind][prev][inverted]= f(ind+1, s[ind]-48, s,false);\\n        //if prev and curr not match and inverted is false.. then its considered as mismatch\\n        else if(s[ind] - 48 != prev and !inverted)\\n            return dp[ind][prev][inverted]= min(ind+ f(ind+1,s[ind]-48,s,false), n-ind + f(ind+1,!(s[ind]-48), s,true));\\n        else return -1;\\n    }\\n    long long minimumCost(string s) {\\n        n= s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(1,s[0]-48,s,false); //ind,prev,string,inverted\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][2][2];\\n    int n;\\n    long long f(int ind, int prev, string &s, bool inverted){\\n        if(ind >= n) return 0;\\n        if(dp[ind][prev][inverted] != -1)\\n            return dp[ind][prev][inverted];\\n     \\n        //if curr and prev match and inverted is false\\n        if(s[ind] - 48 == prev && !inverted)\\n            return dp[ind][prev][inverted]= f(ind+1, s[ind]-48, s,false);\\n        //if prev and curr match and inverted is true.. then its considered as mismatch\\n        else if(s[ind]-48 == prev and inverted)\\n            return dp[ind][prev][inverted]= min(ind+ f(ind+1,s[ind]-48,s,false), n-ind + f(ind+1,!(s[ind]-48), s,true));\\n       //if prev and curr not match and inverted is true.. then its considered as match\\n        else if(s[ind] - 48 != prev and inverted)\\n            return dp[ind][prev][inverted]= f(ind+1, s[ind]-48, s,false);\\n        //if prev and curr not match and inverted is false.. then its considered as mismatch\\n        else if(s[ind] - 48 != prev and !inverted)\\n            return dp[ind][prev][inverted]= min(ind+ f(ind+1,s[ind]-48,s,false), n-ind + f(ind+1,!(s[ind]-48), s,true));\\n        else return -1;\\n    }\\n    long long minimumCost(string s) {\\n        n= s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(1,s[0]-48,s,false); //ind,prev,string,inverted\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572171,
                "title": "c-100-faster-and-easy-explanation-and-clear-concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition behind this logis is that you have to flip the the bit in the string only when there is no match with next character. This is because if the character is matching then inverting it does not make a sense.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo check the next character and flip it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n                long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1])\\n                ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n                long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1])\\n                ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572102,
                "title": "easy-100-space-andtime-beat",
                "content": "# Intuition\\n  - 1.cost can be i+1 or n-i.\\n  - 2.Splitting into and adding cost that is i+1 or n-i.\\n\\n  \\n![image.png](https://assets.leetcode.com/users/images/853d4fda-b852-4165-b7ee-c5f203eef799_1685280625.1763096.png)\\n\\n\\n# Approach\\n 1.spit the string into halves.check for matching in both sides and keep track of changes u have done .\\n2.Update the term before check and complte travel.\\n\\n# Complexity\\n- Time complexity:\\no(N)  single traversal\\n\\n- Space complexity:\\n O(1) constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size(),f=0,e=0;\\n        long long int ans=0;int a[n];\\n        a[n/2]=s[n/2]-\\'0\\';\\n         for (int i =n/2 ; i>0 ; i--)\\n        {  \\n           int p=s[i-1]-\\'0\\'+f;\\n             p=p%2;\\n           if (p!=a[i])\\n           {\\n              f++;\\n              ans+=i;\\n           }\\n             a[i-1]=a[i];\\n           \\n        }\\n        for (int i =n/2 ; i<n-1 ; i++)\\n        {  \\n           int p=s[i+1]-\\'0\\'+e; \\n            p=p%2;\\n           if (p!=a[i])\\n           {\\n              e++;\\n              ans+=(n-i-1);\\n           }\\n            a[i+1]=a[i];\\n           \\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size(),f=0,e=0;\\n        long long int ans=0;int a[n];\\n        a[n/2]=s[n/2]-\\'0\\';\\n         for (int i =n/2 ; i>0 ; i--)\\n        {  \\n           int p=s[i-1]-\\'0\\'+f;\\n             p=p%2;\\n           if (p!=a[i])\\n           {\\n              f++;\\n              ans+=i;\\n           }\\n             a[i-1]=a[i];\\n           \\n        }\\n        for (int i =n/2 ; i<n-1 ; i++)\\n        {  \\n           int p=s[i+1]-\\'0\\'+e; \\n            p=p%2;\\n           if (p!=a[i])\\n           {\\n              e++;\\n              ans+=(n-i-1);\\n           }\\n            a[i+1]=a[i];\\n           \\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572078,
                "title": "o-n-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans = 0;\\n        for(int i = 0; i<s.length()-1;i++){\\n            if(s.charAt(i) != s.charAt(i+1)) ans += Math.min(i+1,s.length()-i-1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans = 0;\\n        for(int i = 0; i<s.length()-1;i++){\\n            if(s.charAt(i) != s.charAt(i+1)) ans += Math.min(i+1,s.length()-i-1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572070,
                "title": "one-path-iterative-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf two characters are different, flipping all characters starting at one of them makes those two characters equal, while preserving number of differences between characters in the flipped part.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start from the middle - to the left, we use first method because it is cheaper to the left, while to the right we use the second method. Commented out code is for debugging only, as we do not need to actually flip characters - we only need to compute cost.\\nThis allows for $$O(n)$$ time and $$O(1)$$ space solution, we only need one path to count cost. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long cost = 0;\\n        for(int i=s.size()/2; i > 0; i--) {\\n            if(s[i] != s[i-1]) {\\n                cost += i;\\n                /*\\n                for(int ii=0;ii<i;ii++) {\\n                    if(s[ii] == \\'1\\') {\\n                        s[ii] = \\'0\\';\\n                    } else {\\n                        s[ii] = \\'1\\';\\n                    }\\n                }\\n                */\\n            }\\n        }\\n        for(int i=s.size()/2; i < s.size() - 1; i++) {\\n            if(s[i] != s[i+1]) {\\n                cost += s.size() - i - 1;\\n                /*\\n                for(int ii=i+1;ii< s.size();ii++) {\\n                    if(s[ii] == \\'1\\') {\\n                        s[ii] = \\'0\\';\\n                    } else {\\n                        s[ii] = \\'1\\';\\n                    }\\n                }\\n                */\\n            }\\n        }\\n        //cout << s << endl;\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long cost = 0;\\n        for(int i=s.size()/2; i > 0; i--) {\\n            if(s[i] != s[i-1]) {\\n                cost += i;\\n                /*\\n                for(int ii=0;ii<i;ii++) {\\n                    if(s[ii] == \\'1\\') {\\n                        s[ii] = \\'0\\';\\n                    } else {\\n                        s[ii] = \\'1\\';\\n                    }\\n                }\\n                */\\n            }\\n        }\\n        for(int i=s.size()/2; i < s.size() - 1; i++) {\\n            if(s[i] != s[i+1]) {\\n                cost += s.size() - i - 1;\\n                /*\\n                for(int ii=i+1;ii< s.size();ii++) {\\n                    if(s[ii] == \\'1\\') {\\n                        s[ii] = \\'0\\';\\n                    } else {\\n                        s[ii] = \\'1\\';\\n                    }\\n                }\\n                */\\n            }\\n        }\\n        //cout << s << endl;\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3572060,
                "title": "c-prefix-and-suffix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long minimumCost(string s) {\\n        ll ans=1e18;\\n        int n= s.size();\\n        vector<ll> pre(n,0),suf(n,0);\\n        pre[0]=0;\\n        suf[n-1]=0;\\n        for(int i=1;i<n;++i)\\n           pre[i]= pre[i-1] + (s[i] != s[i-1] ? i : 0);\\n        for(int i=n-2;i>=0;--i)\\n            suf[i]= suf[i+1] + (s[i] != s[i+1] ? (n-i-1) : 0);\\n        \\n        for(int i=0;i<n;i++)\\n            ans= min(ans, pre[i]+suf[i]);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long minimumCost(string s) {\\n        ll ans=1e18;\\n        int n= s.size();\\n        vector<ll> pre(n,0),suf(n,0);\\n        pre[0]=0;\\n        suf[n-1]=0;\\n        for(int i=1;i<n;++i)\\n           pre[i]= pre[i-1] + (s[i] != s[i-1] ? i : 0);\\n        for(int i=n-2;i>=0;--i)\\n            suf[i]= suf[i+1] + (s[i] != s[i+1] ? (n-i-1) : 0);\\n        \\n        for(int i=0;i<n;i++)\\n            ans= min(ans, pre[i]+suf[i]);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571935,
                "title": "fast-100-easy-explanation-greedy-o-n-clean-code-c",
                "content": "# Intuition\\nIt says we have to flip all the bits in a Binary string i.e (0,1) to make the string of same bits of:\\n* *Think Greedy*\\n\\n# Approach\\n* start traversing through the array\\n*  If you encounter different element i.e s[i] != s[i-1]:\\ncheck from which side it is feasible for us to take less move to make it equal min(i,n-i) either from the front or from the back.\\nMaintain a variable ans and keep on adding the min value required for us.\\n* finally return ans\\uD83D\\uDE0A\\n\\n# Complexity\\n- Time complexity: - 0(n)\\n\\n- Space complexity: - 0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        \\n     long long  int res=0;\\n       int n=s.size();\\n    \\n       for(int i=1;i<n;i++){\\n                  if(s[i]!=s[i-1]){\\n                      res+=min(n-i,i);\\n                  }\\n       }\\n       return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        \\n     long long  int res=0;\\n       int n=s.size();\\n    \\n       for(int i=1;i<n;i++){\\n                  if(s[i]!=s[i-1]){\\n                      res+=min(n-i,i);\\n                  }\\n       }\\n       return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571913,
                "title": "o-n-intution-expained-beats-100-people-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nactually by seeong minimization problem i thought this question we can do by recursion but i first tried of greedy approach first think like if we have an array of 0 and 1s of length n then we can make all its elemnys to either 1 or 0 but for changing we must think greedyly\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirstly think of a solution where u make all elemnts to 0 and after that all elemnts to 1 and we can take minimum of both answers\\nbut here coes a catch let length of arr is n=6 then if we want to make 0th index elemnt change from 9 to 1 or 1 to 0 it would be optimal to change all i elemnts and take i+1 score rather than changing n-1 to i elemnts and adding answer n-i so if we are we divide array to two halfs one left half other right half.\\nnow let us take an array =[011000] left=[011]right=[000]\\n# 1)convert all elemnts to 0:\\ntarverse from mid-1 th index if its not set to zero update answer with ans+=(i+1) change all elemnts from 0 to i but it would take n time approx for each step so keep a flag that says whether if its 0 then that value is not changed if its one then that value is changed do like this till we reach left end\\ntarverse from mid to last index and do same step here first keep flag to 0\\n# 2)convert all elemnts to 1:\\ndo smae as we done for 0 but here convert 0s to 1\\n# 3)after finding both asnwwrs return minimum:\\n#    PLEASE UPVOTE IF U LIKE\\n\\n\\n# Complexity\\n- Time complexity:\\n# - O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        if(s.length()==1)return 0;\\n        long long int ans=0;\\n        long long int ans2=0;\\n        int mid=s.length()/2;\\n        \\n        int flag=0;\\n        int flag2=0;\\n        for(int i=mid-1;i>=0 ;i--){\\n            if(s[i]==\\'1\\'){\\n                \\n                if(flag==0){\\n                ans+=(i+1);\\n                flag++;\\n                }\\n                if(flag2==1){\\n                ans2+=(i+1);\\n                flag2++;\\n                }\\n                \\n            }\\n            else{\\n                if(flag==1){\\n                ans+=(i+1);\\n                flag++;\\n                }\\n                if(flag2==0){\\n                ans2+=(i+1);\\n                flag2++;\\n                }\\n                \\n                \\n            }\\n            flag=flag%2;\\n            flag2=flag2%2;\\n        }\\n        flag=0;\\n        flag2=0;\\n        for(int i=mid;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                \\n                if(flag==0){\\n                ans+=(s.length()-i);\\n                    \\n                flag++;\\n                }\\n                 if(flag2==1){\\n                \\n                     ans2+=(s.length()-i);\\n                flag2++;\\n                }\\n            }\\n            else{\\n                if(flag==1){\\n                \\n                    ans+=(s.length()-i);\\n                flag++;\\n                }\\n                if(flag2==0){\\n               \\n                    ans2+=(s.length()-i);\\n                flag2++;\\n                }\\n                \\n            }\\n            flag=flag%2;\\n            flag2=flag2%2;\\n            \\n        }\\n        return min(ans,ans2);\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        if(s.length()==1)return 0;\\n        long long int ans=0;\\n        long long int ans2=0;\\n        int mid=s.length()/2;\\n        \\n        int flag=0;\\n        int flag2=0;\\n        for(int i=mid-1;i>=0 ;i--){\\n            if(s[i]==\\'1\\'){\\n                \\n                if(flag==0){\\n                ans+=(i+1);\\n                flag++;\\n                }\\n                if(flag2==1){\\n                ans2+=(i+1);\\n                flag2++;\\n                }\\n                \\n            }\\n            else{\\n                if(flag==1){\\n                ans+=(i+1);\\n                flag++;\\n                }\\n                if(flag2==0){\\n                ans2+=(i+1);\\n                flag2++;\\n                }\\n                \\n                \\n            }\\n            flag=flag%2;\\n            flag2=flag2%2;\\n        }\\n        flag=0;\\n        flag2=0;\\n        for(int i=mid;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                \\n                if(flag==0){\\n                ans+=(s.length()-i);\\n                    \\n                flag++;\\n                }\\n                 if(flag2==1){\\n                \\n                     ans2+=(s.length()-i);\\n                flag2++;\\n                }\\n            }\\n            else{\\n                if(flag==1){\\n                \\n                    ans+=(s.length()-i);\\n                flag++;\\n                }\\n                if(flag2==0){\\n               \\n                    ans2+=(s.length()-i);\\n                flag2++;\\n                }\\n                \\n            }\\n            flag=flag%2;\\n            flag2=flag2%2;\\n            \\n        }\\n        return min(ans,ans2);\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571851,
                "title": "swift-solution-using-iteration-over-string",
                "content": "# Code\\n```\\nclass Solution {\\n    func minimumCost(_ s: String) -> Int {\\n        let s = Array(s)\\n        var res = 0\\n\\n        for i in s.indices.dropFirst() where s[i] != s[i - 1] {\\n            res += min(i, s.count - i)\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumCost(_ s: String) -> Int {\\n        let s = Array(s)\\n        var res = 0\\n\\n        for i in s.indices.dropFirst() where s[i] != s[i - 1] {\\n            res += min(i, s.count - i)\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571844,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        int h=n/2;\\n        long long ans1=0,ans2=0;\\n        //to ones\\n        bool ch=0;\\n        for(int i=h-1;i>=0;i--){\\n            if(s[i]!=\\'1\\' && ch==0){ans1+=i+1;ch=!ch;}\\n            if(s[i]==\\'1\\' && ch){ans1+=i+1;ch=!ch;}\\n        }\\n        ch=0;\\n        for(int i=h;i<n;i++){\\n            if(s[i]!=\\'1\\' && ch==0){ans1+=n-i;ch=!ch;}\\n            if(s[i]==\\'1\\' && ch){ans1+=n-i;ch=!ch;}\\n        }\\n        //to zeros\\n        ch=0;\\n        for(int i=h-1;i>=0;i--){\\n            if(s[i]!=\\'0\\' && ch==0){ans2+=i+1;ch=!ch;}\\n            if(s[i]==\\'0\\' && ch){ans2+=i+1;ch=!ch;}\\n        }\\n        ch=0;\\n        for(int i=h;i<n;i++){\\n            if(s[i]!=\\'0\\' && ch==0){ans2+=n-i;ch=!ch;}\\n            if(s[i]==\\'0\\' && ch){ans2+=n-i;ch=!ch;}\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n // for(int i=1;i<h;i++){\\n        //     if(s[i]!=s[i-1])ans+=i;\\n        // }\\n        // for(int i=h;i<n-1;i++){\\n        //     if(s[i]!=s[i+1])ans+=n-i;\\n        // }\\n        // if(s[h-1]!=s[h])ans+=min(h,n-h);\\n        // return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        int h=n/2;\\n        long long ans1=0,ans2=0;\\n        //to ones\\n        bool ch=0;\\n        for(int i=h-1;i>=0;i--){\\n            if(s[i]!=\\'1\\' && ch==0){ans1+=i+1;ch=!ch;}\\n            if(s[i]==\\'1\\' && ch){ans1+=i+1;ch=!ch;}\\n        }\\n        ch=0;\\n        for(int i=h;i<n;i++){\\n            if(s[i]!=\\'1\\' && ch==0){ans1+=n-i;ch=!ch;}\\n            if(s[i]==\\'1\\' && ch){ans1+=n-i;ch=!ch;}\\n        }\\n        //to zeros\\n        ch=0;\\n        for(int i=h-1;i>=0;i--){\\n            if(s[i]!=\\'0\\' && ch==0){ans2+=i+1;ch=!ch;}\\n            if(s[i]==\\'0\\' && ch){ans2+=i+1;ch=!ch;}\\n        }\\n        ch=0;\\n        for(int i=h;i<n;i++){\\n            if(s[i]!=\\'0\\' && ch==0){ans2+=n-i;ch=!ch;}\\n            if(s[i]==\\'0\\' && ch){ans2+=n-i;ch=!ch;}\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n // for(int i=1;i<h;i++){\\n        //     if(s[i]!=s[i-1])ans+=i;\\n        // }\\n        // for(int i=h;i<n-1;i++){\\n        //     if(s[i]!=s[i+1])ans+=n-i;\\n        // }\\n        // if(s[h-1]!=s[h])ans+=min(h,n-h);\\n        // return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571720,
                "title": "c-greedy-full-explaination",
                "content": "# Approach\\nTake 2 cases i.e. either make all characters 0 or all characters 1 and take minimum answer of the two. Now to turn a character which is \\'1\\' to \\'0\\' at index i, we need to flip all indices from 0 to i and then to make the previous characters (before index i) back to their original values we need to flip all characters from 0 to i-1 index hence the total cost would be (i+1)+i, hence we  need to take minimum of the two cases i.e. flip from left end or right end and the minimum will be added in the answer. We have maintained two answers one for the case when we are turning every character to 0 if it is not and the other case is for turning every character to 1.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans1 = 0,ans2=0;\\n        int n = s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                long long tmp1 = i;\\n                int idx = i;\\n                while(i<n && s[i]==\\'1\\')\\n                    i++;\\n                tmp1+=i;\\n                long long tmp2 = n-idx+(n-i);\\n                ans1+=min(tmp1,tmp2);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                long long tmp1 = i;\\n                int idx = i;\\n                while(i<n && s[i]==\\'0\\')\\n                    i++;\\n                tmp1+=i;\\n                long long tmp2 = n-idx+(n-i);\\n                ans2+=min(tmp1,tmp2);\\n            }\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans1 = 0,ans2=0;\\n        int n = s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                long long tmp1 = i;\\n                int idx = i;\\n                while(i<n && s[i]==\\'1\\')\\n                    i++;\\n                tmp1+=i;\\n                long long tmp2 = n-idx+(n-i);\\n                ans1+=min(tmp1,tmp2);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                long long tmp1 = i;\\n                int idx = i;\\n                while(i<n && s[i]==\\'0\\')\\n                    i++;\\n                tmp1+=i;\\n                long long tmp2 = n-idx+(n-i);\\n                ans2+=min(tmp1,tmp2);\\n            }\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571707,
                "title": "easy-c-dp-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(string &s, int x, int count, long long**dp){\\n        if(x>=s.size())\\n            return 0;\\n        else if(dp[x][count]!=-1)\\n            return dp[x][count];\\n        long long ans=0;\\n        if(count==0){\\n            if(s[x]!=s[x-1])\\n                ans=ans+x;\\n            ans=ans+min(solve(s,x+1,1,dp),solve(s,x+1,0,dp));\\n        }else{\\n            \\n            if(s[x]!=s[x-1])\\n                ans=ans+s.size()-x;\\n            ans= ans+solve(s,x+1,1,dp);\\n           \\n        }\\n        dp[x][count]=ans;\\n         return ans;\\n    }\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n    long long** dp = new long long*[n];\\n \\n    for (int i = 0; i < n; i++) {\\n        dp[i] = new long long[2];\\n        for(int j=0;j<2;j++)\\n            dp[i][j]=-1;\\n    }\\n            \\n       return solve(s,1,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(string &s, int x, int count, long long**dp){\\n        if(x>=s.size())\\n            return 0;\\n        else if(dp[x][count]!=-1)\\n            return dp[x][count];\\n        long long ans=0;\\n        if(count==0){\\n            if(s[x]!=s[x-1])\\n                ans=ans+x;\\n            ans=ans+min(solve(s,x+1,1,dp),solve(s,x+1,0,dp));\\n        }else{\\n            \\n            if(s[x]!=s[x-1])\\n                ans=ans+s.size()-x;\\n            ans= ans+solve(s,x+1,1,dp);\\n           \\n        }\\n        dp[x][count]=ans;\\n         return ans;\\n    }\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n    long long** dp = new long long*[n];\\n \\n    for (int i = 0; i < n; i++) {\\n        dp[i] = new long long[2];\\n        for(int j=0;j<2;j++)\\n            dp[i][j]=-1;\\n    }\\n            \\n       return solve(s,1,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571638,
                "title": "good-question-great-solution-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        return min(countCost(s,\\'1\\'),countCost(s,\\'0\\'));      \\n    }\\n\\n    long long countCost(string& s,char ch){\\n        long long sum = 0;\\n        int n = s.size();\\n        char c= ch;\\n        for(int i=n/2;i>=0;i--){\\n            if(s[i]==c){\\n                sum+=(i+1);\\n                c = c==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n        }\\n        c = ch;\\n        for(int i=n/2+1;i<n;i++){\\n            if(s[i]==c){\\n                sum+=(n-i);\\n                c = c==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        return min(countCost(s,\\'1\\'),countCost(s,\\'0\\'));      \\n    }\\n\\n    long long countCost(string& s,char ch){\\n        long long sum = 0;\\n        int n = s.size();\\n        char c= ch;\\n        for(int i=n/2;i>=0;i--){\\n            if(s[i]==c){\\n                sum+=(i+1);\\n                c = c==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n        }\\n        c = ch;\\n        for(int i=n/2+1;i<n;i++){\\n            if(s[i]==c){\\n                sum+=(n-i);\\n                c = c==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571610,
                "title": "c-1-liner-with-linq",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public long MinimumCost(string s)\\n    {\\n        return Enumerable.Range(1, s.Length - 1)\\n            .Where(i => s[i - 1] != s[i])\\n            .Select(i => (long)Math.Min(i, s.Length - i))\\n            .Sum();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long MinimumCost(string s)\\n    {\\n        return Enumerable.Range(1, s.Length - 1)\\n            .Where(i => s[i - 1] != s[i])\\n            .Select(i => (long)Math.Min(i, s.Length - i))\\n            .Sum();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571540,
                "title": "easy-python-solution-missed-this-approach-in-leetcode-challenge",
                "content": "# AT EVERY IND CHECK IF WE SHOULD FLIP THE PREFIX INDEXES OR SUFFIX INDEXES BASED ON WHICH IS LESS.\\n# HAPPY LEETCODING !\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \\n        ans=0\\n        for i in range(1,len(s)):\\n            if s[i]!=s[i-1]:\\n                ans+=min(i,len(s)-i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \\n        ans=0\\n        for i in range(1,len(s)):\\n            if s[i]!=s[i-1]:\\n                ans+=min(i,len(s)-i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571529,
                "title": "c-dp-solution",
                "content": "```\\n/*\\n    Let f(i,0/1,0/1) denote the minimum cost of setting all the first i elements to 0/1 and having an odd/even number of flips to the right\\n    \\nDecision 1: No flipping\\n    f(i,w,t) = f(i-1,w,t)                       w = t^si\\nDecision 2: Flip to the left only\\n    f(i,0,t) = f(i-1,1,t) + i                   t^si == 1\\n    f(i,1,t) = f(i-1,0,t) + i                   t^si == 0\\nDecision 3: Flip to the right only\\n    f(i,0,t^1) = f(i-1,0,t) + (n+1-i)           t^si == 1\\n    f(i,1,t^1) = f(i-1,1,t) + (n+1-i)           t^si == 0\\nDecision 4: Flip on each side\\n    f(i,1,t^1) = f(i-1,0,t) + (n+1)             t^si == 1\\n    f(i,0,t^1) = f(i-1,1,t) + (n+1)             t^si == 0\\n    \\n*/\\n```\\n\\n\\n```\\ntypedef long long       ll;\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {               int n = s.size();   s = \"#\" + s;\\n    \\n        ll  f[2][2][2];\\n        memset(f, 0x3f, sizeof(f));\\n        f[0][0][0] = 0;\\n        f[0][1][0] = 0;\\n                     \\n        int x = 0, w = 0;\\n        for (int i = 1; i <= n; i++) {                  x ^= 1;\\n            for (int t = 0; t <= 1; t++) {              w = t ^ (s[i]-\\'0\\');                       \\n                f[x][w][t]      = min(f[x][w][t],       f[1-x][w][t]);                  // Decision 1\\n                f[x][w^1][t]    = min(f[x][w^1][t],     f[1-x][w][t] + i);              // Decision 2\\n                f[x][w^1][t^1]  = min(f[x][w^1][t^1],   f[1-x][w^1][t] + (n+1-i));      // Decision 3\\n                f[x][w][t^1]    = min(f[x][w][t^1],     f[1-x][w][t] + (n+1));          // Decision 4\\n            }\\n            memset(f[1-x], 0x3f, sizeof(f[1-x]));\\n        }\\n                    \\n        ll  ans = LLONG_MAX;\\n        for (int w = 0; w <= 1; w++) {\\n            for (int t = 0; t <= 1; t++) ans = min(ans, f[x][w][t]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Let f(i,0/1,0/1) denote the minimum cost of setting all the first i elements to 0/1 and having an odd/even number of flips to the right\\n    \\nDecision 1: No flipping\\n    f(i,w,t) = f(i-1,w,t)                       w = t^si\\nDecision 2: Flip to the left only\\n    f(i,0,t) = f(i-1,1,t) + i                   t^si == 1\\n    f(i,1,t) = f(i-1,0,t) + i                   t^si == 0\\nDecision 3: Flip to the right only\\n    f(i,0,t^1) = f(i-1,0,t) + (n+1-i)           t^si == 1\\n    f(i,1,t^1) = f(i-1,1,t) + (n+1-i)           t^si == 0\\nDecision 4: Flip on each side\\n    f(i,1,t^1) = f(i-1,0,t) + (n+1)             t^si == 1\\n    f(i,0,t^1) = f(i-1,1,t) + (n+1)             t^si == 0\\n    \\n*/\\n```\n```\\ntypedef long long       ll;\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {               int n = s.size();   s = \"#\" + s;\\n    \\n        ll  f[2][2][2];\\n        memset(f, 0x3f, sizeof(f));\\n        f[0][0][0] = 0;\\n        f[0][1][0] = 0;\\n                     \\n        int x = 0, w = 0;\\n        for (int i = 1; i <= n; i++) {                  x ^= 1;\\n            for (int t = 0; t <= 1; t++) {              w = t ^ (s[i]-\\'0\\');                       \\n                f[x][w][t]      = min(f[x][w][t],       f[1-x][w][t]);                  // Decision 1\\n                f[x][w^1][t]    = min(f[x][w^1][t],     f[1-x][w][t] + i);              // Decision 2\\n                f[x][w^1][t^1]  = min(f[x][w^1][t^1],   f[1-x][w^1][t] + (n+1-i));      // Decision 3\\n                f[x][w][t^1]    = min(f[x][w][t^1],     f[1-x][w][t] + (n+1));          // Decision 4\\n            }\\n            memset(f[1-x], 0x3f, sizeof(f[1-x]));\\n        }\\n                    \\n        ll  ans = LLONG_MAX;\\n        for (int w = 0; w <= 1; w++) {\\n            for (int t = 0; t <= 1; t++) ans = min(ans, f[x][w][t]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571520,
                "title": "simple-traversal-beats-100-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to make either all 0s and all 1s\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe do 1st operation on the first half of the string and second operation for the second half of the string,for both having all 0s and all 1s and the operation is sum with first half and second half,and take minimum of converting to 0s and converting to 1s\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    long long help(string s,char ch){\\n        long long ans=0,i;\\n        int n=s.size();\\n        bool correct=true;\\n//first half\\n        for(i=n/2-1;i>-1;--i){\\n            if(correct&&s[i]!=ch){\\n                ans+=i+1;\\n                correct=false;\\n            }\\n            else if(!correct&&s[i]==ch){\\n                ans+=i+1;\\n                correct=true;\\n            }\\n        }\\n//correct is used so that we dont have to invert all the 0s and 1s \\n//everytime we apply an operation\\n        long long ans2=0;\\n        correct=true;\\n        int x=s.size()/2;\\n        if(x&1)++x;\\n//second half\\n        for(i=n/2;i<n;++i){\\n            if(correct&&s[i]!=ch){\\n                ans2+=n-i;\\n                correct=false;\\n            }\\n            else if(!correct&&s[i]==ch){\\n                ans2+=n-i;\\n                correct=true;\\n            }\\n        }\\n\\n        return ans+ans2;\\n\\n    }\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=LLONG_MAX;\\n        ans=min(ans,help(s,\\'0\\'));\\n        ans=min(ans,help(s,\\'1\\'));\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long help(string s,char ch){\\n        long long ans=0,i;\\n        int n=s.size();\\n        bool correct=true;\\n//first half\\n        for(i=n/2-1;i>-1;--i){\\n            if(correct&&s[i]!=ch){\\n                ans+=i+1;\\n                correct=false;\\n            }\\n            else if(!correct&&s[i]==ch){\\n                ans+=i+1;\\n                correct=true;\\n            }\\n        }\\n//correct is used so that we dont have to invert all the 0s and 1s \\n//everytime we apply an operation\\n        long long ans2=0;\\n        correct=true;\\n        int x=s.size()/2;\\n        if(x&1)++x;\\n//second half\\n        for(i=n/2;i<n;++i){\\n            if(correct&&s[i]!=ch){\\n                ans2+=n-i;\\n                correct=false;\\n            }\\n            else if(!correct&&s[i]==ch){\\n                ans2+=n-i;\\n                correct=true;\\n            }\\n        }\\n\\n        return ans+ans2;\\n\\n    }\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=LLONG_MAX;\\n        ans=min(ans,help(s,\\'0\\'));\\n        ans=min(ans,help(s,\\'1\\'));\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571512,
                "title": "c-from-constraints-get-idea-of-linear-traversal-keep-past-traversed-substr-chars-equal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length(),i;\\n        long long cost=0;\\n        for(i=1;i<n;i++) if(s[i-1]!=s[i]) cost+=min(i,n-i);\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length(),i;\\n        long long cost=0;\\n        for(i=1;i<n;i++) if(s[i-1]!=s[i]) cost+=min(i,n-i);\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571496,
                "title": "just-a-2-line-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1]){\\n                if(i+1>s.size()-i-1){\\n                    ans+=s.size()-i-1;\\n                }\\n                else{\\n                    ans+=i+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1]){\\n                if(i+1>s.size()-i-1){\\n                    ans+=s.size()-i-1;\\n                }\\n                else{\\n                    ans+=i+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571486,
                "title": "very-easy-simple-one-loop-greedy-solution-beginner-friendly-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    private:\\n    int mini(int a,int b)\\n    {\\n        if(a>=b)return b;\\n        return a;\\n    }\\npublic:\\n    long long minimumCost(string s) \\n    {\\n       long long ans=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]!=s[i+1])\\n            {\\n                int temp=mini(s.size()-i-1,i+1);\\n                ans+=temp; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int mini(int a,int b)\\n    {\\n        if(a>=b)return b;\\n        return a;\\n    }\\npublic:\\n    long long minimumCost(string s) \\n    {\\n       long long ans=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]!=s[i+1])\\n            {\\n                int temp=mini(s.size()-i-1,i+1);\\n                ans+=temp; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571433,
                "title": "c-easiest-solution-beating-100-in-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        int n = s.length();\\n        long long ans = 0;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]!=s[i-1])\\n            {\\n                int mini = min(i,n-i);\\n                ans+=mini;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        int n = s.length();\\n        long long ans = 0;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]!=s[i-1])\\n            {\\n                int mini = min(i,n-i);\\n                ans+=mini;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571403,
                "title": "easy-c-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nclass Solution { \\npublic:\\n    long long minimumCost(string s) {\\n        long long count=0; \\n        for (int i=0; i<s.size()-1; i++){\\n            if (s[i]!=s[i+1]){\\n                count+=min(i+1, (int)s.size()-i-1);\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nclass Solution { \\npublic:\\n    long long minimumCost(string s) {\\n        long long count=0; \\n        for (int i=0; i<s.size()-1; i++){\\n            if (s[i]!=s[i+1]){\\n                count+=min(i+1, (int)s.size()-i-1);\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3571374,
                "title": "greedy-approach-with-detailed-explanation-best-code-for-new-users-one-line-code",
                "content": "# Intuition Detailed Explained code for the new users\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Greedy\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity \\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        //AUTHOR::MOHD FAISAL FROM INDIA\\n        long long ans=0;\\n        //HERE FIRST DECLARE THE VARIABLE THAT WILL BE OUR ANSWER\\n        for(int i=0;i<s.size()-1;i++) //A LOOP FOR CHECKING EVERY INDEX\\n        {\\n            if(s[i]!=s[i+1])\\n            {\\n                /*\\n                SUPPOSE THE STRING IS LIKE \"111000101\"\\n                NOW WE KNOW THAT FOR i=2 s[2]=\\'1\\',and S[3]=\\'0\\';\\n                FIRST CASE 1:\\n                SO EITHER WE WILL CHANGE ALL THE ELEMENT \\n                BEFORE i=2 TO THE \\'0\\' AND THAT OPERATION \\n                WILL COST i+1;\\n                SECOND CASE 2:(VERY IMPORTANT)\\n                HERE WE WILL GIVE CHANGE THE i+1(NOTE THAT IS NOT i)\\n                TO THE EVERY ELEMENT THAT ARE SAME BEFORE i\\n                IN THIS CASE ABOVE EXAMLE THAT IS \"111\" AND HERE \\n                WE ARE CHANGING THE S[3] WHICH IS \\'0\\' WE HAVE TO\\n                CHANGE S[3]=\\'0\\' TO THE \\'1\\' BUT HERE NOTE THAT \\n                ACCORDING TO  QUESTION CRITERIA WE CAN NOT\\n                CHANGE ONLY A SPECIFIC INDEX FROM \\'0\\' TO \\'1\\' AND\\n                VICE VERSA,IN THIS CASE WE CANNOT CHANGE ONLY S[3] \\n                FROM \\'0\\' TO \\'1\\'{EITHER CHANGE ALL INDEX FROM 0 to \\n                (i+1) OR ALL INDEX FROM (i+1) TO (n-(1))}               \\n                HERE WE HAVE TO CHANGE ALL THE ELEMENT FROM\\n                i+1 to n-1 AND ACCORDING TO THE QUESTION THAT WILL\\n                COST n-(i+1)\\n                [NOTE THAT :: HERE AGAIN INDEX IS NOT i HERE INDEX IS i+1(IMP)]\\n                NOW FOR EACH INDEX WHERE( i!=(i+1) ) WE HAVE TO ADD \\n                THE MINIMUM OF THE SITUATION 1 AND 2 TO OUR INITIALLY\\n                DECLARED VARIABLE\\n                NOW THE AFTER A LOOP WE HAVE CHECKED EVERY INDEX\\n                NOW VALUE OF ans(VARIABLE) WILL BE OUR FINAL ANSWER\\n*/\\n                int a=(i+1);  //CASE 1 COST\\n                int b=s.size()-(i+1); //CASE 2 COST\\n                ans=ans+(min(a,b));  //ADDING THE MINIMUM OF CASE 1 AND CASE 2 TO OUR DECLARED VARIABLE\\n            }\\n        }\\n      return ans; //RETURNING THE ANSWER\\n      /*\\n      HAPPY CODING,THANKS FOR WACTHING THE SOLUTION \\n      PLEASE UPVOTE\\n      HAPPY CODING\\n    LOVE FOR ALL HATRED FOR NONE\\n        */\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        //AUTHOR::MOHD FAISAL FROM INDIA\\n        long long ans=0;\\n        //HERE FIRST DECLARE THE VARIABLE THAT WILL BE OUR ANSWER\\n        for(int i=0;i<s.size()-1;i++) //A LOOP FOR CHECKING EVERY INDEX\\n        {\\n            if(s[i]!=s[i+1])\\n            {\\n                /*\\n                SUPPOSE THE STRING IS LIKE \"111000101\"\\n                NOW WE KNOW THAT FOR i=2 s[2]=\\'1\\',and S[3]=\\'0\\';\\n                FIRST CASE 1:\\n                SO EITHER WE WILL CHANGE ALL THE ELEMENT \\n                BEFORE i=2 TO THE \\'0\\' AND THAT OPERATION \\n                WILL COST i+1;\\n                SECOND CASE 2:(VERY IMPORTANT)\\n                HERE WE WILL GIVE CHANGE THE i+1(NOTE THAT IS NOT i)\\n                TO THE EVERY ELEMENT THAT ARE SAME BEFORE i\\n                IN THIS CASE ABOVE EXAMLE THAT IS \"111\" AND HERE \\n                WE ARE CHANGING THE S[3] WHICH IS \\'0\\' WE HAVE TO\\n                CHANGE S[3]=\\'0\\' TO THE \\'1\\' BUT HERE NOTE THAT \\n                ACCORDING TO  QUESTION CRITERIA WE CAN NOT\\n                CHANGE ONLY A SPECIFIC INDEX FROM \\'0\\' TO \\'1\\' AND\\n                VICE VERSA,IN THIS CASE WE CANNOT CHANGE ONLY S[3] \\n                FROM \\'0\\' TO \\'1\\'{EITHER CHANGE ALL INDEX FROM 0 to \\n                (i+1) OR ALL INDEX FROM (i+1) TO (n-(1))}               \\n                HERE WE HAVE TO CHANGE ALL THE ELEMENT FROM\\n                i+1 to n-1 AND ACCORDING TO THE QUESTION THAT WILL\\n                COST n-(i+1)\\n                [NOTE THAT :: HERE AGAIN INDEX IS NOT i HERE INDEX IS i+1(IMP)]\\n                NOW FOR EACH INDEX WHERE( i!=(i+1) ) WE HAVE TO ADD \\n                THE MINIMUM OF THE SITUATION 1 AND 2 TO OUR INITIALLY\\n                DECLARED VARIABLE\\n                NOW THE AFTER A LOOP WE HAVE CHECKED EVERY INDEX\\n                NOW VALUE OF ans(VARIABLE) WILL BE OUR FINAL ANSWER\\n*/\\n                int a=(i+1);  //CASE 1 COST\\n                int b=s.size()-(i+1); //CASE 2 COST\\n                ans=ans+(min(a,b));  //ADDING THE MINIMUM OF CASE 1 AND CASE 2 TO OUR DECLARED VARIABLE\\n            }\\n        }\\n      return ans; //RETURNING THE ANSWER\\n      /*\\n      HAPPY CODING,THANKS FOR WACTHING THE SOLUTION \\n      PLEASE UPVOTE\\n      HAPPY CODING\\n    LOVE FOR ALL HATRED FOR NONE\\n        */\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571328,
                "title": "time-100-java-12ms-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        // Original: 0100100\\n        // Step 1: 1100101\\n        // Step 2: 0000101\\n        // Step 3: 0000010\\n        // Step 4: 0000001\\n        // Step 5: 0000000\\n        long cost = 0;\\n        for (int i = 0; i < s.length()-1; ++i) {\\n            if(s.charAt(i) != s.charAt(i+1)) {\\n                if (invertFront(i, s))\\n                    cost += i + 1;\\n                else\\n                    cost += s.length() - i - 1;\\n            }\\n        }\\n        return cost;\\n    }\\n    public boolean invertFront(int idx, String s) {\\n        // In order to make charAt(idx) and charAt(idx+1) equals,\\n        // Compare the cost of inverting front and back,\\n        // To determine should invert front or back of string.\\n        return idx + 1 < s.length() - idx - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        // Original: 0100100\\n        // Step 1: 1100101\\n        // Step 2: 0000101\\n        // Step 3: 0000010\\n        // Step 4: 0000001\\n        // Step 5: 0000000\\n        long cost = 0;\\n        for (int i = 0; i < s.length()-1; ++i) {\\n            if(s.charAt(i) != s.charAt(i+1)) {\\n                if (invertFront(i, s))\\n                    cost += i + 1;\\n                else\\n                    cost += s.length() - i - 1;\\n            }\\n        }\\n        return cost;\\n    }\\n    public boolean invertFront(int idx, String s) {\\n        // In order to make charAt(idx) and charAt(idx+1) equals,\\n        // Compare the cost of inverting front and back,\\n        // To determine should invert front or back of string.\\n        return idx + 1 < s.length() - idx - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571314,
                "title": "simple-c-video",
                "content": "\\n    using ll = long long;\\n    class Solution {\\n    public:\\n    \\n    ll solve(string s, char c) {\\n        \\n        int n = s.size();\\n        \\n        ll sum = 0;\\n\\n        char ch  = c;\\n        \\n        for(int i = n/2; i >= 0; --i) {\\n            if(s[i] == ch) {\\n                sum += i+1;\\n                if(ch == \\'1\\') ch = \\'0\\'; else ch = \\'1\\';\\n            }\\n        }\\n \\n        ch = c;\\n        for(int i = n/2+1; i < n; ++i) {\\n            if(s[i] == ch) {\\n                sum += n - i;\\n                if(ch == \\'1\\') ch = \\'0\\' ;else ch = \\'1\\';\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    \\n    \\n    ll minimumCost(string s) {\\n\\n        \\n        return min(solve(s, \\'0\\'), solve(s, \\'1\\'));\\n\\n        \\n    }\\n};\\nhttps://youtu.be/zxJ2Zq_r2IQ",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\n    ll solve(string s, char c) {\\n        \\n        int n = s.size();\\n        \\n        ll sum = 0;\\n\\n        char ch  = c;\\n        \\n        for(int i = n/2; i >= 0; --i) {\\n            if(s[i] == ch) {\\n                sum += i+1;\\n                if(ch == \\'1\\') ch = \\'0\\'; else ch = \\'1\\';\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1908191,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1910225,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1908427,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1908777,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1908279,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 2019329,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1910341,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1908411,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1908366,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if The Number is Fascinating",
        "question_content": "<p>You are given an integer <code>n</code> that consists of exactly <code>3</code> digits.</p>\n\n<p>We call the number <code>n</code> <strong>fascinating</strong> if, after the following modification, the resulting number contains all the digits from <code>1</code> to <code>9</code> <strong>exactly</strong> once and does not contain any <code>0</code>&#39;s:</p>\n\n<ul>\n\t<li><strong>Concatenate</strong> <code>n</code> with the numbers <code>2 * n</code> and <code>3 * n</code>.</li>\n</ul>\n\n<p>Return <code>true</code><em> if </em><code>n</code><em> is fascinating, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p><strong>Concatenating</strong> two numbers means joining them together. For example, the concatenation of <code>121</code> and <code>371</code> is <code>121371</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 192\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We concatenate the numbers n = 192 and 2 * n = 384 and 3 * n = 576. The resulting number is 192384576. This number contains all the digits from 1 to 9 exactly once.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 100\n<strong>Output:</strong> false\n<strong>Explanation:</strong> We concatenate the numbers n = 100 and 2 * n = 200 and 3 * n = 300. The resulting number is 100200300. This number does not satisfy any of the conditions.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>100 &lt;= n &lt;= 999</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3622458,
                "title": "using-set-very-simple-and-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution</b>\\n# Approach\\nTake a set to check total number of uniqe char in the final string.\\nIn the set check :\\n- if the total unique char count is 9\\n- if the total size of the string s is 9\\n- if there is no \\'0\\' in the string\\n\\n# Code\\n```\\nbool isFascinating(int n) {\\n    string s = to_string(n) + to_string(n*2) + to_string(n*3);\\n    unordered_set<char> st(s.begin(), s.end());\\n    return (st.size() == 9 && s.size() == 9 && st.find(\\'0\\') == st.end() );\\n}\\n```\\n<b>Here is an article of my recent interview experience at Amazon, you may like :\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool isFascinating(int n) {\\n    string s = to_string(n) + to_string(n*2) + to_string(n*3);\\n    unordered_set<char> st(s.begin(), s.end());\\n    return (st.size() == 9 && s.size() == 9 && st.find(\\'0\\') == st.end() );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623681,
                "title": "easy-python-code-beats-100-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        def pan(num):\\n            if sorted(list(num))==[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]:\\n                return(True)\\n            else:\\n                return False\\n        n=str(n)+str(n*2)+str(n*3)\\n        return pan(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        def pan(num):\\n            if sorted(list(num))==[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]:\\n                return(True)\\n            else:\\n                return False\\n        n=str(n)+str(n*2)+str(n*3)\\n        return pan(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622454,
                "title": "bits-o-1-space",
                "content": "We just traverse all digits in all `3` numbers & use `bit manipulation` to check if every digit is between `[1, 9]`.\\n# C++\\n    bool isFascinating(int n) {\\n        int freq = 0;\\n        function<bool(int)> repd = [&](int n) {\\n            while(n) {\\n                int d = n % 10;\\n                if(d == 0 || (freq >> d & 1)) return false;\\n                freq |= (1 << d);\\n                n /= 10;\\n            }\\n            return true;\\n        };\\n        return repd(n) and repd(2 * n) and repd(3 * n);\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "We just traverse all digits in all `3` numbers & use `bit manipulation` to check if every digit is between `[1, 9]`.\\n# C++\\n    bool isFascinating(int n) {\\n        int freq = 0;\\n        function<bool(int)> repd = [&](int n) {\\n            while(n) {\\n                int d = n % 10;\\n                if(d == 0 || (freq >> d & 1)) return false;\\n                freq |= (1 << d);\\n                n /= 10;\\n            }\\n            return true;\\n        };\\n        return repd(n) and repd(2 * n) and repd(3 * n);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3622291,
                "title": "3-lines-c-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string str= to_string(n)+to_string(2*n)+to_string(3*n);\\n        sort(str.begin(),str.end());\\n        return str == \"123456789\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string str= to_string(n)+to_string(2*n)+to_string(3*n);\\n        sort(str.begin(),str.end());\\n        return str == \"123456789\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625115,
                "title": "c-2-different-approaches-o-1-tc",
                "content": "# Approach 1: do the work at compile time\\nThe property of being _fascinating_ doesn\\'t change, hence we can pre compute them at compile time. ```::isFascinating``` is inspired by [this post](https://leetcode.com/problems/check-if-the-number-is-fascinating/discuss/3622454/Bits-(O(1)-Space)).\\n\\n```cpp\\nnamespace {\\nconstexpr bool isFascinating(int n) {\\n    int seen = 0;\\n    auto check = [&](int n) -> bool {\\n        while (n) {\\n            const int d =  n % 10;\\n            n /= 10;\\n            const int mask = 1 << d;\\n            if (d == 0 || seen & mask) return false;\\n            seen |= mask;\\n        }\\n        return true;\\n    };\\n    return check(n) && check(2 * n) && check(3 * n);\\n}\\n\\nconstexpr array<bool, 1000> gen_isF() {\\n    array<bool, 1000> ans = {};\\n    for (int i = 100; i < 1000; ++i) \\n        ans[i] = isFascinating(i);\\n    return ans;\\n}\\n    \\nconstexpr array<bool, 1000> isF = gen_isF();\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n    static bool isFascinating(int n) {\\n        return isF[n];\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n* Time complexity is $$O(1)$$ and\\n\\n* Space comlexity is $$O(1)$$, even if we need to keep an array of 1000 booleans around.\\n\\n# Approach 2: hard code it\\nIt turns out there are only 4 _fascinating_ numbers: 192, 219, 273, and 327. We can just hard code that. Maybe that\\'s consider cheating. :)\\n\\n```cpp\\n    bool isFascinating(int n) {\\n        return n == 192 || n == 219 || n == 273 || n == 327;\\n    }\\n```\\n\\nIt\\'s interesting how the compiler generates something that looks like binary search for this: https://godbolt.org/z/P9cr7fnE9\\n\\n**Complexity Analysis**\\n* Time complexity is $$O(1)$$ and\\n\\n* Space comlexity is $$O(1)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```::isFascinating```\n```cpp\\nnamespace {\\nconstexpr bool isFascinating(int n) {\\n    int seen = 0;\\n    auto check = [&](int n) -> bool {\\n        while (n) {\\n            const int d =  n % 10;\\n            n /= 10;\\n            const int mask = 1 << d;\\n            if (d == 0 || seen & mask) return false;\\n            seen |= mask;\\n        }\\n        return true;\\n    };\\n    return check(n) && check(2 * n) && check(3 * n);\\n}\\n\\nconstexpr array<bool, 1000> gen_isF() {\\n    array<bool, 1000> ans = {};\\n    for (int i = 100; i < 1000; ++i) \\n        ans[i] = isFascinating(i);\\n    return ans;\\n}\\n    \\nconstexpr array<bool, 1000> isF = gen_isF();\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n    static bool isFascinating(int n) {\\n        return isF[n];\\n    }\\n};\\n```\n```cpp\\n    bool isFascinating(int n) {\\n        return n == 192 || n == 219 || n == 273 || n == 327;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622804,
                "title": "python-3-2-versions-t-m-89-71",
                "content": "Version 1: string manipulation\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool: \\n\\n        return \\'\\'.join(sorted(str(n) + str(2*n) + str(3*n))) ==  \\'123456789\\'\\n```\\nVersion 2: Mathematics. It\\'s an interesting number theory exercise to show that*:\\n- a number`n`is *fascinating* only if `123 <= n <= 329`, and\\n- `n`must be cyclic permutations of the digits of 192 or 273. \\n\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n      \\n        return n in {192, 219, 273, 327}\\n```\\n\\n[https://leetcode.com/problems/check-if-the-number-is-fascinating/submissions/968255394/](http://)\\n\\nI could be wrong, but I think that for each version,  time complexity is *O*(1) and space complexity is *O*(1).\\n\\n*(Edit 6/14/23) By request, here is are the steps to how this assertion can be justified. We will need to use that:\\na) n, 2n and 3n are each three distinct digits (which gives us the inequality`123 <= n <= 329`); and \\nb) digit sums mod 9 are invariant under artihmetic operations (you may want to wiki \"Casting Out Nines.\")\\n\\nStep 1: The three digits of *n* must be one each of 0, 1, and 2 mod 3\\nStep 2: The most significant digit of *n* is 1,2, or 3.\\nStep 3: The three digits of *n* must be two odd and one even.\\nStep 4: The 0 mod 3 digit of *n* must be either 3 or 9.\\nStep 5: The largest digit of *n* must be either 7 or 9, but 7 and 9 cannot be the two odd digits.\\nStep 6: The three digits of *n* must contain 1 or 7, but 1 and 7 cannot be the two odd digits.\\nStep 7: The even digit of *n* must be 2.\\nStep 8: Conclude that only two sets of digits for *n* are 1,2,9 and 2,3,7, of which only 192, 219, 273, and 327 satisfy the necessary conditions.\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool: \\n\\n        return \\'\\'.join(sorted(str(n) + str(2*n) + str(3*n))) ==  \\'123456789\\'\\n```\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n      \\n        return n in {192, 219, 273, 327}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622760,
                "title": "most-efficient-o-1",
                "content": "There are just 4 numbers which satisfy this condition. TC->O(1)\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        return n == 192 || n == 219 || n==273 || n==327;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        return n == 192 || n == 219 || n==273 || n==327;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622474,
                "title": "100-98-beats-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string str = \"\";\\n        int a = n*2,b=n*3;\\n        str = to_string(n)+to_string(a)+to_string(b);\\n        vector<int> v(10,0);\\n        for(auto &i: str){\\n            v[i-\\'0\\']++;\\n        }\\n        for(int i = 0; i < 10; i++){\\n            if(i==0){\\n                if(v[i])return false;\\n            }else{\\n                if(v[i]!=1)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string str = \"\";\\n        int a = n*2,b=n*3;\\n        str = to_string(n)+to_string(a)+to_string(b);\\n        vector<int> v(10,0);\\n        for(auto &i: str){\\n            v[i-\\'0\\']++;\\n        }\\n        for(int i = 0; i < 10; i++){\\n            if(i==0){\\n                if(v[i])return false;\\n            }else{\\n                if(v[i]!=1)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622436,
                "title": "one-liner-easiest",
                "content": "\\n<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI sort the input number in string and then matched with the desired outcome. \\n\\n# Code\\n```js\\nconst isFascinating = (n) => \"123456789\" === `${n}${n * 2}${n * 3}`.split(\"\").sort().join(\"\")\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```js\\nconst isFascinating = (n) => \"123456789\" === `${n}${n * 2}${n * 3}`.split(\"\").sort().join(\"\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3622379,
                "title": "easy-and-clean-solution-beginner-freindly-python3",
                "content": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        s = str(n)\\n        \\n        s = s + str(2*n) + str(3*n)\\n    \\n        ans = set(s)\\n\\n        return len(ans) == 9 == len(s) and \\'0\\' not in ans\\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        s = str(n)\\n        \\n        s = s + str(2*n) + str(3*n)\\n    \\n        ans = set(s)\\n\\n        return len(ans) == 9 == len(s) and \\'0\\' not in ans\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3623077,
                "title": "3-lines-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        \\n        string s = to_string(n) + to_string(n * 2) + to_string(n * 3);\\n        sort(s.begin(), s.end());\\n\\n        if(s == \"123456789\") return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        \\n        string s = to_string(n) + to_string(n * 2) + to_string(n * 3);\\n        sort(s.begin(), s.end());\\n\\n        if(s == \"123456789\") return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622340,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem asks us to determine whether a given three-digit number is fascinating or not. To be fascinating, the number must meet certain conditions after concatenating it with 2 * n and 3 * n. The conditions are that the resulting concatenated number should contain all digits from 1 to 9 exactly once and should not contain any zeros.\\n\\n\\n# Approach\\nTo solve the problem, we first concatenate the given number n with 2 * n and 3 * n. We convert these numbers to strings and concatenate them together. This gives us the concatenated string.\\n\\nNext, we check if the concatenated string contains any zeros. If it does, we immediately return false, as zeros are not allowed in the fascinating number.\\n\\nThen, we check if the length of the concatenated string is greater than 9. If it is, that means the concatenated string contains duplicate digits or additional digits beyond 1 to 9. In such a case, we return false.\\n\\nFinally, we iterate through the digits from 1 to 9 and check if each digit is present in the concatenated string. If any digit is missing, we return false. Otherwise, we return true, indicating that the number is fascinating.\\n\\n\\n# Complexity\\n- Time complexity:\\nTime complexity: The time complexity of this approach is O(1) because the number of iterations and operations performed is constant, regardless of the input size. We are iterating through a fixed range (1 to 9) and performing a constant number of operations for each iteration.\\n\\n\\n- Space complexity:\\nSpace complexity: The space complexity is also O(1) because we are not using any additional data structures that grow with the input size. The space required is only for storing the concatenated string, which is of constant size since we are concatenating three fixed-size numbers.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        concatenated = str(n) + str(2 * n) + str(3 * n)\\n\\n        if \\'0\\' in concatenated:\\n            return False\\n        if len(concatenated)>9:\\n            return False\\n        for i in range(1,10):\\n            if str(i) not in concatenated :\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        concatenated = str(n) + str(2 * n) + str(3 * n)\\n\\n        if \\'0\\' in concatenated:\\n            return False\\n        if len(concatenated)>9:\\n            return False\\n        for i in range(1,10):\\n            if str(i) not in concatenated :\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755310,
                "title": "java-solution-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a number n, we need to check whether every digit from 1 to 9 is present in the number which is formed connecting n + 2 * n + 3 * n.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the code we have made a string s, in which we have stored the number n, 2 * n and 3 * n in string format. We then have created a array of size 9 containing all elements equal to 1. We then ran a for loop till the length of string and checking the value of element at the index (s.charAt(i) - \\'0\\') - 1 if it is equal to 1 then changing it to zero and if already equal to 0 then returning false which means a number is repeated in the string. And also checking that (s.charAt(i) - \\'0\\') - 1 should be greater than 0 because if less than 0 will give a error as there is no index -1 or less in the array.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n\\n        String s = String.valueOf(n) + String.valueOf(2*n) + String.valueOf(3*n);\\n\\n        int[] arr = new int[9];\\n        Arrays.fill(arr,1);\\n\\n        for(int i=0;i<s.length();i++){\\n            int j = s.charAt(i) - \\'0\\';\\n            if(j-1<0){\\n                return false;\\n            }\\n            if(arr[j-1] == 0){\\n                return false;\\n            }else{\\n                arr[j-1] = 0;\\n            }\\n        }\\n\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]!=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n}\\n```\\n\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/96683108-fa6b-4899-825c-6216059f5ff0_1689172819.995048.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n\\n        String s = String.valueOf(n) + String.valueOf(2*n) + String.valueOf(3*n);\\n\\n        int[] arr = new int[9];\\n        Arrays.fill(arr,1);\\n\\n        for(int i=0;i<s.length();i++){\\n            int j = s.charAt(i) - \\'0\\';\\n            if(j-1<0){\\n                return false;\\n            }\\n            if(arr[j-1] == 0){\\n                return false;\\n            }else{\\n                arr[j-1] = 0;\\n            }\\n        }\\n\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]!=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623045,
                "title": "c-java-bitwise-operations-for-efficient-digit-tracking",
                "content": "We the process by concatenating `n`, `2*n`, and `3*n`. Following this, it verifies that the concatenated string\\'s length is strictly `9`. If not, it directly returns `false`, as it\\'s not possible for the number to incorporate all digits from `1` to `9` individually.\\n\\nSubsequently, a `state` variable is defined, initialized to `0`. This will be used to track each digit from `1` to`9` in the concatenated number. The function proceeds with a loop, examining each character in the string, and performing two checks:\\n\\n* If the character equals `0`, the function directly returns false. This is because a fascinating number should not include any zeroes.\\n\\n* We also check whether the same digit has been encountered previously using bitwise operations. If the current digit\\'s corresponding bit in the `state` variable is already 1, it denotes that the digit has been encountered before, and the function immediately returns false.\\n\\nIn the event that neither of these conditions is met, the function adjusts the `state` variable, setting the current digit\\'s corresponding bit to `1` using bitwise operations.\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string s = to_string(n) + to_string(2 * n) + to_string(3 * n);\\n        if (s.length() != 9) return false;\\n        int state = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            int c = s[i] - \\'0\\';\\n            if (c == 0 || ((state >> c) & 1) == 1) return false;\\n            state |= (1 << c);\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(n).append(2 * n).append(3 * n);\\n        if (sb.length() != 9) return false;\\n        int state = 0;\\n        for (int i = 0; i < sb.length(); i++) {\\n            int c = sb.charAt(i) - \\'0\\';\\n            if (c == 0 || ((state >> c) & 1) == 1) return false;\\n            state |= (1 << c); \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string s = to_string(n) + to_string(2 * n) + to_string(3 * n);\\n        if (s.length() != 9) return false;\\n        int state = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            int c = s[i] - \\'0\\';\\n            if (c == 0 || ((state >> c) & 1) == 1) return false;\\n            state |= (1 << c);\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(n).append(2 * n).append(3 * n);\\n        if (sb.length() != 9) return false;\\n        int state = 0;\\n        for (int i = 0; i < sb.length(); i++) {\\n            int c = sb.charAt(i) - \\'0\\';\\n            if (c == 0 || ((state >> c) & 1) == 1) return false;\\n            state |= (1 << c); \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622850,
                "title": "python-elegant-short-counter",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    DIGITS = Counter(\\'123456789\\')\\n\\n    def isFascinating(self, n: int) -> bool:\\n        return Counter(str(n) + str(2 * n) + str(3 * n)) == self.DIGITS\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    DIGITS = Counter(\\'123456789\\')\\n\\n    def isFascinating(self, n: int) -> bool:\\n        return Counter(str(n) + str(2 * n) + str(3 * n)) == self.DIGITS\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622714,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        String str = String.valueOf(n) + String.valueOf(2*n) + String.valueOf(3*n);\\n        HashSet<Integer> set = new HashSet<>();\\n        System.out.println(str);\\n        for(int i=0;i<str.length();i++){\\n            int ch = str.charAt(i)-\\'0\\';      \\n            if(ch == 0){   \\n                return false;\\n            }else{\\n                if(set.contains(ch)){\\n                    return false;\\n                }else{\\n                    set.add(ch);\\n                if(set.size()==9) return true;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        String str = String.valueOf(n) + String.valueOf(2*n) + String.valueOf(3*n);\\n        HashSet<Integer> set = new HashSet<>();\\n        System.out.println(str);\\n        for(int i=0;i<str.length();i++){\\n            int ch = str.charAt(i)-\\'0\\';      \\n            if(ch == 0){   \\n                return false;\\n            }else{\\n                if(set.contains(ch)){\\n                    return false;\\n                }else{\\n                    set.add(ch);\\n                if(set.size()==9) return true;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705673,
                "title": "power-of-javascript-using-string-interpolation-and-sorting",
                "content": "# Complexity\\n- Time complexity: O(Nlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isFascinating(n: number): boolean {\\n    let allNumbers = \\'123456789\\'\\n    let fancyNumber = `${n}${n * 2}${n * 3}`.split(\"\").sort().join(\"\")\\n    if(allNumbers == fancyNumber){\\n        return true\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nfunction isFascinating(n: number): boolean {\\n    let allNumbers = \\'123456789\\'\\n    let fancyNumber = `${n}${n * 2}${n * 3}`.split(\"\").sort().join(\"\")\\n    if(allNumbers == fancyNumber){\\n        return true\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3695452,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string num1 = to_string(2*n);\\n        string num2 = to_string(3*n);\\n        string s = to_string(n);\\n\\n        string ans = s + num1 + num2;\\n        unordered_map<char,int> mp;\\n\\n        for(auto it : ans){\\n            mp[it]++;\\n        }\\n\\n        for(auto it : mp){\\n            if(it.first==\\'0\\' || it.second>1) return false;\\n        }\\n\\n        return mp.size()==9;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string num1 = to_string(2*n);\\n        string num2 = to_string(3*n);\\n        string s = to_string(n);\\n\\n        string ans = s + num1 + num2;\\n        unordered_map<char,int> mp;\\n\\n        for(auto it : ans){\\n            mp[it]++;\\n        }\\n\\n        for(auto it : mp){\\n            if(it.first==\\'0\\' || it.second>1) return false;\\n        }\\n\\n        return mp.size()==9;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690286,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        s=str(n)+str(n*2)+str(n*3)\\n        k=\"123456789\"\\n        return set(s)==set(k) and len(s)==9\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        s=str(n)+str(n*2)+str(n*3)\\n        k=\"123456789\"\\n        return set(s)==set(k) and len(s)==9\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668241,
                "title": "beginners-approach",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n     String res= (n)+\"\"+(n*2)+\"\"+(n*3);\\n     \\n\\n     \\n\\n     if(res.contains(\"0\")) return false;\\n     if(res.length()>9) return false;\\n     HashSet<Character> set= new HashSet<>();\\n     for(int i=0;i<res.length();i++){\\n         char c= res.charAt(i);\\n         set.add(c);\\n     }\\n\\n     return set.size()==9 ? true: false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n     String res= (n)+\"\"+(n*2)+\"\"+(n*3);\\n     \\n\\n     \\n\\n     if(res.contains(\"0\")) return false;\\n     if(res.length()>9) return false;\\n     HashSet<Character> set= new HashSet<>();\\n     for(int i=0;i<res.length();i++){\\n         char c= res.charAt(i);\\n         set.add(c);\\n     }\\n\\n     return set.size()==9 ? true: false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622595,
                "title": "simplest-python-solution-1-2-liner",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        s = str(n)+str(2*n)+str(3*n)\\n        return len(s) == 9 and max(Counter(s).values()) == 1 and \\'0\\' not in Counter(s).keys()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        s = str(n)+str(2*n)+str(3*n)\\n        return len(s) == 9 and max(Counter(s).values()) == 1 and \\'0\\' not in Counter(s).keys()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622563,
                "title": "python3-solution-with-explanation",
                "content": "We have to check if a resulting string contains unique digits except for zero. \\nThe first condition cuts off cases when there are more digits than needed: \\nFor example, n = 334, then we have \\'3346681002\\'. Length of this string is 10, but we should have a maximum of 9 digits.\\nThe second one is obvious, so as not to get zero when multiplied by 2.\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        if n > 333:\\n            return False\\n        \\n        if n % 10 == 5 or n % 10 == 0:\\n            return False\\n        \\n        num = str(n) + str(2 * n) + str(3 * n)\\n        \\n        return len(set(num)) == len(num) and \\'0\\' not in num\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        if n > 333:\\n            return False\\n        \\n        if n % 10 == 5 or n % 10 == 0:\\n            return False\\n        \\n        num = str(n) + str(2 * n) + str(3 * n)\\n        \\n        return len(set(num)) == len(num) and \\'0\\' not in num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875946,
                "title": "using-sprintf-method-functions-mania-but-simple",
                "content": "# Intuition\\nAt the starting of solve this problem, i thought i can done this problem without using any built-in functions.But it is more tideous, so that i used the functions like sprintf(),strcat(),atoi().\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Calculate `two_N` and `three_N`: The function calculates `two_N` and `three_N`, which are the results of multiplying the input `n` by 2 and 3, respectively.\\n\\n2. Convert integers to strings: Three character arrays `s0`, `s1`, and `s2` are used to store the string representations of `n`, `two_N`, and `three_N`, respectively. The `sprintf()` function is used to convert the integers into strings and store them in these arrays.\\n\\n3. Concatenate the strings: The strings `s1` and `s2` are concatenated using the `strcat()` function, resulting in a new string that contains the digits of `two_N` followed by the digits of `three_N`.\\n\\n4. Concatenate again and convert back to integer: The string `s1` (with digits of `two_N` and `three_N`) is then concatenated with the string `s0` (with digits of `n`). The resulting string is converted back to an integer using the `atoi()` function, and the result is stored in the `res` variable.\\n\\n5. Check for fascinating property: The code then iterates over digits from 1 to 9 (using the variable `i`). For each digit, it checks if it appears exactly once in the `res` integer. If it finds a digit that is not present or appears more than once, it returns `false`, indicating that `n` is not a fascinating number.\\n\\n6. Count fascinating digits: The code counts the number of digits that appear exactly once in `res` for all digits from 1 to 9. If all digits appear exactly once, the variable `num` is incremented.\\n\\n7. Check the final result: Finally, the code checks if `num` is equal to 9 (since there are 9 digits from 1 to 9). If `num` is equal to 9, it means all digits from 1 to 9 appear exactly once in the `res` integer, and the function returns `true`, indicating that `n` is a fascinating number. Otherwise, it returns `false`.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![images.jpg](https://assets.leetcode.com/users/images/adda409b-7631-401b-9ad3-8df3031280f3_1691399743.314916.jpeg)\\n\\n# Code\\n```\\nbool isFascinating(int n){\\nint two_N=2*n;\\nint three_N=3*n;\\nchar s0[100],s1[50],s2[50];\\nsprintf(s0,\"%d\",n); // sprintf() is used to assign number to char array[]\\nsprintf(s1,\"%d\",two_N);\\nsprintf(s2,\"%d\",three_N);\\nstrcat(s1,s2); // concatenate the strings\\nstrcat(s0,s1);\\nint res=atoi(s0); // atoi() is used to convert the string respresentation to integer \\nint rem,temp,num=0,count=0;\\nfor(int i=1;i<=9;i++)\\n{\\nint temp=res;\\nwhile(temp>0)\\n{\\n    rem=temp%10;\\n    if(rem==0) return false;\\n    else\\n    {\\n        if(rem==i) count++;\\n    }\\n    temp/=10;\\n}\\nif(count==1) num++;\\ncount=0;\\n}\\nif(num==9) return true;\\nelse return false;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nbool isFascinating(int n){\\nint two_N=2*n;\\nint three_N=3*n;\\nchar s0[100],s1[50],s2[50];\\nsprintf(s0,\"%d\",n); // sprintf() is used to assign number to char array[]\\nsprintf(s1,\"%d\",two_N);\\nsprintf(s2,\"%d\",three_N);\\nstrcat(s1,s2); // concatenate the strings\\nstrcat(s0,s1);\\nint res=atoi(s0); // atoi() is used to convert the string respresentation to integer \\nint rem,temp,num=0,count=0;\\nfor(int i=1;i<=9;i++)\\n{\\nint temp=res;\\nwhile(temp>0)\\n{\\n    rem=temp%10;\\n    if(rem==0) return false;\\n    else\\n    {\\n        if(rem==i) count++;\\n    }\\n    temp/=10;\\n}\\nif(count==1) num++;\\ncount=0;\\n}\\nif(num==9) return true;\\nelse return false;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823789,
                "title": "worst-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        return n == 192 || n == 219 || n == 273 || n == 327;\\n    }\\n}\\n```\\n![\\u043F\\u04352.jpg](https://assets.leetcode.com/users/images/5ecc1b5b-8a66-4bef-a27b-d8884c51a9e2_1690462296.7836988.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        return n == 192 || n == 219 || n == 273 || n == 327;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786674,
                "title": "java-100-faster-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        boolean[] fascinating = new boolean[10];\\n        int n2 = 2 * n;\\n        int n3 = 3 * n;\\n        while(n > 0) {\\n            fascinating[n % 10] = true;\\n            fascinating[n2 % 10] = true;\\n            fascinating[n3 % 10] = true;\\n            n /= 10;\\n            n2 /= 10;\\n            n3 /= 10;\\n        }\\n        for(int i = 1; i < 10; i ++)\\n           if(! fascinating[i]) return false;\\n        return true;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        boolean[] fascinating = new boolean[10];\\n        int n2 = 2 * n;\\n        int n3 = 3 * n;\\n        while(n > 0) {\\n            fascinating[n % 10] = true;\\n            fascinating[n2 % 10] = true;\\n            fascinating[n3 % 10] = true;\\n            n /= 10;\\n            n2 /= 10;\\n            n3 /= 10;\\n        }\\n        for(int i = 1; i < 10; i ++)\\n           if(! fascinating[i]) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780521,
                "title": "check-if-the-number-is-fascinating-time-complexity-o-log-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate a HashMap to keep track of the digits encountered during the checks.\\n\\nCompute 2*n and 3*n.\\n\\nIterate through the digits of n, 2*n, and 3*n, one by one.\\n\\nFor each digit encountered, check if it is already present in the HashMap or if it is equal to 0. If so, return false as it violates the fascinating condition.\\n\\nIf the digit is not already in the HashMap, add it to the HashMap.\\n\\nRepeat steps 3 to 5 for all digits in n, 2*n, and 3*n.\\n\\nIf all digits are unique and not equal to 0 in the HashMap, return true, indicating that the number is fascinating.\\n\\nIf any violation is found during the checks, return false.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        HashMap<Integer, Integer> m = new HashMap<>();\\n\\n        int a = 2*n;\\n        int b = 3*n;\\n        while(n >0){\\n            int r = n%10;\\n            if(m.containsKey(r) || r == 0){\\n                return false;\\n            }\\n            else{\\n                m.put(r,1);\\n            }\\n            n = n/10;\\n\\n        }\\n        while(a >0){\\n            int r = a%10;\\n            if(m.containsKey(r) || r==0){\\n                return false;\\n            }\\n            else{\\n                m.put(r,1);\\n            }                        \\n            a = a/10;\\n\\n        }\\n        while(b >0){\\n            int r = b%10;\\n            if(m.containsKey(r) || r==0){\\n                return false;\\n            }\\n            else{\\n                m.put(r,1);\\n            }            \\n            b = b/10;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        HashMap<Integer, Integer> m = new HashMap<>();\\n\\n        int a = 2*n;\\n        int b = 3*n;\\n        while(n >0){\\n            int r = n%10;\\n            if(m.containsKey(r) || r == 0){\\n                return false;\\n            }\\n            else{\\n                m.put(r,1);\\n            }\\n            n = n/10;\\n\\n        }\\n        while(a >0){\\n            int r = a%10;\\n            if(m.containsKey(r) || r==0){\\n                return false;\\n            }\\n            else{\\n                m.put(r,1);\\n            }                        \\n            a = a/10;\\n\\n        }\\n        while(b >0){\\n            int r = b%10;\\n            if(m.containsKey(r) || r==0){\\n                return false;\\n            }\\n            else{\\n                m.put(r,1);\\n            }            \\n            b = b/10;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759306,
                "title": "c-brute-force-beginner-friendly-sorting-o-n-log-n",
                "content": "**Intuition**\\nThe code checks if a number n is fascinating or not. To determine this, it concatenates n, 2*n, and 3*n into a single string and sorts it. By iterating through the sorted string, if any digit is \\'0\\' or there are repeated digits, the number is not fascinating. Otherwise, it is considered fascinating.\\n\\n**Time Complexity**\\nThe time complexity of sorting an array of size n using a comparison-based sorting algorithm, such as the one used in the std::sort function, is generally O(n log n). The for loop iterates through the sorted string, which also takes O(n) time.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        // Create variables for 2*n and 3*n.\\n        int n2 = 2 * n;\\n        int n3 = 3 * n;\\n        \\n        // Convert the numbers to strings.\\n        string s = to_string(n);\\n        string s2 = to_string(n2);\\n        string s3 = to_string(n3);\\n\\n        // Concatenate the strings.\\n        string ans = s + s2 + s3;\\n        \\n        // Sort the concatenated string.\\n        sort(ans.begin(), ans.end());\\n        \\n        // Check for \\'0\\' or repeated digits.\\n        for (int i = 0; i < ans.size() - 1; i++) {\\n            if (ans[i] == \\'0\\' || ans[i] == ans[i + 1]) {\\n                return false;\\n            }\\n        }\\n        \\n        return true; \\n    }\\n};\\n```\\n\\nPlease consider upvoting and leaving any comments or feedback if you found the solution helpful. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        // Create variables for 2*n and 3*n.\\n        int n2 = 2 * n;\\n        int n3 = 3 * n;\\n        \\n        // Convert the numbers to strings.\\n        string s = to_string(n);\\n        string s2 = to_string(n2);\\n        string s3 = to_string(n3);\\n\\n        // Concatenate the strings.\\n        string ans = s + s2 + s3;\\n        \\n        // Sort the concatenated string.\\n        sort(ans.begin(), ans.end());\\n        \\n        // Check for \\'0\\' or repeated digits.\\n        for (int i = 0; i < ans.size() - 1; i++) {\\n            if (ans[i] == \\'0\\' || ans[i] == ans[i + 1]) {\\n                return false;\\n            }\\n        }\\n        \\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754818,
                "title": "java-solution-using-hashset",
                "content": "\\n# Approach\\n1.Create a string(ans) which store the resultant string after concatenate.\\n2.Create a Hashset which will store elements of string uniquely later.\\n3.Now chech if ans contains \"0\" if yes return false. Also check if length of ans is greater than 9 if yes return false.\\n4.Now iterate in ans and check if set already contains a element return false. Else add the element in the string.\\n5.Now check if the size of hashset is 9 then return true. Else return false. \\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n      String ans = String.valueOf(n) + String.valueOf(2*n) + String.valueOf(3*n);  \\n        // int a = 2*n;\\n        // int b = 3*n;\\n        // String str = Integer.toString(n);\\n        // String str1 = Integer.toString(a);\\n        // String str2 = Integer.toString(b);\\n        // String ans = str+str1+str2;\\n\\n        HashSet<Character> h = new HashSet<>();\\n    \\n       if(ans.contains(\"0\")) return false;\\n       if(ans.length()>9) return false;\\n       for(int i=0; i<ans.length(); i++){\\n           char ch = ans.charAt(i);\\n           if(h.contains(ch)){\\n               return false;\\n           }else{\\n               h.add(ch);\\n           }\\n       }\\n       if(h.size()==9){\\n       return true;\\n       }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n      String ans = String.valueOf(n) + String.valueOf(2*n) + String.valueOf(3*n);  \\n        // int a = 2*n;\\n        // int b = 3*n;\\n        // String str = Integer.toString(n);\\n        // String str1 = Integer.toString(a);\\n        // String str2 = Integer.toString(b);\\n        // String ans = str+str1+str2;\\n\\n        HashSet<Character> h = new HashSet<>();\\n    \\n       if(ans.contains(\"0\")) return false;\\n       if(ans.length()>9) return false;\\n       for(int i=0; i<ans.length(); i++){\\n           char ch = ans.charAt(i);\\n           if(h.contains(ch)){\\n               return false;\\n           }else{\\n               h.add(ch);\\n           }\\n       }\\n       if(h.size()==9){\\n       return true;\\n       }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737838,
                "title": "check-if-the-number-is-fascinating-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int a = n*2;\\n        int b = n*3;\\n        String s = n+\"\"+a+\"\"+b;\\n\\n        if(s.length() < 8){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'0\\'){\\n                return false;\\n            }\\n            for(int j= i+1; j<s.length(); j++){\\n                if(s.charAt(i) == s.charAt(j) ){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int a = n*2;\\n        int b = n*3;\\n        String s = n+\"\"+a+\"\"+b;\\n\\n        if(s.length() < 8){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'0\\'){\\n                return false;\\n            }\\n            for(int j= i+1; j<s.length(); j++){\\n                if(s.charAt(i) == s.charAt(j) ){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698665,
                "title": "c-easy-to-understand-solution-using-sets",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Converting the number to string is first step.\\n2. Adding all the characters to a set as it contains only unique characters.\\n3. The size of string and set must be exactly equal to 9 i.e. it contains all the digits from 1 to 9 exactly once.\\n4. Last thing to check is that 0 is not present in the set.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string res = to_string(n);\\n        res += to_string(2*n);\\n        res += to_string(3*n);\\n        \\n        unordered_set<char> us(res.begin(),res.end());\\n       \\n        if(us.size() == 9 && res.size() == 9 && us.find(\\'0\\') == us.end()) \\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string res = to_string(n);\\n        res += to_string(2*n);\\n        res += to_string(3*n);\\n        \\n        unordered_set<char> us(res.begin(),res.end());\\n       \\n        if(us.size() == 9 && res.size() == 9 && us.find(\\'0\\') == us.end()) \\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695479,
                "title": "easy-solution-using-set",
                "content": "```\\n\\n    void check(int n,string& temp)\\n    {\\n         while(n!=0)\\n        {\\n            temp.push_back((n%10)+\\'0\\');\\n            n=n/10;\\n        }\\n    }\\n    \\n    bool isFascinating(int n) \\n    {\\n        string temp;\\n        set<int> s;\\n        int num=n;\\n        \\n        check(num,temp);\\n        \\n        int t1 = n*2;\\n        check(t1,temp);\\n        int t2 = 3*n;\\n        check(t2,temp);\\n        \\n        for(int i=0;i<temp.size();i++)\\n        {\\n            int x = temp[i]-\\'0\\';\\n            if(s.find(x)!=s.end() || x==0)\\n            {\\n                return false;\\n            }\\n            else\\n            {\\n                s.insert(x);\\n            }\\n        }\\n     return true;    \\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    void check(int n,string& temp)\\n    {\\n         while(n!=0)\\n        {\\n            temp.push_back((n%10)+\\'0\\');\\n            n=n/10;\\n        }\\n    }\\n    \\n    bool isFascinating(int n) \\n    {\\n        string temp;\\n        set<int> s;\\n        int num=n;\\n        \\n        check(num,temp);\\n        \\n        int t1 = n*2;\\n        check(t1,temp);\\n        int t2 = 3*n;\\n        check(t2,temp);\\n        \\n        for(int i=0;i<temp.size();i++)\\n        {\\n            int x = temp[i]-\\'0\\';\\n            if(s.find(x)!=s.end() || x==0)\\n            {\\n                return false;\\n            }\\n            else\\n            {\\n                s.insert(x);\\n            }\\n        }\\n     return true;    \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677098,
                "title": "c-simplest-solution-using-frequency",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n\\n        if(n >= 334) return false;\\n\\n        vector<int> freq(10, 0);\\n\\n        string temp = to_string(n);\\n        n = 2 * n;\\n        temp += to_string(n);\\n        n = n/2 * 3;\\n        temp += to_string(n);\\n\\n        cout << temp << endl;\\n\\n        for(int i=0; i<temp.size(); i++) {\\n            freq[temp[i] - \\'0\\']++;\\n            if(temp[i] == \\'0\\' || freq[temp[i] - \\'0\\'] > 1) return false;\\n        }\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n\\n        if(n >= 334) return false;\\n\\n        vector<int> freq(10, 0);\\n\\n        string temp = to_string(n);\\n        n = 2 * n;\\n        temp += to_string(n);\\n        n = n/2 * 3;\\n        temp += to_string(n);\\n\\n        cout << temp << endl;\\n\\n        for(int i=0; i<temp.size(); i++) {\\n            freq[temp[i] - \\'0\\']++;\\n            if(temp[i] == \\'0\\' || freq[temp[i] - \\'0\\'] > 1) return false;\\n        }\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3661768,
                "title": "100-fast-simple-solution",
                "content": "# Intuition\\nThere are few such number between 100-999\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        if(n==192){\\n            return true;\\n        }\\n        else if(n==273){\\n            return true;\\n        }\\n        else if(n==327){\\n            return true;   \\n        }\\n        else if(n==219){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        if(n==192){\\n            return true;\\n        }\\n        else if(n==273){\\n            return true;\\n        }\\n        else if(n==327){\\n            return true;   \\n        }\\n        else if(n==219){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654795,
                "title": "python3-easy-and-fast-5-lines",
                "content": "# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        num = str(n)\\n        num += str(2 * n)\\n        num += str(3 * n)\\n        counts = [num.count(x) for x in num]\\n        return \"0\" not in num and counts.count(1) == len(counts)\\n```\\n![image.png](https://assets.leetcode.com/users/images/a7e473d2-17a6-446a-bef2-df5bd3ca82ba_1687148819.7501976.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/e1619ae5-35a7-4b6c-bcb9-66b1716d4211_1687148841.0468395.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        num = str(n)\\n        num += str(2 * n)\\n        num += str(3 * n)\\n        counts = [num.count(x) for x in num]\\n        return \"0\" not in num and counts.count(1) == len(counts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627893,
                "title": "java-simple-solution-no-string-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean isFascinating(int n) {\\n        boolean[] facinatingDigits = new boolean[10];\\n        int n2 = 2 * n;\\n        int n3 = 3 * n;\\n        while (n > 0) {\\n            facinatingDigits[n % 10] = true;\\n            facinatingDigits[n2 % 10] = true;\\n            facinatingDigits[n3 % 10] = true;\\n            n /= 10;\\n            n2 /= 10;\\n            n3 /= 10;\\n        }\\n        for (int i = 1; i < facinatingDigits.length; i++) {\\n            if (!facinatingDigits[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean isFascinating(int n) {\\n        boolean[] facinatingDigits = new boolean[10];\\n        int n2 = 2 * n;\\n        int n3 = 3 * n;\\n        while (n > 0) {\\n            facinatingDigits[n % 10] = true;\\n            facinatingDigits[n2 % 10] = true;\\n            facinatingDigits[n3 % 10] = true;\\n            n /= 10;\\n            n2 /= 10;\\n            n3 /= 10;\\n        }\\n        for (int i = 1; i < facinatingDigits.length; i++) {\\n            if (!facinatingDigits[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626198,
                "title": "simple-and-easy-to-understand-cpp-solution",
                "content": "# Intuition\\nThe code checks if a given number n is fascinating or not by following a specific approach. It concatenates n, 2n, and 3n, sorts the resulting string, and then checks for any repeated digits or zeros. If there are any repeated digits or zeros, the number is considered not fascinating.\\n\\n# Approach\\n- Multiply the given number n by 2 and 3 to obtain n2 and n3, respectively.\\n- Convert n, n2, and n3 to strings using the to_string function.\\n- Concatenate the three strings (s, s2, and s3) to form a single string called ans.\\n- **Sort the characters in the ans string in ascending order using the sort function**.\\n- Iterate through each character in ans from the beginning to the second-to-last character.\\n    - If the current character is \\'0\\' or the same as the next character, return false as the fascinating property is violated.\\n- If no violations are found during the iteration, return true, indicating that the number n is fascinating.\\n\\nIn summary, the code **concatenates the string** representations of n, 2n, and 3n, **sorts the resulting string**, and checks for any **repeated digits or zeros**. This approach efficiently determines whether a number is fascinating or not based on the defined properties\\n\\n# Complexity\\n- Time complexity:\\n**O(nlogn)**\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n\\n        int n2 = 2*n;\\n        int n3 = 3*n;\\n\\n        string s = to_string(n);\\n        string s2 = to_string(n2);\\n        string s3 = to_string(n3);\\n\\n        string ans = s+s2+s3;\\n        sort(ans.begin(), ans.end());\\n        for(int i=0; i<ans.length()-1;i++){\\n            if(ans[i] == \\'0\\' || ans[i] == ans[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n\\n        int n2 = 2*n;\\n        int n3 = 3*n;\\n\\n        string s = to_string(n);\\n        string s2 = to_string(n2);\\n        string s3 = to_string(n3);\\n\\n        string ans = s+s2+s3;\\n        sort(ans.begin(), ans.end());\\n        for(int i=0; i<ans.length()-1;i++){\\n            if(ans[i] == \\'0\\' || ans[i] == ans[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625764,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool isFascinating(int n) \\n    {\\n        int n2=2*n;\\n        int n3=3*n;\\n        string s=to_string(n)+to_string(n2)+to_string(n3);\\n        set<char> st;\\n        for(auto ch: s) \\n        {\\n            if(ch==\\'0\\') return false;\\n            st.insert(ch);\\n        }\\n        return st.size()==9 && s.size()==9;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isFascinating(int n) \\n    {\\n        int n2=2*n;\\n        int n3=3*n;\\n        string s=to_string(n)+to_string(n2)+to_string(n3);\\n        set<char> st;\\n        for(auto ch: s) \\n        {\\n            if(ch==\\'0\\') return false;\\n            st.insert(ch);\\n        }\\n        return st.size()==9 && s.size()==9;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623607,
                "title": "1-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        return sorted(str(n)+str(n*2)+str(n*3))==[str(i) for i in range(1,10)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Sort",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        return sorted(str(n)+str(n*2)+str(n*3))==[str(i) for i in range(1,10)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623355,
                "title": "video-solution-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsorting will be the hero\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) fimd the actual number after computation in string form\\n2) sort the string\\n3) check the duplicate or zero value \\n\\nclick to see the video solution\\n[click me](https://youtu.be/-mx_Q4tdVRI)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int m = 2*n;\\n        int p = 3*n;\\n        string a = to_string(n);\\n        string b = to_string(m);\\n        string c = to_string(p);\\n        string ans  = a+b+c;\\n        sort(ans.begin(), ans.end());\\n        bool flag = 0;\\n        int num = ans.size();\\n        for(int i=0;i<num-1;i++){\\n             if(ans[i]==\\'0\\'){\\n                flag = 1;\\n                break;\\n            }\\n            if(ans[i]==ans[i+ 1]){\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if(flag == 1){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n        \\n        \\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int m = 2*n;\\n        int p = 3*n;\\n        string a = to_string(n);\\n        string b = to_string(m);\\n        string c = to_string(p);\\n        string ans  = a+b+c;\\n        sort(ans.begin(), ans.end());\\n        bool flag = 0;\\n        int num = ans.size();\\n        for(int i=0;i<num-1;i++){\\n             if(ans[i]==\\'0\\'){\\n                flag = 1;\\n                break;\\n            }\\n            if(ans[i]==ans[i+ 1]){\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if(flag == 1){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n        \\n        \\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623242,
                "title": "simple-beginners-friendly-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        \\n        string s1 = to_string(n);\\n        string s2 = to_string(2*n);\\n        string s3 = to_string(3*n);\\n        \\n        string s = s1 + s2 + s3;\\n        \\n        unordered_map<char, int> mp;\\n        \\n        for(auto c: s){\\n            if(mp[c] == 1 || c == \\'0\\'){\\n                return false;\\n            }\\n            mp[c] =1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        \\n        string s1 = to_string(n);\\n        string s2 = to_string(2*n);\\n        string s3 = to_string(3*n);\\n        \\n        string s = s1 + s2 + s3;\\n        \\n        unordered_map<char, int> mp;\\n        \\n        for(auto c: s){\\n            if(mp[c] == 1 || c == \\'0\\'){\\n                return false;\\n            }\\n            mp[c] =1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622813,
                "title": "java-easy-solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n      int a = 2 * n;\\n      int b = 3 * n;\\n      String s =\"\";\\n      s=s+a+b+n;\\n      long arr[] = new long[10];\\n      for(int i = 0;i<s.length();i++){\\n        arr[s.charAt(i)-\\'0\\']++;\\n\\n      }\\n      int count = 0;\\n      if(arr[0] >= 1){\\n        return false;\\n      }\\n      for(int i =1;i<arr.length;i++){\\n        if(arr[i] == 0){\\n          count++;\\n        }\\n        if(arr[i] > 1){\\n          return false;\\n        }\\n      }\\n      if(count > 0)\\n        return false;\\n        return true;\\n      \\n      \\n      \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n      int a = 2 * n;\\n      int b = 3 * n;\\n      String s =\"\";\\n      s=s+a+b+n;\\n      long arr[] = new long[10];\\n      for(int i = 0;i<s.length();i++){\\n        arr[s.charAt(i)-\\'0\\']++;\\n\\n      }\\n      int count = 0;\\n      if(arr[0] >= 1){\\n        return false;\\n      }\\n      for(int i =1;i<arr.length;i++){\\n        if(arr[i] == 0){\\n          count++;\\n        }\\n        if(arr[i] > 1){\\n          return false;\\n        }\\n      }\\n      if(count > 0)\\n        return false;\\n        return true;\\n      \\n      \\n      \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622674,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        return sorted(str(n)+str(2*n)+str(3*n))==list(map(str,range(1,10)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        return sorted(str(n)+str(2*n)+str(3*n))==list(map(str,range(1,10)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622345,
                "title": "very-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string s=to_string(n);\\n        string s1=to_string(2*n);\\n        string s2=to_string(3*n);\\n        string s3=s+s1+s2;\\n        vector<int>vis(10000,0);\\n        for(int i=0;i<s3.size();i++){\\n            vis[s3[i]-\\'0\\']++;\\n        }\\n        if(vis[0])return false;\\n        for(int i=1;i<9999;i++){\\n            if(vis[i]>1)return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string s=to_string(n);\\n        string s1=to_string(2*n);\\n        string s2=to_string(3*n);\\n        string s3=s+s1+s2;\\n        vector<int>vis(10000,0);\\n        for(int i=0;i<s3.size();i++){\\n            vis[s3[i]-\\'0\\']++;\\n        }\\n        if(vis[0])return false;\\n        for(int i=1;i<9999;i++){\\n            if(vis[i]>1)return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622344,
                "title": "c-o-1-full-explanation-easy-solution-with-comments",
                "content": "\\n# Approach\\n- Convert the input number n into a string str.\\n- Compute n2 = 2 * n and n3 = 3 * n.\\n- Concatenate str with the strings representing n2 and n3.\\n- Initialize an array digitCount of size 10 to keep track of the count of each digit from 0 to 9.\\n- Iterate through each character in string.\\n-If the character is \\'0\\', return false as fascinating numbers should not contain any zeros.\\n-Increment the count of the corresponding digit in digitCount.\\n-Check if each digit from 1 to 9 appears exactly once in digitCount. If not, return false.\\n-If all conditions are satisfied, return true as the number is fascinating.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n    string str = to_string(n);\\n    int n2 = n * 2;\\n    int n3 = n * 3;\\n    str += to_string(n2);\\n    str += to_string(n3);\\n\\n    vector<int> digitCount(10); // count of each digit from 0 to 9\\n\\n    for (int i = 0; i < str.size(); i++) {\\n        if (str[i] == \\'0\\')\\n            return false; // If any digit is 0, return false\\n        digitCount[str[i] - \\'0\\']++;\\n    }\\n\\n    for (int i = 1; i <= 9; i++) {\\n        if (digitCount[i] != 1)\\n            return false; // If any digit appears more than once or none, return false\\n    }\\n\\n    return true; // All conditions satisfied, return true\\n}\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n    string str = to_string(n);\\n    int n2 = n * 2;\\n    int n3 = n * 3;\\n    str += to_string(n2);\\n    str += to_string(n3);\\n\\n    vector<int> digitCount(10); // count of each digit from 0 to 9\\n\\n    for (int i = 0; i < str.size(); i++) {\\n        if (str[i] == \\'0\\')\\n            return false; // If any digit is 0, return false\\n        digitCount[str[i] - \\'0\\']++;\\n    }\\n\\n    for (int i = 1; i <= 9; i++) {\\n        if (digitCount[i] != 1)\\n            return false; // If any digit appears more than once or none, return false\\n    }\\n\\n    return true; // All conditions satisfied, return true\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097000,
                "title": "fast-and-lightweight-php-solution-using-math-and-no-functions",
                "content": "# Intuition\\nThis problem should be solvable without using strings, concatenation, or string manipulation, and instead using simple math. That should make it quicker and use less memory, especially in other languages that aren\\'t optimized for strings.\\n\\nI also wanted to avoid doing any searching through arrays with `in_array`, doing an additional loop at the end, or using any functions at all. There should be a way to determine a final true/false result while working through each digit, which would also allow the function to end early in many cases.\\n\\n# Approach\\nFilling out an array with indexes from 0 to 9, to correlate with each digit, and then checking the state of each index, would allow us to quickly check if a digit has been used or not. Since it is an indexed array, PHP doesn\\'t need to search the array; it can just check the index value (which are sequential in memory). \\n\\nThe digit 0 is undesired, so its index starts as true, while all others start as false (and are turned true when first occurring). \\n\\nThere will also be initial values of `n` that cannot result in a true response, so those can be weeded out. Anything lower than 100 or greater than 333 will always be false, since they will result in an incorrect total number of digits.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public function isFascinating(int $n): bool\\n    {\\n        // If $n is outside this range it is invalid\\n        if ($n < 100 || $n > 333) {\\n            return false;\\n        }\\n\\n        // This array is used to check that each desired digit occurs once (0 starts as true since it is invalid)\\n        $check = [true, false, false, false, false, false, false, false, false, false];\\n\\n        // Check each digit for each multiplication of $n\\n        for ($i = 1; $i <= 3; $i ++) {\\n            \\n            // Get the 3-digit value for this multiplication\\n            $m = $i == 1 ? $n : $n * $i;\\n\\n            // Digit 1\\n            $d = (int) ($m / 100);\\n            if ($check[$d]) return false;\\n            $check[$d] = true;\\n\\n            // Digit 2\\n            $e = (int) ($m / 10) - $d * 10;\\n            if ($check[$e]) return false;\\n            $check[$e] = true;\\n\\n            // Digit 3\\n            $d = $m - $d * 100 - $e * 10;\\n            if ($check[$d]) return false;\\n            $check[$d] = true;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n    public function isFascinating(int $n): bool\\n    {\\n        // If $n is outside this range it is invalid\\n        if ($n < 100 || $n > 333) {\\n            return false;\\n        }\\n\\n        // This array is used to check that each desired digit occurs once (0 starts as true since it is invalid)\\n        $check = [true, false, false, false, false, false, false, false, false, false];\\n\\n        // Check each digit for each multiplication of $n\\n        for ($i = 1; $i <= 3; $i ++) {\\n            \\n            // Get the 3-digit value for this multiplication\\n            $m = $i == 1 ? $n : $n * $i;\\n\\n            // Digit 1\\n            $d = (int) ($m / 100);\\n            if ($check[$d]) return false;\\n            $check[$d] = true;\\n\\n            // Digit 2\\n            $e = (int) ($m / 10) - $d * 10;\\n            if ($check[$e]) return false;\\n            $check[$e] = true;\\n\\n            // Digit 3\\n            $d = $m - $d * 100 - $e * 10;\\n            if ($check[$d]) return false;\\n            $check[$d] = true;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092396,
                "title": "c-cpp-esay-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n      string temp;\\n      set<int>t;\\n      temp=to_string(n)+to_string(n*2)+to_string(n*3);\\n     \\n\\n    for(auto it :temp){\\n      if(it!=\\'0\\')t.insert(it-48);\\n    }\\n\\n       if(t.size()==9 &&temp.size()==9)return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n      string temp;\\n      set<int>t;\\n      temp=to_string(n)+to_string(n*2)+to_string(n*3);\\n     \\n\\n    for(auto it :temp){\\n      if(it!=\\'0\\')t.insert(it-48);\\n    }\\n\\n       if(t.size()==9 &&temp.size()==9)return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092251,
                "title": "check-out-my-solution-using-new-set",
                "content": "# Code\\n```\\nfunction isFascinating(n: number): boolean {\\n  const n2 = 2 * n\\n  const n3 = 3 * n\\n  const srt = n.toString() + n2 + n3\\n  \\n  return new Set(srt).size === srt.length && !srt.includes(\\'0\\')\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isFascinating(n: number): boolean {\\n  const n2 = 2 * n\\n  const n3 = 3 * n\\n  const srt = n.toString() + n2 + n3\\n  \\n  return new Set(srt).size === srt.length && !srt.includes(\\'0\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084580,
                "title": "java8-solution",
                "content": "\\n\\n# Approach\\nJava8 \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        String val = \"123456789\";\\n        String str = Integer.toString(n).concat(String.valueOf(2 * n)).concat(String.valueOf(3 * n));\\n\\n        if (str.length() == 9) {\\n            return val.equals(str.chars().mapToObj(c -> (char) c).map(Character::getNumericValue).sorted().map(String::valueOf).collect(Collectors.joining()));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        String val = \"123456789\";\\n        String str = Integer.toString(n).concat(String.valueOf(2 * n)).concat(String.valueOf(3 * n));\\n\\n        if (str.length() == 9) {\\n            return val.equals(str.chars().mapToObj(c -> (char) c).map(Character::getNumericValue).sorted().map(String::valueOf).collect(Collectors.joining()));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084094,
                "title": "python-easy-solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isFascinating(self, n):\\n        n_con = str(n) + str(n * 2) + str(n * 3)\\n        return sorted(n_con) == [str(i) for i in range(1, 10)]         \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isFascinating(self, n):\\n        n_con = str(n) + str(n * 2) + str(n * 3)\\n        return sorted(n_con) == [str(i) for i in range(1, 10)]         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084088,
                "title": "python-easy-solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isFascinating(self, n):\\n        n2 = n * 2\\n        n3 = n * 3\\n        n_con = str(n) + str(n2) + str(n3)\\n        sort = sorted(n_con)\\n        return sorted(n_con) == [str(i) for i in range(1, 10)]         \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isFascinating(self, n):\\n        n2 = n * 2\\n        n3 = n * 3\\n        n_con = str(n) + str(n2) + str(n3)\\n        sort = sorted(n_con)\\n        return sorted(n_con) == [str(i) for i in range(1, 10)]         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074790,
                "title": "java-hashmap-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int count = 0;\\n        String str = String.valueOf(n) + String.valueOf(2 * n) + String.valueOf(3 * n);\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < str.length(); i++) {\\n            if(map.containsKey(str.charAt(i)) || str.charAt(i) == \\'0\\') {\\n                return false;\\n            } \\n            map.put(str.charAt(i), 1);\\n            count++;\\n        }\\n        return count == 9;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int count = 0;\\n        String str = String.valueOf(n) + String.valueOf(2 * n) + String.valueOf(3 * n);\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < str.length(); i++) {\\n            if(map.containsKey(str.charAt(i)) || str.charAt(i) == \\'0\\') {\\n                return false;\\n            } \\n            map.put(str.charAt(i), 1);\\n            count++;\\n        }\\n        return count == 9;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069305,
                "title": "simple-c-solution-using-map-beats-100-runtime",
                "content": "This code defines a class `Solution` with a member function `isFascinating` that determines whether a given integer `n` is fascinating or not, based on a specific definition of fascinating numbers.\\n\\n## Intuition\\n\\nThe code is creating a string `temp` by concatenating the string representations of `n`, `2*n`, and `3*n`. It then counts the occurrences of each digit in this string and checks whether the string meets certain conditions to be considered fascinating.\\n\\n## Approach\\n\\n1. Convert the given integer `n` to its string representation and concatenate it with the string representations of `2*n` and `3*n`.\\n2. Count the occurrences of each digit (0-9) in the concatenated string.\\n3. Check if the concatenated string meets the conditions to be considered fascinating:\\n   - All digits from 0 to 9 should appear exactly once.\\n   - The concatenated string should not contain any other characters besides these digits.\\n\\n## Complexity\\n\\n- Time complexity: $$O(\\\\log n)$$, where $$n$$ is the given integer.\\n  - Converting integer to string takes $$O(\\\\log n)$$ time.\\n  - Counting occurrences of digits in the string takes $$O(\\\\log n)$$ time.\\n- Space complexity: $$O(1)$$, since the space used for the unordered map and other variables does not depend on the size of the input.\\n\\n## Code Comments\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        // Convert the given integer to a string and concatenate it with 2*n and 3*n\\n        string temp = to_string(n) + to_string(2 * n) + to_string(3 * n);\\n        \\n        // Create an unordered map to store the count of each digit\\n        unordered_map<int, int> mp;\\n        \\n        // Count the occurrences of each digit in the concatenated string\\n        for (int i = 0; i < temp.length(); i++) {\\n            mp[temp[i] - \\'0\\']++;\\n        }\\n        \\n        // Check if the concatenated string meets the fascinating conditions\\n        for (auto x : mp) {\\n            // Check for conditions where the number is not fascinating\\n            if (x.second == 0 || x.second > 1 || (x.first == 0 && x.second > 0))\\n                return false;\\n        }\\n        \\n        // The number is fascinating if it passed all conditions\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        // Convert the given integer to a string and concatenate it with 2*n and 3*n\\n        string temp = to_string(n) + to_string(2 * n) + to_string(3 * n);\\n        \\n        // Create an unordered map to store the count of each digit\\n        unordered_map<int, int> mp;\\n        \\n        // Count the occurrences of each digit in the concatenated string\\n        for (int i = 0; i < temp.length(); i++) {\\n            mp[temp[i] - \\'0\\']++;\\n        }\\n        \\n        // Check if the concatenated string meets the fascinating conditions\\n        for (auto x : mp) {\\n            // Check for conditions where the number is not fascinating\\n            if (x.second == 0 || x.second > 1 || (x.first == 0 && x.second > 0))\\n                return false;\\n        }\\n        \\n        // The number is fascinating if it passed all conditions\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066739,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public bool IsFascinating(int n) {\\n        var res =\"\";\\n        var h = new HashSet<char>();\\n        res += n.ToString();\\n        res += (n * 2).ToString();\\n        res += (n * 3).ToString();\\n        if(res.Contains(\\'0\\'))\\n            return false;\\n        foreach(var ch in res){\\n            if(!h.Contains(ch))\\n                h.Add(ch);\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsFascinating(int n) {\\n        var res =\"\";\\n        var h = new HashSet<char>();\\n        res += n.ToString();\\n        res += (n * 2).ToString();\\n        res += (n * 3).ToString();\\n        if(res.Contains(\\'0\\'))\\n            return false;\\n        foreach(var ch in res){\\n            if(!h.Contains(ch))\\n                h.Add(ch);\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065419,
                "title": "beginner-friendly-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        n2=2*n\\n        n3=3*n\\n        conc=str(n)+str(n2)+str(n3)\\n        conc=list(conc)\\n        conc.sort()\\n        conc=\"\".join(conc)\\n        if(conc==\\'123456789\\'):\\n            return True\\n        return  False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        n2=2*n\\n        n3=3*n\\n        conc=str(n)+str(n2)+str(n3)\\n        conc=list(conc)\\n        conc.sort()\\n        conc=\"\".join(conc)\\n        if(conc==\\'123456789\\'):\\n            return True\\n        return  False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062210,
                "title": "beat-90-in-memory-and-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        s=str(n)+str(2*n)+str(3*n)\\n        s =\"\".join(sorted(s))\\n        return s==\\'123456789\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        s=str(n)+str(2*n)+str(3*n)\\n        s =\"\".join(sorted(s))\\n        return s==\\'123456789\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051362,
                "title": "using-hashmap-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        long l=(long)n;\\n        long n1=2*l;\\n        long n2=3*l;\\n\\n        String st=Long.toString(l);\\n        String st1=Long.toString(n1);\\n        String st2=Long.toString(n2);\\n\\n        st=st+st1+st2;\\n        for(int i=0;i<st.length();i++){\\n            map.put(st.charAt(i),map.getOrDefault(st.charAt(i),0)+1);\\n        }\\n\\n        for(char ch:map.keySet()){\\n            if(map.get(ch)!=1){\\n                return false;\\n            }\\n        }\\n\\n\\n\\n        for(int i=0;i<st.length();i++){\\n            if(st.charAt(i)==\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        long l=(long)n;\\n        long n1=2*l;\\n        long n2=3*l;\\n\\n        String st=Long.toString(l);\\n        String st1=Long.toString(n1);\\n        String st2=Long.toString(n2);\\n\\n        st=st+st1+st2;\\n        for(int i=0;i<st.length();i++){\\n            map.put(st.charAt(i),map.getOrDefault(st.charAt(i),0)+1);\\n        }\\n\\n        for(char ch:map.keySet()){\\n            if(map.get(ch)!=1){\\n                return false;\\n            }\\n        }\\n\\n\\n\\n        for(int i=0;i<st.length();i++){\\n            if(st.charAt(i)==\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050566,
                "title": "1ms-solution-java-o-n-time-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n\\n        if (n > 333) {\\n            return false;\\n        }\\n        Set<Integer> hold = new HashSet<>();\\n\\n        int left = (int) (n * Math.pow(10, 6));\\n        int mid = (int) (n * Math.pow(10, 3)) * 2;\\n        int right = n * 3;\\n\\n        n = (left + mid + right);\\n        int temp;\\n\\n        // System.out.println(n);\\n\\n        while (n > 0) {\\n            temp = n % 10;\\n            // System.out.println(temp + \"\\\\n\");\\n\\n            if (temp == 0) {\\n                return false;\\n            }\\n\\n            hold.add(temp);\\n            n /= 10;\\n        }\\n\\n        return hold.size() == 9;\\n    }\\n}\\n\\n// 192384576\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n\\n        if (n > 333) {\\n            return false;\\n        }\\n        Set<Integer> hold = new HashSet<>();\\n\\n        int left = (int) (n * Math.pow(10, 6));\\n        int mid = (int) (n * Math.pow(10, 3)) * 2;\\n        int right = n * 3;\\n\\n        n = (left + mid + right);\\n        int temp;\\n\\n        // System.out.println(n);\\n\\n        while (n > 0) {\\n            temp = n % 10;\\n            // System.out.println(temp + \"\\\\n\");\\n\\n            if (temp == 0) {\\n                return false;\\n            }\\n\\n            hold.add(temp);\\n            n /= 10;\\n        }\\n\\n        return hold.size() == 9;\\n    }\\n}\\n\\n// 192384576\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049854,
                "title": "java-set-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        String strs = Integer.toString(n) + Integer.toString(2 * n) + Integer.toString(3 * n);\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int i = 0; i < strs.length(); i++) {\\n            int curr = strs.charAt(i) - \\'0\\';\\n            if (curr == 0) {\\n                return false;\\n            }\\n            if (set.contains(curr)) {\\n                return false;\\n            }\\n            set.add(curr);\\n        }\\n\\n        return set.size() == 9;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        String strs = Integer.toString(n) + Integer.toString(2 * n) + Integer.toString(3 * n);\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int i = 0; i < strs.length(); i++) {\\n            int curr = strs.charAt(i) - \\'0\\';\\n            if (curr == 0) {\\n                return false;\\n            }\\n            if (set.contains(curr)) {\\n                return false;\\n            }\\n            set.add(curr);\\n        }\\n\\n        return set.size() == 9;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049688,
                "title": "c-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        if (n > 333) {\\n            return false;\\n        }\\n        string s = to_string(n) + to_string(2 * n) + to_string(3 * n);\\n        sort(begin(s), end(s));\\n        int num = stoi(s);\\n        if (num != 123456789) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        if (n > 333) {\\n            return false;\\n        }\\n        string s = to_string(n) + to_string(2 * n) + to_string(3 * n);\\n        sort(begin(s), end(s));\\n        int num = stoi(s);\\n        if (num != 123456789) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048644,
                "title": "1-line-solution-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n    return (n == 192 || n == 273 || n == 327 || n == 219)\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n    return (n == 192 || n == 273 || n == 327 || n == 219)\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048609,
                "title": "1-line-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n    return (n == 192 || n == 273 || n == 327 || n == 219)\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n    return (n == 192 || n == 273 || n == 327 || n == 219)\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044807,
                "title": "easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string s3=to_string(n);\\n        string s1=to_string(2*n);\\n        string s2=to_string(3*n);\\n       string s=(s1+s2+s3);\\n       sort(s.begin(),s.end());\\n       for(int i=0;i<s.length()-1;i++){\\n           if(s[i]==\\'0\\' || s[i]==s[i+1]){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string s3=to_string(n);\\n        string s1=to_string(2*n);\\n        string s2=to_string(3*n);\\n       string s=(s1+s2+s3);\\n       sort(s.begin(),s.end());\\n       for(int i=0;i<s.length()-1;i++){\\n           if(s[i]==\\'0\\' || s[i]==s[i+1]){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043931,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n    let allNumbers = \\'123456789\\'\\n    let fancyNumber = `${n}${n * 2}${n * 3}`.split(\"\").sort().join(\"\")\\n    if(allNumbers == fancyNumber){\\n        return true\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n    let allNumbers = \\'123456789\\'\\n    let fancyNumber = `${n}${n * 2}${n * 3}`.split(\"\").sort().join(\"\")\\n    if(allNumbers == fancyNumber){\\n        return true\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043547,
                "title": "only-god-me-can-understand-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0,i8=0,i9=0,i0=0,n2=n*2,n3=n*3,all;\\n        boolean a=false;\\n        n*=1000000;\\n        n2*=1000;\\n        all=n+n2+n3;\\n        if (n/1000000<334){\\n        while (all!=0){\\n            n2=all%10;\\n            all/=10;\\n            switch (n2){\\n                case 0: if (all!=0) i0++; break;\\n                case 1: i1++;  break;\\n                case 2: i2++;  break;\\n                case 3: i3++;  break;\\n                case 4: i4++;  break;\\n                case 5: i5++;  break;\\n                case 6: i6++;  break;\\n                case 7: i7++;  break;\\n                case 8: i8++;  break;\\n                case 9: i9++;  break;\\n            }\\n        }\\n        }\\n    if (i0==0&&i1==1&&i1==i2&&i3==i4&&i5==i6&&i7==i8&&i9==1)\\n        a=true;\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0,i8=0,i9=0,i0=0,n2=n*2,n3=n*3,all;\\n        boolean a=false;\\n        n*=1000000;\\n        n2*=1000;\\n        all=n+n2+n3;\\n        if (n/1000000<334){\\n        while (all!=0){\\n            n2=all%10;\\n            all/=10;\\n            switch (n2){\\n                case 0: if (all!=0) i0++; break;\\n                case 1: i1++;  break;\\n                case 2: i2++;  break;\\n                case 3: i3++;  break;\\n                case 4: i4++;  break;\\n                case 5: i5++;  break;\\n                case 6: i6++;  break;\\n                case 7: i7++;  break;\\n                case 8: i8++;  break;\\n                case 9: i9++;  break;\\n            }\\n        }\\n        }\\n    if (i0==0&&i1==1&&i1==i2&&i3==i4&&i5==i6&&i7==i8&&i9==1)\\n        a=true;\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037474,
                "title": "beats-100-no-sorting-required",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# @param {Integer} n\\n# @return {Boolean}\\ndef is_fascinating(n)\\n    nums_hash = {}\\n    (1..9).each do |num|\\n        nums_hash[num.to_s] = true\\n    end\\n\\n    first_entry = n.to_s\\n    second_entry = (2 * n).to_s\\n    third_entry = (3 * n).to_s\\n    full_string = first_entry + second_entry + third_entry\\n\\n    full_string.each_char do |char|\\n        if nums_hash[char]\\n            nums_hash.delete char\\n        else\\n            return false\\n        end\\n\\n    end\\n    \\n    return true\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @return {Boolean}\\ndef is_fascinating(n)\\n    nums_hash = {}\\n    (1..9).each do |num|\\n        nums_hash[num.to_s] = true\\n    end\\n\\n    first_entry = n.to_s\\n    second_entry = (2 * n).to_s\\n    third_entry = (3 * n).to_s\\n    full_string = first_entry + second_entry + third_entry\\n\\n    full_string.each_char do |char|\\n        if nums_hash[char]\\n            nums_hash.delete char\\n        else\\n            return false\\n        end\\n\\n    end\\n    \\n    return true\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4036601,
                "title": "100-beats-other-c-codes-very-easy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  count every digits occurence in array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   1. calculate 2*n and 3* n of a given number \\n   2. store every digits occurence in array at its respective index.\\n   3. and then traverse through array and see if there is any value not equal to 1 or not.\\n   \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(10) = O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int arr[10]{};\\n        int d = n*2;\\n        int t = n*3;\\n        while(t)\\n        {\\n            arr[d%10]++;\\n            arr[n%10]++;\\n            arr[t%10]++;\\n            n/=10;\\n            d/=10;\\n            t/=10;\\n        }\\n        for(int i=1;i<10;i++)\\n        {\\n              if(arr[i]!=1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int arr[10]{};\\n        int d = n*2;\\n        int t = n*3;\\n        while(t)\\n        {\\n            arr[d%10]++;\\n            arr[n%10]++;\\n            arr[t%10]++;\\n            n/=10;\\n            d/=10;\\n            t/=10;\\n        }\\n        for(int i=1;i<10;i++)\\n        {\\n              if(arr[i]!=1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031035,
                "title": "php-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Boolean\\n     */\\n    function isFascinating($n) {\\n        $num1 = $n * 2;\\n        $num2 = $n * 3;\\n        $n = \"{$n}{$num1}{$num2}\";\\n        $carry = [];\\n        \\n        for($i = 0, $ln = strlen($n); $i < $ln; $i++) {\\n            $digit = $n[$i];\\n\\n            if ($digit == 0 || in_array($digit, $carry)) {\\n                return false;\\n            }\\n\\n            $carry[] = $digit;\\n        }\\n\\n        if (count($carry) !== 9) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Boolean\\n     */\\n    function isFascinating($n) {\\n        $num1 = $n * 2;\\n        $num2 = $n * 3;\\n        $n = \"{$n}{$num1}{$num2}\";\\n        $carry = [];\\n        \\n        for($i = 0, $ln = strlen($n); $i < $ln; $i++) {\\n            $digit = $n[$i];\\n\\n            if ($digit == 0 || in_array($digit, $carry)) {\\n                return false;\\n            }\\n\\n            $carry[] = $digit;\\n        }\\n\\n        if (count($carry) !== 9) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030272,
                "title": "simple-solution-that-beats-97-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string ans=\"\";\\n        int n2 = n*2;\\n        int n3 = n*3;\\n        ans+=(to_string(n));\\n        ans+=(to_string(n2));\\n        ans+=(to_string(n3));\\n        vector<int>freq(10,0);\\n        for(char c:ans)\\n        {\\n            if(c == \\'0\\'||freq[c-\\'0\\'])\\n                return false;\\n            freq[c-\\'0\\']++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string ans=\"\";\\n        int n2 = n*2;\\n        int n3 = n*3;\\n        ans+=(to_string(n));\\n        ans+=(to_string(n2));\\n        ans+=(to_string(n3));\\n        vector<int>freq(10,0);\\n        for(char c:ans)\\n        {\\n            if(c == \\'0\\'||freq[c-\\'0\\'])\\n                return false;\\n            freq[c-\\'0\\']++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006345,
                "title": "const-js-ts-single-line-solution-beats-99",
                "content": "# Code\\n```\\nfunction isFascinating(n: number, value = `${n}${n*2}${n*3}`, uniqueValue = new Set(value)): boolean {\\n    return uniqueValue.size === 9 && !uniqueValue.has(\"0\") && uniqueValue.size === value.length\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isFascinating(n: number, value = `${n}${n*2}${n*3}`, uniqueValue = new Set(value)): boolean {\\n    return uniqueValue.size === 9 && !uniqueValue.has(\"0\") && uniqueValue.size === value.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003191,
                "title": "c-100-solution-w-stringbuilder-hashset",
                "content": "# Code\\n```\\npublic class Solution {\\n    public bool IsFascinating(int n) {\\n        StringBuilder sb = new StringBuilder(n.ToString());\\n        sb.Append(2 * n);\\n        sb.Append(3 * n);\\n        HashSet<char> hs = new HashSet<char>();\\n        for(int i = 0; i < sb.Length; i++)\\n        {\\n            if(sb[i] == \\'0\\')\\n                return false;\\n            if(hs.Contains(sb[i]))\\n                return false;\\n            hs.Add(sb[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsFascinating(int n) {\\n        StringBuilder sb = new StringBuilder(n.ToString());\\n        sb.Append(2 * n);\\n        sb.Append(3 * n);\\n        HashSet<char> hs = new HashSet<char>();\\n        for(int i = 0; i < sb.Length; i++)\\n        {\\n            if(sb[i] == \\'0\\')\\n                return false;\\n            if(hs.Contains(sb[i]))\\n                return false;\\n            hs.Add(sb[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002445,
                "title": "java-stringbuilder",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(n).append(n * 2).append(n * 3);\\n        if (sb.length() > 9) return false;\\n        for (int i = 1; i <= 9; i++) {\\n            if (sb.indexOf(String.valueOf(i)) == -1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(n).append(n * 2).append(n * 3);\\n        if (sb.length() > 9) return false;\\n        for (int i = 1; i <= 9; i++) {\\n            if (sb.indexOf(String.valueOf(i)) == -1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000244,
                "title": "easily-understandable-java-solution-with-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    Get a StringBuildr and append the necessary String \\n    Now convert the StringBuilder intp a String using toString() operation\\n    Now creat a HashSet of Characters and then iterare through the Stirng using for loop and the given condiotns\\n    if(ch==\\'0\\') return false; This line is added in order to pass the last testcase.\\n\\n# Complexity\\n- Time complexity:\\n o(n);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(n);\\n        sb.append(n*2);\\n        sb.append(n*3);\\n        String str = sb.toString();\\n        System.out.println(str);\\n        // if(str.length()>10) return false;\\n        Set<Character> set = new HashSet();\\n        for(int i =0;i<str.length();i++)\\n        {\\n            char ch = str.charAt(i);\\n            if(ch==\\'0\\') return false;\\n            if(!set.add(ch))\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(n);\\n        sb.append(n*2);\\n        sb.append(n*3);\\n        String str = sb.toString();\\n        System.out.println(str);\\n        // if(str.length()>10) return false;\\n        Set<Character> set = new HashSet();\\n        for(int i =0;i<str.length();i++)\\n        {\\n            char ch = str.charAt(i);\\n            if(ch==\\'0\\') return false;\\n            if(!set.add(ch))\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991006,
                "title": "java-solution-easy-understanding-runtime-11ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        String str1 = String.valueOf(2*n);\\n        String str2 = String.valueOf(3*n);\\n        String num = String.valueOf(n);\\n\\n        String str = num + str1 + str2;\\n\\n        Set<Character> set = new HashSet();\\n\\n        for(int i = 0; i<str.length(); i++)\\n        {\\n            if(str.charAt(i) >= \\'1\\' && str.charAt(i) <= \\'9\\')\\n            {\\n                if(set.contains(str.charAt(i)))\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    set.add(str.charAt(i));\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        String str1 = String.valueOf(2*n);\\n        String str2 = String.valueOf(3*n);\\n        String num = String.valueOf(n);\\n\\n        String str = num + str1 + str2;\\n\\n        Set<Character> set = new HashSet();\\n\\n        for(int i = 0; i<str.length(); i++)\\n        {\\n            if(str.charAt(i) >= \\'1\\' && str.charAt(i) <= \\'9\\')\\n            {\\n                if(set.contains(str.charAt(i)))\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    set.add(str.charAt(i));\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990224,
                "title": "runtime-9ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int a=2*n;\\n        int b=3*n;\\n        String s = \"\" + n+ a + b ;\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = i+1; j < s.length(); j++) {\\n                if(s.charAt(i)==s.charAt(j) || s.contains(\"0\"))\\n                {\\n                    return false;\\n                }\\n            } \\n        }\\n   return true;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int a=2*n;\\n        int b=3*n;\\n        String s = \"\" + n+ a + b ;\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = i+1; j < s.length(); j++) {\\n                if(s.charAt(i)==s.charAt(j) || s.contains(\"0\"))\\n                {\\n                    return false;\\n                }\\n            } \\n        }\\n   return true;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988549,
                "title": "1ms-97-java-hashset",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int[]arr = new int[3];\\n        arr[0] = n;\\n        arr[1] = 2*n;\\n        arr[2] = 3*n;\\n\\n        HashSet<Integer> st  = new HashSet<>();\\n\\n        int i = 0;\\n        while(i<3){\\n\\n            if(arr[i]%10==0) return false;\\n\\n            if(st.contains(arr[i]%10)) return false;\\n            else{\\n                st.add(arr[i]%10);\\n                arr[i] = arr[i]/10;\\n            }\\n\\n            if(arr[i]==0) i++;\\n\\n        }\\n\\n        if(st.size()<9) return false;\\n\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int[]arr = new int[3];\\n        arr[0] = n;\\n        arr[1] = 2*n;\\n        arr[2] = 3*n;\\n\\n        HashSet<Integer> st  = new HashSet<>();\\n\\n        int i = 0;\\n        while(i<3){\\n\\n            if(arr[i]%10==0) return false;\\n\\n            if(st.contains(arr[i]%10)) return false;\\n            else{\\n                st.add(arr[i]%10);\\n                arr[i] = arr[i]/10;\\n            }\\n\\n            if(arr[i]==0) i++;\\n\\n        }\\n\\n        if(st.size()<9) return false;\\n\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982776,
                "title": "easy-solution-1-line",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        return Counter(str(n) + str(n*2) + str(n*3)) == Counter(map(str, range(1, 10)))\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        return Counter(str(n) + str(n*2) + str(n*3)) == Counter(map(str, range(1, 10)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977273,
                "title": "easy-to-understand-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        if(n>334){\\n            return false;\\n        }\\n        int n1=2*n;\\n        int n2=3*n;\\n        n=(n*1000)+n1;\\n        n=(n*1000)+n2;\\n        int c=n;\\n        int count=0;\\n        for(int i=1;i<=9;i++){\\n            count=0;\\n            while(n>0){\\n                if(n%10==0){\\n                    return false;\\n                }\\n                if(n%10==i){\\n                    count++;\\n                }\\n                n/=10;\\n            }\\n            if(count!=1){\\n                return false;\\n            }\\n            n=c;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        if(n>334){\\n            return false;\\n        }\\n        int n1=2*n;\\n        int n2=3*n;\\n        n=(n*1000)+n1;\\n        n=(n*1000)+n2;\\n        int c=n;\\n        int count=0;\\n        for(int i=1;i<=9;i++){\\n            count=0;\\n            while(n>0){\\n                if(n%10==0){\\n                    return false;\\n                }\\n                if(n%10==i){\\n                    count++;\\n                }\\n                n/=10;\\n            }\\n            if(count!=1){\\n                return false;\\n            }\\n            n=c;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974880,
                "title": "using-string-and-basic-math",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        if(n>333)return false;\\n        int d=2*n*1000+3*n+n*1000000;\\n        cout<<d;\\n        string s= to_string(d);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]-\\'0\\'!=i+1)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        if(n>333)return false;\\n        int d=2*n*1000+3*n+n*1000000;\\n        cout<<d;\\n        string s= to_string(d);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]-\\'0\\'!=i+1)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3972250,
                "title": "c-no-strings",
                "content": "```\\npublic class Solution {\\n    public bool IsFascinating(int n)\\n    {\\n        var digits = new int[10];\\n        var dcount = 0;\\n\\n        foreach (var num in new[] { n, 2 * n, 3 * n })\\n        {\\n            for (int i = num; i != 0; i /= 10)\\n            {\\n                int d = i % 10;\\n\\n                if (d == 0 || digits[d]++ > 0) return false;\\n\\n                dcount++;\\n            }\\n        }\\n\\n        return dcount == 9;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsFascinating(int n)\\n    {\\n        var digits = new int[10];\\n        var dcount = 0;\\n\\n        foreach (var num in new[] { n, 2 * n, 3 * n })\\n        {\\n            for (int i = num; i != 0; i /= 10)\\n            {\\n                int d = i % 10;\\n\\n                if (d == 0 || digits[d]++ > 0) return false;\\n\\n                dcount++;\\n            }\\n        }\\n\\n        return dcount == 9;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970107,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n     int[] arr = new int[]{n, 2 * n, 3 * n};\\n     int[] table = new int[10];\\n\\n     for(int k : arr){\\n         while(k > 0){\\n             table[k%10]++;\\n             k /= 10;\\n         }\\n     }\\n\\n     if(table[0] > 0) return false;\\n     for(int i = 1; i < 10; i++)\\n        if(table[i] != 1) return false;\\n\\n     return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n     int[] arr = new int[]{n, 2 * n, 3 * n};\\n     int[] table = new int[10];\\n\\n     for(int k : arr){\\n         while(k > 0){\\n             table[k%10]++;\\n             k /= 10;\\n         }\\n     }\\n\\n     if(table[0] > 0) return false;\\n     for(int i = 1; i < 10; i++)\\n        if(table[i] != 1) return false;\\n\\n     return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969753,
                "title": "comparing-2-arrays-no-loops",
                "content": "# Intuition\\nSimply comparing sorted array to an array of digits 1 to 9.\\n\\nRuntime : 31ms (Beats 98.46%) AND Memory: 16.20MB (Beats 88.32%).\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        com_l = [\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\']\\n        new_n = str(n) + str(n*2) +str(n*3)\\n        new_l = list(new_n.replace(\"\",\"\"))\\n        new_l.sort()\\n        return new_l == com_l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        com_l = [\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\']\\n        new_n = str(n) + str(n*2) +str(n*3)\\n        new_l = list(new_n.replace(\"\",\"\"))\\n        new_l.sort()\\n        return new_l == com_l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966752,
                "title": "easy-solution-using-java",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int[] arr = new int[10];\\n        boolean done = false;\\n        int n1 = n;\\n        while(n > 0){\\n            int idx = n % 10;\\n            arr[idx]++;\\n            if(idx == 0 || arr[idx] > 1){\\n                return false;\\n            }\\n            n /= 10;\\n            if(n == 0 && n1 != 0){\\n                if(done == false){\\n                    n = n1 * 2;\\n                    done = true;\\n                }\\n                else{\\n                    n = n1 * 3;\\n                    n1 = 0;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int[] arr = new int[10];\\n        boolean done = false;\\n        int n1 = n;\\n        while(n > 0){\\n            int idx = n % 10;\\n            arr[idx]++;\\n            if(idx == 0 || arr[idx] > 1){\\n                return false;\\n            }\\n            n /= 10;\\n            if(n == 0 && n1 != 0){\\n                if(done == false){\\n                    n = n1 * 2;\\n                    done = true;\\n                }\\n                else{\\n                    n = n1 * 3;\\n                    n1 = 0;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962007,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string num = to_string(n);\\n        int n1 = 2*n;\\n        int n2 = 3*n;\\n        num += to_string(n1) + to_string(n2);\\n\\n        unordered_map<char , int> freq;\\n        for (int i=0 ; i<num.length() ; i++){\\n            freq[num[i]]++;\\n        }    \\n\\n        for (auto i : freq){\\n            if (i.first == \\'0\\')\\n                return false;\\n            \\n            else if (i.second > 1)\\n                return false;\\n        }\\n        if (freq.size() == 9)\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string num = to_string(n);\\n        int n1 = 2*n;\\n        int n2 = 3*n;\\n        num += to_string(n1) + to_string(n2);\\n\\n        unordered_map<char , int> freq;\\n        for (int i=0 ; i<num.length() ; i++){\\n            freq[num[i]]++;\\n        }    \\n\\n        for (auto i : freq){\\n            if (i.first == \\'0\\')\\n                return false;\\n            \\n            else if (i.second > 1)\\n                return false;\\n        }\\n        if (freq.size() == 9)\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960381,
                "title": "fascinating-number-js-amazing-solutions",
                "content": "```\\nvar isFascinating = function(n) {\\n    arr = (n +\\'\\'+ n * 2 +\\'\\'+ n * 3).split(\\'\\').sort()\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] != i + 1) return false\\n    }\\n\\n    return true\\n};\\n```\\n```\\nvar isFascinating = function(n) {\\n    arr = (n +\\'\\'+ n * 2 +\\'\\'+ n * 3).split(\\'\\').sort().join(\\'\\')\\n\\n    return arr == \\'123456789\\'\\n};\\n```\\n```\\nvar isFascinating = function(n) {\\n    // only four numbers is Fascinating\\n    return n == 192 || n == 273 || n == 327 || n == 219\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isFascinating = function(n) {\\n    arr = (n +\\'\\'+ n * 2 +\\'\\'+ n * 3).split(\\'\\').sort()\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] != i + 1) return false\\n    }\\n\\n    return true\\n};\\n```\n```\\nvar isFascinating = function(n) {\\n    arr = (n +\\'\\'+ n * 2 +\\'\\'+ n * 3).split(\\'\\').sort().join(\\'\\')\\n\\n    return arr == \\'123456789\\'\\n};\\n```\n```\\nvar isFascinating = function(n) {\\n    // only four numbers is Fascinating\\n    return n == 192 || n == 273 || n == 327 || n == 219\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954552,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        StringBuilder s=new StringBuilder(String.valueOf(n));\\n        s.append(String.valueOf(2*n));\\n        s.append(String.valueOf(3*n));\\n        int[] v=new int[10];\\n        for(int i=0;i<s.length();i++){\\n            v[Integer.valueOf(s.charAt(i)-\\'0\\')]++;\\n        }\\n        if(v[0]!=0) return false;\\n        for(int i=1;i<10;i++){\\n            if(v[i]!=1) return false;\\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        StringBuilder s=new StringBuilder(String.valueOf(n));\\n        s.append(String.valueOf(2*n));\\n        s.append(String.valueOf(3*n));\\n        int[] v=new int[10];\\n        for(int i=0;i<s.length();i++){\\n            v[Integer.valueOf(s.charAt(i)-\\'0\\')]++;\\n        }\\n        if(v[0]!=0) return false;\\n        for(int i=1;i<10;i++){\\n            if(v[i]!=1) return false;\\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951547,
                "title": "concat-map-then-check-esay-and-readable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n1= 2*n ;\\n        int n2= 3*n ; \\n        String f = Integer.toString(n1).concat(Integer.toString(n2)) ;\\n        String str1 = Integer.toString(n);\\n        String ans = f.concat(str1) ; \\n        HashMap<Character ,Integer> hm = new HashMap<>();\\n        for(int i = 0 ;i<ans.length();i++)\\n        {\\n            char ch = ans.charAt(i);\\n            if(ch==\\'0\\')return false ; \\n            else \\n            {\\n                if(hm.containsKey(ch))\\n                {\\n                    return false ; \\n                }\\n                else\\n                {\\n                    hm.put(ch , 1);\\n                } \\n            }\\n        }\\n        if(hm.size()!=9){return false  ;}\\n        return true ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n1= 2*n ;\\n        int n2= 3*n ; \\n        String f = Integer.toString(n1).concat(Integer.toString(n2)) ;\\n        String str1 = Integer.toString(n);\\n        String ans = f.concat(str1) ; \\n        HashMap<Character ,Integer> hm = new HashMap<>();\\n        for(int i = 0 ;i<ans.length();i++)\\n        {\\n            char ch = ans.charAt(i);\\n            if(ch==\\'0\\')return false ; \\n            else \\n            {\\n                if(hm.containsKey(ch))\\n                {\\n                    return false ; \\n                }\\n                else\\n                {\\n                    hm.put(ch , 1);\\n                } \\n            }\\n        }\\n        if(hm.size()!=9){return false  ;}\\n        return true ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951223,
                "title": "easiest-hashmap-solution",
                "content": "\\n# Approach\\nSimply Convert into string and use Hashmap to store the frequency, if Frequency is greater than 1 we can simply return False or if element equals zero we can simply return False.\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        a=str(n)\\n        b=str(2*n)\\n        c=str(3*n)\\n        d=a+b+c\\n        m={}\\n        for i in d:\\n            if i not in m and i!=\\'0\\':\\n                m[i]=1\\n            elif i==\\'0\\' or  i in m:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        a=str(n)\\n        b=str(2*n)\\n        c=str(3*n)\\n        d=a+b+c\\n        m={}\\n        for i in d:\\n            if i not in m and i!=\\'0\\':\\n                m[i]=1\\n            elif i==\\'0\\' or  i in m:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941276,
                "title": "solution-easy",
                "content": "![2023-08-21_19-27-28.png](https://assets.leetcode.com/users/images/83e0a110-1c8f-443f-aede-25b41000b3b2_1692628083.1656432.png)\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        res = f\"{n}{n*2}{n*3}\"\\n        for i in range(1,10):\\n            if res.count(f\"{i}\") == 1:\\n                continue\\n            else:\\n                return False\\n        return True\\n  \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        res = f\"{n}{n*2}{n*3}\"\\n        for i in range(1,10):\\n            if res.count(f\"{i}\") == 1:\\n                continue\\n            else:\\n                return False\\n        return True\\n  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940156,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        ArrayList<Integer> set =  new ArrayList<>();\\n        int temp = n;\\n        temp = temp *  2;\\n        while(temp > 0){\\n            int rem = temp %  10;\\n            if(rem ==0)return false;\\n            set.add(rem);\\n            temp /= 10;\\n        }\\n        int temp2 = n;\\n        temp2 =  temp2*3;\\n         while(temp2 > 0){\\n            int rem = temp2 %  10;\\n            if(rem ==0)return false;\\n            set.add(rem);\\n            temp2 /= 10;\\n        }\\n        while(n > 0){\\n            int rem = n%10;\\n            if(rem == 0)return false;\\n            set.add(rem);\\n            n/=10;\\n        }\\n        if(set.size() > 9)return false;\\n        for(int i=1; i<=9; i++){\\n            if(!set.contains(i)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        ArrayList<Integer> set =  new ArrayList<>();\\n        int temp = n;\\n        temp = temp *  2;\\n        while(temp > 0){\\n            int rem = temp %  10;\\n            if(rem ==0)return false;\\n            set.add(rem);\\n            temp /= 10;\\n        }\\n        int temp2 = n;\\n        temp2 =  temp2*3;\\n         while(temp2 > 0){\\n            int rem = temp2 %  10;\\n            if(rem ==0)return false;\\n            set.add(rem);\\n            temp2 /= 10;\\n        }\\n        while(n > 0){\\n            int rem = n%10;\\n            if(rem == 0)return false;\\n            set.add(rem);\\n            n/=10;\\n        }\\n        if(set.size() > 9)return false;\\n        for(int i=1; i<=9; i++){\\n            if(!set.contains(i)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927800,
                "title": "ruby-solution",
                "content": "# Code\\n```\\n# @param {Integer} n\\n# @return {Boolean}\\ndef is_fascinating(n)\\n  n_conc = n.to_s + (2*n).to_s + (3*n).to_s\\n  counts = {}\\n  (1..9).each do |num| \\n    counts[num.to_s] = n_conc.count(num.to_s)\\n  end\\n  counts.reject{|k,v| v != 1}.length == 9\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @return {Boolean}\\ndef is_fascinating(n)\\n  n_conc = n.to_s + (2*n).to_s + (3*n).to_s\\n  counts = {}\\n  (1..9).each do |num| \\n    counts[num.to_s] = n_conc.count(num.to_s)\\n  end\\n  counts.reject{|k,v| v != 1}.length == 9\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3927044,
                "title": "c-easy-solution-beats-100-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        unordered_set<char> st;\\n\\n        int n1=2*n;\\n        int n2=3*n;\\n\\n        string s=to_string(n);\\n        string s1=to_string(n1);\\n        string s2=to_string(n2);\\n\\n        string res= s+s1+s2;\\n        if(res.length()!=9) return 0;\\n        for(int i=0;i<res.length();i++){\\n            st.insert(res[i]);\\n        }\\n\\n        \\n        if(st.count(\\'0\\')) return 0;\\n        return st.size()==9?1:0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        unordered_set<char> st;\\n\\n        int n1=2*n;\\n        int n2=3*n;\\n\\n        string s=to_string(n);\\n        string s1=to_string(n1);\\n        string s2=to_string(n2);\\n\\n        string res= s+s1+s2;\\n        if(res.length()!=9) return 0;\\n        for(int i=0;i<res.length();i++){\\n            st.insert(res[i]);\\n        }\\n\\n        \\n        if(st.count(\\'0\\')) return 0;\\n        return st.size()==9?1:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925541,
                "title": "simplest-of-the-solution-quick-and-efficient-anyone-can-do-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We have to multiply `n` by `2` and then by `3` and then check\\n    - if it doesn\\'t contains 0\\n    - it only contains a digit exactly once.\\n- For example: n = 421\\n    - first step: multiply by 2 --> `n * 2 = 421 * 2 = 842` \\n    - second step: multiply by 3 -- > `n * 3 = 842 * 3 = 4218421263`\\n    - now check if there are any `0` in the value, we don\\'t have any `0` in it, so we move to next check.\\n    - check digits occurrences:\\n    - 4 appears twice, so we should return False \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a string which will store the value of n after completing the multiplications.\\n- Then, check if there is any `0` present in the value.\\n    - if present, then return `False`\\n    - otherwise, move on to the next step.\\n- `set()` can be used to get only unique elements.\\n    - for example: n = 121\\n    - then set(n) will have 12\\n- Lastly, we just have to check if the length of value we obtained after doing multiplications is equal to the length of set of that value.\\n    - if equals, then it means it only contains unique digits, thus return `True`.\\n    - if not equals, then it means it doesn\\'t contains unique digits, thus return `False`.\\n\\n\\n- Other approach we could have used is to use a `dictionary` or `Counter` to keep the track of occurrence of the value.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        temp = str(n) + str(n*2) + str(n*3)\\n\\n        if \\'0\\' in temp: return False\\n        return len(temp) == len(set(temp))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        temp = str(n) + str(n*2) + str(n*3)\\n\\n        if \\'0\\' in temp: return False\\n        return len(temp) == len(set(temp))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921008,
                "title": "a-way-to-see-if-1-9-appear-exactly-once",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def isFascinating(self, n):\\n        #get the string of the entire number\\n        Mio=str(n)+str(2*n)+str(3*n)\\n        Ritsu=[]\\n        #set every digit into the list\\n        for i in range(0,9):\\n            Ritsu.append(int(Mio[i]))\\n        #sort the list\\n        Ritsu.sort()\\n        return Ritsu==[1,2,3,4,5,6,7,8,9]\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isFascinating(self, n):\\n        #get the string of the entire number\\n        Mio=str(n)+str(2*n)+str(3*n)\\n        Ritsu=[]\\n        #set every digit into the list\\n        for i in range(0,9):\\n            Ritsu.append(int(Mio[i]))\\n        #sort the list\\n        Ritsu.sort()\\n        return Ritsu==[1,2,3,4,5,6,7,8,9]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915503,
                "title": "java-1ms-beats-99-and-clean-code",
                "content": "# Approach\\n1. Concanate n, n*2 and n *3 as a string\\n2. If the resulting length != 9 return false\\n3. Iterate over each digit and if it is 0 OR its count > 1, return false\\n4. Return true by default\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n + 10)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {   \\n        StringBuilder stb = new StringBuilder();\\n        stb.append(n).append(2 * n).append(3 * n);\\n        return isFascinating(stb.toString());\\n    }\\n\\n    private boolean isFascinating(String s) {\\n        if (s.length() != 9) {\\n            return false;\\n        }\\n        int[] digitCount = new int[10];\\n        char ch;\\n        for (int i = 0; i < s.length(); i++) {\\n            ch = s.charAt(i);\\n            if (ch == \\'0\\' || ++digitCount[ch - \\'0\\'] > 1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {   \\n        StringBuilder stb = new StringBuilder();\\n        stb.append(n).append(2 * n).append(3 * n);\\n        return isFascinating(stb.toString());\\n    }\\n\\n    private boolean isFascinating(String s) {\\n        if (s.length() != 9) {\\n            return false;\\n        }\\n        int[] digitCount = new int[10];\\n        char ch;\\n        for (int i = 0; i < s.length(); i++) {\\n            ch = s.charAt(i);\\n            if (ch == \\'0\\' || ++digitCount[ch - \\'0\\'] > 1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913007,
                "title": "simple-solution-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n\\n        int a=2*n;\\n        int b=3*n;\\n\\n        int[] arr=new int[10];\\n        \\n        while(a!=0){\\n            arr[a%10]++;\\n            a=a/10;\\n        }\\n        while(b!=0){\\n            arr[b%10]++;\\n            b=b/10;\\n        }\\n        while(n!=0){\\n            arr[n%10]++;\\n            n=n/10;\\n        }\\n\\n        if(arr[0]>0){\\n            return false;\\n        }\\n\\n        for(int i=1;i<=9;i++){\\n            if(arr[i]!=1){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n\\n        int a=2*n;\\n        int b=3*n;\\n\\n        int[] arr=new int[10];\\n        \\n        while(a!=0){\\n            arr[a%10]++;\\n            a=a/10;\\n        }\\n        while(b!=0){\\n            arr[b%10]++;\\n            b=b/10;\\n        }\\n        while(n!=0){\\n            arr[n%10]++;\\n            n=n/10;\\n        }\\n\\n        if(arr[0]>0){\\n            return false;\\n        }\\n\\n        for(int i=1;i<=9;i++){\\n            if(arr[i]!=1){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910374,
                "title": "my-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n1=n*2;\\n        int n2=n*3;\\n        String no=Integer.toString(n);\\n        String n1_str=Integer.toString(n1);\\n        String n2_str=Integer.toString(n2);\\n        no+=n1_str+n2_str;\\n        \\n        if(no.contains(\"0\"))\\n        {\\n            return false;\\n        }\\n\\n        if(no.length()==9 && (no.contains(\"1\") && no.contains(\"2\") && no.contains(\"3\") && no.contains(\"4\") && no.contains(\"5\") && no.contains(\"6\") && no.contains(\"7\") && no.contains(\"8\") && no.contains(\"9\")))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n1=n*2;\\n        int n2=n*3;\\n        String no=Integer.toString(n);\\n        String n1_str=Integer.toString(n1);\\n        String n2_str=Integer.toString(n2);\\n        no+=n1_str+n2_str;\\n        \\n        if(no.contains(\"0\"))\\n        {\\n            return false;\\n        }\\n\\n        if(no.length()==9 && (no.contains(\"1\") && no.contains(\"2\") && no.contains(\"3\") && no.contains(\"4\") && no.contains(\"5\") && no.contains(\"6\") && no.contains(\"7\") && no.contains(\"8\") && no.contains(\"9\")))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885090,
                "title": "simple-decision-with-2-lines-of-code",
                "content": "## Code\\n![image.png](https://assets.leetcode.com/users/images/dffd9dc2-c0bf-4694-a632-64e02b92b909_1691565987.4129865.png)\\n\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        result = str(n) + str(n * 2) + str(n * 3)\\n        return len(result) == len(set(result)) and \"0\" not in result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        result = str(n) + str(n * 2) + str(n * 3)\\n        return len(result) == len(set(result)) and \"0\" not in result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879924,
                "title": "begineers-friendly-c-beats-100-00-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int a = n*2;\\n        int b = n*3;\\n        unordered_map<char, int>  mp;\\n        \\n        string st1 = to_string(n);\\n        string st2 = to_string(a);\\n        string st3 = to_string(b);\\n\\n        string temp = st1 + st2 + st3;\\n\\n        for(auto it:temp){\\n            mp[it]++;\\n        }\\n\\n        for(auto [i, j] : mp){\\n            if(j > 1 || i == \\'0\\')\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int a = n*2;\\n        int b = n*3;\\n        unordered_map<char, int>  mp;\\n        \\n        string st1 = to_string(n);\\n        string st2 = to_string(a);\\n        string st3 = to_string(b);\\n\\n        string temp = st1 + st2 + st3;\\n\\n        for(auto it:temp){\\n            mp[it]++;\\n        }\\n\\n        for(auto [i, j] : mp){\\n            if(j > 1 || i == \\'0\\')\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877281,
                "title": "100-98-beats-than-other",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string s = to_string(n)+to_string(n*2)+to_string(n*3);\\n        sort(s.begin(),s.end());\\n        if(s==\"123456789\"){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string s = to_string(n)+to_string(n*2)+to_string(n*3);\\n        sort(s.begin(),s.end());\\n        if(s==\"123456789\"){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874961,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int n2=n*2;\\n        int n3=n*3;\\n        string s = to_string(n);\\n        string s2 = to_string(n2);\\n        string s3 = to_string(n3);\\n        string ans=s+s2+s3;\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size()-1;i++)\\n        {\\n            if(ans[i]==\\'0\\' || ans[i]==ans[i+1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int n2=n*2;\\n        int n3=n*3;\\n        string s = to_string(n);\\n        string s2 = to_string(n2);\\n        string s3 = to_string(n3);\\n        string ans=s+s2+s3;\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size()-1;i++)\\n        {\\n            if(ans[i]==\\'0\\' || ans[i]==ans[i+1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874633,
                "title": "o-n-time-complexity-easy-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n1 = n*2;\\n        int n2 =n*3;\\n        if(n1>=1000 ){\\n            n*=10000;\\n            n+=n1;\\n        }\\n        else{\\n            n*=1000;\\n            n+=n1;\\n        }\\n        if(n2>=1000){\\n            n*=10000;\\n            n+=n2;\\n        }\\n        else{\\n            n*=1000;\\n            n+=n2;\\n        }\\n         int fre[] = new int[10];\\n    while(n>0){\\n        int rem = n%10;\\n        fre[rem]++;\\n        n/=10;\\n    }\\n     if(fre[0]!=0){\\n            return false;\\n        }\\n    for(int i=1;i<10;i++){\\n       if(fre[i]!=1){\\n           return false;\\n       }\\n    }\\n    return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n1 = n*2;\\n        int n2 =n*3;\\n        if(n1>=1000 ){\\n            n*=10000;\\n            n+=n1;\\n        }\\n        else{\\n            n*=1000;\\n            n+=n1;\\n        }\\n        if(n2>=1000){\\n            n*=10000;\\n            n+=n2;\\n        }\\n        else{\\n            n*=1000;\\n            n+=n2;\\n        }\\n         int fre[] = new int[10];\\n    while(n>0){\\n        int rem = n%10;\\n        fre[rem]++;\\n        n/=10;\\n    }\\n     if(fre[0]!=0){\\n            return false;\\n        }\\n    for(int i=1;i<10;i++){\\n       if(fre[i]!=1){\\n           return false;\\n       }\\n    }\\n    return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874579,
                "title": "easy-solution-in-java-easy-to-understand-o-n-time",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        String str = String.valueOf(n);\\n        int n1 = 2*n;\\n        int n2 = 3*n;\\n        String s1 = String.valueOf(n1);\\n        String s2 = String.valueOf(n2);\\n        str = str+s1;\\n        str = str+s2;\\n        \\n        int[] freq = new int[10];\\n        for(int i=0;i<10;i++)\\n            freq[i] = 0;\\n        for(int i=0;i<str.length();i++){\\n            freq[str.charAt(i)-48]++;\\n        }\\n        for(int i=1;i<=9;i++){\\n            if(freq[i]>1 || freq[i]==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        String str = String.valueOf(n);\\n        int n1 = 2*n;\\n        int n2 = 3*n;\\n        String s1 = String.valueOf(n1);\\n        String s2 = String.valueOf(n2);\\n        str = str+s1;\\n        str = str+s2;\\n        \\n        int[] freq = new int[10];\\n        for(int i=0;i<10;i++)\\n            freq[i] = 0;\\n        for(int i=0;i<str.length();i++){\\n            freq[str.charAt(i)-48]++;\\n        }\\n        for(int i=1;i<=9;i++){\\n            if(freq[i]>1 || freq[i]==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872395,
                "title": "javascript-beats-97-runtime",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n    let str = n + `${n*2}` + `${n*3}`\\n    if(str.includes(\\'0\\')) return false\\n    for(let i=0;i<str.length;i++){\\n        if(!!~str.indexOf(str[i], i+1)) return false\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n    let str = n + `${n*2}` + `${n*3}`\\n    if(str.includes(\\'0\\')) return false\\n    for(let i=0;i<str.length;i++){\\n        if(!!~str.indexOf(str[i], i+1)) return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3870320,
                "title": "simple-py3-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        lst2=str(n)\\n        lst=[i for i in range(1,10)]\\n        lst1=[2,3]\\n        c3=sum(lst)\\n        c4=len(lst)\\n        for i in lst1:\\n            v=n*i\\n            lst2=lst2+str(v)\\n        lst7=list(map(int,lst2))\\n        if len(lst7)==c4:\\n            if c3==sum(list(set(lst7))):\\n                return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        lst2=str(n)\\n        lst=[i for i in range(1,10)]\\n        lst1=[2,3]\\n        c3=sum(lst)\\n        c4=len(lst)\\n        for i in lst1:\\n            v=n*i\\n            lst2=lst2+str(v)\\n        lst7=list(map(int,lst2))\\n        if len(lst7)==c4:\\n            if c3==sum(list(set(lst7))):\\n                return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870097,
                "title": "o-1-time-and-o-1-memory-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'re working with numbers between 100 and 999, so all values can be pre-computed to reduce our time and space complexity to O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRunning the following code,\\n```\\nfrom collections import Counter\\nkey = Counter(\"123456789\")\\nfor i in range(100, 1000):\\n    s = str(i) + str(i * 2) + str(i * 3)\\n    if Counter(s) == key:\\n        print(i)\\n```\\n... yields our only possible fascinating numbers: ```192, 219, 273, 327```\\nNow, we can simply return True if n is in our list of three-digit fascinating numbers!\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- - Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        return True if n in {192, 219, 273, 327} else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nkey = Counter(\"123456789\")\\nfor i in range(100, 1000):\\n    s = str(i) + str(i * 2) + str(i * 3)\\n    if Counter(s) == key:\\n        print(i)\\n```\n```192, 219, 273, 327```\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        return True if n in {192, 219, 273, 327} else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870054,
                "title": "beats-99-91-four-liner-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we\\'re working with a constraint of ```100 <= n <= 999```, we can pre-compute all values that are \"fascinating\". Once we find all fascinating numbers, we can simply check if each n is in our key of fascinating numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find all fascinating numbers between 100 and 999, we use:\\n```\\nfrom collections import Counter\\nkey = Counter(\"123456789\")\\nfor i in range(100, 1000):\\n    s = str(i) + str(i * 2) + str(i * 3)\\n    if Counter(s) == key:\\n        print(i)\\n```\\nand find that,\\n```\\nfascinating_nums = {192, 219, 273, 327}\\n```\\nThis approach (1) creates the hashmap (set) of the key, (2) opens up the user.out file to write the output, and (3) writes the output to the user.out. The output is simply \\'true\\' or \\'false\\' based on if it\\'s in our \\'nums\\' set. \\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nWe iterate stdin to generate the output for the problem. If we were to use a pre-constructed class structure, the time complexity would be O(1) for each test case.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nIn this solution, I use stdin and user.out to more quickly print out the solution, using str.join() to generate the output. In the normal solution using a Class, the time complexity would be O(1) since we would simply return True/False if n was in ```fascinating_nums``` or not.\\n\\n# Code\\n```\\nnums = {192, 219, 273, 327}\\nf=open(\"user.out\",\\'w\\')\\nf.write(\"\".join(\"true\\\\n\" if int(l) in nums else \"false\\\\n\" for l in stdin))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```100 <= n <= 999```\n```\\nfrom collections import Counter\\nkey = Counter(\"123456789\")\\nfor i in range(100, 1000):\\n    s = str(i) + str(i * 2) + str(i * 3)\\n    if Counter(s) == key:\\n        print(i)\\n```\n```\\nfascinating_nums = {192, 219, 273, 327}\\n```\n```fascinating_nums```\n```\\nnums = {192, 219, 273, 327}\\nf=open(\"user.out\",\\'w\\')\\nf.write(\"\".join(\"true\\\\n\" if int(l) in nums else \"false\\\\n\" for l in stdin))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3869903,
                "title": "java-1ms-beats-99-78",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n\\n        int twoN = 2 * n;\\n        int threeN = 3 * n;\\n\\n        // analyze numbers for fascinating-ness\\n        int[] counter = new int[10];\\n        while (n > 0) {\\n            ++counter[n % 10];\\n            n /= 10;\\n        }\\n        while (twoN > 0) {\\n            ++counter[twoN % 10];\\n            twoN /= 10;\\n        }\\n        while (threeN > 0) {\\n            ++counter[threeN % 10];\\n            threeN /= 10;\\n        }\\n\\n        for (int digit = 1; digit <= 9; ++digit) {\\n            if (counter[digit] != 1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n\\n        int twoN = 2 * n;\\n        int threeN = 3 * n;\\n\\n        // analyze numbers for fascinating-ness\\n        int[] counter = new int[10];\\n        while (n > 0) {\\n            ++counter[n % 10];\\n            n /= 10;\\n        }\\n        while (twoN > 0) {\\n            ++counter[twoN % 10];\\n            twoN /= 10;\\n        }\\n        while (threeN > 0) {\\n            ++counter[threeN % 10];\\n            threeN /= 10;\\n        }\\n\\n        for (int digit = 1; digit <= 9; ++digit) {\\n            if (counter[digit] != 1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861864,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func isFascinating(_ n: Int) -> Bool {\\n\\n        let d = Array(\"\\\\(n)\" + \"\\\\(n * 2)\" + \"\\\\(n * 3)\")\\n            .map { Int(String($0))! }\\n            .sorted()\\n        \\n        return d == [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isFascinating(_ n: Int) -> Bool {\\n\\n        let d = Array(\"\\\\(n)\" + \"\\\\(n * 2)\" + \"\\\\(n * 3)\")\\n            .map { Int(String($0))! }\\n            .sorted()\\n        \\n        return d == [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859888,
                "title": "java-solution-beats-99-95-runtime-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        StringBuilder str = new StringBuilder(Integer.toString(n));\\n        str.append(Integer.toString(2*n));\\n        str.append(Integer.toString(3*n));\\n\\n        boolean arr[] = new boolean[str.length()+1];\\n        for(int i=0; i<str.length(); i++) {\\n            int idx = str.charAt(i)-\\'0\\';\\n            if(arr[idx] || idx==0) {\\n                return false;\\n            }\\n            arr[idx] = true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        StringBuilder str = new StringBuilder(Integer.toString(n));\\n        str.append(Integer.toString(2*n));\\n        str.append(Integer.toString(3*n));\\n\\n        boolean arr[] = new boolean[str.length()+1];\\n        for(int i=0; i<str.length(); i++) {\\n            int idx = str.charAt(i)-\\'0\\';\\n            if(arr[idx] || idx==0) {\\n                return false;\\n            }\\n            arr[idx] = true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858138,
                "title": "python3-solution-27ms-runtime-beats-99-9",
                "content": "All we have to do is sort the concatenated string, then return true if and only if the sorted string is \\'123456789\\'\\n\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        return \\'\\'.join(sorted(str(n) + str(n * 2) + str(n * 3))) == \\'123456789\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        return \\'\\'.join(sorted(str(n) + str(n * 2) + str(n * 3))) == \\'123456789\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856599,
                "title": "c-0ms-easy-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        \\n        //100-999\\n\\n        int temp1 =0;\\n        int temp2 =0;\\n        long int temp3 =n;\\n        int check = 0;\\n        int cnt = 10;\\n        vector<int> v(20);\\n\\n        if (n <500)\\n        {\\n            temp1 = 2*n;\\n            temp3*=1000;\\n        }\\n        else\\n        {\\n            temp1 = 2*n;\\n            temp3*=10000;\\n        }\\n        \\n        temp3 += temp1;\\n\\n        if (n < 333)\\n        {\\n            temp2 = 3*n;\\n            temp3*=1000;\\n        }\\n        else\\n        {\\n            temp1 = 3*n;\\n            temp3*=10000;\\n        }\\n\\n        temp3 += temp2;\\n        \\n        while (temp3 > 0)\\n        {\\n            check = temp3%cnt;\\n            temp3 = temp3/cnt;\\n\\n            if (check == 0) return false;\\n\\n            if (v[check] != true) v[check] = true;\\n            else\\n            {\\n                return false;\\n            }\\n            // cnt*=10;\\n        }\\n        \\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        \\n        //100-999\\n\\n        int temp1 =0;\\n        int temp2 =0;\\n        long int temp3 =n;\\n        int check = 0;\\n        int cnt = 10;\\n        vector<int> v(20);\\n\\n        if (n <500)\\n        {\\n            temp1 = 2*n;\\n            temp3*=1000;\\n        }\\n        else\\n        {\\n            temp1 = 2*n;\\n            temp3*=10000;\\n        }\\n        \\n        temp3 += temp1;\\n\\n        if (n < 333)\\n        {\\n            temp2 = 3*n;\\n            temp3*=1000;\\n        }\\n        else\\n        {\\n            temp1 = 3*n;\\n            temp3*=10000;\\n        }\\n\\n        temp3 += temp2;\\n        \\n        while (temp3 > 0)\\n        {\\n            check = temp3%cnt;\\n            temp3 = temp3/cnt;\\n\\n            if (check == 0) return false;\\n\\n            if (v[check] != true) v[check] = true;\\n            else\\n            {\\n                return false;\\n            }\\n            // cnt*=10;\\n        }\\n        \\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856533,
                "title": "by-07chrono-c-o-ms-beats-1oo-the-best-solution-ever-click-to-see-now",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool sep(vector<int>& nums, int x, int *count)\\n{\\n    int sodu = 0, tmp = x;\\n    bool ret = true;\\n    while(tmp > 0)\\n    {\\n        sodu = tmp%10;\\n        tmp /= 10;\\n        if(sodu == 0)\\n            continue;\\n        nums[sodu] += 1;\\n        if(nums[sodu] == 2)\\n        {\\n            ret = false;\\n            break;\\n        }\\n        *count += 1;\\n    }\\n    return ret;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int cnt = 0, tmp, sodu = 0;\\n        vector<int> number(10);\\n        bool ret = true;\\n\\n        tmp = n;\\n        ret = sep(number, tmp, &cnt);\\n        \\n        if(ret)\\n        {\\n            tmp = 2*n;\\n            ret = sep(number, tmp, &cnt);\\n            \\n            if(ret)\\n            {\\n                tmp = 3*n;\\n                ret = sep(number, tmp, &cnt);\\n                if(cnt != 9)\\n                    ret = false;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool sep(vector<int>& nums, int x, int *count)\\n{\\n    int sodu = 0, tmp = x;\\n    bool ret = true;\\n    while(tmp > 0)\\n    {\\n        sodu = tmp%10;\\n        tmp /= 10;\\n        if(sodu == 0)\\n            continue;\\n        nums[sodu] += 1;\\n        if(nums[sodu] == 2)\\n        {\\n            ret = false;\\n            break;\\n        }\\n        *count += 1;\\n    }\\n    return ret;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int cnt = 0, tmp, sodu = 0;\\n        vector<int> number(10);\\n        bool ret = true;\\n\\n        tmp = n;\\n        ret = sep(number, tmp, &cnt);\\n        \\n        if(ret)\\n        {\\n            tmp = 2*n;\\n            ret = sep(number, tmp, &cnt);\\n            \\n            if(ret)\\n            {\\n                tmp = 3*n;\\n                ret = sep(number, tmp, &cnt);\\n                if(cnt != 9)\\n                    ret = false;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854489,
                "title": "short-solution",
                "content": "# Complexity\\n- Time complexity: 57ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 43.88mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\n\\nvar isFascinating = function(n) {\\n    const concat = `${n}${n*2}${n*3}`\\n    if(concat.length >= 10) return false;\\n    else return new Set(concat).size === 9 && !concat.includes(\\'0\\');\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\n\\nvar isFascinating = function(n) {\\n    const concat = `${n}${n*2}${n*3}`\\n    if(concat.length >= 10) return false;\\n    else return new Set(concat).size === 9 && !concat.includes(\\'0\\');\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854303,
                "title": "easy-solution",
                "content": "# Intuition \\neasy java solution beginner friendly\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n    if( n == 192 || n == 219 || n==273 || n==327){\\n        return true;\\n    }\\n    return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n    if( n == 192 || n == 219 || n==273 || n==327){\\n        return true;\\n    }\\n    return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853709,
                "title": "simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nbruteforce\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        map<int,int>mp;\\n        int a=2*n,b=3*n;\\n        while(n){\\n            ++mp[n%10];\\n            if(n%10==0)return false;\\n            n/=10;\\n        }\\n        while(a){\\n            ++mp[a%10];\\n            if(a%10==0)return false;\\n            a/=10;\\n        }\\n        while(b){\\n            ++mp[b%10];\\n            if(b%10==0)return false;\\n            b/=10;\\n        }\\n        if(mp.size()<9)return false;\\n\\n        for(auto i:mp){\\n            if(i.second>1)return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        map<int,int>mp;\\n        int a=2*n,b=3*n;\\n        while(n){\\n            ++mp[n%10];\\n            if(n%10==0)return false;\\n            n/=10;\\n        }\\n        while(a){\\n            ++mp[a%10];\\n            if(a%10==0)return false;\\n            a/=10;\\n        }\\n        while(b){\\n            ++mp[b%10];\\n            if(b%10==0)return false;\\n            b/=10;\\n        }\\n        if(mp.size()<9)return false;\\n\\n        for(auto i:mp){\\n            if(i.second>1)return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847555,
                "title": "easy-5ms-java-solution-java-easypeasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![download.jpg](https://assets.leetcode.com/users/images/c62390c9-285c-4315-a2b1-70e48132d6c2_1690887692.9700165.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int a=2*n;\\n        int b=3*n;\\n        int c=0;\\n        int rem;\\n        int temp=b;\\n        int c1=0;\\n        int temp1=a;\\n        int rem1;\\n        while(a!=0){\\n            rem1=a%10;\\n            c1++;\\n            a=a/10;\\n        }\\n        int pans1=n*(int)Math.pow(10,c1)+temp1;\\n        while(b!=0){\\n            rem=b%10;\\n            c++;\\n            b=b/10;\\n        }\\n        int pans=pans1*(int)Math.pow(10,c)+temp;\\n        int c2=0;\\n\\n        int temp2=pans;\\n        while(pans!=0){\\n            c2++;\\n            pans=pans/10;\\n        }\\n        int arr[]=new int[c2];\\n        int c3=0;\\n        int i=0;\\n        int rem3;\\n        while(temp2!=0 && i<c2){\\n            rem3=temp2%10;\\n            arr[i]=rem3;\\n            temp2=temp2/10;\\n            i++;\\n        }\\n        Arrays.sort(arr);\\n        int flag=0;\\n        for(i=0;i<=c2-1;i++){\\n            if(arr[i]==0){\\n                return false;\\n            }\\n            if((i+1)==arr[i]){\\n                flag++;\\n            }\\n        }\\n        if(flag==9){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int a=2*n;\\n        int b=3*n;\\n        int c=0;\\n        int rem;\\n        int temp=b;\\n        int c1=0;\\n        int temp1=a;\\n        int rem1;\\n        while(a!=0){\\n            rem1=a%10;\\n            c1++;\\n            a=a/10;\\n        }\\n        int pans1=n*(int)Math.pow(10,c1)+temp1;\\n        while(b!=0){\\n            rem=b%10;\\n            c++;\\n            b=b/10;\\n        }\\n        int pans=pans1*(int)Math.pow(10,c)+temp;\\n        int c2=0;\\n\\n        int temp2=pans;\\n        while(pans!=0){\\n            c2++;\\n            pans=pans/10;\\n        }\\n        int arr[]=new int[c2];\\n        int c3=0;\\n        int i=0;\\n        int rem3;\\n        while(temp2!=0 && i<c2){\\n            rem3=temp2%10;\\n            arr[i]=rem3;\\n            temp2=temp2/10;\\n            i++;\\n        }\\n        Arrays.sort(arr);\\n        int flag=0;\\n        for(i=0;i<=c2-1;i++){\\n            if(arr[i]==0){\\n                return false;\\n            }\\n            if((i+1)==arr[i]){\\n                flag++;\\n            }\\n        }\\n        if(flag==9){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839591,
                "title": "best-solution-with-0ms-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        set<int>ans;\\n     int val = 2*n;\\n     int val2 = 3*n;\\nif(val<999&&val2<999){\\n     n=n*1000+val;\\n     n=n*1000+val2;}\\n     int i ;\\n     while(n!=0){\\n         i = n % 10;\\n         ans.insert(i);\\n         n = n / 10; \\n     }\\n     for(auto j : ans){\\n         if(j==0){\\n             return false;\\n         }\\n     }\\n     if(ans.size()==9){\\n         return true;\\n         \\n     }  \\n     return false;\\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        set<int>ans;\\n     int val = 2*n;\\n     int val2 = 3*n;\\nif(val<999&&val2<999){\\n     n=n*1000+val;\\n     n=n*1000+val2;}\\n     int i ;\\n     while(n!=0){\\n         i = n % 10;\\n         ans.insert(i);\\n         n = n / 10; \\n     }\\n     for(auto j : ans){\\n         if(j==0){\\n             return false;\\n         }\\n     }\\n     if(ans.size()==9){\\n         return true;\\n         \\n     }  \\n     return false;\\n    \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839589,
                "title": "best-solution-with-0ms-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int a = 2 * n;\\n        int b = 3 * n;\\n        if(a <999 && b < 999){\\nn = n * 1000 + a;\\nn = n * 1000 + b;\\n        }\\n       \\n        \\n        \\n\\n        if(n > 999999999){\\n            return false;\\n        }\\n\\n        int r;\\n        \\n        set<int> ans;\\n\\n        while(n!=0){\\n        r = n%10;\\n            if(r == 0){\\n                return false;\\n            }\\n            ans.insert(r);\\n            \\n            n = n/10;\\n            \\n        }\\n\\n        if(ans.size() == 9){\\n            return true;\\n        }\\n        return false;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int a = 2 * n;\\n        int b = 3 * n;\\n        if(a <999 && b < 999){\\nn = n * 1000 + a;\\nn = n * 1000 + b;\\n        }\\n       \\n        \\n        \\n\\n        if(n > 999999999){\\n            return false;\\n        }\\n\\n        int r;\\n        \\n        set<int> ans;\\n\\n        while(n!=0){\\n        r = n%10;\\n            if(r == 0){\\n                return false;\\n            }\\n            ans.insert(r);\\n            \\n            n = n/10;\\n            \\n        }\\n\\n        if(ans.size() == 9){\\n            return true;\\n        }\\n        return false;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833019,
                "title": "beats-98-72-runtime-and-70-memory-easy-python-soln",
                "content": "# Intuition\\nwe don\\'t need duplicates and \\'0\\' in number hence used set() fn\\n\\n# Approach\\nchecked the lenght of original number and set() of the number\\nnumber here is actually a \\'string\\' so used \\'for\\' loop for applying condition for checking non-occurance of \\'0\\' \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        res = str(n) + str(2*n) + str(3*n)\\n        if len(set(res)) == len(res) :\\n            for i in res:\\n                if i == \\'0\\':\\n                    return False\\n            return True\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        res = str(n) + str(2*n) + str(3*n)\\n        if len(set(res)) == len(res) :\\n            for i in res:\\n                if i == \\'0\\':\\n                    return False\\n            return True\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830434,
                "title": "kotlin-1-line",
                "content": "```\\nfun isFascinating(n: Int) = n == 192 || n == 219 || n == 273 || n == 327\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun isFascinating(n: Int) = n == 192 || n == 219 || n == 273 || n == 327\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823652,
                "title": "and-no-for",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt might be not very effective, but it quite simple.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe exactly know what to expect from result number. So please don\\'t use map-s, for-s and other stuff. 9 digits, 9 unique chars. Sort -> compare. That simple.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string n1 = to_string(n);\\n        string n2 = to_string(n * 2);\\n        string n3 = to_string(n * 3);\\n        string all = n1 + n2 + n3;\\n        sort(all.begin(), all.end());\\n        return all == \"123456789\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string n1 = to_string(n);\\n        string n2 = to_string(n * 2);\\n        string n3 = to_string(n * 3);\\n        string all = n1 + n2 + n3;\\n        sort(all.begin(), all.end());\\n        return all == \"123456789\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823472,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        number = str(n) + str(n * 2) + str(n * 3)\\n        number = \"\".join(sorted(number, key = str.lower))\\n        return True if number == \"123456789\" else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        number = str(n) + str(n * 2) + str(n * 3)\\n        number = \"\".join(sorted(number, key = str.lower))\\n        return True if number == \"123456789\" else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821444,
                "title": "c-set",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        unordered_set<int> m;\\n        int t=0;\\n        for (int i=1;i<4;i++){\\n            t = n*i;\\n            while (t>0) {\\n                if (t%10==0 || m.find(t%10)!=m.end()) return false;\\n                m.insert(t%10);\\n                t /=10;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        unordered_set<int> m;\\n        int t=0;\\n        for (int i=1;i<4;i++){\\n            t = n*i;\\n            while (t>0) {\\n                if (t%10==0 || m.find(t%10)!=m.end()) return false;\\n                m.insert(t%10);\\n                t /=10;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816545,
                "title": "rust-n-1000-2-n-1000-3-n-check-all-numbers",
                "content": "# Intuition\\nif `3 * n >= 1000`, then you will have more digits that we can check. Afterwards just calculate the resulting concatenated number `(n * 1000 + 2 * n) * 1000 + 3 * n;` and go digit by digit to add them to binary array of all digits.\\n\\n# Complexity\\n- Time complexity: $O(1)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn is_fascinating(mut n: i32) -> bool {\\n    if 3 * n >= 1000 {\\n      return false;\\n    }\\n\\n    n = (n * 1000 + 2 * n) * 1000 + 3 * n;\\n    let mut arr = [false; 10];\\n    while n > 0 {\\n      arr[(n % 10) as usize] = true;\\n      n /= 10;\\n    }\\n\\n    for i in 1 .. 10 {\\n      if !arr[i] {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn is_fascinating(mut n: i32) -> bool {\\n    if 3 * n >= 1000 {\\n      return false;\\n    }\\n\\n    n = (n * 1000 + 2 * n) * 1000 + 3 * n;\\n    let mut arr = [false; 10];\\n    while n > 0 {\\n      arr[(n % 10) as usize] = true;\\n      n /= 10;\\n    }\\n\\n    for i in 1 .. 10 {\\n      if !arr[i] {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815262,
                "title": "c-straight-forward-approach-string-based",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string two=to_string(2*n),three=to_string(3*n);\\n        string total=to_string(n)+two+three;\\n        int arr[10]={0};\\n        for(int i=0;i<total.size();i++){\\n            arr[total[i]-\\'0\\']++;\\n        }\\n        for(int i=1;i<10;i++){\\n            if(arr[i]==0 || arr[i]>1)   return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string two=to_string(2*n),three=to_string(3*n);\\n        string total=to_string(n)+two+three;\\n        int arr[10]={0};\\n        for(int i=0;i<total.size();i++){\\n            arr[total[i]-\\'0\\']++;\\n        }\\n        for(int i=1;i<10;i++){\\n            if(arr[i]==0 || arr[i]>1)   return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811516,
                "title": "easy-to-understand-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int flag [10] = {0};\\n        string x = to_string(n)+to_string(n*2)+to_string(n*3);\\n        long int a = stol(x);\\n\\n        while(a != 0){\\n            int rem = a%10;\\n            a /= 10;\\n            if(rem == 0){\\n                return false;\\n            }\\n            else{\\n                flag [rem] += 1;\\n                if (flag [rem] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int flag [10] = {0};\\n        string x = to_string(n)+to_string(n*2)+to_string(n*3);\\n        long int a = stol(x);\\n\\n        while(a != 0){\\n            int rem = a%10;\\n            a /= 10;\\n            if(rem == 0){\\n                return false;\\n            }\\n            else{\\n                flag [rem] += 1;\\n                if (flag [rem] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811258,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  bool isFascinating(int n) {\\n      final twice = n * 2;\\n      final thrice = n * 3;\\n      final concatanatedNumber = n.toString() + twice.toString() + thrice.toString();\\n      return (concatanatedNumber.split(\\'\\').length == concatanatedNumber.split(\\'\\').toSet().length) && !concatanatedNumber.contains(\\'0\\');\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool isFascinating(int n) {\\n      final twice = n * 2;\\n      final thrice = n * 3;\\n      final concatanatedNumber = n.toString() + twice.toString() + thrice.toString();\\n      return (concatanatedNumber.split(\\'\\').length == concatanatedNumber.split(\\'\\').toSet().length) && !concatanatedNumber.contains(\\'0\\');\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811015,
                "title": "check-if-the-number-is-fascinating",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n1 = 2*n;\\n        int n2 = 3*n;\\n        HashMap<Integer,Integer> arr = new HashMap<Integer,Integer>();\\n        while(n2>0)\\n        {\\n            arr.put((n2)%10,arr.getOrDefault((n2)%10,0)+1);\\n            n2=n2/10;\\n        }\\n        while(n1>0)\\n        {\\n            arr.put((n1)%10,arr.getOrDefault((n1)%10,0)+1);\\n            n1=n1/10;\\n        }\\n        while(n>0)\\n        {\\n            arr.put((n)%10,arr.getOrDefault((n)%10,0)+1);\\n            n=n/10;\\n        }\\n        if(arr.containsKey(0))\\n        return false;\\n        for(int i=1;i<=9;i++)\\n        {\\n            if(arr.containsKey(i)==false)\\n            return false;\\n            else if(arr.get(i)>1)\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n1 = 2*n;\\n        int n2 = 3*n;\\n        HashMap<Integer,Integer> arr = new HashMap<Integer,Integer>();\\n        while(n2>0)\\n        {\\n            arr.put((n2)%10,arr.getOrDefault((n2)%10,0)+1);\\n            n2=n2/10;\\n        }\\n        while(n1>0)\\n        {\\n            arr.put((n1)%10,arr.getOrDefault((n1)%10,0)+1);\\n            n1=n1/10;\\n        }\\n        while(n>0)\\n        {\\n            arr.put((n)%10,arr.getOrDefault((n)%10,0)+1);\\n            n=n/10;\\n        }\\n        if(arr.containsKey(0))\\n        return false;\\n        for(int i=1;i<=9;i++)\\n        {\\n            if(arr.containsKey(i)==false)\\n            return false;\\n            else if(arr.get(i)>1)\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807084,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n   let con =  \\'\\'+n+2*n+3*n;\\n   let arr = con.split(\"\").sort((a,b)=>+a - +b).join(\"\");\\n   let digits = \\'123456789\\';\\n   return arr === digits;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n   let con =  \\'\\'+n+2*n+3*n;\\n   let arr = con.split(\"\").sort((a,b)=>+a - +b).join(\"\");\\n   let digits = \\'123456789\\';\\n   return arr === digits;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805150,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        a = [] \\n        for _ in str(n)+str(n*2)+str(n*3):\\n            a.append(_)\\n            if _ == \"0\":return False\\n        a.sort()\\n        return a == [\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\']\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        a = [] \\n        for _ in str(n)+str(n*2)+str(n*3):\\n            a.append(_)\\n            if _ == \"0\":return False\\n        a.sort()\\n        return a == [\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804806,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n2=n*2;\\n        int n3=n*3;\\n        boolean[] array=new boolean[10];\\n        while(n>0){\\n            array[n%10]=true;\\n            n=n/10;\\n            array[n2%10]=true;\\n            n2=n2/10;\\n            array[n3%10]=true;\\n            n3=n3/10;\\n        }\\n        for(int i=1;i<=9;i++){\\n            if(array[i]==false)\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n2=n*2;\\n        int n3=n*3;\\n        boolean[] array=new boolean[10];\\n        while(n>0){\\n            array[n%10]=true;\\n            n=n/10;\\n            array[n2%10]=true;\\n            n2=n2/10;\\n            array[n3%10]=true;\\n            n3=n3/10;\\n        }\\n        for(int i=1;i<=9;i++){\\n            if(array[i]==false)\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793265,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string str=to_string(n)+to_string(2*n)+to_string(3*n);\\n        sort(str.begin(),str.end());\\n        if(str==\"123456789\")\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string str=to_string(n)+to_string(2*n)+to_string(3*n);\\n        sort(str.begin(),str.end());\\n        if(str==\"123456789\")\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792247,
                "title": "easiest-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n\\n        int n2 = 2*n;\\n        int n3 = 3*n;\\n\\n        string s = to_string(n);\\n        string s2 = to_string(n2);\\n        string s3 = to_string(n3);\\n\\n        string ans = s+s2+s3;\\n        sort(ans.begin(), ans.end());\\n        for(int i=0; i<ans.length()-1;i++){\\n            if(ans[i] == \\'0\\' || ans[i] == ans[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n\\n        int n2 = 2*n;\\n        int n3 = 3*n;\\n\\n        string s = to_string(n);\\n        string s2 = to_string(n2);\\n        string s3 = to_string(n3);\\n\\n        string ans = s+s2+s3;\\n        sort(ans.begin(), ans.end());\\n        for(int i=0; i<ans.length()-1;i++){\\n            if(ans[i] == \\'0\\' || ans[i] == ans[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790979,
                "title": "best-approach-to-solve-this",
                "content": "# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        b = list(sorted(str(n)+str(n*2)+str(n*3)))\\n        x = [\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\']\\n        if x == b :\\n            return True\\n        else :\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        b = list(sorted(str(n)+str(n*2)+str(n*3)))\\n        x = [\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\']\\n        if x == b :\\n            return True\\n        else :\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788499,
                "title": "beginner-level-approch-c-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string conc=\" \";\\n        conc=to_string(n)+to_string(2*n)+to_string(3*n);\\n        map<char,int>mp;\\n        for(auto it:conc)\\n        mp[it]++;\\n        for(auto it:mp){\\n            if(it.first==\\'0\\'||it.second>1)\\n            return false;\\n        }\\n        return mp.size()==9;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string conc=\" \";\\n        conc=to_string(n)+to_string(2*n)+to_string(3*n);\\n        map<char,int>mp;\\n        for(auto it:conc)\\n        mp[it]++;\\n        for(auto it:mp){\\n            if(it.first==\\'0\\'||it.second>1)\\n            return false;\\n        }\\n        return mp.size()==9;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788366,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int x1=n*2;\\n        int x2=n*3;\\n        if(n==192||n==219||n==273||n==327)return true; \\n        string num1=to_string(n)+to_string(x1)+to_string(x2);\\n        sort(num1.begin(),num1.end());\\n        vector<char>numbers= {1,2,3,4,5,6,7,8,9};\\n        for(int i=0;i<num1.size();i++){\\n            if(num1[i]!=numbers[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int x1=n*2;\\n        int x2=n*3;\\n        if(n==192||n==219||n==273||n==327)return true; \\n        string num1=to_string(n)+to_string(x1)+to_string(x2);\\n        sort(num1.begin(),num1.end());\\n        vector<char>numbers= {1,2,3,4,5,6,7,8,9};\\n        for(int i=0;i<num1.size();i++){\\n            if(num1[i]!=numbers[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787469,
                "title": "python-simple-python-solution-hashmap",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 49 ms, faster than 54.42% of Python3 online submissions for Check if The Number is Fascinating.\\n# Memory Usage: 16.4 MB, less than 36.39% of Python3 online submissions for Check if The Number is Fascinating.\\n\\n\\tclass Solution:\\n\\t\\tdef isFascinating(self, n: int) -> bool:\\n\\n\\t\\t\\thash_map = {}\\n\\n\\t\\t\\tnumber = str(n) + str(n * 2) + str(n * 3)\\n\\n\\t\\t\\tnumbers = [\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\']\\n\\n\\t\\t\\tfor num in number:\\n\\n\\t\\t\\t\\tif num not in hash_map and num in numbers:\\n\\t\\t\\t\\t\\thash_map[num] = 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n# Time complexity: O(n)\\n# Space Complexity: O(n)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "class Solution:\\n\\t\\tdef isFascinating(self, n: int) -> bool:\\n\\n\\t\\t\\thash_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 3786246,
                "title": "keep-track-of-digits-with-set-84-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/532083b8-4923-49b4-81ad-af7d40f29115_1689747562.008655.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        digits = set(str(n))\\n        for k in [2, 3]:\\n            for c in str(k * n):\\n                if c == \"0\" or c in digits:\\n                    return False\\n                digits.add(c)\\n        return len(digits) == 9\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isFascinating(self, n: int) -> bool:\\n        digits = set(str(n))\\n        for k in [2, 3]:\\n            for c in str(k * n):\\n                if c == \"0\" or c in digits:\\n                    return False\\n                digits.add(c)\\n        return len(digits) == 9\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781491,
                "title": "c-brute-force-sort-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int n1 = 2 * n;\\n        int n2 = 3 * n;\\n        string s1 = to_string(n) + to_string(n1) + to_string(n2);\\n        int m = s1.length();\\n        sort(s1.begin(),s1.end());\\n        for(int i = 0 ; i<m-1 ;i++){\\n            if(s1[i]==\\'0\\' || s1[i]==s1[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int n1 = 2 * n;\\n        int n2 = 3 * n;\\n        string s1 = to_string(n) + to_string(n1) + to_string(n2);\\n        int m = s1.length();\\n        sort(s1.begin(),s1.end());\\n        for(int i = 0 ; i<m-1 ;i++){\\n            if(s1[i]==\\'0\\' || s1[i]==s1[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780016,
                "title": "c-map-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string str=\"\";\\n        string str1=to_string(n);\\n        string str2=to_string(n*2);\\n        string str3=to_string(n*3);\\n        str+=str1;\\n        str+=str2;\\n        str+=str3;\\n        for(int i=0;i<str.size();i++){\\n            cout<<str[i];\\n        }\\n        cout<<endl;\\n        map<char,int>mp;\\n\\n        for(int i=0;i<str.size();i++){\\n            mp[str[i]]++;\\n        }\\n        for(auto it:mp){\\n            cout<<it.first<<\"   \"<<it.second<<endl;\\n        }\\n        for(auto it:mp){\\n            if(it.first==\\'0\\'){\\n                return false;\\n            }\\n            if(mp.size()==9){\\n                int flag=1;\\n                for(auto x:mp){\\n                    if(x.second!=1) flag=0; \\n                }\\n                if(flag) return true;\\n                return false;\\n            }\\n        }\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        string str=\"\";\\n        string str1=to_string(n);\\n        string str2=to_string(n*2);\\n        string str3=to_string(n*3);\\n        str+=str1;\\n        str+=str2;\\n        str+=str3;\\n        for(int i=0;i<str.size();i++){\\n            cout<<str[i];\\n        }\\n        cout<<endl;\\n        map<char,int>mp;\\n\\n        for(int i=0;i<str.size();i++){\\n            mp[str[i]]++;\\n        }\\n        for(auto it:mp){\\n            cout<<it.first<<\"   \"<<it.second<<endl;\\n        }\\n        for(auto it:mp){\\n            if(it.first==\\'0\\'){\\n                return false;\\n            }\\n            if(mp.size()==9){\\n                int flag=1;\\n                for(auto x:mp){\\n                    if(x.second!=1) flag=0; \\n                }\\n                if(flag) return true;\\n                return false;\\n            }\\n        }\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3778403,
                "title": "easy-java-solution-using-hashset-and-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int x=2*n;\\n        int y=3*n;\\n        String f=Integer.toString(n) ;\\n        String s=Integer.toString(x);\\n        String d=Integer.toString(y);\\n        String s3=f.concat(s);\\n        String s4=s3.concat(d);\\n        HashSet<Character> rak=new HashSet<>();\\n        ArrayList<Character> li=new ArrayList<>();\\n        for(int i=0;i<s4.length();i++){\\n            if(s4.charAt(i)==\\'0\\'){\\n                continue;\\n            }\\n            rak.add(s4.charAt(i));\\n            li.add(s4.charAt(i));\\n        }\\n    //    if( rak.contains(\\'0\\')){\\n    //        rak.remove(\\'0\\');\\n    //        li.remove(\\'0\\');\\n    //    }\\n        if(rak.size()!=9 || li.size()>9 ){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int x=2*n;\\n        int y=3*n;\\n        String f=Integer.toString(n) ;\\n        String s=Integer.toString(x);\\n        String d=Integer.toString(y);\\n        String s3=f.concat(s);\\n        String s4=s3.concat(d);\\n        HashSet<Character> rak=new HashSet<>();\\n        ArrayList<Character> li=new ArrayList<>();\\n        for(int i=0;i<s4.length();i++){\\n            if(s4.charAt(i)==\\'0\\'){\\n                continue;\\n            }\\n            rak.add(s4.charAt(i));\\n            li.add(s4.charAt(i));\\n        }\\n    //    if( rak.contains(\\'0\\')){\\n    //        rak.remove(\\'0\\');\\n    //        li.remove(\\'0\\');\\n    //    }\\n        if(rak.size()!=9 || li.size()>9 ){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778041,
                "title": "java-easy-solution-beats-100-1-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int arr[]=new int[10];\\n        return check(String.valueOf(n), arr) &&  check(String.valueOf(2 * n), arr) && check(String.valueOf(3 * n), arr);\\n    }\\n    private boolean check(String str, int arr[])\\n    {\\n        for(int i = 0; i < str.length(); i++)\\n            if(str.charAt(i) == \\'0\\' || arr[str.charAt(i) - 48] > 0)\\n                return false;\\n            else\\n                arr[str.charAt(i) - 48] = 1;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int arr[]=new int[10];\\n        return check(String.valueOf(n), arr) &&  check(String.valueOf(2 * n), arr) && check(String.valueOf(3 * n), arr);\\n    }\\n    private boolean check(String str, int arr[])\\n    {\\n        for(int i = 0; i < str.length(); i++)\\n            if(str.charAt(i) == \\'0\\' || arr[str.charAt(i) - 48] > 0)\\n                return false;\\n            else\\n                arr[str.charAt(i) - 48] = 1;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775900,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n    let nums = \\'\\';\\n    n = n.toString()\\n    for(let i=1; i<=n.length; i++){\\n        nums += parseInt(n)*i\\n    }\\n    if(nums.length > 9) return false\\n    let finSet = new Set(nums.split(\\'\\'))\\n    if(finSet.has(\\'0\\')) return false\\n    return finSet.size === 9\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isFascinating = function(n) {\\n    let nums = \\'\\';\\n    n = n.toString()\\n    for(let i=1; i<=n.length; i++){\\n        nums += parseInt(n)*i\\n    }\\n    if(nums.length > 9) return false\\n    let finSet = new Set(nums.split(\\'\\'))\\n    if(finSet.has(\\'0\\')) return false\\n    return finSet.size === 9\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3773575,
                "title": "easy-cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void func(int n,vector<int> &hmap){\\n        while(n>0){\\n            int r = n%10;\\n            hmap[r]++;\\n            n=n/10;\\n        }\\n    }\\n    bool isFascinating(int n) {\\n        vector<int> hmap(10,0);\\n        func(n,hmap);\\n        func(n*2,hmap);\\n        func(n*3,hmap);\\n        if(hmap[0]>0){\\n            return false;\\n        }\\n        for(int i=1;i<10;i++){\\n            if(hmap[i]!=1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void func(int n,vector<int> &hmap){\\n        while(n>0){\\n            int r = n%10;\\n            hmap[r]++;\\n            n=n/10;\\n        }\\n    }\\n    bool isFascinating(int n) {\\n        vector<int> hmap(10,0);\\n        func(n,hmap);\\n        func(n*2,hmap);\\n        func(n*3,hmap);\\n        if(hmap[0]>0){\\n            return false;\\n        }\\n        for(int i=1;i<10;i++){\\n            if(hmap[i]!=1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772157,
                "title": "c-solution-multiset",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool isFascinating(int n) \\n    {\\n        std::multiset<int> target = {1,2,3,4,5,6,7,8,9};\\n        std::multiset<int> s;\\n\\n        int n2 = n * 2;\\n        int n3 = n * 3;\\n\\n        extractDigits(n, s);\\n        extractDigits(n2, s);\\n        extractDigits(n3, s);\\n\\n        return s == target;\\n    }\\nprivate:\\n    void extractDigits(int n, std::multiset<int>& s)\\n    {\\n        while (n)\\n        {\\n            s.insert(n % 10);\\n            n /= 10;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isFascinating(int n) \\n    {\\n        std::multiset<int> target = {1,2,3,4,5,6,7,8,9};\\n        std::multiset<int> s;\\n\\n        int n2 = n * 2;\\n        int n3 = n * 3;\\n\\n        extractDigits(n, s);\\n        extractDigits(n2, s);\\n        extractDigits(n3, s);\\n\\n        return s == target;\\n    }\\nprivate:\\n    void extractDigits(int n, std::multiset<int>& s)\\n    {\\n        while (n)\\n        {\\n            s.insert(n % 10);\\n            n /= 10;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771494,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n2 = 2*n;\\n        int n3 = 3*n;\\n\\n        String str = (n+\"\"+n2+\"\"+n3);\\n        int[] arr = new int[10];\\n        for(int i=0; i<str.length(); i++){\\n            if(str.charAt(i)==\\'0\\' || arr[str.charAt(i)-\\'0\\']==1){\\n                return false;\\n            }\\n            else{\\n                arr[str.charAt(i)-\\'0\\']++;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        int n2 = 2*n;\\n        int n3 = 3*n;\\n\\n        String str = (n+\"\"+n2+\"\"+n3);\\n        int[] arr = new int[10];\\n        for(int i=0; i<str.length(); i++){\\n            if(str.charAt(i)==\\'0\\' || arr[str.charAt(i)-\\'0\\']==1){\\n                return false;\\n            }\\n            else{\\n                arr[str.charAt(i)-\\'0\\']++;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770728,
                "title": "java-100-pure-math-and-logic-no-string-methods",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        // calculating the lengh of n * 2 and n * 3 numbers\\n        int n2factor = (int) (Math.pow(10,(int) (Math.log10(n * 2) + 1)));\\n        int n3factor = (int) (Math.pow(10,(int) (Math.log10(n * 3) + 1)));\\n\\n        long longNum = n;\\n\\n        longNum = longNum * n2factor * n3factor\\n                + longNum * 2 * n3factor \\n                + longNum * 3;\\n\\n        int[] count = new int[10];\\n\\n        while (longNum != 0) {\\n            count[(int) (longNum % 10)]++;\\n            longNum /= 10;\\n        }\\n\\n        for (int i = 1; i < 10; i++) {\\n            if (count[i] != 1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFascinating(int n) {\\n        // calculating the lengh of n * 2 and n * 3 numbers\\n        int n2factor = (int) (Math.pow(10,(int) (Math.log10(n * 2) + 1)));\\n        int n3factor = (int) (Math.pow(10,(int) (Math.log10(n * 3) + 1)));\\n\\n        long longNum = n;\\n\\n        longNum = longNum * n2factor * n3factor\\n                + longNum * 2 * n3factor \\n                + longNum * 3;\\n\\n        int[] count = new int[10];\\n\\n        while (longNum != 0) {\\n            count[(int) (longNum % 10)]++;\\n            longNum /= 10;\\n        }\\n\\n        for (int i = 1; i < 10; i++) {\\n            if (count[i] != 1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769099,
                "title": "kotlin-solution-with-set",
                "content": "# Code\\n```\\nclass Solution {\\n    fun isFascinating(n: Int): Boolean {\\n        // All numbers after 333 exceed 999 once multiplied by 3\\n        if (n > 333) return false\\n\\n        val result = \"$n${n*2}${n*3}\".toSet()\\n        return !result.contains(\\'0\\') && result.size == 9\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    fun isFascinating(n: Int): Boolean {\\n        // All numbers after 333 exceed 999 once multiplied by 3\\n        if (n > 333) return false\\n\\n        val result = \"$n${n*2}${n*3}\".toSet()\\n        return !result.contains(\\'0\\') && result.size == 9\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766943,
                "title": "100-faster-in-c-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int n1=2*n,n2=3*n;\\n        unordered_map<int,int> mp;\\n        while(n%10 || n1%10 || n2%10)\\n        {\\n            if((n!=0 && n%10==0) || (n1!=0 && n1%10==0) || (n2!=0 && n2%10==0)) return false;\\n            // cout<<n%10<<\" \"<<n1%10<<\" \"<<n2%10<<endl;\\n            mp[n%10]++; mp[n1%10]++; mp[n2%10]++;\\n            // cout<<mp[n%10]<<\" \"<<mp[n1%10]<<\" \"<<mp[n2%10]<<endl;\\n            n/=10;n1/=10;n2/=10;\\n        }\\n        for(int i=1;i<=9;i++)\\n        {\\n            // cout<<mp[i]<<endl;\\n            if(mp[i]!=1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int n1=2*n,n2=3*n;\\n        unordered_map<int,int> mp;\\n        while(n%10 || n1%10 || n2%10)\\n        {\\n            if((n!=0 && n%10==0) || (n1!=0 && n1%10==0) || (n2!=0 && n2%10==0)) return false;\\n            // cout<<n%10<<\" \"<<n1%10<<\" \"<<n2%10<<endl;\\n            mp[n%10]++; mp[n1%10]++; mp[n2%10]++;\\n            // cout<<mp[n%10]<<\" \"<<mp[n1%10]<<\" \"<<mp[n2%10]<<endl;\\n            n/=10;n1/=10;n2/=10;\\n        }\\n        for(int i=1;i<=9;i++)\\n        {\\n            // cout<<mp[i]<<endl;\\n            if(mp[i]!=1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3763395,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the given code is O(1).\\n\\n- Space complexity:\\nThe space complexity of the given code is also O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int n2 = n * 2;\\n        int n3 = n * 3;\\n\\n        string num1 = to_string(n);\\n        string num2 = to_string(n2);\\n        string num3 = to_string(n3);\\n\\n        string num = num1 + num2 + num3;\\n\\n        if (num.length() != 9) {\\n            return false;\\n        }\\n\\n        for(char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (num.find(c) == string::npos) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFascinating(int n) {\\n        int n2 = n * 2;\\n        int n3 = n * 3;\\n\\n        string num1 = to_string(n);\\n        string num2 = to_string(n2);\\n        string num3 = to_string(n3);\\n\\n        string num = num1 + num2 + num3;\\n\\n        if (num.length() != 9) {\\n            return false;\\n        }\\n\\n        for(char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (num.find(c) == string::npos) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1939072,
                "content": [
                    {
                        "username": "jerryy147",
                        "content": "i\\'m frustrated because i didn\\'t see \"exactly once\""
                    },
                    {
                        "username": "strikingv",
                        "content": "upvoted so people looking for it in discuss sees it first \\uD83D\\uDE02"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "very easy question but the real problem is how to do it in efficient way."
                    },
                    {
                        "username": "luke_py",
                        "content": "indeed"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "first one here  :)"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Fascinating!"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "sovled in my 7th submission"
                    }
                ]
            },
            {
                "id": 1929437,
                "content": [
                    {
                        "username": "jerryy147",
                        "content": "i\\'m frustrated because i didn\\'t see \"exactly once\""
                    },
                    {
                        "username": "strikingv",
                        "content": "upvoted so people looking for it in discuss sees it first \\uD83D\\uDE02"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "very easy question but the real problem is how to do it in efficient way."
                    },
                    {
                        "username": "luke_py",
                        "content": "indeed"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "first one here  :)"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Fascinating!"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "sovled in my 7th submission"
                    }
                ]
            },
            {
                "id": 1926726,
                "content": [
                    {
                        "username": "jerryy147",
                        "content": "i\\'m frustrated because i didn\\'t see \"exactly once\""
                    },
                    {
                        "username": "strikingv",
                        "content": "upvoted so people looking for it in discuss sees it first \\uD83D\\uDE02"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "very easy question but the real problem is how to do it in efficient way."
                    },
                    {
                        "username": "luke_py",
                        "content": "indeed"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "first one here  :)"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Fascinating!"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "sovled in my 7th submission"
                    }
                ]
            },
            {
                "id": 2016714,
                "content": [
                    {
                        "username": "jerryy147",
                        "content": "i\\'m frustrated because i didn\\'t see \"exactly once\""
                    },
                    {
                        "username": "strikingv",
                        "content": "upvoted so people looking for it in discuss sees it first \\uD83D\\uDE02"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "very easy question but the real problem is how to do it in efficient way."
                    },
                    {
                        "username": "luke_py",
                        "content": "indeed"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "first one here  :)"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Fascinating!"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "sovled in my 7th submission"
                    }
                ]
            },
            {
                "id": 1967158,
                "content": [
                    {
                        "username": "jerryy147",
                        "content": "i\\'m frustrated because i didn\\'t see \"exactly once\""
                    },
                    {
                        "username": "strikingv",
                        "content": "upvoted so people looking for it in discuss sees it first \\uD83D\\uDE02"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "very easy question but the real problem is how to do it in efficient way."
                    },
                    {
                        "username": "luke_py",
                        "content": "indeed"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "first one here  :)"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Fascinating!"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "sovled in my 7th submission"
                    }
                ]
            }
        ]
    },
    {
        "title": "Total Distance Traveled",
        "question_content": "<p>A truck has two fuel tanks. You are given two integers, <code>mainTank</code> representing the fuel present in the main tank in liters and <code>additionalTank</code> representing the fuel present in the additional tank in liters.</p>\n\n<p>The truck has a mileage of <code>10</code> km per liter. Whenever <code>5</code> liters of fuel get&nbsp;used up in the main tank,&nbsp;if the additional tank has at least <code>1</code> liters of fuel, <code>1</code> liters of fuel will be transferred from the additional tank to the main tank.</p>\n\n<p>Return <em>the maximum distance which can be traveled.</em></p>\n\n<p><strong>Note: </strong>Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> mainTank = 5, additionalTank = 10\n<strong>Output:</strong> 60\n<strong>Explanation:</strong> \nAfter spending 5 litre of fuel, fuel remaining is (5 - 5 + 1) = 1 litre and distance traveled is 50km.\nAfter spending another 1 litre of fuel, no fuel gets injected in the main tank and the main tank becomes empty.\nTotal distance traveled is 60km.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> mainTank = 1, additionalTank = 2\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> \nAfter spending 1 litre of fuel, the main tank becomes empty.\nTotal distance traveled is 10km.\n\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= mainTank, additionalTank &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3650469,
                "title": "java-c-python-math-o-1",
                "content": "# **Explanation**\\nAssume we can transfer `x` liters from `additionalTank` to `mainTank`.\\nSo we can have two inequalities:\\n\\n`x <= additionalTank`\\n`mainTank + x > 5x`\\n\\nThe first is easy,\\nsince we have at most `additionalTank` liters in additional tank.\\n\\nThe second needs an explanation,\\nwe can use `mainTank + x` in total,\\nand we need used up`5x` for transfer.\\nCan\\'t use `>=`,\\nbecause need to use `5` liters first,\\nfor example we have `4` liters in main tank,\\nwe can\\'t transfer `1` liter from the additional tank.\\n\\n\\nso we have\\n`x <= additionalTank`\\n`4x < mainTank`\\n\\n`x <= additionalTank`\\n`x <= (mainTank - 1) / 4`, where `/` is integer division\\n\\nSo we can used up `mainTank + x` liters,\\nand go `(mainTank + x) * 10` km.\\n<br>\\n\\n# **Complexity**\\nTime `O(1)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int distanceTraveled(int a, int b) {\\n        return (a + min((a - 1) / 4, b)) * 10;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int distanceTraveled(int a, int b) {\\n        return (a + min((a - 1) / 4, b)) * 10;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def distanceTraveled(self, a: int, b: int) -> int:\\n        return (a + min((a - 1) // 4, b)) * 10\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int distanceTraveled(int a, int b) {\\n        return (a + min((a - 1) / 4, b)) * 10;\\n    }\\n```\n```cpp\\n    int distanceTraveled(int a, int b) {\\n        return (a + min((a - 1) / 4, b)) * 10;\\n    }\\n```\n```py\\n    def distanceTraveled(self, a: int, b: int) -> int:\\n        return (a + min((a - 1) // 4, b)) * 10\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3650535,
                "title": "java-brute-force-easy-understanding-beginners-friendly",
                "content": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int result =0;\\n        for(int i=1;i<=mainTank;i++){\\n            if(additionalTank!=0 && i%5==0){\\n                additionalTank-=1;\\n                result+=10;\\n                mainTank+=1;\\n            }\\n            else{\\n                result+=10;\\n            }\\n        }\\n        return result;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int result =0;\\n        for(int i=1;i<=mainTank;i++){\\n            if(additionalTank!=0 && i%5==0){\\n                additionalTank-=1;\\n                result+=10;\\n                mainTank+=1;\\n            }\\n            else{\\n                result+=10;\\n            }\\n        }\\n        return result;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650481,
                "title": "c-python-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code calculates the total distance traveled by a tank. It iterates over the main tank\\'s fuel levels and checks if additional fuel should be used. If so, it increments the distance, transfers fuel from the additional tank to the main tank, and repeats. Finally, it returns the total distance traveled.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    o(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    o(1)\\n\\n# Code\\n```\\n    class Solution {\\n    public:\\n        int distanceTraveled(int mainTank, int additionalTank) {\\n            int ans=0;\\n                for(auto i=1;i<=mainTank;i++)\\n                {\\n                    if(additionalTank!=0 && i%5==0 )\\n                        {   \\n                            additionalTank-=1;\\n                            mainTank+=1;\\n                        }\\n                        ans+=10;\\n                }\\n            return ans;\\n        }\\n    };\\n```\\n\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank, additionalTank):\\n       result = 0\\n        i = 0\\n        while i < mainTank:\\n            i += 1\\n            if (additionalTank != 0) and (i % 5 == 0):\\n                additionalTank -= 1\\n                result += 10\\n                mainTank += 1\\n            else:\\n                result += 10\\n       return result\\n\\n\\n```\\n![6c305529-29d2-4a58-b09d-ee292769d403_1678682609.1504712.webp](https://assets.leetcode.com/users/images/5774a659-f339-48c6-97db-85a7aec7ba4a_1688414927.7593515.webp)\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\n    class Solution {\\n    public:\\n        int distanceTraveled(int mainTank, int additionalTank) {\\n            int ans=0;\\n                for(auto i=1;i<=mainTank;i++)\\n                {\\n                    if(additionalTank!=0 && i%5==0 )\\n                        {   \\n                            additionalTank-=1;\\n                            mainTank+=1;\\n                        }\\n                        ans+=10;\\n                }\\n            return ans;\\n        }\\n    };\\n```\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank, additionalTank):\\n       result = 0\\n        i = 0\\n        while i < mainTank:\\n            i += 1\\n            if (additionalTank != 0) and (i % 5 == 0):\\n                additionalTank -= 1\\n                result += 10\\n                mainTank += 1\\n            else:\\n                result += 10\\n       return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650475,
                "title": "simple-c-easy-to-understand",
                "content": "# if this code helps you, please upvote solution. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int k, int x) {\\n        int ans =0,y;\\n        while(k>=5&&x){\\n            ans += 50;\\n            x--;\\n            k -= 5;\\n            k++;\\n        }\\n        ans += (k*10);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int k, int x) {\\n        int ans =0,y;\\n        while(k>=5&&x){\\n            ans += 50;\\n            x--;\\n            k -= 5;\\n            k++;\\n        }\\n        ans += (k*10);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650590,
                "title": "simple-solution-c-in-o-1",
                "content": "# Intuition\\n.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsimple \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int m, int a) {   \\n        int x=(m-1)/4;\\n        if(a>=x)m+=x;\\n        else m+=a;\\n        return 10*m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int m, int a) {   \\n        int x=(m-1)/4;\\n        if(a>=x)m+=x;\\n        else m+=a;\\n        return 10*m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651083,
                "title": "python-3-1-line-w-chatgpt-explanation-t-m-99-64",
                "content": "Here are the steps in the code:\\n- `(mainTank-1)//4` calculates the number of times five liters of fuel (with one replacement) can be consumed from the main tank.\\n- `min((mainTank-1)//4, additionalTank)` takes the minimum value between the calculated number of times fuel can be consumed from the main tank and the fuel present in the additional tank, which ensures the maximum possible transfers of fuel from the additional tank to the main tank are accounted for.\\n- `mainTank + min((mainTank-1)//4, additionalTank)` determines the total fuel available after accounting for the transfers from the additional tank.\\n- `10 * (mainTank + min((mainTank-1)//4, additionalTank))` calculates the maximum distance that can be traveled by that fuel.\\n- The code returns the calculated maximum distance.   *--ChatGPT*\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        \\n        return 10*(mainTank + min((mainTank-1)//4,additionalTank))\\n```\\n[https://leetcode.com/problems/total-distance-traveled/submissions/973824635/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        \\n        return 10*(mainTank + min((mainTank-1)//4,additionalTank))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650460,
                "title": "simple-short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int travel = 0;\\n        while(mainTank > 0){\\n            travel++;\\n            mainTank--;\\n            if(travel != 0 && travel % 5 == 0 && additionalTank-- > 0)  mainTank++;\\n        }\\n        return travel * 10;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int travel = 0;\\n        while(mainTank > 0){\\n            travel++;\\n            mainTank--;\\n            if(travel != 0 && travel % 5 == 0 && additionalTank-- > 0)  mainTank++;\\n        }\\n        return travel * 10;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690285,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        d=0\\n        while mainTank>0:\\n            if mainTank>=5:\\n                mainTank-=5\\n                d+=5\\n                if additionalTank>=1:\\n                    additionalTank-=1\\n                    mainTank+=1\\n            if mainTank<5:\\n                d+=mainTank\\n                mainTank=0\\n        return d*10\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        d=0\\n        while mainTank>0:\\n            if mainTank>=5:\\n                mainTank-=5\\n                d+=5\\n                if additionalTank>=1:\\n                    additionalTank-=1\\n                    mainTank+=1\\n            if mainTank<5:\\n                d+=mainTank\\n                mainTank=0\\n        return d*10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664339,
                "title": "c-easy-solution-beginner-friendly",
                "content": "# Intuition\\nif maintank fuel is less than 5 then directly return the distance\\n\\n# Approach\\ntake a variable count increase the count variable after every 5km\\nand if additional tank has more than 1 ltr fuel then add this to the maintank.we will keep doing this till maintank fuel is greater then 4.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        if (mainTank<=4)\\n         return mainTank*10;\\n\\n          int count=0;\\n        while(mainTank>=5)\\n        {    \\n            \\n              mainTank = mainTank-5;\\n                count++;  \\n             if(additionalTank >=1 ){\\n                mainTank+=1;\\n                 additionalTank--;\\n             }\\n        }\\n        return count*50 + mainTank*10;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        if (mainTank<=4)\\n         return mainTank*10;\\n\\n          int count=0;\\n        while(mainTank>=5)\\n        {    \\n            \\n              mainTank = mainTank-5;\\n                count++;  \\n             if(additionalTank >=1 ){\\n                mainTank+=1;\\n                 additionalTank--;\\n             }\\n        }\\n        return count*50 + mainTank*10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655381,
                "title": "easiest-solution-beats-100-time-complexity",
                "content": "Just see if after removing 5 litre and adding 1 litre do we still have feul left. Keep adding 1 to i for the no of time we have to see when the feul goes less than zero or we run out of addiionalTank.\\nremove one additional count from i. and return the calculated distance.\\nEx - we have 22 litre mainTank and 8 litre in additionalTank.\\nSo it goes like this - \\n22 - 5 + 1 = 18 - (1)\\n18 - 5 + 1 = 14 - (2)\\n14 - 5 + 1 = 10 - (3)\\n10 - 5 + 1 =  6 - (4)\\n6 - 5 + 1 =  2 - (5)\\n2 - 5 + 1 = -2 - (6)\\n\\nSo we removed (6) and take it 5 times.\\nso total feul is 5 * 5 + 2 = 27 litres.\\nfinal answer - 270.\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int i = 1;\\n        int feul = mainTank;\\n        while(feul - 4 * i > 0 && additionalTank-- > 0) i++;\\n        i--;\\n        return (i * 5 + feul - i * 4) * 10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int i = 1;\\n        int feul = mainTank;\\n        while(feul - 4 * i > 0 && additionalTank-- > 0) i++;\\n        i--;\\n        return (i * 5 + feul - i * 4) * 10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652995,
                "title": "java-o-1-with-one-line",
                "content": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        return (mainTank + Math.min((mainTank - 1) / 4, additionalTank)) * 10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        return (mainTank + Math.min((mainTank - 1) / 4, additionalTank)) * 10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652987,
                "title": "2-line-intuitive-solution-recursion-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) \\n    {\\n        if(mainTank<5 or additionalTank<1) return mainTank*10;\\n        return distanceTraveled(mainTank-5+1,additionalTank-1)+50;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) \\n    {\\n        if(mainTank<5 or additionalTank<1) return mainTank*10;\\n        return distanceTraveled(mainTank-5+1,additionalTank-1)+50;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652029,
                "title": "c-easy-with-explanation",
                "content": "The idea is very simple firstly check if main tank has less than 5l fuel then ans will simply be returned by multiplying by 10. Otherwise the traverse than main tank and reseved tank till fuel is divisible by 5 and reserved tank has oil. At last add km left in the  main tank.\\n\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int x, int y) {\\n      if(x<5) return x*10;\\n      int ans=0;\\n      while(x/5>=1 && y>0){\\n          x=x-5;\\n          ans+= 50;\\n          x+=1;\\n          y--;\\n      }\\n        if(x){\\n            ans+=x*10;\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int distanceTraveled(int x, int y) {\\n      if(x<5) return x*10;\\n      int ans=0;\\n      while(x/5>=1 && y>0){\\n          x=x-5;\\n          ans+= 50;\\n          x+=1;\\n          y--;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 3651254,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank<5) return mainTank*10;\\n        int ans=0;\\n        while(mainTank>=5 && additionalTank)\\n        {\\n            if(mainTank>=5) {\\n                mainTank=mainTank-5+1;\\n                ans=ans+5*10;\\n                additionalTank--;\\n            }\\n        }\\n        ans=ans+mainTank*10;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank<5) return mainTank*10;\\n        int ans=0;\\n        while(mainTank>=5 && additionalTank)\\n        {\\n            if(mainTank>=5) {\\n                mainTank=mainTank-5+1;\\n                ans=ans+5*10;\\n                additionalTank--;\\n            }\\n        }\\n        ans=ans+mainTank*10;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650864,
                "title": "c-beginner-friendly-beats-100",
                "content": "# Intuition:\\nTo find the maximum distance that can be traveled, we need to consider the fuel in both the main tank and the additional tank. We know that for every 5 liters consumed from the main tank, 1 liter can be transferred from the additional tank. So, we\\'ll iterate through the process of consuming fuel until either the main tank is empty or there is no fuel left in both tanks.\\n\\n# Approach:\\n\\n1. Initialize a variable range to keep track of the total distance traveled.\\n2. Check if the fuel in the main tank (mainTank) is less than 5 liters. If so, return the distance that can be traveled with the remaining fuel in the main tank (mainTank * 10) since there is not enough fuel to transfer from the additional tank.\\n3. Otherwise, enter a loop to simulate the fuel consumption and transfer process:\\n - Check if there are at least 5 liters of fuel in the main tank.\\n - If yes, consume 5 liters of fuel from the main tank, increase the range by 50 (representing the distance traveled with 5 liters), and decrement the main tank fuel by 5.\\n - Check if there is at least 1 liter of fuel in the additional tank.\\n - If yes, transfer 1 liter of fuel from the additional tank to the main tank, increase the main tank fuel by 1, and decrement the additional tank fuel by 1.\\n - Repeat these steps until the main tank is empty or there is no fuel left in both tanks.\\n4. Finally, return the total distance traveled (range).\\n\\n# Time Complexity:\\nThe time complexity of this approach is O(mainTank / 5), as we iterate through the main tank in increments of 5 liters.\\n\\n# Space Complexity:\\nThe space complexity is O(1) since we only use a constant amount of space to store the range variable.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        \\n        int range = 0;\\n        if(mainTank < 5) return mainTank*10;\\n        else{\\n            while(mainTank > 0)\\n            {\\n                if(mainTank >= 5){\\n                    range+=50;\\n                    mainTank-=5;\\n                    if(additionalTank >= 1)\\n                    {\\n                        mainTank++;\\n                        additionalTank--;\\n                    }\\n                }\\n                else{\\n                    range+=(10*mainTank);\\n                    mainTank=0;\\n                }\\n            }\\n        }\\n\\n        return range;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        \\n        int range = 0;\\n        if(mainTank < 5) return mainTank*10;\\n        else{\\n            while(mainTank > 0)\\n            {\\n                if(mainTank >= 5){\\n                    range+=50;\\n                    mainTank-=5;\\n                    if(additionalTank >= 1)\\n                    {\\n                        mainTank++;\\n                        additionalTank--;\\n                    }\\n                }\\n                else{\\n                    range+=(10*mainTank);\\n                    mainTank=0;\\n                }\\n            }\\n        }\\n\\n        return range;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650564,
                "title": "easy-java-solution-if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int m, int a) {\\n        int ans=0;\\n        if(m<5)\\n            ans= m*10;\\n        else{\\n            while(m>0){\\n                if(m>=5){\\n                m=(m-5);\\n                ans+=(5*10);\\n                    if(a>=1){\\n                        m+=1;\\n                        a-=1;\\n                    }\\n                }\\n                else{\\n                    ans+=m*10;\\n                    m=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int m, int a) {\\n        int ans=0;\\n        if(m<5)\\n            ans= m*10;\\n        else{\\n            while(m>0){\\n                if(m>=5){\\n                m=(m-5);\\n                ans+=(5*10);\\n                    if(a>=1){\\n                        m+=1;\\n                        a-=1;\\n                    }\\n                }\\n                else{\\n                    ans+=m*10;\\n                    m=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650498,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int main, int extra) {\\n        if(main<5){\\n            return main*10;\\n        }\\n        main-=5;\\n        int ans = 50;\\n        int bor = min(extra, 1);\\n        main+=bor, extra-=bor;\\n        ans+=distanceTraveled(main, extra);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int main, int extra) {\\n        if(main<5){\\n            return main*10;\\n        }\\n        main-=5;\\n        int ans = 50;\\n        int bor = min(extra, 1);\\n        main+=bor, extra-=bor;\\n        ans+=distanceTraveled(main, extra);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650493,
                "title": "very-easy-and-beginner-friendly-brute-force-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use the fuel one by one and increase the fuel by `1` if the used fuel is divisible by 5.\\nContraints are very low so apply brute force\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwhile `current_fuel` > 0\\n- Use the fuel one by one (`current_fuel --`);\\n- If the used fuel is divisible by 5 increase the `current_fuel`\\n- Everytime increase the distance by `10`\\n\\n# Complexity\\n- Time complexity: `O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans = 0, used = 0;\\n        while(mainTank > 0){\\n            used++;\\n            if(used%5 == 0 && additionalTank > 0){\\n                additionalTank--;\\n                mainTank++;\\n            }\\n            mainTank--;\\n            ans += 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans = 0, used = 0;\\n        while(mainTank > 0){\\n            used++;\\n            if(used%5 == 0 && additionalTank > 0){\\n                additionalTank--;\\n                mainTank++;\\n            }\\n            mainTank--;\\n            ans += 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975095,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int solve(int m,int a){\\n        if (m<5){\\n            //a=0;\\n            return m;\\n        }\\n        if (a==0){\\n            return m;\\n        }\\n        return 5+solve(m-4,a-1);\\n    }\\n    public int distanceTraveled(int m, int a) {\\n        return solve(m,a)*10;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int solve(int m,int a){\\n        if (m<5){\\n            //a=0;\\n            return m;\\n        }\\n        if (a==0){\\n            return m;\\n        }\\n        return 5+solve(m-4,a-1);\\n    }\\n    public int distanceTraveled(int m, int a) {\\n        return solve(m,a)*10;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849374,
                "title": "simple-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is really just a straight forward problem, just follow the prompt to calculate the distance\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every 5 liters we can think of it as for every 50 km. So we only need to check if the car has traveled for 50km and check for the additional tank, then we add to the main tank 1 liter\\n# Complexity\\n- Time complexity: O(maintank + additionalTank)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction distanceTraveled(mainTank: number, additionalTank: number): number {\\n    let distance : number = 0;\\n    do {\\n        distance+= 10;\\n        mainTank--;\\n        if (distance % 50 === 0 && additionalTank > 0) {\\n            additionalTank--;\\n            mainTank++;\\n        }\\n    } while(mainTank > 0);\\n    return distance;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction distanceTraveled(mainTank: number, additionalTank: number): number {\\n    let distance : number = 0;\\n    do {\\n        distance+= 10;\\n        mainTank--;\\n        if (distance % 50 === 0 && additionalTank > 0) {\\n            additionalTank--;\\n            mainTank++;\\n        }\\n    } while(mainTank > 0);\\n    return distance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784053,
                "title": "java-easy-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor every 5 litres of oil consumed from `mainTank`, 1 litre of oil is transfered from `additionalTank` to `mainTank`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncalculate how much oil is consumed from `mainTank` and then for every 5 litres of oil consumed, add 1 litre of oil from `additionalTank` to `mainTank`\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n      int dist = 0;\\n      while(mainTank > 0) {\\n          dist ++;\\n          mainTank --;\\n          if(dist != 0 && dist % 5 == 0 && additionalTank > 0) {\\n              additionalTank --;\\n              mainTank ++;\\n            }\\n      }  \\n      return dist * 10;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n      int dist = 0;\\n      while(mainTank > 0) {\\n          dist ++;\\n          mainTank --;\\n          if(dist != 0 && dist % 5 == 0 && additionalTank > 0) {\\n              additionalTank --;\\n              mainTank ++;\\n            }\\n      }  \\n      return dist * 10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738288,
                "title": "time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int sum = 0;\\n        \\n        if (mainTank < 5) {\\n            sum = 10 * mainTank;\\n        } else if (mainTank == 5) {\\n            sum = 60;\\n        } else {\\n           while(mainTank>0)\\n           {\\n               if(mainTank>5)\\n               {\\n                    sum=sum+50;\\n               }\\n               else {\\n                   sum=sum+mainTank*10;\\n               }\\n               mainTank=mainTank-5;\\n              \\n               if(additionalTank>=1)\\n               {\\n                   additionalTank=additionalTank-1;\\n                   mainTank+=1;\\n               }\\n           }\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int sum = 0;\\n        \\n        if (mainTank < 5) {\\n            sum = 10 * mainTank;\\n        } else if (mainTank == 5) {\\n            sum = 60;\\n        } else {\\n           while(mainTank>0)\\n           {\\n               if(mainTank>5)\\n               {\\n                    sum=sum+50;\\n               }\\n               else {\\n                   sum=sum+mainTank*10;\\n               }\\n               mainTank=mainTank-5;\\n              \\n               if(additionalTank>=1)\\n               {\\n                   additionalTank=additionalTank-1;\\n                   mainTank+=1;\\n               }\\n           }\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738287,
                "title": "time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int sum = 0;\\n        \\n        if (mainTank < 5) {\\n            sum = 10 * mainTank;\\n        } else if (mainTank == 5) {\\n            sum = 60;\\n        } else {\\n           while(mainTank>0)\\n           {\\n               if(mainTank>5)\\n               {\\n                    sum=sum+50;\\n               }\\n               else {\\n                   sum=sum+mainTank*10;\\n               }\\n               mainTank=mainTank-5;\\n              \\n               if(additionalTank>=1)\\n               {\\n                   additionalTank=additionalTank-1;\\n                   mainTank+=1;\\n               }\\n           }\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int sum = 0;\\n        \\n        if (mainTank < 5) {\\n            sum = 10 * mainTank;\\n        } else if (mainTank == 5) {\\n            sum = 60;\\n        } else {\\n           while(mainTank>0)\\n           {\\n               if(mainTank>5)\\n               {\\n                    sum=sum+50;\\n               }\\n               else {\\n                   sum=sum+mainTank*10;\\n               }\\n               mainTank=mainTank-5;\\n              \\n               if(additionalTank>=1)\\n               {\\n                   additionalTank=additionalTank-1;\\n                   mainTank+=1;\\n               }\\n           }\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733260,
                "title": "c-beginner-friendly-approach",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) \\n    {\\n        int petrol=0;\\n        while(mainTank>0)\\n        {\\n            if(mainTank/5)\\n            {\\n                if(additionalTank>0)\\n                {\\n                    mainTank++;\\n                    additionalTank--;\\n                }   \\n                petrol += 5;\\n                mainTank -= 5;\\n            }\\n            else\\n            {\\n                petrol += mainTank;\\n                break;\\n            }\\n        }\\n        return 10*petrol;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) \\n    {\\n        int petrol=0;\\n        while(mainTank>0)\\n        {\\n            if(mainTank/5)\\n            {\\n                if(additionalTank>0)\\n                {\\n                    mainTank++;\\n                    additionalTank--;\\n                }   \\n                petrol += 5;\\n                mainTank -= 5;\\n            }\\n            else\\n            {\\n                petrol += mainTank;\\n                break;\\n            }\\n        }\\n        return 10*petrol;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697969,
                "title": "easy-explanation-with-approach-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDid exactly what is stated in the question:\\n1. If mainTank is less than 5, then directly return mainTank*10\\n2. Else decrease mainTank by 5 and add 10 to the answer, if additionalTank is not empty, fill the mainTank by 1 and decrease the additional Tank by 1\\n3. Loop this till the mainTank becomes empty\\n\\n# Complexity\\n- Time complexity: O(N) where N is mainTank\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans = 0;\\n        while(mainTank){\\n            if(mainTank<5){\\n                ans=ans+mainTank*10;\\n                return ans;\\n            }\\n            \\n            mainTank = mainTank - 5;\\n            ans = ans + 5*10;\\n            if(additionalTank){\\n                mainTank = mainTank + 1;\\n                additionalTank--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans = 0;\\n        while(mainTank){\\n            if(mainTank<5){\\n                ans=ans+mainTank*10;\\n                return ans;\\n            }\\n            \\n            mainTank = mainTank - 5;\\n            ans = ans + 5*10;\\n            if(additionalTank){\\n                mainTank = mainTank + 1;\\n                additionalTank--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686777,
                "title": "o-1-1-line-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy Intution is to see a patter in main tank and fuel tank \\nIf you see clearly you can see \\nfor 5 litre in main tank you can at max use 1 litre in additional \\nfor 9 2\\nfor 13 3\\nfor 17 4\\nand each of them is 4*x +1\\nso if you dont have addition fuel there is no point of calc and answer should be clearly m*10\\nAnd other thing is At any case all the fuel from maintank is used so we just have to take care of additional fuel tank\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\napproach is for finding a formula according to relation above and that is\\ntotal fuel we can used from addition = (m-1)/4\\nand if we dont have that we can only use fuel we have\\n\\nso it will be mainfuel *10 + min of ((Mainfuel -1)/4 and additionfuel)*10;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int m, int add) {\\n        return 10*(m+min((m-1)/4,add));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int m, int add) {\\n        return 10*(m+min((m-1)/4,add));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669840,
                "title": "2739-total-distance-traveled-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n       int count = 0;\\n\\n       for(int i=1; i<=mainTank; i++){\\n           if(i%5==0 && additionalTank!=0){\\n               additionalTank--;\\n               count +=10;\\n               mainTank++;\\n               \\n           }\\n           else{\\n               count+=10;\\n           }\\n       } \\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n       int count = 0;\\n\\n       for(int i=1; i<=mainTank; i++){\\n           if(i%5==0 && additionalTank!=0){\\n               additionalTank--;\\n               count +=10;\\n               mainTank++;\\n               \\n           }\\n           else{\\n               count+=10;\\n           }\\n       } \\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663780,
                "title": "iterative-approarch-math",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int DistanceTraveled(int mainTank, int additionalTank) {\\n        int currTank = mainTank;\\n        int totalFuelBurnt = 0;\\n\\n        while(currTank >= 5 && additionalTank > 0){\\n            currTank -= 4;\\n            --additionalTank;\\n            totalFuelBurnt += 5;\\n        }\\n\\n        totalFuelBurnt += currTank;\\n        return totalFuelBurnt * 10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int DistanceTraveled(int mainTank, int additionalTank) {\\n        int currTank = mainTank;\\n        int totalFuelBurnt = 0;\\n\\n        while(currTank >= 5 && additionalTank > 0){\\n            currTank -= 4;\\n            --additionalTank;\\n            totalFuelBurnt += 5;\\n        }\\n\\n        totalFuelBurnt += currTank;\\n        return totalFuelBurnt * 10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661907,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int DistanceTraveled(int mainTank, int additionalTank) {\\n        int dis = 0;\\n\\n        while(mainTank >= 5){\\n            dis += 5*10;\\n            mainTank -= 5;\\n            mainTank += additionalTank >= 1 ? 1 : 0;\\n            additionalTank--;\\n        }\\n\\n        dis += mainTank*10;\\n\\n        return dis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int DistanceTraveled(int mainTank, int additionalTank) {\\n        int dis = 0;\\n\\n        while(mainTank >= 5){\\n            dis += 5*10;\\n            mainTank -= 5;\\n            mainTank += additionalTank >= 1 ? 1 : 0;\\n            additionalTank--;\\n        }\\n\\n        dis += mainTank*10;\\n\\n        return dis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655099,
                "title": "python-very-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        tot=0\\n        while(1):\\n            if(mainTank>=5):\\n                tot+=5*10\\n                mainTank-=5\\n                if additionalTank>=1:\\n                    mainTank+=1\\n                    additionalTank-=1\\n            else:\\n                break\\n        tot+=mainTank*10\\n        return tot\\n        \\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        tot=0\\n        while(1):\\n            if(mainTank>=5):\\n                tot+=5*10\\n                mainTank-=5\\n                if additionalTank>=1:\\n                    mainTank+=1\\n                    additionalTank-=1\\n            else:\\n                break\\n        tot+=mainTank*10\\n        return tot\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654921,
                "title": "c-easy-solution-beginner-s-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int res = 0;\\n        \\n        while(mainTank>=5 && additionalTank>=1){\\n            res += (5*10);\\n            mainTank -= 5;\\n            mainTank++;\\n            additionalTank--;\\n        }\\n\\n        res += (mainTank*10);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int res = 0;\\n        \\n        while(mainTank>=5 && additionalTank>=1){\\n            res += (5*10);\\n            mainTank -= 5;\\n            mainTank++;\\n            additionalTank--;\\n        }\\n\\n        res += (mainTank*10);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654891,
                "title": "python-easiest-understandable-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def distanceTraveled(self, mainTank, additionalTank):\\n        \"\"\"\\n        :type mainTank: int\\n        :type additionalTank: int\\n        :rtype: int\\n        \"\"\"\\n        mil=0\\n        while mainTank!=0:\\n            if additionalTank==0 and mainTank==0:\\n                return mil\\n            if mainTank>=5 and additionalTank>=1:\\n                mainTank-=5-1\\n                additionalTank-=1\\n                mil+=5*10\\n            else:\\n                mil+=mainTank*10\\n                mainTank=0\\n                \\n        return mil\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def distanceTraveled(self, mainTank, additionalTank):\\n        \"\"\"\\n        :type mainTank: int\\n        :type additionalTank: int\\n        :rtype: int\\n        \"\"\"\\n        mil=0\\n        while mainTank!=0:\\n            if additionalTank==0 and mainTank==0:\\n                return mil\\n            if mainTank>=5 and additionalTank>=1:\\n                mainTank-=5-1\\n                additionalTank-=1\\n                mil+=5*10\\n            else:\\n                mil+=mainTank*10\\n                mainTank=0\\n                \\n        return mil\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654376,
                "title": "distance-traveled-beats-100-beginners-friendly",
                "content": "# KARRAR\\n>Contest\\n>>Total distance traveled...\\n>>>Most optimized code...\\n>>>>Generalized with least complexity...\\n>>>>>Only single loop used...\\n>>>>>>Beginners freindly...\\n-     PLEASE UPVOTE...\\uD83D\\uDC4D\\uD83C\\uDFFB\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n            Minimize the names to make the code easy...\\n            Simply calculate the tanks petrol...\\n            Multiply the answer by 10 and return it...\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity:\\n- Time complexity: Beats 100% (88 ms)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Beats 28% (16 MB)\\n\\n![Screenshot from 2023-06-19 06-57-47.png](https://assets.leetcode.com/users/images/ef534aab-7b95-49d9-8c12-d61910d4a01f_1687139892.7142644.png)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        ans=0\\n        mt=mainTank\\n        at=additionalTank\\n        \\n        while(mt>4 and at>0):\\n            mt=mt-5\\n            at=at-1\\n            mt=mt+1\\n            ans=ans+5*10\\n        ans+=mt*10\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        ans=0\\n        mt=mainTank\\n        at=additionalTank\\n        \\n        while(mt>4 and at>0):\\n            mt=mt-5\\n            at=at-1\\n            mt=mt+1\\n            ans=ans+5*10\\n        ans+=mt*10\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653369,
                "title": "python-python3-easy-solution",
                "content": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        if mainTank < 5:\\n            return mainTank*10\\n        \\n        dist = 0\\n        used = 0\\n        while mainTank:\\n            used += 1\\n            if used % 5 == 0 and additionalTank:\\n                mainTank += 1\\n                additionalTank -= 1\\n            mainTank -= 1    \\n            dist += 10\\n        return dist\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        if mainTank < 5:\\n            return mainTank*10\\n        \\n        dist = 0\\n        used = 0\\n        while mainTank:\\n            used += 1\\n            if used % 5 == 0 and additionalTank:\\n                mainTank += 1\\n                additionalTank -= 1\\n            mainTank -= 1    \\n            dist += 10\\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653016,
                "title": "simple-approach-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        count = 0\\n        while(mainTank>=5 and additionalTank>0 ):\\n            mainTank = (mainTank-5)\\n            additionalTank-=1\\n            count+=5\\n            mainTank+=1\\n        return(count+mainTank)*10\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        count = 0\\n        while(mainTank>=5 and additionalTank>0 ):\\n            mainTank = (mainTank-5)\\n            additionalTank-=1\\n            count+=5\\n            mainTank+=1\\n        return(count+mainTank)*10\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652635,
                "title": "one-line-sol-java-c-python-bruteforce-o-1-both-solved",
                "content": "Java O(1) solution  one linear\\n// TC-> O(1)\\n// SC-> O(1)\\n```\\nclass Solution {\\n     public static int distanceTraveled(int m, int a) {\\n          return (m+Math.min((m-1)/4,a))*10;\\n}\\n}\\n```\\n\\nJava Solution Brute force \\n```\\nclass Solution {\\n     public static int distanceTraveled(int m, int a) {\\n        int d=0,tf=0;\\n\\n        while(m>=5){\\n            tf+=5;\\n            m=m-5;\\n            if(a>0){\\n                m++;\\n                a--;\\n            }\\n        }\\n        tf+=m;\\n        return tf*10;\\n    }\\n}\\n```\\n\\n \\n\\n\\nC++ Solution \\n\\n//TC-> O(1)\\n// SC-> O(1)\\n```\\nclass Solution {\\npublic:\\n     int distanceTraveled(int mainTank, int additionalTank) {\\n        return (mainTank+min((mainTank-1)/4,additionalTank))*10;\\n    }\\n};\\n```\\n\\nPython 3\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        return (mainTank+min((mainTank-1)//4,additionalTank))*10;\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n     public static int distanceTraveled(int m, int a) {\\n          return (m+Math.min((m-1)/4,a))*10;\\n}\\n}\\n```\n```\\nclass Solution {\\n     public static int distanceTraveled(int m, int a) {\\n        int d=0,tf=0;\\n\\n        while(m>=5){\\n            tf+=5;\\n            m=m-5;\\n            if(a>0){\\n                m++;\\n                a--;\\n            }\\n        }\\n        tf+=m;\\n        return tf*10;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n     int distanceTraveled(int mainTank, int additionalTank) {\\n        return (mainTank+min((mainTank-1)/4,additionalTank))*10;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        return (mainTank+min((mainTank-1)//4,additionalTank))*10;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651482,
                "title": "easy-to-understand-c-solution-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans = 0;\\n        while(mainTank > 0){\\n            if(mainTank >= 5){\\n                ans += 50;\\n                mainTank -= 5;\\n                if(additionalTank > 0){\\n                    mainTank++;\\n                    additionalTank--;\\n                }\\n                continue;\\n            }\\n            ans += mainTank*10;\\n            mainTank = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans = 0;\\n        while(mainTank > 0){\\n            if(mainTank >= 5){\\n                ans += 50;\\n                mainTank -= 5;\\n                if(additionalTank > 0){\\n                    mainTank++;\\n                    additionalTank--;\\n                }\\n                continue;\\n            }\\n            ans += mainTank*10;\\n            mainTank = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651318,
                "title": "c-java-javascript-solution-100-fast-well-explained",
                "content": "# Intuition\\n- If the main tank has less than 5 liters of fuel, the remaining fuel determines the maximum distance that can be traveled. Calculate the distance based on the remaining fuel and return it.\\n- Simulate the process of fuel consumption and transfer between the main tank and additional tank.\\n- In each iteration, if the main tank has at least 5 liters of fuel:\\n    - Add 50 to the distance traveled (10 km per liter for 5 liters).\\n    - Subtract 5 from the main tank fuel.\\n    - If there is fuel in the additional tank, transfer 1 liter to the main tank.\\n- When the main tank has less than 5 liters of fuel, calculate the distance based on the remaining fuel and add it to the total distance traveled.\\n- Return the total distance traveled.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- If the main tank has less than 5 liters of fuel, calculate and return the distance that can be traveled with the remaining fuel.\\n- Simulate the process of fuel consumption and transfer between the main tank and additional tank.\\n- Add 50 to the distance traveled for every 5 liters of fuel in the main tank.\\n- If there is fuel in the additional tank, transfer 1 liter to the main tank for every 5 liters consumed.\\n- Calculate and add the distance that can be traveled with the remaining fuel in the main tank if it\\'s less than 5 liters.\\n- Return the total distance traveled.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n**- Time complexity:**\\nThe time complexity of this code is O(max(mainTank, additionalTank)). In the worst case, both tanks need to be fully consumed before the loop breaks.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n**- Space complexity:**\\nThe space complexity is O(1) as it uses only a constant amount of extra space for variables.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0;\\n        if(mainTank<5){\\n            int res=mainTank%5;\\n            return (res*10);\\n        }\\n        while (mainTank > 0 || additionalTank > 0) {\\n            if (mainTank >= 5) {\\n                distance += 50;\\n                mainTank -= 5;\\n                if(additionalTank>0){\\n                    mainTank += 1;\\n                    additionalTank -= 1;\\n                }\\n            } \\n            else{\\n                int res=mainTank%5;\\n                distance=distance+(res*10);\\n                break;\\n            }\\n        }\\n        return distance;\\n    }\\n};\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0;\\n\\n        if (mainTank < 5) {\\n            int remainingFuel = mainTank % 5;\\n            return (remainingFuel * 10);\\n        }\\n\\n        while (mainTank > 0 || additionalTank > 0) {\\n            if (mainTank >= 5) {\\n                distance += 50;\\n                mainTank -= 5;\\n\\n                if (additionalTank > 0) {\\n                    mainTank += 1;\\n                    additionalTank -= 1;\\n                }\\n            } else {\\n                int remainingFuel = mainTank % 5;\\n                distance += (remainingFuel * 10);\\n                break;\\n            }\\n        }\\n\\n        return distance;\\n    }\\n}\\n\\n```\\n# JavaScript\\n```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    let distance = 0;\\n\\n    if (mainTank < 5) {\\n        let remainingFuel = mainTank % 5;\\n        return remainingFuel * 10;\\n    }\\n\\n    while (mainTank > 0 || additionalTank > 0) {\\n        if (mainTank >= 5) {\\n            distance += 50;\\n            mainTank -= 5;\\n\\n            if (additionalTank > 0) {\\n                mainTank += 1;\\n                additionalTank -= 1;\\n            }\\n        } else {\\n            let remainingFuel = mainTank % 5;\\n            distance += remainingFuel * 10;\\n            break;\\n        }\\n    }\\n\\n    return distance;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0;\\n        if(mainTank<5){\\n            int res=mainTank%5;\\n            return (res*10);\\n        }\\n        while (mainTank > 0 || additionalTank > 0) {\\n            if (mainTank >= 5) {\\n                distance += 50;\\n                mainTank -= 5;\\n                if(additionalTank>0){\\n                    mainTank += 1;\\n                    additionalTank -= 1;\\n                }\\n            } \\n            else{\\n                int res=mainTank%5;\\n                distance=distance+(res*10);\\n                break;\\n            }\\n        }\\n        return distance;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0;\\n\\n        if (mainTank < 5) {\\n            int remainingFuel = mainTank % 5;\\n            return (remainingFuel * 10);\\n        }\\n\\n        while (mainTank > 0 || additionalTank > 0) {\\n            if (mainTank >= 5) {\\n                distance += 50;\\n                mainTank -= 5;\\n\\n                if (additionalTank > 0) {\\n                    mainTank += 1;\\n                    additionalTank -= 1;\\n                }\\n            } else {\\n                int remainingFuel = mainTank % 5;\\n                distance += (remainingFuel * 10);\\n                break;\\n            }\\n        }\\n\\n        return distance;\\n    }\\n}\\n\\n```\n```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    let distance = 0;\\n\\n    if (mainTank < 5) {\\n        let remainingFuel = mainTank % 5;\\n        return remainingFuel * 10;\\n    }\\n\\n    while (mainTank > 0 || additionalTank > 0) {\\n        if (mainTank >= 5) {\\n            distance += 50;\\n            mainTank -= 5;\\n\\n            if (additionalTank > 0) {\\n                mainTank += 1;\\n                additionalTank -= 1;\\n            }\\n        } else {\\n            let remainingFuel = mainTank % 5;\\n            distance += remainingFuel * 10;\\n            break;\\n        }\\n    }\\n\\n    return distance;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651115,
                "title": "c-java-python-easy-solution-with-perfect-explanation",
                "content": "# Intuition\\nBrute-force\\n\\n# Approach\\n\\n1.  x here represents the total possible km factors. For example, if the maintank is 26, then x will be 5, which means we will require additionalTank 5 times.\\n2. y represents the remaining fuel after dividing 5 times. This means we will later add y to additionalTank.\\n3. If additionalTank is more than x, it means there is extra fuel in additionalTank, so we will only use x from additionalTank.\\n4. Else if additionalTank is less than x, we will use all of the additionalTank.\\n5. Otherwise, we will update mainTank by y, which is the remaining fuel in the main tank. (Use this test case to understand: maintank=19 and additionaltank=1)\\n6. Then, we will subtract additionalTank by x.\\n7. After that, we will calculate the sum by adding x * 5 * 10.\\n8. If any fuel remains, we will return it by using the fuel from the maintank as well.\\n\\n# Code (C++)\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int sum=0,x=0,y=0;\\n        while(mainTank>=5)\\n        { \\n            x=mainTank/5;  \\n            y=mainTank%5;  \\n            if(additionalTank>=x)\\n            mainTank=y+x;\\n            else if(additionalTank>=0)\\n                mainTank=y+additionalTank;\\n            else \\n                mainTank=y;  \\n            additionalTank=additionalTank-x;\\n            sum=sum+x*5*10;\\n        }\\n        return sum+mainTank*10;\\n    }\\n};\\n```\\n# Code (java)\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int sum = 0, x = 0, y = 0;\\n        while (mainTank >= 5) {\\n            x = mainTank / 5;\\n            y = mainTank % 5;\\n            if (additionalTank >= x)\\n                mainTank = y + x;\\n            else if (additionalTank >= 0)\\n                mainTank = y + additionalTank;\\n            else\\n                mainTank = y;\\n            additionalTank = additionalTank - x;\\n            sum = sum + x * 5 * 10;\\n        }\\n        return sum + mainTank * 10;\\n    }\\n}\\n```\\n# Code (python)\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank, additionalTank):\\n        sum = 0\\n        x = 0\\n        y = 0\\n        while mainTank >= 5:\\n            x = mainTank // 5\\n            y = mainTank % 5\\n            if additionalTank >= x:\\n                mainTank = y + x\\n            elif additionalTank >= 0:\\n                mainTank = y + additionalTank\\n            else:\\n                mainTank = y\\n            additionalTank = additionalTank - x\\n            sum = sum + x * 5 * 10\\n        return sum + mainTank * 10\\n\\n```\\n\\n\\n\\n// please upvote the solution if you like and helpful for you.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int sum=0,x=0,y=0;\\n        while(mainTank>=5)\\n        { \\n            x=mainTank/5;  \\n            y=mainTank%5;  \\n            if(additionalTank>=x)\\n            mainTank=y+x;\\n            else if(additionalTank>=0)\\n                mainTank=y+additionalTank;\\n            else \\n                mainTank=y;  \\n            additionalTank=additionalTank-x;\\n            sum=sum+x*5*10;\\n        }\\n        return sum+mainTank*10;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int sum = 0, x = 0, y = 0;\\n        while (mainTank >= 5) {\\n            x = mainTank / 5;\\n            y = mainTank % 5;\\n            if (additionalTank >= x)\\n                mainTank = y + x;\\n            else if (additionalTank >= 0)\\n                mainTank = y + additionalTank;\\n            else\\n                mainTank = y;\\n            additionalTank = additionalTank - x;\\n            sum = sum + x * 5 * 10;\\n        }\\n        return sum + mainTank * 10;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank, additionalTank):\\n        sum = 0\\n        x = 0\\n        y = 0\\n        while mainTank >= 5:\\n            x = mainTank // 5\\n            y = mainTank % 5\\n            if additionalTank >= x:\\n                mainTank = y + x\\n            elif additionalTank >= 0:\\n                mainTank = y + additionalTank\\n            else:\\n                mainTank = y\\n            additionalTank = additionalTank - x\\n            sum = sum + x * 5 * 10\\n        return sum + mainTank * 10\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651043,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int dist =0;\\n        \\n        while(mainTank>=5){\\n            mainTank-=5;\\n            dist = dist+5*10;\\n            if(additionalTank>=1){\\n                mainTank++;\\n                additionalTank--;\\n            }\\n        }\\n        dist = dist + mainTank*10;\\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int dist =0;\\n        \\n        while(mainTank>=5){\\n            mainTank-=5;\\n            dist = dist+5*10;\\n            if(additionalTank>=1){\\n                mainTank++;\\n                additionalTank--;\\n            }\\n        }\\n        dist = dist + mainTank*10;\\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650811,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        return (mainTank+min((mainTank-1)//4,additionalTank))*10\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        return (mainTank+min((mainTank-1)//4,additionalTank))*10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650803,
                "title": "very-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans=0;\\n        while(mainTank>=5){\\n            if(additionalTank>0){\\n                mainTank++;\\n                additionalTank--;\\n            }\\n            ans+=50;\\n            mainTank-=5;\\n        }\\n        int t=10;\\n        ans+=(mainTank*t);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans=0;\\n        while(mainTank>=5){\\n            if(additionalTank>0){\\n                mainTank++;\\n                additionalTank--;\\n            }\\n            ans+=50;\\n            mainTank-=5;\\n        }\\n        int t=10;\\n        ans+=(mainTank*t);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650702,
                "title": "very-simple-c-solution-begineer-friendly-solution",
                "content": "\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int cnt=0;\\n        \\n        int n=mainTank;\\n        \\n        while(n>=5 && additionalTank>0){\\n            n=(n-5)+1;\\n            additionalTank-=1;\\n            cnt++;  \\n        }\\n     \\n        return (mainTank+cnt)*10; \\n        \\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int cnt=0;\\n        \\n        int n=mainTank;\\n        \\n        while(n>=5 && additionalTank>0){\\n            n=(n-5)+1;\\n            additionalTank-=1;\\n            cnt++;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3650630,
                "title": "brute-force-for-beginners",
                "content": "Initialize a variable res to keep track of the total distance traveled.\\n\\nEnter a while loop that continues as long as there is enough fuel in the mainTank to cover a distance of 5 units.\\n\\nInside the loop, increment res by 5 multiplied by 10 (assuming a distance of 10 units is covered per unit of fuel).\\n\\nSubtract 5 from mainTank since 5 units of fuel were consumed.\\nCheck if there is any fuel available in the additionalTank.\\n\\nIf there is fuel in the additionalTank, increment mainTank by 1 (since 1 unit of fuel is transferred from additionalTank to mainTank) and decrement additionalTank by 1.\\n\\nRepeat steps 3-6 until there is not enough fuel in the mainTank to cover a distance of 5 units.\\n\\nAdd the remaining fuel in mainTank to res multiplied by 10 (assuming a distance of 10 units is covered per unit of fuel).\\n\\nReturn the final value of res, representing the total distance traveled.\\n\\nIt\\'s important to note that the code assumes a fixed conversion rate of 10 units of distance per unit of fuel. Additionally, the code does not handle any errors or validate the input values.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n       int res=0;\\n        while(mainTank>=5){\\n            res+=5*10;\\n            mainTank-=5;\\n            if(additionalTank>0) {\\n                mainTank+=1;\\n                additionalTank--;\\n            }\\n        }\\n       res+=(mainTank*10);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n       int res=0;\\n        while(mainTank>=5){\\n            res+=5*10;\\n            mainTank-=5;\\n            if(additionalTank>0) {\\n                mainTank+=1;\\n                additionalTank--;\\n            }\\n        }\\n       res+=(mainTank*10);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650609,
                "title": "c-easy-and-crisp-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mt, int at) {\\n        int ans=0;\\n        int flag=0;\\n        if(mt<5) return mt*10;\\n        while(mt>=5){\\n                ans+=5*10;\\n                mt-=5;\\n                if(at>0){\\n                    mt+=1;\\n                    at-=1;\\n                }\\n            else continue;\\n        }\\n        ans+=mt*10;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mt, int at) {\\n        int ans=0;\\n        int flag=0;\\n        if(mt<5) return mt*10;\\n        while(mt>=5){\\n                ans+=5*10;\\n                mt-=5;\\n                if(at>0){\\n                    mt+=1;\\n                    at-=1;\\n                }\\n            else continue;\\n        }\\n        ans+=mt*10;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096988,
                "title": "beginner-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint distanceTraveled(int mainTank, int additionalTank){\\n\\tbool run;\\n\\tint b;\\n\\tint a;\\n\\n\\trun = true;\\n\\ta = 0;\\n\\tb = 0;\\n\\twhile (run == true)\\n\\t{\\n\\t\\tif (b % 5 == 0 && additionalTank > 0)\\n\\t\\t{\\n\\t\\t\\tif (b != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmainTank += 1;\\n\\t\\t\\t\\tadditionalTank -= 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (mainTank > 0)\\n\\t\\t{\\n\\t\\t\\ta += 10;\\n\\t\\t\\tb +=1;\\n\\t\\t\\tmainTank -= 1;\\n\\t\\t}\\n\\t\\telse if (mainTank == 0)\\n\\t\\t{\\n\\t\\t\\trun = false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn (a);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint distanceTraveled(int mainTank, int additionalTank){\\n\\tbool run;\\n\\tint b;\\n\\tint a;\\n\\n\\trun = true;\\n\\ta = 0;\\n\\tb = 0;\\n\\twhile (run == true)\\n\\t{\\n\\t\\tif (b % 5 == 0 && additionalTank > 0)\\n\\t\\t{\\n\\t\\t\\tif (b != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmainTank += 1;\\n\\t\\t\\t\\tadditionalTank -= 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (mainTank > 0)\\n\\t\\t{\\n\\t\\t\\ta += 10;\\n\\t\\t\\tb +=1;\\n\\t\\t\\tmainTank -= 1;\\n\\t\\t}\\n\\t\\telse if (mainTank == 0)\\n\\t\\t{\\n\\t\\t\\trun = false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn (a);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058224,
                "title": "o-1-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst distanceTraveled = (mainTank: number, additionalTank: number) => {\\n  if (mainTank < 5 || additionalTank < 1) return mainTank * 10;\\n  return (\\n    (1 +\\n      mainTank +\\n      Math.min(additionalTank - 1, Math.floor((mainTank - 5) / 4))) *\\n    10\\n  );\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst distanceTraveled = (mainTank: number, additionalTank: number) => {\\n  if (mainTank < 5 || additionalTank < 1) return mainTank * 10;\\n  return (\\n    (1 +\\n      mainTank +\\n      Math.min(additionalTank - 1, Math.floor((mainTank - 5) / 4))) *\\n    10\\n  );\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057353,
                "title": "java-simple-for-while-loop-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int t=0;\\n        int c=0;\\n        while(mainTank >0){\\n          mainTank--;\\n          c++;\\n          if(additionalTank > 0 && c == 5){\\n            mainTank++;\\n            additionalTank--;\\n            c=0;\\n          }\\n          t+=10;\\n        }\\n        t+=mainTank*10;\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int t=0;\\n        int c=0;\\n        while(mainTank >0){\\n          mainTank--;\\n          c++;\\n          if(additionalTank > 0 && c == 5){\\n            mainTank++;\\n            additionalTank--;\\n            c=0;\\n          }\\n          t+=10;\\n        }\\n        t+=mainTank*10;\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056870,
                "title": "100-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int result=0; \\n        while(mainTank > 0){\\n            if(mainTank < 5){\\n                result += mainTank*10;\\n                break;\\n            }else{\\n                mainTank = mainTank -5;\\n                result += 50;\\n                if(additionalTank>0){\\n                    additionalTank--;\\n                    mainTank++;\\n                }\\n            }\\n        }\\n        \\n    return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int result=0; \\n        while(mainTank > 0){\\n            if(mainTank < 5){\\n                result += mainTank*10;\\n                break;\\n            }else{\\n                mainTank = mainTank -5;\\n                result += 50;\\n                if(additionalTank>0){\\n                    additionalTank--;\\n                    mainTank++;\\n                }\\n            }\\n        }\\n        \\n    return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053140,
                "title": "brute-force-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf initially the mainTank fuel is less than 5, it means that extra fuel injection from the additional tank will not take place. So, we need to return mainTank*10(as the mileage is 10kms per litre).\\n\\nIf the mainTank fuel>=5, we will run a while loop where we check if mainTank fuel>=5 and additionalTank fuel>=1(as it is mentioned in the question that , the fuel injection of extra 1litre will only take place if the additionalTank has atleast 1litre fuel in it), and consequently change the mainTank value(mainTank-5+1) and additionalTank(decrementing the value), and adding 50kms to the variable ans, and at last we add mainTank*10 to the ans(if some remaining fuel is left after consumption).\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank<5){\\n            return mainTank*10;\\n        }\\n        int ans=0;\\n        while(mainTank>=5 && additionalTank>=1){\\n             ans+=50;\\n             mainTank=mainTank-4;\\n             additionalTank--;\\n        }\\n        ans+=mainTank*10;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank<5){\\n            return mainTank*10;\\n        }\\n        int ans=0;\\n        while(mainTank>=5 && additionalTank>=1){\\n             ans+=50;\\n             mainTank=mainTank-4;\\n             additionalTank--;\\n        }\\n        ans+=mainTank*10;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051067,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int add) {\\n        //take result and fuel if the fuel is reach to 5 unit we check additional tank has fuel remaining or not if it\\'s reamining then we add 1 litre to mainTank\\n           int fuel=0;\\n           int res=0;\\n           //check unitl additonal tank is not empty and main tank is not empty\\n           while(mainTank>0 and add>0 )\\n             {\\n               fuel++;\\n               res=res+10;\\n               mainTank--;\\n               //fuel react to 5 so we reset the fuel check additionalfuel and increase fuel in maintank if present\\n                if(fuel==5)\\n                   {\\n                     fuel=0;\\n                   if(add>0)\\n                   mainTank++,add--;\\n                  }\\n             }\\n             //add all the reamining amount of fuel into result because no additonal fuel is present\\n             res=res+mainTank*10;\\n             return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int add) {\\n        //take result and fuel if the fuel is reach to 5 unit we check additional tank has fuel remaining or not if it\\'s reamining then we add 1 litre to mainTank\\n           int fuel=0;\\n           int res=0;\\n           //check unitl additonal tank is not empty and main tank is not empty\\n           while(mainTank>0 and add>0 )\\n             {\\n               fuel++;\\n               res=res+10;\\n               mainTank--;\\n               //fuel react to 5 so we reset the fuel check additionalfuel and increase fuel in maintank if present\\n                if(fuel==5)\\n                   {\\n                     fuel=0;\\n                   if(add>0)\\n                   mainTank++,add--;\\n                  }\\n             }\\n             //add all the reamining amount of fuel into result because no additonal fuel is present\\n             res=res+mainTank*10;\\n             return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049165,
                "title": "c-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        \\n        int dist =0;\\n        if(mainTank < 5) return mainTank*10;\\n        while(mainTank >= 5)\\n        {\\n            dist += 5*10;\\n            mainTank -=5;\\n            if(additionalTank >0) \\n            {\\n                mainTank +=1;\\n                additionalTank -=1;\\n            }\\n        }\\n        dist += mainTank *10;\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        \\n        int dist =0;\\n        if(mainTank < 5) return mainTank*10;\\n        while(mainTank >= 5)\\n        {\\n            dist += 5*10;\\n            mainTank -=5;\\n            if(additionalTank >0) \\n            {\\n                mainTank +=1;\\n                additionalTank -=1;\\n            }\\n        }\\n        dist += mainTank *10;\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035638,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int d=0;\\n        for(int i=1;i<=mainTank;i++){\\n            if(i%5==0 && additionalTank!=0){\\n                 additionalTank--;\\n                 d+=10;\\n                 mainTank++;\\n\\n            }\\n            else{\\n                d+=10;\\n            }\\n        }\\n        return d;\\n    }\\n}\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int d=0;\\n        for(int i=1;i<=mainTank;i++){\\n            if(i%5==0 && additionalTank!=0){\\n                 additionalTank--;\\n                 d+=10;\\n                 mainTank++;\\n\\n            }\\n            else{\\n                d+=10;\\n            }\\n        }\\n        return d;\\n    }\\n}\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031524,
                "title": "100-runtime-beats-easy-approach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        \\n\\n        int c=0;\\n        while(mainTank>=5 && additionalTank>=1){\\n           \\n           c+=5;\\n           mainTank-=4;\\n           additionalTank--;\\n        }\\n\\n        if(mainTank>0){\\n            c+=mainTank;\\n        }\\n        return c*10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        \\n\\n        int c=0;\\n        while(mainTank>=5 && additionalTank>=1){\\n           \\n           c+=5;\\n           mainTank-=4;\\n           additionalTank--;\\n        }\\n\\n        if(mainTank>0){\\n            c+=mainTank;\\n        }\\n        return c*10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031125,
                "title": "php-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $mainTank\\n     * @param Integer $additionalTank\\n     * @return Integer\\n     */\\n    function distanceTraveled($mainTank, $additionalTank) {\\n        if ($mainTank < 5) {\\n            return $mainTank * 10;\\n        }\\n\\n        $distance = 0;\\n        $consumption = 0;\\n\\n        while($mainTank > 0) {\\n            $distance += 10;\\n\\n            $consumption++;\\n            $mainTank--;\\n\\n            if ($consumption === 5) {\\n                $consumption = 0;\\n\\n                if ($additionalTank > 0) {\\n                    $mainTank++;\\n                    $additionalTank--;\\n                }\\n            }\\n        }\\n\\n        return $distance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $mainTank\\n     * @param Integer $additionalTank\\n     * @return Integer\\n     */\\n    function distanceTraveled($mainTank, $additionalTank) {\\n        if ($mainTank < 5) {\\n            return $mainTank * 10;\\n        }\\n\\n        $distance = 0;\\n        $consumption = 0;\\n\\n        while($mainTank > 0) {\\n            $distance += 10;\\n\\n            $consumption++;\\n            $mainTank--;\\n\\n            if ($consumption === 5) {\\n                $consumption = 0;\\n\\n                if ($additionalTank > 0) {\\n                    $mainTank++;\\n                    $additionalTank--;\\n                }\\n            }\\n        }\\n\\n        return $distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016887,
                "title": "maximum-truck-ride",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int mileage=10,distance=0,count=0;\\n       if(mainTank>=5){\\n           while(mainTank>=5){\\n                count++;\\n                mainTank=mainTank-5;\\n                if(additionalTank>0){\\n                     additionalTank-=1;\\n                     mainTank+=1;\\n                }\\n               \\n           }\\n          distance= mainTank*mileage;\\n           distance+=(count*5)*mileage;\\n         \\n       }else{\\n          distance= mainTank*mileage;\\n       }\\n       return distance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int mileage=10,distance=0,count=0;\\n       if(mainTank>=5){\\n           while(mainTank>=5){\\n                count++;\\n                mainTank=mainTank-5;\\n                if(additionalTank>0){\\n                     additionalTank-=1;\\n                     mainTank+=1;\\n                }\\n               \\n           }\\n          distance= mainTank*mileage;\\n           distance+=(count*5)*mileage;\\n         \\n       }else{\\n          distance= mainTank*mileage;\\n       }\\n       return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011103,
                "title": "java-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n\\n        int ans = 0;\\n\\n        while(mainTank >= 5){\\n            mainTank -= 5;\\n\\n            ans += 50;\\n\\n            if(additionalTank > 0){\\n                mainTank++;\\n                additionalTank--;\\n            }\\n        }\\n\\n        ans += mainTank * 10;\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n\\n        int ans = 0;\\n\\n        while(mainTank >= 5){\\n            mainTank -= 5;\\n\\n            ans += 50;\\n\\n            if(additionalTank > 0){\\n                mainTank++;\\n                additionalTank--;\\n            }\\n        }\\n\\n        ans += mainTank * 10;\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999189,
                "title": "runtime-100-memory-83-20-easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0;\\n        int addFuel = 0;\\n        while(mainTank>0){\\n            while(mainTank >=5){\\n                distance += (mainTank-mainTank%5)*10;\\n                addFuel = mainTank/5;\\n                mainTank = mainTank%5;\\n                if(addFuel > additionalTank){\\n                    return distance+((mainTank+additionalTank)*10);\\n                }\\n                mainTank += addFuel;\\n                additionalTank -= addFuel;\\n                addFuel = 0;\\n            }\\n            distance += mainTank*10;\\n            mainTank = 0;\\n        }\\n        return distance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0;\\n        int addFuel = 0;\\n        while(mainTank>0){\\n            while(mainTank >=5){\\n                distance += (mainTank-mainTank%5)*10;\\n                addFuel = mainTank/5;\\n                mainTank = mainTank%5;\\n                if(addFuel > additionalTank){\\n                    return distance+((mainTank+additionalTank)*10);\\n                }\\n                mainTank += addFuel;\\n                additionalTank -= addFuel;\\n                addFuel = 0;\\n            }\\n            distance += mainTank*10;\\n            mainTank = 0;\\n        }\\n        return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993413,
                "title": "basic-o-1-solution-beginner-s-friendly",
                "content": "# Intuition\\nBasic approach via if-else statements\\n\\n# Approach\\nuse while loop for the repeated filling of the maintank \\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int fuel=0, count=0;\\n        while(mainTank >0 && additionalTank >0){ // check until one of them is 0\\n            fuel+=1; // for distance calculation\\n            mainTank-=1;maintank is depleting until it get five\\n            count++;\\n            if(count==5){ // when maintank get depleted 5liters\\n                count=0;\\n                additionalTank-=1; //we take 1L from additional\\n                mainTank+=1;//add 1L to maintank\\n            }\\n        }\\n    fuel+=mainTank;\\n    return fuel*10;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int fuel=0, count=0;\\n        while(mainTank >0 && additionalTank >0){ // check until one of them is 0\\n            fuel+=1; // for distance calculation\\n            mainTank-=1;maintank is depleting until it get five\\n            count++;\\n            if(count==5){ // when maintank get depleted 5liters\\n                count=0;\\n                additionalTank-=1; //we take 1L from additional\\n                mainTank+=1;//add 1L to maintank\\n            }\\n        }\\n    fuel+=mainTank;\\n    return fuel*10;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991111,
                "title": "step-by-step-explanation-and-o-1-time-complexity-solution-using-c-beginner-friendly-3",
                "content": "# Intuition\\nThe code calculates the total distance a vehicle can travel, considering fuel consumption, by combining the fuel in the main tank with the fuel in an additional tank if needed.\\n\\n# Approach\\nIt calculates the remaining fuel in the main tank after traveling (mainTank - 1) / 4 units of distance.\\n\\nThis calculation assumes that the main tank consumes 1 unit of fuel for every 5 units of distance traveled.\\n\\nIt checks if the additional tank\\'s fuel is greater than or equal to the remaining fuel calculated in the previous step.\\n\\nIf the additional tank\\'s fuel is sufficient to cover the remaining distance in the main tank, it adds the remaining fuel to the main tank by setting mainTank += Remaining_fuel_In_Main_Tank.\\n\\nIf the additional tank\\'s fuel is not sufficient, it adds the entire additional tank\\'s fuel to the main tank by setting mainTank += additionalTank.\\n\\nFinally, it returns the total distance traveled, which is 10 * mainTank. This calculation assumes that each unit of fuel in the main tank can cover 10 units of distance.\\n\\n\\nYou need some mathematical thought for that..\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int Remaining_fuel_In_Main_Tank=(mainTank-1)/4;\\n        if(additionalTank>=Remaining_fuel_In_Main_Tank) \\n        {\\n            mainTank+=Remaining_fuel_In_Main_Tank;\\n        }\\n        else\\n        {\\n            mainTank+=additionalTank;\\n        }\\n        return 10*mainTank;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int Remaining_fuel_In_Main_Tank=(mainTank-1)/4;\\n        if(additionalTank>=Remaining_fuel_In_Main_Tank) \\n        {\\n            mainTank+=Remaining_fuel_In_Main_Tank;\\n        }\\n        else\\n        {\\n            mainTank+=additionalTank;\\n        }\\n        return 10*mainTank;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983585,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) \\n    {\\n        int res = 0;\\n        while (mainTank >= 5 && additionalTank > 0)\\n        {\\n            mainTank -= 5;\\n            res += 50;\\n            mainTank++;\\n            additionalTank--;\\n        }\\n\\n        res += mainTank * 10;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) \\n    {\\n        int res = 0;\\n        while (mainTank >= 5 && additionalTank > 0)\\n        {\\n            mainTank -= 5;\\n            res += 50;\\n            mainTank++;\\n            additionalTank--;\\n        }\\n\\n        res += mainTank * 10;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971432,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven the problem, the main point of concern is when to transfer fuel from the additional tank to the main tank. The constraint of 5 liters consumption before a possible transfer leads us to think about solving this problem iteratively, deducting fuel from the main tank until it\\'s empty while occasionally refilling it from the additional tank.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Main Loop: Start a loop that runs while there\\'s fuel in the main tank.\\n2. Consume 5 Liters: If the main tank has 5 liters or more, consume those 5 liters, which results in a 50 km travel, and then check the additional tank.\\n3.Fuel Transfer: If the additional tank has at least 1 liter of fuel, transfer that liter to the main tank.\\n4. Less than 5 Liters: If the main tank has fewer than 5 liters, simply consume what\\'s left in the main tank to travel the corresponding distance.\\n5. Compute Distance: For every liter consumed, increase the total distance by 10 km.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        distance = 0\\n\\n        while mainTank > 0:\\n            if mainTank -5 >=0:\\n                mainTank -=5\\n                distance += 5 * 10\\n                if additionalTank:\\n                    additionalTank -=1\\n                    mainTank+=1\\n            else:\\n                mainTank-=1\\n                distance+=10\\n        return distance\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        distance = 0\\n\\n        while mainTank > 0:\\n            if mainTank -5 >=0:\\n                mainTank -=5\\n                distance += 5 * 10\\n                if additionalTank:\\n                    additionalTank -=1\\n                    mainTank+=1\\n            else:\\n                mainTank-=1\\n                distance+=10\\n        return distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967432,
                "title": "user-friendly-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans = 0;\\n        while(mainTank > 4 && additionalTank > 0){\\n            ans += 5 * 10;\\n            mainTank = mainTank - 5 + 1;\\n            additionalTank -= 1;\\n        }\\n        return ans + (mainTank * 10);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans = 0;\\n        while(mainTank > 4 && additionalTank > 0){\\n            ans += 5 * 10;\\n            mainTank = mainTank - 5 + 1;\\n            additionalTank -= 1;\\n        }\\n        return ans + (mainTank * 10);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964712,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        return 10 * (mainTank + min(additionalTank, (mainTank - 1) / 4));\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        return 10 * (mainTank + min(additionalTank, (mainTank - 1) / 4));\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962608,
                "title": "distance-traveled-js-back-to-the-future",
                "content": "```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    ans = 0\\n\\n    while (mainTank >= 5) {\\n        mainTank -= 5\\n        ans += 50\\n        if (additionalTank > 0) {\\n            mainTank += 1\\n            additionalTank -= 1\\n        }\\n    }\\n\\n    return ans + mainTank * 10\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    ans = 0\\n\\n    while (mainTank >= 5) {\\n        mainTank -= 5\\n        ans += 50\\n        if (additionalTank > 0) {\\n            mainTank += 1\\n            additionalTank -= 1\\n        }\\n    }\\n\\n    return ans + mainTank * 10\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3948395,
                "title": "simple-self-explanatory-java-code-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank < 5)\\n            return mainTank*10;\\n        else{\\n            int dist = 0;\\n            for(int i=1; i <= mainTank; i++){\\n                dist = dist + 10;\\n                if(i%5 == 0 && additionalTank >= 1){\\n                    mainTank++;\\n                    additionalTank--;\\n                }\\n            }\\n            return dist;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank < 5)\\n            return mainTank*10;\\n        else{\\n            int dist = 0;\\n            for(int i=1; i <= mainTank; i++){\\n                dist = dist + 10;\\n                if(i%5 == 0 && additionalTank >= 1){\\n                    mainTank++;\\n                    additionalTank--;\\n                }\\n            }\\n            return dist;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943169,
                "title": "simple-java-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank<=4|| additionalTank<=0){\\n            return mainTank*10;\\n        }\\n        return 50+distanceTraveled(mainTank-5+1, additionalTank-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank<=4|| additionalTank<=0){\\n            return mainTank*10;\\n        }\\n        return 50+distanceTraveled(mainTank-5+1, additionalTank-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933146,
                "title": "easy-and-clean-code-to-understand-c-beginner-friendly-solution",
                "content": "Upvote if you find this helpful !!\\n```cpp\\nint distanceTraveled(int mainTank, int additionalTank) \\n{\\n\\tint ans=0;\\n\\tint i=1;\\n\\twhile(i<=mainTank)\\n\\t{\\n\\t\\tif(i%5==0 and additionalTank )\\n\\t\\t{\\n\\t\\t\\tmainTank++;\\n\\t\\t\\tadditionalTank--;\\n\\t\\t}\\n\\t\\tans+=10;\\n\\t\\ti++;\\n\\t}\\n\\treturn ans;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "Upvote if you find this helpful !!\\n```cpp\\nint distanceTraveled(int mainTank, int additionalTank) \\n{\\n\\tint ans=0;\\n\\tint i=1;\\n\\twhile(i<=mainTank)\\n\\t{\\n\\t\\tif(i%5==0 and additionalTank )\\n\\t\\t{\\n\\t\\t\\tmainTank++;\\n\\t\\t\\tadditionalTank--;\\n\\t\\t}\\n\\t\\tans+=10;\\n\\t\\ti++;\\n\\t}\\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3918571,
                "title": "distance-traveled",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0;\\n        int count = 0;\\n        while(mainTank>0){\\n            distance = distance + 10;\\n            count++;\\n            if(count>=5 && additionalTank>0){\\n                mainTank++;\\n                additionalTank--;\\n                count = 0;\\n            }\\n            mainTank--;\\n        }\\n        return distance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0;\\n        int count = 0;\\n        while(mainTank>0){\\n            distance = distance + 10;\\n            count++;\\n            if(count>=5 && additionalTank>0){\\n                mainTank++;\\n                additionalTank--;\\n                count = 0;\\n            }\\n            mainTank--;\\n        }\\n        return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909149,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int totalDis = 0;\\n        while(mainTank >= 5) {\\n            mainTank = mainTank - 5;\\n            totalDis += 50;\\n            if(additionalTank > 0) {\\n                mainTank++;\\n                additionalTank--;\\n            }\\n        }\\n\\n        totalDis += mainTank * 10;\\n\\n        return totalDis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int totalDis = 0;\\n        while(mainTank >= 5) {\\n            mainTank = mainTank - 5;\\n            totalDis += 50;\\n            if(additionalTank > 0) {\\n                mainTank++;\\n                additionalTank--;\\n            }\\n        }\\n\\n        totalDis += mainTank * 10;\\n\\n        return totalDis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906164,
                "title": "bruteforce-method-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust write the Given things firsT, LIKE:\\n1) Mileage = 10km/lt i.e. in 1 lt it goes to 10km\\n2)Main tank gets the fuel of 1lt from additional tank whenever it reaches to multiple of 5lt. i.e 5,10,15 etc.\\n3)Additional tank will keep on supplying 1lt at a multiple of 5 until it have atleast 1lt left in it. i.e. greater than 0.\\n\\nNow?\\nKrnaa kya hau? What we have to do in question?\\nWe have to give the how much km the vechile have completed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we will make a loop which will run until the mainTank fuel is greater than 0. i.e. while(mainTank>0). We will create a used variable which will show how much fuel is used. We will increase it by 1 whenver mainTank>0, and if used is multiple of 5 then the additional tank will supply the 1lt of fuel i.e. additionalTankfuel decreases by 1, and main Tank increases by 1. and when the loop end, for wach 1lt of used fuel the ans = ans + 10; since for 1lt of fuel the truck drives 10km.\\n\\nMore clearly is explained through code and comment.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int m = mainTank;\\n        int a = additionalTank;\\n// mileage: - 10km/lt ---> 1lt mai 10km\\n// if 5lt of fuel is used up in main tank---> additional tank = fuel - 1(until fuel > 1)\\n        int ans=0;\\n        int used=0;\\n\\n        while(m>0) \\n        {\\n          used++; //increase krdo used ko until it main tank>0 hai i.e filled\\n\\n        // andar wale loop mai tab hi jayenge jab 5 ka multiple hoga\\n          if(used%5==0 && a>0)\\n          {\\n              a--; //additional tank se 1lt kaam ho gya\\n              m++; //main tank mai 1lt bad gya\\n          }\\n\\n          m--;//ab main tank se 1lt aur kaam hoga kyuki use ho gya\\n          ans = ans +10; //10km chal gyi gaadi\\n        }\\n        return ans;\\n        \\n    } \\n};\\n    \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int m = mainTank;\\n        int a = additionalTank;\\n// mileage: - 10km/lt ---> 1lt mai 10km\\n// if 5lt of fuel is used up in main tank---> additional tank = fuel - 1(until fuel > 1)\\n        int ans=0;\\n        int used=0;\\n\\n        while(m>0) \\n        {\\n          used++; //increase krdo used ko until it main tank>0 hai i.e filled\\n\\n        // andar wale loop mai tab hi jayenge jab 5 ka multiple hoga\\n          if(used%5==0 && a>0)\\n          {\\n              a--; //additional tank se 1lt kaam ho gya\\n              m++; //main tank mai 1lt bad gya\\n          }\\n\\n          m--;//ab main tank se 1lt aur kaam hoga kyuki use ho gya\\n          ans = ans +10; //10km chal gyi gaadi\\n        }\\n        return ans;\\n        \\n    } \\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879711,
                "title": "java-5ms-beats-98-70",
                "content": "# Intuition & Approach\\n- perform a simulation\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 5ms Beats 98.70%\\n\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n\\n        // strategy: simulation\\n\\n        int distanceTraveled_km = 0;  // what we\\'ll return\\n        int fuelUsed_L = 0;\\n\\n        while (mainTank > 0) {\\n            // each loop is 10 km traveled\\n            distanceTraveled_km += 10;\\n            --mainTank;\\n            ++fuelUsed_L;\\n\\n            if (fuelUsed_L % 5 == 0) {\\n                if (additionalTank >= 1) {\\n                    --additionalTank;\\n                    ++mainTank;\\n                }\\n            }\\n        }\\n\\n        return distanceTraveled_km;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 5ms Beats 98.70%\\n\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n\\n        // strategy: simulation\\n\\n        int distanceTraveled_km = 0;  // what we\\'ll return\\n        int fuelUsed_L = 0;\\n\\n        while (mainTank > 0) {\\n            // each loop is 10 km traveled\\n            distanceTraveled_km += 10;\\n            --mainTank;\\n            ++fuelUsed_L;\\n\\n            if (fuelUsed_L % 5 == 0) {\\n                if (additionalTank >= 1) {\\n                    --additionalTank;\\n                    ++mainTank;\\n                }\\n            }\\n        }\\n\\n        return distanceTraveled_km;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877129,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public int DistanceTraveled(int mainTank, int additionalTank) {\\n         int usedFuelCount = 0;\\n            int totalDistance = 0;\\n            while (mainTank> 0)\\n            {\\n                totalDistance += 10;\\n                usedFuelCount++;\\n                mainTank--;\\n                if(usedFuelCount==5 && additionalTank>0)\\n                {\\n                    mainTank++;\\n                    additionalTank--;\\n                    usedFuelCount = 0;\\n                }\\n            }\\n            return totalDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int DistanceTraveled(int mainTank, int additionalTank) {\\n         int usedFuelCount = 0;\\n            int totalDistance = 0;\\n            while (mainTank> 0)\\n            {\\n                totalDistance += 10;\\n                usedFuelCount++;\\n                mainTank--;\\n                if(usedFuelCount==5 && additionalTank>0)\\n                {\\n                    mainTank++;\\n                    additionalTank--;\\n                    usedFuelCount = 0;\\n                }\\n            }\\n            return totalDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876228,
                "title": "total-distance-travelled",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        if mainTank<5:\\n            return mainTank*10\\n        mainTank-=5\\n        if additionalTank>=1:\\n            mainTank+=1\\n            additionalTank-=1\\n        return 50+Solution.distanceTraveled(self,mainTank,additionalTank)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        if mainTank<5:\\n            return mainTank*10\\n        mainTank-=5\\n        if additionalTank>=1:\\n            mainTank+=1\\n            additionalTank-=1\\n        return 50+Solution.distanceTraveled(self,mainTank,additionalTank)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867661,
                "title": "very-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will iterate to simulate each litre of fuel where one speding every 5 litre of fuel we use from main tank we\\'ll add 1 litre of fuel from additional fuel tank. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans=0;\\n        int i=1;\\n        while(i<=mainTank){\\n            if(i%5==0 && additionalTank) {mainTank++; additionalTank--;}\\n            ans+=10;\\n            i++;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans=0;\\n        int i=1;\\n        while(i<=mainTank){\\n            if(i%5==0 && additionalTank) {mainTank++; additionalTank--;}\\n            ans+=10;\\n            i++;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865111,
                "title": "beats-100-00-of-users-with-javascript-in-runtime",
                "content": "# Intuition\\nthe first thing that come to mind was trying to solve this problem only using mathematical formulas, or something like that, but i can\\'t find a solution in this path, so i tried to use a for loop if 2 variables to help me keep track my tank volume\\n\\n# Approach\\nsince we know that every 5 meters we need to refuel 1 liter, we need to iterate over the number of meters we are going to travel and add fuel to our tank, and on the other hand we need to check if we have already emptied the reserve fuel or not \\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    let temp = 0\\n    let ourTank = mainTank\\n    for(i=1;i <= ourTank;i++){\\n        if(temp + 1 > additionalTank) break\\n        if(i % 5 === 0){\\n            ourTank++\\n            temp++\\n        }\\n    }\\n    return ourTank * 10\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    let temp = 0\\n    let ourTank = mainTank\\n    for(i=1;i <= ourTank;i++){\\n        if(temp + 1 > additionalTank) break\\n        if(i % 5 === 0){\\n            ourTank++\\n            temp++\\n        }\\n    }\\n    return ourTank * 10\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864436,
                "title": "java-100-faster",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans = 1;\\n        for(int i = 0; i <= mainTank - 5; i+= 5){\\n            if(additionalTank > 0) {\\n                additionalTank--;\\n                mainTank++;\\n            }else break;\\n        }\\n\\n        return mainTank * 10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int ans = 1;\\n        for(int i = 0; i <= mainTank - 5; i+= 5){\\n            if(additionalTank > 0) {\\n                additionalTank--;\\n                mainTank++;\\n            }else break;\\n        }\\n\\n        return mainTank * 10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862481,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func distanceTraveled(_ mainTank: Int, _ additionalTank: Int) -> Int {\\n        \\n        var m = mainTank\\n        var a = additionalTank\\n        var d = 0\\n        \\n        while m > 0 {\\n            m += (m >= 5 && a > 0) ? 1 : 0\\n            d += min(m, 5) * 10\\n            m -= 5\\n            a -= 1\\n        }\\n\\n        return d\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distanceTraveled(_ mainTank: Int, _ additionalTank: Int) -> Int {\\n        \\n        var m = mainTank\\n        var a = additionalTank\\n        var d = 0\\n        \\n        while m > 0 {\\n            m += (m >= 5 && a > 0) ? 1 : 0\\n            d += min(m, 5) * 10\\n            m -= 5\\n            a -= 1\\n        }\\n\\n        return d\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839660,
                "title": "great-runtime-but-higher-memory-usage-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    \\n    let totalDistance = 0;\\n\\n    // 10 km / L\\n    // subtract 5 from mainTank and then if addTank > 0, addTank-1, mainTank+1, distanceTraveled = amountSubtracted from mainTank,\\n    // while mainTank is above 0 run this \\n    let gasLiterCounter = 0;\\n\\n\\n\\n\\n\\n    while (mainTank>0) {\\n        mainTank -= 1;\\n        totalDistance += 10; \\n        gasLiterCounter += 1;\\n        if(gasLiterCounter % 5 === 0) {\\n            if (additionalTank > 0) {\\n                additionalTank -= 1;\\n                mainTank += 1;\\n            }\\n        }\\n    }\\n    return totalDistance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    \\n    let totalDistance = 0;\\n\\n    // 10 km / L\\n    // subtract 5 from mainTank and then if addTank > 0, addTank-1, mainTank+1, distanceTraveled = amountSubtracted from mainTank,\\n    // while mainTank is above 0 run this \\n    let gasLiterCounter = 0;\\n\\n\\n\\n\\n\\n    while (mainTank>0) {\\n        mainTank -= 1;\\n        totalDistance += 10; \\n        gasLiterCounter += 1;\\n        if(gasLiterCounter % 5 === 0) {\\n            if (additionalTank > 0) {\\n                additionalTank -= 1;\\n                mainTank += 1;\\n            }\\n        }\\n    }\\n    return totalDistance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836000,
                "title": "swift-one-liner-o-1-time-space",
                "content": "The first transfer from the additional tank will occur when 5 litres have been consumed from the main tank. Subsequent transfer will happen with the previous transfer of 1 litre has been consumed and 4 litres from the main tank. \\n\\nSo the number of (1L) transfers is\\n\\n$$transfers = min(additonalTank, (mainTank - 1) / 4)$$\\n\\nand the total available fuel is \\n\\n$$totalFuel = mainTank + min(additonalTank, (mainTank - 1) / 4)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    func distanceTraveled(_ mainTank: Int, _ additionalTank: Int) -> Int {\\n        10 * (mainTank + min(additionalTank, (mainTank - 1) / 4))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distanceTraveled(_ mainTank: Int, _ additionalTank: Int) -> Int {\\n        10 * (mainTank + min(additionalTank, (mainTank - 1) / 4))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831007,
                "title": "easy-solution",
                "content": "Easy solution`code`\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int dist=0;\\n        while(mainTank>0){\\n            dist++;\\n            mainTank--;\\n            if(dist!=0&&dist%5==0&&additionalTank>0){\\n                additionalTank--;\\n                mainTank++;\\n                \\n            }\\n        }return dist*10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int dist=0;\\n        while(mainTank>0){\\n            dist++;\\n            mainTank--;\\n            if(dist!=0&&dist%5==0&&additionalTank>0){\\n                additionalTank--;\\n                mainTank++;\\n                \\n            }\\n        }return dist*10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829759,
                "title": "the-most-bruteforce-approach",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this solution, I take exactly the steps in the question.\\nFirst thing to note is how to calculate the distance, given the litters. ```Distance = numLiters * 10``` since 1 liter covers 10 km. \\nIn the start, there is an automatic ```mainTank * 10``` km since it is guaranteed that the car will use all the liters in the main tank. That is why I initiliaze ```result``` with ```mainTank * 10```\\nTo be able to accomodate the additionalTank, we use the bruteforce way. After every five liters is used up(```mainTank -= 5```), tansfer 1 liter from additionalTank to mainTank (```mainTank += 1``` and ```additionalTank -= 1```). Remember that, when we add a liter to mainTank, we also have to calculate its distance, hence we increment result by 10 (```result += 10```)\\nNow, when do we stop adding tansfering liters? (```additing 1 and subtracting 5```)?\\nWe will stop when the additionalTank finishes or when there is not up to 5 liters left in main tank and hence the while condition, ```while mainTank >= 5 or additionalTank```\\n\\nAt the end, you return ```result```\\n\\n# Complexity\\n- Time complexity:\\nO(min(mainTank / 5), additionalTank), which is roughly O(min(mainTank, additionalTank))\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        result = mainTank * 10\\n        while mainTank >= 5 and additionalTank:\\n            result += 10\\n            mainTank -= 5\\n            mainTank += 1\\n            additionalTank -= 1\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Distance = numLiters * 10```\n```mainTank * 10```\n```result```\n```mainTank * 10```\n```mainTank -= 5```\n```mainTank += 1```\n```additionalTank -= 1```\n```result += 10```\n```additing 1 and subtracting 5```\n```while mainTank >= 5 or additionalTank```\n```result```\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        result = mainTank * 10\\n        while mainTank >= 5 and additionalTank:\\n            result += 10\\n            mainTank -= 5\\n            mainTank += 1\\n            additionalTank -= 1\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823546,
                "title": "python-3-1-line-w-chatgpt-explanation-t-m-99-98",
                "content": "# Intuition\\n![Screenshot 2023-07-27 165741.png](https://assets.leetcode.com/users/images/4e63743a-4e6e-4f7a-9119-084947d970bf_1690459112.4551978.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        return 10*(mainTank + min((mainTank-1)//4,additionalTank))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        return 10*(mainTank + min((mainTank-1)//4,additionalTank))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820159,
                "title": "using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def distanceTraveled(self, mainTank, additionalTank):\\n        \"\"\"\\n        :type mainTank: int\\n        :type additionalTank: int\\n        :rtype: int\\n        \"\"\"\\n\\n       \\n        mt,at,prev,n=mainTank,additionalTank,0,-1\\n   \\n        while True:\\n                \\n                prev,n=n,int(mt/5)\\n                \\n                if at>=n:\\n                  mt=mainTank+n\\n                else:\\n                      mt=mainTank+at\\n                      break\\n                if prev==n:\\n                        break\\n        \\n        return mt*10\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def distanceTraveled(self, mainTank, additionalTank):\\n        \"\"\"\\n        :type mainTank: int\\n        :type additionalTank: int\\n        :rtype: int\\n        \"\"\"\\n\\n       \\n        mt,at,prev,n=mainTank,additionalTank,0,-1\\n   \\n        while True:\\n                \\n                prev,n=n,int(mt/5)\\n                \\n                if at>=n:\\n                  mt=mainTank+n\\n                else:\\n                      mt=mainTank+at\\n                      break\\n                if prev==n:\\n                        break\\n        \\n        return mt*10\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817828,
                "title": "basic-approach-basic-while-loop-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNormal mathematics\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to add 1 litre of fuel from additionalTank to mainTank for every 5 litre fuel consumption from mainTank.\\nRun a while loop in which mainTank value is greater than 4 and additional Tank value is greater than zero(atleat 1).\\nDefine a answer variable.\\nAdd 50 value to it for every iteration, decrement mainTank value by 5, increment mainTank value by 1 and decrement additional tank value by 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mainTank)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nconstant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int Tank) {\\n        int distance = 0;\\n\\n\\n        while( mainTank > 4 and Tank > 0 )\\n        {\\n            distance = distance + 5 * 10;\\n            mainTank = mainTank - 5;\\n            mainTank = mainTank + 1;\\n            Tank--;\\n        }\\n\\n        distance = distance + mainTank * 10;\\n\\n        return distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int Tank) {\\n        int distance = 0;\\n\\n\\n        while( mainTank > 4 and Tank > 0 )\\n        {\\n            distance = distance + 5 * 10;\\n            mainTank = mainTank - 5;\\n            mainTank = mainTank + 1;\\n            Tank--;\\n        }\\n\\n        distance = distance + mainTank * 10;\\n\\n        return distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814383,
                "title": "c-one-line-code-mathematical-and-formula-based-approach",
                "content": "# Intuition\\nA truck has two fuel tanks. We are given two integers, mainTank representing the fuel present in the main tank in liters and additionalTank representing the fuel present in the additional tank in liters.\\n\\nThe truck has a mileage of 10 km per liter. Whenever 5 liters of fuel get used up in the main tank, if the additional tank has at least 1 liters of fuel, 1 liters of fuel will be transferred from the additional tank to the main tank.\\n\\nWe have to return the maximum distance which can be traveled.\\n\\n# Approach\\nThe approach is mathematical and formula-based, if the mainTank has less than 5 liters of fuel in that case no fuel from additionalTank would be added and the mileage per liter is of 10 km, so in that case we simply return mainTank\\\\*10, otherwise if there are more than 5 liters of fuel in that case for the first 5 liters a liter of fuel will be added from additionalTank so total fuel used becomes 6 liters thenafter, for every 4 liters of fuel from mainTank, a liter is added so the formula becomes 1+(mainTank-5)/4 and it cannot exceed the capacity of additionalTank so we take the minimum, so the maximum fuel obtainable by additional tank becomes min(1+(mainTank-5)/4, additionalTank), so we return mainTank\\\\*10+min(1+(mainTank-5)/4, additionalTank)\\\\*10, because in this case we add distance provided to us by fuel of mainTank and the fuel obtained by additionalTank.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        return mainTank<5?mainTank*10:mainTank*10+min(1+(mainTank-5)/4, additionalTank)*10;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        return mainTank<5?mainTank*10:mainTank*10+min(1+(mainTank-5)/4, additionalTank)*10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812519,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def distanceTraveled(self, mainTank, additionalTank):\\n        \"\"\"\\n        :type mainTank: int\\n        :type additionalTank: int\\n        :rtype: int\\n        \"\"\"\\n        res, count = 0, 0\\n        while mainTank > 0:\\n            mainTank -= 1\\n            res += 10\\n            count += 1\\n            if count % 5 ==0 and additionalTank >=1:\\n                count = 0\\n                mainTank +=1 \\n                additionalTank -= 1\\n\\n        return res \\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def distanceTraveled(self, mainTank, additionalTank):\\n        \"\"\"\\n        :type mainTank: int\\n        :type additionalTank: int\\n        :rtype: int\\n        \"\"\"\\n        res, count = 0, 0\\n        while mainTank > 0:\\n            mainTank -= 1\\n            res += 10\\n            count += 1\\n            if count % 5 ==0 and additionalTank >=1:\\n                count = 0\\n                mainTank +=1 \\n                additionalTank -= 1\\n\\n        return res \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807042,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    let n=0;\\n    let res=0;\\n    let i=mainTank;\\n    while(i>0){\\n         i--;\\n         n++;\\n         res+=10;\\n        if(n==5){\\n            n=0;\\n            if(additionalTank>0){\\n               additionalTank--;\\n               i++; \\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    let n=0;\\n    let res=0;\\n    let i=mainTank;\\n    while(i>0){\\n         i--;\\n         n++;\\n         res+=10;\\n        if(n==5){\\n            n=0;\\n            if(additionalTank>0){\\n               additionalTank--;\\n               i++; \\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3804042,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int m, int a) {\\n        if(m<5)\\n        return m*10;\\n        int ans=0;\\n        if(m>=5 && a>=1){\\n            while(m>0){\\n                if(m>=5){\\n                    ans+=5*10;\\n                    m=m-5;\\n                    if(a>=1){\\n                        m=m+1;\\n                        a=a-1;\\n                    }\\n                    else{\\n                        ans+=m*10;\\n                        m=0;\\n                    }\\n                }\\n                else{\\n                    ans+=m*10;\\n                    m=0;\\n                }\\n            }\\n        }\\n        else{\\n            return m*10;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int m, int a) {\\n        if(m<5)\\n        return m*10;\\n        int ans=0;\\n        if(m>=5 && a>=1){\\n            while(m>0){\\n                if(m>=5){\\n                    ans+=5*10;\\n                    m=m-5;\\n                    if(a>=1){\\n                        m=m+1;\\n                        a=a-1;\\n                    }\\n                    else{\\n                        ans+=m*10;\\n                        m=0;\\n                    }\\n                }\\n                else{\\n                    ans+=m*10;\\n                    m=0;\\n                }\\n            }\\n        }\\n        else{\\n            return m*10;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802903,
                "title": "simple-intuitive-solution-in-python-sc-o-1-tc-o-n",
                "content": "# Intuition\\nUsing simulation. Increment multiplier by one every time the main tank decreases by 5 litres and subtract from additionalTank at the same time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n\\n        num = 0\\n        while mainTank >= 5:\\n            mainTank -= 5\\n            if additionalTank:\\n                mainTank += 1\\n                additionalTank -= 1\\n            num += 1\\n        \\n        return (num * 50) + (mainTank * 10)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n\\n        num = 0\\n        while mainTank >= 5:\\n            mainTank -= 5\\n            if additionalTank:\\n                mainTank += 1\\n                additionalTank -= 1\\n            num += 1\\n        \\n        return (num * 50) + (mainTank * 10)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798877,
                "title": "javascript-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nRecursive approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    if (mainTank < 5) return mainTank * 10;    \\n    if (additionalTank > 0) {\\n        additionalTank--\\n        return 50 + distanceTraveled(mainTank - 4, additionalTank);\\n    } else {\\n        return 50 + distanceTraveled(mainTank - 5, additionalTank);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    if (mainTank < 5) return mainTank * 10;    \\n    if (additionalTank > 0) {\\n        additionalTank--\\n        return 50 + distanceTraveled(mainTank - 4, additionalTank);\\n    } else {\\n        return 50 + distanceTraveled(mainTank - 5, additionalTank);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3798221,
                "title": "kotlin-solution-simulation",
                "content": "# Code\\n```\\nclass Solution {\\n    fun distanceTraveled(mainTank: Int, additionalTank: Int): Int {\\n        var result = 0\\n        var remainingMainTank = mainTank\\n        var remainingAdditionalTank = additionalTank\\n\\n        while (remainingMainTank - 5 >= 0) {\\n            remainingMainTank -= 5\\n            remainingAdditionalTank--\\n\\n            if (remainingAdditionalTank >= 0)\\n                remainingMainTank++\\n                \\n            result += 50\\n        }\\n\\n        return result + remainingMainTank * 10\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    fun distanceTraveled(mainTank: Int, additionalTank: Int): Int {\\n        var result = 0\\n        var remainingMainTank = mainTank\\n        var remainingAdditionalTank = additionalTank\\n\\n        while (remainingMainTank - 5 >= 0) {\\n            remainingMainTank -= 5\\n            remainingAdditionalTank--\\n\\n            if (remainingAdditionalTank >= 0)\\n                remainingMainTank++\\n                \\n            result += 50\\n        }\\n\\n        return result + remainingMainTank * 10\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797643,
                "title": "100-beat-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mT, int aT) {\\n        int i=1;\\n        int dis=0;\\n      while(mT>=5&&aT!=0){\\n       dis+=10*5;\\n       mT=mT-4;;\\n       aT--;\\n      }\\n      if(mT!=0){\\n          dis+=mT*10;\\n      }\\n      return dis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mT, int aT) {\\n        int i=1;\\n        int dis=0;\\n      while(mT>=5&&aT!=0){\\n       dis+=10*5;\\n       mT=mT-4;;\\n       aT--;\\n      }\\n      if(mT!=0){\\n          dis+=mT*10;\\n      }\\n      return dis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792448,
                "title": "distance-travel-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n      int ans=0;\\n      while(mainTank>=5 && additionalTank!=0){\\n          ans +=50;\\n          additionalTank--;\\n          mainTank -=4;\\n      }\\n      ans +=mainTank *10;\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n      int ans=0;\\n      while(mainTank>=5 && additionalTank!=0){\\n          ans +=50;\\n          additionalTank--;\\n          mainTank -=4;\\n      }\\n      ans +=mainTank *10;\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789982,
                "title": "easy-challenge",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    const CAPACITY= 10 // km/liter\\n    let distance=0;\\n    let i=0;\\n    while (mainTank >=1 && additionalTank <= 100){\\n        distance += 10\\n        mainTank --\\n        i++\\n        if(i%5 === 0 && additionalTank >= 1){\\n            mainTank += 1\\n            additionalTank --\\n        }\\n    }\\n    return distance\\n   \\n   \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    const CAPACITY= 10 // km/liter\\n    let distance=0;\\n    let i=0;\\n    while (mainTank >=1 && additionalTank <= 100){\\n        distance += 10\\n        mainTank --\\n        i++\\n        if(i%5 === 0 && additionalTank >= 1){\\n            mainTank += 1\\n            additionalTank --\\n        }\\n    }\\n    return distance\\n   \\n   \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786442,
                "title": "easiest-solution-ever",
                "content": "\\n# Code\\n```\\nclass Solution {\\n   public int distanceTraveled(int mainTank, int additionalTank) {\\n            int dis=0;\\n            while(mainTank>=5){\\n               mainTank = mainTank -5;\\n               dis = dis + 50;\\n               if(additionalTank>=1) {\\n                additionalTank--;\\n                mainTank++;\\n               }\\n               \\n            }\\n            dis = dis + mainTank*10;\\n            return dis;\\n        }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int distanceTraveled(int mainTank, int additionalTank) {\\n            int dis=0;\\n            while(mainTank>=5){\\n               mainTank = mainTank -5;\\n               dis = dis + 50;\\n               if(additionalTank>=1) {\\n                additionalTank--;\\n                mainTank++;\\n               }\\n               \\n            }\\n            dis = dis + mainTank*10;\\n            return dis;\\n        }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785105,
                "title": "beginner-friendly-easy-to-understand-memory-efficient",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int count = 0;\\n        while (mainTank != 0){\\n            if (mainTank >= 5){\\n                count += 5;\\n                mainTank -= 5;\\n                if(additionalTank != 0){\\n                    mainTank++;\\n                    additionalTank--;\\n                }\\n            }\\n            else {\\n                count += mainTank;\\n                mainTank = 0;\\n            }     \\n        }\\n        return count*10;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int count = 0;\\n        while (mainTank != 0){\\n            if (mainTank >= 5){\\n                count += 5;\\n                mainTank -= 5;\\n                if(additionalTank != 0){\\n                    mainTank++;\\n                    additionalTank--;\\n                }\\n            }\\n            else {\\n                count += mainTank;\\n                mainTank = 0;\\n            }     \\n        }\\n        return count*10;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783128,
                "title": "c-simple-math",
                "content": "# Complexity\\n- Time complexity:\\nO(log(mainTank+additionalTank))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int dt =0,temp=0;\\n        while (mainTank>=5){\\n            temp = mainTank-mainTank%5;\\n            dt += temp*10;\\n            mainTank =  mainTank%5 + min(additionalTank,temp/5);\\n            additionalTank -= min(additionalTank,temp/5);\\n        }\\n        dt+=mainTank*10;\\n        return dt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int dt =0,temp=0;\\n        while (mainTank>=5){\\n            temp = mainTank-mainTank%5;\\n            dt += temp*10;\\n            mainTank =  mainTank%5 + min(additionalTank,temp/5);\\n            additionalTank -= min(additionalTank,temp/5);\\n        }\\n        dt+=mainTank*10;\\n        return dt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781104,
                "title": "follow-the-description-python-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Program the drive as described\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Use mainTank fuel, add additionalTank fuel if it exists\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where is the size of the mainTank\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        driven = 0\\n        while mainTank >= 5:\\n            driven += 50\\n            if additionalTank >= 1:\\n                additionalTank -= 1\\n                mainTank += 1\\n            mainTank -= 5\\n        return driven + mainTank*10\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        driven = 0\\n        while mainTank >= 5:\\n            driven += 50\\n            if additionalTank >= 1:\\n                additionalTank -= 1\\n                mainTank += 1\\n            mainTank -= 5\\n        return driven + mainTank*10\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779771,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int answer=0;\\n        while(mainTank>0)\\n        {\\n            if(mainTank>=5)\\n            {\\n                answer=answer+5;\\n                mainTank=mainTank-5;\\n                if(additionalTank>0)\\n                {\\n                    additionalTank--;\\n                    mainTank++;\\n                }\\n            }\\n            else\\n            {\\n                answer=answer+mainTank;\\n                mainTank=0;\\n            }\\n        }\\n        return answer*10;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int answer=0;\\n        while(mainTank>0)\\n        {\\n            if(mainTank>=5)\\n            {\\n                answer=answer+5;\\n                mainTank=mainTank-5;\\n                if(additionalTank>0)\\n                {\\n                    additionalTank--;\\n                    mainTank++;\\n                }\\n            }\\n            else\\n            {\\n                answer=answer+mainTank;\\n                mainTank=0;\\n            }\\n        }\\n        return answer*10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778715,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int maintank, int addtank)\\n    {\\n        int total_distance=0;\\n        //if initial capacity of main tank is less then 5\\n        if(maintank<5)\\n        {\\n            return maintank*10;\\n        }\\n        //else we will use this loop\\n        while(maintank>=5)\\n        {\\n            if(addtank>=1)\\n            {\\n                maintank-=4;\\n                total_distance+=5*10;\\n                addtank--;\\n            }\\n            else\\n            {\\n                maintank-=5;\\n                total_distance+=5*10;\\n            }\\n        }  \\n        //if still there is < 5 leter of fuel available we will \\n        //simply multiply it by 10  \\n        if(maintank<5)\\n        {\\n            total_distance+=maintank*10;\\n        }   \\n        return total_distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int maintank, int addtank)\\n    {\\n        int total_distance=0;\\n        //if initial capacity of main tank is less then 5\\n        if(maintank<5)\\n        {\\n            return maintank*10;\\n        }\\n        //else we will use this loop\\n        while(maintank>=5)\\n        {\\n            if(addtank>=1)\\n            {\\n                maintank-=4;\\n                total_distance+=5*10;\\n                addtank--;\\n            }\\n            else\\n            {\\n                maintank-=5;\\n                total_distance+=5*10;\\n            }\\n        }  \\n        //if still there is < 5 leter of fuel available we will \\n        //simply multiply it by 10  \\n        if(maintank<5)\\n        {\\n            total_distance+=maintank*10;\\n        }   \\n        return total_distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777867,
                "title": "java-easy-solution-beats-100-7-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int totalLitre = 0;\\n        while (mainTank > 4)\\n        {\\n            totalLitre += 5;\\n            mainTank -= 5;\\n            if(additionalTank > 0)\\n            {\\n                additionalTank--;\\n                mainTank++;\\n            }                \\n        }\\n       return  (totalLitre + mainTank) * 10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int totalLitre = 0;\\n        while (mainTank > 4)\\n        {\\n            totalLitre += 5;\\n            mainTank -= 5;\\n            if(additionalTank > 0)\\n            {\\n                additionalTank--;\\n                mainTank++;\\n            }                \\n        }\\n       return  (totalLitre + mainTank) * 10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775950,
                "title": "simple-javascript-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    let travel = 0;\\n    while(mainTank > 0){\\n        travel++;\\n        mainTank--;\\n        if(travel != 0 && travel % 5 == 0 && additionalTank-- > 0)  mainTank++;\\n    }\\n    return travel * 10;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} mainTank\\n * @param {number} additionalTank\\n * @return {number}\\n */\\nvar distanceTraveled = function(mainTank, additionalTank) {\\n    let travel = 0;\\n    while(mainTank > 0){\\n        travel++;\\n        mainTank--;\\n        if(travel != 0 && travel % 5 == 0 && additionalTank-- > 0)  mainTank++;\\n    }\\n    return travel * 10;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775698,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        res = 0\\n        while mainTank >= 5:\\n            quotient, remainder = divmod(mainTank, 5)\\n            res += quotient * 5 * 10\\n            mainTank = remainder + min(additionalTank, quotient)\\n            additionalTank = max(additionalTank - quotient, 0)\\n        res += mainTank * 10\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        res = 0\\n        while mainTank >= 5:\\n            quotient, remainder = divmod(mainTank, 5)\\n            res += quotient * 5 * 10\\n            mainTank = remainder + min(additionalTank, quotient)\\n            additionalTank = max(additionalTank - quotient, 0)\\n        res += mainTank * 10\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773935,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->simple math\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->7ms\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->42.67\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank<5){\\n            return mainTank*10;\\n        }\\n        int ans=0;\\n        while(mainTank>=5 && additionalTank>0){\\n            mainTank-=5;\\n            additionalTank-=1;\\n            mainTank+=1;\\n            ans+=50;\\n\\n        }\\n        return ans+(mainTank*10);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank<5){\\n            return mainTank*10;\\n        }\\n        int ans=0;\\n        while(mainTank>=5 && additionalTank>0){\\n            mainTank-=5;\\n            additionalTank-=1;\\n            mainTank+=1;\\n            ans+=50;\\n\\n        }\\n        return ans+(mainTank*10);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773765,
                "title": "solution-beats-99-total-distance-traveled-problem-python-c-java-c-js-go-rust",
                "content": "\\uD83D\\uDCA8\\uD83D\\uDCAF Python Solution Beats 99% on LeetCode: Total Distance Traveled Problem \\uD83D\\uDE9A\\u26FD\\uFE0F\\n\\n# Intuition\\nOn first glance, this problem boils down to calculating the maximum distance a truck can travel with two fuel tanks, with the main tank having the capacity to take additional fuel from the secondary tank. The key insight is that for every 5 liters of fuel in the main tank, the truck can travel an extra 10 km, thanks to the additional tank. Therefore, we need to figure out how many times we can transfer fuel from the additional tank to the main tank and then compute the total distance.\\n\\nhttps://youtu.be/jQJ4Lgn_dQk\\n\\n# Approach\\nWe approach the problem by first calculating how many times we can transfer fuel from the additional tank to the main tank. This is done by the expression `(mainTank - 1) // 4`, as for every 4 liters used, we get an extra one from the additional tank. We then check if the additional tank has enough fuel to perform all the transfers. If it does, we increase the fuel in the main tank by the calculated amount; otherwise, we transfer as much fuel as there is in the additional tank. The last step is to return the total distance the truck can travel, which is the amount of fuel in the main tank (after all transfers) multiplied by the mileage of the truck, i.e., `10 * mainTank`.\\n\\n# Complexity\\n- Time complexity: The time complexity of the solution is $$O(1)$$ as we perform constant-time operations to calculate the solution.\\n\\n- Space complexity: The space complexity is also $$O(1)$$ since we\\'re only using a constant amount of space to store the variables.\\n\\n# Codes\\n\\n# >>> C++\\n        int x = (mainTank - 1) / 4;\\n        if (additionalTank >= x) {\\n            mainTank += x;\\n        } else {\\n            mainTank += additionalTank;\\n        }\\n        return 10 * mainTank;\\n# >>> Java\\n        int x = (mainTank - 1) / 4;\\n        if (additionalTank >= x) {\\n            mainTank += x;\\n        } else {\\n            mainTank += additionalTank;\\n        }\\n        return 10 * mainTank; \\n# >>> Python\\n        x = (mainTank - 1) // 4 \\n        if additionalTank >= x: \\n            mainTank += x \\n        else: \\n            mainTank += additionalTank \\n        return 10 * mainTank\\n# >>> C#\\n        int x = (mainTank - 1) / 4;\\n        if (additionalTank >= x) {\\n            mainTank += x;\\n        } else {\\n            mainTank += additionalTank;\\n        }\\n        return 10 * mainTank;\\n# >>> JavaScript\\n        let x = Math.floor((mainTank - 1) / 4);\\n        if (additionalTank >= x) {\\n            mainTank += x;\\n        } else {\\n            mainTank += additionalTank;\\n        }\\n        return 10 * mainTank;\\n# >>> Go\\n\\tx := (mainTank - 1) / 4\\n\\tif additionalTank >= x {\\n\\t\\tmainTank += x\\n\\t} else {\\n\\t\\tmainTank += additionalTank\\n\\t}\\n\\treturn 10 * mainTank\\n# >>> Rust\\n        let x = (main_tank - 1) / 4;\\n        if additional_tank >= x {\\n            main_tank += x;\\n        } else {\\n            main_tank += additional_tank;\\n        }\\n        10 * main_tank",
                "solutionTags": [
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust"
                ],
                "code": "\\uD83D\\uDCA8\\uD83D\\uDCAF Python Solution Beats 99% on LeetCode: Total Distance Traveled Problem \\uD83D\\uDE9A\\u26FD\\uFE0F\\n\\n# Intuition\\nOn first glance, this problem boils down to calculating the maximum distance a truck can travel with two fuel tanks, with the main tank having the capacity to take additional fuel from the secondary tank. The key insight is that for every 5 liters of fuel in the main tank, the truck can travel an extra 10 km, thanks to the additional tank. Therefore, we need to figure out how many times we can transfer fuel from the additional tank to the main tank and then compute the total distance.\\n\\nhttps://youtu.be/jQJ4Lgn_dQk\\n\\n# Approach\\nWe approach the problem by first calculating how many times we can transfer fuel from the additional tank to the main tank. This is done by the expression `(mainTank - 1) // 4`, as for every 4 liters used, we get an extra one from the additional tank. We then check if the additional tank has enough fuel to perform all the transfers. If it does, we increase the fuel in the main tank by the calculated amount; otherwise, we transfer as much fuel as there is in the additional tank. The last step is to return the total distance the truck can travel, which is the amount of fuel in the main tank (after all transfers) multiplied by the mileage of the truck, i.e., `10 * mainTank`.\\n\\n# Complexity\\n- Time complexity: The time complexity of the solution is $$O(1)$$ as we perform constant-time operations to calculate the solution.\\n\\n- Space complexity: The space complexity is also $$O(1)$$ since we\\'re only using a constant amount of space to store the variables.\\n\\n# Codes\\n\\n# >>> C++\\n        int x = (mainTank - 1) / 4;\\n        if (additionalTank >= x) {\\n            mainTank += x;\\n        } else {\\n            mainTank += additionalTank;\\n        }\\n        return 10 * mainTank;\\n# >>> Java\\n        int x = (mainTank - 1) / 4;\\n        if (additionalTank >= x) {\\n            mainTank += x;\\n        } else {\\n            mainTank += additionalTank;\\n        }\\n        return 10 * mainTank; \\n# >>> Python\\n        x = (mainTank - 1) // 4 \\n        if additionalTank >= x: \\n            mainTank += x \\n        else: \\n            mainTank += additionalTank \\n        return 10 * mainTank\\n# >>> C#\\n        int x = (mainTank - 1) / 4;\\n        if (additionalTank >= x) {\\n            mainTank += x;\\n        } else {\\n            mainTank += additionalTank;\\n        }\\n        return 10 * mainTank;\\n# >>> JavaScript\\n        let x = Math.floor((mainTank - 1) / 4);\\n        if (additionalTank >= x) {\\n            mainTank += x;\\n        } else {\\n            mainTank += additionalTank;\\n        }\\n        return 10 * mainTank;\\n# >>> Go\\n\\tx := (mainTank - 1) / 4\\n\\tif additionalTank >= x {\\n\\t\\tmainTank += x\\n\\t} else {\\n\\t\\tmainTank += additionalTank\\n\\t}\\n\\treturn 10 * mainTank\\n# >>> Rust\\n        let x = (main_tank - 1) / 4;\\n        if additional_tank >= x {\\n            main_tank += x;\\n        } else {\\n            main_tank += additional_tank;\\n        }\\n        10 * main_tank",
                "codeTag": "Unknown"
            },
            {
                "id": 3773099,
                "title": "simulate-the-process-97-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/79239bfc-b2bf-4e11-8a71-64c7e8df4898_1689503715.0340621.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        fuel = 0\\n        while mainTank > 4:\\n            n_fives, rem = divmod(mainTank, 5)\\n            fuel += n_fives * 5\\n            mainTank = rem\\n            if n_fives < additionalTank:\\n                mainTank += n_fives\\n                additionalTank -= n_fives\\n            else:\\n                mainTank += additionalTank\\n                break\\n        return (fuel + mainTank) * 10\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        fuel = 0\\n        while mainTank > 4:\\n            n_fives, rem = divmod(mainTank, 5)\\n            fuel += n_fives * 5\\n            mainTank = rem\\n            if n_fives < additionalTank:\\n                mainTank += n_fives\\n                additionalTank -= n_fives\\n            else:\\n                mainTank += additionalTank\\n                break\\n        return (fuel + mainTank) * 10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769328,
                "title": "scala-brute-force-recursion",
                "content": "# Code\\n```\\nobject Solution {\\n  def distanceTraveled(main: Int, other: Int): Int =\\n    if (main < 5) main * 10\\n    else 50 + (if (other > 0) distanceTraveled(main - 4, other - 1) else distanceTraveled(main - 5, 0))\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def distanceTraveled(main: Int, other: Int): Int =\\n    if (main < 5) main * 10\\n    else 50 + (if (other > 0) distanceTraveled(main - 4, other - 1) else distanceTraveled(main - 5, 0))\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3767088,
                "title": "short-10-liner-java",
                "content": "# Complexity\\n- Time complexity:O(n) Beats : 100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) Beats : 97%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank<5)\\n        return mainTank*10;\\n        else\\n        {\\n            int max=0;\\n            while(mainTank>4 && additionalTank>0)\\n            {\\n                max+=50;\\n                mainTank-=4;\\n                additionalTank--;\\n            }\\n            max+=mainTank*10;\\n            return max;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank<5)\\n        return mainTank*10;\\n        else\\n        {\\n            int max=0;\\n            while(mainTank>4 && additionalTank>0)\\n            {\\n                max+=50;\\n                mainTank-=4;\\n                additionalTank--;\\n            }\\n            max+=mainTank*10;\\n            return max;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766059,
                "title": "o-n-java-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if (mainTank < 5) {\\n            return mainTank * 10;\\n        }\\n        int distance = 0;\\n        int count = 0;\\n        while (mainTank != 0) {\\n            distance = distance + 10;\\n            count++;\\n            mainTank--;\\n            if (count == 5 && additionalTank > 0) {\\n                mainTank++;\\n                additionalTank--;\\n                count = 0;\\n            }\\n        }\\n        return distance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if (mainTank < 5) {\\n            return mainTank * 10;\\n        }\\n        int distance = 0;\\n        int count = 0;\\n        while (mainTank != 0) {\\n            distance = distance + 10;\\n            count++;\\n            mainTank--;\\n            if (count == 5 && additionalTank > 0) {\\n                mainTank++;\\n                additionalTank--;\\n                count = 0;\\n            }\\n        }\\n        return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764369,
                "title": "simple-solution-in-java-using-a-while-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n    \\n        int distanceTravelled = 0;\\n        while (mainTank>0){\\n\\n        if (mainTank>=5){\\n            distanceTravelled += 50;\\n            if (additionalTank>=1){\\n                mainTank -= 4;\\n                additionalTank--;\\n\\n            }\\n            else {\\n                mainTank -= 5;\\n            }\\n        }\\n\\n        else {\\n            distanceTravelled += mainTank*10;\\n            break;\\n        }\\n        }\\n\\n        \\n        return distanceTravelled; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n    \\n        int distanceTravelled = 0;\\n        while (mainTank>0){\\n\\n        if (mainTank>=5){\\n            distanceTravelled += 50;\\n            if (additionalTank>=1){\\n                mainTank -= 4;\\n                additionalTank--;\\n\\n            }\\n            else {\\n                mainTank -= 5;\\n            }\\n        }\\n\\n        else {\\n            distanceTravelled += mainTank*10;\\n            break;\\n        }\\n        }\\n\\n        \\n        return distanceTravelled; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761487,
                "title": "simple-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        current_gas = mainTank\\n        for i in range(mainTank):\\n            if additionalTank >= 1 and current_gas >= 5:\\n                mainTank += 1\\n                additionalTank -= 1\\n                current_gas -= 4\\n            else:\\n                break\\n        return (mainTank * 10)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        current_gas = mainTank\\n        for i in range(mainTank):\\n            if additionalTank >= 1 and current_gas >= 5:\\n                mainTank += 1\\n                additionalTank -= 1\\n                current_gas -= 4\\n            else:\\n                break\\n        return (mainTank * 10)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755511,
                "title": "longest-approcsh-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int y=mainTank/5;\\n        if (additionalTank>y){\\n        y=(mainTank+y+4)/5;}\\n        int ans=0;\\n        for(int i=0;i<=y;i++){\\n             int x=mainTank/5;\\n        if(x==0){\\n            ans=ans+mainTank*10;\\n            return ans;\\n        }      \\n        else {\\n            if(additionalTank>0){\\n            ans=ans+50;\\n            mainTank=mainTank-4;\\n            additionalTank--;}\\n            else{\\n                 ans=ans+mainTank*10;\\n            mainTank=0;\\n            }\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int y=mainTank/5;\\n        if (additionalTank>y){\\n        y=(mainTank+y+4)/5;}\\n        int ans=0;\\n        for(int i=0;i<=y;i++){\\n             int x=mainTank/5;\\n        if(x==0){\\n            ans=ans+mainTank*10;\\n            return ans;\\n        }      \\n        else {\\n            if(additionalTank>0){\\n            ans=ans+50;\\n            mainTank=mainTank-4;\\n            additionalTank--;}\\n            else{\\n                 ans=ans+mainTank*10;\\n            mainTank=0;\\n            }\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754756,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n\\n        if(mainTank<5){\\n            return mainTank*10;\\n        }\\n      \\n        int count = 0;\\n        while(mainTank >= 5&&additionalTank>0){\\n    \\n\\n            count++; \\n            mainTank-=4;\\n            additionalTank--;\\n\\n        }\\n\\n        \\n        return (count*5+mainTank)*10;\\n            \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n\\n        if(mainTank<5){\\n            return mainTank*10;\\n        }\\n      \\n        int count = 0;\\n        while(mainTank >= 5&&additionalTank>0){\\n    \\n\\n            count++; \\n            mainTank-=4;\\n            additionalTank--;\\n\\n        }\\n\\n        \\n        return (count*5+mainTank)*10;\\n            \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753723,
                "title": "c-beats-91-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) \\n    {\\n        int count=0;\\n        while(mainTank)\\n        {\\n            if(mainTank-5>=0)\\n            {\\n                mainTank-=5;\\n                count+=5;\\n                if(additionalTank>=1)\\n                {\\n                    additionalTank--;\\n                    mainTank++;\\n                }\\n               \\n            }\\n            else\\n            {\\n                count +=mainTank;\\n                mainTank=0;\\n            }\\n        }\\n        return count*10;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) \\n    {\\n        int count=0;\\n        while(mainTank)\\n        {\\n            if(mainTank-5>=0)\\n            {\\n                mainTank-=5;\\n                count+=5;\\n                if(additionalTank>=1)\\n                {\\n                    additionalTank--;\\n                    mainTank++;\\n                }\\n               \\n            }\\n            else\\n            {\\n                count +=mainTank;\\n                mainTank=0;\\n            }\\n        }\\n        return count*10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753238,
                "title": "4-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int maintank, int xtank) {\\n        int ans =0;\\n        while(xtank>0 && (maintank/5)>0){\\n            ans+=50;\\n            xtank--;\\n            maintank-=4;\\n        }\\n        if(xtank == 0 ||(maintank/5)==0 ){ans +=maintank*10;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int maintank, int xtank) {\\n        int ans =0;\\n        while(xtank>0 && (maintank/5)>0){\\n            ans+=50;\\n            xtank--;\\n            maintank-=4;\\n        }\\n        if(xtank == 0 ||(maintank/5)==0 ){ans +=maintank*10;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750798,
                "title": "very-effective-and-easy-to-understand",
                "content": "# Intuition\\nsubtracting the fuel consumption for each 5-unit distance, and adding the remaining fuel in the main tank. The result is then multiplied by 10 to obtain the distance in a consistent unit.\\n\\n\\n\\n# Approach\\n\\nIf the additional tank is empty (has a value of 0), the function returns the distance that can be traveled using only the main tank. This is calculated by multiplying the value of mainTank by 10.\\n\\nIf the additional tank has fuel, the function enters a while loop. The loop continues as long as there is fuel remaining in the main tank (mainTank > 0).\\n\\nWithin the loop, the function checks if there is enough fuel in both the main tank and the additional tank to cover a distance of 5 units. If there is enough fuel, it subtracts 4 units from the main tank, decrements the additional tank by 1, and adds 5 units to the variable t, which keeps track of the total time traveled.\\n\\nIf there is not enough fuel in either the main tank or the additional tank to cover a distance of 5 units, the function adds the remaining fuel in the main tank to the variable t and sets the main tank to 0, indicating that it is empty.\\n\\nAfter the while loop ends, the function returns the total time traveled (t) multiplied by 10, representing the total distance traveled.\\n\\n\\n# Complexity\\n- Time complexity: O(mainTank / 4)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction distanceTraveled(mainTank: number, additionalTank: number): number {\\n    if (additionalTank === 0) return mainTank * 10\\n    let t = 0;\\n    while (mainTank > 0) {\\n        if (mainTank - 5 >= 0 && additionalTank > 0) {\\n            t += 5;    \\n            mainTank -= 4;\\n            additionalTank--;\\n        } else {\\n            t += mainTank;\\n            mainTank = 0;\\n        }\\n    }\\n    return t * 10;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction distanceTraveled(mainTank: number, additionalTank: number): number {\\n    if (additionalTank === 0) return mainTank * 10\\n    let t = 0;\\n    while (mainTank > 0) {\\n        if (mainTank - 5 >= 0 && additionalTank > 0) {\\n            t += 5;    \\n            mainTank -= 4;\\n            additionalTank--;\\n        } else {\\n            t += mainTank;\\n            mainTank = 0;\\n        }\\n    }\\n    return t * 10;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749109,
                "title": "beginner-friendly-soln-ez-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n      int cnt=0;\\n      int ans=0;\\n      for(int i=mainTank;i>0;i--)\\n      {\\n        cnt++;\\n        if(cnt==5 &&additionalTank>0 )\\n        {\\n         // mainTank+=1;\\n          additionalTank-=1;\\n          cnt=0;\\n          i++;\\n        }\\n         mainTank-=1;\\n         ans+=10;\\n\\n      }\\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n      int cnt=0;\\n      int ans=0;\\n      for(int i=mainTank;i>0;i--)\\n      {\\n        cnt++;\\n        if(cnt==5 &&additionalTank>0 )\\n        {\\n         // mainTank+=1;\\n          additionalTank-=1;\\n          cnt=0;\\n          i++;\\n        }\\n         mainTank-=1;\\n         ans+=10;\\n\\n      }\\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748245,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int dis = 0;\\n        while(mainTank){\\n            if(mainTank > 4){\\n                mainTank-=5;\\n                dis+=50;\\n                if(additionalTank > 0){\\n                    mainTank+=1;\\n                    additionalTank--;\\n                }\\n            }\\n            else{\\n                dis+=(mainTank*10);\\n                mainTank=0;\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int dis = 0;\\n        while(mainTank){\\n            if(mainTank > 4){\\n                mainTank-=5;\\n                dis+=50;\\n                if(additionalTank > 0){\\n                    mainTank+=1;\\n                    additionalTank--;\\n                }\\n            }\\n            else{\\n                dis+=(mainTank*10);\\n                mainTank=0;\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747401,
                "title": "simple-solution-using-while-loop",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        if mainTank < 5:\\n            return mainTank * 10\\n        result = 0\\n        while mainTank >= 5:\\n            result += 50\\n            mainTank -= 5\\n            if additionalTank:\\n                mainTank += 1\\n                additionalTank -= 1\\n        return result + mainTank*10\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        if mainTank < 5:\\n            return mainTank * 10\\n        result = 0\\n        while mainTank >= 5:\\n            result += 50\\n            mainTank -= 5\\n            if additionalTank:\\n                mainTank += 1\\n                additionalTank -= 1\\n        return result + mainTank*10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745424,
                "title": "simple-solution-simple-to-understand-beats-95",
                "content": "\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int m, int a) {\\n      int sum=0;\\n      while(m>=5&&a)\\n      {\\n        sum+=50;\\n        m-=5;\\n        a--;\\n        m+=1;\\n      }  \\n      sum+=m*10;\\n      return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int m, int a) {\\n      int sum=0;\\n      while(m>=5&&a)\\n      {\\n        sum+=50;\\n        m-=5;\\n        a--;\\n        m+=1;\\n      }  \\n      sum+=m*10;\\n      return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744047,
                "title": "c-simple-and-clean-code-simple-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0; //total distance travelled\\n        int litreConsumed = 0; //how many litres consumed from main tank\\n        while(mainTank){\\n            distance += 10;\\n            mainTank--;\\n            litreConsumed++;\\n            if(litreConsumed == 5 && additionalTank > 0){\\n                additionalTank--;\\n                mainTank++;\\n                litreConsumed = 0;\\n            }\\n        }\\n        return distance; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0; //total distance travelled\\n        int litreConsumed = 0; //how many litres consumed from main tank\\n        while(mainTank){\\n            distance += 10;\\n            mainTank--;\\n            litreConsumed++;\\n            if(litreConsumed == 5 && additionalTank > 0){\\n                additionalTank--;\\n                mainTank++;\\n                litreConsumed = 0;\\n            }\\n        }\\n        return distance; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741707,
                "title": "distance-traveled",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint distanceTraveled(int x, int y){\\n     if(x<5) return x*10;\\n     int ans=0;\\n     while(x/5>=1 && y>0){\\n         x=x-5;\\n         ans+=50;\\n         x+=1;\\n         y--;\\n         }\\n         if(x)\\n         {\\n             ans+=x*10;\\n         }\\n         return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint distanceTraveled(int x, int y){\\n     if(x<5) return x*10;\\n     int ans=0;\\n     while(x/5>=1 && y>0){\\n         x=x-5;\\n         ans+=50;\\n         x+=1;\\n         y--;\\n         }\\n         if(x)\\n         {\\n             ans+=x*10;\\n         }\\n         return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738447,
                "title": "recursion-solution-c",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio();\\n        cin.tie(NULL);\\n    }\\n\\n    int calculateDistance(int mainFuel, int additionalFuel) {\\n        if (mainFuel >= 5) {\\n            int distance = 50 + calculateDistance(mainFuel - 5 + (additionalFuel > 0 ? 1 : 0), additionalFuel - 1);\\n            return distance;\\n        } else {\\n            return mainFuel * 10;\\n        }\\n    }\\n\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        return calculateDistance(mainTank, additionalTank);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio();\\n        cin.tie(NULL);\\n    }\\n\\n    int calculateDistance(int mainFuel, int additionalFuel) {\\n        if (mainFuel >= 5) {\\n            int distance = 50 + calculateDistance(mainFuel - 5 + (additionalFuel > 0 ? 1 : 0), additionalFuel - 1);\\n            return distance;\\n        } else {\\n            return mainFuel * 10;\\n        }\\n    }\\n\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        return calculateDistance(mainTank, additionalTank);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736589,
                "title": "easy-to-understand-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int count=0;\\n        for(int i=0;i<mainTank;i++){\\n            count++;\\n            if(count%5==0&&additionalTank !=0 ){\\n                count++;\\n                additionalTank--;\\n            }\\n        }\\n        return count*10;\\n     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int count=0;\\n        for(int i=0;i<mainTank;i++){\\n            count++;\\n            if(count%5==0&&additionalTank !=0 ){\\n                count++;\\n                additionalTank--;\\n            }\\n        }\\n        return count*10;\\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732444,
                "title": "simple-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc distanceTraveled(mainTank int, additionalTank int) int {\\n    spent := 0\\n\\n    for mainTank >= 5 {\\n        mainTank -= 5\\n        spent += 5\\n        if additionalTank != 0 {\\n            additionalTank--\\n            mainTank++\\n        }\\n    }\\n\\n    return (spent + mainTank) * 10\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distanceTraveled(mainTank int, additionalTank int) int {\\n    spent := 0\\n\\n    for mainTank >= 5 {\\n        mainTank -= 5\\n        spent += 5\\n        if additionalTank != 0 {\\n            additionalTank--\\n            mainTank++\\n        }\\n    }\\n\\n    return (spent + mainTank) * 10\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732443,
                "title": "simple-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc distanceTraveled(mainTank int, additionalTank int) int {\\n    spent := 0\\n\\n    for mainTank >= 5 {\\n        mainTank -= 5\\n        spent += 5\\n        if additionalTank != 0 {\\n            additionalTank--\\n            mainTank++\\n        }\\n    }\\n\\n    return (spent + mainTank) * 10\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distanceTraveled(mainTank int, additionalTank int) int {\\n    spent := 0\\n\\n    for mainTank >= 5 {\\n        mainTank -= 5\\n        spent += 5\\n        if additionalTank != 0 {\\n            additionalTank--\\n            mainTank++\\n        }\\n    }\\n\\n    return (spent + mainTank) * 10\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3730604,
                "title": "c-simple-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n                O(n), where n is the litters in the the mainTank\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n                O(1)\\n# Code\\n```\\npublic class Solution {\\n    public int DistanceTraveled(int mainTank, int additionalTank) {\\n        int dist = 0; \\n        while(mainTank >= 5)\\n        {\\n            dist += 10*5;\\n            mainTank -= 5;\\n            if(additionalTank > 0)\\n            {\\n                mainTank += 1;\\n                additionalTank--;\\n            }\\n        }\\n\\n        dist += 10*mainTank;\\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int DistanceTraveled(int mainTank, int additionalTank) {\\n        int dist = 0; \\n        while(mainTank >= 5)\\n        {\\n            dist += 10*5;\\n            mainTank -= 5;\\n            if(additionalTank > 0)\\n            {\\n                mainTank += 1;\\n                additionalTank--;\\n            }\\n        }\\n\\n        dist += 10*mainTank;\\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728516,
                "title": "c-easy-to-understand-straight-forward-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0; //total distance travelled\\n        int litreConsumed = 0; //how many litres consumed from main tank\\n        while(mainTank){\\n            distance += 10;\\n            mainTank--;\\n            litreConsumed++;\\n            if(litreConsumed == 5 && additionalTank > 0){\\n                additionalTank--;\\n                mainTank++;\\n                litreConsumed = 0;\\n            }\\n        }\\n        return distance;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int distance = 0; //total distance travelled\\n        int litreConsumed = 0; //how many litres consumed from main tank\\n        while(mainTank){\\n            distance += 10;\\n            mainTank--;\\n            litreConsumed++;\\n            if(litreConsumed == 5 && additionalTank > 0){\\n                additionalTank--;\\n                mainTank++;\\n                litreConsumed = 0;\\n            }\\n        }\\n        return distance;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727072,
                "title": "c-easy-solution-o-n",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n    \\n              int out = 0;\\n        \\n        while(mainTank>=5 && additionalTank>=1){\\n            out += (5*10);\\n            mainTank -= 4;\\n            additionalTank--;\\n        }\\n\\n        out += (mainTank*10);\\n        return out;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n    \\n              int out = 0;\\n        \\n        while(mainTank>=5 && additionalTank>=1){\\n            out += (5*10);\\n            mainTank -= 4;\\n            additionalTank--;\\n        }\\n\\n        out += (mainTank*10);\\n        return out;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722545,
                "title": "simple-o-1-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int res = 0;\\n        if(mainTank >= 5) {\\n            if((mainTank / 4) <= additionalTank) {\\n                res = mainTank / 4;\\n                if(mainTank % 4 == 0) res -= 1;\\n            } else {\\n                res = additionalTank;\\n            }\\n        }\\n        return ((mainTank * 10) + (res * 10));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int res = 0;\\n        if(mainTank >= 5) {\\n            if((mainTank / 4) <= additionalTank) {\\n                res = mainTank / 4;\\n                if(mainTank % 4 == 0) res -= 1;\\n            } else {\\n                res = additionalTank;\\n            }\\n        }\\n        return ((mainTank * 10) + (res * 10));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719832,
                "title": "python-o-log-n-solution",
                "content": "# Intuition\\nUsing loop to refill the tank every 5km run\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def distanceTraveled(self, mainTank, additionalTank):\\n        \"\"\"\\n        :type mainTank: int\\n        :type additionalTank: int\\n        :rtype: int\\n        \"\"\"\\n        spare = mainTank%5\\n        left = mainTank\\n        result = 0\\n        \\n        while left > 4 and additionalTank > 0:\\n            times = min(left//5,additionalTank)\\n            spare = left-times*5\\n            \\n            result += times*5*10\\n            \\n            additionalTank = additionalTank-times\\n            left = spare+times\\n        \\n        result += left*10\\n            \\n            \\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def distanceTraveled(self, mainTank, additionalTank):\\n        \"\"\"\\n        :type mainTank: int\\n        :type additionalTank: int\\n        :rtype: int\\n        \"\"\"\\n        spare = mainTank%5\\n        left = mainTank\\n        result = 0\\n        \\n        while left > 4 and additionalTank > 0:\\n            times = min(left//5,additionalTank)\\n            spare = left-times*5\\n            \\n            result += times*5*10\\n            \\n            additionalTank = additionalTank-times\\n            left = spare+times\\n        \\n        result += left*10\\n            \\n            \\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718716,
                "title": "brute-force-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int count=0;\\n        int dist=0;\\n        while(mainTank>0)\\n        {\\n            count++;\\n            dist += 10;\\n            mainTank--;\\n            if(count==5)\\n            {\\n                if(additionalTank>=1)\\n                {\\n                    mainTank++;\\n                    additionalTank = additionalTank -1;\\n                }\\n                count=0;\\n            }\\n        }\\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int count=0;\\n        int dist=0;\\n        while(mainTank>0)\\n        {\\n            count++;\\n            dist += 10;\\n            mainTank--;\\n            if(count==5)\\n            {\\n                if(additionalTank>=1)\\n                {\\n                    mainTank++;\\n                    additionalTank = additionalTank -1;\\n                }\\n                count=0;\\n            }\\n        }\\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718632,
                "title": "not-bad-short-crisp-easy-one",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int m, int a) {\\n        int d=0;\\n        while(m>=5&&a>0)\\n        {\\n                d+=50;\\n                m=m-5;\\n                m+=1;\\n                a--;\\n        }\\n        d+=m*10;\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int m, int a) {\\n        int d=0;\\n        while(m>=5&&a>0)\\n        {\\n                d+=50;\\n                m=m-5;\\n                m+=1;\\n                a--;\\n        }\\n        d+=m*10;\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716997,
                "title": "easy-c-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mt, int at) {\\n        int ans=0;\\n        for(int i=1;i<=mt;i++){\\n            if(at!=0 && i%5==0){\\n                at-=1;\\n                mt+=1;\\n            }\\n            ans+=10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mt, int at) {\\n        int ans=0;\\n        for(int i=1;i<=mt;i++){\\n            if(at!=0 && i%5==0){\\n                at-=1;\\n                mt+=1;\\n            }\\n            ans+=10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712278,
                "title": "simple-solution",
                "content": "# Code\\n```\\nobject Solution {\\n  def distanceTraveled(mainTank: Int, additionalTank: Int): Int = {\\n    eval(0, mainTank, additionalTank) { case (d, m, a) =>\\n      if (m < 5 || a == 0) Right(d + m * 10)\\n      else Left(d + 50, m - 4, a - 1)\\n    }\\n  }\\n\\n  def eval[A, B](init: A)(f: A => Either[A, B]): B = \\n   LazyList.unfold(Option(init)) { \\n     _.flatMap(f(_).fold(\\n       x => Option(None -> Some(x)), \\n       x => Option(Some(x) -> None)\\n     ))\\n   }.flatten.head\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def distanceTraveled(mainTank: Int, additionalTank: Int): Int = {\\n    eval(0, mainTank, additionalTank) { case (d, m, a) =>\\n      if (m < 5 || a == 0) Right(d + m * 10)\\n      else Left(d + 50, m - 4, a - 1)\\n    }\\n  }\\n\\n  def eval[A, B](init: A)(f: A => Either[A, B]): B = \\n   LazyList.unfold(Option(init)) { \\n     _.flatMap(f(_).fold(\\n       x => Option(None -> Some(x)), \\n       x => Option(Some(x) -> None)\\n     ))\\n   }.flatten.head\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3711756,
                "title": "python-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        distance = 0\\n        count =0\\n        while(mainTank):\\n            distance +=10\\n            count+=1\\n            mainTank-=1\\n            if(count==5 and additionalTank>0):\\n                mainTank+=1\\n                additionalTank-=1\\n                count =0\\n            \\n        return distance\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        distance = 0\\n        count =0\\n        while(mainTank):\\n            distance +=10\\n            count+=1\\n            mainTank-=1\\n            if(count==5 and additionalTank>0):\\n                mainTank+=1\\n                additionalTank-=1\\n                count =0\\n            \\n        return distance\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711388,
                "title": "no-intuition-just-solution-look-at-it-easiest-way-to-make",
                "content": "\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n      return (mainTank + Math.min((mainTank - 1) / 4, additionalTank)) * 10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n      return (mainTank + Math.min((mainTank - 1) / 4, additionalTank)) * 10;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3710249,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n      int distance = 0;\\n      int initialmainTank = mainTank;\\n\\t  \\twhile (additionalTank >= 0 && mainTank >= 1) {\\n\\t\\t\\t   distance = distance +10;\\n\\t\\t     mainTank = mainTank - 1;\\n\\t\\t   \\tif (mainTank == initialmainTank - 5 && additionalTank >0 ) {\\n\\t\\t\\t\\t  additionalTank = additionalTank - 1;\\n\\t\\t\\t\\t  mainTank = mainTank + 1;\\n\\t\\t\\t\\t  initialmainTank = mainTank;\\n\\t\\t\\t  }\\n\\t  \\t}\\n\\t  \\treturn distance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n      int distance = 0;\\n      int initialmainTank = mainTank;\\n\\t  \\twhile (additionalTank >= 0 && mainTank >= 1) {\\n\\t\\t\\t   distance = distance +10;\\n\\t\\t     mainTank = mainTank - 1;\\n\\t\\t   \\tif (mainTank == initialmainTank - 5 && additionalTank >0 ) {\\n\\t\\t\\t\\t  additionalTank = additionalTank - 1;\\n\\t\\t\\t\\t  mainTank = mainTank + 1;\\n\\t\\t\\t\\t  initialmainTank = mainTank;\\n\\t\\t\\t  }\\n\\t  \\t}\\n\\t  \\treturn distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706582,
                "title": "inequalities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        return(mainTank+Math.min((mainTank-1)/4,additionalTank))*10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        return(mainTank+Math.min((mainTank-1)/4,additionalTank))*10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704570,
                "title": "no-explainatation-needed-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int used = 0;\\n        int ans = 0;\\n        while(mainTank>0){\\n            mainTank--;\\n            ans+=10;\\n            used++;\\n            if(used==5 && additionalTank>0){\\n                used=0;\\n                mainTank++;\\n                additionalTank--;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int used = 0;\\n        int ans = 0;\\n        while(mainTank>0){\\n            mainTank--;\\n            ans+=10;\\n            used++;\\n            if(used==5 && additionalTank>0){\\n                used=0;\\n                mainTank++;\\n                additionalTank--;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701275,
                "title": "c-very-simple",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int s=0, c=0;\\n        while(mainTank>0){\\n            s += 10;\\n            --mainTank;\\n            ++c;\\n            if(c%5==0 && additionalTank>0){\\n                --additionalTank;\\n                ++mainTank;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int s=0, c=0;\\n        while(mainTank>0){\\n            s += 10;\\n            --mainTank;\\n            ++c;\\n            if(c%5==0 && additionalTank>0){\\n                --additionalTank;\\n                ++mainTank;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701106,
                "title": "easiest-c-code-with-a-trick-without-recurssion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to get the maximum distance travelled . This is possible in case of maximum utilization of fuel. This can be done by help of additional tank.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use additional tank only when we use up 5L of fuel from main tank so we will use only chunks of 5L of fuel. For Ever 5L fuel we will use up 1 extra L of fuel from additional tank by transfering it to main tank. \\n> **Trick** here is to use the additional tank to its fullest and that can be done by seeing if main tank has fuel in multiples of 5 we can use basic maths to calculate that but here we will see the iterative approach in which we are just simulating the stated process.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe will run the process till our main tank fuel is exhausted . So Time complexity is O(N). \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are **not** using **any extra space** so space complexity will be **O(1)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n       int dis= 0;\\n\\n    while (mainTank >=5) {\\n        mainTank-=5;\\n        dis+=5*10;\\n        if (additionalTank >=1) {\\n            mainTank++;\\n            additionalTank--;\\n        }\\n\\n    }\\n        int x=mainTank*10;\\n        \\n\\n    return dis+x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Design",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n       int dis= 0;\\n\\n    while (mainTank >=5) {\\n        mainTank-=5;\\n        dis+=5*10;\\n        if (additionalTank >=1) {\\n            mainTank++;\\n            additionalTank--;\\n        }\\n\\n    }\\n        int x=mainTank*10;\\n        \\n\\n    return dis+x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698628,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int DistanceTraveled(int mainTank, int additionalTank) {\\n        var sum = 0;\\n        while(mainTank >= 5){\\n            mainTank -= 5;\\n            sum += 5 * 10;\\n            if(additionalTank >= 1){\\n                additionalTank--;\\n                mainTank++;\\n            }          \\n        }\\n        sum += mainTank * 10;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int DistanceTraveled(int mainTank, int additionalTank) {\\n        var sum = 0;\\n        while(mainTank >= 5){\\n            mainTank -= 5;\\n            sum += 5 * 10;\\n            if(additionalTank >= 1){\\n                additionalTank--;\\n                mainTank++;\\n            }          \\n        }\\n        sum += mainTank * 10;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698431,
                "title": "simple-solution-chill-as-a-bill",
                "content": "# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        if mainTank < 5:\\n            return mainTank * 10\\n\\n        total_traveled = 0\\n        while mainTank:\\n            leg = min(mainTank, 5)\\n            total_traveled += (leg * 10)\\n            mainTank -= leg\\n            if leg == 5 and additionalTank:\\n                mainTank += 1\\n                additionalTank -= 1\\n\\n        return total_traveled\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        if mainTank < 5:\\n            return mainTank * 10\\n\\n        total_traveled = 0\\n        while mainTank:\\n            leg = min(mainTank, 5)\\n            total_traveled += (leg * 10)\\n            mainTank -= leg\\n            if leg == 5 and additionalTank:\\n                mainTank += 1\\n                additionalTank -= 1\\n\\n        return total_traveled\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697454,
                "title": "java-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank < 5) return mainTank * 10;\\n        \\n        int totalFuel = 0;\\n        while(mainTank > 0) {\\n            if(mainTank >= 5 && additionalTank >= 1) {\\n                totalFuel += 5;\\n                mainTank += 1;\\n                mainTank -= 5;\\n                additionalTank -= 1;\\n            } else {\\n                int temp = mainTank;\\n                totalFuel += temp;\\n                mainTank -= temp;\\n            }\\n        }\\n        \\n        return totalFuel * 10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        if(mainTank < 5) return mainTank * 10;\\n        \\n        int totalFuel = 0;\\n        while(mainTank > 0) {\\n            if(mainTank >= 5 && additionalTank >= 1) {\\n                totalFuel += 5;\\n                mainTank += 1;\\n                mainTank -= 5;\\n                additionalTank -= 1;\\n            } else {\\n                int temp = mainTank;\\n                totalFuel += temp;\\n                mainTank -= temp;\\n            }\\n        }\\n        \\n        return totalFuel * 10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696887,
                "title": "100-beating-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n          return (mainTank + Math.min((mainTank - 1) / 4, additionalTank)) * 10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n          return (mainTank + Math.min((mainTank - 1) / 4, additionalTank)) * 10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695904,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ct = 0;\\n        int i = 1;\\n        while(i<=mainTank)\\n        {\\n            if(additionalTank!=0 && i%5==0)\\n            {\\n                additionalTank--;\\n                mainTank++;\\n            }\\n            ct+=10;\\n            i++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distanceTraveled(int mainTank, int additionalTank) {\\n        int ct = 0;\\n        int i = 1;\\n        while(i<=mainTank)\\n        {\\n            if(additionalTank!=0 && i%5==0)\\n            {\\n                additionalTank--;\\n                mainTank++;\\n            }\\n            ct+=10;\\n            i++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695116,
                "title": "java-easy-solution-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int result=0;\\n        while(mainTank>=5)\\n        {\\n            result=result+(10*5);\\n            mainTank=(mainTank-5);\\n            if(additionalTank!=0)\\n            {\\n            mainTank=mainTank+1;\\n            additionalTank--;\\n            }\\n            else{\\n                break;\\n            }\\n            \\n        }\\n        result=result+(mainTank*10);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int result=0;\\n        while(mainTank>=5)\\n        {\\n            result=result+(10*5);\\n            mainTank=(mainTank-5);\\n            if(additionalTank!=0)\\n            {\\n            mainTank=mainTank+1;\\n            additionalTank--;\\n            }\\n            else{\\n                break;\\n            }\\n            \\n        }\\n        result=result+(mainTank*10);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695011,
                "title": "java-solution-with-while",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int mainF = 0;\\n        int fcounter = 0;\\n        if (mainTank < 5) {\\n            //System.out.println(\"Executed 1\");\\n            mainF = mainTank * 10;\\n        } else {\\n            while (mainTank > 0) {\\n                System.out.println(\"mainTank1: \" + mainTank);\\n                mainTank = mainTank - 1;\\n                mainF = mainF + 10;\\n                fcounter = fcounter + 1;\\n                if (fcounter == 5 && additionalTank >= 1) {\\n                    mainTank = mainTank + 1;\\n                    additionalTank = additionalTank - 1;\\n                    fcounter = 0;\\n                    System.out.println(\"mainTank2: \" + mainTank);\\n                    System.out.println(\"additionalTank: \" + additionalTank);\\n                }\\n            } \\n        }\\n        return mainF;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int mainF = 0;\\n        int fcounter = 0;\\n        if (mainTank < 5) {\\n            //System.out.println(\"Executed 1\");\\n            mainF = mainTank * 10;\\n        } else {\\n            while (mainTank > 0) {\\n                System.out.println(\"mainTank1: \" + mainTank);\\n                mainTank = mainTank - 1;\\n                mainF = mainF + 10;\\n                fcounter = fcounter + 1;\\n                if (fcounter == 5 && additionalTank >= 1) {\\n                    mainTank = mainTank + 1;\\n                    additionalTank = additionalTank - 1;\\n                    fcounter = 0;\\n                    System.out.println(\"mainTank2: \" + mainTank);\\n                    System.out.println(\"additionalTank: \" + additionalTank);\\n                }\\n            } \\n        }\\n        return mainF;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1939718,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1935020,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1934433,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 2015430,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1945444,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1935171,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1961631,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1949284,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1944188,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 2033103,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1939718,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1935020,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1934433,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 2015430,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1945444,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1935171,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1961631,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1949284,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 1944188,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            },
            {
                "id": 2033103,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "Question says : Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed the why the hell is this \\nmainTank =\\n9\\nadditionalTank =\\n2\\nUse Testcase\\nOutput\\n100\\nExpected\\n110"
                    },
                    {
                        "username": "McAzz",
                        "content": "The truck will use fuel until 4 liters are left (+ 50 km), then the main tank recieves 1 liter (5 liters in main tank now) it goes for another 50 km (100 km now) recieves another liter because it used another 5 liters and runs for another 10km. So the solution they provided is right, it does run for 110km for that case."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once the tank use 5 from main tank he will be able to use 1 from additional tank\\nNow  the one 1 he used from additional tank plus 4 remaining in main Tank add up to 5 So he will  able to  use 1 from additional tank \\nSo in this way he will be using total of 11 liter so it is 110"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Weird truck"
                    },
                    {
                        "username": "AdrianParry",
                        "content": "Yes, why not just remove the additional tanks and make it the second main tank as well."
                    },
                    {
                        "username": "Msey",
                        "content": "it\\'s not easy at all"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "For me, it is easy."
                    },
                    {
                        "username": "whocares1",
                        "content": "[@thesaiki](/thesaiki) The constant time solution contains a complicated edge case. I doubt you implemented it yourself."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just brute force, the size is just 100"
                    },
                    {
                        "username": "Applethal",
                        "content": "Having the same issue as the others with the input (9,2), using the exercise\\'s logic, I do not think that the output should be 110."
                    },
                    {
                        "username": "Sanyam36",
                        "content": "I don\\'t know why but i find Medium questions more easy then the easy question having acceptance rate below 40%. And this is one of them. At first look, i found it very simple but when i checked test cases, i realized this is not easy at all."
                    },
                    {
                        "username": "alex2266",
                        "content": "should be marked v easy"
                    },
                    {
                        "username": "Dextro9",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": "In the case of inputs mainTank = 9 and additionalTank = 2, after 5 liters of fuel cosumption from the mainTank we add 1 liter of fuel from the additionalTank to mainTank, so we don\\'t add fuel again since mainTank is no more containing 5 liters (9 - 5 = 4 liters). So how could the output be 110?? Please someone explain... "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "1 liter is added after consuming 5 intially and now 1+ 4 will become 5 liter again in main tank so once it will be used one more will be added so this way answer is 110"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Fuel is not typically a currency, therefore not typically \\'spent\\'. Can we amend to \\'consumed\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) It is difficult to ignore as it make the question rather confusing to understand."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "MAY Be the problem statement is given by truck driver.So ignore grammatical and symentic mistakes"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "How I approached the problem and got the solution.\\n\\nNote: This may not be the optimal solution, but it works for me.\\n\\nInitialize distance variable with 0.\\nThen while the mainTank > 5, add 50 to distance and if additionalTank > 0, then subtract 4 from mainTank and 1 from additionalTank. Else subtract 5 from mainTank. Finally outside the while loop, do distance += mainTank * 10. Then return distance, this is working for me. Feel free to more optimize it to get better solution."
                    },
                    {
                        "username": "RAKSHITH_SP",
                        "content": "I think the problem is too easy. Took me less than a min. But the examples are not helpful. I only understood after reading a very good example -->\\nmainTank = 9,\\nadditionalTank = 2,\\nTestcase Output = 100,\\nExpected = 110\\nby [@Ujjawal_OP](/ujjawal_OP)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Robot Collisions",
        "question_content": "<p>There are <code>n</code> <strong>1-indexed</strong> robots, each having a position on a line, health, and movement direction.</p>\n\n<p>You are given <strong>0-indexed</strong> integer arrays <code>positions</code>, <code>healths</code>, and a string <code>directions</code> (<code>directions[i]</code> is either <strong>&#39;L&#39;</strong> for <strong>left</strong> or <strong>&#39;R&#39;</strong> for <strong>right</strong>). All integers in <code>positions</code> are <strong>unique</strong>.</p>\n\n<p>All robots start moving on the line<strong> simultaneously</strong> at the <strong>same speed </strong>in their given directions. If two robots ever share the same position while moving, they will <strong>collide</strong>.</p>\n\n<p>If two robots collide, the robot with <strong>lower health</strong> is <strong>removed</strong> from the line, and the health of the other robot <strong>decreases</strong> <strong>by one</strong>. The surviving robot continues in the <strong>same</strong> direction it was going. If both robots have the <strong>same</strong> health, they are both<strong> </strong>removed from the line.</p>\n\n<p>Your task is to determine the <strong>health</strong> of the robots that survive the collisions, in the same <strong>order </strong>that the robots were given,<strong> </strong>i.e. final heath of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.</p>\n\n<p>Return <em>an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.</em></p>\n\n<p><strong>Note:</strong> The positions may be unsorted.</p>\n\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img height=\"169\" src=\"https://assets.leetcode.com/uploads/2023/05/15/image-20230516011718-12.png\" width=\"808\" /></p>\n\n<pre>\n<strong>Input:</strong> positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = &quot;RRRRR&quot;\n<strong>Output:</strong> [2,17,9,15,10]\n<strong>Explanation:</strong> No collision occurs in this example, since all robots are moving in the same direction. So, the health of the robots in order from the first robot is returned, [2, 17, 9, 15, 10].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img height=\"176\" src=\"https://assets.leetcode.com/uploads/2023/05/15/image-20230516004433-7.png\" width=\"717\" /></p>\n\n<pre>\n<strong>Input:</strong> positions = [3,5,2,6], healths = [10,10,15,12], directions = &quot;RLRL&quot;\n<strong>Output:</strong> [14]\n<strong>Explanation:</strong> There are 2 collisions in this example. Firstly, robot 1 and robot 2 will collide, and since both have the same health, they will be removed from the line. Next, robot 3 and robot 4 will collide and since robot 4&#39;s health is smaller, it gets removed, and robot 3&#39;s health becomes 15 - 1 = 14. Only robot 3 remains, so we return [14].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><img height=\"172\" src=\"https://assets.leetcode.com/uploads/2023/05/15/image-20230516005114-9.png\" width=\"732\" /></p>\n\n<pre>\n<strong>Input:</strong> positions = [1,2,5,6], healths = [10,10,11,11], directions = &quot;RLRL&quot;\n<strong>Output:</strong> []\n<strong>Explanation:</strong> Robot 1 and robot 2 will collide and since both have the same health, they are both removed. Robot 3 and 4 will collide and since both have the same health, they are both removed. So, we return an empty array, [].</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positions.length == healths.length == directions.length == n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= positions[i], healths[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>directions[i] == &#39;L&#39;</code> or <code>directions[i] == &#39;R&#39;</code></li>\n\t<li>All values in <code>positions</code> are distinct</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3679414,
                "title": "c-detailed-approach-using-stack-sorting",
                "content": "\\n# Approach\\n\\nInside the function, a struct named Robot is defined, which has four members: position, health, direction, and index. This struct represents the properties of a robot.\\n\\nThe function begins by initializing a vector of Robot structs called vals. Each struct is created using the corresponding elements from the input vectors, and the index is set to the current index in the loop. This vector is then sorted based on the position of the robots using a lambda function.\\n\\nNext, another vector of Robot structs called stack is initialized. The function iterates over each robot in the sorted vals vector. If the robot\\'s direction is \\'R\\' (right), it is simply pushed onto the stack.\\n\\nFor robots with direction other than \\'R\\', the function checks if they can eliminate any robots on the stack. It continues popping robots from the stack as long as the top robot\\'s health is less than or equal to the current robot\\'s health and its direction is \\'R\\'. If the health of the top robot is equal to the current robot\\'s health, that robot is also popped and marked as gone. Otherwise, the health of the current robot is decreased and the top robot on the stack is popped. If no elimination occurs, the current robot is pushed onto the stack.\\n\\nAfter processing all robots, the stack is sorted based on the original indices of the robots using another lambda function.\\n\\nFinally, the health values of the robots in the stack are extracted and stored in a vector called result, which is then returned as the output of the function.\\n# Complexity \\n- Time : O(n logn)\\n- space : O(n)\\n\\n# C++ Code\\n![image.png](https://assets.leetcode.com/users/images/1c1fb0db-ef1c-412e-83b7-c1cf4ceca6b2_1688387689.2878623.png)\\n\\n```\\nclass Solution {\\npublic:\\n\\n    struct Robot {\\n        int position;\\n        int health;\\n        char direction;\\n        int index;\\n    };\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string& directions) {\\n        int n = positions.size();\\n        vector<Robot> vals;\\n        for (int i = 0; i < n; i++) {\\n            vals.push_back({positions[i], healths[i], directions[i], i});\\n        }\\n        sort(vals.begin(), vals.end(), [](const Robot& a, const Robot& b) {\\n            return a.position < b.position;\\n        });\\n\\n        vector<Robot> stack;\\n        for (auto& robot : vals) {\\n            if (robot.direction == \\'R\\') {\\n                stack.push_back(robot);\\n                continue;\\n            }\\n\\n            // Check if the robot should be eliminated\\n            bool gone = false;\\n\\n            // Process the stack to eliminate robots with lower health\\n            while (!stack.empty() && stack.back().health <= robot.health && stack.back().direction == \\'R\\') {\\n                if (stack.back().health == robot.health) {\\n                    stack.pop_back();\\n                    gone = true;\\n                    break;\\n                }\\n                robot.health--;\\n                stack.pop_back();\\n            }\\n\\n            // If the robot is not yet eliminated and there is a robot facing right with higher health\\n            if (!gone && !stack.empty() && stack.back().direction == \\'R\\' && stack.back().health > robot.health) {\\n                stack.back().health--;\\n                gone = true;\\n            }\\n\\n            // If the robot is not eliminated, add it to the stack\\n            if (!gone) {\\n                stack.push_back(robot);\\n            }\\n        }\\n\\n        sort(stack.begin(), stack.end(), [](const Robot& a, const Robot& b) {\\n            return a.index < b.index;\\n        });\\n\\n        vector<int> result;\\n        for (const auto& robot : stack) {\\n            result.push_back(robot.health);\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    struct Robot {\\n        int position;\\n        int health;\\n        char direction;\\n        int index;\\n    };\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string& directions) {\\n        int n = positions.size();\\n        vector<Robot> vals;\\n        for (int i = 0; i < n; i++) {\\n            vals.push_back({positions[i], healths[i], directions[i], i});\\n        }\\n        sort(vals.begin(), vals.end(), [](const Robot& a, const Robot& b) {\\n            return a.position < b.position;\\n        });\\n\\n        vector<Robot> stack;\\n        for (auto& robot : vals) {\\n            if (robot.direction == \\'R\\') {\\n                stack.push_back(robot);\\n                continue;\\n            }\\n\\n            // Check if the robot should be eliminated\\n            bool gone = false;\\n\\n            // Process the stack to eliminate robots with lower health\\n            while (!stack.empty() && stack.back().health <= robot.health && stack.back().direction == \\'R\\') {\\n                if (stack.back().health == robot.health) {\\n                    stack.pop_back();\\n                    gone = true;\\n                    break;\\n                }\\n                robot.health--;\\n                stack.pop_back();\\n            }\\n\\n            // If the robot is not yet eliminated and there is a robot facing right with higher health\\n            if (!gone && !stack.empty() && stack.back().direction == \\'R\\' && stack.back().health > robot.health) {\\n                stack.back().health--;\\n                gone = true;\\n            }\\n\\n            // If the robot is not eliminated, add it to the stack\\n            if (!gone) {\\n                stack.push_back(robot);\\n            }\\n        }\\n\\n        sort(stack.begin(), stack.end(), [](const Robot& a, const Robot& b) {\\n            return a.index < b.index;\\n        });\\n\\n        vector<int> result;\\n        for (const auto& robot : stack) {\\n            result.push_back(robot.health);\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679168,
                "title": "java-c-python-stack-soluton",
                "content": "# **Explanation**\\nNeed to sort all robots index `ind` (from `0` to `n - 1`),\\nsort them by their `positions` first.\\n\\nUse a `stack` to keep all the robot moving to right.\\nNow we iterate robots one by one,\\n\\nIf it\\'s moving to right,\\nwon\\'t collide with robots in the `stack`.\\n\\nIf it\\'s moving to left,\\ncompare its `healths[i]` with the top robot in `stack`.\\n\\nFinally we return the robot with positive `healths[i]`.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] h, String directions) {\\n        int n = positions.length;\\n        List<Integer> ind = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            ind.add(i);\\n        }\\n        ind.sort((a, b) -> Integer.compare(positions[a], positions[b]));\\n\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i : ind) {\\n            if (directions.charAt(i) == \\'R\\') {\\n                stack.push(i);\\n                continue;\\n            }\\n            while (!stack.isEmpty() && h[i] > 0) {\\n                if (h[stack.peek()] < h[i]) {\\n                    h[stack.pop()] = 0;\\n                    h[i] -= 1;\\n                } else if (h[stack.peek()] > h[i]) {\\n                    h[stack.peek()] -= 1;\\n                    h[i] = 0;\\n                } else {\\n                    h[stack.pop()] = 0;\\n                    h[i] = 0;\\n                }\\n            }\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int v : h) {\\n            if (v > 0) {\\n                res.add(v);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& h, string directions) {\\n        int n = positions.size();\\n        vector<int> ind(n), stack, res;\\n        for (int i = 0; i < n; i++)\\n            ind[i] = i;\\n        sort(ind.begin(), ind.end(), [&](int a, int b) {\\n            return positions[a] < positions[b];\\n        });\\n        for (int i : ind) {\\n            if (directions[i] == \\'R\\') {\\n                stack.push_back(i);\\n                continue;\\n            }\\n            while (!stack.empty() && h[i] > 0) {\\n                if (h[stack.back()] < h[i]) {\\n                    h[stack.back()] = 0, stack.pop_back();\\n                    h[i] -= 1;\\n                } else if (h[stack.back()] > h[i]) {\\n                    h[stack.back()] -= 1;\\n                    h[i] = 0;\\n                } else {\\n                    h[stack.back()] = 0, stack.pop_back();\\n                    h[i] = 0;\\n                }\\n            }\\n        }\\n        for (int v : h) {\\n            if (v > 0) {\\n                res.push_back(v);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def survivedRobotsHealths(self, positions: List[int], h: List[int], directions: str) -> List[int]:\\n        n = len(positions)\\n        ind = sorted(range(n), key=positions.__getitem__)\\n        stack = []\\n        for i in ind:\\n            if directions[i] == \\'R\\':\\n                stack.append(i)\\n                continue\\n            while stack and h[i] > 0:\\n                if h[stack[-1]] < h[i]:\\n                    h[stack.pop()] = 0\\n                    h[i] -= 1\\n                elif h[stack[-1]] > h[i]:\\n                    h[stack[-1]] -= 1\\n                    h[i] = 0\\n                else:\\n                    h[stack.pop()] = 0\\n                    h[i] = 0\\n        return [v for v in h if v > 0]\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] h, String directions) {\\n        int n = positions.length;\\n        List<Integer> ind = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            ind.add(i);\\n        }\\n        ind.sort((a, b) -> Integer.compare(positions[a], positions[b]));\\n\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i : ind) {\\n            if (directions.charAt(i) == \\'R\\') {\\n                stack.push(i);\\n                continue;\\n            }\\n            while (!stack.isEmpty() && h[i] > 0) {\\n                if (h[stack.peek()] < h[i]) {\\n                    h[stack.pop()] = 0;\\n                    h[i] -= 1;\\n                } else if (h[stack.peek()] > h[i]) {\\n                    h[stack.peek()] -= 1;\\n                    h[i] = 0;\\n                } else {\\n                    h[stack.pop()] = 0;\\n                    h[i] = 0;\\n                }\\n            }\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int v : h) {\\n            if (v > 0) {\\n                res.add(v);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& h, string directions) {\\n        int n = positions.size();\\n        vector<int> ind(n), stack, res;\\n        for (int i = 0; i < n; i++)\\n            ind[i] = i;\\n        sort(ind.begin(), ind.end(), [&](int a, int b) {\\n            return positions[a] < positions[b];\\n        });\\n        for (int i : ind) {\\n            if (directions[i] == \\'R\\') {\\n                stack.push_back(i);\\n                continue;\\n            }\\n            while (!stack.empty() && h[i] > 0) {\\n                if (h[stack.back()] < h[i]) {\\n                    h[stack.back()] = 0, stack.pop_back();\\n                    h[i] -= 1;\\n                } else if (h[stack.back()] > h[i]) {\\n                    h[stack.back()] -= 1;\\n                    h[i] = 0;\\n                } else {\\n                    h[stack.back()] = 0, stack.pop_back();\\n                    h[i] = 0;\\n                }\\n            }\\n        }\\n        for (int v : h) {\\n            if (v > 0) {\\n                res.push_back(v);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def survivedRobotsHealths(self, positions: List[int], h: List[int], directions: str) -> List[int]:\\n        n = len(positions)\\n        ind = sorted(range(n), key=positions.__getitem__)\\n        stack = []\\n        for i in ind:\\n            if directions[i] == \\'R\\':\\n                stack.append(i)\\n                continue\\n            while stack and h[i] > 0:\\n                if h[stack[-1]] < h[i]:\\n                    h[stack.pop()] = 0\\n                    h[i] -= 1\\n                elif h[stack[-1]] > h[i]:\\n                    h[stack[-1]] -= 1\\n                    h[i] = 0\\n                else:\\n                    h[stack.pop()] = 0\\n                    h[i] = 0\\n        return [v for v in h if v > 0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3679112,
                "title": "cpp-sorting-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially I did not thought that positions are not sorted hence got 1 wa.\\nThen sorted according to postions and used stack to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If a robot is going to left and your stack is empty that means their is no robot to stop your current robot.\\n- If your robot is going towards right just push in your stack.\\n- If your robot is moving towards left and your stack is non empty.\\n    1. if the health of current robot is equal to the robot which is coming from its left i.e towards right then make health of both robots to 0.\\n    2. if the health of current robot is lesser to the robot which is coming from its left i.e towards right then make health of current robot to 0 and push the previous robot back in the stack and decrease it\\'s health with 1.\\n    3. if the health of current robot is greater to the robot which is coming from its left i.e towards right then make health of prev robot to 0 and decrease health of curr robot with 1 and continue with more prev robots if there.\\n\\n# Complexity\\n- Time complexity: `O(nlogn)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void performOperations(vector<int> &h,stack<int> &st,int i) {\\n        while(!st.empty()) {\\n            int top = st.top();\\n            st.pop();\\n            if(h[top] > h[i]) {\\n                h[top] -= 1;\\n                h[i] = 0;\\n                st.push(top);\\n                return ;\\n            } else if(h[top] == h[i]) {\\n                h[i] = 0, h[top] = 0;\\n                return ;\\n            }\\n            else {\\n                h[i] -= 1;\\n                h[top] = 0;\\n            }\\n        }\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& v, vector<int>& h, string s) {\\n        stack<int> st;\\n        int n = v.size();\\n        vector<int> idx(n);\\n        for(int i = 0; i < n; i += 1) idx[i] = i;\\n        sort(idx.begin(),idx.end(),[&](int i, int j) {\\n           return v[i] < v[j]; \\n        });\\n        for(int j = 0; j < n; j += 1) {\\n            int i = idx[j];\\n            if(s[i] == \\'L\\' && st.empty()) continue;\\n            else if(s[i] == \\'R\\') st.push(i);\\n            else {\\n                performOperations(h, st, i);\\n            }\\n        }\\n        vector<int> ans;\\n        for(int x : h) {\\n            if(x) ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void performOperations(vector<int> &h,stack<int> &st,int i) {\\n        while(!st.empty()) {\\n            int top = st.top();\\n            st.pop();\\n            if(h[top] > h[i]) {\\n                h[top] -= 1;\\n                h[i] = 0;\\n                st.push(top);\\n                return ;\\n            } else if(h[top] == h[i]) {\\n                h[i] = 0, h[top] = 0;\\n                return ;\\n            }\\n            else {\\n                h[i] -= 1;\\n                h[top] = 0;\\n            }\\n        }\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& v, vector<int>& h, string s) {\\n        stack<int> st;\\n        int n = v.size();\\n        vector<int> idx(n);\\n        for(int i = 0; i < n; i += 1) idx[i] = i;\\n        sort(idx.begin(),idx.end(),[&](int i, int j) {\\n           return v[i] < v[j]; \\n        });\\n        for(int j = 0; j < n; j += 1) {\\n            int i = idx[j];\\n            if(s[i] == \\'L\\' && st.empty()) continue;\\n            else if(s[i] == \\'R\\') st.push(i);\\n            else {\\n                performOperations(h, st, i);\\n            }\\n        }\\n        vector<int> ans;\\n        for(int x : h) {\\n            if(x) ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681151,
                "title": "solution-using-stack-in-c-java-python",
                "content": "# Intuition\\nSort the robot by positions. Scan all robots from left to right. The key point is that all robots are moving with the same speed, so if they move to the same direction they will never collide. And if they move to the different position, say a robot is moving to the left, then it collide with the ones moving to the right in order (based on the positions of the robots that are moving to the left, the rightmost one on its left collides first).\\n\\n# Approach\\nScan all the robots from left to right one by one.\\n(1) If it\\'s moving to the right, we just push it to the stack for future use.\\n(2) If it\\'s moving to the left, then we pop robots from the stack one by one. Processing the collisions until the current robot disappears or the stack is empty.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) because of sorting.\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        const int n = positions.size();\\n        vector<int> ind(n);\\n        for (int i = 0; i < n; ++i) {\\n            ind[i] = i;\\n        }\\n        sort(ind.begin(), ind.end(), [&](const int x, const int y) {\\n            return positions[x] < positions[y];\\n        });\\n        stack<int> s;\\n        for (int x : ind) {\\n            if (directions[x] == \\'L\\') {\\n                while (!s.empty()) {\\n                    const int y = s.top();\\n                    if (healths[x] == healths[y]) {\\n                        healths[x] = healths[y] = 0;\\n                        s.pop();\\n                        break;\\n                    }\\n                    if (healths[x] > healths[y]) {\\n                        --healths[x];\\n                        healths[y] = 0;\\n                        s.pop();\\n                    } else {\\n                        healths[x] = 0;\\n                        --healths[y];\\n                        break;\\n                    }\\n                }  \\n            } else {\\n                s.push(x);\\n            }\\n        }\\n        vector<int> r;\\n        for (int x : healths) {\\n            if (x) {\\n                r.push_back(x);\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\nJava:\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        List<Integer> ind = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            ind.add(i);\\n        }\\n        Collections.sort(ind, (x, y) -> Integer.compare(positions[x], positions[y]));\\n        Stack<Integer> s = new Stack<>();\\n        for (int x : ind) {\\n            if (directions.charAt(x) == \\'L\\') {\\n                while (!s.empty()) {\\n                    int y = s.peek();\\n                    if (healths[x] == healths[y]) {\\n                        healths[x] = 0;\\n                        healths[y] = 0;\\n                        s.pop();\\n                        break;\\n                    }\\n                    if (healths[x] > healths[y]) {\\n                        healths[x]--;\\n                        healths[y] = 0;\\n                        s.pop();\\n                    } else {\\n                        healths[x] = 0;\\n                        healths[y]--;\\n                        break;\\n                    }\\n                }  \\n            } else {\\n                s.push(x);\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for (int x : healths) {\\n            if (x != 0) {\\n                result.add(x);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\nPython\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        n = len(positions)\\n        ind = [i for i in range(n)]\\n        ind.sort(key=lambda x: positions[x])\\n        s = []\\n        for x in ind:\\n            if directions[x] == \\'L\\':\\n                while s:\\n                    y = s[-1]\\n                    if healths[x] == healths[y]:\\n                        healths[x] = healths[y] = 0\\n                        s.pop()\\n                        break\\n                    if healths[x] > healths[y]:\\n                        healths[x] -= 1\\n                        healths[y] = 0\\n                        s.pop()\\n                    else:\\n                        healths[x] = 0\\n                        healths[y] -= 1\\n                        break\\n            else:\\n                s.append(x)\\n        r = [x for x in healths if x]\\n        return r\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        const int n = positions.size();\\n        vector<int> ind(n);\\n        for (int i = 0; i < n; ++i) {\\n            ind[i] = i;\\n        }\\n        sort(ind.begin(), ind.end(), [&](const int x, const int y) {\\n            return positions[x] < positions[y];\\n        });\\n        stack<int> s;\\n        for (int x : ind) {\\n            if (directions[x] == \\'L\\') {\\n                while (!s.empty()) {\\n                    const int y = s.top();\\n                    if (healths[x] == healths[y]) {\\n                        healths[x] = healths[y] = 0;\\n                        s.pop();\\n                        break;\\n                    }\\n                    if (healths[x] > healths[y]) {\\n                        --healths[x];\\n                        healths[y] = 0;\\n                        s.pop();\\n                    } else {\\n                        healths[x] = 0;\\n                        --healths[y];\\n                        break;\\n                    }\\n                }  \\n            } else {\\n                s.push(x);\\n            }\\n        }\\n        vector<int> r;\\n        for (int x : healths) {\\n            if (x) {\\n                r.push_back(x);\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        List<Integer> ind = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            ind.add(i);\\n        }\\n        Collections.sort(ind, (x, y) -> Integer.compare(positions[x], positions[y]));\\n        Stack<Integer> s = new Stack<>();\\n        for (int x : ind) {\\n            if (directions.charAt(x) == \\'L\\') {\\n                while (!s.empty()) {\\n                    int y = s.peek();\\n                    if (healths[x] == healths[y]) {\\n                        healths[x] = 0;\\n                        healths[y] = 0;\\n                        s.pop();\\n                        break;\\n                    }\\n                    if (healths[x] > healths[y]) {\\n                        healths[x]--;\\n                        healths[y] = 0;\\n                        s.pop();\\n                    } else {\\n                        healths[x] = 0;\\n                        healths[y]--;\\n                        break;\\n                    }\\n                }  \\n            } else {\\n                s.push(x);\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for (int x : healths) {\\n            if (x != 0) {\\n                result.add(x);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        n = len(positions)\\n        ind = [i for i in range(n)]\\n        ind.sort(key=lambda x: positions[x])\\n        s = []\\n        for x in ind:\\n            if directions[x] == \\'L\\':\\n                while s:\\n                    y = s[-1]\\n                    if healths[x] == healths[y]:\\n                        healths[x] = healths[y] = 0\\n                        s.pop()\\n                        break\\n                    if healths[x] > healths[y]:\\n                        healths[x] -= 1\\n                        healths[y] = 0\\n                        s.pop()\\n                    else:\\n                        healths[x] = 0\\n                        healths[y] -= 1\\n                        break\\n            else:\\n                s.append(x)\\n        r = [x for x in healths if x]\\n        return r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679189,
                "title": "c-java-python-with-visuals-stack-sorting-asteroid-collision",
                "content": "This problem has been asked in Atlassian OA for Intern 2023.\\nVery similar to [735. Asteroid Collision\\n](https://leetcode.com/problems/asteroid-collision/)\\n\\n# Intuition\\nAssume we sort robots by their initial positions. Then, we traverse robots from left to right positions.\\n\\nLet\\'s try few cases\\n- First robot goes left: nothing happens, it keeps going on left. This robot can never collide anyone as this is the leftmost robot going left.\\n```\\n    R1\\n   <--\\n```\\n- Second robot also goes left: nothing happens, it keeps going on.\\n```\\n    R1    R2\\n   <--   <--\\n```\\n- Every robot going left will not collide with anyone and will proceed towards $-\\\\infty$.\\n- Third robot goes right: no collision happens (until now)\\n```\\n    R1    R2    R3\\n   <--   <--    -->\\n```\\n- Fourth robot goes left: now the collision will take place. (Atleast one of them will lose). There are 3 cases:\\n```\\n    R1    R2    R3    R4\\n   <--   <--    -->  <--\\n```\\n  1. `R3 > R4`: `R3` wins and `R4` loses. `R3` keeps going right with health -1.\\n```\\n    R1    R2    R3\\n   <--   <--    -->\\n```\\n  2. `R3 = R4`: Both lose.\\n```\\n    R1    R2\\n   <--   <--\\n```\\n  3. `R3 < R4`: `R3` loses and `R4` wins. `R4` keeps going left upto $-\\\\infty$ with health -1.\\n```\\n    R1    R2    R4\\n   <--   <--   <--\\n```\\n\\n---\\n\\nIn general case, there will be some robots going left upto $-\\\\infty$. We don\\'t consider them anymore as they are not going to collide with anyone in future. Then there will be some robots going right. These might collide with someone coming from left in future.\\n```\\n    R1    R2    R3  ...  R(x)    R(x+1)    R(x+2)  ...  R(y)    R(curr)\\n   <--   <--   <--      <--      -->       -->          -->     <--\\n```\\n\\n`R(curr)` i.e., our current robot, will collide with robots `R(y)` to `R(x+1)` or some of them.\\n```\\n    R1    R2    R3  ...  R(x)  [  R(x+1)    R(x+2)  ...  R(y)  ]  R(curr)\\n   <--   <--   <--      <--    [  -->       -->          -->   ]  <--\\n```\\n- `R(curr)` will win from every robot with lesser health.\\n- But it will lose from the robot which is going right with bigger health.\\n- Or it might encounter a same health robot where both will lose.\\n- Or it might win from every robot which was going right (`R(y)` to `R(x+1)`), and then `R(curr)` continues its journey towards $-\\\\infty$.\\n\\nThis gives the intuition of using stack to simulate robots that are available to us until now (or the robots that are not lost until now).\\n\\n# Approach\\n- Sort the robots by their initial position. Traverse from left to right maintaing stack of available robots. Topmost element of stack will represent rightmost robot.\\n- If the current robot is going right, no collision happens and robot is added to stack.\\n- If the current robot is going left, collisions will start happening with every robot in stack which is going right.\\n- Pop the robots that lose while decreasing health of current robot.\\n  - We might get a robot going right with equal health. Both of them loses.\\n  - We might get a robot going right with greater health. It wins and its health decreases. Current robot loses.\\n  - Or current robot might win from every robot which was going right.\\n- At last, we will have the robots that are not lost. Sort them by their initial index and return.\\n\\n# Code\\n```C++ []\\nclass Robot {\\npublic:\\n    int position, health, index;\\n    char direction;\\n\\n    Robot(int position = 0, int health = 0, char direction = 0, int index = 0)\\n    : position(position), health(health), direction(direction), index(index) {}\\n};\\n\\nclass Solution {\\nprivate:\\n    void makeCollisions(stack<Robot>& s, Robot& robot) {\\n        // current robot will collide with every robot in stack that is going right\\n        while (!s.empty() && s.top().direction == \\'R\\' && s.top().health < robot.health) {\\n            // current robot wins\\n            s.pop();\\n            robot.health--;\\n        }\\n        if (!s.empty() && s.top().direction == \\'R\\') { // current robot loses\\n            if (s.top().health == robot.health) {\\n                // last collision was with a robot of same health, both removed\\n                s.pop();\\n            } else {\\n                // last collision was with a robot of bigger health, it wins\\n                s.top().health--;\\n            }\\n        } else {\\n            // current robot wins from every robot going right\\n            // it continues going left towards -infinity\\n            s.push(robot);\\n        }\\n    }\\n\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string& directions) {\\n        int n = positions.size();\\n        vector<Robot> robots(n);\\n        for (int i = 0; i < n; i++) {\\n            robots[i] = Robot(positions[i], healths[i], directions[i], i);\\n        }\\n        // sort by initial position\\n        sort(robots.begin(), robots.end(), \\n            [](Robot& r1, Robot& r2) { return r1.position < r2.position; });\\n        stack<Robot> s;\\n        for (Robot& robot: robots) {\\n            if (robot.direction == \\'R\\') { // going right\\n                s.push(robot);\\n            } else { // going left\\n                makeCollisions(s, robot);\\n            }\\n        }\\n        robots.clear();\\n        while (!s.empty()) {\\n            robots.push_back(s.top());\\n            s.pop();\\n        }\\n        // sort by initial index\\n        sort(robots.begin(), robots.end(),\\n            [](Robot& r1, Robot& r2) { return r1.index < r2.index; });\\n        vector<int> result;\\n        for (auto& robot: robots) {\\n            result.push_back(robot.health);\\n        }\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Robot {\\n    public int position, health, index;\\n    public char direction;\\n\\n    public Robot(int position, int health, char direction, int index) {\\n        this.position = position;\\n        this.health = health;\\n        this.direction = direction;\\n        this.index = index;\\n    }\\n}\\n\\nclass Solution {\\n    Stack<Robot> s;\\n\\n    private void makeCollisions(Robot robot) {\\n        // current robot will collide with every robot in stack that is going right\\n        while (!s.isEmpty() && s.peek().direction == \\'R\\' && s.peek().health < robot.health) {\\n            // current robot wins\\n            s.pop();\\n            robot.health--;\\n        }\\n        if (!s.isEmpty() && s.peek().direction == \\'R\\') { // current robot loses\\n            if (s.peek().health == robot.health) {\\n                // last collision was with a robot of same health, both removed\\n                s.pop();\\n            } else {\\n                // last collision was with a robot of bigger health, it wins\\n                s.peek().health--;\\n            }\\n        } else {\\n            // current robot wins from every robot going right\\n            // it continues going left towards -infinity\\n            s.push(robot);\\n        }\\n    }\\n\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        List<Robot> robots = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            robots.add(new Robot(positions[i], healths[i], directions.charAt(i), i));\\n        }\\n        // sort by initial position\\n        Collections.sort(robots, (r1, r2) -> r1.position - r2.position);\\n        s = new Stack<>();\\n        for (Robot robot : robots) {\\n            if (robot.direction == \\'R\\') { // going right\\n                s.push(robot);\\n            } else { // going left\\n                makeCollisions(robot);\\n            }\\n        }\\n        robots.clear();\\n        while (!s.isEmpty()) {\\n            robots.add(s.pop());\\n        }\\n        // sort by initial index\\n        Collections.sort(robots, (r1, r2) -> r1.index - r2.index);\\n        List<Integer> result = new ArrayList<>();\\n        for (Robot robot : robots) {\\n            result.add(robot.health);\\n        }\\n        return result;\\n    }\\n}\\n```\\n```Python []\\nclass Robot:\\n    def __init__(self, position: int, health: int, direction: str, index: int):\\n        self.position = position\\n        self.health = health\\n        self.direction = direction\\n        self.index = index\\n    \\nclass Solution:\\n    def makeCollisions(self, s: List[Robot], robot: Robot):\\n        # current robot will collide with every robot in stack that is going right\\n        while s and s[-1].direction == \\'R\\' and s[-1].health < robot.health:\\n            # current robot wins\\n            s.pop()\\n            robot.health -= 1\\n        if s and s[-1].direction == \\'R\\': # current robot loses\\n            if s[-1].health == robot.health:\\n                # last collision was with a robot of same health, both removed\\n                s.pop()\\n            else:\\n                # last collision was with a robot of bigger health, it wins\\n                s[-1].health -= 1\\n        else:\\n            # current robot wins from every robot going right\\n            # it continues going left towards -infinity\\n            s.append(robot)\\n    \\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        n = len(positions)\\n        robots = [\\n            Robot(pos, health, direction, i)\\n            for i, (pos, health, direction) in enumerate(zip(positions, healths, directions))\\n        ]\\n        # sort by initial position\\n        robots.sort(key=lambda x: x.position)\\n        s = []\\n        for robot in robots:\\n            if robot.direction == \\'R\\': # going right\\n                s.append(robot)\\n            else: # going left\\n                self.makeCollisions(s, robot)\\n        robots = s\\n        # sort by initial index\\n        robots.sort(key=lambda x: x.index)\\n        return [robot.health for robot in robots]\\n```\\n\\n# Complexity\\nSorting time complexity is $O(n \\\\log n)$. Every robot is pushed and popped from the stack atmost once. Therefore, simulating stack\\'s time complexity is $O(n)$.\\n- Time complexity: $O(n \\\\log n)$\\n- Space complexity: $O(n)$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\n    R1\\n   <--\\n```\n```\\n    R1    R2\\n   <--   <--\\n```\n```\\n    R1    R2    R3\\n   <--   <--    -->\\n```\n```\\n    R1    R2    R3    R4\\n   <--   <--    -->  <--\\n```\n```\\n    R1    R2    R3\\n   <--   <--    -->\\n```\n```\\n    R1    R2\\n   <--   <--\\n```\n```\\n    R1    R2    R4\\n   <--   <--   <--\\n```\n```\\n    R1    R2    R3  ...  R(x)    R(x+1)    R(x+2)  ...  R(y)    R(curr)\\n   <--   <--   <--      <--      -->       -->          -->     <--\\n```\n```\\n    R1    R2    R3  ...  R(x)  [  R(x+1)    R(x+2)  ...  R(y)  ]  R(curr)\\n   <--   <--   <--      <--    [  -->       -->          -->   ]  <--\\n```\n```C++ []\\nclass Robot {\\npublic:\\n    int position, health, index;\\n    char direction;\\n\\n    Robot(int position = 0, int health = 0, char direction = 0, int index = 0)\\n    : position(position), health(health), direction(direction), index(index) {}\\n};\\n\\nclass Solution {\\nprivate:\\n    void makeCollisions(stack<Robot>& s, Robot& robot) {\\n        // current robot will collide with every robot in stack that is going right\\n        while (!s.empty() && s.top().direction == \\'R\\' && s.top().health < robot.health) {\\n            // current robot wins\\n            s.pop();\\n            robot.health--;\\n        }\\n        if (!s.empty() && s.top().direction == \\'R\\') { // current robot loses\\n            if (s.top().health == robot.health) {\\n                // last collision was with a robot of same health, both removed\\n                s.pop();\\n            } else {\\n                // last collision was with a robot of bigger health, it wins\\n                s.top().health--;\\n            }\\n        } else {\\n            // current robot wins from every robot going right\\n            // it continues going left towards -infinity\\n            s.push(robot);\\n        }\\n    }\\n\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string& directions) {\\n        int n = positions.size();\\n        vector<Robot> robots(n);\\n        for (int i = 0; i < n; i++) {\\n            robots[i] = Robot(positions[i], healths[i], directions[i], i);\\n        }\\n        // sort by initial position\\n        sort(robots.begin(), robots.end(), \\n            [](Robot& r1, Robot& r2) { return r1.position < r2.position; });\\n        stack<Robot> s;\\n        for (Robot& robot: robots) {\\n            if (robot.direction == \\'R\\') { // going right\\n                s.push(robot);\\n            } else { // going left\\n                makeCollisions(s, robot);\\n            }\\n        }\\n        robots.clear();\\n        while (!s.empty()) {\\n            robots.push_back(s.top());\\n            s.pop();\\n        }\\n        // sort by initial index\\n        sort(robots.begin(), robots.end(),\\n            [](Robot& r1, Robot& r2) { return r1.index < r2.index; });\\n        vector<int> result;\\n        for (auto& robot: robots) {\\n            result.push_back(robot.health);\\n        }\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Robot {\\n    public int position, health, index;\\n    public char direction;\\n\\n    public Robot(int position, int health, char direction, int index) {\\n        this.position = position;\\n        this.health = health;\\n        this.direction = direction;\\n        this.index = index;\\n    }\\n}\\n\\nclass Solution {\\n    Stack<Robot> s;\\n\\n    private void makeCollisions(Robot robot) {\\n        // current robot will collide with every robot in stack that is going right\\n        while (!s.isEmpty() && s.peek().direction == \\'R\\' && s.peek().health < robot.health) {\\n            // current robot wins\\n            s.pop();\\n            robot.health--;\\n        }\\n        if (!s.isEmpty() && s.peek().direction == \\'R\\') { // current robot loses\\n            if (s.peek().health == robot.health) {\\n                // last collision was with a robot of same health, both removed\\n                s.pop();\\n            } else {\\n                // last collision was with a robot of bigger health, it wins\\n                s.peek().health--;\\n            }\\n        } else {\\n            // current robot wins from every robot going right\\n            // it continues going left towards -infinity\\n            s.push(robot);\\n        }\\n    }\\n\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        List<Robot> robots = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            robots.add(new Robot(positions[i], healths[i], directions.charAt(i), i));\\n        }\\n        // sort by initial position\\n        Collections.sort(robots, (r1, r2) -> r1.position - r2.position);\\n        s = new Stack<>();\\n        for (Robot robot : robots) {\\n            if (robot.direction == \\'R\\') { // going right\\n                s.push(robot);\\n            } else { // going left\\n                makeCollisions(robot);\\n            }\\n        }\\n        robots.clear();\\n        while (!s.isEmpty()) {\\n            robots.add(s.pop());\\n        }\\n        // sort by initial index\\n        Collections.sort(robots, (r1, r2) -> r1.index - r2.index);\\n        List<Integer> result = new ArrayList<>();\\n        for (Robot robot : robots) {\\n            result.add(robot.health);\\n        }\\n        return result;\\n    }\\n}\\n```\n```Python []\\nclass Robot:\\n    def __init__(self, position: int, health: int, direction: str, index: int):\\n        self.position = position\\n        self.health = health\\n        self.direction = direction\\n        self.index = index\\n    \\nclass Solution:\\n    def makeCollisions(self, s: List[Robot], robot: Robot):\\n        # current robot will collide with every robot in stack that is going right\\n        while s and s[-1].direction == \\'R\\' and s[-1].health < robot.health:\\n            # current robot wins\\n            s.pop()\\n            robot.health -= 1\\n        if s and s[-1].direction == \\'R\\': # current robot loses\\n            if s[-1].health == robot.health:\\n                # last collision was with a robot of same health, both removed\\n                s.pop()\\n            else:\\n                # last collision was with a robot of bigger health, it wins\\n                s[-1].health -= 1\\n        else:\\n            # current robot wins from every robot going right\\n            # it continues going left towards -infinity\\n            s.append(robot)\\n    \\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        n = len(positions)\\n        robots = [\\n            Robot(pos, health, direction, i)\\n            for i, (pos, health, direction) in enumerate(zip(positions, healths, directions))\\n        ]\\n        # sort by initial position\\n        robots.sort(key=lambda x: x.position)\\n        s = []\\n        for robot in robots:\\n            if robot.direction == \\'R\\': # going right\\n                s.append(robot)\\n            else: # going left\\n                self.makeCollisions(s, robot)\\n        robots = s\\n        # sort by initial index\\n        robots.sort(key=lambda x: x.index)\\n        return [robot.health for robot in robots]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679169,
                "title": "stack",
                "content": "We process robots left-to-right, so we sort them first.\\n\\nIf a robot goes right, we add it to the stack.\\n    \\nIf a robot goes left, we colide it with the robot on top of the stack:\\n- If the health of the robot on top of the stack is lower:\\n\\t- We set its health to zero.\\n\\t- We remove it from the stack and decrement the health of the \"L\"-robot.\\n- Otherwise, we set the health of \"L\"-robot to zero.\\n\\t- And decrement the healt of the robot on top of the stack.\\n\\n**C++**\\n```cpp\\nvector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& healths, string dirs) {\\n    vector<int> ids(pos.size()), st;\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return pos[i] < pos[j]; });\\n    for (int id : ids) {\\n        if (dirs[id] == \\'R\\')\\n            st.push_back(id);\\n        else {\\n            while (!st.empty() && healths[id]) {\\n                if (healths[id] >= healths[st.back()]) {\\n                    healths[id] = healths[id] == healths[st.back()] ? 0 : healths[id] - 1;\\n                    healths[st.back()] = 0;\\n                    st.pop_back();\\n                }\\n                else {\\n                    --healths[st.back()];\\n                    healths[id] = 0;\\n                }\\n            }\\n        }\\n    }\\n    healths.erase(remove(begin(healths), end(healths), 0), end(healths));\\n    return healths;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& healths, string dirs) {\\n    vector<int> ids(pos.size()), st;\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return pos[i] < pos[j]; });\\n    for (int id : ids) {\\n        if (dirs[id] == \\'R\\')\\n            st.push_back(id);\\n        else {\\n            while (!st.empty() && healths[id]) {\\n                if (healths[id] >= healths[st.back()]) {\\n                    healths[id] = healths[id] == healths[st.back()] ? 0 : healths[id] - 1;\\n                    healths[st.back()] = 0;\\n                    st.pop_back();\\n                }\\n                else {\\n                    --healths[st.back()];\\n                    healths[id] = 0;\\n                }\\n            }\\n        }\\n    }\\n    healths.erase(remove(begin(healths), end(healths), 0), end(healths));\\n    return healths;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679132,
                "title": "java-python-3-check-rl-after-sorting-by-positions-w-brief-explanation-and-analysis",
                "content": "1. Sort the indices of `healths` by `positions`;\\n2. Traverse the sorted indices and check if the index on the top of the stack (`survivors`) corresponds to the direction `R` and current direction is `L`, then process according to the problem definition;\\n3. return the health value still in the stack (`survivors`) sorted by their original indices.\\n\\n\\n```java\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = healths.length;\\n        Integer[] sortedIndices = IntStream.range(0, n).boxed().sorted(Comparator.comparingInt(i -> positions[i])).toArray(Integer[]::new);\\n        Deque<Integer> survivors = new ArrayDeque<>();\\n        for (int i : sortedIndices) {\\n            while (!survivors.isEmpty() && survivors.peek() >= 0 && \\n                   directions.charAt(survivors.peek()) == \\'R\\' && directions.charAt(i) == \\'L\\' &&\\n                   healths[survivors.peek()] < healths[i]) {\\n                survivors.pop();\\n                healths[i] -= 1;\\n            }\\n            if (!survivors.isEmpty() && survivors.peek() >= 0 && \\n                   directions.charAt(survivors.peek()) == \\'R\\' && directions.charAt(i) == \\'L\\') {\\n                if (healths[survivors.peek()] == healths[i]) {\\n                    survivors.pop();\\n                }else {\\n                    healths[survivors.peek()] -= 1;\\n                }\\n            }else {\\n                survivors.push(i);\\n            }\\n        }\\n        return survivors.stream().sorted().map(i -> healths[i]).collect(Collectors.toList());\\n    }\\n```\\n\\n```python\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        n = len(healths)\\n        sorted_indices = sorted(range(n), key=lambda i: positions[i])\\n        survivors = []\\n        for i in sorted_indices:\\n            while survivors and directions[survivors[-1]] == \\'R\\' and directions[i] == \\'L\\' and healths[i] > healths[survivors[-1]]:\\n                healths[i] -= 1\\n                survivors.pop()\\n            if survivors and directions[survivors[-1]] == \\'R\\' and directions[i] == \\'L\\':\\n                if healths[i] == healths[survivors[-1]]:\\n                    survivors.pop()\\n                else:\\n                    healths[survivors[-1]] -= 1\\n            else:    \\n                survivors.append(i) \\n        return [healths[i] for i in sorted(survivors)]\\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(n)`, where `n = healths.length`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Stack",
                    "Sorting"
                ],
                "code": "```java\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = healths.length;\\n        Integer[] sortedIndices = IntStream.range(0, n).boxed().sorted(Comparator.comparingInt(i -> positions[i])).toArray(Integer[]::new);\\n        Deque<Integer> survivors = new ArrayDeque<>();\\n        for (int i : sortedIndices) {\\n            while (!survivors.isEmpty() && survivors.peek() >= 0 && \\n                   directions.charAt(survivors.peek()) == \\'R\\' && directions.charAt(i) == \\'L\\' &&\\n                   healths[survivors.peek()] < healths[i]) {\\n                survivors.pop();\\n                healths[i] -= 1;\\n            }\\n            if (!survivors.isEmpty() && survivors.peek() >= 0 && \\n                   directions.charAt(survivors.peek()) == \\'R\\' && directions.charAt(i) == \\'L\\') {\\n                if (healths[survivors.peek()] == healths[i]) {\\n                    survivors.pop();\\n                }else {\\n                    healths[survivors.peek()] -= 1;\\n                }\\n            }else {\\n                survivors.push(i);\\n            }\\n        }\\n        return survivors.stream().sorted().map(i -> healths[i]).collect(Collectors.toList());\\n    }\\n```\n```python\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        n = len(healths)\\n        sorted_indices = sorted(range(n), key=lambda i: positions[i])\\n        survivors = []\\n        for i in sorted_indices:\\n            while survivors and directions[survivors[-1]] == \\'R\\' and directions[i] == \\'L\\' and healths[i] > healths[survivors[-1]]:\\n                healths[i] -= 1\\n                survivors.pop()\\n            if survivors and directions[survivors[-1]] == \\'R\\' and directions[i] == \\'L\\':\\n                if healths[i] == healths[survivors[-1]]:\\n                    survivors.pop()\\n                else:\\n                    healths[survivors[-1]] -= 1\\n            else:    \\n                survivors.append(i) \\n        return [healths[i] for i in sorted(survivors)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3679480,
                "title": "easy-solution-using-sorting-stack-c-beginner-friendly",
                "content": "**Approach:**\\n\\n* If a robot is moving to the left and the stack is empty, it means there is no robot to stop the current robot. Therefore, the current robot survives.\\n* If a robot is moving to the right, simply push it into the stack.\\n* If a robot is moving to the left and the stack is not empty:\\n* Compare the health of the current robot with the top robot in the stack.\\n1. If the current robot has the same health as the top robot, both robots have their health reduced to 0 as they collide.\\n2. If the current robot has lower health, set its health to 0 and push the previous robot back into the stack. Decrease the health of the previous robot by 1.\\n3. If the current robot has higher health, set the health of the previous robot to 0. Decrease the health of the current robot by 1 and continue comparing with more previous robots in the stack if there are any.\\n* After iterating through all the robots, the stack contains the surviving robots in the order they appeared in the input.\\n* Pop the robots from the stack one by one and store their health values in a result array.\\n* Reverse the result array to match the order of the robots in the input.\\n* Return the result array, which contains the health of the surviving robots in the same order they were given.\\nBy following this approach, we can identify the surviving robots and determine their health after the collisions have occurred.\\n\\n\\n**Code:**\\n\\t\\n\\t\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n\\t\\t\\t\\t\\tvector<int> r=p;\\n\\t\\t\\t\\t\\tint n=p.size();\\n\\t\\t\\t\\t\\tvector<tuple<int,int,char>> v;\\n\\t\\t\\t\\t\\tfor(int i=0;i<n;i++) v.push_back({p[i],h[i],d[i]});\\n\\t\\t\\t\\t\\tsort(v.begin(),v.end());\\n\\n\\t\\t\\t\\t\\tstack<pair<int,int>> st;\\n\\t\\t\\t\\t\\tint a,b; char c;\\n\\t\\t\\t\\t\\tvector<pair<int,int>> temp;\\n\\t\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\t\\ttie(a,b,c)=v[i];\\n\\t\\t\\t\\t\\t\\tif(c==\\'R\\')\\n\\t\\t\\t\\t\\t\\t\\tst.push({a,b});\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tif(st.empty()) temp.push_back({a,b});\\n\\t\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\t\\twhile(!st.empty()){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(st.top().second>b){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tst.top().second--;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tb=0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(st.top().second==b){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tb=0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tb--;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tif(b) temp.push_back({a,b});\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\twhile(!st.empty()){\\n\\t\\t\\t\\t\\t\\ttemp.push_back(st.top());\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmap<int,int> m;\\n\\t\\t\\t\\t\\tfor(auto i:temp) m[i.first]=i.second;\\n\\n\\t\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\t\\tif(m[r[i]]) ans.push_back(m[r[i]]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n\\t\\t\\t\\t\\tvector<int> r=p;\\n\\t\\t\\t\\t\\tint n=p.size();\\n\\t\\t\\t\\t\\tvector<tuple<int,int,char>> v;\\n\\t\\t\\t\\t\\tfor(int i=0;i<n;i++) v.push_back({p[i],h[i],d[i]}",
                "codeTag": "Java"
            },
            {
                "id": 3679138,
                "title": "stack-brute-force-sol-with-comments",
                "content": "# Intuition\\n##### Check the condition of collide , if there is collision remove robot with min health \\n\\n\\n---\\n\\n\\n\\n# Approach\\n\\n###### First we arrange  the robots in ascending order of their pos , after that we start from left side and  check the direction of cur robot , now  check the condition of collision , if there is collision then removing robot with min health and storing left moving robots in ans whose survive till end , for right moving store in stack st  \\n\\n- for collision\\n **R --> <--L**\\n- no collision \\n**<--L R-->**\\n**<--L <--L**\\n**R--> R-->**\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN + N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp( pair<int,int>&a,pair<int,int>&b){\\n        return a.first<b.first;\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string d) {\\n        vector<pair<int,int>>v;\\n        int n = pos.size();\\n         \\n        for( int  i = 0; i< n; i++){\\n            v.push_back({pos[i], i});                //storing the position with index\\n        }\\n        sort(v.begin(),v.end(),comp);                //sort acc to pos\\n        stack<int>st;                               // store the index of remaining robot whose surviving till now\\n        vector<int>ans;\\n        \\n        for( int i= 0; i < n; i++){\\n            \\n            int ind =  v[i].second;                 // finding respective index of that pos           \\n            \\n            if( d[ind] ==\\'L\\'){                       // check the dir if it is left \\n                if(st.empty()) ans.push_back(ind);   // if there is nothing to collide for  a particle that moving in left direction so it never collide to anyone  so its health never decrease  , so push into our final ans  \\n                else{\\n                    while( !st.empty() && h[st.top()] <  h[ind]){      // check if anyone going to right dir and with min health with current robot which moving in Left\\n                        st.pop();   //removing right moving robot with min health \\n                        h[ind]--;   //health of cur robot decrease by one\\n                    }\\n                    if( st.empty())ans.push_back(ind);  // if there no right moving robot remain so again push into our final ans \\n                    else{\\n                        if( h[st.top() ] == h[ind])st.pop();   // if left and right moving robot have same health then  remove both robot \\n                        else {\\n                            h[st.top()]--;   //if right moving element having more health than left ,then health of right moving decrease  by one  \\n                             if( h[st.top()]== 0)st.pop();   // if( health of right moving become zero which at the top of stack them removing from stack )\\n                             }\\n                    }\\n                }\\n            }\\n            else {\\n                st.push(ind);  // if cur robot is right moving so it don\\'t collide with previous right moving robots so simply store the index of this one  \\n            }\\n        }\\n        \\n        while( !st.empty()){\\n            ans.push_back(st.top());   // now storing tha index of remaining right moving robot whose survive till the end and present in stack\\n            st.pop();\\n        }\\n        sort( ans.begin(),ans.end());    // acc to question result store in intial given state  \\n        \\n        for( int i =0; i< ans.size(); i++)ans[i] = h[ans[i]];   // now assigning  health of robot with index ans[i] \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n---\\n# Plz upvote !!!",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp( pair<int,int>&a,pair<int,int>&b){\\n        return a.first<b.first;\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string d) {\\n        vector<pair<int,int>>v;\\n        int n = pos.size();\\n         \\n        for( int  i = 0; i< n; i++){\\n            v.push_back({pos[i], i});                //storing the position with index\\n        }\\n        sort(v.begin(),v.end(),comp);                //sort acc to pos\\n        stack<int>st;                               // store the index of remaining robot whose surviving till now\\n        vector<int>ans;\\n        \\n        for( int i= 0; i < n; i++){\\n            \\n            int ind =  v[i].second;                 // finding respective index of that pos           \\n            \\n            if( d[ind] ==\\'L\\'){                       // check the dir if it is left \\n                if(st.empty()) ans.push_back(ind);   // if there is nothing to collide for  a particle that moving in left direction so it never collide to anyone  so its health never decrease  , so push into our final ans  \\n                else{\\n                    while( !st.empty() && h[st.top()] <  h[ind]){      // check if anyone going to right dir and with min health with current robot which moving in Left\\n                        st.pop();   //removing right moving robot with min health \\n                        h[ind]--;   //health of cur robot decrease by one\\n                    }\\n                    if( st.empty())ans.push_back(ind);  // if there no right moving robot remain so again push into our final ans \\n                    else{\\n                        if( h[st.top() ] == h[ind])st.pop();   // if left and right moving robot have same health then  remove both robot \\n                        else {\\n                            h[st.top()]--;   //if right moving element having more health than left ,then health of right moving decrease  by one  \\n                             if( h[st.top()]== 0)st.pop();   // if( health of right moving become zero which at the top of stack them removing from stack )\\n                             }\\n                    }\\n                }\\n            }\\n            else {\\n                st.push(ind);  // if cur robot is right moving so it don\\'t collide with previous right moving robots so simply store the index of this one  \\n            }\\n        }\\n        \\n        while( !st.empty()){\\n            ans.push_back(st.top());   // now storing tha index of remaining right moving robot whose survive till the end and present in stack\\n            st.pop();\\n        }\\n        sort( ans.begin(),ans.end());    // acc to question result store in intial given state  \\n        \\n        for( int i =0; i< ans.size(); i++)ans[i] = h[ans[i]];   // now assigning  health of robot with index ans[i] \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679127,
                "title": "c-for-beginners-sorting-stack-brute-force",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct robot{\\n        int pos, heal, idx;\\n        char dir;\\n    };\\n    \\n    static bool mySort(robot r1, robot r2){\\n        return r1.pos < r2.pos;\\n    }\\n    static bool myComp(robot r1, robot r2){\\n        return r1.idx < r2.idx;\\n    }\\n\\n    \\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<robot> v(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            v[i].pos = positions[i];\\n            v[i].heal = healths[i];\\n            v[i].dir = directions[i];\\n            v[i].idx = i;\\n        }\\n        \\n        sort(v.begin(), v.end(), mySort);\\n        stack<robot> st;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(v[i].dir == \\'R\\')\\n            {\\n                st.push(v[i]);\\n                continue;\\n            }\\n            \\n            while(!st.empty())\\n            {\\n                robot prev = st.top();\\n                if(prev.dir == \\'L\\')\\n                    break;\\n                st.pop();\\n                if(prev.heal < v[i].heal)\\n                    v[i].heal--;\\n                else if(prev.heal > v[i].heal)\\n                {\\n                    prev.heal--;\\n                    st.push(prev);\\n                    v[i].heal = 0;\\n                    break;\\n                }\\n                else\\n                {\\n                    v[i].heal = 0;\\n                    break;\\n                }\\n            }\\n            if(v[i].heal > 0)\\n                st.push(v[i]);\\n\\n            \\n        }\\n        \\n        \\n        vector<robot> temp;\\n        while(!st.empty())\\n            temp.push_back(st.top()), st.pop();\\n    \\n        sort(temp.begin(), temp.end(), myComp);\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < temp.size(); i++)\\n            ans.push_back(temp[i].heal);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct robot{\\n        int pos, heal, idx;\\n        char dir;\\n    };\\n    \\n    static bool mySort(robot r1, robot r2){\\n        return r1.pos < r2.pos;\\n    }\\n    static bool myComp(robot r1, robot r2){\\n        return r1.idx < r2.idx;\\n    }\\n\\n    \\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<robot> v(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            v[i].pos = positions[i];\\n            v[i].heal = healths[i];\\n            v[i].dir = directions[i];\\n            v[i].idx = i;\\n        }\\n        \\n        sort(v.begin(), v.end(), mySort);\\n        stack<robot> st;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(v[i].dir == \\'R\\')\\n            {\\n                st.push(v[i]);\\n                continue;\\n            }\\n            \\n            while(!st.empty())\\n            {\\n                robot prev = st.top();\\n                if(prev.dir == \\'L\\')\\n                    break;\\n                st.pop();\\n                if(prev.heal < v[i].heal)\\n                    v[i].heal--;\\n                else if(prev.heal > v[i].heal)\\n                {\\n                    prev.heal--;\\n                    st.push(prev);\\n                    v[i].heal = 0;\\n                    break;\\n                }\\n                else\\n                {\\n                    v[i].heal = 0;\\n                    break;\\n                }\\n            }\\n            if(v[i].heal > 0)\\n                st.push(v[i]);\\n\\n            \\n        }\\n        \\n        \\n        vector<robot> temp;\\n        while(!st.empty())\\n            temp.push_back(st.top()), st.pop();\\n    \\n        sort(temp.begin(), temp.end(), myComp);\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < temp.size(); i++)\\n            ans.push_back(temp[i].heal);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680314,
                "title": "no-stack-is-this-clean-code",
                "content": "![robo-fight.jpg](https://assets.leetcode.com/users/images/9e66d9c9-0625-4cdf-b957-8d1561a26b34_1687681164.2591827.jpeg)<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Intuition\\n\\nWe put all robots in their positions. Then start from the left (lowest position). We keep moving forward (to the right or higher position), until we can find a fightable pair of robots. But what are fightable robots?\\n\\n# Can you eat popcorn?\\n\\nIf we could find a robot that goes to the left (moves backward), it means that we could successfully find the fightable pair. Is that correct?\\n\\nNope! if the previous robot is also going to the left, or there\\'s no previous robot, then we have to keep moving forward and check the next robot.\\n\\nBut if the previous robot goes to the right, we start eating popcorn and watching the fight.\\n\\n\\n# Approach\\nWe use TreeMap (it\\'s like HashMap, but the keys are sorted).\\nKeys will be the position, and the value will be the Robot object.\\n\\nWe have a variable called `positionGoingLeft` which is used to find the position of the robot that goes to the left.\\nYou can\\'t imagine what `positionGoingRight` is.\\n\\n# Complexity\\n\\n- Time complexity:\\nSince the keys in `treeMap` are sorted, it will take `O(n log n)` to build the `treeMap`.\\nFor each key on the `treeMap` (which is the position for the robots), we check the previous and next one which is `O(log n)`. \\nSo the time complexity will be `O(n log n)`\\n\\n\\n- Space complexity:\\n`O(n)` because we store n objects in the `treeMap`\\n\\n# Very Important Question\\n\\nCan you make the code cleaner than this (please comment) or does this deserve an upvote?\\n\\n# Code\\n```\\nclass Robot {\\n  int index;\\n  int health;\\n  boolean goingLeft;\\n\\n  public Robot(int i, int health, char direction) {\\n    index = i;\\n    this.health = health;\\n    this.goingLeft = direction == \\'L\\';\\n  }\\n}\\n\\nTreeMap<Integer, Robot> treeMap = new TreeMap<>();\\nInteger positionGoingLeft = 0;\\nInteger positionGoingRight = 0;\\n\\npublic List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n  createTreeMap(positions, healths, directions);\\n  findFighters();\\n  return getResult();\\n}\\n\\n  void createTreeMap(int[] positions, int[] healths, String directions) {\\n    for (int i = 0; i < positions.length; i++) {\\n      Robot robot = new Robot(i + 1, healths[i], directions.charAt(i));\\n      treeMap.put(positions[i], robot);\\n    }\\n  }\\n\\n  private void findFighters() {\\n    while (fightableRobotsExist()) {\\n      fight();\\n    }\\n  }\\n\\n    private boolean fightableRobotsExist() {\\n      while (foundRobotGoingLeft()) {\\n        if (previousRobotGoesRight()) {\\n          return true;\\n        }\\n        positionGoingLeft++;\\n      }\\n      return false;\\n    }\\n\\n      private boolean foundRobotGoingLeft() {\\n        positionGoingLeft = treeMap.ceilingKey(positionGoingLeft);\\n        while (positionGoingLeft != null) {\\n          Robot nextRobot = treeMap.get(positionGoingLeft);\\n          if (nextRobot.goingLeft) {\\n            return true;\\n          }\\n          positionGoingLeft = treeMap.higherKey(positionGoingLeft);\\n        }\\n        return false;\\n      }\\n\\n      private boolean previousRobotGoesRight() {\\n        positionGoingRight = treeMap.lowerKey(positionGoingLeft);\\n        if (positionGoingRight == null) {\\n          return false;\\n        }\\n        Robot robotGoingRight = treeMap.get(positionGoingRight);\\n        return !robotGoingRight.goingLeft;\\n      }\\n\\n    private void fight() {\\n      Robot robotGoingLeft = treeMap.get(positionGoingLeft);\\n      Robot robotGoingRight = treeMap.get(positionGoingRight);\\n      if (robotGoingRight.health == robotGoingLeft.health) {\\n        treeMap.remove(positionGoingLeft);\\n        treeMap.remove(positionGoingRight);\\n      } else if (robotGoingRight.health < robotGoingLeft.health) {\\n        treeMap.remove(positionGoingRight);\\n        robotGoingLeft.health--;\\n      } else {\\n        treeMap.remove(positionGoingLeft);\\n        robotGoingRight.health--;\\n      }\\n    }\\n\\n\\n  private List<Integer> getResult() {\\n    PriorityQueue<Robot> robotPriorityQueue = getPriorityQueueSortedByIndex();\\n    return getHealths(robotPriorityQueue);\\n  }\\n\\n    private PriorityQueue<Robot> getPriorityQueueSortedByIndex() {\\n      PriorityQueue<Robot> priorityQueueSortedByOriginalIndex = new PriorityQueue<>\\n            (Comparator.comparingInt(a -> a.index));\\n      for (Map.Entry<Integer, Robot> entry : treeMap.entrySet()) {\\n        priorityQueueSortedByOriginalIndex.add(entry.getValue());\\n      }\\n      return priorityQueueSortedByOriginalIndex;\\n    }\\n  \\n    private List<Integer> getHealths(PriorityQueue<Robot> robotPriorityQueue) {\\n      List<Integer> results = new ArrayList<>();\\n      while (!robotPriorityQueue.isEmpty()) {\\n        Robot r = robotPriorityQueue.remove();\\n        results.add(r.health);\\n      }\\n      return results;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Sorting"
                ],
                "code": "```\\nclass Robot {\\n  int index;\\n  int health;\\n  boolean goingLeft;\\n\\n  public Robot(int i, int health, char direction) {\\n    index = i;\\n    this.health = health;\\n    this.goingLeft = direction == \\'L\\';\\n  }\\n}\\n\\nTreeMap<Integer, Robot> treeMap = new TreeMap<>();\\nInteger positionGoingLeft = 0;\\nInteger positionGoingRight = 0;\\n\\npublic List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n  createTreeMap(positions, healths, directions);\\n  findFighters();\\n  return getResult();\\n}\\n\\n  void createTreeMap(int[] positions, int[] healths, String directions) {\\n    for (int i = 0; i < positions.length; i++) {\\n      Robot robot = new Robot(i + 1, healths[i], directions.charAt(i));\\n      treeMap.put(positions[i], robot);\\n    }\\n  }\\n\\n  private void findFighters() {\\n    while (fightableRobotsExist()) {\\n      fight();\\n    }\\n  }\\n\\n    private boolean fightableRobotsExist() {\\n      while (foundRobotGoingLeft()) {\\n        if (previousRobotGoesRight()) {\\n          return true;\\n        }\\n        positionGoingLeft++;\\n      }\\n      return false;\\n    }\\n\\n      private boolean foundRobotGoingLeft() {\\n        positionGoingLeft = treeMap.ceilingKey(positionGoingLeft);\\n        while (positionGoingLeft != null) {\\n          Robot nextRobot = treeMap.get(positionGoingLeft);\\n          if (nextRobot.goingLeft) {\\n            return true;\\n          }\\n          positionGoingLeft = treeMap.higherKey(positionGoingLeft);\\n        }\\n        return false;\\n      }\\n\\n      private boolean previousRobotGoesRight() {\\n        positionGoingRight = treeMap.lowerKey(positionGoingLeft);\\n        if (positionGoingRight == null) {\\n          return false;\\n        }\\n        Robot robotGoingRight = treeMap.get(positionGoingRight);\\n        return !robotGoingRight.goingLeft;\\n      }\\n\\n    private void fight() {\\n      Robot robotGoingLeft = treeMap.get(positionGoingLeft);\\n      Robot robotGoingRight = treeMap.get(positionGoingRight);\\n      if (robotGoingRight.health == robotGoingLeft.health) {\\n        treeMap.remove(positionGoingLeft);\\n        treeMap.remove(positionGoingRight);\\n      } else if (robotGoingRight.health < robotGoingLeft.health) {\\n        treeMap.remove(positionGoingRight);\\n        robotGoingLeft.health--;\\n      } else {\\n        treeMap.remove(positionGoingLeft);\\n        robotGoingRight.health--;\\n      }\\n    }\\n\\n\\n  private List<Integer> getResult() {\\n    PriorityQueue<Robot> robotPriorityQueue = getPriorityQueueSortedByIndex();\\n    return getHealths(robotPriorityQueue);\\n  }\\n\\n    private PriorityQueue<Robot> getPriorityQueueSortedByIndex() {\\n      PriorityQueue<Robot> priorityQueueSortedByOriginalIndex = new PriorityQueue<>\\n            (Comparator.comparingInt(a -> a.index));\\n      for (Map.Entry<Integer, Robot> entry : treeMap.entrySet()) {\\n        priorityQueueSortedByOriginalIndex.add(entry.getValue());\\n      }\\n      return priorityQueueSortedByOriginalIndex;\\n    }\\n  \\n    private List<Integer> getHealths(PriorityQueue<Robot> robotPriorityQueue) {\\n      List<Integer> results = new ArrayList<>();\\n      while (!robotPriorityQueue.isEmpty()) {\\n        Robot r = robotPriorityQueue.remove();\\n        results.add(r.health);\\n      }\\n      return results;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679382,
                "title": "intuitive-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter reading the problem, I thought it was very similar to the Aestroid Collision Problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Steps:**\\n1. Convert the question into Aestroid Collision. In that question, the order of the aestroids was from left to right. We can achieve that in this question too by simply creating a new vector v which has (position,health,direction). Then we sort this v according to position.\\n2. The only changes made to the Aestroid Collision solution is how to decrease the health of the robot after a collision. There are two cases when we have to do so:\\na. if the current robot is moving to the left and its value is greater than the robot on top of the stack. Decrease the  health of the left moving robot by 1 and pop the robot from the top of the stack.If stack becomes empty, push the cur robot onto the stack.\\nb. if current robot was moving to the left and we encounter another robot moving to the right on top of the tack, but the robot on top of the stack has a grerater health. In this case, decrease health of the element on top of the stack and dont push the current robot onto the stack.\\n3.Now the last step is to arrange the elements in the same order of their positions in the orignal array. This can be done using a map.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    2 iterations of the input vector so  O(n) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n) for the additional vector, stack and map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        return a[0]<b[0];\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& heal, string dir) {\\n        int n=dir.size();\\n        \\n        vector<vector<int>>v(n);\\n        for(int i=0;i<n;i++){\\n            v[i]={pos[i],heal[i],dir[i]==\\'R\\'};\\n        }\\n        // dir R means 1\\n        sort(v.begin(),v.end(),comp);\\n        stack<vector<int>>st;\\n        for(auto it:v){\\n            if(it[2]==1 || st.empty()){\\n                st.push(it);\\n            }else{\\n                while(!st.empty() && st.top()[2]==1 && st.top()[1]<it[1]){st.pop();it[1]--;}\\n                \\n                  if(!st.empty() && st.top()[2]==1 && st.top()[1]==it[1]){st.pop();}\\n            \\n                else if(st.empty() || st.top()[2]==0){st.push(it);}\\n                else if(!st.empty()){st.top()[1]--;}\\n                \\n            }\\n        }\\n        vector<int>ans(n,-1);\\n      map<int,int>m;\\n        \\n        for(int i=0;i<pos.size();i++){\\n            m[pos[i]]=i;\\n        }\\n        while(!st.empty()){\\n            ans[m[st.top()[0]]]=st.top()[1];\\n            st.pop();\\n        }\\n                vector<int>final;\\n         for(auto it:ans){\\n             if(it!=-1)final.push_back(it);\\n         }       \\n        return final;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        return a[0]<b[0];\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& heal, string dir) {\\n        int n=dir.size();\\n        \\n        vector<vector<int>>v(n);\\n        for(int i=0;i<n;i++){\\n            v[i]={pos[i],heal[i],dir[i]==\\'R\\'};\\n        }\\n        // dir R means 1\\n        sort(v.begin(),v.end(),comp);\\n        stack<vector<int>>st;\\n        for(auto it:v){\\n            if(it[2]==1 || st.empty()){\\n                st.push(it);\\n            }else{\\n                while(!st.empty() && st.top()[2]==1 && st.top()[1]<it[1]){st.pop();it[1]--;}\\n                \\n                  if(!st.empty() && st.top()[2]==1 && st.top()[1]==it[1]){st.pop();}\\n            \\n                else if(st.empty() || st.top()[2]==0){st.push(it);}\\n                else if(!st.empty()){st.top()[1]--;}\\n                \\n            }\\n        }\\n        vector<int>ans(n,-1);\\n      map<int,int>m;\\n        \\n        for(int i=0;i<pos.size();i++){\\n            m[pos[i]]=i;\\n        }\\n        while(!st.empty()){\\n            ans[m[st.top()[0]]]=st.top()[1];\\n            st.pop();\\n        }\\n                vector<int>final;\\n         for(auto it:ans){\\n             if(it!=-1)final.push_back(it);\\n         }       \\n        return final;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679208,
                "title": "c-sorting-stack-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string d) {\\n        \\n        \\n         vector<pair<int,int>>vp ;\\n          int n=pos.size() ;\\n         for(int  i=0;i<n;i++) {\\n             \\n             vp.push_back({pos[i],i}) ;\\n         }\\n        \\n        sort(vp.begin(),vp.end()) ;\\n        \\n         stack<int>st ;\\n         \\n         \\n         for(int i=0;i<n;i++) {\\n              int ind=vp[i].second ;\\n               char dir=d[ind] ;\\n               \\n               if(dir==\\'L\\') {\\n                  \\n                    if(st.empty()) {\\n                        st.push(ind) ;  \\n                    }\\n                   else {\\n                       \\n                        if(d[st.top()]==\\'R\\' && h[st.top()] ==h[ind]) {\\n                             h[st.top()]=0 ;\\n                             st.pop() ;\\n                             h[ind]=0 ;\\n                           \\n                        }\\n                       else{ \\n                       \\n                        while(!st.empty() && d[st.top()]==\\'R\\' && h[st.top()] < h[ind] ){\\n                             h[st.top()]=0 ;\\n                            st.pop();\\n                            h[ind]--;\\n                        }\\n                       // left robot moving in right direction and health is greater than curr robot\\n                        if(!st.empty() &&  d[st.top()]==\\'R\\' && h[st.top()] > h[ind]) {\\n                            h[st.top()]--; \\n                            h[ind]=0 ;\\n                        }\\n                       // left robot moving in right direction and health is  equal to curr robot\\n                          else  if(!st.empty() &&  d[st.top()]==\\'R\\' && h[st.top()] == h[ind]) {\\n                            h[st.top()]=0; \\n                            h[ind]=0 ;\\n                                st.pop();\\n                        }\\n                       else{\\n                           st.push(ind) ;\\n                       }\\n                       }\\n                        \\n                   }\\n               } \\n     // moving in right direction, collison is not possible with behind this robot\\n             else{\\n                 st.push(ind) ;     \\n             }\\n         }\\n        \\n         vector<int>ans;\\n        \\n         for(int x:h) {\\n             if(x >0) ans.push_back(x) ; \\n         }\\n        \\n         return ans;\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string d) {\\n        \\n        \\n         vector<pair<int,int>>vp ;\\n          int n=pos.size() ;\\n         for(int  i=0;i<n;i++) {\\n             \\n             vp.push_back({pos[i],i}) ;\\n         }\\n        \\n        sort(vp.begin(),vp.end()) ;\\n        \\n         stack<int>st ;\\n         \\n         \\n         for(int i=0;i<n;i++) {\\n              int ind=vp[i].second ;\\n               char dir=d[ind] ;\\n               \\n               if(dir==\\'L\\') {\\n                  \\n                    if(st.empty()) {\\n                        st.push(ind) ;  \\n                    }\\n                   else {\\n                       \\n                        if(d[st.top()]==\\'R\\' && h[st.top()] ==h[ind]) {\\n                             h[st.top()]=0 ;\\n                             st.pop() ;\\n                             h[ind]=0 ;\\n                           \\n                        }\\n                       else{ \\n                       \\n                        while(!st.empty() && d[st.top()]==\\'R\\' && h[st.top()] < h[ind] ){\\n                             h[st.top()]=0 ;\\n                            st.pop();\\n                            h[ind]--;\\n                        }\\n                       // left robot moving in right direction and health is greater than curr robot\\n                        if(!st.empty() &&  d[st.top()]==\\'R\\' && h[st.top()] > h[ind]) {\\n                            h[st.top()]--; \\n                            h[ind]=0 ;\\n                        }\\n                       // left robot moving in right direction and health is  equal to curr robot\\n                          else  if(!st.empty() &&  d[st.top()]==\\'R\\' && h[st.top()] == h[ind]) {\\n                            h[st.top()]=0; \\n                            h[ind]=0 ;\\n                                st.pop();\\n                        }\\n                       else{\\n                           st.push(ind) ;\\n                       }\\n                       }\\n                        \\n                   }\\n               } \\n     // moving in right direction, collison is not possible with behind this robot\\n             else{\\n                 st.push(ind) ;     \\n             }\\n         }\\n        \\n         vector<int>ans;\\n        \\n         for(int x:h) {\\n             if(x >0) ans.push_back(x) ; \\n         }\\n        \\n         return ans;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679185,
                "title": "easy-c-solution-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<pair<int, int>>v;\\n        int n=positions.size();\\n        for(int i=0; i<n; i++){\\n            v.push_back({positions[i], i});\\n        }\\n        sort(v.begin(), v.end());\\n        stack<pair<int, int>> st;\\n        st.push(v[0]);\\n        for(int i=1; i<v.size(); i++){\\n            int flag=1;\\n            int curpos=v[i].first;\\n            int ind=v[i].second;\\n            while(st.size()!=0 && directions[st.top().second]==\\'R\\' && directions[ind]==\\'L\\' && flag==1){\\n                pair<int, int> p=st.top();\\n                int pos=p.first;\\n                if(healths[p.second]==healths[ind]){\\n                    st.pop();\\n                    flag=0;\\n                }\\n                else if(healths[p.second]>healths[ind]){\\n                    flag=0;\\n                    healths[p.second]-=1;\\n                }\\n                else if(healths[ind]>healths[p.second]){\\n                    st.pop();\\n                    healths[ind]-=1;\\n                }\\n            }\\n            if(flag==1)st.push({curpos, ind});\\n        }\\n        map<pair<int, int>, int>mp;\\n        while(st.size()!=0){\\n            mp[st.top()]++;\\n            st.pop();\\n        }\\n        vector<int> ans;\\n        for(int i=0; i<n; i++){\\n            if(mp.count({positions[i], i})>0){\\n                ans.push_back(healths[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<pair<int, int>>v;\\n        int n=positions.size();\\n        for(int i=0; i<n; i++){\\n            v.push_back({positions[i], i});\\n        }\\n        sort(v.begin(), v.end());\\n        stack<pair<int, int>> st;\\n        st.push(v[0]);\\n        for(int i=1; i<v.size(); i++){\\n            int flag=1;\\n            int curpos=v[i].first;\\n            int ind=v[i].second;\\n            while(st.size()!=0 && directions[st.top().second]==\\'R\\' && directions[ind]==\\'L\\' && flag==1){\\n                pair<int, int> p=st.top();\\n                int pos=p.first;\\n                if(healths[p.second]==healths[ind]){\\n                    st.pop();\\n                    flag=0;\\n                }\\n                else if(healths[p.second]>healths[ind]){\\n                    flag=0;\\n                    healths[p.second]-=1;\\n                }\\n                else if(healths[ind]>healths[p.second]){\\n                    st.pop();\\n                    healths[ind]-=1;\\n                }\\n            }\\n            if(flag==1)st.push({curpos, ind});\\n        }\\n        map<pair<int, int>, int>mp;\\n        while(st.size()!=0){\\n            mp[st.top()]++;\\n            st.pop();\\n        }\\n        vector<int> ans;\\n        for(int i=0; i<n; i++){\\n            if(mp.count({positions[i], i})>0){\\n                ans.push_back(healths[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679122,
                "title": "priority-queue-intuitive-soln-easy-explanation-c",
                "content": "# Intuition\\nWe divide all the robots into two types namely -\\n\\n1. Robots Going Left (save them all in a set)\\n2. Robots going right( put them all in a priority queue)\\n\\n# Approach\\nAs we can see both of them as ordered containers means sorted in some manner\\n\\nnow when comparing these two structure simultaneously we have this kind of structure.\\n\\nL     LL.    L.       L\\n\\n   R       R      R      R\\n\\nnow as we can see the last R will not collide with anybody, but how would we know this in code ??\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\nFor that we will take the rightmost element( top of priority Queue) get its x coordinate, and  binary search upon the L set, or the elements going left, \\n\\nThrough binary search or specifically lower bound we will always get the robot which is right or at the same position to the position we are at in priority queue. \\n\\nThen after that it\\'s a matter of simple comparison.\\n\\nWe eighter Pop from the queue or we erase from the set depending on the values\\n\\n\\nPlease Upvote if you liked my approach, and do let me know if in comments if you require further explainations.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<pair<int,int>> answer;\\n        priority_queue<pair<int, pair<int,int> >> r;\\n        set<pair<int,  pair<int,int> >> l;\\n        \\n        \\n        for(int i = 0; i < directions.size(); i++){\\n            if(directions[i] == \\'L\\'){\\n                l.insert({positions[i], {healths[i], i}});\\n            }else{\\n                r.push({positions[i], {healths[i], i}});\\n            }\\n        }\\n        \\n        \\n        while(r.size()){\\n            int pos = r.top().first, h = r.top().second.first, idx = r.top().second.second;\\n            r.pop();\\n            \\n            auto ptr = l.lower_bound({pos, {0, 0}});\\n            \\n            if(ptr == l.end()){\\n                answer.push_back({idx, h});\\n                continue;\\n            }\\n            \\n            int x = ptr->second.first;\\n            int id = ptr->second.second;\\n            \\n            if(h > x){\\n                l.erase(ptr);\\n                r.push({pos, {h -1, idx}});\\n                continue;\\n            }else if( x > h){\\n                l.erase(ptr);\\n                l.insert({pos, {x- 1, id} });\\n                continue;\\n            }else{\\n                l.erase(ptr);\\n            }\\n        }\\n        \\n        \\n        \\n        for(auto i : l){\\n            answer.push_back({i.second.second, i.second.first});\\n        }\\n        sort(answer.begin(), answer.end());\\n        \\n        \\n        vector<int> temp;\\n        for(auto i : answer){\\n            temp.push_back(i.second);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<pair<int,int>> answer;\\n        priority_queue<pair<int, pair<int,int> >> r;\\n        set<pair<int,  pair<int,int> >> l;\\n        \\n        \\n        for(int i = 0; i < directions.size(); i++){\\n            if(directions[i] == \\'L\\'){\\n                l.insert({positions[i], {healths[i], i}});\\n            }else{\\n                r.push({positions[i], {healths[i], i}});\\n            }\\n        }\\n        \\n        \\n        while(r.size()){\\n            int pos = r.top().first, h = r.top().second.first, idx = r.top().second.second;\\n            r.pop();\\n            \\n            auto ptr = l.lower_bound({pos, {0, 0}});\\n            \\n            if(ptr == l.end()){\\n                answer.push_back({idx, h});\\n                continue;\\n            }\\n            \\n            int x = ptr->second.first;\\n            int id = ptr->second.second;\\n            \\n            if(h > x){\\n                l.erase(ptr);\\n                r.push({pos, {h -1, idx}});\\n                continue;\\n            }else if( x > h){\\n                l.erase(ptr);\\n                l.insert({pos, {x- 1, id} });\\n                continue;\\n            }else{\\n                l.erase(ptr);\\n            }\\n        }\\n        \\n        \\n        \\n        for(auto i : l){\\n            answer.push_back({i.second.second, i.second.first});\\n        }\\n        sort(answer.begin(), answer.end());\\n        \\n        \\n        vector<int> temp;\\n        for(auto i : answer){\\n            temp.push_back(i.second);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686564,
                "title": "easy-code-stack-sorting-based-approach-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    static bool cmp(pair<int,int> &p1 , pair<int,int> &p2){\\n        return p1.second < p2.second;\\n    }\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<pair<int,pair<int,pair<int,int>>>>vp;\\n        for(int i = 0 ; i < positions.size() ; i++){\\n            vp.push_back({positions[i],{healths[i],{directions[i],i}}});\\n        }\\n        sort(vp.begin(),vp.end());\\n        stack<pair<int,pair<int,int>>>stk;\\n        stk.push({vp[0].second.first,{vp[0].second.second.first,vp[0].second.second.second}});\\n        int j = 1;\\n        while(j < n){\\n            int health = vp[j].second.first;\\n            int dir = vp[j].second.second.first;\\n            if(!stk.empty() and stk.top().second.first == \\'R\\' and dir == \\'L\\'){\\n                if(!stk.empty() and stk.top().first < health){\\n                    vp[j].second.first = vp[j].second.first - 1;\\n                    stk.pop();\\n                    if(j == n-1){\\n                        if(stk.empty()){\\n                            stk.push({vp[j].second.first,{dir,vp[j].second.second.second}});\\n                            break;\\n                        }\\n                    }\\n                    continue;\\n                }\\n                else if(!stk.empty() and stk.top().first == health){\\n                    stk.pop();\\n                }\\n                else{\\n                    stk.top().first--;\\n                }\\n            }\\n            else{\\n                stk.push({health,{dir,vp[j].second.second.second}});\\n            }\\n            j++;\\n        }\\n        vector<pair<int,int>>ans;\\n        while(!stk.empty()){\\n            ans.push_back({stk.top().first,stk.top().second.second});\\n            stk.pop();\\n        }\\n        sort(ans.begin(),ans.end(),cmp);\\n        vector<int>res;\\n        for(auto x : ans){\\n            res.push_back(x.first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool cmp(pair<int,int> &p1 , pair<int,int> &p2){\\n        return p1.second < p2.second;\\n    }\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<pair<int,pair<int,pair<int,int>>>>vp;\\n        for(int i = 0 ; i < positions.size() ; i++){\\n            vp.push_back({positions[i],{healths[i],{directions[i],i}}});\\n        }\\n        sort(vp.begin(),vp.end());\\n        stack<pair<int,pair<int,int>>>stk;\\n        stk.push({vp[0].second.first,{vp[0].second.second.first,vp[0].second.second.second}});\\n        int j = 1;\\n        while(j < n){\\n            int health = vp[j].second.first;\\n            int dir = vp[j].second.second.first;\\n            if(!stk.empty() and stk.top().second.first == \\'R\\' and dir == \\'L\\'){\\n                if(!stk.empty() and stk.top().first < health){\\n                    vp[j].second.first = vp[j].second.first - 1;\\n                    stk.pop();\\n                    if(j == n-1){\\n                        if(stk.empty()){\\n                            stk.push({vp[j].second.first,{dir,vp[j].second.second.second}});\\n                            break;\\n                        }\\n                    }\\n                    continue;\\n                }\\n                else if(!stk.empty() and stk.top().first == health){\\n                    stk.pop();\\n                }\\n                else{\\n                    stk.top().first--;\\n                }\\n            }\\n            else{\\n                stk.push({health,{dir,vp[j].second.second.second}});\\n            }\\n            j++;\\n        }\\n        vector<pair<int,int>>ans;\\n        while(!stk.empty()){\\n            ans.push_back({stk.top().first,stk.top().second.second});\\n            stk.pop();\\n        }\\n        sort(ans.begin(),ans.end(),cmp);\\n        vector<int>res;\\n        for(auto x : ans){\\n            res.push_back(x.first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686085,
                "title": "python-3-15-lines-duples-no-zip-t-m-81-49",
                "content": "This code is pretty much the standard stack solution used by most on this problem, with the addition of two variations.\\n\\n1. We code the direction into`healths`; `\\'L\\'`-> change to negative, `\\'R\\'`-> leave as positive.\\n\\n1. We use`positions`as the sort key.\\n\\nAs a result, we only need`idx`and`hth` as a two-tuple (a \"duple\") from `enumerate(healths)` for the stack. Thus, no zipping.\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], \\n                                    healths: List[int], \\n                                    directions: str) -> List[int]:\\n         \\n\\n        healths = map(mul,(-1 if  ch == \\'L\\' \\n                       else 1 for ch in directions), healths)    # <-- (1)\\n\\n        arr = sorted(enumerate(healths),\\n                               key = lambda x: positions[x[0]])  # <-- (2)\\n        \\n        stack = deque([arr.pop(0)])\\n        \\n        for idx, hth in arr:\\n            if hth > 0: stack.append((idx,hth))\\n\\n            else:\\n                while stack and stack[-1][1] > 0 and hth < 0:\\n\\n                    IDX, HTH = stack.pop()\\n                    diff = HTH + hth\\n\\n                    if   diff > 0: idx,hth = IDX,HTH-1  # \\'R\\' robot wins\\n                    elif diff < 0: hth+= 1              # \\'L\\' robot wins\\n                    else: break                         # robots tie\\n\\n                else: stack.append((idx,hth))           # only appends if \\n                                                        # there\\'s a winner\\n        return [abs(hth) for _,hth in sorted(stack)]\\n```\\n[https://leetcode.com/problems/robot-collisions/submissions/980182168/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(*N*), in which *N* ~ `len(healths)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], \\n                                    healths: List[int], \\n                                    directions: str) -> List[int]:\\n         \\n\\n        healths = map(mul,(-1 if  ch == \\'L\\' \\n                       else 1 for ch in directions), healths)    # <-- (1)\\n\\n        arr = sorted(enumerate(healths),\\n                               key = lambda x: positions[x[0]])  # <-- (2)\\n        \\n        stack = deque([arr.pop(0)])\\n        \\n        for idx, hth in arr:\\n            if hth > 0: stack.append((idx,hth))\\n\\n            else:\\n                while stack and stack[-1][1] > 0 and hth < 0:\\n\\n                    IDX, HTH = stack.pop()\\n                    diff = HTH + hth\\n\\n                    if   diff > 0: idx,hth = IDX,HTH-1  # \\'R\\' robot wins\\n                    elif diff < 0: hth+= 1              # \\'L\\' robot wins\\n                    else: break                         # robots tie\\n\\n                else: stack.append((idx,hth))           # only appends if \\n                                                        # there\\'s a winner\\n        return [abs(hth) for _,hth in sorted(stack)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682774,
                "title": "cleanest-implementation-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> ans;\\n        vector<int> sol;\\n        vector<pair<pair<int,int>,char>> v;\\n        unordered_map<int,int> m;\\n        for(int i=0; i<positions.size(); i++){\\n            m[positions[i]]=i;\\n            v.push_back({{positions[i],healths[i]},directions[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        stack<pair<int,int>> st;\\n        for(int i = 0; i<v.size(); i++){\\n            if(v[i].second==\\'R\\'){\\n                st.push({v[i].first.first,v[i].first.second});\\n            }\\n            else{\\n                int l = v[i].first.second;\\n                while(!st.empty()){\\n                    auto temp = st.top();\\n                    st.pop();\\n                    if(l>temp.second){\\n                        l-=1;\\n                    }\\n                    else{\\n                        temp.second-=1;\\n                        if(temp.second!=l-1)st.push(temp);\\n                        l=0;\\n                        break;\\n                    }\\n                }\\n                if(l!=0)ans.push({m[v[i].first.first],l});\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push({m[st.top().first],st.top().second});\\n            st.pop();\\n        }\\n        while(!ans.empty()){\\n            auto t = ans.top();\\n            ans.pop();\\n            sol.push_back(t.second);\\n        }\\n        return sol;\\n    }\\n};\\n```\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> ans;\\n        vector<int> sol;\\n        vector<pair<pair<int,int>,char>> v;\\n        unordered_map<int,int> m;\\n        for(int i=0; i<positions.size(); i++){\\n            m[positions[i]]=i;\\n            v.push_back({{positions[i],healths[i]},directions[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        stack<pair<int,int>> st;\\n        for(int i = 0; i<v.size(); i++){\\n            if(v[i].second==\\'R\\'){\\n                st.push({v[i].first.first,v[i].first.second});\\n            }\\n            else{\\n                int l = v[i].first.second;\\n                while(!st.empty()){\\n                    auto temp = st.top();\\n                    st.pop();\\n                    if(l>temp.second){\\n                        l-=1;\\n                    }\\n                    else{\\n                        temp.second-=1;\\n                        if(temp.second!=l-1)st.push(temp);\\n                        l=0;\\n                        break;\\n                    }\\n                }\\n                if(l!=0)ans.push({m[v[i].first.first],l});\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push({m[st.top().first],st.top().second});\\n            st.pop();\\n        }\\n        while(!ans.empty()){\\n            auto t = ans.top();\\n            ans.pop();\\n            sol.push_back(t.second);\\n        }\\n        return sol;\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681250,
                "title": "done-using-stack-sort-in-c",
                "content": "#  Intuition\\nSince the problem requires us to keep track of all of the collisions so that we can get the final health array, we have to sort the positions of the robot and add the robot to a stack either by scanning from left to right (or) from right to left. Just before adding the robot in the stack , check for collision case where the direction is opposite and update the health array for each collisions. We generally use stack when there is frequent updates to be made. \\n\\n# Approach\\nCreate a new array to keep track of the original index of the sorted postion array. In the following approach the data array has both position and original index, so we can still get the original index after sorting the data array. Now just create a stack to keep track of the previous robots. Here we are scanning from left to right so the collision case is when previous robot is moving right and current robot is moving left. We don\\'t consider previous robot moving left and current moving to right since there is no collision between current and previous and the stack only stores the updated robots seen uptil now so previous moving to left won\\'t lead to a collision case. We update the health array for each collision and we can finally scan the health array to get the non-zero values alone (this way we can get our final answer array to be in the same order as the health array)\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) due to sorting\\n\\n- Space complexity:\\nO(n) since the data array requires O(n) space, and the space stack can contain at most n elements\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<pair<int,int>> data;\\n        for(int i=0;i<positions.size();i++)\\n        {\\n            data.push_back({positions[i],i});\\n        }\\n        sort(data.begin(),data.end());\\n        stack<int> space;\\n        for(int i=0;i<data.size();i++)\\n        {\\n            int pos=data[i].first, index=data[i].second;\\n            if(!space.empty())\\n            {\\n                while(true && !space.empty())\\n                {\\n                    int prev=space.top();\\n                    if(directions[prev]==\\'R\\' && directions[index]==\\'L\\' && healths[index]!=0)\\n                    {\\n                        if(healths[index]==healths[prev]) \\n                        {\\n                            healths[index]=0;\\n                            healths[prev]=0;\\n                            space.pop();\\n                            break;\\n                        }\\n                        else if(healths[index]>healths[prev])\\n                        {\\n                            space.pop();\\n                            healths[index]--;\\n                            healths[prev]=0;\\n                        }\\n                        else\\n                        {\\n                            healths[prev]--;\\n                            healths[index]=0;\\n                            if(healths[prev]==0) space.pop();\\n                            break;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n\\n                if(healths[index]!=0) space.push(index);\\n            }\\n            else \\n            {\\n                space.push(index);\\n            }\\n        }\\n        vector<int> arr;\\n        for(int i=0;i<healths.size();i++)\\n        {\\n            if(healths[i]) arr.push_back(healths[i]);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<pair<int,int>> data;\\n        for(int i=0;i<positions.size();i++)\\n        {\\n            data.push_back({positions[i],i});\\n        }\\n        sort(data.begin(),data.end());\\n        stack<int> space;\\n        for(int i=0;i<data.size();i++)\\n        {\\n            int pos=data[i].first, index=data[i].second;\\n            if(!space.empty())\\n            {\\n                while(true && !space.empty())\\n                {\\n                    int prev=space.top();\\n                    if(directions[prev]==\\'R\\' && directions[index]==\\'L\\' && healths[index]!=0)\\n                    {\\n                        if(healths[index]==healths[prev]) \\n                        {\\n                            healths[index]=0;\\n                            healths[prev]=0;\\n                            space.pop();\\n                            break;\\n                        }\\n                        else if(healths[index]>healths[prev])\\n                        {\\n                            space.pop();\\n                            healths[index]--;\\n                            healths[prev]=0;\\n                        }\\n                        else\\n                        {\\n                            healths[prev]--;\\n                            healths[index]=0;\\n                            if(healths[prev]==0) space.pop();\\n                            break;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n\\n                if(healths[index]!=0) space.push(index);\\n            }\\n            else \\n            {\\n                space.push(index);\\n            }\\n        }\\n        vector<int> arr;\\n        for(int i=0;i<healths.size();i++)\\n        {\\n            if(healths[i]) arr.push_back(healths[i]);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679237,
                "title": "java-solution-using-stack-and-sorting",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int p;\\n        int h;\\n        char d;\\n        int idx;\\n        Pair(int p,int h,char d,int i){\\n            this.p=p;\\n            this.h=h;\\n            this.d=d;\\n            this.idx=i;\\n        }\\n    }\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n          int n=positions.length;\\n          List<Pair> list=new ArrayList<>();\\n        \\n          for(int i=0;i<n;i++){\\n              list.add(new Pair(positions[i],healths[i],directions.charAt(i),i));\\n          }\\n        \\n          Collections.sort(list,(a,b)->a.p-b.p);\\n        \\n          List<int[]> ans=new ArrayList<>();\\n          Stack<int[]> q=new Stack<>();\\n        \\n          for(int i=0;i<n;i++){\\n              Pair curr=list.get(i);\\n              if(curr.d==\\'R\\'){\\n                  q.add(new int[]{curr.h,curr.idx});\\n                  continue;\\n              }\\n              else{\\n                  boolean flag=false;\\n                  int health=curr.h;\\n                  \\n                  while(!q.isEmpty() && health!=0){\\n                       int top[]=q.pop();\\n                       int last=top[0];\\n                       int idx=top[1];\\n                      \\n                       if(last<health){\\n                           health-=1;\\n                       }else if(last==health){\\n                           health=0;\\n                           break;\\n                       }\\n                       else{\\n                          last-=1;\\n                          health=0;\\n                          q.add(new int[]{last,idx});\\n                           \\n                       }\\n                  }\\n                  \\n                  if(health!=0)\\n                      ans.add(new int[]{health,curr.idx});\\n              }\\n          }\\n        \\n        while(!q.isEmpty()){\\n              ans.add(q.pop());\\n        }\\n        \\n        Collections.sort(ans,(a,b)->a[1]-b[1]);\\n        \\n        List<Integer> result=new ArrayList<>();\\n        \\n        for(int i=0;i<ans.size();i++){\\n            result.add(ans.get(i)[0]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int p;\\n        int h;\\n        char d;\\n        int idx;\\n        Pair(int p,int h,char d,int i){\\n            this.p=p;\\n            this.h=h;\\n            this.d=d;\\n            this.idx=i;\\n        }\\n    }\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n          int n=positions.length;\\n          List<Pair> list=new ArrayList<>();\\n        \\n          for(int i=0;i<n;i++){\\n              list.add(new Pair(positions[i],healths[i],directions.charAt(i),i));\\n          }\\n        \\n          Collections.sort(list,(a,b)->a.p-b.p);\\n        \\n          List<int[]> ans=new ArrayList<>();\\n          Stack<int[]> q=new Stack<>();\\n        \\n          for(int i=0;i<n;i++){\\n              Pair curr=list.get(i);\\n              if(curr.d==\\'R\\'){\\n                  q.add(new int[]{curr.h,curr.idx});\\n                  continue;\\n              }\\n              else{\\n                  boolean flag=false;\\n                  int health=curr.h;\\n                  \\n                  while(!q.isEmpty() && health!=0){\\n                       int top[]=q.pop();\\n                       int last=top[0];\\n                       int idx=top[1];\\n                      \\n                       if(last<health){\\n                           health-=1;\\n                       }else if(last==health){\\n                           health=0;\\n                           break;\\n                       }\\n                       else{\\n                          last-=1;\\n                          health=0;\\n                          q.add(new int[]{last,idx});\\n                           \\n                       }\\n                  }\\n                  \\n                  if(health!=0)\\n                      ans.add(new int[]{health,curr.idx});\\n              }\\n          }\\n        \\n        while(!q.isEmpty()){\\n              ans.add(q.pop());\\n        }\\n        \\n        Collections.sort(ans,(a,b)->a[1]-b[1]);\\n        \\n        List<Integer> result=new ArrayList<>();\\n        \\n        for(int i=0;i<ans.size();i++){\\n            result.add(ans.get(i)[0]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679179,
                "title": "little-bit-complex-code-in-c-stack",
                "content": "# if this code helps you, please upvote that\\'s helps to me.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<vector<int>> tmp;\\n        for(int i = 0; i < positions.size(); i++){\\n            tmp.push_back({positions[i],healths[i],directions[i],i});\\n        }\\n        sort(tmp.begin(),tmp.end());\\n        vector<int> vv(positions.size());\\n        for(int i = 0; i < positions.size(); i++){\\n            positions[i] = tmp[i][0];\\n            healths[i] = tmp[i][1];\\n            directions[i] = tmp[i][2];\\n            vv[i] = tmp[i][3];\\n        }\\n        vector<int> ans(directions.length(),0);\\n        vector<vector<int>> v;\\n        int i = 0, n = directions.length(),k=1;\\n        while(i<n && directions[i]==\\'L\\'){\\n            v.push_back({0,healths[i],vv[i]});\\n            i++;\\n        }\\n        while(i<n){\\n            while(i<n&&directions[i]==\\'R\\'){\\n                v.push_back({1,healths[i],vv[i]});\\n                i++;\\n            }\\n            if(i<n && directions[i]==\\'L\\'){\\n                k = 1;\\n                while(!v.empty() && v.back()[0] == 1){\\n                    if(v.back()[1]<healths[i]){\\n                        healths[i]--;\\n                        v.pop_back();\\n                    }else if(v.back()[1]==healths[i]){\\n                        v.pop_back();\\n                        k=0;\\n                        i++;\\n                        break;\\n                    }else{\\n                        k=0;\\n                        v.back()[1]--;\\n                        i++;\\n                        break;\\n                    }\\n                }\\n                    if(k && healths[i]>0){\\n                        v.push_back({0,healths[i],vv[i]});\\n                        i++;\\n                    }\\n            }\\n            \\n        }\\n        if(v.empty())return {};\\n        for(auto &i: v)ans[i[2]] = i[1];\\n        vector<int> xxxx;\\n        for(auto &i: ans){\\n            if(i)xxxx.push_back(i);\\n        }\\n        return xxxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<vector<int>> tmp;\\n        for(int i = 0; i < positions.size(); i++){\\n            tmp.push_back({positions[i],healths[i],directions[i],i});\\n        }\\n        sort(tmp.begin(),tmp.end());\\n        vector<int> vv(positions.size());\\n        for(int i = 0; i < positions.size(); i++){\\n            positions[i] = tmp[i][0];\\n            healths[i] = tmp[i][1];\\n            directions[i] = tmp[i][2];\\n            vv[i] = tmp[i][3];\\n        }\\n        vector<int> ans(directions.length(),0);\\n        vector<vector<int>> v;\\n        int i = 0, n = directions.length(),k=1;\\n        while(i<n && directions[i]==\\'L\\'){\\n            v.push_back({0,healths[i],vv[i]});\\n            i++;\\n        }\\n        while(i<n){\\n            while(i<n&&directions[i]==\\'R\\'){\\n                v.push_back({1,healths[i],vv[i]});\\n                i++;\\n            }\\n            if(i<n && directions[i]==\\'L\\'){\\n                k = 1;\\n                while(!v.empty() && v.back()[0] == 1){\\n                    if(v.back()[1]<healths[i]){\\n                        healths[i]--;\\n                        v.pop_back();\\n                    }else if(v.back()[1]==healths[i]){\\n                        v.pop_back();\\n                        k=0;\\n                        i++;\\n                        break;\\n                    }else{\\n                        k=0;\\n                        v.back()[1]--;\\n                        i++;\\n                        break;\\n                    }\\n                }\\n                    if(k && healths[i]>0){\\n                        v.push_back({0,healths[i],vv[i]});\\n                        i++;\\n                    }\\n            }\\n            \\n        }\\n        if(v.empty())return {};\\n        for(auto &i: v)ans[i[2]] = i[1];\\n        vector<int> xxxx;\\n        for(auto &i: ans){\\n            if(i)xxxx.push_back(i);\\n        }\\n        return xxxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679166,
                "title": "java-use-stack-to-simulate-clean-code",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        int[] finalHealths = new int[n];\\n        Arrays.fill(finalHealths, -1);\\n\\n        List<int[]> robots = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            robots.add(new int[]{positions[i], healths[i], i});\\n        }\\n        \\n        Collections.sort(robots, (a, b) -> a[0] - b[0]);\\n\\n        Deque<int[]> left = new ArrayDeque<>();\\n        Deque<int[]> right = new ArrayDeque<>();\\n\\n        for (int[] robot : robots) {\\n            if (directions.charAt(robot[2]) == \\'R\\') {\\n                right.push(robot);\\n            } else {\\n                while (!right.isEmpty()) {\\n                    int[] rightRobot = right.peek();\\n                    if (rightRobot[1] > robot[1]) {\\n                        rightRobot[1]--;\\n                        robot[1] = 0;\\n                        break;\\n                    } else if (rightRobot[1] < robot[1]) {\\n                        rightRobot[1] = 0;\\n                        robot[1]--;\\n                        right.pop();\\n                    } else {\\n                        rightRobot[1] = 0;\\n                        robot[1] = 0;\\n                        right.pop();\\n                        break;\\n                    }\\n                }\\n                if (robot[1] > 0) {\\n                    left.push(robot);\\n                }\\n            }\\n        }\\n\\n        while (!right.isEmpty()) {\\n            int[] robot = right.pop();\\n            finalHealths[robot[2]] = robot[1];\\n        }\\n\\n        while (!left.isEmpty()) {\\n            int[] robot = left.pop();\\n            finalHealths[robot[2]] = robot[1];\\n        }\\n        \\n        List<Integer> healthList = new ArrayList<>();\\n        for (int health : finalHealths) {\\n            if (health > 0) {\\n                healthList.add(health);\\n            }\\n        }\\n        \\n        return healthList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        int[] finalHealths = new int[n];\\n        Arrays.fill(finalHealths, -1);\\n\\n        List<int[]> robots = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            robots.add(new int[]{positions[i], healths[i], i});\\n        }\\n        \\n        Collections.sort(robots, (a, b) -> a[0] - b[0]);\\n\\n        Deque<int[]> left = new ArrayDeque<>();\\n        Deque<int[]> right = new ArrayDeque<>();\\n\\n        for (int[] robot : robots) {\\n            if (directions.charAt(robot[2]) == \\'R\\') {\\n                right.push(robot);\\n            } else {\\n                while (!right.isEmpty()) {\\n                    int[] rightRobot = right.peek();\\n                    if (rightRobot[1] > robot[1]) {\\n                        rightRobot[1]--;\\n                        robot[1] = 0;\\n                        break;\\n                    } else if (rightRobot[1] < robot[1]) {\\n                        rightRobot[1] = 0;\\n                        robot[1]--;\\n                        right.pop();\\n                    } else {\\n                        rightRobot[1] = 0;\\n                        robot[1] = 0;\\n                        right.pop();\\n                        break;\\n                    }\\n                }\\n                if (robot[1] > 0) {\\n                    left.push(robot);\\n                }\\n            }\\n        }\\n\\n        while (!right.isEmpty()) {\\n            int[] robot = right.pop();\\n            finalHealths[robot[2]] = robot[1];\\n        }\\n\\n        while (!left.isEmpty()) {\\n            int[] robot = left.pop();\\n            finalHealths[robot[2]] = robot[1];\\n        }\\n        \\n        List<Integer> healthList = new ArrayList<>();\\n        for (int health : finalHealths) {\\n            if (health > 0) {\\n                healthList.add(health);\\n            }\\n        }\\n        \\n        return healthList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679164,
                "title": "java-nlogn-solution-using-deque",
                "content": "# Approach:\\n- Create an 2d list with all valued combined and also maintain the index in original array\\n- Sort the list based on position\\n- Start from index 0, and check for each robot.\\n  - For first robot, insert into deque\\n  - For other robots, if direction is left, check in loop for last elements in deque for any collisions. If collision is detected then if current robot health is greater, remove last robot from deque and decrease current robot health and vice versa\\n  - Finally sort the remaining robots in deque based on index in original array\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        ArrayList<ArrayList<Integer>> combined = new ArrayList<>();\\n        \\n        int n = positions.length;\\n        for(int i=0; i<n; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(positions[i]);\\n            temp.add(healths[i]);\\n            temp.add(directions.charAt(i) == \\'R\\' ? 1 : -1);\\n            temp.add(i);\\n            combined.add(temp);\\n        }\\n        \\n        Collections.sort(combined, new Comparator<ArrayList<Integer>>() {\\n            public int compare(ArrayList<Integer> o1, ArrayList<Integer> o2) {\\n                return o1.get(0).compareTo(o2.get(0));\\n            }\\n        });\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int i=0;\\n        int j=0;\\n        Deque<ArrayList<Integer>> deque = new ArrayDeque<>();\\n\\n        while(j < n) {\\n            if(j == 0) {\\n                deque.addLast(combined.get(j));\\n            } else {\\n                ArrayList<Integer> current = combined.get(j);\\n                int currHealth = current.get(1);\\n                if(current.get(2) == -1) {\\n                    while(!deque.isEmpty() && deque.peekLast().get(2) == 1) {\\n                        ArrayList<Integer> prev1 = deque.peekLast();\\n                        if(deque.peekLast().get(1) < currHealth) {\\n                            currHealth--;\\n                            deque.removeLast();\\n                        } else if(deque.peekLast().get(1) > currHealth) {\\n                            ArrayList<Integer> prev = deque.pollLast();\\n                            prev.set(1, prev.get(1) - 1);\\n                            currHealth = 0;\\n                            deque.addLast(prev);\\n                            break;\\n                        } else {\\n                            deque.removeLast();\\n                            currHealth = 0;\\n                            break;\\n                        }\\n                    }\\n\\n                    if(currHealth > 0) {\\n                        current.set(1, currHealth);\\n                        deque.addLast(current);\\n                    }\\n                } else {\\n                    deque.addLast(current);\\n                }\\n            }\\n            j++;\\n        }\\n        \\n        ArrayList<ArrayList<Integer>> temp = new ArrayList<>();\\n        for(ArrayList<Integer> arr : deque)\\n            temp.add(arr);\\n        \\n        Collections.sort(temp, new Comparator<ArrayList<Integer>>() {\\n            public int compare(ArrayList<Integer> o1, ArrayList<Integer> o2) {\\n                return o1.get(3).compareTo(o2.get(3));\\n            }\\n        });\\n        \\n        for(ArrayList<Integer> arr : temp) {\\n            result.add(arr.get(1));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        ArrayList<ArrayList<Integer>> combined = new ArrayList<>();\\n        \\n        int n = positions.length;\\n        for(int i=0; i<n; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(positions[i]);\\n            temp.add(healths[i]);\\n            temp.add(directions.charAt(i) == \\'R\\' ? 1 : -1);\\n            temp.add(i);\\n            combined.add(temp);\\n        }\\n        \\n        Collections.sort(combined, new Comparator<ArrayList<Integer>>() {\\n            public int compare(ArrayList<Integer> o1, ArrayList<Integer> o2) {\\n                return o1.get(0).compareTo(o2.get(0));\\n            }\\n        });\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int i=0;\\n        int j=0;\\n        Deque<ArrayList<Integer>> deque = new ArrayDeque<>();\\n\\n        while(j < n) {\\n            if(j == 0) {\\n                deque.addLast(combined.get(j));\\n            } else {\\n                ArrayList<Integer> current = combined.get(j);\\n                int currHealth = current.get(1);\\n                if(current.get(2) == -1) {\\n                    while(!deque.isEmpty() && deque.peekLast().get(2) == 1) {\\n                        ArrayList<Integer> prev1 = deque.peekLast();\\n                        if(deque.peekLast().get(1) < currHealth) {\\n                            currHealth--;\\n                            deque.removeLast();\\n                        } else if(deque.peekLast().get(1) > currHealth) {\\n                            ArrayList<Integer> prev = deque.pollLast();\\n                            prev.set(1, prev.get(1) - 1);\\n                            currHealth = 0;\\n                            deque.addLast(prev);\\n                            break;\\n                        } else {\\n                            deque.removeLast();\\n                            currHealth = 0;\\n                            break;\\n                        }\\n                    }\\n\\n                    if(currHealth > 0) {\\n                        current.set(1, currHealth);\\n                        deque.addLast(current);\\n                    }\\n                } else {\\n                    deque.addLast(current);\\n                }\\n            }\\n            j++;\\n        }\\n        \\n        ArrayList<ArrayList<Integer>> temp = new ArrayList<>();\\n        for(ArrayList<Integer> arr : deque)\\n            temp.add(arr);\\n        \\n        Collections.sort(temp, new Comparator<ArrayList<Integer>>() {\\n            public int compare(ArrayList<Integer> o1, ArrayList<Integer> o2) {\\n                return o1.get(3).compareTo(o2.get(3));\\n            }\\n        });\\n        \\n        for(ArrayList<Integer> arr : temp) {\\n            result.add(arr.get(1));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679139,
                "title": "easiest-code-sorting-and-stack-just-do-a-simulation-c-short-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n=positions.size();\\n        vector<pair<int,pair<int,pair<int,char>>>> nums(n); //pos,ind,heal,dir\\n        for(int i=0;i<n;i++){\\n            nums[i]={positions[i],{i,{healths[i],directions[i]}}};\\n        }\\n        sort(nums.begin(),nums.end());\\n        stack<pair<int,pair<int,char>>> st; //ind,heal,dir\\n        vector<int> ans(n,-1);\\n        for(auto it:nums){\\n            int ind=it.second.first;\\n            int heal=it.second.second.first;\\n            char dir=it.second.second.second;\\n            if(dir==\\'R\\'){\\n                st.push({ind,{heal,dir}});\\n            }\\n            else{\\n                while(!st.empty() and st.top().second.second!=\\'L\\'){\\n                    if(st.top().second.first>heal){\\n                        st.top().second.first--;\\n                        heal=0;\\n                        break;\\n                    }\\n                    else if(st.top().second.first<heal){\\n                        st.pop();\\n                        heal--;\\n                    }\\n                    else{\\n                        heal=0;\\n                        st.pop();\\n                        break;\\n                    }\\n                }\\n                if(heal>0) st.push({ind,{heal,dir}});\\n            }\\n        }\\n        while(!st.empty()){\\n            ans[st.top().first]=st.top().second.first;\\n            st.pop();\\n        }\\n        vector<int> fin;\\n        for(auto it:ans){\\n            if(it!=-1) fin.push_back(it);\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n=positions.size();\\n        vector<pair<int,pair<int,pair<int,char>>>> nums(n); //pos,ind,heal,dir\\n        for(int i=0;i<n;i++){\\n            nums[i]={positions[i],{i,{healths[i],directions[i]}}};\\n        }\\n        sort(nums.begin(),nums.end());\\n        stack<pair<int,pair<int,char>>> st; //ind,heal,dir\\n        vector<int> ans(n,-1);\\n        for(auto it:nums){\\n            int ind=it.second.first;\\n            int heal=it.second.second.first;\\n            char dir=it.second.second.second;\\n            if(dir==\\'R\\'){\\n                st.push({ind,{heal,dir}});\\n            }\\n            else{\\n                while(!st.empty() and st.top().second.second!=\\'L\\'){\\n                    if(st.top().second.first>heal){\\n                        st.top().second.first--;\\n                        heal=0;\\n                        break;\\n                    }\\n                    else if(st.top().second.first<heal){\\n                        st.pop();\\n                        heal--;\\n                    }\\n                    else{\\n                        heal=0;\\n                        st.pop();\\n                        break;\\n                    }\\n                }\\n                if(heal>0) st.push({ind,{heal,dir}});\\n            }\\n        }\\n        while(!st.empty()){\\n            ans[st.top().first]=st.top().second.first;\\n            st.pop();\\n        }\\n        vector<int> fin;\\n        for(auto it:ans){\\n            if(it!=-1) fin.push_back(it);\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787627,
                "title": "easy-c-stack-based-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&healths,stack<int>&st,int i){\\n        while(!st.empty()){\\n        int top=st.top();\\n        st.pop();\\n        if(healths[top]>healths[i]){\\n            healths[top]-=1;\\n            healths[i]=0;\\n            st.push(top);\\n            return;\\n        }\\n        else if(healths[top]==healths[i]){\\n            healths[i]=0;\\n            healths[top]=0;\\n            return;\\n        }\\n        else {\\n        healths[i]-=1;\\n        healths[top]=0;\\n        }\\n    }\\n}\\n    #define comp [&](int i,int j){return positions[i]<positions[j];}\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        //This problem can be easily solved using stack\\n        stack<int>st;\\n        int n=positions.size();\\n        vector<int>index(n);\\n        for(int i=0;i<n;i++)index[i]=i;\\n        sort(index.begin(),index.end(),comp);\\n        for(int j=0;j<n;j++){\\n            int i=index[j];\\n            if(directions[i]==\\'L\\'&&st.empty())continue;\\n            else if(directions[i]==\\'R\\')st.push(i);\\n            else solve(healths,st,i);\\n        }\\n    vector<int>ans;\\n    for(auto x : healths){\\n        if(x)ans.push_back(x);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&healths,stack<int>&st,int i){\\n        while(!st.empty()){\\n        int top=st.top();\\n        st.pop();\\n        if(healths[top]>healths[i]){\\n            healths[top]-=1;\\n            healths[i]=0;\\n            st.push(top);\\n            return;\\n        }\\n        else if(healths[top]==healths[i]){\\n            healths[i]=0;\\n            healths[top]=0;\\n            return;\\n        }\\n        else {\\n        healths[i]-=1;\\n        healths[top]=0;\\n        }\\n    }\\n}\\n    #define comp [&](int i,int j){return positions[i]<positions[j];}\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        //This problem can be easily solved using stack\\n        stack<int>st;\\n        int n=positions.size();\\n        vector<int>index(n);\\n        for(int i=0;i<n;i++)index[i]=i;\\n        sort(index.begin(),index.end(),comp);\\n        for(int j=0;j<n;j++){\\n            int i=index[j];\\n            if(directions[i]==\\'L\\'&&st.empty())continue;\\n            else if(directions[i]==\\'R\\')st.push(i);\\n            else solve(healths,st,i);\\n        }\\n    vector<int>ans;\\n    for(auto x : healths){\\n        if(x)ans.push_back(x);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705497,
                "title": "stack-map-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& heal, string dir) {\\n        int n=pos.size(),i=0;\\n        map<int,pair<int,char>>mp;\\n        stack<int>st;        \\n\\n        for(i=0;i<n;i++)mp[pos[i]]={heal[i],dir[i]};\\n        auto it=mp.begin();\\n        \\n        while(it!=mp.end()){\\n            if(st.empty() || ((it->second).second == mp[st.top()].second) || ((it->second).second == \\'R\\' && mp[st.top()].second == \\'L\\')){st.push(it->first);it++;}\\n            else{\\n                if((it->second).first == mp[st.top()].first){\\n                        mp[st.top()].first = (it->second).first =0;\\n                        st.pop();it++;\\n                    }\\n                    else if((it->second).first > mp[st.top()].first){\\n                        mp[st.top()].first=0;\\n                        st.pop();\\n                        (it->second).first--;\\n                    }\\n                    else if((it->second).first < mp[st.top()].first){\\n                        (it->second).first=0;\\n                        mp[st.top()].first--;\\n                        it++;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        \\n        for(i=0;i<n;i++){\\n            if(mp[pos[i]].first)ans.push_back(mp[pos[i]].first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& heal, string dir) {\\n        int n=pos.size(),i=0;\\n        map<int,pair<int,char>>mp;\\n        stack<int>st;        \\n\\n        for(i=0;i<n;i++)mp[pos[i]]={heal[i],dir[i]};\\n        auto it=mp.begin();\\n        \\n        while(it!=mp.end()){\\n            if(st.empty() || ((it->second).second == mp[st.top()].second) || ((it->second).second == \\'R\\' && mp[st.top()].second == \\'L\\')){st.push(it->first);it++;}\\n            else{\\n                if((it->second).first == mp[st.top()].first){\\n                        mp[st.top()].first = (it->second).first =0;\\n                        st.pop();it++;\\n                    }\\n                    else if((it->second).first > mp[st.top()].first){\\n                        mp[st.top()].first=0;\\n                        st.pop();\\n                        (it->second).first--;\\n                    }\\n                    else if((it->second).first < mp[st.top()].first){\\n                        (it->second).first=0;\\n                        mp[st.top()].first--;\\n                        it++;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        \\n        for(i=0;i<n;i++){\\n            if(mp[pos[i]].first)ans.push_back(mp[pos[i]].first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688872,
                "title": "c-detailed-approach-using-stack-balanced-parenthesis",
                "content": "Can we think about something like :\\nIf we are able to move any robot untill either it dies or reaches either one of end points left or right end,\\n\\nDid u remembered the ```Balanced parenthesis``` problem using stack it\\'s same concept here insted of brackets( \\'(\\' ,\\')\\'  )\\nwe have two opposite moving direction and the health assosited with the robots.\\n\\nsimilar to that problem we will keep  poping opposing robots which have lesser health and simultineously keep decreasing the surviour robot\\'s health by one. \\n\\nand at the end we will be left with some element in stack after itrating through the whole array \\nwhich means they are safe to move so we will just collect those at the end.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n   \\n    struct tri{  // let\\'s define a structure for easy handling of all these features of robot\\n        int p;  // position\\n        int h;  // health\\n        int d; // direction\\n        int idx;  // index will be used in last during returning ans\\n    };\\n     static bool mycom (tri &a, tri &b)\\n    {\\n        return a.p<b.p;\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        \\n       vector<tri> a;\\n       \\n        int n=p.size();\\n       for(int i=0; i<n; i++)\\n       {\\n           tri r;\\n           r.p=p[i];\\n           r.h=h[i];\\n           r.d=d[i]==\\'R\\';\\n           r.idx=i;\\n           a.push_back(r);\\n           \\n       }\\n        \\n        sort(a.begin(),a.end(),mycom); // sort according to position\\n        ///////////\\n        stack<tri> s;\\n        \\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(s.size()==0)// no one is their so just push\\n            {\\n                s.push(a[i]);\\n            }else \\n            {\\n                //0 means  left  1 means right\\n                \\n                if(a[i].d==0) // if new robot is left moving\\n                {\\n                   if(s.top().d==0)// previous robot also left moving means no collision will occur\\n                   {\\n                       s.push(a[i]);\\n                       \\n                       \\n                   }else// previous robot is right moving means no collision will occur\\n                   {\\n                       \\n                       int f=0;\\n                       while(!s.empty() && s.top().d==1)\\n                       {\\n                           if(s.top().h> a[i].h)  // if right moving robot has more health then current will die\\n                           {\\n                               s.top().h--;\\n                               f=1;  // new one dies\\n                               if(s.top().h==0) s.pop();\\n                               break;\\n                           }else if(s.top().h<a[i].h) // new robot has more health the previous right moving will die\\n                           {\\n                               s.pop();\\n                               a[i].h--;  // decrease by one\\n                           }else    // if both have same health both die\\n                           {\\n                               f=1;  // new one also dies\\n                               s.pop();\\n                               a[i].h--;\\n                               break;\\n                           }\\n                       }\\n                       //if new one is still alive\\n                       if(f==0) s.push(a[i]);\\n                   }\\n                    \\n                }else  // if new robot is right moving so no opposing will come as of now so push\\n                {\\n                    s.push(a[i]);\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        vector<int> ans;\\n        \\n        map<int,int> m; /// map will ensure the intial relative order bcz we are using idx as key\\n        \\n        while(!s.empty())\\n        {\\n            m[s.top().idx]=s.top().h;\\n            s.pop();\\n        }\\n        \\n        \\n        for(auto i: m)\\n        {\\n            ans.push_back(i.second);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```\\n\\n\\n```\\nTime Complexcity : O(NlogN) bcz sorting is involved\\nSpace : O(N)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Sorting"
                ],
                "code": "```Balanced parenthesis```\n```\\nclass Solution {\\npublic:\\n    \\n   \\n    struct tri{  // let\\'s define a structure for easy handling of all these features of robot\\n        int p;  // position\\n        int h;  // health\\n        int d; // direction\\n        int idx;  // index will be used in last during returning ans\\n    };\\n     static bool mycom (tri &a, tri &b)\\n    {\\n        return a.p<b.p;\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        \\n       vector<tri> a;\\n       \\n        int n=p.size();\\n       for(int i=0; i<n; i++)\\n       {\\n           tri r;\\n           r.p=p[i];\\n           r.h=h[i];\\n           r.d=d[i]==\\'R\\';\\n           r.idx=i;\\n           a.push_back(r);\\n           \\n       }\\n        \\n        sort(a.begin(),a.end(),mycom); // sort according to position\\n        ///////////\\n        stack<tri> s;\\n        \\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(s.size()==0)// no one is their so just push\\n            {\\n                s.push(a[i]);\\n            }else \\n            {\\n                //0 means  left  1 means right\\n                \\n                if(a[i].d==0) // if new robot is left moving\\n                {\\n                   if(s.top().d==0)// previous robot also left moving means no collision will occur\\n                   {\\n                       s.push(a[i]);\\n                       \\n                       \\n                   }else// previous robot is right moving means no collision will occur\\n                   {\\n                       \\n                       int f=0;\\n                       while(!s.empty() && s.top().d==1)\\n                       {\\n                           if(s.top().h> a[i].h)  // if right moving robot has more health then current will die\\n                           {\\n                               s.top().h--;\\n                               f=1;  // new one dies\\n                               if(s.top().h==0) s.pop();\\n                               break;\\n                           }else if(s.top().h<a[i].h) // new robot has more health the previous right moving will die\\n                           {\\n                               s.pop();\\n                               a[i].h--;  // decrease by one\\n                           }else    // if both have same health both die\\n                           {\\n                               f=1;  // new one also dies\\n                               s.pop();\\n                               a[i].h--;\\n                               break;\\n                           }\\n                       }\\n                       //if new one is still alive\\n                       if(f==0) s.push(a[i]);\\n                   }\\n                    \\n                }else  // if new robot is right moving so no opposing will come as of now so push\\n                {\\n                    s.push(a[i]);\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        vector<int> ans;\\n        \\n        map<int,int> m; /// map will ensure the intial relative order bcz we are using idx as key\\n        \\n        while(!s.empty())\\n        {\\n            m[s.top().idx]=s.top().h;\\n            s.pop();\\n        }\\n        \\n        \\n        for(auto i: m)\\n        {\\n            ans.push_back(i.second);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```\n```\\nTime Complexcity : O(NlogN) bcz sorting is involved\\nSpace : O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685457,
                "title": "stack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int> &positions, vector<int> &healths, string directions)\\n{\\n    int n = positions.size();\\n    \\n    // pos health index\\n    vector<pair<pair<int, int>, int>> pq(n);\\n    for (int i = 0; i < n; i++)\\n    {\\n        int hel = healths[i];\\n        if (directions[i] == \\'L\\')\\n        {\\n            hel *= -1;\\n        }\\n        pq[i] = {{positions[i], hel}, i};\\n    }\\n    sort(pq.begin(), pq.end());\\n\\n    // health index\\n    stack<pair<int, int>> st;\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (st.empty())\\n        {\\n            st.push({pq[i].first.second, pq[i].second});\\n        }\\n        else\\n        {\\n\\n            int tophel = st.top().first;\\n            int ind = st.top().second;\\n            \\n            //right,right   left,left    left,right\\n            if ((tophel > 0 && pq[i].first.second > 0) || (tophel < 0 && pq[i].first.second < 0) || (tophel < 0 && pq[i].first.second > 0))\\n            {\\n\\n                st.push({pq[i].first.second, pq[i].second});\\n            }\\n            else\\n            {\\n                if (abs(tophel) > abs(pq[i].first.second))\\n                {\\n                    auto it = st.top();\\n                    st.pop();\\n                    pair<int, int> pr = {it.first - 1, it.second};\\n                    st.push(pr);\\n                }\\n                else if (abs(tophel) == abs(pq[i].first.second))\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.pop();\\n                    if (pq[i].first.second < 0)\\n                    {\\n                        pq[i].first.second = -(abs(pq[i].first.second) - 1);\\n                    }\\n                    else\\n                    {\\n                        pq[i].first.second--;\\n                    }\\n\\n                    i--;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<int> ans;\\n    vector<pair<int, int>> z;\\n    while (!st.empty())\\n    {\\n        auto it = st.top();\\n        z.push_back({it.second, it.first});\\n        st.pop();\\n    }\\n    sort(z.begin(), z.end());\\n    for (auto it : z)\\n    {\\n        int val = abs(it.second);\\n        ans.push_back(val);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int> &positions, vector<int> &healths, string directions)\\n{\\n    int n = positions.size();\\n    \\n    // pos health index\\n    vector<pair<pair<int, int>, int>> pq(n);\\n    for (int i = 0; i < n; i++)\\n    {\\n        int hel = healths[i];\\n        if (directions[i] == \\'L\\')\\n        {\\n            hel *= -1;\\n        }\\n        pq[i] = {{positions[i], hel}, i};\\n    }\\n    sort(pq.begin(), pq.end());\\n\\n    // health index\\n    stack<pair<int, int>> st;\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (st.empty())\\n        {\\n            st.push({pq[i].first.second, pq[i].second});\\n        }\\n        else\\n        {\\n\\n            int tophel = st.top().first;\\n            int ind = st.top().second;\\n            \\n            //right,right   left,left    left,right\\n            if ((tophel > 0 && pq[i].first.second > 0) || (tophel < 0 && pq[i].first.second < 0) || (tophel < 0 && pq[i].first.second > 0))\\n            {\\n\\n                st.push({pq[i].first.second, pq[i].second});\\n            }\\n            else\\n            {\\n                if (abs(tophel) > abs(pq[i].first.second))\\n                {\\n                    auto it = st.top();\\n                    st.pop();\\n                    pair<int, int> pr = {it.first - 1, it.second};\\n                    st.push(pr);\\n                }\\n                else if (abs(tophel) == abs(pq[i].first.second))\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.pop();\\n                    if (pq[i].first.second < 0)\\n                    {\\n                        pq[i].first.second = -(abs(pq[i].first.second) - 1);\\n                    }\\n                    else\\n                    {\\n                        pq[i].first.second--;\\n                    }\\n\\n                    i--;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<int> ans;\\n    vector<pair<int, int>> z;\\n    while (!st.empty())\\n    {\\n        auto it = st.top();\\n        z.push_back({it.second, it.first});\\n        st.pop();\\n    }\\n    sort(z.begin(), z.end());\\n    for (auto it : z)\\n    {\\n        int val = abs(it.second);\\n        ans.push_back(val);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681929,
                "title": "java-o-nlogn-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Stack Datastructure\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Robot> robots = new ArrayList();\\n        for(int i=0;i<positions.length;i++) {\\n            robots.add(new Robot(i, positions[i], healths[i], directions.charAt(i)));\\n        }\\n        Collections.sort(robots);\\n        List<Robot> survived = new ArrayList<>();\\n        Stack<Robot> stack = new Stack<>();\\n        for(Robot robot: robots) {\\n            if(robot.dir == \\'R\\') {\\n                stack.push(robot);\\n                continue;\\n            }\\n            while(!stack.isEmpty() && robot.hlt > 0) {\\n                Robot peek = stack.peek();\\n                if(peek.hlt == robot.hlt) {\\n                    stack.pop();\\n                    robot.hlt = 0;\\n                } else if(peek.hlt > robot.hlt) {\\n                    robot.hlt = 0;\\n                    peek.hlt -= 1;\\n                } else {\\n                    stack.pop();\\n                    robot.hlt -= 1;\\n                }\\n            }\\n            if(robot.hlt > 0) survived.add(robot);\\n        }\\n        while(!stack.isEmpty()) {\\n            survived.add(stack.pop());\\n        }\\n        Collections.sort(survived, (o1, o2) -> o1.idx - o2.idx);\\n        return survived.stream().map(robot -> robot.hlt).collect(Collectors.toList());\\n    }\\n}\\n\\nclass Robot implements Comparable<Robot> {\\n    public int idx;\\n    public int pos;\\n    public int hlt;\\n    public char dir;\\n    \\n    public Robot(int i, int p, int h, char d) {\\n        idx = i;\\n        pos = p;\\n        hlt = h;\\n        dir = d;\\n    }\\n    \\n    @Override\\n    public int compareTo(Robot robot) {\\n        return this.pos - robot.pos;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Robot> robots = new ArrayList();\\n        for(int i=0;i<positions.length;i++) {\\n            robots.add(new Robot(i, positions[i], healths[i], directions.charAt(i)));\\n        }\\n        Collections.sort(robots);\\n        List<Robot> survived = new ArrayList<>();\\n        Stack<Robot> stack = new Stack<>();\\n        for(Robot robot: robots) {\\n            if(robot.dir == \\'R\\') {\\n                stack.push(robot);\\n                continue;\\n            }\\n            while(!stack.isEmpty() && robot.hlt > 0) {\\n                Robot peek = stack.peek();\\n                if(peek.hlt == robot.hlt) {\\n                    stack.pop();\\n                    robot.hlt = 0;\\n                } else if(peek.hlt > robot.hlt) {\\n                    robot.hlt = 0;\\n                    peek.hlt -= 1;\\n                } else {\\n                    stack.pop();\\n                    robot.hlt -= 1;\\n                }\\n            }\\n            if(robot.hlt > 0) survived.add(robot);\\n        }\\n        while(!stack.isEmpty()) {\\n            survived.add(stack.pop());\\n        }\\n        Collections.sort(survived, (o1, o2) -> o1.idx - o2.idx);\\n        return survived.stream().map(robot -> robot.hlt).collect(Collectors.toList());\\n    }\\n}\\n\\nclass Robot implements Comparable<Robot> {\\n    public int idx;\\n    public int pos;\\n    public int hlt;\\n    public char dir;\\n    \\n    public Robot(int i, int p, int h, char d) {\\n        idx = i;\\n        pos = p;\\n        hlt = h;\\n        dir = d;\\n    }\\n    \\n    @Override\\n    public int compareTo(Robot robot) {\\n        return this.pos - robot.pos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681077,
                "title": "sort-stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        \\n        vector<vector<int>> v;\\n        for(int i=0; i<n; i++) {\\n            int d = directions[i] == \\'R\\' ? 1 : 0;\\n            v.push_back({positions[i], healths[i], d, i});\\n        }\\n        sort(v.begin(), v.end());\\n        \\n        stack<vector<int>> s;\\n        \\n        for(auto i : v) {\\n            if(!s.size()) s.push(i);\\n            else {\\n                if((s.top()[2] == 0 && i[2] == 0) || (s.top()[2] == 0 && i[2] == 1) || (s.top()[2] == 1 && i[2] == 1)) {\\n                    s.push(i);\\n                    continue;\\n                }\\n                int cnt = 0, f = 0;\\n                while(s.size() && s.top()[2] == 1 && i[2] == 0 && s.top()[1] <= i[1] - cnt) {\\n                    if(s.top()[1] == i[1] - cnt) {\\n                        s.pop();\\n                        f = 1;\\n                        break;\\n                    }\\n                    s.pop(), cnt++;\\n                }\\n                if(!f) {\\n                    if(s.size() && s.top()[1] > i[1] - cnt && (s.top()[2] == 1 && i[2] == 0)) {\\n                        auto t = s.top(); s.pop();\\n                        s.push({t[0], t[1] - 1, t[2], t[3]});\\n                    }\\n                    else s.push({i[0], i[1] - cnt, i[2], i[3]});\\n                }\\n            }\\n        }\\n        vector<int> a(n), ans;\\n        while(s.size()) {\\n            auto t = s.top(); s.pop();\\n            a[t[3]] = t[1];\\n        }\\n        for(int i : a) {\\n            if(i) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        \\n        vector<vector<int>> v;\\n        for(int i=0; i<n; i++) {\\n            int d = directions[i] == \\'R\\' ? 1 : 0;\\n            v.push_back({positions[i], healths[i], d, i});\\n        }\\n        sort(v.begin(), v.end());\\n        \\n        stack<vector<int>> s;\\n        \\n        for(auto i : v) {\\n            if(!s.size()) s.push(i);\\n            else {\\n                if((s.top()[2] == 0 && i[2] == 0) || (s.top()[2] == 0 && i[2] == 1) || (s.top()[2] == 1 && i[2] == 1)) {\\n                    s.push(i);\\n                    continue;\\n                }\\n                int cnt = 0, f = 0;\\n                while(s.size() && s.top()[2] == 1 && i[2] == 0 && s.top()[1] <= i[1] - cnt) {\\n                    if(s.top()[1] == i[1] - cnt) {\\n                        s.pop();\\n                        f = 1;\\n                        break;\\n                    }\\n                    s.pop(), cnt++;\\n                }\\n                if(!f) {\\n                    if(s.size() && s.top()[1] > i[1] - cnt && (s.top()[2] == 1 && i[2] == 0)) {\\n                        auto t = s.top(); s.pop();\\n                        s.push({t[0], t[1] - 1, t[2], t[3]});\\n                    }\\n                    else s.push({i[0], i[1] - cnt, i[2], i[3]});\\n                }\\n            }\\n        }\\n        vector<int> a(n), ans;\\n        while(s.size()) {\\n            auto t = s.top(); s.pop();\\n            a[t[3]] = t[1];\\n        }\\n        for(int i : a) {\\n            if(i) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681008,
                "title": "rust-sorting-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nAssume the positions are listed in asceending order. With a vector and a stack, we iterate through the array:\\n1) if a robot is moving right, we push it to the stack;\\n2) consolidate the the left moving robot with those right moving robots in the reverse order until stablized. At the end, we have one of the following three possibilities:\\na) the left moving robot cancels one or more right moving robots;\\nb) the end result is a right moving robot, leaving it on the stack;\\nc) the end result is a left moving robot, add it the end of the vector.\\n3) collect all entreies from the stack and append them to the end of the vector.\\n\\nTo deal with the situation when positions are not listed in ascending order:\\n1) we introduce a vector with the values and indexes of positions;\\n2) sort the vector based on the values of positions.\\n3) solve the problem with associated the final position of a robot with its original index.\\n4) sort the final positions based on their indexes.\\n\\n  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn survived_robots_healths(positions: Vec<i32>, healths: Vec<i32>, directions: String) -> Vec<i32> {\\n        let n = positions.len();\\n        let mut p = (0 .. n).map(|i| (positions[i], i)).collect::<Vec<(i32, usize)>>();\\n        p.sort();\\n\\n        let directions = directions.chars().into_iter().collect::<Vec<char>>();\\n        let (mut temp, mut sk) = (vec![], vec![]);\\n        for i in 0 .. n {\\n            let k = p[i].1;\\n            \\n            if directions[k] == \\'R\\' {\\n                sk.push((k, healths[k]));\\n                continue\\n            }\\n            \\n            let mut h = healths[k];\\n            while sk.is_empty() == false {\\n                let sz = sk.len();\\n                if sk[sz - 1].1 >= h { break }\\n                h -= 1;\\n                sk.pop(); \\n            }\\n\\n            if sk.is_empty() == false {\\n                let sz = sk.len();\\n                if sk[sz - 1].1 == h {\\n                    sk.pop();\\n                    continue\\n                }\\n                sk[sz - 1].1 -= 1;\\n                continue\\n            }\\n            temp.push((k, h));\\n        }\\n        for (i, h) in sk { temp.push((i, h)); }\\n        temp.sort();\\n\\n        temp.into_iter().map(|a| a.1).collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn survived_robots_healths(positions: Vec<i32>, healths: Vec<i32>, directions: String) -> Vec<i32> {\\n        let n = positions.len();\\n        let mut p = (0 .. n).map(|i| (positions[i], i)).collect::<Vec<(i32, usize)>>();\\n        p.sort();\\n\\n        let directions = directions.chars().into_iter().collect::<Vec<char>>();\\n        let (mut temp, mut sk) = (vec![], vec![]);\\n        for i in 0 .. n {\\n            let k = p[i].1;\\n            \\n            if directions[k] == \\'R\\' {\\n                sk.push((k, healths[k]));\\n                continue\\n            }\\n            \\n            let mut h = healths[k];\\n            while sk.is_empty() == false {\\n                let sz = sk.len();\\n                if sk[sz - 1].1 >= h { break }\\n                h -= 1;\\n                sk.pop(); \\n            }\\n\\n            if sk.is_empty() == false {\\n                let sz = sk.len();\\n                if sk[sz - 1].1 == h {\\n                    sk.pop();\\n                    continue\\n                }\\n                sk[sz - 1].1 -= 1;\\n                continue\\n            }\\n            temp.push((k, h));\\n        }\\n        for (i, h) in sk { temp.push((i, h)); }\\n        temp.sort();\\n\\n        temp.into_iter().map(|a| a.1).collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680980,
                "title": "easiest-simplest-c-stack-only-no-class",
                "content": "**ATLASSIAN 2023 INTERN** Question\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple Just keep adding all robots going to R and when Robots goes to L, Just see if the health of robot at top having health less then equal to or higher then health at top. if equal simply set both healths to 0. else if the one having lesser health make it 0 and decrease other one by 1. Make sure to use While loop till health at top of stack index is not greater then current.\\n\\nYou Know what calculation is Just having bit calculation but toughest part is to recall healths in same order as given.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string d) {\\n\\n         vector<pair<int,int>>v ;\\n          int n=pos.size() ;\\n         for(int  i=0;i<n;i++) {\\n             \\n             v.push_back({pos[i],i}) ;\\n         }\\n        \\n        sort(v.begin(),v.end()) ;\\n        \\n         stack<int>st ;\\n         \\n         \\n         for(int i=0;i<n;i++) {\\n              int ind=v[i].second ;\\n               char dir=d[ind] ;\\n               \\n               if(dir==\\'L\\') \\n               {\\n                  \\n                    if(st.empty()) {\\n                        st.push(ind) ;  \\n                    }\\n                   else {\\n                       \\n                        if(d[st.top()]==\\'R\\' && h[st.top()] ==h[ind]) // when same health\\n                        {\\n                             h[st.top()]=0 ;\\n                             st.pop() ;\\n                             h[ind]=0 ;\\n                           \\n                        }\\n                       else{ \\n                       \\n                        while(!st.empty() && d[st.top()]==\\'R\\' && h[st.top()] < h[ind] )\\n                        {\\n                             h[st.top()]=0 ;\\n                            st.pop();\\n                            h[ind]--;\\n                        }\\n                       // left robot moving in right direction and health is greater than curr robot\\n                        if(!st.empty() &&  d[st.top()]==\\'R\\' && h[st.top()] > h[ind]) {\\n                            h[st.top()]--; \\n                            h[ind]=0 ;\\n                        }\\n                       // left robot moving in right direction and health is  equal to curr robot\\n                          else  if(!st.empty() &&  d[st.top()]==\\'R\\' && h[st.top()] == h[ind]) {\\n                            h[st.top()]=0; \\n                            h[ind]=0 ;\\n                                st.pop();\\n                        }\\n                       else{\\n                           st.push(ind) ;\\n                       }\\n                       }\\n                        \\n                   }\\n               } \\n     // moving in right direction, collison is not possible with behind this robot\\n             else{\\n                 st.push(ind) ;     \\n             }\\n         }\\n        \\n         vector<int>ans;\\n        \\n         for(int x:h) {\\n             if(x >0) ans.push_back(x) ; \\n         }\\n        \\n         return ans;\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string d) {\\n\\n         vector<pair<int,int>>v ;\\n          int n=pos.size() ;\\n         for(int  i=0;i<n;i++) {\\n             \\n             v.push_back({pos[i],i}) ;\\n         }\\n        \\n        sort(v.begin(),v.end()) ;\\n        \\n         stack<int>st ;\\n         \\n         \\n         for(int i=0;i<n;i++) {\\n              int ind=v[i].second ;\\n               char dir=d[ind] ;\\n               \\n               if(dir==\\'L\\') \\n               {\\n                  \\n                    if(st.empty()) {\\n                        st.push(ind) ;  \\n                    }\\n                   else {\\n                       \\n                        if(d[st.top()]==\\'R\\' && h[st.top()] ==h[ind]) // when same health\\n                        {\\n                             h[st.top()]=0 ;\\n                             st.pop() ;\\n                             h[ind]=0 ;\\n                           \\n                        }\\n                       else{ \\n                       \\n                        while(!st.empty() && d[st.top()]==\\'R\\' && h[st.top()] < h[ind] )\\n                        {\\n                             h[st.top()]=0 ;\\n                            st.pop();\\n                            h[ind]--;\\n                        }\\n                       // left robot moving in right direction and health is greater than curr robot\\n                        if(!st.empty() &&  d[st.top()]==\\'R\\' && h[st.top()] > h[ind]) {\\n                            h[st.top()]--; \\n                            h[ind]=0 ;\\n                        }\\n                       // left robot moving in right direction and health is  equal to curr robot\\n                          else  if(!st.empty() &&  d[st.top()]==\\'R\\' && h[st.top()] == h[ind]) {\\n                            h[st.top()]=0; \\n                            h[ind]=0 ;\\n                                st.pop();\\n                        }\\n                       else{\\n                           st.push(ind) ;\\n                       }\\n                       }\\n                        \\n                   }\\n               } \\n     // moving in right direction, collison is not possible with behind this robot\\n             else{\\n                 st.push(ind) ;     \\n             }\\n         }\\n        \\n         vector<int>ans;\\n        \\n         for(int x:h) {\\n             if(x >0) ans.push_back(x) ; \\n         }\\n        \\n         return ans;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680735,
                "title": "easy-implementation-using-stack-and-sorting-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        stack<pair<int,int>>left,right;\\n        int n = positions.size();\\n        vector<pair<int,pair<int,int>>>vp;\\n        for(int i=0; i<n; i++){\\n            vp.push_back({positions[i],{i,healths[i]}});\\n        }\\n        sort(vp.begin(),vp.end());\\n        for(int i=0; i<n; i++){\\n            int h = vp[i].second.second;\\n            int id = vp[i].second.first;\\n            if(directions[id] == \\'L\\'){\\n                while(!right.empty() && h > 0){\\n                    // cout<<h<<\"  \"<<right.top() << endl;\\n                    if(right.top().second == h){\\n                        right.pop();\\n                        h = 0;\\n                    }\\n                    else if(right.top().second > h){\\n                        int tempId = right.top().first;\\n                        int tempH = right.top().second;\\n                        right.pop();\\n                        right.push({tempId,tempH-1});\\n                        h = 0;\\n                    }\\n                    else{\\n                        right.pop();\\n                        h--;\\n                    }\\n                }\\n                if(h > 0) left.push({id,h});\\n            }\\n            else{\\n                right.push({id,h});\\n            }\\n        }\\n        vector<pair<int,int>>vp2;\\n        vector<int>ans;\\n        while(!left.empty()){\\n            vp2.push_back(left.top());\\n            left.pop();\\n        }\\n        while(!right.empty()){\\n            vp2.push_back(right.top());\\n            right.pop();\\n        }\\n        sort(vp2.begin(), vp2.end());\\n        for(auto i:vp2){\\n            ans.push_back(i.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        stack<pair<int,int>>left,right;\\n        int n = positions.size();\\n        vector<pair<int,pair<int,int>>>vp;\\n        for(int i=0; i<n; i++){\\n            vp.push_back({positions[i],{i,healths[i]}});\\n        }\\n        sort(vp.begin(),vp.end());\\n        for(int i=0; i<n; i++){\\n            int h = vp[i].second.second;\\n            int id = vp[i].second.first;\\n            if(directions[id] == \\'L\\'){\\n                while(!right.empty() && h > 0){\\n                    // cout<<h<<\"  \"<<right.top() << endl;\\n                    if(right.top().second == h){\\n                        right.pop();\\n                        h = 0;\\n                    }\\n                    else if(right.top().second > h){\\n                        int tempId = right.top().first;\\n                        int tempH = right.top().second;\\n                        right.pop();\\n                        right.push({tempId,tempH-1});\\n                        h = 0;\\n                    }\\n                    else{\\n                        right.pop();\\n                        h--;\\n                    }\\n                }\\n                if(h > 0) left.push({id,h});\\n            }\\n            else{\\n                right.push({id,h});\\n            }\\n        }\\n        vector<pair<int,int>>vp2;\\n        vector<int>ans;\\n        while(!left.empty()){\\n            vp2.push_back(left.top());\\n            left.pop();\\n        }\\n        while(!right.empty()){\\n            vp2.push_back(right.top());\\n            right.pop();\\n        }\\n        sort(vp2.begin(), vp2.end());\\n        for(auto i:vp2){\\n            ans.push_back(i.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3680513,
                "title": "javascript-stack",
                "content": "**Solution: Stack**\\n\\nNote: The positions don\\'t affect which robots will collide with each other, this stays the same no matter what. Robots adjacent to each other going right and left will always collide.\\nIn the stack, keep track of robots we have processed so far that have still survived.\\n\\nIf the current robot is going left,\\n*   We need to eliminate all right-going robots with smaller health at the top of the stack, while decreasing the health of the current robot. \\n*   If the robot at the top of the stack is right-going and the health is greater, then remove the current robot and decrease the health of the robot at the top of the stack.\\n*   If the robot at the top of the stack is right-going and the health is the same, remove both.\\n\\nIf the current robot is going right, then just push it onto the stack to be dealt with later.\\n\\n`n = number of robots`\\nTime Complexity: `O(n log(n))` \\nSpace Complexity: `O(n)` \\n```\\nvar survivedRobotsHealths = function(positions, healths, directions) {\\n  let n = positions.length, stack = [], robots = [];\\n  for (let i = 0; i < n; i++) {\\n    robots.push({position: positions[i], health: healths[i], direction: directions[i], originalIndex: i})\\n  }\\n  robots.sort((a, b) => a.position - b.position); \\n  for (let i = 0; i < n; i++) {\\n    if (robots[i].direction === \\'L\\') {\\n      // remove right-going robots with smaller health from the top of the stack while decreasing the current robot\\'s health\\n      while (stack.length && robots[stack[stack.length - 1]].direction === \\'R\\' && robots[stack[stack.length - 1]].health < robots[i].health) {\\n        stack.pop();\\n        robots[i].health--;\\n      }\\n      if (stack.length === 0 || robots[stack[stack.length - 1]].direction === \\'L\\') stack.push(i); // no more collisions, add current robot to stack\\n      else if (stack.length > 0 && robots[stack[stack.length - 1]].health === robots[i].health) stack.pop(); // health is same, remove both\\n      else if (stack.length > 0 && robots[stack[stack.length - 1]].health > robots[i].health) robots[stack[stack.length - 1]].health--; // right-going robot has greater health, remove current robot and decrease right-going robot\\'s health\\n    } else {\\n      stack.push(i);\\n    }\\n  }\\n  return stack.sort((a, b) => robots[a].originalIndex - robots[b].originalIndex).map((i) => robots[i].health);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar survivedRobotsHealths = function(positions, healths, directions) {\\n  let n = positions.length, stack = [], robots = [];\\n  for (let i = 0; i < n; i++) {\\n    robots.push({position: positions[i], health: healths[i], direction: directions[i], originalIndex: i})\\n  }\\n  robots.sort((a, b) => a.position - b.position); \\n  for (let i = 0; i < n; i++) {\\n    if (robots[i].direction === \\'L\\') {\\n      // remove right-going robots with smaller health from the top of the stack while decreasing the current robot\\'s health\\n      while (stack.length && robots[stack[stack.length - 1]].direction === \\'R\\' && robots[stack[stack.length - 1]].health < robots[i].health) {\\n        stack.pop();\\n        robots[i].health--;\\n      }\\n      if (stack.length === 0 || robots[stack[stack.length - 1]].direction === \\'L\\') stack.push(i); // no more collisions, add current robot to stack\\n      else if (stack.length > 0 && robots[stack[stack.length - 1]].health === robots[i].health) stack.pop(); // health is same, remove both\\n      else if (stack.length > 0 && robots[stack[stack.length - 1]].health > robots[i].health) robots[stack[stack.length - 1]].health--; // right-going robot has greater health, remove current robot and decrease right-going robot\\'s health\\n    } else {\\n      stack.push(i);\\n    }\\n  }\\n  return stack.sort((a, b) => robots[a].originalIndex - robots[b].originalIndex).map((i) => robots[i].health);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680398,
                "title": "c-stack-explained-and-commented",
                "content": "This problem would be easy enough if you solve the problem \"Asteroid Collision\". Unfortunately, I missed this problem in contest by merely 3 min \\uD83D\\uDE22\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string dir) {\\n        vector<vector<int>> vec; int n= pos.size();\\n        for(int i=0; i<n; i++){\\n            int health= (dir[i]==\\'R\\') ? h[i] : (-1)*h[i]; // Sign represent direction. If direction is \\'L\\' , make health -ve (same as asteroid collision) \\n\\t\\t\\t// as we need to return answer in the order they were given in the input, so we will carry the actual index throughout.\\n            vec.push_back({pos[i], health, i});  // {position, health, actualIndex}\\n        }\\n        \\n        sort(vec.begin(), vec.end()); // sort them in the order of their positions\\n        stack<vector<int>> stk; // {health, actualIndex}\\n        \\n        for(int i=0; i<vec.size(); i++){\\n            int health= vec[i][1]; int idx= vec[i][2]; \\n            if(stk.empty()){ // If stack is empty, simply push it\\n                stk.push({health, idx});\\n            }\\n            else if(stk.top()[0]>0 && health<0){ // opposite moving (towards each other) --> Collission\\n                while(!stk.empty() && (stk.top()[0]>0 && health<0) && stk.top()[0] < (abs)(health)){\\n\\t\\t\\t\\t\\t// run loop till currentHealth is greater in magnitude than stack top [as it will destroy stack top, so pop it]\\n                    stk.pop();\\n                    health++; // also after collision, currentHealth will decreament by one ( as health <0, so decreament means ++)\\n                }\\n                if(!stk.empty() && stk.top()[0]==(abs)(health)){  // stack top == currentHealth --> Both will collide and destroy each other\\n\\t\\t\\t\\t\\t// pop top and ignore health (desttoy both top and health)\\n                    stk.pop(); continue;\\n                }\\n                else if(!stk.empty() && stk.top()[0] > (abs)(health)){  // stack top  > currHealth, they will collide and stack top decreaments\\n\\t\\t\\t\\t\\t// reduce top value by 1 and destroy health\\n                    int top= stk.top()[0]; int i= stk.top()[1]; stk.pop(); top--;\\n                    stk.push({top, i});\\n                    continue;\\n                }\\n                stk.push({health, idx}); // if all above conditions fails, then currentHealth can be safely pushed into stack\\n            }\\n            else if(stk.top()[0]>0 && health>0 || stk.top()[0]<0 && health<0){ // top and health are in same direction --> No collision\\n                stk.push({health, idx});\\n            }\\n            else if(stk.top()[0]<0 && health>0){ // they are moving in opposite direction (away) --> No collision \\n                stk.push({health, idx});\\n            }\\n        }\\n        vector<vector<int>> temp;  // { actualIndex of remaining Health, remaining healths }\\n        while(!stk.empty()){\\n            temp.push_back({stk.top()[1], stk.top()[0]}); stk.pop();\\n        }\\n        \\n        sort(temp.begin(), temp.end()); // sort in increasing order of actualIndex [as we need to return answer in the order they were given in the input]\\n        vector<int> ans;\\n        for(int i=0; i<temp.size(); i++){\\n            ans.push_back((abs)(temp[i][1])); // take absolute value of health as it can be <0 \\n        }\\n        return ans; // finalAnswer\\n    }\\n};\\n```\\nHope this code is understandable.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string dir) {\\n        vector<vector<int>> vec; int n= pos.size();\\n        for(int i=0; i<n; i++){\\n            int health= (dir[i]==\\'R\\') ? h[i] : (-1)*h[i]; // Sign represent direction. If direction is \\'L\\' , make health -ve (same as asteroid collision) \\n\\t\\t\\t// as we need to return answer in the order they were given in the input, so we will carry the actual index throughout.\\n            vec.push_back({pos[i], health, i});  // {position, health, actualIndex}\\n        }\\n        \\n        sort(vec.begin(), vec.end()); // sort them in the order of their positions\\n        stack<vector<int>> stk; // {health, actualIndex}\\n        \\n        for(int i=0; i<vec.size(); i++){\\n            int health= vec[i][1]; int idx= vec[i][2]; \\n            if(stk.empty()){ // If stack is empty, simply push it\\n                stk.push({health, idx});\\n            }\\n            else if(stk.top()[0]>0 && health<0){ // opposite moving (towards each other) --> Collission\\n                while(!stk.empty() && (stk.top()[0]>0 && health<0) && stk.top()[0] < (abs)(health)){\\n\\t\\t\\t\\t\\t// run loop till currentHealth is greater in magnitude than stack top [as it will destroy stack top, so pop it]\\n                    stk.pop();\\n                    health++; // also after collision, currentHealth will decreament by one ( as health <0, so decreament means ++)\\n                }\\n                if(!stk.empty() && stk.top()[0]==(abs)(health)){  // stack top == currentHealth --> Both will collide and destroy each other\\n\\t\\t\\t\\t\\t// pop top and ignore health (desttoy both top and health)\\n                    stk.pop(); continue;\\n                }\\n                else if(!stk.empty() && stk.top()[0] > (abs)(health)){  // stack top  > currHealth, they will collide and stack top decreaments\\n\\t\\t\\t\\t\\t// reduce top value by 1 and destroy health\\n                    int top= stk.top()[0]; int i= stk.top()[1]; stk.pop(); top--;\\n                    stk.push({top, i});\\n                    continue;\\n                }\\n                stk.push({health, idx}); // if all above conditions fails, then currentHealth can be safely pushed into stack\\n            }\\n            else if(stk.top()[0]>0 && health>0 || stk.top()[0]<0 && health<0){ // top and health are in same direction --> No collision\\n                stk.push({health, idx});\\n            }\\n            else if(stk.top()[0]<0 && health>0){ // they are moving in opposite direction (away) --> No collision \\n                stk.push({health, idx});\\n            }\\n        }\\n        vector<vector<int>> temp;  // { actualIndex of remaining Health, remaining healths }\\n        while(!stk.empty()){\\n            temp.push_back({stk.top()[1], stk.top()[0]}); stk.pop();\\n        }\\n        \\n        sort(temp.begin(), temp.end()); // sort in increasing order of actualIndex [as we need to return answer in the order they were given in the input]\\n        vector<int> ans;\\n        for(int i=0; i<temp.size(); i++){\\n            ans.push_back((abs)(temp[i][1])); // take absolute value of health as it can be <0 \\n        }\\n        return ans; // finalAnswer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679999,
                "title": "c-hash-map-detailed-explanation",
                "content": "# Approach\\n- Firstly we can separate left direction and right direction robots because the right moving robots will collide with left moving only.\\n- This separation can be done in 2 maps left and right.\\n- We will sort the right map in decreasing order of position.\\n- Now we will iterate on the right map and since the first value is the highest right position, we will choose it\\'s lowerbound position in the left map and according to the health, we will move the iterator.\\n- This way we will get the final survivors.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& hel, string dir) {\\n        map<int,int,greater<int>> r;\\n        map<int,int> l;\\n        int n = pos.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dir[i]==\\'L\\')\\n            {\\n                l[pos[i]] = hel[i];\\n            }\\n            else\\n                r[pos[i]] = hel[i];\\n        }\\n        \\n        auto it1 = r.begin();\\n        while(it1!=r.end())\\n        {\\n            auto it2 = l.lower_bound(it1->first);\\n            if(it2!=l.end())\\n            {\\n                if(it1->second>it2->second)\\n                {\\n                    it1->second--;\\n                    l.erase(it2);\\n                }\\n                else if(it1->second<it2->second)\\n                {\\n                    it2->second--;\\n                    it1->second = -1;\\n                    it1++;\\n                }\\n                else\\n                {\\n                    l.erase(it2);\\n                    it1->second = -1;\\n                    it1++;\\n                }\\n            }\\n            else\\n                it1++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dir[i]==\\'L\\')\\n            {\\n                if(l.find(pos[i])!=l.end())\\n                {\\n                    if(l[pos[i]]>0)\\n                        ans.push_back(l[pos[i]]);\\n                }\\n            }\\n            else if(dir[i]==\\'R\\')\\n            {\\n                if(r.find(pos[i])!=r.end())\\n                {\\n                    if(r[pos[i]]>0)\\n                        ans.push_back(r[pos[i]]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& hel, string dir) {\\n        map<int,int,greater<int>> r;\\n        map<int,int> l;\\n        int n = pos.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dir[i]==\\'L\\')\\n            {\\n                l[pos[i]] = hel[i];\\n            }\\n            else\\n                r[pos[i]] = hel[i];\\n        }\\n        \\n        auto it1 = r.begin();\\n        while(it1!=r.end())\\n        {\\n            auto it2 = l.lower_bound(it1->first);\\n            if(it2!=l.end())\\n            {\\n                if(it1->second>it2->second)\\n                {\\n                    it1->second--;\\n                    l.erase(it2);\\n                }\\n                else if(it1->second<it2->second)\\n                {\\n                    it2->second--;\\n                    it1->second = -1;\\n                    it1++;\\n                }\\n                else\\n                {\\n                    l.erase(it2);\\n                    it1->second = -1;\\n                    it1++;\\n                }\\n            }\\n            else\\n                it1++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dir[i]==\\'L\\')\\n            {\\n                if(l.find(pos[i])!=l.end())\\n                {\\n                    if(l[pos[i]]>0)\\n                        ans.push_back(l[pos[i]]);\\n                }\\n            }\\n            else if(dir[i]==\\'R\\')\\n            {\\n                if(r.find(pos[i])!=r.end())\\n                {\\n                    if(r[pos[i]]>0)\\n                        ans.push_back(r[pos[i]]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679766,
                "title": "beautifully-explained-cpp-code-stack-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we can see the problem we can see that there are few things that need to be concerned,\\n1. The only way the robots will collide is robot from left side is moving towards right and the right side robot will move towrds left.\\n2. If there is any collision then we have to go through 3 scenarios.\\n    - Health of both of the robots are equal\\n        In which we will remove both robots\\n    - Health of left side robot is greater than right side robot\\n        In which we have to ignore the right side robot,and decrement the health of left side robot by 1.\\n    - Health of right side robot is greater than left side robot.\\n        In which the left side robot will be removed, and after decrementing the health of right side robot, it will be moving in its direction.\\n3. If there isn\\'t any kind of collisions then its good to go.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all for simplicity of the problem we are going to sort the array according to their positions. and we are going to keep record of positions, health, index in positions, directions as below\\n```\\nElement = {position, {direction, {health, index in position}}}\\n\\n```\\n\\nHere, we are going to use here stack because of following reasons,\\n- If we are going to remove the left side robot then we have to check for the condition in which right side robot can collide with previous robot of current left side robot. So, to keep track of that we have to use stack. \\n(case : RRL)\\n\\n```\\nnow while(!st.empty()) check that whether there is any possible collide with rightRobot or not,\\nand if there is any collision then try to avoid that using below conditions.\\n\\nFor here we are going to have 3 coditions for collisions:\\n1. if st.top().health == rightRobot.health\\n    st.pop() \\n    dont add the rightRobot\\n2. if st.top().health > rightRobot.health\\n    decrement the health of left robot by 1\\n    and ignore the rightRobot as its destroyed\\n3. if st.top().health < rightRobot.health\\n    firstly decerment rightRobot.health by 1\\n    And go to while loop again\\n\\n```\\n\\nNow after going through all the elements, we have to return the robots which have survived through collisions, So, we will copy their index and health from stack.\\n\\nSo, now we will sort them to get in the order of index. and then we will copy them into result vector.\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& health, string directions) {\\n        vector<pair<int, pair<char, pair<int, int>>>> arr;\\n        int n = positions.size();\\n        \\n        for(int i=0;i<n;i++){\\n            arr.push_back({positions[i], {directions[i],{health[i], i}}});\\n        }\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        stack<pair<int, pair<char, pair<int, int>>>> st;\\n        \\n        for(int i=0;i<n;i++){\\n            if(st.empty()) st.push(arr[i]);\\n            else{\\n                if(arr[i].second.first == \\'L\\'){\\n                    bool take = true;\\n                    while(!st.empty() && (st.top().second.first == \\'R\\' && arr[i].second.first == \\'L\\')){\\n                        int health = st.top().second.second.first;\\n                        if(health == arr[i].second.second.first){\\n                            st.pop();\\n                            take = false;\\n                            break;\\n                        }\\n                        else{\\n                            if(health > arr[i].second.second.first){\\n                                st.top().second.second.first--;\\n                                take = false;\\n                                break;\\n                            }else{\\n                                arr[i].second.second.first--;\\n                                st.pop();\\n                            }\\n                        }\\n                    }\\n                    if(take) st.push(arr[i]);\\n                }else{\\n                    st.push(arr[i]);\\n                }\\n            }\\n        }\\n        \\n        vector<pair<int, int>> tmp;\\n        vector<int> res;\\n        \\n        while(!st.empty()){\\n            tmp.push_back({st.top().second.second.second, st.top().second.second.first});\\n            st.pop();\\n        }\\n        \\n        sort(tmp.begin(), tmp.end());\\n        \\n        for(auto it: tmp){\\n            res.push_back(it.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nPlease upvote if you find it helpful & Best of Luck for your future : )",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nElement = {position, {direction, {health, index in position}}}\\n\\n```\n```\\nnow while(!st.empty()) check that whether there is any possible collide with rightRobot or not,\\nand if there is any collision then try to avoid that using below conditions.\\n\\nFor here we are going to have 3 coditions for collisions:\\n1. if st.top().health == rightRobot.health\\n    st.pop() \\n    dont add the rightRobot\\n2. if st.top().health > rightRobot.health\\n    decrement the health of left robot by 1\\n    and ignore the rightRobot as its destroyed\\n3. if st.top().health < rightRobot.health\\n    firstly decerment rightRobot.health by 1\\n    And go to while loop again\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& health, string directions) {\\n        vector<pair<int, pair<char, pair<int, int>>>> arr;\\n        int n = positions.size();\\n        \\n        for(int i=0;i<n;i++){\\n            arr.push_back({positions[i], {directions[i],{health[i], i}}});\\n        }\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        stack<pair<int, pair<char, pair<int, int>>>> st;\\n        \\n        for(int i=0;i<n;i++){\\n            if(st.empty()) st.push(arr[i]);\\n            else{\\n                if(arr[i].second.first == \\'L\\'){\\n                    bool take = true;\\n                    while(!st.empty() && (st.top().second.first == \\'R\\' && arr[i].second.first == \\'L\\')){\\n                        int health = st.top().second.second.first;\\n                        if(health == arr[i].second.second.first){\\n                            st.pop();\\n                            take = false;\\n                            break;\\n                        }\\n                        else{\\n                            if(health > arr[i].second.second.first){\\n                                st.top().second.second.first--;\\n                                take = false;\\n                                break;\\n                            }else{\\n                                arr[i].second.second.first--;\\n                                st.pop();\\n                            }\\n                        }\\n                    }\\n                    if(take) st.push(arr[i]);\\n                }else{\\n                    st.push(arr[i]);\\n                }\\n            }\\n        }\\n        \\n        vector<pair<int, int>> tmp;\\n        vector<int> res;\\n        \\n        while(!st.empty()){\\n            tmp.push_back({st.top().second.second.second, st.top().second.second.first});\\n            st.pop();\\n        }\\n        \\n        sort(tmp.begin(), tmp.end());\\n        \\n        for(auto it: tmp){\\n            res.push_back(it.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679418,
                "title": "simple-c-solution-using-stack-and-sorting",
                "content": "# Intuition\\nThe first approach that comes across is the collision will only take place when we have a robot moving towards the left just after a robot moving towards right. So we can use a stack to store the most recent robot moving towards. When we encounter a robot moving towards left we can perform required operation mentioned in the question for collision.\\n# Approach\\nSince the question doesn\\'t provide the positions in sorted manner we need to first sort the positions alongwith health and modify the direction string.\\n```\\nstring str;\\nvector<pair<int, pair<int, int>>> v;\\nfor(int i=0; i<n; i++){\\n    v.push_back(make_pair(p[i], make_pair(h[i], i)));\\n    m[p[i]]=i;\\n}\\nsort(v.begin(), v.end());\\nfor(int i=0; i<n; i++){\\n    str+=d[v[i].second.second];\\n}\\n``` \\nNow there is a bit of issue here we can sort the positions for getting the solutions but in the return value we need the solution vector to be of same order as the input. To tackle this we can use a map to store the indices of the position before sorting. \\n```\\nmap<int, int> m;\\nfor(int i=0; i<n; i++){\\n    m[p[i]]=i;\\n}\\n```\\nNow we can intialize the stack of pair which store the pair of values as (health, position). The postion value is needed to find the original index of the robot.\\n```\\nstack<pair<int, int>> s;\\nvector<int> ans(n, -1);\\nfor(int i=0; i<n; i++){\\n    if(str[i]==\\'L\\'){\\n        int x = v[i].second.first;\\n        bool check=true; // checks if the current robot is destroyed\\n        while(!s.empty()){\\n            pair<int, int> temp = s.top();\\n            s.pop();\\n            if(temp.first>x){ // robot moving in right has greater health than the curr robot\\n                temp.first--;\\n                check=false;\\n                s.push(temp);\\n                break;\\n            }\\n            else if(temp.first==x){ // both the robots have same health value\\n                check=false;\\n                break;\\n            }\\n            else{ // curr robot has higher health value and continuous moving in left direction\\n                x--;\\n            }\\n        }\\n        if(check) ans[m[v[i].first]]=x; // the robot has destroyed all the robots in its path\\n    }\\n    else{\\n        s.push({v[i].second.first, v[i].first}); // the curr robot is moving right direction\\n    }\\n}\\n```\\nFinally we need to check if there are still any robots moving in the right direction and map there position to the health value.\\n```\\nwhile(!s.empty()){\\n    pair<int, int> temp = s.top();\\n    s.pop();\\n    int pos = m[temp.second];\\n    ans[pos]=temp.first;\\n}\\n```\\n# Complexity\\n- Time complexity: O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        int n = d.length();\\n        string str;\\n        vector<pair<int, pair<int, int>>> v;\\n        map<int, int> m;\\n        for(int i=0; i<n; i++){\\n            v.push_back(make_pair(p[i], make_pair(h[i], i)));\\n            m[p[i]]=i;\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<n; i++){\\n            str+=d[v[i].second.second];\\n        }\\n        stack<pair<int, int>> s;\\n        vector<int> ans(n, -1);\\n        for(int i=0; i<n; i++){\\n            if(str[i]==\\'L\\'){\\n                int x = v[i].second.first;\\n                bool check=true;\\n                while(!s.empty()){\\n                    pair<int, int> temp = s.top();\\n                    s.pop();\\n                    if(temp.first>x){\\n                        temp.first--;\\n                        check=false;\\n                        s.push(temp);\\n                        break;\\n                    }\\n                    else if(temp.first==x){\\n                        check=false;\\n                        break;\\n                    }\\n                    else{\\n                        x--;\\n                    }\\n                }\\n                if(check) ans[m[v[i].first]]=x;\\n            }\\n            else{\\n                s.push({v[i].second.first, v[i].first});\\n            }\\n        }\\n        while(!s.empty()){\\n            pair<int, int> temp = s.top();\\n            s.pop();\\n            int pos = m[temp.second];\\n            ans[pos]=temp.first;\\n        }\\n        vector<int> res;\\n        for(auto x:ans){\\n            if(x!=-1) res.push_back(x);\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nstring str;\\nvector<pair<int, pair<int, int>>> v;\\nfor(int i=0; i<n; i++){\\n    v.push_back(make_pair(p[i], make_pair(h[i], i)));\\n    m[p[i]]=i;\\n}\\nsort(v.begin(), v.end());\\nfor(int i=0; i<n; i++){\\n    str+=d[v[i].second.second];\\n}\\n```\n```\\nmap<int, int> m;\\nfor(int i=0; i<n; i++){\\n    m[p[i]]=i;\\n}\\n```\n```\\nstack<pair<int, int>> s;\\nvector<int> ans(n, -1);\\nfor(int i=0; i<n; i++){\\n    if(str[i]==\\'L\\'){\\n        int x = v[i].second.first;\\n        bool check=true; // checks if the current robot is destroyed\\n        while(!s.empty()){\\n            pair<int, int> temp = s.top();\\n            s.pop();\\n            if(temp.first>x){ // robot moving in right has greater health than the curr robot\\n                temp.first--;\\n                check=false;\\n                s.push(temp);\\n                break;\\n            }\\n            else if(temp.first==x){ // both the robots have same health value\\n                check=false;\\n                break;\\n            }\\n            else{ // curr robot has higher health value and continuous moving in left direction\\n                x--;\\n            }\\n        }\\n        if(check) ans[m[v[i].first]]=x; // the robot has destroyed all the robots in its path\\n    }\\n    else{\\n        s.push({v[i].second.first, v[i].first}); // the curr robot is moving right direction\\n    }\\n}\\n```\n```\\nwhile(!s.empty()){\\n    pair<int, int> temp = s.top();\\n    s.pop();\\n    int pos = m[temp.second];\\n    ans[pos]=temp.first;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        int n = d.length();\\n        string str;\\n        vector<pair<int, pair<int, int>>> v;\\n        map<int, int> m;\\n        for(int i=0; i<n; i++){\\n            v.push_back(make_pair(p[i], make_pair(h[i], i)));\\n            m[p[i]]=i;\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<n; i++){\\n            str+=d[v[i].second.second];\\n        }\\n        stack<pair<int, int>> s;\\n        vector<int> ans(n, -1);\\n        for(int i=0; i<n; i++){\\n            if(str[i]==\\'L\\'){\\n                int x = v[i].second.first;\\n                bool check=true;\\n                while(!s.empty()){\\n                    pair<int, int> temp = s.top();\\n                    s.pop();\\n                    if(temp.first>x){\\n                        temp.first--;\\n                        check=false;\\n                        s.push(temp);\\n                        break;\\n                    }\\n                    else if(temp.first==x){\\n                        check=false;\\n                        break;\\n                    }\\n                    else{\\n                        x--;\\n                    }\\n                }\\n                if(check) ans[m[v[i].first]]=x;\\n            }\\n            else{\\n                s.push({v[i].second.first, v[i].first});\\n            }\\n        }\\n        while(!s.empty()){\\n            pair<int, int> temp = s.top();\\n            s.pop();\\n            int pos = m[temp.second];\\n            ans[pos]=temp.first;\\n        }\\n        vector<int> res;\\n        for(auto x:ans){\\n            if(x!=-1) res.push_back(x);\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679335,
                "title": "python-stack-o-nlogn",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        l2r = sorted([(p, h, d, idx) for idx, (p, h, d) in enumerate(zip(positions, healths, directions))])\\n        st = []\\n        for p, h, d, idx in l2r:\\n            if d == \\'R\\':\\n                st.append( (idx, h, d) )\\n            else:\\n                while st and st[-1][2] == \\'R\\' and d == \\'L\\':\\n                    last_idx, last_h, last_d = st.pop()\\n                    if last_h > h:\\n                        idx, h, d = last_idx, last_h -1, \\'R\\'\\n                    elif last_h < h:\\n                        h, d = h - 1, \\'L\\'\\n                    else:\\n                        d = \\'#\\'                        \\n                if d != \\'#\\':\\n                    st.append((idx, h, d))\\n\\n        st.sort()\\n        return [tmp[1] for tmp in st]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        l2r = sorted([(p, h, d, idx) for idx, (p, h, d) in enumerate(zip(positions, healths, directions))])\\n        st = []\\n        for p, h, d, idx in l2r:\\n            if d == \\'R\\':\\n                st.append( (idx, h, d) )\\n            else:\\n                while st and st[-1][2] == \\'R\\' and d == \\'L\\':\\n                    last_idx, last_h, last_d = st.pop()\\n                    if last_h > h:\\n                        idx, h, d = last_idx, last_h -1, \\'R\\'\\n                    elif last_h < h:\\n                        h, d = h - 1, \\'L\\'\\n                    else:\\n                        d = \\'#\\'                        \\n                if d != \\'#\\':\\n                    st.append((idx, h, d))\\n\\n        st.sort()\\n        return [tmp[1] for tmp in st]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679165,
                "title": "simple-efficient-solution",
                "content": "The problem is almost the same as [Asteroid Collision](https://leetcode.com/submissions/detail/920644309/)\\nWe just need to sort on basis of position, form the answer, and restore the order of the answer to bot_id\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pi;\\n    static bool cmp(const pi&a, const pi&b){\\n        return (a.first==b.first ? a.second<b.second : a.first<b.first);\\n    }\\n    static bool cmp2(const pi&a, const pi&b){\\n        return (a.second<b.second);\\n    }\\n    vector<int> getSorted(const vector<int>&ans, const vector<pi>&line, const vector<int>&h){\\n        int m = ans.size(), n = line.size();\\n        unordered_set<int>ust(begin(ans), end(ans));\\n        vector<pi>tmp;\\n        for(int i=0; i<n; ++i){\\n            if(ust.find(i)!=ust.end()){ // eliminate the bots that are not present in the answer\\n                tmp.push_back(line[i]);\\n            }\\n        }\\n        sort(begin(tmp), end(tmp), cmp2); // restore the order\\n        vector<int>res;\\n        for(const auto&it : tmp){\\n            res.push_back(h[it.second]); // the health\\n        }\\n        return res;\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string& dir) {\\n        int n=h.size();\\n        vector<int>ans; // stack of indices of line\\n        vector<pi>line(n); // number line\\n        for(int i=0; i<n; ++i){\\n            line[i]={pos[i], i};\\n        }\\n        sort(begin(line), end(line), cmp); // on basis of pos\\n        for(int i=0; i<n; ++i){\\n            const int&bot = line[i].second, loc = line[i].first; // the current bot moving left\\n            if(dir[bot]==\\'R\\'){\\n                ans.push_back(i);\\n                continue;\\n            }\\n            bool broke = 0;\\n            while(!broke && !ans.empty() && dir[line[ans.back()].second]==\\'R\\'){\\n                const int&bot2 = line[ans.back()].second, loc2 = line[ans.back()].first; // prev bot moving right\\n                if(h[bot]==h[bot2]){\\n                    broke=1, ans.pop_back();\\n                }\\n                else if(h[bot2]<h[bot]){\\n                    ans.pop_back(), --h[bot];\\n                }\\n                else{\\n                    broke=1, --h[bot2];\\n                }\\n            }\\n            if(!broke){ // cur bot still moves to left and is now guranteed to always do so without any future collisions cause we have already explored right moving bots to the left of it\\n                ans.push_back(i);\\n            }\\n        }\\n        return getSorted(ans, line, h); // need to restore order from position to bot_number and convert to health as ans contains indices of line\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pi;\\n    static bool cmp(const pi&a, const pi&b){\\n        return (a.first==b.first ? a.second<b.second : a.first<b.first);\\n    }\\n    static bool cmp2(const pi&a, const pi&b){\\n        return (a.second<b.second);\\n    }\\n    vector<int> getSorted(const vector<int>&ans, const vector<pi>&line, const vector<int>&h){\\n        int m = ans.size(), n = line.size();\\n        unordered_set<int>ust(begin(ans), end(ans));\\n        vector<pi>tmp;\\n        for(int i=0; i<n; ++i){\\n            if(ust.find(i)!=ust.end()){ // eliminate the bots that are not present in the answer\\n                tmp.push_back(line[i]);\\n            }\\n        }\\n        sort(begin(tmp), end(tmp), cmp2); // restore the order\\n        vector<int>res;\\n        for(const auto&it : tmp){\\n            res.push_back(h[it.second]); // the health\\n        }\\n        return res;\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string& dir) {\\n        int n=h.size();\\n        vector<int>ans; // stack of indices of line\\n        vector<pi>line(n); // number line\\n        for(int i=0; i<n; ++i){\\n            line[i]={pos[i], i};\\n        }\\n        sort(begin(line), end(line), cmp); // on basis of pos\\n        for(int i=0; i<n; ++i){\\n            const int&bot = line[i].second, loc = line[i].first; // the current bot moving left\\n            if(dir[bot]==\\'R\\'){\\n                ans.push_back(i);\\n                continue;\\n            }\\n            bool broke = 0;\\n            while(!broke && !ans.empty() && dir[line[ans.back()].second]==\\'R\\'){\\n                const int&bot2 = line[ans.back()].second, loc2 = line[ans.back()].first; // prev bot moving right\\n                if(h[bot]==h[bot2]){\\n                    broke=1, ans.pop_back();\\n                }\\n                else if(h[bot2]<h[bot]){\\n                    ans.pop_back(), --h[bot];\\n                }\\n                else{\\n                    broke=1, --h[bot2];\\n                }\\n            }\\n            if(!broke){ // cur bot still moves to left and is now guranteed to always do so without any future collisions cause we have already explored right moving bots to the left of it\\n                ans.push_back(i);\\n            }\\n        }\\n        return getSorted(ans, line, h); // need to restore order from position to bot_number and convert to health as ans contains indices of line\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087869,
                "title": "easy-and-concise",
                "content": "# Intuition\\nEasy Stack approach\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& po, vector<int>& he, string di) {\\n        vector<pair<int,pair<char,pair<int,int>>>>v;\\n        for(int i=0;i<po.size();i++)\\n        {\\n            v.push_back({po[i],{di[i],{he[i],i}}});\\n        }\\n        sort(v.begin(),v.end());\\n        stack<pair<int,pair<char,pair<int,int>>>>s;\\n        for(int i=0;i<po.size();i++)\\n        {\\n            //cout<<v[i].first<<\\' \\'<<v[i].second.first<<\\' \\'<<v[i].second.second.first<<\\' \\'<<v[i].second.second.second<<endl;\\n            if(s.empty())\\n            {\\n                s.push({v[i].first,{v[i].second.first,{v[i].second.second.first,v[i].second.second.second}}});\\n            }\\n            else\\n            {\\n                bool flag=false;\\n                while((s.top().second.first==\\'R\\' && v[i].second.first==\\'L\\')||(s.top().first==v[i].first))\\n                {\\n                    if(s.top().second.second.first>v[i].second.second.first)\\n                    {\\n                        int dir=s.top().first,health=s.top().second.second.first,ind=s.top().second.second.second;\\n                        char c=s.top().second.first;\\n                        s.pop();\\n                        s.push({dir,{c,{health-1,ind}}});\\n                        flag=true;\\n                        break;\\n                    }\\n                    else if(s.top().second.second.first<v[i].second.second.first)\\n                    {\\n                        s.pop();\\n                        v[i].second.second.first--;\\n                    }\\n                    else{\\n                    s.pop();\\n                    flag=true;\\n                    break;\\n                    }\\n                    if(s.empty())\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                {\\n                    s.push({v[i].first,{v[i].second.first,{v[i].second.second.first,v[i].second.second.second}}});\\n                }\\n            }\\n        }\\n        vector<pair<int,int>>ans;\\n        while(!s.empty())\\n        {\\n            ans.push_back({s.top().second.second.second,s.top().second.second.first});\\n            s.pop();\\n        }\\n        sort(ans.begin(),ans.end());\\n        vector<int>answer;\\n        for(int i=0;i<ans.size();i++)\\n        answer.push_back(ans[i].second);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& po, vector<int>& he, string di) {\\n        vector<pair<int,pair<char,pair<int,int>>>>v;\\n        for(int i=0;i<po.size();i++)\\n        {\\n            v.push_back({po[i],{di[i],{he[i],i}}});\\n        }\\n        sort(v.begin(),v.end());\\n        stack<pair<int,pair<char,pair<int,int>>>>s;\\n        for(int i=0;i<po.size();i++)\\n        {\\n            //cout<<v[i].first<<\\' \\'<<v[i].second.first<<\\' \\'<<v[i].second.second.first<<\\' \\'<<v[i].second.second.second<<endl;\\n            if(s.empty())\\n            {\\n                s.push({v[i].first,{v[i].second.first,{v[i].second.second.first,v[i].second.second.second}}});\\n            }\\n            else\\n            {\\n                bool flag=false;\\n                while((s.top().second.first==\\'R\\' && v[i].second.first==\\'L\\')||(s.top().first==v[i].first))\\n                {\\n                    if(s.top().second.second.first>v[i].second.second.first)\\n                    {\\n                        int dir=s.top().first,health=s.top().second.second.first,ind=s.top().second.second.second;\\n                        char c=s.top().second.first;\\n                        s.pop();\\n                        s.push({dir,{c,{health-1,ind}}});\\n                        flag=true;\\n                        break;\\n                    }\\n                    else if(s.top().second.second.first<v[i].second.second.first)\\n                    {\\n                        s.pop();\\n                        v[i].second.second.first--;\\n                    }\\n                    else{\\n                    s.pop();\\n                    flag=true;\\n                    break;\\n                    }\\n                    if(s.empty())\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                {\\n                    s.push({v[i].first,{v[i].second.first,{v[i].second.second.first,v[i].second.second.second}}});\\n                }\\n            }\\n        }\\n        vector<pair<int,int>>ans;\\n        while(!s.empty())\\n        {\\n            ans.push_back({s.top().second.second.second,s.top().second.second.first});\\n            s.pop();\\n        }\\n        sort(ans.begin(),ans.end());\\n        vector<int>answer;\\n        for(int i=0;i<ans.size();i++)\\n        answer.push_back(ans[i].second);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4047898,
                "title": "sorting-with-stack-r-85-m-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n!\\n**All robots start moving on the line simultaneously at the same speed in their given directions**\\n!\\nMeans they will never overrun any other robot, and we can ignore everything except **collisions**.\\nSo, robots can collide only when R-> <-L.\\nAnd because all of them going with the same speed it\\'s essentially looks like:\\nr1->r2->r3->... <-r4<-r5<-r6....\\nLiterally a Que of robots who\\'s goin to collide one by one until there\\'s no counterpart.\\nIf we were given sorted array, then it\\'s just left -> right traverse with a stack of R directioned robots.\\nBut -> ! **Note: The `positions` may be unsorted.** !\\n**Return** -> ! **remaining robots (in the order they were given in the input),** !\\nOnly thing is needed is to remember original indexing of all robots.\\nThere\\'s at least 2 ways to do this:\\n 1. Create a list with (position, index):\\n```\\nsorted(enumerate(positions), key=lambda x: x[1])\\n```\\n 2. Create simple dictionary with (positions: index):\\n```\\ndict_name: dict[int, int] = {}\\nfor x in range(len(positions)):\\n    dict_name[positions[x]] = x\\n```\\nNow we can sort `positions` and still maintain correct order.\\nAll it\\'s left is maintain stack with all robots who goes Right and check them for a collision rules when encounter robot with Left direction.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Store original indexing of robots.\\n2. Sort `positions` in ascending order.\\n3. Create empty list to use as stack.\\n4. Check every position in `positions` after sorting.\\n4.1 If robot on current position have \\'R\\' direction, add him into stack and continue.\\n4.2 If robot on current position have \\'L\\' direction, and \\nstack not empty. Check **last** robot from a stack for a collision rules.\\n4.3 If robot on current position have \\'L\\' direction, and stack is empty, then it can\\'t collide with anyone. Ignore him.\\n5. Create new list with only **survived** robots. Who\\'s healths isn\\'t equal to  0\\n# Complexity\\n- Time complexity: **O(n * log n)**\\nn - len of any input array, we\\'re given 3 of same size.\\nSorting of `positions` will dominate everything else.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\nWorst case:\\nEvery robot goes R direction, none will collide and we\\'re just recreating input array == healths.\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        # (position: index) <- index == id of the robot.\\n        # We\\'re given input of 3 lists with every robot id is equal to list index.\\n        # Need this for -> ! remaining robots (in the order they were given in the input) !\\n        ids: dict[int, int] = {}\\n        for x in range(len(positions)):\\n            ids[positions[x]] = x\\n        # All robots have same speed, they will never override someone.\\n        # Essentially it will be a que of collisions:\\n        #   r1->r2->r3-> <-r4<-r5<-r6\\n        # So, only thing we care is R-L collision.\\n        # Just sort() and check all robots from left -> right.\\n        positions.sort()\\n        might_collide: list[int] = []\\n        # Only option for collision is R -> <- L\\n        # Store robots with R direction in a stack\\n        #  to get them in correct order and check for collisions.\\n        for pos in positions:\\n            if directions[ids[pos]] == \\'L\\':\\n                while might_collide and healths[ids[pos]] > 0:  # \\'> 0\\' for easier read.\\n                    # R survives.\\n                    if healths[might_collide[-1]] > healths[ids[pos]]:\\n                        healths[might_collide[-1]] -= 1\\n                        healths[ids[pos]] = 0\\n                    # L survives.\\n                    elif healths[might_collide[-1]] < healths[ids[pos]]:\\n                        healths[might_collide.pop()] = 0\\n                        healths[ids[pos]] -= 1\\n                    # Both gone.\\n                    elif healths[might_collide[-1]] == healths[ids[pos]]:\\n                        healths[might_collide.pop()] = 0\\n                        healths[ids[pos]] = 0\\n            if directions[ids[pos]] == \\'R\\':\\n                might_collide.append(ids[pos])\\n        survivors: list[int] = [health for health in healths if health > 0]\\n        return survivors\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nsorted(enumerate(positions), key=lambda x: x[1])\\n```\n```\\ndict_name: dict[int, int] = {}\\nfor x in range(len(positions)):\\n    dict_name[positions[x]] = x\\n```\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        # (position: index) <- index == id of the robot.\\n        # We\\'re given input of 3 lists with every robot id is equal to list index.\\n        # Need this for -> ! remaining robots (in the order they were given in the input) !\\n        ids: dict[int, int] = {}\\n        for x in range(len(positions)):\\n            ids[positions[x]] = x\\n        # All robots have same speed, they will never override someone.\\n        # Essentially it will be a que of collisions:\\n        #   r1->r2->r3-> <-r4<-r5<-r6\\n        # So, only thing we care is R-L collision.\\n        # Just sort() and check all robots from left -> right.\\n        positions.sort()\\n        might_collide: list[int] = []\\n        # Only option for collision is R -> <- L\\n        # Store robots with R direction in a stack\\n        #  to get them in correct order and check for collisions.\\n        for pos in positions:\\n            if directions[ids[pos]] == \\'L\\':\\n                while might_collide and healths[ids[pos]] > 0:  # \\'> 0\\' for easier read.\\n                    # R survives.\\n                    if healths[might_collide[-1]] > healths[ids[pos]]:\\n                        healths[might_collide[-1]] -= 1\\n                        healths[ids[pos]] = 0\\n                    # L survives.\\n                    elif healths[might_collide[-1]] < healths[ids[pos]]:\\n                        healths[might_collide.pop()] = 0\\n                        healths[ids[pos]] -= 1\\n                    # Both gone.\\n                    elif healths[might_collide[-1]] == healths[ids[pos]]:\\n                        healths[might_collide.pop()] = 0\\n                        healths[ids[pos]] = 0\\n            if directions[ids[pos]] == \\'R\\':\\n                might_collide.append(ids[pos])\\n        survivors: list[int] = [health for health in healths if health > 0]\\n        return survivors\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014181,
                "title": "java-short-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(Nlogn)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n          int n = positions.length;\\n        List<Integer> rindex = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            rindex.add(i);\\n        }\\n        Collections.sort(rindex ,(a, b) -> (positions[a]- positions[b]));\\n\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i : rindex) {\\n            if (directions.charAt(i) == \\'R\\') {\\n                stack.push(i);\\n                continue;\\n            }\\n            while (!stack.isEmpty() && healths[i] > 0) {\\n                if (healths[stack.peek()] < healths[i]) {\\n                    healths[stack.pop()] = 0;\\n                    healths[i] -= 1;\\n                } else if (healths[stack.peek()] > healths[i]) {\\n                    healths[stack.peek()] -= 1;\\n                    healths[i] = 0;\\n                } else {\\n                    healths[stack.pop()] = 0;\\n                    healths[i] = 0;\\n                }\\n            }\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        for (int h: healths) {\\n            if (h> 0) {\\n                ans.add(h);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n          int n = positions.length;\\n        List<Integer> rindex = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            rindex.add(i);\\n        }\\n        Collections.sort(rindex ,(a, b) -> (positions[a]- positions[b]));\\n\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i : rindex) {\\n            if (directions.charAt(i) == \\'R\\') {\\n                stack.push(i);\\n                continue;\\n            }\\n            while (!stack.isEmpty() && healths[i] > 0) {\\n                if (healths[stack.peek()] < healths[i]) {\\n                    healths[stack.pop()] = 0;\\n                    healths[i] -= 1;\\n                } else if (healths[stack.peek()] > healths[i]) {\\n                    healths[stack.peek()] -= 1;\\n                    healths[i] = 0;\\n                } else {\\n                    healths[stack.pop()] = 0;\\n                    healths[i] = 0;\\n                }\\n            }\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        for (int h: healths) {\\n            if (h> 0) {\\n                ans.add(h);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011947,
                "title": "straightforward-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        #define arr array<int,4>\\n        vector<arr> robots;\\n        for (int i = 0; i < n; i++) {\\n            robots.push_back({positions[i], healths[i], (int)directions[i], i});\\n        }\\n        sort(robots.begin(), robots.end());\\n        int i = 0;\\n        vector<int> ans;\\n        vector<array<int,2>> tmp;\\n        while (i < n && robots[i][2] == \\'L\\') {\\n            tmp.push_back({robots[i][3], robots[i][1]});\\n            i++;\\n        }\\n        stack<array<int,2>> st; // Only contains R\\n        for (; i < n; i++) {\\n            int health = robots[i][1];\\n            int dir = robots[i][2];\\n            int idx = robots[i][3];\\n            if (st.empty() && dir == \\'L\\') {\\n                tmp.push_back({idx, health});\\n            } else if (dir == \\'R\\') {\\n                st.push({health, idx});\\n            } else if (dir == \\'L\\') {\\n                while (!st.empty() && health > st.top()[0]) {\\n                    health--;\\n                    st.pop();\\n                }\\n                if (st.empty()) {\\n                    tmp.push_back({idx, health});\\n                } else if (health < st.top()[0]) {\\n                    auto e = st.top();\\n                    int top = e[0];\\n                    int cp = e[1];\\n                    st.pop();\\n                    st.push({top-1, cp});\\n                } else if (health == st.top()[0]) {\\n                    st.pop();\\n                }\\n            }\\n        }\\n        \\n        while (!st.empty()) {\\n            auto e = st.top();\\n            st.pop();\\n            tmp.push_back({e[1], e[0]});\\n        }\\n        sort(tmp.begin(), tmp.end());\\n        for (int j = 0; j < tmp.size(); j++) {\\n            ans.push_back(tmp[j][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        #define arr array<int,4>\\n        vector<arr> robots;\\n        for (int i = 0; i < n; i++) {\\n            robots.push_back({positions[i], healths[i], (int)directions[i], i});\\n        }\\n        sort(robots.begin(), robots.end());\\n        int i = 0;\\n        vector<int> ans;\\n        vector<array<int,2>> tmp;\\n        while (i < n && robots[i][2] == \\'L\\') {\\n            tmp.push_back({robots[i][3], robots[i][1]});\\n            i++;\\n        }\\n        stack<array<int,2>> st; // Only contains R\\n        for (; i < n; i++) {\\n            int health = robots[i][1];\\n            int dir = robots[i][2];\\n            int idx = robots[i][3];\\n            if (st.empty() && dir == \\'L\\') {\\n                tmp.push_back({idx, health});\\n            } else if (dir == \\'R\\') {\\n                st.push({health, idx});\\n            } else if (dir == \\'L\\') {\\n                while (!st.empty() && health > st.top()[0]) {\\n                    health--;\\n                    st.pop();\\n                }\\n                if (st.empty()) {\\n                    tmp.push_back({idx, health});\\n                } else if (health < st.top()[0]) {\\n                    auto e = st.top();\\n                    int top = e[0];\\n                    int cp = e[1];\\n                    st.pop();\\n                    st.push({top-1, cp});\\n                } else if (health == st.top()[0]) {\\n                    st.pop();\\n                }\\n            }\\n        }\\n        \\n        while (!st.empty()) {\\n            auto e = st.top();\\n            st.pop();\\n            tmp.push_back({e[1], e[0]});\\n        }\\n        sort(tmp.begin(), tmp.end());\\n        for (int j = 0; j < tmp.size(); j++) {\\n            ans.push_back(tmp[j][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970504,
                "title": "c-commented-for-better-understanding",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        int n = p.size();\\n        vector<pair<int, pair<char, int>>> v;\\n        for(int i=0; i<n; i++) v.push_back({p[i], {d[i], h[i]}});\\n        // Sorting according to positions\\n        sort(v.begin(), v.end());\\n        stack<pair<int, pair<char, int>>> st;\\n        for(int i=0; i<n; i++) {\\n            if(st.empty()) st.push(v[i]);\\n            // The only possible case for collision => R-> <-L\\n            else if(st.top().second.first == \\'R\\' && v[i].second.first == \\'L\\') {\\n                char curd = v[i].second.first; // current direction\\n                int curh = v[i].second.second; // current health\\n                int curp = v[i].first;          // current position\\n                pair<int, pair<char, int>> t;\\n                // here we\\'re using t to track the final robot after collisions \\n                bool f = true;                  // Flag for a valid push\\n                while(!st.empty() && (st.top().second.first == \\'R\\' && curd == \\'L\\')) {\\n                    t = st.top();\\n                    st.pop();\\n                    int prevh = t.second.second; // stack\\'s top robot\\'s health\\n                    if(curh > prevh) {\\n                        // then we no more require the previous robot\\n                        // so all of its data is overwritten\\n                        t.second.second = --curh;\\n                        t.second.first = curd;\\n                        t.first = curp;\\n                    }\\n                    else if(prevh > curh) {\\n                        // here we still need the previous robot\\n                        t.second.second--;\\n                        // but the current direction should be updated\\n                        curd = t.second.first; \\n                        // here the loop breaks since curd is no more equal to L\\n                    }\\n                    else {\\n                        // since both the robots having same health, they were removed from the line\\n                        // by making f as false, we are not pushing any robot into the stack\\n                        f = false;\\n                        break;\\n                    }\\n                }\\n                // now the final robot after collisions will be pushed into the stack while checking the flag accordingly\\n                if(st.empty() && f) st.push(t);\\n                else if(f) st.push(t);\\n            }\\n            else st.push(v[i]);\\n        }\\n        unordered_map<int, int> mp;\\n        // we are using map to get the health of remaining robots in the order they were given in the input\\n        while(!st.empty()) {\\n            mp[st.top().first] = st.top().second.second;\\n            st.pop();\\n        }\\n        vector<int> ans;\\n        for(int it : p) {\\n            if(mp[it]) ans.push_back(mp[it]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHope it helps :)",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        int n = p.size();\\n        vector<pair<int, pair<char, int>>> v;\\n        for(int i=0; i<n; i++) v.push_back({p[i], {d[i], h[i]}});\\n        // Sorting according to positions\\n        sort(v.begin(), v.end());\\n        stack<pair<int, pair<char, int>>> st;\\n        for(int i=0; i<n; i++) {\\n            if(st.empty()) st.push(v[i]);\\n            // The only possible case for collision => R-> <-L\\n            else if(st.top().second.first == \\'R\\' && v[i].second.first == \\'L\\') {\\n                char curd = v[i].second.first; // current direction\\n                int curh = v[i].second.second; // current health\\n                int curp = v[i].first;          // current position\\n                pair<int, pair<char, int>> t;\\n                // here we\\'re using t to track the final robot after collisions \\n                bool f = true;                  // Flag for a valid push\\n                while(!st.empty() && (st.top().second.first == \\'R\\' && curd == \\'L\\')) {\\n                    t = st.top();\\n                    st.pop();\\n                    int prevh = t.second.second; // stack\\'s top robot\\'s health\\n                    if(curh > prevh) {\\n                        // then we no more require the previous robot\\n                        // so all of its data is overwritten\\n                        t.second.second = --curh;\\n                        t.second.first = curd;\\n                        t.first = curp;\\n                    }\\n                    else if(prevh > curh) {\\n                        // here we still need the previous robot\\n                        t.second.second--;\\n                        // but the current direction should be updated\\n                        curd = t.second.first; \\n                        // here the loop breaks since curd is no more equal to L\\n                    }\\n                    else {\\n                        // since both the robots having same health, they were removed from the line\\n                        // by making f as false, we are not pushing any robot into the stack\\n                        f = false;\\n                        break;\\n                    }\\n                }\\n                // now the final robot after collisions will be pushed into the stack while checking the flag accordingly\\n                if(st.empty() && f) st.push(t);\\n                else if(f) st.push(t);\\n            }\\n            else st.push(v[i]);\\n        }\\n        unordered_map<int, int> mp;\\n        // we are using map to get the health of remaining robots in the order they were given in the input\\n        while(!st.empty()) {\\n            mp[st.top().first] = st.top().second.second;\\n            st.pop();\\n        }\\n        vector<int> ans;\\n        for(int it : p) {\\n            if(mp[it]) ans.push_back(mp[it]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944398,
                "title": "done-with-stack-faster-than-95-80-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,pair<int,char>>&a , pair<int,pair<int,char>> &b){\\n        return a.first<b.first;\\n    }\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        // This have came in Deusteche bank OA\\n        int n=positions.size();\\n\\n        vector<pair<int,pair<int,char>>> x;\\n        for(int i=0;i<n;i++){\\n            x.push_back({positions[i],{healths[i],directions[i]}});\\n        }\\n        sort(x.begin(),x.end(),cmp);\\n\\n        stack<pair<int,pair<int,char>>> st;\\n        \\n        for(int i=0;i<n;i++) {\\n            auto cur = x[i];\\n\\n            if(st.size()==0) {\\n                st.push(cur);\\n            }\\n\\n            else {\\n                if(st.top().second.second==\\'R\\' && cur.second.second==\\'L\\') {\\n                   // there will be a collision for sure\\n                   int endedIn=-1;\\n                   while(st.size()>0 && st.top().second.second==\\'R\\' && cur.second.second==\\'L\\') {\\n                       if(st.top().second.first<cur.second.first) {\\n                           st.pop();\\n                           cur.second.first-=1;\\n                           endedIn=1;\\n                       }\\n\\n                       else if(st.top().second.first>cur.second.first) {\\n                           auto t = st.top();\\n                           t.second.first-=1;\\n                           st.pop();\\n                           st.push(t);\\n                           endedIn=2;\\n                           break;\\n                       }\\n\\n                       else {\\n                           st.pop();\\n                           endedIn=3;\\n                           break;\\n                       }\\n                   }\\n                   if(endedIn==1){\\n                       st.push(cur);\\n                   }\\n                }\\n\\n                else {\\n                    st.push(cur);\\n                }\\n            }\\n        }\\n\\n        unordered_map<int,int> mp;\\n        while(!st.empty()){\\n            mp[st.top().first]=st.top().second.first;\\n            st.pop();\\n        }\\n\\n        vector<int> ans;\\n        for(auto i:positions){\\n            if(mp.find(i)!=mp.end()) ans.push_back(mp[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,pair<int,char>>&a , pair<int,pair<int,char>> &b){\\n        return a.first<b.first;\\n    }\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        // This have came in Deusteche bank OA\\n        int n=positions.size();\\n\\n        vector<pair<int,pair<int,char>>> x;\\n        for(int i=0;i<n;i++){\\n            x.push_back({positions[i],{healths[i],directions[i]}});\\n        }\\n        sort(x.begin(),x.end(),cmp);\\n\\n        stack<pair<int,pair<int,char>>> st;\\n        \\n        for(int i=0;i<n;i++) {\\n            auto cur = x[i];\\n\\n            if(st.size()==0) {\\n                st.push(cur);\\n            }\\n\\n            else {\\n                if(st.top().second.second==\\'R\\' && cur.second.second==\\'L\\') {\\n                   // there will be a collision for sure\\n                   int endedIn=-1;\\n                   while(st.size()>0 && st.top().second.second==\\'R\\' && cur.second.second==\\'L\\') {\\n                       if(st.top().second.first<cur.second.first) {\\n                           st.pop();\\n                           cur.second.first-=1;\\n                           endedIn=1;\\n                       }\\n\\n                       else if(st.top().second.first>cur.second.first) {\\n                           auto t = st.top();\\n                           t.second.first-=1;\\n                           st.pop();\\n                           st.push(t);\\n                           endedIn=2;\\n                           break;\\n                       }\\n\\n                       else {\\n                           st.pop();\\n                           endedIn=3;\\n                           break;\\n                       }\\n                   }\\n                   if(endedIn==1){\\n                       st.push(cur);\\n                   }\\n                }\\n\\n                else {\\n                    st.push(cur);\\n                }\\n            }\\n        }\\n\\n        unordered_map<int,int> mp;\\n        while(!st.empty()){\\n            mp[st.top().first]=st.top().second.first;\\n            st.pop();\\n        }\\n\\n        vector<int> ans;\\n        for(auto i:positions){\\n            if(mp.find(i)!=mp.end()) ans.push_back(mp[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929230,
                "title": "simple-stack",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length ;\\n        HashMap<Integer , Integer > map = new HashMap<>() ; \\n        int[][] arr = new int[n][3] ; \\n        for( int i = 0 ; i < n ; i++){\\n            arr[i][0] = positions[i] ; \\n            arr[i][1] = healths[i] ; \\n            char ch = directions.charAt(i) ; \\n            arr[i][2] = (ch == \\'R\\' ? 1 : -1 )  ; \\n        } \\n        Arrays.sort( arr , ( int[] a , int[] b) -> a[0]-b[0] ) ; \\n        Stack<int[]> stk = new Stack<>() ; \\n        List<Integer> ans = new ArrayList<>() ; \\n        for( int ar[] : arr ){\\n            int a = ar[0], b = ar[1], c = ar[2] ; \\n            int temp[] = {a, b, c } ; \\n            if( c == 1 ){\\n                stk.push( temp ) ; \\n            }else{\\n                boolean got = true   ; \\n                while( stk.size() > 0 && b > 0  ){\\n                    int[] ent = stk.pop() ; \\n                    if( ent[1] == b ){\\n                        got = false ;\\n                        b = 0  ; \\n                    }else if ( ent[1] < b  ){\\n                        b-- ; \\n                        if( b == 0 ) got = false; \\n                    }else{\\n                        ent[1]--; \\n                        if( ent[1] != 0 ) stk.push( ent ) ; \\n                        got = false ; \\n                        b = 0 ; \\n                    }\\n                }\\n                if( got ){\\n                    // ans.add( b ) ;\\n                    // res.add( a ) ;\\n                    map.put( a  , b ) ;   \\n                }\\n\\n            }\\n\\n\\n\\n        }\\n\\n        // List<Integer> res = new ArrayList<>()  ;\\n        while( stk.size() > 0 ){\\n            int[] p = stk.pop() ; \\n            // res.add( p[0]) ;\\n            map.put( p[0] , p[1]) ; \\n             \\n        }\\n        for( int  i= 0 ;  i < n ; i++){\\n            int  a = positions[i] , b = healths[i]  ; \\n            if( map.containsKey(a)) ans.add(map.get(a)) ; \\n        }\\n        \\n        return ans  ; \\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length ;\\n        HashMap<Integer , Integer > map = new HashMap<>() ; \\n        int[][] arr = new int[n][3] ; \\n        for( int i = 0 ; i < n ; i++){\\n            arr[i][0] = positions[i] ; \\n            arr[i][1] = healths[i] ; \\n            char ch = directions.charAt(i) ; \\n            arr[i][2] = (ch == \\'R\\' ? 1 : -1 )  ; \\n        } \\n        Arrays.sort( arr , ( int[] a , int[] b) -> a[0]-b[0] ) ; \\n        Stack<int[]> stk = new Stack<>() ; \\n        List<Integer> ans = new ArrayList<>() ; \\n        for( int ar[] : arr ){\\n            int a = ar[0], b = ar[1], c = ar[2] ; \\n            int temp[] = {a, b, c } ; \\n            if( c == 1 ){\\n                stk.push( temp ) ; \\n            }else{\\n                boolean got = true   ; \\n                while( stk.size() > 0 && b > 0  ){\\n                    int[] ent = stk.pop() ; \\n                    if( ent[1] == b ){\\n                        got = false ;\\n                        b = 0  ; \\n                    }else if ( ent[1] < b  ){\\n                        b-- ; \\n                        if( b == 0 ) got = false; \\n                    }else{\\n                        ent[1]--; \\n                        if( ent[1] != 0 ) stk.push( ent ) ; \\n                        got = false ; \\n                        b = 0 ; \\n                    }\\n                }\\n                if( got ){\\n                    // ans.add( b ) ;\\n                    // res.add( a ) ;\\n                    map.put( a  , b ) ;   \\n                }\\n\\n            }\\n\\n\\n\\n        }\\n\\n        // List<Integer> res = new ArrayList<>()  ;\\n        while( stk.size() > 0 ){\\n            int[] p = stk.pop() ; \\n            // res.add( p[0]) ;\\n            map.put( p[0] , p[1]) ; \\n             \\n        }\\n        for( int  i= 0 ;  i < n ; i++){\\n            int  a = positions[i] , b = healths[i]  ; \\n            if( map.containsKey(a)) ans.add(map.get(a)) ; \\n        }\\n        \\n        return ans  ; \\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901045,
                "title": "robot-collisions-java-easy-stack-sorting-comparable",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n=positions.length;\\n\\n        int []ans=new int[n];\\n        Arrays.fill(ans,Integer.MIN_VALUE);\\n        Stack<Pair> s=new Stack<>();\\n        char []ch=directions.toCharArray();\\n\\n        List<Pair> ls=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++){\\n            ls.add(new Pair(positions[i],healths[i],ch[i],i));\\n        }\\n\\n        Collections.sort(ls);\\n\\n        for(Pair p: ls){\\n            if(p.dir==\\'R\\'){\\n                s.push(p);\\n            }\\n\\n            if(p.dir==\\'L\\'){\\n                while(!s.isEmpty()){\\n                    Pair curr=s.peek();\\n                    if(curr.h==p.h){\\n                        s.pop();\\n                        p.h=-1;\\n                        break;\\n                    }else if(curr.h>p.h){\\n                        curr.h-=1;\\n                        p.h=-1;\\n                        break;\\n                    }else{\\n                        s.pop();\\n                        p.h-=1;\\n                    }\\n                }\\n\\n                if(p.h!=-1)ans[p.idx]=p.h;\\n            }\\n        }\\n\\n        while(!s.isEmpty()){\\n            Pair curr=s.pop();\\n            ans[curr.idx]=curr.h;\\n        }\\n\\n        List<Integer> ansls=new ArrayList<>();\\n\\n        for(int a:ans){\\n            if(a!=Integer.MIN_VALUE){\\n                ansls.add(a);\\n            }\\n        }\\n\\n        return ansls;\\n\\n    }\\n\\n    class Pair implements Comparable<Pair>{\\n        int pos;\\n        int h;\\n        char dir;\\n        int idx;\\n\\n        public Pair(int pos, int h, char dir, int idx){\\n            this.pos=pos;\\n            this.h=h;\\n            this.dir=dir;\\n            this.idx=idx;\\n        }\\n\\n        public int compareTo(Pair o){\\n            return this.pos-o.pos;\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n=positions.length;\\n\\n        int []ans=new int[n];\\n        Arrays.fill(ans,Integer.MIN_VALUE);\\n        Stack<Pair> s=new Stack<>();\\n        char []ch=directions.toCharArray();\\n\\n        List<Pair> ls=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++){\\n            ls.add(new Pair(positions[i],healths[i],ch[i],i));\\n        }\\n\\n        Collections.sort(ls);\\n\\n        for(Pair p: ls){\\n            if(p.dir==\\'R\\'){\\n                s.push(p);\\n            }\\n\\n            if(p.dir==\\'L\\'){\\n                while(!s.isEmpty()){\\n                    Pair curr=s.peek();\\n                    if(curr.h==p.h){\\n                        s.pop();\\n                        p.h=-1;\\n                        break;\\n                    }else if(curr.h>p.h){\\n                        curr.h-=1;\\n                        p.h=-1;\\n                        break;\\n                    }else{\\n                        s.pop();\\n                        p.h-=1;\\n                    }\\n                }\\n\\n                if(p.h!=-1)ans[p.idx]=p.h;\\n            }\\n        }\\n\\n        while(!s.isEmpty()){\\n            Pair curr=s.pop();\\n            ans[curr.idx]=curr.h;\\n        }\\n\\n        List<Integer> ansls=new ArrayList<>();\\n\\n        for(int a:ans){\\n            if(a!=Integer.MIN_VALUE){\\n                ansls.add(a);\\n            }\\n        }\\n\\n        return ansls;\\n\\n    }\\n\\n    class Pair implements Comparable<Pair>{\\n        int pos;\\n        int h;\\n        char dir;\\n        int idx;\\n\\n        public Pair(int pos, int h, char dir, int idx){\\n            this.pos=pos;\\n            this.h=h;\\n            this.dir=dir;\\n            this.idx=idx;\\n        }\\n\\n        public int compareTo(Pair o){\\n            return this.pos-o.pos;\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894504,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Robot {\\n  int index;\\n  int position;\\n  int health;\\n  char direction;\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> survivedRobotsHealths(vector<int>& positions,\\n                                    vector<int>& healths, string directions) {\\n    vector<int> ans;\\n    vector<Robot> robots;\\n    vector<Robot> stack;  // runnnig robots\\n\\n    for (int i = 0; i < positions.size(); ++i)\\n      robots.push_back(Robot{i, positions[i], healths[i], directions[i]});\\n\\n    sort(robots.begin(), robots.end(), [](const Robot& a, const Robot& b) {\\n      return a.position < b.position;\\n    });\\n\\n    for (Robot& robot : robots) {\\n      if (robot.direction == \\'R\\') {\\n        stack.push_back(robot);\\n        continue;\\n      }\\n      // Collide with robots going right if any.\\n      while (!stack.empty() && stack.back().direction == \\'R\\' &&\\n             robot.health > 0) {\\n        if (stack.back().health == robot.health) {\\n          stack.pop_back();\\n          robot.health = 0;\\n        } else if (stack.back().health < robot.health) {\\n          stack.pop_back();\\n          robot.health -= 1;\\n        } else {  // stack.back().health > robot.health\\n          stack.back().health -= 1;\\n          robot.health = 0;\\n        }\\n      }\\n      if (robot.health > 0)\\n        stack.push_back(robot);\\n    }\\n\\n    sort(stack.begin(), stack.end(),\\n         [](const Robot& a, const Robot& b) { return a.index < b.index; });\\n\\n    for (const Robot& robot : stack)\\n      ans.push_back(robot.health);\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Robot {\\n  int index;\\n  int position;\\n  int health;\\n  char direction;\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> survivedRobotsHealths(vector<int>& positions,\\n                                    vector<int>& healths, string directions) {\\n    vector<int> ans;\\n    vector<Robot> robots;\\n    vector<Robot> stack;  // runnnig robots\\n\\n    for (int i = 0; i < positions.size(); ++i)\\n      robots.push_back(Robot{i, positions[i], healths[i], directions[i]});\\n\\n    sort(robots.begin(), robots.end(), [](const Robot& a, const Robot& b) {\\n      return a.position < b.position;\\n    });\\n\\n    for (Robot& robot : robots) {\\n      if (robot.direction == \\'R\\') {\\n        stack.push_back(robot);\\n        continue;\\n      }\\n      // Collide with robots going right if any.\\n      while (!stack.empty() && stack.back().direction == \\'R\\' &&\\n             robot.health > 0) {\\n        if (stack.back().health == robot.health) {\\n          stack.pop_back();\\n          robot.health = 0;\\n        } else if (stack.back().health < robot.health) {\\n          stack.pop_back();\\n          robot.health -= 1;\\n        } else {  // stack.back().health > robot.health\\n          stack.back().health -= 1;\\n          robot.health = 0;\\n        }\\n      }\\n      if (robot.health > 0)\\n        stack.push_back(robot);\\n    }\\n\\n    sort(stack.begin(), stack.end(),\\n         [](const Robot& a, const Robot& b) { return a.index < b.index; });\\n\\n    for (const Robot& robot : stack)\\n      ans.push_back(robot.health);\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885874,
                "title": "python-3-with-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        # Create a list of robots, each represented by a tuple of (position, health, direction, index).\\n        # Also create a list to keep the final health of robots\\n        robots = sorted([(pos, health, dir, index) for index, (pos, health, dir) in enumerate(zip(positions, healths, directions))])\\n        final_healths = [0]*len(robots)\\n        \\n        # Initialize an empty stack.\\n        stack = []\\n        \\n        # Iterate through the sorted list of robots.\\n        for robot in robots:\\n            while True:\\n                # If the stack is empty, push the current robot onto the stack.\\n                if not stack:\\n                    stack.append(robot)\\n                    break\\n\\n                # If the current robot and the robot on top of the stack are moving towards each other,\\n                # they will collide.\\n                if stack[-1][2] == \\'R\\' and robot[2] == \\'L\\':\\n                    # If the current robot has more health, decrease its health by one.\\n                    if robot[1] > stack[-1][1]:\\n                        robot = (robot[0], robot[1]-1, robot[2], robot[3])\\n                        stack.pop()\\n                    # If the robot on top of the stack has more health, decrease its health by one,\\n                    # remove the current robot.\\n                    elif robot[1] < stack[-1][1]:\\n                        stack[-1] = (stack[-1][0], stack[-1][1]-1, stack[-1][2], stack[-1][3])\\n                        break\\n                    # If both robots have the same health, remove both robots.\\n                    else:\\n                        stack.pop()\\n                        break\\n                else:\\n                    # If the current robot and the robot on top of the stack are not moving towards each other,\\n                    # push the current robot onto the stack if it is moving to the right.\\n                    # If it is moving to the left and there are no other robots moving to the left on the stack,\\n                    # add its final health to the result and remove it.\\n                    if stack[-1][2] == robot[2]:\\n                        if robot[2] == \\'R\\':\\n                            stack.append(robot)\\n                        else:\\n                            final_healths[robot[3]] = robot[1]\\n                        break\\n                    else:\\n                        stack.append(robot)\\n                        break\\n        \\n        # After iterating through all the robots, the stack contains the surviving robots. \\n        # Store their healths in the order they were given in the input.\\n        for robot in stack:\\n            final_healths[robot[3]] = robot[1]\\n        \\n        # Return the final healths of the robots that survived\\n        return [health for health in final_healths if health != 0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        # Create a list of robots, each represented by a tuple of (position, health, direction, index).\\n        # Also create a list to keep the final health of robots\\n        robots = sorted([(pos, health, dir, index) for index, (pos, health, dir) in enumerate(zip(positions, healths, directions))])\\n        final_healths = [0]*len(robots)\\n        \\n        # Initialize an empty stack.\\n        stack = []\\n        \\n        # Iterate through the sorted list of robots.\\n        for robot in robots:\\n            while True:\\n                # If the stack is empty, push the current robot onto the stack.\\n                if not stack:\\n                    stack.append(robot)\\n                    break\\n\\n                # If the current robot and the robot on top of the stack are moving towards each other,\\n                # they will collide.\\n                if stack[-1][2] == \\'R\\' and robot[2] == \\'L\\':\\n                    # If the current robot has more health, decrease its health by one.\\n                    if robot[1] > stack[-1][1]:\\n                        robot = (robot[0], robot[1]-1, robot[2], robot[3])\\n                        stack.pop()\\n                    # If the robot on top of the stack has more health, decrease its health by one,\\n                    # remove the current robot.\\n                    elif robot[1] < stack[-1][1]:\\n                        stack[-1] = (stack[-1][0], stack[-1][1]-1, stack[-1][2], stack[-1][3])\\n                        break\\n                    # If both robots have the same health, remove both robots.\\n                    else:\\n                        stack.pop()\\n                        break\\n                else:\\n                    # If the current robot and the robot on top of the stack are not moving towards each other,\\n                    # push the current robot onto the stack if it is moving to the right.\\n                    # If it is moving to the left and there are no other robots moving to the left on the stack,\\n                    # add its final health to the result and remove it.\\n                    if stack[-1][2] == robot[2]:\\n                        if robot[2] == \\'R\\':\\n                            stack.append(robot)\\n                        else:\\n                            final_healths[robot[3]] = robot[1]\\n                        break\\n                    else:\\n                        stack.append(robot)\\n                        break\\n        \\n        # After iterating through all the robots, the stack contains the surviving robots. \\n        # Store their healths in the order they were given in the input.\\n        for robot in stack:\\n            final_healths[robot[3]] = robot[1]\\n        \\n        # Return the final healths of the robots that survived\\n        return [health for health in final_healths if health != 0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866334,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, ps: List[int], hs: List[int], ds: str) -> List[int]:\\n        pp=[]\\n        for i in range(0,len(ps),1):\\n            pp.append([ps[i],hs[i],ds[i],i])\\n        pp.sort()\\n        st=[]\\n        del ps,hs,ds\\n        for i in range(0,len(pp),1):\\n            while st and st[-1][0]==\\'R\\'and pp[i][2]==\\'L\\' and pp[i][1]>st[-1][1]:\\n                pp[i][1]-=1\\n                st.pop()\\n            if st and st[-1][0]==\\'R\\'and pp[i][2]==\\'L\\':\\n                if(pp[i][1]<st[-1][1]):st[-1][1]-=1\\n                elif(pp[i][1]==st[-1][1]):st.pop()\\n            else:st.append([pp[i][2],pp[i][1],pp[i][-1]])\\n        ans=[]\\n        #print(st)\\n        for i in st:\\n            ans.append((i[-1],i[1]))\\n        ans.sort()\\n        return [i[1] for i in ans]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, ps: List[int], hs: List[int], ds: str) -> List[int]:\\n        pp=[]\\n        for i in range(0,len(ps),1):\\n            pp.append([ps[i],hs[i],ds[i],i])\\n        pp.sort()\\n        st=[]\\n        del ps,hs,ds\\n        for i in range(0,len(pp),1):\\n            while st and st[-1][0]==\\'R\\'and pp[i][2]==\\'L\\' and pp[i][1]>st[-1][1]:\\n                pp[i][1]-=1\\n                st.pop()\\n            if st and st[-1][0]==\\'R\\'and pp[i][2]==\\'L\\':\\n                if(pp[i][1]<st[-1][1]):st[-1][1]-=1\\n                elif(pp[i][1]==st[-1][1]):st.pop()\\n            else:st.append([pp[i][2],pp[i][1],pp[i][-1]])\\n        ans=[]\\n        #print(st)\\n        for i in st:\\n            ans.append((i[-1],i[1]))\\n        ans.sort()\\n        return [i[1] for i in ans]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835520,
                "title": "c-sorting-stack-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct robot {\\n        int pos;\\n        int health;\\n        int order;\\n        char dir;\\n    };\\n    static bool cmp(robot a, robot b) {\\n        return a.pos < b.pos;\\n    }\\n    static bool cmp2(robot a, robot b) {\\n        return a.order < b.order;\\n    }\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n\\n        vector<robot> arr(n);\\n        for (int i = 0; i < n; i++) {\\n            arr[i].pos = positions[i];\\n            arr[i].health = healths[i];\\n            arr[i].dir = directions[i];\\n            arr[i].order = i+1; \\n        }\\n        sort(arr.begin(), arr.end(), cmp);\\n\\n        stack<robot> s;\\n        vector<robot> tmp;\\n\\n        for (auto i : arr) {\\n            if (i.dir == \\'R\\') {\\n                s.push(i);\\n                continue;\\n            }\\n            if (s.empty()) {\\n                tmp.push_back(i);\\n                continue;\\n            }\\n            while (!s.empty()) {\\n                robot j = s.top();\\n                s.pop();\\n\\n                if (i.health > j.health) \\n                    i.health--;\\n                else {\\n                    if (i.health < j.health) {\\n                        j.health--;\\n                        s.push(j);\\n                    }\\n                    i.health = 0;\\n                    break;\\n                }\\n            }\\n            if (i.health != 0) tmp.push_back(i); \\n        }\\n        \\n        while (!s.empty()){\\n            tmp.push_back(s.top());\\n            s.pop();\\n        }\\n        sort(tmp.begin(), tmp.end(), cmp2);\\n\\n        vector<int> ans;\\n        for (auto i : tmp) \\n            ans.push_back(i.health);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct robot {\\n        int pos;\\n        int health;\\n        int order;\\n        char dir;\\n    };\\n    static bool cmp(robot a, robot b) {\\n        return a.pos < b.pos;\\n    }\\n    static bool cmp2(robot a, robot b) {\\n        return a.order < b.order;\\n    }\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n\\n        vector<robot> arr(n);\\n        for (int i = 0; i < n; i++) {\\n            arr[i].pos = positions[i];\\n            arr[i].health = healths[i];\\n            arr[i].dir = directions[i];\\n            arr[i].order = i+1; \\n        }\\n        sort(arr.begin(), arr.end(), cmp);\\n\\n        stack<robot> s;\\n        vector<robot> tmp;\\n\\n        for (auto i : arr) {\\n            if (i.dir == \\'R\\') {\\n                s.push(i);\\n                continue;\\n            }\\n            if (s.empty()) {\\n                tmp.push_back(i);\\n                continue;\\n            }\\n            while (!s.empty()) {\\n                robot j = s.top();\\n                s.pop();\\n\\n                if (i.health > j.health) \\n                    i.health--;\\n                else {\\n                    if (i.health < j.health) {\\n                        j.health--;\\n                        s.push(j);\\n                    }\\n                    i.health = 0;\\n                    break;\\n                }\\n            }\\n            if (i.health != 0) tmp.push_back(i); \\n        }\\n        \\n        while (!s.empty()){\\n            tmp.push_back(s.top());\\n            s.pop();\\n        }\\n        sort(tmp.begin(), tmp.end(), cmp2);\\n\\n        vector<int> ans;\\n        for (auto i : tmp) \\n            ans.push_back(i.health);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835059,
                "title": "beats-99-98-greedy-and-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:~O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& h, string d) {\\n        int n=h.size();\\n        vector<pair<int,int>>num(n);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            num[i]={positions[i],i};\\n        }\\n        sort(num.begin(),num.end());\\n        stack<pair<int,int>>s;\\n\\n        for(int j=0;j<n;j++)\\n        {\\n            int i=num[j].second;\\n            while(!s.empty() && d[s.top().second]==\\'R\\' && d[i]==\\'L\\' && s.top().first<h[i])\\n            {\\n                 s.pop();\\n                 h[i]-=1;\\n            }\\n            if(s.empty())\\n            {\\n                s.push({h[i],i});\\n            }\\n            else if(d[s.top().second]==d[i] || (d[s.top().second]==\\'L\\' && d[i]==\\'R\\'))\\n            {\\n                s.push({h[i],i});\\n            }\\n            else if(s.top().first==h[i] && d[s.top().second]==\\'R\\' && d[i]==\\'L\\')\\n            {\\n                s.pop();\\n            }\\n            else\\n            {\\n                s.top().first-=1;\\n            }\\n        }\\n        num.clear();\\n        while(!s.empty())\\n        {\\n            num.push_back({s.top().second,s.top().first});\\n            s.pop();\\n        }\\n        sort(num.begin(),num.end());\\n        vector<int>ans;\\n        for(auto i:num)\\n        {\\n            ans.push_back(i.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& h, string d) {\\n        int n=h.size();\\n        vector<pair<int,int>>num(n);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            num[i]={positions[i],i};\\n        }\\n        sort(num.begin(),num.end());\\n        stack<pair<int,int>>s;\\n\\n        for(int j=0;j<n;j++)\\n        {\\n            int i=num[j].second;\\n            while(!s.empty() && d[s.top().second]==\\'R\\' && d[i]==\\'L\\' && s.top().first<h[i])\\n            {\\n                 s.pop();\\n                 h[i]-=1;\\n            }\\n            if(s.empty())\\n            {\\n                s.push({h[i],i});\\n            }\\n            else if(d[s.top().second]==d[i] || (d[s.top().second]==\\'L\\' && d[i]==\\'R\\'))\\n            {\\n                s.push({h[i],i});\\n            }\\n            else if(s.top().first==h[i] && d[s.top().second]==\\'R\\' && d[i]==\\'L\\')\\n            {\\n                s.pop();\\n            }\\n            else\\n            {\\n                s.top().first-=1;\\n            }\\n        }\\n        num.clear();\\n        while(!s.empty())\\n        {\\n            num.push_back({s.top().second,s.top().first});\\n            s.pop();\\n        }\\n        sort(num.begin(),num.end());\\n        vector<int>ans;\\n        for(auto i:num)\\n        {\\n            ans.push_back(i.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834973,
                "title": "sort-collision-detection-runtime-343ms-memory-187-58mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort robots by position and check if robots will collide.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(n)))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    auto collisionDetection(const deque<int> &survivedRobots, const string &directions, const int &pos) const -> int{\\n        const auto &dir     = directions[pos]; \\n\\n        //nobody to collide with\\n        if(empty(survivedRobots)){return false;}\\n\\n        //moving in the same direction ==> no collision\\n        if(directions[survivedRobots.back()] == dir){return false;}\\n\\n        //moving in the opposite direction ==> no collision (L, R) <== O ==>\\n        if(directions[survivedRobots.back()] == \\'L\\'){return false;}\\n    \\n        //moving in the opposite direction ==> collision occurs (R, L) ==> X <==\\n        return true;\\n    }\\npublic:\\n    auto survivedRobotsHealths(const vector<int> &positions, vector<int> &healths, const string &directions) -> vector<int>{\\n        auto robots = size(positions);\\n        vector<int> ascendingPositions(robots);\\n        iota(begin(ascendingPositions), end(ascendingPositions), 0);\\n\\n        sort(begin(ascendingPositions), end(ascendingPositions), [&](const auto &i, const auto &j){\\n            return positions[i] < positions[j];\\n        });\\n\\n        deque<int> survivedRobots;\\n        for_each(cbegin(ascendingPositions), cend(ascendingPositions), [&](const auto &pos){\\n            while(collisionDetection(survivedRobots, directions, pos)){\\n                if(healths[survivedRobots.back()] == healths[pos]){\\n                    survivedRobots.pop_back();\\n                    return;\\n                }\\n                if(healths[survivedRobots.back()] > healths[pos]){\\n                    healths[survivedRobots.back()]--;\\n                    return;\\n                }\\n                survivedRobots.pop_back();\\n                healths[pos]--;\\n            }\\n            if(healths[pos] != 0){\\n                survivedRobots.push_back(pos);\\n            }\\n        });\\n\\n        sort(begin(survivedRobots), end(survivedRobots));\\n        vector<int> survivedRobotsHealths(size(survivedRobots));\\n\\n        for(int i = 0; i < size(survivedRobots); ++i){\\n            survivedRobotsHealths[i] = healths[survivedRobots[i]];\\n        }\\n\\n        return survivedRobotsHealths;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    auto collisionDetection(const deque<int> &survivedRobots, const string &directions, const int &pos) const -> int{\\n        const auto &dir     = directions[pos]; \\n\\n        //nobody to collide with\\n        if(empty(survivedRobots)){return false;}\\n\\n        //moving in the same direction ==> no collision\\n        if(directions[survivedRobots.back()] == dir){return false;}\\n\\n        //moving in the opposite direction ==> no collision (L, R) <== O ==>\\n        if(directions[survivedRobots.back()] == \\'L\\'){return false;}\\n    \\n        //moving in the opposite direction ==> collision occurs (R, L) ==> X <==\\n        return true;\\n    }\\npublic:\\n    auto survivedRobotsHealths(const vector<int> &positions, vector<int> &healths, const string &directions) -> vector<int>{\\n        auto robots = size(positions);\\n        vector<int> ascendingPositions(robots);\\n        iota(begin(ascendingPositions), end(ascendingPositions), 0);\\n\\n        sort(begin(ascendingPositions), end(ascendingPositions), [&](const auto &i, const auto &j){\\n            return positions[i] < positions[j];\\n        });\\n\\n        deque<int> survivedRobots;\\n        for_each(cbegin(ascendingPositions), cend(ascendingPositions), [&](const auto &pos){\\n            while(collisionDetection(survivedRobots, directions, pos)){\\n                if(healths[survivedRobots.back()] == healths[pos]){\\n                    survivedRobots.pop_back();\\n                    return;\\n                }\\n                if(healths[survivedRobots.back()] > healths[pos]){\\n                    healths[survivedRobots.back()]--;\\n                    return;\\n                }\\n                survivedRobots.pop_back();\\n                healths[pos]--;\\n            }\\n            if(healths[pos] != 0){\\n                survivedRobots.push_back(pos);\\n            }\\n        });\\n\\n        sort(begin(survivedRobots), end(survivedRobots));\\n        vector<int> survivedRobotsHealths(size(survivedRobots));\\n\\n        for(int i = 0; i < size(survivedRobots); ++i){\\n            survivedRobotsHealths[i] = healths[survivedRobots[i]];\\n        }\\n\\n        return survivedRobotsHealths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819970,
                "title": "stack-based-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct robot{\\n        int pos;\\n        int h;\\n        char d;\\n        int idx;\\n    };\\n\\n    static bool comp(const struct robot &a , const struct robot &b){\\n        return a.pos < b.pos;\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& hl, string dir) {\\n        int n = p.size();\\n        vector<robot> v;\\n        vector<int> ans(n);\\n        stack<robot> st;\\n\\n        for(int i = 0 ; i < n ; i++){\\n            struct robot r;\\n            r.pos = p[i];\\n            r.h = hl[i];\\n            r.d = dir[i];\\n            r.idx = i;\\n            v.push_back(r);\\n        }\\n        sort(v.begin() , v.end() , comp);\\n        st.push(v[0]);\\n        for(int i = 1 ; i < n ; i++){\\n            bool ok = true;\\n            while(!st.empty() and v[i].d == \\'L\\' and st.top().d == \\'R\\'){                if(v[i].h == st.top().h){\\n                    ok = false;\\n                    st.pop();\\n                    break;\\n                }\\n                else if(v[i].h > st.top().h)\\n                {\\n                    st.pop();\\n                    v[i].h--;\\n                }\\n                else if(v[i].h < st.top().h){\\n                    auto it = st.top();\\n                    it.h--;\\n                    st.pop();\\n                    ok = false;\\n                    if(it.h > 0){\\n                        st.push(it);\\n                    }\\n                    break;\\n                }\\n            }\\n            if(ok){\\n                st.push(v[i]);\\n            }\\n        }\\n\\n        vector<int> tmp;\\n        while(!st.empty()){\\n            auto it = st.top();\\n            st.pop();\\n            ans[it.idx] = it.h;\\n        }\\n\\n        for(int i = 0 ; i < n ; i++){\\n            if(ans[i] != 0){\\n                tmp.push_back(ans[i]);\\n            }\\n        }\\n\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct robot{\\n        int pos;\\n        int h;\\n        char d;\\n        int idx;\\n    };\\n\\n    static bool comp(const struct robot &a , const struct robot &b){\\n        return a.pos < b.pos;\\n    }\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& hl, string dir) {\\n        int n = p.size();\\n        vector<robot> v;\\n        vector<int> ans(n);\\n        stack<robot> st;\\n\\n        for(int i = 0 ; i < n ; i++){\\n            struct robot r;\\n            r.pos = p[i];\\n            r.h = hl[i];\\n            r.d = dir[i];\\n            r.idx = i;\\n            v.push_back(r);\\n        }\\n        sort(v.begin() , v.end() , comp);\\n        st.push(v[0]);\\n        for(int i = 1 ; i < n ; i++){\\n            bool ok = true;\\n            while(!st.empty() and v[i].d == \\'L\\' and st.top().d == \\'R\\'){                if(v[i].h == st.top().h){\\n                    ok = false;\\n                    st.pop();\\n                    break;\\n                }\\n                else if(v[i].h > st.top().h)\\n                {\\n                    st.pop();\\n                    v[i].h--;\\n                }\\n                else if(v[i].h < st.top().h){\\n                    auto it = st.top();\\n                    it.h--;\\n                    st.pop();\\n                    ok = false;\\n                    if(it.h > 0){\\n                        st.push(it);\\n                    }\\n                    break;\\n                }\\n            }\\n            if(ok){\\n                st.push(v[i]);\\n            }\\n        }\\n\\n        vector<int> tmp;\\n        while(!st.empty()){\\n            auto it = st.top();\\n            st.pop();\\n            ans[it.idx] = it.h;\\n        }\\n\\n        for(int i = 0 ; i < n ; i++){\\n            if(ans[i] != 0){\\n                tmp.push_back(ans[i]);\\n            }\\n        }\\n\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805545,
                "title": "c-solution-stack-sorting-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> SurvivedRobotsHealths(int[] positions, int[] healths, string directions) {\\n        int n = positions.Length;\\n        Robot[] robots = new Robot[n];\\n\\n        for(int j=0; j<n; j++){\\n            robots[j] = new Robot(positions[j], healths[j], directions[j], j);\\n        }\\n\\n        Array.Sort(robots, (a, b) => a.Position - b.Position);\\n        Stack<Robot> stack = new();\\n        int i=0;\\n\\n        while(i < n){\\n            while(i < n && robots[i].Direction == \\'R\\'){\\n                //Console.WriteLine($\"Pushed => {robots[i].Health}\");\\n                stack.Push(robots[i++]);\\n            }\\n            \\n            while(i<n && stack.Count > 0 && stack.Peek().Direction == \\'R\\' && robots[i].Direction == \\'L\\'){\\n                if(robots[i].Health > stack.Peek().Health){\\n                    //Console.WriteLine($\"Popped and Reduced=> {robots[i].Health}\");\\n                    robots[i].Health--;\\n                    stack.Pop();\\n                }\\n                else if(robots[i].Health < stack.Peek().Health){\\n                    //Console.WriteLine($\"Reduced=> {robots[i].Health}, {stack.Peek().Health}\");\\n                    stack.Peek().Health--;\\n                    i++;\\n                }\\n                else{\\n                    //Console.WriteLine($\"Popped => {robots[i].Health}, {stack.Peek().Health}\");\\n                    stack.Pop();\\n                    i++;\\n                }\\n            }\\n\\n            if(i<n)\\n                stack.Push(robots[i++]);\\n        }\\n\\n        List<Robot> res = new List<Robot>();\\n\\n        while(stack.Count > 0){\\n            res.Add(stack.Pop());\\n        }\\n\\n        return res.OrderBy(x=>x.Index).Select(x=>x.Health).ToList();\\n\\n    }\\n\\n    public class Robot {\\n        public int Position;\\n        public int Health;\\n        public char Direction;\\n        public int Index;\\n\\n        public Robot(int position, int health, char direction, int index){\\n            Position = position;\\n            Health = health;\\n            Direction = direction;\\n            Index = index;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Stack",
                    "Sorting",
                    "Simulation"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> SurvivedRobotsHealths(int[] positions, int[] healths, string directions) {\\n        int n = positions.Length;\\n        Robot[] robots = new Robot[n];\\n\\n        for(int j=0; j<n; j++){\\n            robots[j] = new Robot(positions[j], healths[j], directions[j], j);\\n        }\\n\\n        Array.Sort(robots, (a, b) => a.Position - b.Position);\\n        Stack<Robot> stack = new();\\n        int i=0;\\n\\n        while(i < n){\\n            while(i < n && robots[i].Direction == \\'R\\'){\\n                //Console.WriteLine($\"Pushed => {robots[i].Health}\");\\n                stack.Push(robots[i++]);\\n            }\\n            \\n            while(i<n && stack.Count > 0 && stack.Peek().Direction == \\'R\\' && robots[i].Direction == \\'L\\'){\\n                if(robots[i].Health > stack.Peek().Health){\\n                    //Console.WriteLine($\"Popped and Reduced=> {robots[i].Health}\");\\n                    robots[i].Health--;\\n                    stack.Pop();\\n                }\\n                else if(robots[i].Health < stack.Peek().Health){\\n                    //Console.WriteLine($\"Reduced=> {robots[i].Health}, {stack.Peek().Health}\");\\n                    stack.Peek().Health--;\\n                    i++;\\n                }\\n                else{\\n                    //Console.WriteLine($\"Popped => {robots[i].Health}, {stack.Peek().Health}\");\\n                    stack.Pop();\\n                    i++;\\n                }\\n            }\\n\\n            if(i<n)\\n                stack.Push(robots[i++]);\\n        }\\n\\n        List<Robot> res = new List<Robot>();\\n\\n        while(stack.Count > 0){\\n            res.Add(stack.Pop());\\n        }\\n\\n        return res.OrderBy(x=>x.Index).Select(x=>x.Health).ToList();\\n\\n    }\\n\\n    public class Robot {\\n        public int Position;\\n        public int Health;\\n        public char Direction;\\n        public int Index;\\n\\n        public Robot(int position, int health, char direction, int index){\\n            Position = position;\\n            Health = health;\\n            Direction = direction;\\n            Index = index;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795057,
                "title": "simple-stack-sorting-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public IList<int> SurvivedRobotsHealths(int[] positions, int[] healths, string directions)\\n    {\\n        int n = positions.Length;\\n        int[] indexLookup = new int[n];\\n        for (int i = 0; i < n; i++)\\n            indexLookup[i] = i;\\n\\n        Array.Sort(indexLookup, (x, y) => positions[x] - positions[y]);\\n        Stack<int> roboStack = new Stack<int>();\\n\\n        foreach (int robo in indexLookup)\\n        {\\n            if (directions[robo] == \\'R\\'){\\n                roboStack.Push(robo);\\n                continue;\\n            }\\n\\n            while (roboStack.Count != 0)\\n            {\\n                int topRobo = roboStack.Peek();\\n                if (healths[topRobo] == healths[robo])\\n                {\\n                    healths[topRobo] = 0;\\n                    healths[robo] = 0;\\n                    roboStack.Pop();\\n                    break;\\n                }\\n\\n                if (healths[topRobo] < healths[robo])\\n                {\\n                    healths[topRobo] = 0;\\n                    healths[robo] -= 1;\\n                    roboStack.Pop();\\n                }\\n                else\\n                {\\n                    healths[robo] = 0;\\n                    healths[topRobo] -= 1;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        List<int> result = new List<int>();\\n        foreach (int health in healths)\\n            if (health != 0)\\n                result.Add(health);\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<int> SurvivedRobotsHealths(int[] positions, int[] healths, string directions)\\n    {\\n        int n = positions.Length;\\n        int[] indexLookup = new int[n];\\n        for (int i = 0; i < n; i++)\\n            indexLookup[i] = i;\\n\\n        Array.Sort(indexLookup, (x, y) => positions[x] - positions[y]);\\n        Stack<int> roboStack = new Stack<int>();\\n\\n        foreach (int robo in indexLookup)\\n        {\\n            if (directions[robo] == \\'R\\'){\\n                roboStack.Push(robo);\\n                continue;\\n            }\\n\\n            while (roboStack.Count != 0)\\n            {\\n                int topRobo = roboStack.Peek();\\n                if (healths[topRobo] == healths[robo])\\n                {\\n                    healths[topRobo] = 0;\\n                    healths[robo] = 0;\\n                    roboStack.Pop();\\n                    break;\\n                }\\n\\n                if (healths[topRobo] < healths[robo])\\n                {\\n                    healths[topRobo] = 0;\\n                    healths[robo] -= 1;\\n                    roboStack.Pop();\\n                }\\n                else\\n                {\\n                    healths[robo] = 0;\\n                    healths[topRobo] -= 1;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        List<int> result = new List<int>();\\n        foreach (int health in healths)\\n            if (health != 0)\\n                result.Add(health);\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794402,
                "title": "c-solution-with-stacks",
                "content": "# Intuition\\nProcess Collisions in sorted manner . Think of some data structures \\nwhich can store health ,  positions , index and directions for further use . Then process collisions and for avoiding repeative iterating use stack to keep track of previous data and push the above data in it.\\n\\n# Approach\\nFirst Sort your data structure based on position (Most Important).\\nThen keep track of index with it and then process collisions.If stack is empty , then push data , otherwise check collision conditions , however here is only one condition that is R and then L . Check for it\\nand when you find that pop from stack and take care of edge cases.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n\\n        vector<pair<int,vector<int>>>v;\\n        for(int i = 0;i<positions.size();++i)\\n        {\\n            v.push_back({positions[i],{i,healths[i],directions[i]}});\\n        }\\n\\n        sort(v.begin(),v.end());\\n        stack<pair<int,pair<int,char>>>st;\\n        for(int i = 0;i<v.size();++i)\\n        {\\n            if(st.empty())\\n            {\\n                st.push({v[i].second[0],{v[i].second[1],v[i].second[2]}});\\n            }\\n            else\\n            {\\n                if(v[i].second[2] == \\'L\\' && st.top().second.second == \\'R\\')\\n                {\\n                    bool check = false;\\n                    while(!st.empty() && st.top().second.second == \\'R\\')\\n                    {\\n                        if(st.top().second.first > v[i].second[1])\\n                        {\\n                            check = true;\\n                            st.top().second.first -=1;\\n                            break;\\n                        }\\n                        else if(st.top().second.first == v[i].second[1])\\n                        {\\n                            check = true;\\n                            st.pop();\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            v[i].second[1] -=1;\\n                            st.pop();\\n                        }\\n                    }\\n\\n                    if(!check)\\n                    {\\n                        st.push({v[i].second[0],{v[i].second[1],v[i].second[2]}});\\n                    }\\n                }\\n                else\\n                {\\n                    st.push({v[i].second[0],{v[i].second[1],v[i].second[2]}});\\n                }\\n                \\n            }\\n        }\\n        vector<pair<int,int>>res;\\n        while(!st.empty())\\n        {\\n            res.push_back({st.top().first,st.top().second.first});\\n            st.pop();\\n        }\\n        \\n        sort(res.begin(),res.end());\\n        vector<int>ans;\\n        for(int i = 0;i<res.size();++i)\\n        {\\n            ans.push_back(res[i].second);\\n        }\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n\\n        vector<pair<int,vector<int>>>v;\\n        for(int i = 0;i<positions.size();++i)\\n        {\\n            v.push_back({positions[i],{i,healths[i],directions[i]}});\\n        }\\n\\n        sort(v.begin(),v.end());\\n        stack<pair<int,pair<int,char>>>st;\\n        for(int i = 0;i<v.size();++i)\\n        {\\n            if(st.empty())\\n            {\\n                st.push({v[i].second[0],{v[i].second[1],v[i].second[2]}});\\n            }\\n            else\\n            {\\n                if(v[i].second[2] == \\'L\\' && st.top().second.second == \\'R\\')\\n                {\\n                    bool check = false;\\n                    while(!st.empty() && st.top().second.second == \\'R\\')\\n                    {\\n                        if(st.top().second.first > v[i].second[1])\\n                        {\\n                            check = true;\\n                            st.top().second.first -=1;\\n                            break;\\n                        }\\n                        else if(st.top().second.first == v[i].second[1])\\n                        {\\n                            check = true;\\n                            st.pop();\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            v[i].second[1] -=1;\\n                            st.pop();\\n                        }\\n                    }\\n\\n                    if(!check)\\n                    {\\n                        st.push({v[i].second[0],{v[i].second[1],v[i].second[2]}});\\n                    }\\n                }\\n                else\\n                {\\n                    st.push({v[i].second[0],{v[i].second[1],v[i].second[2]}});\\n                }\\n                \\n            }\\n        }\\n        vector<pair<int,int>>res;\\n        while(!st.empty())\\n        {\\n            res.push_back({st.top().first,st.top().second.first});\\n            st.pop();\\n        }\\n        \\n        sort(res.begin(),res.end());\\n        vector<int>ans;\\n        for(int i = 0;i<res.size();++i)\\n        {\\n            ans.push_back(res[i].second);\\n        }\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793372,
                "title": "stack-hashmap-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        unordered_map<int, int> health;\\n        unordered_map<int, char> direc;\\n        stack<int> s;\\n        vector<int> result;\\n\\n        for(int i = 0; i < positions.size(); i++) {\\n            health[positions[i]] = healths[i];\\n            direc[positions[i]] = directions[i];\\n        }\\n        \\n        vector<int> v = positions;\\n        sort(positions.begin(), positions.end());\\n\\n        for(auto pos : positions) {\\n            if(!s.empty() && direc[pos] == \\'L\\' ) {\\n                while(!s.empty() && direc[s.top()] != direc[pos] && health[pos] > 0) {\\n                    int leftPos = s.top(); s.pop();\\n\\n                    if(health[leftPos] > health[pos]) {\\n                        health[leftPos]--;\\n                        health[pos] = 0;\\n                        s.push(leftPos);\\n                    } else if(health[leftPos] < health[pos]) {\\n                        health[pos]--;\\n                        health[leftPos] = 0;\\n                    } else {\\n                        health[leftPos] = 0;\\n                        health[pos] = 0;\\n                    }\\n                } \\n                \\n                if(health[pos] > 0)s.push(pos);\\n\\n            } else {\\n                s.push(pos);\\n            }\\n        }\\n\\n        for(auto num : v) {\\n            if(health[num] > 0) result.push_back(health[num]);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        unordered_map<int, int> health;\\n        unordered_map<int, char> direc;\\n        stack<int> s;\\n        vector<int> result;\\n\\n        for(int i = 0; i < positions.size(); i++) {\\n            health[positions[i]] = healths[i];\\n            direc[positions[i]] = directions[i];\\n        }\\n        \\n        vector<int> v = positions;\\n        sort(positions.begin(), positions.end());\\n\\n        for(auto pos : positions) {\\n            if(!s.empty() && direc[pos] == \\'L\\' ) {\\n                while(!s.empty() && direc[s.top()] != direc[pos] && health[pos] > 0) {\\n                    int leftPos = s.top(); s.pop();\\n\\n                    if(health[leftPos] > health[pos]) {\\n                        health[leftPos]--;\\n                        health[pos] = 0;\\n                        s.push(leftPos);\\n                    } else if(health[leftPos] < health[pos]) {\\n                        health[pos]--;\\n                        health[leftPos] = 0;\\n                    } else {\\n                        health[leftPos] = 0;\\n                        health[pos] = 0;\\n                    }\\n                } \\n                \\n                if(health[pos] > 0)s.push(pos);\\n\\n            } else {\\n                s.push(pos);\\n            }\\n        }\\n\\n        for(auto num : v) {\\n            if(health[num] > 0) result.push_back(health[num]);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792986,
                "title": "optimal-solution-using-stack",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        stack = []\\n        n = len(positions)\\n\\n        ind = sorted(range(n) , key=positions.__getitem__)\\n\\n        for i in ind:\\n            while stack and directions[stack[-1]] == \\'R\\' and directions[i] == \\'L\\' and healths[i] != 0:\\n                diff = healths[stack[-1]] - healths[i]\\n\\n                if diff == 0:\\n                    healths[i] = 0\\n                    healths[stack[-1]] = 0\\n                    stack.pop()\\n                if diff < 0:\\n                    healths[stack[-1]] = 0\\n                    healths[i] -= 1\\n                    stack.pop()\\n                if diff > 0:\\n                    healths[stack[-1]] -= 1\\n                    healths[i] = 0\\n            \\n            if healths[i] != 0:\\n                stack.append(i)\\n\\n        ans = []\\n        for h in healths:\\n            if h != 0:\\n                ans.append(h)\\n\\n        return  ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        stack = []\\n        n = len(positions)\\n\\n        ind = sorted(range(n) , key=positions.__getitem__)\\n\\n        for i in ind:\\n            while stack and directions[stack[-1]] == \\'R\\' and directions[i] == \\'L\\' and healths[i] != 0:\\n                diff = healths[stack[-1]] - healths[i]\\n\\n                if diff == 0:\\n                    healths[i] = 0\\n                    healths[stack[-1]] = 0\\n                    stack.pop()\\n                if diff < 0:\\n                    healths[stack[-1]] = 0\\n                    healths[i] -= 1\\n                    stack.pop()\\n                if diff > 0:\\n                    healths[stack[-1]] -= 1\\n                    healths[i] = 0\\n            \\n            if healths[i] != 0:\\n                stack.append(i)\\n\\n        ans = []\\n        for h in healths:\\n            if h != 0:\\n                ans.append(h)\\n\\n        return  ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792060,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint cmp(const void *a,const void *b){\\n    int*aa=*(int**)a;\\n    int*bb=*(int**)b;\\n    return aa[0]-bb[0];\\n}\\nint* survivedRobotsHealths(int* positions, int positionsSize, int* healths, int healthsSize, char * directions, int* returnSize){\\n    int **record=malloc(sizeof(int*)*positionsSize);\\n    int *stack=malloc(sizeof(int)*positionsSize),idx=-1;\\n    int *res=malloc(sizeof(int)*positionsSize);\\n    *returnSize=0;\\n    for(int i=0;i<positionsSize;i++){\\n        record[i]=malloc(sizeof(int)*2);\\n        record[i][0]=positions[i];\\n        record[i][1]=i;\\n        if(directions[i]==\\'L\\') healths[i]*=-1;\\n    }\\n    \\n    qsort(record,positionsSize,sizeof(int*),cmp);\\n    \\n    // for(int i=0;i<positionsSize;i++){\\n    //     printf(\" pos :%d | idx : %d | health : %d\\\\n\",record[i][0],record[i][1],healths[record[i][1]]);\\n    // }\\n    \\n    for(int i=0;i<positionsSize;i++){\\n        if(idx==-1){\\n            stack[++idx]=record[i][1];\\n        }\\n        else if(healths[record[i][1]]<0 && healths[stack[idx]]>0){\\n            if(healths[stack[idx]]==-1*healths[record[i][1]]){\\n                healths[stack[idx]]=0;\\n                healths[record[i][1]]=0;\\n                idx--;\\n            }\\n            else if(healths[stack[idx]]>-1*healths[record[i][1]]){\\n                healths[record[i][1]]=0;\\n                healths[stack[idx]]-=1;\\n            }\\n            else{\\n                while(idx!=-1 && healths[stack[idx]]>0 && healths[stack[idx]]<-1*healths[record[i][1]]){\\n                    healths[stack[idx]]=0;\\n                    idx--;\\n                    healths[record[i][1]]+=1;\\n                }\\n                // both of robots go left \\n                if(idx==-1 || healths[stack[idx]]<0){\\n                    stack[++idx]=record[i][1];\\n                }\\n                // both of robots are equal \\n                else if(-1*healths[record[i][1]]==healths[stack[idx]]){\\n                    healths[stack[idx]]=0;\\n                    healths[record[i][1]]=0;\\n                    idx--;\\n                }\\n                // robot to right is bigger than robot to left \\n                else{\\n                    healths[record[i][1]]=0;\\n                    healths[stack[idx]]-=1;\\n                }\\n            }\\n        }else{\\n            stack[++idx]=record[i][1];\\n        }\\n    }\\n    for(int i=0;i<positionsSize;i++){\\n        free(record[i]);\\n    }\\n    free(record);\\n    free(stack);\\n    for(int i=0;i<positionsSize;i++){\\n        if(healths[i]!=0)\\n            res[(*returnSize)++]=abs(healths[i]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint cmp(const void *a,const void *b){\\n    int*aa=*(int**)a;\\n    int*bb=*(int**)b;\\n    return aa[0]-bb[0];\\n}\\nint* survivedRobotsHealths(int* positions, int positionsSize, int* healths, int healthsSize, char * directions, int* returnSize){\\n    int **record=malloc(sizeof(int*)*positionsSize);\\n    int *stack=malloc(sizeof(int)*positionsSize),idx=-1;\\n    int *res=malloc(sizeof(int)*positionsSize);\\n    *returnSize=0;\\n    for(int i=0;i<positionsSize;i++){\\n        record[i]=malloc(sizeof(int)*2);\\n        record[i][0]=positions[i];\\n        record[i][1]=i;\\n        if(directions[i]==\\'L\\') healths[i]*=-1;\\n    }\\n    \\n    qsort(record,positionsSize,sizeof(int*),cmp);\\n    \\n    // for(int i=0;i<positionsSize;i++){\\n    //     printf(\" pos :%d | idx : %d | health : %d\\\\n\",record[i][0],record[i][1],healths[record[i][1]]);\\n    // }\\n    \\n    for(int i=0;i<positionsSize;i++){\\n        if(idx==-1){\\n            stack[++idx]=record[i][1];\\n        }\\n        else if(healths[record[i][1]]<0 && healths[stack[idx]]>0){\\n            if(healths[stack[idx]]==-1*healths[record[i][1]]){\\n                healths[stack[idx]]=0;\\n                healths[record[i][1]]=0;\\n                idx--;\\n            }\\n            else if(healths[stack[idx]]>-1*healths[record[i][1]]){\\n                healths[record[i][1]]=0;\\n                healths[stack[idx]]-=1;\\n            }\\n            else{\\n                while(idx!=-1 && healths[stack[idx]]>0 && healths[stack[idx]]<-1*healths[record[i][1]]){\\n                    healths[stack[idx]]=0;\\n                    idx--;\\n                    healths[record[i][1]]+=1;\\n                }\\n                // both of robots go left \\n                if(idx==-1 || healths[stack[idx]]<0){\\n                    stack[++idx]=record[i][1];\\n                }\\n                // both of robots are equal \\n                else if(-1*healths[record[i][1]]==healths[stack[idx]]){\\n                    healths[stack[idx]]=0;\\n                    healths[record[i][1]]=0;\\n                    idx--;\\n                }\\n                // robot to right is bigger than robot to left \\n                else{\\n                    healths[record[i][1]]=0;\\n                    healths[stack[idx]]-=1;\\n                }\\n            }\\n        }else{\\n            stack[++idx]=record[i][1];\\n        }\\n    }\\n    for(int i=0;i<positionsSize;i++){\\n        free(record[i]);\\n    }\\n    free(record);\\n    free(stack);\\n    for(int i=0;i<positionsSize;i++){\\n        if(healths[i]!=0)\\n            res[(*returnSize)++]=abs(healths[i]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3791663,
                "title": "python3-solution-using-sorting",
                "content": "# Intuition\\nFollowing a similar logic as in [Problem 735](https://leetcode.com/problems/asteroid-collision) but encoding R as +ve and L as -ve and sorting according to positions.\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        arr = [(a+1, b, -c if d == \\'L\\' else c) for a, (b,c,d) in enumerate(zip(positions, healths, directions)) ]\\n        arr = sorted(arr, key = lambda x: x[1])\\n        stk = [] \\n        health_res = [0 for _ in healths]\\n        for idx, pos, health in arr:\\n            while stk and stk[-1][-1]>=0 and health<0 and stk[-1][1] < pos:\\n                if abs(health) < abs(stk[-1][-1]):\\n                    stk[-1][-1]-=1\\n                    health = None\\n                    break\\n                elif abs(health) > abs(stk[-1][-1]):\\n                    stk.pop()\\n                    health+=1\\n                elif abs(health) == abs(stk[-1][-1]):\\n                    stk.pop()\\n                    health = None\\n                    break\\n            if health is not None and health!=0: stk.append([idx, pos, health])\\n        health_res = [None for _ in healths]\\n        for a,b,c in stk:\\n            health_res[a-1] = -c if c<0 else c\\n        return [i for i in health_res if i is not None]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        arr = [(a+1, b, -c if d == \\'L\\' else c) for a, (b,c,d) in enumerate(zip(positions, healths, directions)) ]\\n        arr = sorted(arr, key = lambda x: x[1])\\n        stk = [] \\n        health_res = [0 for _ in healths]\\n        for idx, pos, health in arr:\\n            while stk and stk[-1][-1]>=0 and health<0 and stk[-1][1] < pos:\\n                if abs(health) < abs(stk[-1][-1]):\\n                    stk[-1][-1]-=1\\n                    health = None\\n                    break\\n                elif abs(health) > abs(stk[-1][-1]):\\n                    stk.pop()\\n                    health+=1\\n                elif abs(health) == abs(stk[-1][-1]):\\n                    stk.pop()\\n                    health = None\\n                    break\\n            if health is not None and health!=0: stk.append([idx, pos, health])\\n        health_res = [None for _ in healths]\\n        for a,b,c in stk:\\n            health_res[a-1] = -c if c<0 else c\\n        return [i for i in health_res if i is not None]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791434,
                "title": "stack-based-sorting-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: N (Log N) where N is the number of robots\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N where N is the number of robots\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        # sort based on postion\\n        positionHealth = []\\n        for p,h,d in zip(positions,healths,directions):\\n            positionHealth.append([p,h,d])\\n        positionHealth.sort(key = lambda x: x[0])\\n\\n        # stack simulation\\n        stack = []\\n        map = dict()\\n        for p,h,d in positionHealth:\\n            # if directions are same or last stack element is moving towards left\\n            if not stack or stack[-1][-1] == d or stack[-1][-1] == \"L\":\\n                stack.append((p,h,d))\\n                map[p] = h\\n            else:\\n                while stack and stack[-1][-1] != d and h!= 0:\\n                    if stack[-1][1] < h:\\n                        a,b,c = stack.pop()\\n                        h -= 1\\n                        map[a] = 0\\n                        map[p] = h\\n                    elif stack[-1][1] == h:\\n                        a,b,c = stack.pop()\\n                        map[a] = 0\\n                        map[p] = 0\\n                        h = 0\\n                    else:\\n                        h = 0\\n                        stack[-1] = (stack[-1][0],stack[-1][1]-1,stack[-1][-1])\\n                        map[stack[-1][0]] = stack[-1][1]\\n                        map[p] = 0\\n                if not stack and h != 0:\\n                    stack.append((p,h,d))\\n                    map[p] = h\\n        res = []\\n        for pos in positions:\\n            if pos in map and map[pos] != 0:\\n                res.append(map[pos])\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Stack",
                    "Sorting",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        # sort based on postion\\n        positionHealth = []\\n        for p,h,d in zip(positions,healths,directions):\\n            positionHealth.append([p,h,d])\\n        positionHealth.sort(key = lambda x: x[0])\\n\\n        # stack simulation\\n        stack = []\\n        map = dict()\\n        for p,h,d in positionHealth:\\n            # if directions are same or last stack element is moving towards left\\n            if not stack or stack[-1][-1] == d or stack[-1][-1] == \"L\":\\n                stack.append((p,h,d))\\n                map[p] = h\\n            else:\\n                while stack and stack[-1][-1] != d and h!= 0:\\n                    if stack[-1][1] < h:\\n                        a,b,c = stack.pop()\\n                        h -= 1\\n                        map[a] = 0\\n                        map[p] = h\\n                    elif stack[-1][1] == h:\\n                        a,b,c = stack.pop()\\n                        map[a] = 0\\n                        map[p] = 0\\n                        h = 0\\n                    else:\\n                        h = 0\\n                        stack[-1] = (stack[-1][0],stack[-1][1]-1,stack[-1][-1])\\n                        map[stack[-1][0]] = stack[-1][1]\\n                        map[p] = 0\\n                if not stack and h != 0:\\n                    stack.append((p,h,d))\\n                    map[p] = h\\n        res = []\\n        for pos in positions:\\n            if pos in map and map[pos] != 0:\\n                res.append(map[pos])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791336,
                "title": "simple-fast-best-explanation-easy-to-understand",
                "content": "# Intuition\\nRemember one thing: Collision occurs only when the resultant of left is going right and the current is going left!!!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<pair<int,pair<int, char>>>v(n);\\n        for(int i=0;i<n;i++){\\n            v[i]={positions[i], {healths[i], directions[i]}};\\n        }\\n        sort(v.begin(), v.end());\\n        stack<pair<int,pair<int, char>>>st;\\n        unordered_map<int,int>ans;\\n        int i=0;\\n        while(i<n && v[i].second.second==\\'L\\'){\\n            ans[v[i].first]=v[i].second.first;\\n            i++;\\n        }//tackling elements initially going to the left\\n        while(i<n){\\n            if(v[i].second.second==\\'R\\'){\\n                st.push(v[i]);\\n            }//elements going to right is pushed\\n            else{\\n                while(!st.empty() && st.top().second.second==\\'R\\' && v[i].second.first){//if current element is not zero\\n                    if(v[i].second.first<st.top().second.first){\\n                        st.top().second.first=st.top().second.first-1;\\n                        v[i].second.first=0;\\n                    }\\n                    else if(v[i].second.first==st.top().second.first){\\n                        st.pop();\\n                        v[i].second.first=0;\\n                    }\\n                    else{\\n                        v[i].second.first--;\\n                        st.pop();\\n                    }\\n                }\\n                if(v[i].second.first)st.push(v[i]); \\n                //if current element exists after collision\\n                //then push into the stack\\n            }\\n            i++;\\n        }\\n        while(!st.empty()){//converting stack to vector\\n            ans[st.top().first]=st.top().second.first;\\n            st.pop();\\n        }\\n        vector<int>ans2;\\n        for(int i=0;i<n;i++){//rearranging to original position\\n            if(ans.count(positions[i])>0)\\n                ans2.push_back(ans[positions[i]]);\\n        }\\n        return ans2;\\n    }   \\n};\\n```\\n\\n**Please upvote if you find the solution helpful!!**",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<pair<int,pair<int, char>>>v(n);\\n        for(int i=0;i<n;i++){\\n            v[i]={positions[i], {healths[i], directions[i]}};\\n        }\\n        sort(v.begin(), v.end());\\n        stack<pair<int,pair<int, char>>>st;\\n        unordered_map<int,int>ans;\\n        int i=0;\\n        while(i<n && v[i].second.second==\\'L\\'){\\n            ans[v[i].first]=v[i].second.first;\\n            i++;\\n        }//tackling elements initially going to the left\\n        while(i<n){\\n            if(v[i].second.second==\\'R\\'){\\n                st.push(v[i]);\\n            }//elements going to right is pushed\\n            else{\\n                while(!st.empty() && st.top().second.second==\\'R\\' && v[i].second.first){//if current element is not zero\\n                    if(v[i].second.first<st.top().second.first){\\n                        st.top().second.first=st.top().second.first-1;\\n                        v[i].second.first=0;\\n                    }\\n                    else if(v[i].second.first==st.top().second.first){\\n                        st.pop();\\n                        v[i].second.first=0;\\n                    }\\n                    else{\\n                        v[i].second.first--;\\n                        st.pop();\\n                    }\\n                }\\n                if(v[i].second.first)st.push(v[i]); \\n                //if current element exists after collision\\n                //then push into the stack\\n            }\\n            i++;\\n        }\\n        while(!st.empty()){//converting stack to vector\\n            ans[st.top().first]=st.top().second.first;\\n            st.pop();\\n        }\\n        vector<int>ans2;\\n        for(int i=0;i<n;i++){//rearranging to original position\\n            if(ans.count(positions[i])>0)\\n                ans2.push_back(ans[positions[i]]);\\n        }\\n        return ans2;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791226,
                "title": "c-stack-easy-to-understand-beats-87",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    struct info {\\n        int p, h, d, idx;\\n    };\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<info> a(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            a[i].p = positions[i];\\n            a[i].h = healths[i];\\n            a[i].d = (directions[i] == \\'R\\' ? 1 : 0);\\n            a[i].idx = i;\\n        }\\n        sort(a.begin(), a.end(), [&](const info &l, const info &r)\\n        {\\n            if(l.p <= r.p) return true;\\n            return false;\\n        });\\n\\n        vector<int> ans(n);\\n\\n        int i = 0;\\n        while(i < n)\\n        {\\n            if(a[i].d == 0)\\n            {\\n                ans[a[i].idx] = a[i].h;\\n                i++;\\n            }\\n            else break;\\n        }\\n        \\n        stack<info> st;\\n        while(i < n)\\n        {\\n            if(a[i].d == 0)\\n            {\\n                int f = 0;\\n                if(st.empty()) ans[a[i].idx] = a[i].h;\\n                while(!st.empty())\\n                {\\n                    int h1 = st.top().h, h2 = a[i].h;\\n                    if(h1 < h2)\\n                    {\\n                        f = 1;\\n                        a[i].h = a[i].h - 1;\\n                        st.pop();\\n                    }\\n                    else if(h1 > h2)\\n                    {\\n                        f = 0;\\n                        info temp = st.top();\\n                        st.pop();\\n                        temp.h = temp.h - 1;\\n                        st.push(temp);\\n                        break;\\n                    } \\n                    else\\n                    {\\n                        f = 0;\\n                        st.pop();\\n                        break;\\n                    }\\n                }\\n                if(f) ans[a[i].idx] = a[i].h;\\n            }\\n            else\\n            {\\n                st.push(a[i]);\\n            }\\n            i++;\\n        }\\n\\n        while(!st.empty())\\n        {\\n            ans[st.top().idx] = st.top().h;\\n            st.pop();\\n        }\\n\\n        vector<int> res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ans[i] == 0) continue;\\n            res.push_back(ans[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct info {\\n        int p, h, d, idx;\\n    };\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<info> a(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            a[i].p = positions[i];\\n            a[i].h = healths[i];\\n            a[i].d = (directions[i] == \\'R\\' ? 1 : 0);\\n            a[i].idx = i;\\n        }\\n        sort(a.begin(), a.end(), [&](const info &l, const info &r)\\n        {\\n            if(l.p <= r.p) return true;\\n            return false;\\n        });\\n\\n        vector<int> ans(n);\\n\\n        int i = 0;\\n        while(i < n)\\n        {\\n            if(a[i].d == 0)\\n            {\\n                ans[a[i].idx] = a[i].h;\\n                i++;\\n            }\\n            else break;\\n        }\\n        \\n        stack<info> st;\\n        while(i < n)\\n        {\\n            if(a[i].d == 0)\\n            {\\n                int f = 0;\\n                if(st.empty()) ans[a[i].idx] = a[i].h;\\n                while(!st.empty())\\n                {\\n                    int h1 = st.top().h, h2 = a[i].h;\\n                    if(h1 < h2)\\n                    {\\n                        f = 1;\\n                        a[i].h = a[i].h - 1;\\n                        st.pop();\\n                    }\\n                    else if(h1 > h2)\\n                    {\\n                        f = 0;\\n                        info temp = st.top();\\n                        st.pop();\\n                        temp.h = temp.h - 1;\\n                        st.push(temp);\\n                        break;\\n                    } \\n                    else\\n                    {\\n                        f = 0;\\n                        st.pop();\\n                        break;\\n                    }\\n                }\\n                if(f) ans[a[i].idx] = a[i].h;\\n            }\\n            else\\n            {\\n                st.push(a[i]);\\n            }\\n            i++;\\n        }\\n\\n        while(!st.empty())\\n        {\\n            ans[st.top().idx] = st.top().h;\\n            st.pop();\\n        }\\n\\n        vector<int> res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ans[i] == 0) continue;\\n            res.push_back(ans[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790808,
                "title": "c-solution-with-explanation-using-ordered-map-and-vector-array",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a map **(C++ sorts map by default)** for position and health of robots, directions can be assigned by modifying health as positive or negative.\\nSo map will have key as position of robot and value as health, if direction is left, value will be negative of health and in case of right direction keep value as positive.\\n\\nCollision will happen between two robots when directions are L, R;\\nNo collision between \\n    - L, L; \\n    - R, R;\\n    - R, L;\\n\\nMaintain another stack, while iterating over map keep on pushing $${key, value}$$ inside the stack. \\nWhile stack size is greater than equal to 2, compare top two elements of stack for collision, if collision is there pop these 2 elements and push the survior robot inside the stack by decreasing its health by 1.\\nAlso update the new healths for positions inside map.\\n\\nNow to get the output you can iterate over positions array and retrive their corresponsing health from the map, consider it only is health is not 0. Robots with health 0 are dead.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<pair<int, int>> st;\\n        map<int, int> m;\\n        for (int i = 0; i < n; ++i) {\\n            if (directions[i] == \\'L\\') {\\n                m[positions[i]] = -healths[i];\\n            } else {\\n                m[positions[i]] = healths[i];\\n            }\\n        }\\n        for(auto&miter : m) {\\n            if (miter.second == 0) {\\n                continue;\\n            }\\n            st.push_back({miter.first,miter.second});\\n            while (st.size() >= 2) {\\n                pair<int,int> a = st[st.size()-1];\\n                pair<int,int> b = st[st.size()-2];\\n                if (a.second < 0 && b.second > 0) {//collide\\n                    st.pop_back();\\n                    st.pop_back();\\n                    if (abs(a.second) == abs(b.second)) {\\n                        m[a.first] = 0;\\n                        m[b.first] = 0;\\n                    } else if(abs(a.second) > abs(b.second)) {\\n                        m[a.first] = -(abs(a.second)-1);\\n                        m[b.first] = 0;\\n                        if ((abs(a.second)-1) > 0)\\n                            st.push_back({a.first, -(abs(a.second)-1)});\\n                    } else if (abs(a.second) < abs(b.second)){\\n                        m[a.first] = 0;\\n                        m[b.first] = abs(b.second)-1;\\n                        if (abs(b.second)-1 > 0)    st.push_back({b.first, abs(b.second)-1});\\n                    }\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        for (auto&position : positions) {\\n            if (m[position]) {\\n                res.push_back(abs(m[position]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Ordered Map",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<pair<int, int>> st;\\n        map<int, int> m;\\n        for (int i = 0; i < n; ++i) {\\n            if (directions[i] == \\'L\\') {\\n                m[positions[i]] = -healths[i];\\n            } else {\\n                m[positions[i]] = healths[i];\\n            }\\n        }\\n        for(auto&miter : m) {\\n            if (miter.second == 0) {\\n                continue;\\n            }\\n            st.push_back({miter.first,miter.second});\\n            while (st.size() >= 2) {\\n                pair<int,int> a = st[st.size()-1];\\n                pair<int,int> b = st[st.size()-2];\\n                if (a.second < 0 && b.second > 0) {//collide\\n                    st.pop_back();\\n                    st.pop_back();\\n                    if (abs(a.second) == abs(b.second)) {\\n                        m[a.first] = 0;\\n                        m[b.first] = 0;\\n                    } else if(abs(a.second) > abs(b.second)) {\\n                        m[a.first] = -(abs(a.second)-1);\\n                        m[b.first] = 0;\\n                        if ((abs(a.second)-1) > 0)\\n                            st.push_back({a.first, -(abs(a.second)-1)});\\n                    } else if (abs(a.second) < abs(b.second)){\\n                        m[a.first] = 0;\\n                        m[b.first] = abs(b.second)-1;\\n                        if (abs(b.second)-1 > 0)    st.push_back({b.first, abs(b.second)-1});\\n                    }\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        for (auto&position : positions) {\\n            if (m[position]) {\\n                res.push_back(abs(m[position]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790388,
                "title": "js-sorting-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need to pay attention to robots heading right to the left of robots going left. To make this easy, we sort the robots, and scan the list left to right progressively eliminating robots.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe sort the robots, then maintain a \\'left\\' pointer (representing the rightmost right-heading robot we currently know of), and a \\'right\\' pointer (representing the rightmost left-heading robot we currently know of). We then simply loop the right pointer from 0 to the end, moving the left pointer back further left as robots get knocked out.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} positions\\n * @param {number[]} healths\\n * @param {string} directions\\n * @return {number[]}\\n */\\nvar survivedRobotsHealths = function(positions, healths, directions) {\\n    //combine the inputs into one array to make sorting easy\\n    let robots = positions.map((x, idx) => {\\n        return {\\n            h: healths[idx],\\n            r: directions[idx] === \\'R\\',\\n            i: idx\\n        };\\n    });\\n    healths = null, directions = null;\\n\\n    robots.sort((a, b) => positions[a.i]-positions[b.i]);\\n    positions = null;\\n\\n    let l = 0, r = 0;\\n\\n    let rightCount = 0;\\n    \\n    while(r < robots.length) {\\n        //if the robot we\\'re currently considering is headed right,\\n        // make this the new \\'left\\' and continue\\n        if(robots[r].r) { \\n            l = r;\\n            ++r;\\n            ++rightCount;\\n            continue;\\n        }\\n        \\n        //if the current robot is headed left, and we have\\n        //right-headed robots preceding it, it\\'s BATTLE TIME\\n        if(rightCount > 0) {\\n            if(robots[l].h === robots[r].h) {\\n                //mutual knockout\\n                robots[l] = null;\\n                robots[r] = null;\\n                --rightCount;\\n                ++r;\\n            } else if(robots[l].h > robots[r].h) {\\n                //left wins\\n                robots[l].h -= 1;\\n                robots[r] = null;\\n                ++r;\\n                continue;\\n            } else {\\n                //right wins\\n                robots[l] = null;\\n                robots[r].h -= 1; //negative because pointing left.. so ADD\\n                --rightCount;\\n            }\\n        } else {\\n            //we didn\\'t have any right-headed robots.. keep advancing\\n            ++r;\\n        }\\n\\n        //if we knocked out the left robot, move the left pointer back\\n        //to the previous right-headed one. We could use a stack...\\n        //but the test cases don\\'t really call for it.\\n        while(rightCount > 0 && (robots[l] === null || !robots[l].r)) {\\n            --l;\\n        }\\n    }\\n\\n    //sort and return the robots that didn\\'t get knocked out\\n    robots = robots.filter(x=>x);\\n    robots.sort((a, b) => {\\n        return a.i-b.i;\\n    });\\n\\n    let ret = new Uint32Array(robots.length);\\n    let cnt = 0;\\n    for(let i = 0; i < robots.length; ++i) {\\n        if(robots[i]) {\\n            ret[cnt++] = robots[i].h;\\n        }\\n    }\\n\\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} positions\\n * @param {number[]} healths\\n * @param {string} directions\\n * @return {number[]}\\n */\\nvar survivedRobotsHealths = function(positions, healths, directions) {\\n    //combine the inputs into one array to make sorting easy\\n    let robots = positions.map((x, idx) => {\\n        return {\\n            h: healths[idx],\\n            r: directions[idx] === \\'R\\',\\n            i: idx\\n        };\\n    });\\n    healths = null, directions = null;\\n\\n    robots.sort((a, b) => positions[a.i]-positions[b.i]);\\n    positions = null;\\n\\n    let l = 0, r = 0;\\n\\n    let rightCount = 0;\\n    \\n    while(r < robots.length) {\\n        //if the robot we\\'re currently considering is headed right,\\n        // make this the new \\'left\\' and continue\\n        if(robots[r].r) { \\n            l = r;\\n            ++r;\\n            ++rightCount;\\n            continue;\\n        }\\n        \\n        //if the current robot is headed left, and we have\\n        //right-headed robots preceding it, it\\'s BATTLE TIME\\n        if(rightCount > 0) {\\n            if(robots[l].h === robots[r].h) {\\n                //mutual knockout\\n                robots[l] = null;\\n                robots[r] = null;\\n                --rightCount;\\n                ++r;\\n            } else if(robots[l].h > robots[r].h) {\\n                //left wins\\n                robots[l].h -= 1;\\n                robots[r] = null;\\n                ++r;\\n                continue;\\n            } else {\\n                //right wins\\n                robots[l] = null;\\n                robots[r].h -= 1; //negative because pointing left.. so ADD\\n                --rightCount;\\n            }\\n        } else {\\n            //we didn\\'t have any right-headed robots.. keep advancing\\n            ++r;\\n        }\\n\\n        //if we knocked out the left robot, move the left pointer back\\n        //to the previous right-headed one. We could use a stack...\\n        //but the test cases don\\'t really call for it.\\n        while(rightCount > 0 && (robots[l] === null || !robots[l].r)) {\\n            --l;\\n        }\\n    }\\n\\n    //sort and return the robots that didn\\'t get knocked out\\n    robots = robots.filter(x=>x);\\n    robots.sort((a, b) => {\\n        return a.i-b.i;\\n    });\\n\\n    let ret = new Uint32Array(robots.length);\\n    let cnt = 0;\\n    for(let i = 0; i < robots.length; ++i) {\\n        if(robots[i]) {\\n            ret[cnt++] = robots[i].h;\\n        }\\n    }\\n\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3790233,
                "title": "easy-c-2-approach-stack-implementation-commented-code-no-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n\\n        stack<int> st;\\n        int n = positions.size();\\n        vector<int> idx(n);        //taking account of robot index\\n        for(int i = 0; i < n; i++) \\n            idx[i] = i;\\n\\n        sort(idx.begin(),idx.end(),[&](int i, int j) { //sort index wrt positions\\n           return positions[i] < positions[j]; \\n        });\\n\\n        //idx will contain index of robot position after sorting their position,\\n        //this way, we will reduce our time complexity\\n        for(int j = 0; j < n; j++) { \\n            int i = idx[j];  //getting index of robot\\n\\n            if(directions[i] == \\'L\\' && st.empty()) continue; \\n            else if(directions[i] == \\'R\\') st.push(i);\\n            else { //this condition, is when there is possibility of RL(only condition of collision)\\n                while(!st.empty()) {\\n                    int top = st.top();\\n                    st.pop();\\n                    if(healths[top] > healths[i]) { //if different health,\\n                        healths[top] -= 1;    // decreasing health of robot with higher health\\n                        healths[i] = 0;       // making health of robot with lower health to 0\\n                        st.push(top);\\n                        break;    //since stack top robot has more health, destroy incoming robot and break;\\n                    } \\n                    else if(healths[top] == healths[i]) { //if same health, both healths set to 0 & break\\n                        healths[i] = 0;\\n                        healths[top] = 0;\\n                        break;\\n                    }\\n                    else { //since incoming robot has more health, iterate over stack robot till it got destroyed or all other robot;\\n                        healths[i] -= 1;\\n                        healths[top] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            if(healths[i]!=0)   //if health 0, means destroyed\\n                ans.push_back(healths[i]);\\n        }\\n        return ans;\\n\\n\\n\\n        // TLE at 2429/2433\\n\\n        // int n=positions.size();\\n        // vector<pair<int,pair<int,int>>> temp(n);\\n        // for(int i=0; i<n; i++) {\\n        //     if(directions[i]==\\'R\\') \\n        //         temp[i] = make_pair(positions[i], make_pair(i, healths[i]));\\n        //     else\\n        //         temp[i] = make_pair(positions[i], make_pair(i, -1*healths[i]));\\n        // }\\n\\n        // sort(temp.begin(), temp.end());\\n\\n\\n        // for(int i=0; i<n-1; i++) {\\n        //     // if(temp.size() == 0 || temp.size() == 1)   break;     //  failed at 1441/2433\\n            \\n        //     if(temp.size() == 0 || temp.size() == 1 || i==temp.size()-1)   break; \\n\\n\\n        //     int x = (temp[i].second).second, y =(temp[i+1].second).second;\\n        //     if(x >0 && y < 0) {\\n        //         if(x + y == 0) {\\n        //             temp.erase(temp.begin()+i, temp.begin()+i+2);\\n        //             i = max(-1,i-2);\\n        //         }\\n        //         else if(abs(x) > abs(y)) {\\n        //             // decrease health of bigger element x\\n        //             (temp[i].second).second -= 1;\\n                    \\n        //             temp.erase(temp.begin()+i+1, temp.begin()+i+2);\\n\\n        //             i = max(-1,i-1);\\n        //         }\\n        //         else if(abs(x) < abs(y)) {\\n        //             // decrease health of bigger element y\\n        //             (temp[i+1].second).second += 1;\\n\\n        //             temp.erase(temp.begin()+i, temp.begin()+i+1);\\n                    \\n        //             i = max(-1,i-2);\\n        //         }\\n        //     }\\n        //     else    continue;\\n        // }\\n\\n        // vector<pair<int,int>> ans;\\n\\n        // for(int i=0; i<temp.size(); i++) {\\n        //     ans.push_back(temp[i].second);\\n        // }\\n        // sort(ans.begin(),ans.end());\\n\\n        // vector<int> res;\\n        // for(int i=0; i<temp.size(); i++) {\\n        //     res.push_back(abs(ans[i].second));\\n        // }\\n        // return res;\\n\\n\\n\\n\\n\\n        ///////////contest incomplete sol /////////\\n\\n        // vector<pair<int,pair<int,int>>> pr;\\n        // for(int i=0; i<positions.size()+1; i++) {\\n        //     pr.push_back(make_pair(positions[i],make_pair(directions[i], healths[i])));\\n        // }\\n        // sort(pr.begin(), pr.end());\\n        \\n        \\n        // for(int i=1; i<pr.size()-1; i++) {\\n        //     if((pr[i].second).first==\\'R\\' && (pr[i+1].second).first==\\'L\\' && pr[i+1].first>pr[i].first) {\\n        //         cout <<\"sds\\\\n\";\\n        //         if((pr[i].second).second == (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i, pr.begin()+i+2);\\n        //             i = i-1;\\n        //         }\\n        //         else if((pr[i].second).second > (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i+1, pr.begin()+i+2);\\n        //             i = i-1;\\n        //         }\\n        //         else if((pr[i].second).second < (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i, pr.begin()+i+1);\\n        //             i = i-1;\\n        //         }\\n        //     }\\n        //     else if((pr[i].second).first==\\'L\\' && (pr[i+1].second).first==\\'R\\' && pr[i+1].first<pr[i].first) {\\n        //         cout <<\"sds\\\\n\";\\n        //         if((pr[i].second).second == (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i, pr.begin()+i+2);\\n        //             cout << i << \" \" << pr.size() <<endl;\\n        //             i = i-1;\\n        //         }\\n        //         else if((pr[i].second).second > (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i+1, pr.begin()+i+2);\\n        //             i = i-1;\\n        //         }\\n        //         else if((pr[i].second).second < (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i, pr.begin()+i+1);\\n        //             i = i-1;\\n        //         }\\n        //     }\\n        // }\\n        \\n        // vector<int> ans;\\n        // for(int i=1; i<pr.size(); i++) {\\n        //     ans.push_back((pr[i].second).second);\\n        // }\\n        \\n        // cout << pr.size();\\n        // return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n\\n        stack<int> st;\\n        int n = positions.size();\\n        vector<int> idx(n);        //taking account of robot index\\n        for(int i = 0; i < n; i++) \\n            idx[i] = i;\\n\\n        sort(idx.begin(),idx.end(),[&](int i, int j) { //sort index wrt positions\\n           return positions[i] < positions[j]; \\n        });\\n\\n        //idx will contain index of robot position after sorting their position,\\n        //this way, we will reduce our time complexity\\n        for(int j = 0; j < n; j++) { \\n            int i = idx[j];  //getting index of robot\\n\\n            if(directions[i] == \\'L\\' && st.empty()) continue; \\n            else if(directions[i] == \\'R\\') st.push(i);\\n            else { //this condition, is when there is possibility of RL(only condition of collision)\\n                while(!st.empty()) {\\n                    int top = st.top();\\n                    st.pop();\\n                    if(healths[top] > healths[i]) { //if different health,\\n                        healths[top] -= 1;    // decreasing health of robot with higher health\\n                        healths[i] = 0;       // making health of robot with lower health to 0\\n                        st.push(top);\\n                        break;    //since stack top robot has more health, destroy incoming robot and break;\\n                    } \\n                    else if(healths[top] == healths[i]) { //if same health, both healths set to 0 & break\\n                        healths[i] = 0;\\n                        healths[top] = 0;\\n                        break;\\n                    }\\n                    else { //since incoming robot has more health, iterate over stack robot till it got destroyed or all other robot;\\n                        healths[i] -= 1;\\n                        healths[top] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            if(healths[i]!=0)   //if health 0, means destroyed\\n                ans.push_back(healths[i]);\\n        }\\n        return ans;\\n\\n\\n\\n        // TLE at 2429/2433\\n\\n        // int n=positions.size();\\n        // vector<pair<int,pair<int,int>>> temp(n);\\n        // for(int i=0; i<n; i++) {\\n        //     if(directions[i]==\\'R\\') \\n        //         temp[i] = make_pair(positions[i], make_pair(i, healths[i]));\\n        //     else\\n        //         temp[i] = make_pair(positions[i], make_pair(i, -1*healths[i]));\\n        // }\\n\\n        // sort(temp.begin(), temp.end());\\n\\n\\n        // for(int i=0; i<n-1; i++) {\\n        //     // if(temp.size() == 0 || temp.size() == 1)   break;     //  failed at 1441/2433\\n            \\n        //     if(temp.size() == 0 || temp.size() == 1 || i==temp.size()-1)   break; \\n\\n\\n        //     int x = (temp[i].second).second, y =(temp[i+1].second).second;\\n        //     if(x >0 && y < 0) {\\n        //         if(x + y == 0) {\\n        //             temp.erase(temp.begin()+i, temp.begin()+i+2);\\n        //             i = max(-1,i-2);\\n        //         }\\n        //         else if(abs(x) > abs(y)) {\\n        //             // decrease health of bigger element x\\n        //             (temp[i].second).second -= 1;\\n                    \\n        //             temp.erase(temp.begin()+i+1, temp.begin()+i+2);\\n\\n        //             i = max(-1,i-1);\\n        //         }\\n        //         else if(abs(x) < abs(y)) {\\n        //             // decrease health of bigger element y\\n        //             (temp[i+1].second).second += 1;\\n\\n        //             temp.erase(temp.begin()+i, temp.begin()+i+1);\\n                    \\n        //             i = max(-1,i-2);\\n        //         }\\n        //     }\\n        //     else    continue;\\n        // }\\n\\n        // vector<pair<int,int>> ans;\\n\\n        // for(int i=0; i<temp.size(); i++) {\\n        //     ans.push_back(temp[i].second);\\n        // }\\n        // sort(ans.begin(),ans.end());\\n\\n        // vector<int> res;\\n        // for(int i=0; i<temp.size(); i++) {\\n        //     res.push_back(abs(ans[i].second));\\n        // }\\n        // return res;\\n\\n\\n\\n\\n\\n        ///////////contest incomplete sol /////////\\n\\n        // vector<pair<int,pair<int,int>>> pr;\\n        // for(int i=0; i<positions.size()+1; i++) {\\n        //     pr.push_back(make_pair(positions[i],make_pair(directions[i], healths[i])));\\n        // }\\n        // sort(pr.begin(), pr.end());\\n        \\n        \\n        // for(int i=1; i<pr.size()-1; i++) {\\n        //     if((pr[i].second).first==\\'R\\' && (pr[i+1].second).first==\\'L\\' && pr[i+1].first>pr[i].first) {\\n        //         cout <<\"sds\\\\n\";\\n        //         if((pr[i].second).second == (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i, pr.begin()+i+2);\\n        //             i = i-1;\\n        //         }\\n        //         else if((pr[i].second).second > (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i+1, pr.begin()+i+2);\\n        //             i = i-1;\\n        //         }\\n        //         else if((pr[i].second).second < (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i, pr.begin()+i+1);\\n        //             i = i-1;\\n        //         }\\n        //     }\\n        //     else if((pr[i].second).first==\\'L\\' && (pr[i+1].second).first==\\'R\\' && pr[i+1].first<pr[i].first) {\\n        //         cout <<\"sds\\\\n\";\\n        //         if((pr[i].second).second == (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i, pr.begin()+i+2);\\n        //             cout << i << \" \" << pr.size() <<endl;\\n        //             i = i-1;\\n        //         }\\n        //         else if((pr[i].second).second > (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i+1, pr.begin()+i+2);\\n        //             i = i-1;\\n        //         }\\n        //         else if((pr[i].second).second < (pr[i+1].second).second) {\\n        //             pr.erase(pr.begin()+i, pr.begin()+i+1);\\n        //             i = i-1;\\n        //         }\\n        //     }\\n        // }\\n        \\n        // vector<int> ans;\\n        // for(int i=1; i<pr.size(); i++) {\\n        //     ans.push_back((pr[i].second).second);\\n        // }\\n        \\n        // cout << pr.size();\\n        // return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3790228,
                "title": "python-simple-solution-using-sorting-and-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        robots = sorted(zip(positions, range(len(positions)), healths, directions))\\n        robots = [quadruplet[1:] for quadruplet in robots]\\n        DELIMITER = \\'X\\'\\n        stack = [DELIMITER]\\n        for index, health, direction in robots:\\n            if direction == \\'R\\':\\n                stack.append([health, index])\\n                continue\\n            add = False\\n            while stack:\\n                if stack[-1][0] == DELIMITER:\\n                    add = True\\n                    break\\n                if stack[-1][0] == health:\\n                    stack.pop()\\n                    break\\n                if stack[-1][0] < health:\\n                    stack.pop()\\n                    health -= 1\\n                else:\\n                    stack[-1][0] -= 1\\n                    break\\n            if add:\\n                stack.append([health, index])\\n                stack.append(DELIMITER)\\n        result = [health for health in stack if health != DELIMITER]\\n        result = [(index, health) for health, index in result]\\n        result.sort()\\n        return [health for _, health in result]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        robots = sorted(zip(positions, range(len(positions)), healths, directions))\\n        robots = [quadruplet[1:] for quadruplet in robots]\\n        DELIMITER = \\'X\\'\\n        stack = [DELIMITER]\\n        for index, health, direction in robots:\\n            if direction == \\'R\\':\\n                stack.append([health, index])\\n                continue\\n            add = False\\n            while stack:\\n                if stack[-1][0] == DELIMITER:\\n                    add = True\\n                    break\\n                if stack[-1][0] == health:\\n                    stack.pop()\\n                    break\\n                if stack[-1][0] < health:\\n                    stack.pop()\\n                    health -= 1\\n                else:\\n                    stack[-1][0] -= 1\\n                    break\\n            if add:\\n                stack.append([health, index])\\n                stack.append(DELIMITER)\\n        result = [health for health in stack if health != DELIMITER]\\n        result = [(index, health) for health, index in result]\\n        result.sort()\\n        return [health for _, health in result]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783505,
                "title": "very-messy-python-solution",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n))$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        arr = []\\n        for i in range(len(positions)):\\n            arr.append([positions[i], directions[i], healths[i]])\\n        arr.sort()\\n        stack = [arr[0]]\\n        for i in range(1, len(arr)):\\n            # print(stack)\\n            if stack:\\n                prev_pos, prev_dir, prev_health = stack[-1]\\n                if arr[i][1] == \\'L\\' and prev_dir == \\'R\\':\\n                    if prev_health == arr[i][2]:\\n                        stack.pop()\\n                        continue\\n                    elif prev_health > arr[i][2]:\\n                        stack[-1][2] = prev_health - 1\\n                    else:\\n                        stack[-1] = [arr[i][0], arr[i][1], arr[i][2] - 1]\\n                        while len(stack) > 1 and stack[-1][1] == \\'L\\' and stack[-2][1] == \\'R\\':\\n                            if stack[-1][2] == stack[-2][2]:\\n                                stack.pop()\\n                                stack.pop()\\n                            elif stack[-1][2] > stack[-2][2]:\\n                                stack[-2] = [stack[-1][0], stack[-1][1], stack[-1][2]- 1]\\n                                stack.pop()\\n                            else:\\n                                stack[-2][2] = stack[-2][2] - 1\\n                                stack.pop()\\n                else:\\n                    stack.append(arr[i])\\n            else:\\n                stack.append(arr[i])\\n        # print(stack)\\n        record = {}\\n        for i in range(len(stack)):\\n            record[stack[i][0]] = stack[i][2]\\n        \\n        ans = []\\n        for i in positions:\\n            if i in record:\\n                ans.append(record[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        arr = []\\n        for i in range(len(positions)):\\n            arr.append([positions[i], directions[i], healths[i]])\\n        arr.sort()\\n        stack = [arr[0]]\\n        for i in range(1, len(arr)):\\n            # print(stack)\\n            if stack:\\n                prev_pos, prev_dir, prev_health = stack[-1]\\n                if arr[i][1] == \\'L\\' and prev_dir == \\'R\\':\\n                    if prev_health == arr[i][2]:\\n                        stack.pop()\\n                        continue\\n                    elif prev_health > arr[i][2]:\\n                        stack[-1][2] = prev_health - 1\\n                    else:\\n                        stack[-1] = [arr[i][0], arr[i][1], arr[i][2] - 1]\\n                        while len(stack) > 1 and stack[-1][1] == \\'L\\' and stack[-2][1] == \\'R\\':\\n                            if stack[-1][2] == stack[-2][2]:\\n                                stack.pop()\\n                                stack.pop()\\n                            elif stack[-1][2] > stack[-2][2]:\\n                                stack[-2] = [stack[-1][0], stack[-1][1], stack[-1][2]- 1]\\n                                stack.pop()\\n                            else:\\n                                stack[-2][2] = stack[-2][2] - 1\\n                                stack.pop()\\n                else:\\n                    stack.append(arr[i])\\n            else:\\n                stack.append(arr[i])\\n        # print(stack)\\n        record = {}\\n        for i in range(len(stack)):\\n            record[stack[i][0]] = stack[i][2]\\n        \\n        ans = []\\n        for i in positions:\\n            if i in record:\\n                ans.append(record[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782145,
                "title": "hopefully-easy-to-understand-c-beating-96-of-users-in-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOkay so lets image this problem in real life. There is single lane road where cars are moving in both directions and at same speed.\\n\\nonly possible situation of collision will be when two cars are moving in opposite direction.\\nAnd in case, two cars are moving in same direction, there won\\'t be any collision.\\n\\nSo, based on cars initial position, lets sort the the array and preseve the initial position using **vector<pair<position, index>>**.\\n\\nNow, We will use **a stack** to push only those cars which is moving in **right direction**. while iterating through the array, if\\n- a car is moving in right direction:\\n    - just add car to stack as all cars are moving in same direction.\\n- a car is moving in left direction:\\n    - let is pass through the stack and kill as many car as possible.\\n    - means, till the car moving has some health, keep picking car from stack and update the health of both the car.\\n    - if the health of the car on top of Stack has higher health\\n        - decrease the health of car by 1 using the index in vector. and just update the health of car thats moving in left direction with value = 0.\\n    - if the health of car on top of Stack is equal to the health of car moving in left direction\\n        - update the helath of both of the car with value = 0\\n    - if the health of car on top of the stack is less than the health of the car moving in left direction.\\n        - update the health of the car on top of stack with 0 value and remove from stack.\\n        - decrease the health of the car moving in left direction\\n        - and repease till either\\n            - stack is empty\\n            - health of the car moving in left is 0\\n    - if the car successfully reaches the bottom of the stack. just let it go and chase its dream.\\n\\n\\nNow, since we have to return the health of remaining cars in same order, just return the health vector after removing the health with zero value.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity: O(NlogN)\\n1. We are sorting the position vector with its index O(NlogN)\\n2. We are iterating through the vecor one time: O(N)\\n    1. A while loop for stack that is just touching all the car in moving in right direction only one time over complete parent loop in worse case. O(1)\\n\\nSo overall Time complexity: O(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using one stack and vector of size N: O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<pair<int, int>> vec;\\n        vector<int>res;\\n        for(int i=0; i<n; i++) {\\n            vec.push_back({positions[i], i});\\n        }\\n        sort(vec.begin(), vec.end());\\n        stack<pair<int, int>>stk;\\n\\n        for(auto a: vec) {\\n            if (directions[a.second] == \\'R\\') {\\n                stk.push(a);\\n            } else {\\n                while(!stk.empty() && healths[a.second] > 0) {\\n                    if (healths[stk.top().second] > healths[a.second]) {\\n                        healths[stk.top().second]--;\\n                        healths[a.second] = 0;\\n                    } else if (healths[stk.top().second] < healths[a.second]) {\\n                        healths[stk.top().second] = 0;\\n                        healths[a.second]--;\\n                        stk.pop();\\n                    } else {\\n                        healths[stk.top().second] = 0;\\n                        healths[a.second] = 0;\\n                        stk.pop();\\n                    }\\n                }\\n            }\\n        }\\n        for(auto a: healths) {\\n            if (a) res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<pair<int, int>> vec;\\n        vector<int>res;\\n        for(int i=0; i<n; i++) {\\n            vec.push_back({positions[i], i});\\n        }\\n        sort(vec.begin(), vec.end());\\n        stack<pair<int, int>>stk;\\n\\n        for(auto a: vec) {\\n            if (directions[a.second] == \\'R\\') {\\n                stk.push(a);\\n            } else {\\n                while(!stk.empty() && healths[a.second] > 0) {\\n                    if (healths[stk.top().second] > healths[a.second]) {\\n                        healths[stk.top().second]--;\\n                        healths[a.second] = 0;\\n                    } else if (healths[stk.top().second] < healths[a.second]) {\\n                        healths[stk.top().second] = 0;\\n                        healths[a.second]--;\\n                        stk.pop();\\n                    } else {\\n                        healths[stk.top().second] = 0;\\n                        healths[a.second] = 0;\\n                        stk.pop();\\n                    }\\n                }\\n            }\\n        }\\n        for(auto a: healths) {\\n            if (a) res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769091,
                "title": "c-o-nlogn",
                "content": "\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int> &positions, vector<int> &healths, string directions) {\\n        vector<tuple<int, int, char, int>> viis;\\n        for (int i = 0; i < positions.size(); ++i) viis.push_back(make_tuple(positions[i], healths[i], directions[i], i));\\n        sort(viis.begin(), viis.end(), [](auto &p, auto &q) -> bool {\\n            return get<0>(p) < get<0>(q);\\n        });\\n        vector<tuple<int, int, char, int>> siic;\\n        for (auto &it: viis) {\\n            auto p = it;\\n            while (true) {\\n                if (siic.empty()) {\\n                    siic.push_back(p);\\n                    break;\\n                }\\n                if (get<2>(siic.back()) == \\'R\\' && get<2>(p) == \\'L\\') {\\n                    if (get<1>(siic.back()) == get<1>(p)) {\\n                        siic.pop_back();\\n                        break;\\n                    } else if (get<1>(siic.back()) > get<1>(p)) {\\n                        get<1>(siic.back())--;\\n                        break;\\n                    } else {\\n                        siic.pop_back();\\n                        get<1>(p)--;\\n                    }\\n                } else {\\n                    siic.push_back(p);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(siic.begin(), siic.end(), [](auto &p, auto &q)->bool {\\n            return get<3>(p) < get<3>(q);\\n        });\\n        vector<int> ans(siic.size());\\n        for (int i = 0; i < siic.size(); ++i) ans[i] = get<1>(siic[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int> &positions, vector<int> &healths, string directions) {\\n        vector<tuple<int, int, char, int>> viis;\\n        for (int i = 0; i < positions.size(); ++i) viis.push_back(make_tuple(positions[i], healths[i], directions[i], i));\\n        sort(viis.begin(), viis.end(), [](auto &p, auto &q) -> bool {\\n            return get<0>(p) < get<0>(q);\\n        });\\n        vector<tuple<int, int, char, int>> siic;\\n        for (auto &it: viis) {\\n            auto p = it;\\n            while (true) {\\n                if (siic.empty()) {\\n                    siic.push_back(p);\\n                    break;\\n                }\\n                if (get<2>(siic.back()) == \\'R\\' && get<2>(p) == \\'L\\') {\\n                    if (get<1>(siic.back()) == get<1>(p)) {\\n                        siic.pop_back();\\n                        break;\\n                    } else if (get<1>(siic.back()) > get<1>(p)) {\\n                        get<1>(siic.back())--;\\n                        break;\\n                    } else {\\n                        siic.pop_back();\\n                        get<1>(p)--;\\n                    }\\n                } else {\\n                    siic.push_back(p);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(siic.begin(), siic.end(), [](auto &p, auto &q)->bool {\\n            return get<3>(p) < get<3>(q);\\n        });\\n        vector<int> ans(siic.size());\\n        for (int i = 0; i < siic.size(); ++i) ans[i] = get<1>(siic[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766257,
                "title": "python3-stack-sort",
                "content": "# Approach\\nStack + Sort\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        n = len(positions)\\n        robots = list(enumerate(positions))\\n        robots.sort(key=lambda x : x[1]) # Sort robots by it\\'s position\\n        stk = []\\n        ans = []\\n        for idx, pos in robots:\\n            if directions[idx] == \\'R\\':\\n                stk.append(idx)\\n            else:\\n                while len(stk) > 0:\\n                    if healths[stk[-1]] == healths[idx]: # When both robot die\\n                        healths[idx] = healths[stk.pop()] = 0\\n                        break\\n                    elif healths[stk[-1]] > healths[idx]: # When current robot loses\\n                        healths[stk[-1]] -= 1\\n                        healths[idx] = 0\\n                        break\\n                    else: # When current robot wins\\n                        healths[idx] -= 1\\n                        healths[stk.pop()] = 0\\n        for i in range(n):\\n            if healths[i] > 0:\\n                ans.append(healths[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        n = len(positions)\\n        robots = list(enumerate(positions))\\n        robots.sort(key=lambda x : x[1]) # Sort robots by it\\'s position\\n        stk = []\\n        ans = []\\n        for idx, pos in robots:\\n            if directions[idx] == \\'R\\':\\n                stk.append(idx)\\n            else:\\n                while len(stk) > 0:\\n                    if healths[stk[-1]] == healths[idx]: # When both robot die\\n                        healths[idx] = healths[stk.pop()] = 0\\n                        break\\n                    elif healths[stk[-1]] > healths[idx]: # When current robot loses\\n                        healths[stk[-1]] -= 1\\n                        healths[idx] = 0\\n                        break\\n                    else: # When current robot wins\\n                        healths[idx] -= 1\\n                        healths[stk.pop()] = 0\\n        for i in range(n):\\n            if healths[i] > 0:\\n                ans.append(healths[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759522,
                "title": "c-detailed-approach-using-stack-full-explanation-using-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        //735. Asteroid Collision similar to this question\\n        // the difference here is that we need to remember the index of each robot where they we given in position array  like in example 1, 5 was placed on i==0 and we need to store it to remember itr for last\\n        // in vector v we stored 4 things position,health,index in position array and direction if left then mark it as negative else positive  \\n        vector<pair<int,pair<int,pair<int,int>>>> v(p.size());\\n        for(int i=0;i<p.size();i++){\\n            int a=1;\\n            if(d[i]==\\'L\\'){\\n                a=-1;\\n            }\\n            v[i]={p[i],{h[i],{a,i}}};\\n        }\\n        // now sort v on the basis of position so that we  can take idea that where collision can take place\\n        sort(v.begin(),v.end());\\n        // in array a we will only store health(negative or positive ) and index in original array for future refrence \\n        vector<pair<int,int>> a(p.size());\\n        for(int i=0;i<p.size();i++){\\n            a[i].first=v[i].second.first*v[i].second.second.first;\\n            a[i].second=v[i].second.second.second;\\n        }\\n        \\n        stack<pair<int,int>> s;\\n        for(int i=0;i<a.size();i++){\\n            // if s is empty add element to it \\n            if(s.empty()){\\n                s.push({a[i].first,a[i].second});\\n            }\\n            else{\\n            // current element is moving left ans last elemnt was also moving left then they will not collide \\n                if(a[i].first<0 && s.top().first<0){\\n                    s.push({a[i].first,a[i].second});\\n                } \\n                // else if last element is positive and current is negative then they will collide\\n                else if(a[i].first<0 ){\\n                    // if top element is more then abs of current then current will vanish and top will be reduced by 1\\n                    if(s.top().first>abs(a[i].first)){\\n                        int x=s.top().first;\\n                        int y=s.top().second;\\n                        x-=1;\\n                        s.pop();\\n                        s.push({x,y});\\n                        continue;\\n                    }\\n                    // if both are same then remove last and donot add current \\n                    else if (s.top().first==abs(a[i].first)){\\n                        s.pop();\\n\\n                    }\\n                    else{\\n                        // else if top < curr then remove top until health of current is positive and less than top or s is empty \\n                        while(!s.empty() && s.top().first<abs(a[i].first) && s.top().first>0){\\n                            a[i].first+=1;\\n                            s.pop();\\n                        }\\n                        // push curr if we we get a negative number as they both can exist simuntaneously\\n                        if(s.empty() || s.top().first<0){\\n                            s.push({a[i].first,a[i].second});\\n                        }\\n                        // if top is positive then reduce top by 1 \\n                        else if(s.top().first>abs(a[i].first)){\\n                        int x=s.top().first;\\n                        int y=s.top().second;\\n                        x-=1;\\n                        s.pop();\\n                        s.push({x,y});\\n                        continue;\\n                        }\\n                        else if(s.top().first==abs(a[i].first)){\\n                            s.pop();\\n                        }\\n                        else{\\n                            continue;\\n                        }\\n                    }\\n                }\\n                // if current element is postive \\n                else{\\n                    s.push({a[i].first,a[i].second});\\n                }\\n            }\\n        }\\n        vector<pair<int,int>> m;\\n        while(!s.empty()){\\n            if(s.top().first<0){\\n                m.push_back({s.top().second,-s.top().first});\\n            }\\n            else{\\n            m.push_back({s.top().second,s.top().first});\\n            }\\n            s.pop();\\n        }\\n        sort(m.begin(),m.end());\\n        vector<int> n;\\n        for(int i=0;i<m.size();i++){\\n            n.push_back(m[i].second);\\n        }\\n        // reverse(m.begin(),m.end());\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        //735. Asteroid Collision similar to this question\\n        // the difference here is that we need to remember the index of each robot where they we given in position array  like in example 1, 5 was placed on i==0 and we need to store it to remember itr for last\\n        // in vector v we stored 4 things position,health,index in position array and direction if left then mark it as negative else positive  \\n        vector<pair<int,pair<int,pair<int,int>>>> v(p.size());\\n        for(int i=0;i<p.size();i++){\\n            int a=1;\\n            if(d[i]==\\'L\\'){\\n                a=-1;\\n            }\\n            v[i]={p[i],{h[i],{a,i}}};\\n        }\\n        // now sort v on the basis of position so that we  can take idea that where collision can take place\\n        sort(v.begin(),v.end());\\n        // in array a we will only store health(negative or positive ) and index in original array for future refrence \\n        vector<pair<int,int>> a(p.size());\\n        for(int i=0;i<p.size();i++){\\n            a[i].first=v[i].second.first*v[i].second.second.first;\\n            a[i].second=v[i].second.second.second;\\n        }\\n        \\n        stack<pair<int,int>> s;\\n        for(int i=0;i<a.size();i++){\\n            // if s is empty add element to it \\n            if(s.empty()){\\n                s.push({a[i].first,a[i].second});\\n            }\\n            else{\\n            // current element is moving left ans last elemnt was also moving left then they will not collide \\n                if(a[i].first<0 && s.top().first<0){\\n                    s.push({a[i].first,a[i].second});\\n                } \\n                // else if last element is positive and current is negative then they will collide\\n                else if(a[i].first<0 ){\\n                    // if top element is more then abs of current then current will vanish and top will be reduced by 1\\n                    if(s.top().first>abs(a[i].first)){\\n                        int x=s.top().first;\\n                        int y=s.top().second;\\n                        x-=1;\\n                        s.pop();\\n                        s.push({x,y});\\n                        continue;\\n                    }\\n                    // if both are same then remove last and donot add current \\n                    else if (s.top().first==abs(a[i].first)){\\n                        s.pop();\\n\\n                    }\\n                    else{\\n                        // else if top < curr then remove top until health of current is positive and less than top or s is empty \\n                        while(!s.empty() && s.top().first<abs(a[i].first) && s.top().first>0){\\n                            a[i].first+=1;\\n                            s.pop();\\n                        }\\n                        // push curr if we we get a negative number as they both can exist simuntaneously\\n                        if(s.empty() || s.top().first<0){\\n                            s.push({a[i].first,a[i].second});\\n                        }\\n                        // if top is positive then reduce top by 1 \\n                        else if(s.top().first>abs(a[i].first)){\\n                        int x=s.top().first;\\n                        int y=s.top().second;\\n                        x-=1;\\n                        s.pop();\\n                        s.push({x,y});\\n                        continue;\\n                        }\\n                        else if(s.top().first==abs(a[i].first)){\\n                            s.pop();\\n                        }\\n                        else{\\n                            continue;\\n                        }\\n                    }\\n                }\\n                // if current element is postive \\n                else{\\n                    s.push({a[i].first,a[i].second});\\n                }\\n            }\\n        }\\n        vector<pair<int,int>> m;\\n        while(!s.empty()){\\n            if(s.top().first<0){\\n                m.push_back({s.top().second,-s.top().first});\\n            }\\n            else{\\n            m.push_back({s.top().second,s.top().first});\\n            }\\n            s.pop();\\n        }\\n        sort(m.begin(),m.end());\\n        vector<int> n;\\n        for(int i=0;i<m.size();i++){\\n            n.push_back(m[i].second);\\n        }\\n        // reverse(m.begin(),m.end());\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757888,
                "title": "easily-understandable-stack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<vector<int>> robots;\\n        for(int i=0;i<n;i++){\\n            vector<int>temp;       \\n            temp.push_back(positions[i]);\\n            temp.push_back(i+1);\\n            temp.push_back(healths[i]);\\n            if(directions[i]==\\'R\\'){\\n                temp.push_back(1);\\n            }\\n            else{\\n                temp.push_back(0);\\n            }\\n            robots.push_back(temp);\\n        }\\n        sort(robots.begin(),robots.end());\\n        stack<vector<int>> s1,s2;\\n        for(auto it:robots){\\n            s1.push(it);\\n        }\\n        while(s1.size()!=0){\\n           if(s1.size()>0 && s2.size()==0){\\n               s2.push(s1.top());\\n               s1.pop();\\n           }\\n           else if(s1.size()>0 && s2.size()>0){\\n               vector<int>v1=s1.top();\\n               vector<int>v2=s2.top();\\n               if(v1[3]==v2[3] || (v2[3]==1 && v1[3]==0)){\\n                   s2.push(v1);\\n                   s1.pop();\\n               }\\n               else{\\n                 if(v1[2]==v2[2]){\\n                     s1.pop();\\n                     s2.pop();\\n                 }  \\n                 else if(v1[2]>v2[2]){\\n                     s2.pop();\\n                     v1[2]--;\\n                     s1.pop();\\n                     s1.push(v1);\\n                 }\\n                 else{\\n                     s1.pop();\\n                     v2[2]--;\\n                     s2.pop();\\n                     s2.push(v2);\\n                 }\\n               }\\n\\n               }\\n           }\\n           vector<vector<int>> res;\\n           while(s2.size()!=0){\\n               res.push_back(s2.top());\\n               s2.pop();\\n           }\\n           sort(res.begin(),res.end());\\n           unordered_map<int,int>mp;\\n           for(auto it: res){\\n               mp[it[0]]=it[2];\\n           }\\n\\n           vector<int>ans;\\n           for(int i=0;i<n;i++){\\n               if(mp.find(positions[i])!=mp.end()){\\n                   ans.push_back(mp[positions[i]]);\\n               }\\n           }\\n        return ans;\\n\\n        }\\n\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<vector<int>> robots;\\n        for(int i=0;i<n;i++){\\n            vector<int>temp;       \\n            temp.push_back(positions[i]);\\n            temp.push_back(i+1);\\n            temp.push_back(healths[i]);\\n            if(directions[i]==\\'R\\'){\\n                temp.push_back(1);\\n            }\\n            else{\\n                temp.push_back(0);\\n            }\\n            robots.push_back(temp);\\n        }\\n        sort(robots.begin(),robots.end());\\n        stack<vector<int>> s1,s2;\\n        for(auto it:robots){\\n            s1.push(it);\\n        }\\n        while(s1.size()!=0){\\n           if(s1.size()>0 && s2.size()==0){\\n               s2.push(s1.top());\\n               s1.pop();\\n           }\\n           else if(s1.size()>0 && s2.size()>0){\\n               vector<int>v1=s1.top();\\n               vector<int>v2=s2.top();\\n               if(v1[3]==v2[3] || (v2[3]==1 && v1[3]==0)){\\n                   s2.push(v1);\\n                   s1.pop();\\n               }\\n               else{\\n                 if(v1[2]==v2[2]){\\n                     s1.pop();\\n                     s2.pop();\\n                 }  \\n                 else if(v1[2]>v2[2]){\\n                     s2.pop();\\n                     v1[2]--;\\n                     s1.pop();\\n                     s1.push(v1);\\n                 }\\n                 else{\\n                     s1.pop();\\n                     v2[2]--;\\n                     s2.pop();\\n                     s2.push(v2);\\n                 }\\n               }\\n\\n               }\\n           }\\n           vector<vector<int>> res;\\n           while(s2.size()!=0){\\n               res.push_back(s2.top());\\n               s2.pop();\\n           }\\n           sort(res.begin(),res.end());\\n           unordered_map<int,int>mp;\\n           for(auto it: res){\\n               mp[it[0]]=it[2];\\n           }\\n\\n           vector<int>ans;\\n           for(int i=0;i<n;i++){\\n               if(mp.find(positions[i])!=mp.end()){\\n                   ans.push_back(mp[positions[i]]);\\n               }\\n           }\\n        return ans;\\n\\n        }\\n\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756652,
                "title": "wtf-did-i-do-to-a-simple-brackets-problem-simulation",
                "content": "# Intuition\\nThis solution is done by a game engineer, who got so excited about battling robots, that he simulated the whole sequence with some optimizations! \\n\\nAfter seeing other solutions, the author of this one has covered his face with shame. \\n\\n# Approach\\n\\n1. Let\\'s give identities to robots in a bundle (index, pos, health, dir). See `class Robot`. After doing the simulations, we will simply sort them by index & get the final answer.\\n2. Sort by position (obviously)\\n3. Find out all the battles in the first round.\\n4. Loop:\\n    a. Perform all the battles of previous round.\\n    b. Go through the battling robots and find out who would be the next contenders in their immediate locality. \\n    c. This is done by asking `findLeft(left-1)` and/or `findRight(right+1)`.\\n    d. It is possible that a match will not happen b/w these two in the next round. In this case, we just apply an optimization to bridge the gap of h = 0 b/w findLeft & findRight.\\n\\n\\n# Complexity\\n- Time complexity:\\nNot sure, Most probably: O(n log n) ... All test cases pass!\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n# Robot Collisions\\n### 1. Template:\\nfrom typing import List, Tuple\\nfrom dataclasses import dataclass\\n\\nDEBUG = False\\ndef dprint(*args, **kwargs):\\n    if DEBUG:\\n        print(*args, **kwargs)\\n\\n# 1d array convenience\\ndef isOk(arr, i):\\n    return not (i < 0 or i >= len(arr))\\n\\n### 2. Businesss:\\n@dataclass\\nclass Robot:\\n    i: int\\n    p: int\\n    h: int\\n    dir: int\\n    # If h == 0, then one of the following field has a value.\\n    destroyed_by: int = -1\\n    killed_by: int = -1\\n    last_kill: int = -1\\n    # next_: int = -1\\n\\n    def __init__(self, index, position, health, direction):\\n        self.i = index\\n        self.p = position\\n        self.h = health\\n        self.dir = 0 if direction == \"L\" else 1\\n\\n\\n\\n\\nclass Solution:\\n    def findFirstBattles(self) -> List[Tuple[int, int]]:\\n        \"\"\"i is always less than j. i is moving right & j left.\"\"\"\\n        return [\\n            (i, i + 1)\\n            for i in range(self.N - 1)\\n            if self.robots[i].dir == 1 and self.robots[i + 1].dir == 0\\n        ]\\n\\n    def performBattles(self, battles: List[Tuple[int, int]]) -> None:\\n        for i, j in battles:\\n            if self.robots[i].h == 0 or self.robots[j].h == 0:\\n                continue\\n\\n            if self.robots[i].h == self.robots[j].h:\\n                # Both are destroyed:\\n                self.robots[i].h = 0\\n                self.robots[i].destroyed_by = j\\n                self.robots[j].h = 0\\n                self.robots[j].destroyed_by = i\\n                continue\\n\\n            winner = i if self.robots[i].h > self.robots[j].h else j\\n            loser = i if winner == j else j\\n            # Winner gets damage.\\n            self.robots[winner].h -= 1\\n            self.robots[winner].last_kill = loser\\n            # Loser is KILLED & not DESTROYED:\\n            self.robots[loser].h = 0\\n            self.robots[loser].killed_by = winner\\n\\n    def findLeft(self, index: int) -> int:\\n        # Bot was moving RIGHT. But it was killed or destroyed by someone FROM right.\\n        if self.robots[index].dir == 0:\\n            raise Exception(\\n                f\"findLeft called on a robot moving left! {self.robots[index]}\"\\n            )\\n\\n        if self.robots[index].h > 0:\\n            return index\\n\\n        # go 1 unit left:\\n        if not (isOk(self.robots, index - 1)):\\n            return -1\\n\\n        left = self.robots[index - 1]\\n        if left.h > 0:\\n            return index - 1\\n\\n        return self.findLeft(max(left.killed_by, left.destroyed_by))\\n\\n    def findRight(self, index: int) -> int:\\n        # Bot was moving LEFT. But it was killed or destroyed by someone FROM left.\\n        if self.robots[index].dir == 1:\\n            raise Exception(\\n                f\"findRight called on a robot moving right! {self.robots[index]}\"\\n            )\\n\\n        if self.robots[index].h > 0:\\n            return index\\n\\n        # go 1 unit right:\\n        if not (isOk(self.robots, index + 1)):\\n            return -1\\n\\n        right = self.robots[index + 1]\\n        if right.h > 0:\\n            return index + 1\\n\\n        return self.findRight(max(right.killed_by, right.destroyed_by))\\n\\n    def bridgeGap(self, i, j) -> None:\\n        if i >= j:\\n            return\\n        # Were they both `destroyed`?\\n        if self.robots[i].destroyed_by > 0 and self.robots[j].destroyed_by >= 0:\\n            self.robots[i].destroyed_by = j\\n            self.robots[j].destroyed_by = i\\n\\n    def findNextBattles(self, battles: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\\n        ans = []\\n        annihlations = set(\\n            [(i, j) for i, j in battles if self.robots[i].destroyed_by >= 0]\\n        )\\n        for i, j in battles:\\n            if self.robots[i].h == 0 and self.robots[j].h == 0:\\n                # Annihilation occur[ed!\\n                # But the previous guy was also annihilated!\\n                im1 = i - 1\\n                if (\\n                    isOk(self.robots, im1)\\n                    and (im1, self.robots[im1].destroyed_by) in annihlations\\n                ):\\n                    # The guy towards the left was also annihilated in the last round!\\n                    continue\\n\\n                left = self.findLeft(i)\\n                right = self.findRight(j)\\n\\n                # print(\"Annihilation: \", i, j, left, right)\\n                if left == -1 or right == -1:\\n                    continue\\n\\n                self.bridgeGap(left + 1, right - 1)\\n\\n                if self.robots[left].dir == 1 and self.robots[right].dir == 0:\\n                    ans.append((left, right))\\n                continue\\n\\n            if self.robots[i].h > 0:\\n                # `i` needs to find its next battle contender TOWARDS its RIGHT\\n                contender = self.findRight(j)\\n                if contender == -1:\\n                    continue\\n\\n                # Let\\'s bridge the gap b/w `i` & `contender`:\\n                self.bridgeGap(i + 1, contender - 1)\\n                if self.robots[contender].dir == 0:\\n                    ans.append((i, contender))\\n                continue\\n\\n            if self.robots[j].h > 0:\\n                # `j` needs to find its next battle contender TOWARDS its LEFT\\n                contender = self.findLeft(i)\\n                if contender == -1:\\n                    continue\\n\\n                # Let\\'s bridge the gap b/w `i` & `contender`:\\n                self.bridgeGap(contender + 1, j - 1)\\n                if self.robots[contender].dir == 1:\\n                    ans.append((contender, j))\\n                continue\\n        return ans\\n\\n    def survivedRobotsHealths(\\n        self, positions: List[int], healths: List[int], directions: str\\n    ) -> List[int]:\\n        # Setup:\\n        self.robots = [\\n            Robot(i, p, h, d)\\n            for i, p, h, d in zip(\\n                range(len(positions)),\\n                positions,\\n                healths,\\n                directions,\\n            )\\n        ]\\n        self.N = len(self.robots)\\n\\n        # sort the robots by their positions:\\n        self.robots.sort(key=lambda r: r.p)\\n\\n        self.printState()\\n        battles = self.findFirstBattles()\\n        if DEBUG:\\n            print(\"First Battles:\", battles)\\n\\n        while len(battles) > 0:\\n            self.performBattles(battles)\\n            dprint(\"After Battles: \")\\n            self.printState()\\n\\n            battles = self.findNextBattles(battles)\\n            battles = sorted(list(set(battles)))\\n            dprint(\"Next Battles: \", battles)\\n\\n        # print(\"\\\\n\\\\nAfter All Battles: \")\\n        self.printState()\\n\\n        self.robots.sort(key=lambda r: r.i)\\n        return [r.h for r in self.robots if r.h > 0]\\n\\n    def printState(self):\\n        if DEBUG:\\n            print(\"=== State ===\")\\n            pos = [r.p for r in self.robots]\\n            health = [r.h for r in self.robots]\\n            destroyed_by = [r.destroyed_by for r in self.robots]\\n            killed_by = [r.killed_by for r in self.robots]\\n\\n            print(\"Pos: \" + str(pos))\\n            print(\"Dir: \" + str([r.dir for r in self.robots]))\\n            print(\"Hel: \" + str(health))\\n            print(\"Des: \" + str(destroyed_by))\\n            print(\"Kil: \" + str(killed_by))\\n            print(\"-----------------\")\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Robot Collisions\\n### 1. Template:\\nfrom typing import List, Tuple\\nfrom dataclasses import dataclass\\n\\nDEBUG = False\\ndef dprint(*args, **kwargs):\\n    if DEBUG:\\n        print(*args, **kwargs)\\n\\n# 1d array convenience\\ndef isOk(arr, i):\\n    return not (i < 0 or i >= len(arr))\\n\\n### 2. Businesss:\\n@dataclass\\nclass Robot:\\n    i: int\\n    p: int\\n    h: int\\n    dir: int\\n    # If h == 0, then one of the following field has a value.\\n    destroyed_by: int = -1\\n    killed_by: int = -1\\n    last_kill: int = -1\\n    # next_: int = -1\\n\\n    def __init__(self, index, position, health, direction):\\n        self.i = index\\n        self.p = position\\n        self.h = health\\n        self.dir = 0 if direction == \"L\" else 1\\n\\n\\n\\n\\nclass Solution:\\n    def findFirstBattles(self) -> List[Tuple[int, int]]:\\n        \"\"\"i is always less than j. i is moving right & j left.\"\"\"\\n        return [\\n            (i, i + 1)\\n            for i in range(self.N - 1)\\n            if self.robots[i].dir == 1 and self.robots[i + 1].dir == 0\\n        ]\\n\\n    def performBattles(self, battles: List[Tuple[int, int]]) -> None:\\n        for i, j in battles:\\n            if self.robots[i].h == 0 or self.robots[j].h == 0:\\n                continue\\n\\n            if self.robots[i].h == self.robots[j].h:\\n                # Both are destroyed:\\n                self.robots[i].h = 0\\n                self.robots[i].destroyed_by = j\\n                self.robots[j].h = 0\\n                self.robots[j].destroyed_by = i\\n                continue\\n\\n            winner = i if self.robots[i].h > self.robots[j].h else j\\n            loser = i if winner == j else j\\n            # Winner gets damage.\\n            self.robots[winner].h -= 1\\n            self.robots[winner].last_kill = loser\\n            # Loser is KILLED & not DESTROYED:\\n            self.robots[loser].h = 0\\n            self.robots[loser].killed_by = winner\\n\\n    def findLeft(self, index: int) -> int:\\n        # Bot was moving RIGHT. But it was killed or destroyed by someone FROM right.\\n        if self.robots[index].dir == 0:\\n            raise Exception(\\n                f\"findLeft called on a robot moving left! {self.robots[index]}\"\\n            )\\n\\n        if self.robots[index].h > 0:\\n            return index\\n\\n        # go 1 unit left:\\n        if not (isOk(self.robots, index - 1)):\\n            return -1\\n\\n        left = self.robots[index - 1]\\n        if left.h > 0:\\n            return index - 1\\n\\n        return self.findLeft(max(left.killed_by, left.destroyed_by))\\n\\n    def findRight(self, index: int) -> int:\\n        # Bot was moving LEFT. But it was killed or destroyed by someone FROM left.\\n        if self.robots[index].dir == 1:\\n            raise Exception(\\n                f\"findRight called on a robot moving right! {self.robots[index]}\"\\n            )\\n\\n        if self.robots[index].h > 0:\\n            return index\\n\\n        # go 1 unit right:\\n        if not (isOk(self.robots, index + 1)):\\n            return -1\\n\\n        right = self.robots[index + 1]\\n        if right.h > 0:\\n            return index + 1\\n\\n        return self.findRight(max(right.killed_by, right.destroyed_by))\\n\\n    def bridgeGap(self, i, j) -> None:\\n        if i >= j:\\n            return\\n        # Were they both `destroyed`?\\n        if self.robots[i].destroyed_by > 0 and self.robots[j].destroyed_by >= 0:\\n            self.robots[i].destroyed_by = j\\n            self.robots[j].destroyed_by = i\\n\\n    def findNextBattles(self, battles: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\\n        ans = []\\n        annihlations = set(\\n            [(i, j) for i, j in battles if self.robots[i].destroyed_by >= 0]\\n        )\\n        for i, j in battles:\\n            if self.robots[i].h == 0 and self.robots[j].h == 0:\\n                # Annihilation occur[ed!\\n                # But the previous guy was also annihilated!\\n                im1 = i - 1\\n                if (\\n                    isOk(self.robots, im1)\\n                    and (im1, self.robots[im1].destroyed_by) in annihlations\\n                ):\\n                    # The guy towards the left was also annihilated in the last round!\\n                    continue\\n\\n                left = self.findLeft(i)\\n                right = self.findRight(j)\\n\\n                # print(\"Annihilation: \", i, j, left, right)\\n                if left == -1 or right == -1:\\n                    continue\\n\\n                self.bridgeGap(left + 1, right - 1)\\n\\n                if self.robots[left].dir == 1 and self.robots[right].dir == 0:\\n                    ans.append((left, right))\\n                continue\\n\\n            if self.robots[i].h > 0:\\n                # `i` needs to find its next battle contender TOWARDS its RIGHT\\n                contender = self.findRight(j)\\n                if contender == -1:\\n                    continue\\n\\n                # Let\\'s bridge the gap b/w `i` & `contender`:\\n                self.bridgeGap(i + 1, contender - 1)\\n                if self.robots[contender].dir == 0:\\n                    ans.append((i, contender))\\n                continue\\n\\n            if self.robots[j].h > 0:\\n                # `j` needs to find its next battle contender TOWARDS its LEFT\\n                contender = self.findLeft(i)\\n                if contender == -1:\\n                    continue\\n\\n                # Let\\'s bridge the gap b/w `i` & `contender`:\\n                self.bridgeGap(contender + 1, j - 1)\\n                if self.robots[contender].dir == 1:\\n                    ans.append((contender, j))\\n                continue\\n        return ans\\n\\n    def survivedRobotsHealths(\\n        self, positions: List[int], healths: List[int], directions: str\\n    ) -> List[int]:\\n        # Setup:\\n        self.robots = [\\n            Robot(i, p, h, d)\\n            for i, p, h, d in zip(\\n                range(len(positions)),\\n                positions,\\n                healths,\\n                directions,\\n            )\\n        ]\\n        self.N = len(self.robots)\\n\\n        # sort the robots by their positions:\\n        self.robots.sort(key=lambda r: r.p)\\n\\n        self.printState()\\n        battles = self.findFirstBattles()\\n        if DEBUG:\\n            print(\"First Battles:\", battles)\\n\\n        while len(battles) > 0:\\n            self.performBattles(battles)\\n            dprint(\"After Battles: \")\\n            self.printState()\\n\\n            battles = self.findNextBattles(battles)\\n            battles = sorted(list(set(battles)))\\n            dprint(\"Next Battles: \", battles)\\n\\n        # print(\"\\\\n\\\\nAfter All Battles: \")\\n        self.printState()\\n\\n        self.robots.sort(key=lambda r: r.i)\\n        return [r.h for r in self.robots if r.h > 0]\\n\\n    def printState(self):\\n        if DEBUG:\\n            print(\"=== State ===\")\\n            pos = [r.p for r in self.robots]\\n            health = [r.h for r in self.robots]\\n            destroyed_by = [r.destroyed_by for r in self.robots]\\n            killed_by = [r.killed_by for r in self.robots]\\n\\n            print(\"Pos: \" + str(pos))\\n            print(\"Dir: \" + str([r.dir for r in self.robots]))\\n            print(\"Hel: \" + str(health))\\n            print(\"Des: \" + str(destroyed_by))\\n            print(\"Kil: \" + str(killed_by))\\n            print(\"-----------------\")\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740896,
                "title": "stack-sorting-simulating-rl-collisions-via-stack",
                "content": "# Approach\\nOptimised approach will be to use a stack to add all the traversed robots till position current $$p_i$$ and check if the last robot added to stack will collide or not and do respective operations.\\n\\nFirst we\\'ll create a array of all robots and sort them in he order of their $$positions$$.\\n\\nAfter this we\\'ll iterate robots w.r.t $$positions$$ and and check if the last robot will collide with the current one, we\\'ll use stack for maintaining top order.\\n\\nThe collision will only happen if the last robot in stack ( most recent position before current ) will have direction $$R$$ and current robot have direction $$L$$, then we just simulate the way question asks.\\n\\nAfter all this since we need to return w.r.t $$indices$$ so we\\'ll sort them based on $$indices$$ and we\\'re done.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\n    struct R{\\n        int i, p, h, d ;\\n\\n        R(int x, int y, int j, int k) noexcept : i(x), p(y), h(j), d(k) {} ;\\n    } ;\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        int n = p.size() ;\\n\\n        vector<R> a ;\\n\\n        for(int i = 0 ; i < n ; i++){\\n            a.push_back( R(i, p[i], h[i], d[i]) );\\n        }\\n\\n        sort( a.begin(), a.end(), [](auto& x, auto& y) { return x.p < y.p ; } ) ; // sort w.r.t position\\n\\n        vector<R> st ;\\n        for(int i = 0 ; i < n ; i++){\\n            auto& cur = a[i] ;\\n            \\n            while( st.size() ){\\n                auto& last = st.back() ;\\n                if( !(last.d == \\'R\\' && cur.d == \\'L\\') || cur.h == 0 )\\n                    break ; // no collision or our health 0\\n                if( last.h < cur.h ){ // cur wins\\n                    st.pop_back() ; \\n                    cur.h-- ;\\n                }else if( last.h == cur.h ){ // both dies\\n                    st.pop_back() ;\\n                    cur.h = 0 ;\\n                } else { // last wins\\n                    last.h-- ;\\n                    cur.h = 0 ;\\n                }\\n            }\\n\\n            if( cur.h )\\n                st.push_back( cur ) ;\\n        }\\n\\n        vector<int> ret ;\\n        sort( st.begin(), st.end(), [](auto& x, auto& y){return x.i < y.i ;} ) ; // sort w.r.t indices.\\n\\n        for(auto& i : st){\\n            ret.push_back( i.h ) ;\\n        }\\n\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sort",
                    "Simulation"
                ],
                "code": "```cpp\\nclass Solution {\\n    struct R{\\n        int i, p, h, d ;\\n\\n        R(int x, int y, int j, int k) noexcept : i(x), p(y), h(j), d(k) {} ;\\n    } ;\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        int n = p.size() ;\\n\\n        vector<R> a ;\\n\\n        for(int i = 0 ; i < n ; i++){\\n            a.push_back( R(i, p[i], h[i], d[i]) );\\n        }\\n\\n        sort( a.begin(), a.end(), [](auto& x, auto& y) { return x.p < y.p ; } ) ; // sort w.r.t position\\n\\n        vector<R> st ;\\n        for(int i = 0 ; i < n ; i++){\\n            auto& cur = a[i] ;\\n            \\n            while( st.size() ){\\n                auto& last = st.back() ;\\n                if( !(last.d == \\'R\\' && cur.d == \\'L\\') || cur.h == 0 )\\n                    break ; // no collision or our health 0\\n                if( last.h < cur.h ){ // cur wins\\n                    st.pop_back() ; \\n                    cur.h-- ;\\n                }else if( last.h == cur.h ){ // both dies\\n                    st.pop_back() ;\\n                    cur.h = 0 ;\\n                } else { // last wins\\n                    last.h-- ;\\n                    cur.h = 0 ;\\n                }\\n            }\\n\\n            if( cur.h )\\n                st.push_back( cur ) ;\\n        }\\n\\n        vector<int> ret ;\\n        sort( st.begin(), st.end(), [](auto& x, auto& y){return x.i < y.i ;} ) ; // sort w.r.t indices.\\n\\n        for(auto& i : st){\\n            ret.push_back( i.h ) ;\\n        }\\n\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738830,
                "title": "c-solution-using-stack-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding the nearest opposite moving robot in left direction.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the positions so that we can get the positions in order. Then using stack trace the left moving robot and right moving robot if a robot is moving right then just push it as it cannot collide with any previous robot and if the robot is moving left then it can only collide with previous right moving robot. Robot which gets destroyed marks that health as -1;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string dir) {\\n        int n= positions.size();\\n        vector<pair<int,int>> temp;\\n        for(int i=0;i<n;i++){\\n            temp.push_back({positions[i],i});\\n        }\\n        sort(temp.begin(),temp.end());                                \\n        stack<int>left,right;\\n        for(auto t:temp){\\n            int pos= t.first;\\n            int ind= t.second;\\n            if(dir[ind]==\\'L\\'){\\n                while(!right.empty()){\\n                    int r= right.top();right.pop();\\n                    if(healths[r]>healths[ind]){\\n                        healths[r]= healths[r]-1;\\n                        healths[ind]=-1;\\n                        right.push(r);\\n                        break;\\n                    }\\n                    else if(healths[r]<healths[ind]){\\n                        healths[ind]=healths[ind]-1;\\n                        healths[r]=-1;\\n                    }\\n                    else{\\n                        healths[ind]=-1;\\n                        healths[r]=-1;\\n                        break;\\n                    }\\n                }\\n                if(healths[ind]!=-1){\\n                    left.push(ind);\\n                }\\n            }\\n            else{\\n                right.push(ind);\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(healths[i]!=-1){\\n                ans.push_back(healths[i]);\\n            }\\n        }\\n        return ans;                                            \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string dir) {\\n        int n= positions.size();\\n        vector<pair<int,int>> temp;\\n        for(int i=0;i<n;i++){\\n            temp.push_back({positions[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 3737741,
                "title": "java-detailed-solution-iterate-over-code-for-clear-understanding-cheers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        // have ind list, to store indices\\n        List<Integer> ind = new ArrayList();\\n        for(int i=0;i<n;i++)\\n            ind.add(i);\\n        // sorting the indices basaed on positions of the robot,\\n        Collections.sort(ind, (x,y) -> Integer.compare(positions[x],positions[y]));\\n        System.out.println(ind);\\n        // ind will have indices of positions, in sorted manner\\n        Stack<Integer> st = new Stack();\\n        for(int indx:ind)\\n        {\\n            // indx, is the index of postion of robotss from left to right\\n            if(directions.charAt(indx)==\\'L\\')\\n            {\\n                // then its the problem, since we will hit the robots that are coming right\\n                while(!st.isEmpty())\\n                {\\n                    int popInd = st.peek();\\n                    if(healths[indx]==healths[popInd])\\n                    {\\n                        healths[indx] = 0;\\n                        healths[popInd] = 0;\\n                        st.pop();\\n                        // left coming robot is destroyed , so break\\n                        break;\\n                    }\\n                    if(healths[indx] > healths[popInd])\\n                    {\\n                        healths[indx]--;\\n                        healths[popInd]=0;\\n                        st.pop();\\n                    }\\n                    else\\n                    {\\n                        healths[indx] = 0;\\n                        // current robot is destroyed by the one present in stack\\n                        healths[popInd]--;\\n                        // no work left by current robot, so break out of this looop\\n                        break;\\n                    }\\n\\n                }\\n            }\\n            else\\n            {\\n                // if the direction is right, then add it to the stack\\n                st.push(indx);\\n            }\\n        }\\n\\n        List<Integer> myAns = new ArrayList();\\n        for(int x:healths)\\n            if(x!=0)\\n                myAns.add(x);\\n\\n        return myAns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        // have ind list, to store indices\\n        List<Integer> ind = new ArrayList();\\n        for(int i=0;i<n;i++)\\n            ind.add(i);\\n        // sorting the indices basaed on positions of the robot,\\n        Collections.sort(ind, (x,y) -> Integer.compare(positions[x],positions[y]));\\n        System.out.println(ind);\\n        // ind will have indices of positions, in sorted manner\\n        Stack<Integer> st = new Stack();\\n        for(int indx:ind)\\n        {\\n            // indx, is the index of postion of robotss from left to right\\n            if(directions.charAt(indx)==\\'L\\')\\n            {\\n                // then its the problem, since we will hit the robots that are coming right\\n                while(!st.isEmpty())\\n                {\\n                    int popInd = st.peek();\\n                    if(healths[indx]==healths[popInd])\\n                    {\\n                        healths[indx] = 0;\\n                        healths[popInd] = 0;\\n                        st.pop();\\n                        // left coming robot is destroyed , so break\\n                        break;\\n                    }\\n                    if(healths[indx] > healths[popInd])\\n                    {\\n                        healths[indx]--;\\n                        healths[popInd]=0;\\n                        st.pop();\\n                    }\\n                    else\\n                    {\\n                        healths[indx] = 0;\\n                        // current robot is destroyed by the one present in stack\\n                        healths[popInd]--;\\n                        // no work left by current robot, so break out of this looop\\n                        break;\\n                    }\\n\\n                }\\n            }\\n            else\\n            {\\n                // if the direction is right, then add it to the stack\\n                st.push(indx);\\n            }\\n        }\\n\\n        List<Integer> myAns = new ArrayList();\\n        for(int x:healths)\\n            if(x!=0)\\n                myAns.add(x);\\n\\n        return myAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736143,
                "title": "stack-easy-c-code-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        int n=p.size();\\n        vector<vector<int>>v(n,vector<int>(2));\\n        for(int i=0;i<n;i++){\\n            v[i][0]=p[i];\\n            v[i][1]=i;\\n        }\\n        sort(v.begin(),v.end());\\n        stack<int>q;\\n        q.push(0);\\n        int i=1;\\n        while(i<n){\\n            if(q.size()==0){\\n                q.push(i);\\n                i++;\\n            }\\n            else{\\n                int presd=d[v[i][1]];\\n                int prevd=d[v[q.top()][1]];\\n                int presh=h[v[i][1]];\\n                int prevh=h[v[q.top()][1]];\\n                int presi=v[i][1];\\n                int previ=v[q.top()][1];\\n                int stacki=i;\\n                if(d[v[q.top()][1]]==d[v[i][1]] or (d[v[q.top()][1]]==\\'L\\' and d[v[i][1]]==\\'R\\')){\\n                    q.push(i);\\n                    i++;\\n                }\\n                else{\\n                    bool cut=false;\\n                    while(presd!=prevd){\\n                        if(presh==prevh){\\n                            q.pop();\\n                            i++;\\n                            cut=true;\\n                            break;\\n                        }\\n                        else{\\n                            if(presh>prevh){\\n                                h[presi]--;\\n                                presh--;\\n                                stacki=i;\\n                                q.pop();\\n                                if(q.size()>0){\\n                                    prevd=d[v[q.top()][1]];\\n                                    prevh=h[v[q.top()][1]];\\n                                    previ=v[q.top()][1];\\n                                }\\n                                else{\\n                                    break;\\n                                }\\n                                if(prevd==\\'L\\' and presd==\\'R\\') break;\\n                            }\\n                            else{\\n                                h[previ]--;\\n                                presh=h[previ];\\n                                presd=prevd;\\n                                presi=previ;\\n                                stacki=q.top();\\n                                q.pop();\\n                                if(q.size()>0){\\n                                    prevd=d[v[q.top()][1]];\\n                                    prevh=h[v[q.top()][1]];\\n                                    previ=v[q.top()][1];\\n                                }\\n                                else{\\n                                    break;\\n                                }\\n                                if(prevd==\\'L\\' and presd==\\'R\\') break;\\n                            }\\n                        }\\n                    }\\n                    if(cut==false){\\n                        q.push(stacki);\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int>res;\\n        while(!q.empty()){\\n            res.push_back(v[q.top()][1]);\\n            q.pop();\\n        }\\n        sort(res.begin(),res.end());\\n        for(int i=0;i<res.size();i++){\\n            res[i]=h[res[i]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        int n=p.size();\\n        vector<vector<int>>v(n,vector<int>(2));\\n        for(int i=0;i<n;i++){\\n            v[i][0]=p[i];\\n            v[i][1]=i;\\n        }\\n        sort(v.begin(),v.end());\\n        stack<int>q;\\n        q.push(0);\\n        int i=1;\\n        while(i<n){\\n            if(q.size()==0){\\n                q.push(i);\\n                i++;\\n            }\\n            else{\\n                int presd=d[v[i][1]];\\n                int prevd=d[v[q.top()][1]];\\n                int presh=h[v[i][1]];\\n                int prevh=h[v[q.top()][1]];\\n                int presi=v[i][1];\\n                int previ=v[q.top()][1];\\n                int stacki=i;\\n                if(d[v[q.top()][1]]==d[v[i][1]] or (d[v[q.top()][1]]==\\'L\\' and d[v[i][1]]==\\'R\\')){\\n                    q.push(i);\\n                    i++;\\n                }\\n                else{\\n                    bool cut=false;\\n                    while(presd!=prevd){\\n                        if(presh==prevh){\\n                            q.pop();\\n                            i++;\\n                            cut=true;\\n                            break;\\n                        }\\n                        else{\\n                            if(presh>prevh){\\n                                h[presi]--;\\n                                presh--;\\n                                stacki=i;\\n                                q.pop();\\n                                if(q.size()>0){\\n                                    prevd=d[v[q.top()][1]];\\n                                    prevh=h[v[q.top()][1]];\\n                                    previ=v[q.top()][1];\\n                                }\\n                                else{\\n                                    break;\\n                                }\\n                                if(prevd==\\'L\\' and presd==\\'R\\') break;\\n                            }\\n                            else{\\n                                h[previ]--;\\n                                presh=h[previ];\\n                                presd=prevd;\\n                                presi=previ;\\n                                stacki=q.top();\\n                                q.pop();\\n                                if(q.size()>0){\\n                                    prevd=d[v[q.top()][1]];\\n                                    prevh=h[v[q.top()][1]];\\n                                    previ=v[q.top()][1];\\n                                }\\n                                else{\\n                                    break;\\n                                }\\n                                if(prevd==\\'L\\' and presd==\\'R\\') break;\\n                            }\\n                        }\\n                    }\\n                    if(cut==false){\\n                        q.push(stacki);\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int>res;\\n        while(!q.empty()){\\n            res.push_back(v[q.top()][1]);\\n            q.pop();\\n        }\\n        sort(res.begin(),res.end());\\n        for(int i=0;i<res.size();i++){\\n            res[i]=h[res[i]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726313,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Robot {\\n        int pos;\\n        int health;\\n        char direction;\\n        int index;\\n    };\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<int> in(n);\\n        vector<Robot> robots(n);\\n        for (int i = 0; i < n; i++) {\\n            robots[i].pos = positions[i];\\n            robots[i].health = healths[i];\\n            robots[i].direction = directions[i];\\n            robots[i].index = i;\\n        }\\n        sort(robots.begin(), robots.end(), [] (const Robot& x, const Robot& y) {\\n            return x.pos < y.pos;\\n        });\\n        vector<Robot> left;\\n        vector<Robot> right;\\n        for (int i = 0; i < n; i++) {\\n            if (robots[i].direction == \\'R\\') {\\n                right.push_back(robots[i]);\\n            } else {\\n                while (!right.empty() && right.back().health < robots[i].health) {\\n                    right.pop_back();\\n                    --robots[i].health;\\n                }\\n                if (right.empty()) {\\n                   left.push_back(robots[i]);\\n                } else {\\n                    if (right.back().health == robots[i].health) {\\n                        right.pop_back();\\n                    } else {\\n                        --right.back().health;\\n                    }\\n                }\\n            }\\n        }\\n        for (const Robot& r : right) {\\n            left.push_back(r);\\n        }\\n        sort(left.begin(), left.end(), [] (const Robot& x, const Robot& y) {\\n            return x.index < y.index;\\n        });\\n        vector<int> sol;\\n        for (const Robot& r : left) {\\n            sol.push_back(r.health);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Robot {\\n        int pos;\\n        int health;\\n        char direction;\\n        int index;\\n    };\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<int> in(n);\\n        vector<Robot> robots(n);\\n        for (int i = 0; i < n; i++) {\\n            robots[i].pos = positions[i];\\n            robots[i].health = healths[i];\\n            robots[i].direction = directions[i];\\n            robots[i].index = i;\\n        }\\n        sort(robots.begin(), robots.end(), [] (const Robot& x, const Robot& y) {\\n            return x.pos < y.pos;\\n        });\\n        vector<Robot> left;\\n        vector<Robot> right;\\n        for (int i = 0; i < n; i++) {\\n            if (robots[i].direction == \\'R\\') {\\n                right.push_back(robots[i]);\\n            } else {\\n                while (!right.empty() && right.back().health < robots[i].health) {\\n                    right.pop_back();\\n                    --robots[i].health;\\n                }\\n                if (right.empty()) {\\n                   left.push_back(robots[i]);\\n                } else {\\n                    if (right.back().health == robots[i].health) {\\n                        right.pop_back();\\n                    } else {\\n                        --right.back().health;\\n                    }\\n                }\\n            }\\n        }\\n        for (const Robot& r : right) {\\n            left.push_back(r);\\n        }\\n        sort(left.begin(), left.end(), [] (const Robot& x, const Robot& y) {\\n            return x.index < y.index;\\n        });\\n        vector<int> sol;\\n        for (const Robot& r : left) {\\n            sol.push_back(r.health);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722574,
                "title": "easy-to-understand-java-solution-using-linkedlist-hashmap",
                "content": "# Intuition\\nAgain, let\\'s not to use Stack, since we don\\'t know if the interviewer will take it seriously when we use an outdated data structure. No reason to risk it.\\n\\n# Approach\\nLinkedList here is to keep the robots that will survive.\\nI cannot use Deque since I need to sort it later by position.\\nHashMap to keep track of original position since question wants us to return in original order.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) sorting made it nlogn.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        HashMap<Integer, Integer> positionMap = new HashMap();\\n        for(int i = 0; i < positions.length; i++)\\n            positionMap.put(positions[i], i);\\n\\n        LinkedList<Combo> q = new LinkedList();\\n\\n        Arrays.sort(positions);\\n\\n        for(int i = 0; i < positions.length; i++) {\\n            // idx of original arrays\\n            int idx = positionMap.get(positions[i]);\\n            int healthCurr = healths[idx];\\n            boolean movingLeft = directions.charAt(idx) == \\'L\\';\\n\\n            if(movingLeft) {\\n                while(!q.isEmpty() && q.peekLast().health > 0 && q.peekLast().health < healthCurr) {\\n                    // collision\\n                    healthCurr--;\\n                    q.pollLast();\\n                }\\n                if(!q.isEmpty() && q.peekLast().health > 0 && q.peekLast().health == healthCurr) {\\n                    q.pollLast();\\n                    continue; \\n                }\\n                if(!q.isEmpty() && q.peekLast().health > 0 && q.peekLast().health > healthCurr) {\\n                    Combo prev = q.pollLast();\\n                    prev.health--;\\n                    q.offerLast(prev);\\n                    continue; \\n                }\\n            }\\n\\n            if(movingLeft) q.offerLast(new Combo(positionMap.get(positions[i]), -healthCurr));\\n            else q.offerLast(new Combo(positionMap.get(positions[i]), healthCurr)); // moving left is negative\\n        }\\n\\n        List<Integer> res = new ArrayList();\\n\\n        Collections.sort(q, (a,b) -> a.position - b.position);\\n\\n        for(Combo c : q) res.add(c.health < 0 ? -c.health : c.health);\\n        return res;\\n    }\\n\\n    class Combo {\\n        int position;\\n        int health;\\n        Combo(int a, int b) { position = a; health = b; }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        HashMap<Integer, Integer> positionMap = new HashMap();\\n        for(int i = 0; i < positions.length; i++)\\n            positionMap.put(positions[i], i);\\n\\n        LinkedList<Combo> q = new LinkedList();\\n\\n        Arrays.sort(positions);\\n\\n        for(int i = 0; i < positions.length; i++) {\\n            // idx of original arrays\\n            int idx = positionMap.get(positions[i]);\\n            int healthCurr = healths[idx];\\n            boolean movingLeft = directions.charAt(idx) == \\'L\\';\\n\\n            if(movingLeft) {\\n                while(!q.isEmpty() && q.peekLast().health > 0 && q.peekLast().health < healthCurr) {\\n                    // collision\\n                    healthCurr--;\\n                    q.pollLast();\\n                }\\n                if(!q.isEmpty() && q.peekLast().health > 0 && q.peekLast().health == healthCurr) {\\n                    q.pollLast();\\n                    continue; \\n                }\\n                if(!q.isEmpty() && q.peekLast().health > 0 && q.peekLast().health > healthCurr) {\\n                    Combo prev = q.pollLast();\\n                    prev.health--;\\n                    q.offerLast(prev);\\n                    continue; \\n                }\\n            }\\n\\n            if(movingLeft) q.offerLast(new Combo(positionMap.get(positions[i]), -healthCurr));\\n            else q.offerLast(new Combo(positionMap.get(positions[i]), healthCurr)); // moving left is negative\\n        }\\n\\n        List<Integer> res = new ArrayList();\\n\\n        Collections.sort(q, (a,b) -> a.position - b.position);\\n\\n        for(Combo c : q) res.add(c.health < 0 ? -c.health : c.health);\\n        return res;\\n    }\\n\\n    class Combo {\\n        int position;\\n        int health;\\n        Combo(int a, int b) { position = a; health = b; }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718721,
                "title": "easy-understanding-simple-c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<int> ans;\\n        map<int,pair<int,pair<int,char>>> mp;\\n        int n = positions.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[positions[i]] = {healths[i],{count,directions[i]}};\\n            count++;\\n        }\\n        \\n        stack<pair<int,pair<int,char>>> st;\\n        for(auto &it : mp)\\n        {\\n            while(!st.empty() && it.second.second.second == \\'L\\' && st.top().second.second == \\'R\\')\\n            {\\n               auto &curr = st.top();\\n               if(curr.first == it.second.first)\\n               {\\n                   it.second.second.second = \\'#\\'; // mark  if it diminish\\n                   st.pop();\\n                   break;\\n               }else if(curr.first<it.second.first){\\n                   it.second.first -= 1;\\n                   st.pop();\\n               }else{\\n                   it.second.second.second = \\'#\\';\\n                   curr.first -= 1;\\n                   break;\\n               }\\n            }\\n            \\n            if(it.second.second.second != \\'#\\')\\n                st.push({it.second.first,{it.second.second.first,it.second.second.second}});\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        while(!st.empty())\\n        {\\n            v.push_back({st.top().second.first,st.top().first});\\n            st.pop();\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        for(auto it : v)\\n        {\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<int> ans;\\n        map<int,pair<int,pair<int,char>>> mp;\\n        int n = positions.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[positions[i]] = {healths[i],{count,directions[i]}};\\n            count++;\\n        }\\n        \\n        stack<pair<int,pair<int,char>>> st;\\n        for(auto &it : mp)\\n        {\\n            while(!st.empty() && it.second.second.second == \\'L\\' && st.top().second.second == \\'R\\')\\n            {\\n               auto &curr = st.top();\\n               if(curr.first == it.second.first)\\n               {\\n                   it.second.second.second = \\'#\\'; // mark  if it diminish\\n                   st.pop();\\n                   break;\\n               }else if(curr.first<it.second.first){\\n                   it.second.first -= 1;\\n                   st.pop();\\n               }else{\\n                   it.second.second.second = \\'#\\';\\n                   curr.first -= 1;\\n                   break;\\n               }\\n            }\\n            \\n            if(it.second.second.second != \\'#\\')\\n                st.push({it.second.first,{it.second.second.first,it.second.second.second}});\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        while(!st.empty())\\n        {\\n            v.push_back({st.top().second.first,st.top().first});\\n            st.pop();\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        for(auto it : v)\\n        {\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718482,
                "title": "moe-like-a-medium-problem-easy-as-shit-faster-than-3-of-the-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        vector<vector<int>>v;\\n        for(int i=0;i<p.size();i++){\\n            int f = -1;\\n            if(d[i] == \\'R\\'){\\n                f =1;\\n            }\\n            v.push_back({p[i], h[i], f, i});\\n        }\\n        sort(v.begin(), v.end());\\n        vector<int>ans;\\n        vector<pair<int, int>>s;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<v.size();i++){\\n            if(v[i][2] == -1) {\\n                int lh = v[i][1];\\n                while(s.size() > 0 && lh>s[s.size()-1].first){\\n                    int rh = s[s.size()-1].first;\\n                    s.pop_back();\\n                    lh--;\\n                }\\n                if(s.size() == 0){\\n                    m[v[i][3]] = lh;\\n                } else if(s[s.size()-1].first == lh) {\\n                    s.pop_back();\\n                } else {\\n                    int rh = s[s.size()-1].first, index = s[s.size()-1].second;\\n                    s.pop_back();\\n                    rh--;\\n                    s.push_back({rh, index});\\n                }\\n            } else {\\n                s.push_back({v[i][1], v[i][3]});\\n            }\\n        }\\n        for(int i=0;i<s.size();i++){\\n            m[s[i].second] = s[i].first;\\n        }\\n        for(int i=0;i<p.size();i++){\\n            if(m.find(i)!=m.end())\\n                ans.push_back(m[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        vector<vector<int>>v;\\n        for(int i=0;i<p.size();i++){\\n            int f = -1;\\n            if(d[i] == \\'R\\'){\\n                f =1;\\n            }\\n            v.push_back({p[i], h[i], f, i});\\n        }\\n        sort(v.begin(), v.end());\\n        vector<int>ans;\\n        vector<pair<int, int>>s;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<v.size();i++){\\n            if(v[i][2] == -1) {\\n                int lh = v[i][1];\\n                while(s.size() > 0 && lh>s[s.size()-1].first){\\n                    int rh = s[s.size()-1].first;\\n                    s.pop_back();\\n                    lh--;\\n                }\\n                if(s.size() == 0){\\n                    m[v[i][3]] = lh;\\n                } else if(s[s.size()-1].first == lh) {\\n                    s.pop_back();\\n                } else {\\n                    int rh = s[s.size()-1].first, index = s[s.size()-1].second;\\n                    s.pop_back();\\n                    rh--;\\n                    s.push_back({rh, index});\\n                }\\n            } else {\\n                s.push_back({v[i][1], v[i][3]});\\n            }\\n        }\\n        for(int i=0;i<s.size();i++){\\n            m[s[i].second] = s[i].first;\\n        }\\n        for(int i=0;i<p.size();i++){\\n            if(m.find(i)!=m.end())\\n                ans.push_back(m[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709619,
                "title": "java-clear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n/*\\n\\nhttps://leetcode.com/problems/robot-collisions/solutions/3679189/c-java-python-with-visuals-stack-sorting-asteroid-collision/\\n\\n*/\\n\\n\\nclass Robot{\\n\\n  int pos;\\n  int index;\\n  int health;\\n  char dir;\\n\\n  public Robot(int pos, int index, int health, char dir){\\n\\n      this.pos=pos;\\n      this.index=index;\\n      this.health=health;\\n      this.dir = dir;\\n  }\\n    \\n}\\n\\nclass Solution {\\n    Stack<Robot> s;\\n\\n    public void makeCollison(Robot left){\\n\\n        // if top of the stack has robot moving in the right dir and left is moving in the left dir \\n        // and all the right moving robot has health less then left robot \\n\\n        while(!s.isEmpty() && s.peek().dir==\\'R\\' && s.peek().health<left.health){\\n            s.pop();\\n            left.health--;\\n        }\\n\\n        //Now there are two case if still stack has right moving robot then its health will be\\n        //more than or equal to left moving robot\\n        //or there will be no right moving robot\\n\\n        if(!s.isEmpty() && s.peek().dir==\\'R\\'){\\n            if(s.peek().health == left.health)\\n            s.pop(); //drop both of them left and right\\n            else\\n            s.peek().health--; //decrease the health by 1\\n        }else{\\n            // there is no right moving robot either only left moving \\n            s.push(left);\\n        }\\n\\n\\n    }\\n\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n\\n        s = new Stack();\\n        List<Robot> list = new ArrayList<>();\\n\\n        for(int i=0;i<positions.length;i++){\\n            list.add(new Robot(positions[i],i,healths[i],directions.charAt(i)));\\n\\n        }\\n\\n      //sorting based on the position of robots\\n        Collections.sort(list,(r1,r2)->r1.pos-r2.pos);\\n\\n        for(int i=0;i<list.size();i++){\\n\\n            if(list.get(i).dir==\\'R\\')\\n            s.push(list.get(i));\\n            else\\n            makeCollison(list.get(i));\\n        }\\n\\n        //Now we will have the stack with all the req robot after collison\\n\\n        //stack contains all the robot post collsion with the top of the robot as highest position\\n        // so we will pop all the robot ans put in the list and then sort the list by index as we need the\\n        //answer in the order of index in which robot position is given in an input\\n\\n        list.clear();\\n\\n        while(!s.isEmpty()){\\n            list.add(s.pop());\\n        }\\n        \\n        Collections.sort(list,(r1,r2)->r1.index-r2.index);\\n\\n        List<Integer> remainHealths = new ArrayList<Integer>();\\n\\n        for(int i=0;i<list.size();i++){\\n            remainHealths.add(list.get(i).health);\\n        }\\n        \\n  return remainHealths;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n/*\\n\\nhttps://leetcode.com/problems/robot-collisions/solutions/3679189/c-java-python-with-visuals-stack-sorting-asteroid-collision/\\n\\n*/\\n\\n\\nclass Robot{\\n\\n  int pos;\\n  int index;\\n  int health;\\n  char dir;\\n\\n  public Robot(int pos, int index, int health, char dir){\\n\\n      this.pos=pos;\\n      this.index=index;\\n      this.health=health;\\n      this.dir = dir;\\n  }\\n    \\n}\\n\\nclass Solution {\\n    Stack<Robot> s;\\n\\n    public void makeCollison(Robot left){\\n\\n        // if top of the stack has robot moving in the right dir and left is moving in the left dir \\n        // and all the right moving robot has health less then left robot \\n\\n        while(!s.isEmpty() && s.peek().dir==\\'R\\' && s.peek().health<left.health){\\n            s.pop();\\n            left.health--;\\n        }\\n\\n        //Now there are two case if still stack has right moving robot then its health will be\\n        //more than or equal to left moving robot\\n        //or there will be no right moving robot\\n\\n        if(!s.isEmpty() && s.peek().dir==\\'R\\'){\\n            if(s.peek().health == left.health)\\n            s.pop(); //drop both of them left and right\\n            else\\n            s.peek().health--; //decrease the health by 1\\n        }else{\\n            // there is no right moving robot either only left moving \\n            s.push(left);\\n        }\\n\\n\\n    }\\n\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n\\n        s = new Stack();\\n        List<Robot> list = new ArrayList<>();\\n\\n        for(int i=0;i<positions.length;i++){\\n            list.add(new Robot(positions[i],i,healths[i],directions.charAt(i)));\\n\\n        }\\n\\n      //sorting based on the position of robots\\n        Collections.sort(list,(r1,r2)->r1.pos-r2.pos);\\n\\n        for(int i=0;i<list.size();i++){\\n\\n            if(list.get(i).dir==\\'R\\')\\n            s.push(list.get(i));\\n            else\\n            makeCollison(list.get(i));\\n        }\\n\\n        //Now we will have the stack with all the req robot after collison\\n\\n        //stack contains all the robot post collsion with the top of the robot as highest position\\n        // so we will pop all the robot ans put in the list and then sort the list by index as we need the\\n        //answer in the order of index in which robot position is given in an input\\n\\n        list.clear();\\n\\n        while(!s.isEmpty()){\\n            list.add(s.pop());\\n        }\\n        \\n        Collections.sort(list,(r1,r2)->r1.index-r2.index);\\n\\n        List<Integer> remainHealths = new ArrayList<Integer>();\\n\\n        for(int i=0;i<list.size();i++){\\n            remainHealths.add(list.get(i).health);\\n        }\\n        \\n  return remainHealths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707727,
                "title": "simulation-treeset-java",
                "content": "# Intuition\\nUsually immitation process takes longer in time complexity and you need to come up with something different, but here it seems like we can do it with nlog(n) using treesets to find next bigger elements with necessary directions. It\\'s also obvious that robots\\' positions don\\'t need to be calculated or updated anyhow because they don\\'t change directions, which means that as long as they are alive we will know their health finally, and the position is needed only to determine the other robot for collision\\n\\n# Approach\\nCreate robot class to describe a robot and place them in TreeSet by sorting them by position. Next, recursively collide them as long as all the conditions are met for it.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n)) - we make only one collision for each robot and at each collision it\\'s obvious that we remove at least one robot. So there will be at most n collisions and at each collision we make log(n) call to find necessary robots to collide.\\n\\n- Space complexity:\\nO(n) - recursion calls and total items will be bounded to n maximum elements.\\n\\n# Code\\n```\\nclass Solution {\\n    private static class Robot {\\n        char direction;\\n        int position;\\n        int health;\\n        Robot(char direction, int position, int health) {\\n            this.direction = direction;\\n            this.position = position;\\n            this.health = health;\\n        }\\n    }\\n    public static List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        Comparator<Robot> comparator = Comparator.comparingInt(a -> a.position);\\n        TreeSet<Robot> rightRobots = new TreeSet<>(comparator);\\n        TreeSet<Robot> leftRobots = new TreeSet<>(comparator);\\n        int n = healths.length;\\n        for (int i = 0; i < n; i++) {\\n            char direction = directions.charAt(i);\\n            if (direction == \\'R\\') {\\n                rightRobots.add(new Robot(direction, positions[i], healths[i]));\\n            } else {\\n                leftRobots.add(new Robot(direction, positions[i], healths[i]));\\n            }\\n        }\\n\\n        collide(rightRobots.higher(new Robot(\\'R\\', 0, 1)), rightRobots, leftRobots);\\n\\n        TreeSet<Robot> remainingRobots = new TreeSet<>(comparator);\\n        remainingRobots.addAll(rightRobots);\\n        remainingRobots.addAll(leftRobots);\\n        List<Integer> answer = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            Robot robot = remainingRobots.ceiling(new Robot(\\'R\\', positions[i], 1));\\n            if (robot != null && robot.position == positions[i]) answer.add(robot.health);\\n        }\\n        return answer;\\n    }\\n\\n    private static void collide(Robot robot, TreeSet<Robot> rightRobots, TreeSet<Robot> leftRobots) {\\n        if (robot == null) return;\\n        Robot rightRobot = rightRobots.higher(robot);\\n        Robot leftRobot = leftRobots.higher(robot);\\n\\n        if (leftRobot == null) return;\\n\\n        while (leftRobot != null && (rightRobot == null || rightRobot.position > leftRobot.position)) {\\n            if (robot.health > leftRobot.health) {\\n                leftRobots.remove(leftRobot);\\n                robot.health--;\\n                leftRobot = leftRobots.higher(robot);\\n            } else if (robot.health < leftRobot.health) {\\n                rightRobots.remove(robot);\\n                leftRobot.health--;\\n                collide(rightRobots.higher(robot), rightRobots, leftRobots);\\n                return;\\n            } else {\\n                rightRobots.remove(robot);\\n                leftRobots.remove(leftRobot);\\n                collide(rightRobots.higher(robot), rightRobots, leftRobots);\\n                return;\\n            }\\n        }\\n        collide(rightRobot, rightRobots, leftRobots);\\n        collide(robot, rightRobots, leftRobots);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    private static class Robot {\\n        char direction;\\n        int position;\\n        int health;\\n        Robot(char direction, int position, int health) {\\n            this.direction = direction;\\n            this.position = position;\\n            this.health = health;\\n        }\\n    }\\n    public static List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        Comparator<Robot> comparator = Comparator.comparingInt(a -> a.position);\\n        TreeSet<Robot> rightRobots = new TreeSet<>(comparator);\\n        TreeSet<Robot> leftRobots = new TreeSet<>(comparator);\\n        int n = healths.length;\\n        for (int i = 0; i < n; i++) {\\n            char direction = directions.charAt(i);\\n            if (direction == \\'R\\') {\\n                rightRobots.add(new Robot(direction, positions[i], healths[i]));\\n            } else {\\n                leftRobots.add(new Robot(direction, positions[i], healths[i]));\\n            }\\n        }\\n\\n        collide(rightRobots.higher(new Robot(\\'R\\', 0, 1)), rightRobots, leftRobots);\\n\\n        TreeSet<Robot> remainingRobots = new TreeSet<>(comparator);\\n        remainingRobots.addAll(rightRobots);\\n        remainingRobots.addAll(leftRobots);\\n        List<Integer> answer = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            Robot robot = remainingRobots.ceiling(new Robot(\\'R\\', positions[i], 1));\\n            if (robot != null && robot.position == positions[i]) answer.add(robot.health);\\n        }\\n        return answer;\\n    }\\n\\n    private static void collide(Robot robot, TreeSet<Robot> rightRobots, TreeSet<Robot> leftRobots) {\\n        if (robot == null) return;\\n        Robot rightRobot = rightRobots.higher(robot);\\n        Robot leftRobot = leftRobots.higher(robot);\\n\\n        if (leftRobot == null) return;\\n\\n        while (leftRobot != null && (rightRobot == null || rightRobot.position > leftRobot.position)) {\\n            if (robot.health > leftRobot.health) {\\n                leftRobots.remove(leftRobot);\\n                robot.health--;\\n                leftRobot = leftRobots.higher(robot);\\n            } else if (robot.health < leftRobot.health) {\\n                rightRobots.remove(robot);\\n                leftRobot.health--;\\n                collide(rightRobots.higher(robot), rightRobots, leftRobots);\\n                return;\\n            } else {\\n                rightRobots.remove(robot);\\n                leftRobots.remove(leftRobot);\\n                collide(rightRobots.higher(robot), rightRobots, leftRobots);\\n                return;\\n            }\\n        }\\n        collide(rightRobot, rightRobots, leftRobots);\\n        collide(robot, rightRobots, leftRobots);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707628,
                "title": "c-easy-to-understand-stack",
                "content": "# Intuition\\nThe intuition is:\\nA robot moving in direction = L, will keep moving till its gets a robot in its left side which has direction = R (....R....L...).\\nOnce it gets a robot in its left side with direction  = R, we perform the check to see who wins. \\n- If robot with direction R wins, its health decreases by 1 and we wait for the next robot with direction L in its right hand side.\\n- If robot with direction L wins, its health decreases by 1 and it keeps moving left further to check if there are other robots which has direction = R and can be killed. (...R...R...L..)\\n\\nAll the robots with direction R can be kept in a stack. The intuition here is that, say there are 3 robots with direction R and there is a robot with direction L after that (...R1..R2...R3...L). So, the robot L will first fight with R3, then with R2, then with R1. So, to keep track of this reverse order, we use a stack.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn + n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct node{\\n        int pos;\\n        int h;\\n        char dir;\\n        int originalIdx;\\n    };\\n\\n    //Note: A robot with direction L will have a collision iff\\n    //there is a robot in its left, which is coming towards it,\\n    //ie, has a direction R\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<node> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({positions[i], healths[i], directions[i], i});\\n        }\\n        //sort according to position\\n        sort(v.begin(), v.end(), [](const node &a, const node &b) -> bool{\\n            return a.pos < b.pos;\\n        });\\n        stack<node> s; //stores all robots with direction. = R\\n        vector<node> rem; //stores all robots which will always stay alive\\n\\n        //moving from left to right\\n        for(int i=0;i<n;i++){\\n            if(v[i].dir == \\'L\\'){\\n                if(s.empty()){\\n                    //there is no robot in its left which is coming toward it\\n                    //(ie, with direction R)\\n                    //thus this robot will have no collisions.\\n\\n                    rem.push_back(v[i]);\\n                }\\n                else{\\n                    //For this robot with direction L, try moving much as possible, till:\\n                    //a) No robot in its left side is remaining, which has direction R, OR\\n                    //b) This robot has been killed\\n                    while(!s.empty() && v[i].h > s.top().h){\\n                        v[i].h--; //our robot killed one, so its health decreases by 1\\n                        s.pop();\\n                        if(v[i].h == 0) break;\\n                    }\\n                    if(s.empty()){\\n                        //No robot is remaining in its left side, which has direction = R\\n                        if(v[i].h > 0){\\n                            rem.push_back(v[i]);\\n                        }\\n                    }\\n                    else if(v[i].h == s.top().h){\\n                        //both are removed\\n                        s.pop();\\n                    }\\n                    else{\\n                        //there is a right moving robot which killed our robot v[i]\\n                        //But, its strength also decreases by 1\\n                        s.top().h--;\\n                    }\\n                    \\n                }\\n            }\\n            else{\\n                s.push(v[i]);\\n            }\\n        }\\n        \\n        //all robots remaining in stack are moving in right direction and hence\\n        //will always be alive\\n        while(!s.empty()) {\\n            rem.push_back(s.top());\\n            s.pop();\\n        }\\n\\n        //sort the robots by original Index\\n        sort(rem.begin(), rem.end(), [](const node & a, const node & b) -> bool{\\n            return a.originalIdx < b.originalIdx; \\n        });\\n        vector<int> ans;\\n        for(auto n : rem){\\n            ans.push_back(n.h);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct node{\\n        int pos;\\n        int h;\\n        char dir;\\n        int originalIdx;\\n    };\\n\\n    //Note: A robot with direction L will have a collision iff\\n    //there is a robot in its left, which is coming towards it,\\n    //ie, has a direction R\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<node> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({positions[i], healths[i], directions[i], i});\\n        }\\n        //sort according to position\\n        sort(v.begin(), v.end(), [](const node &a, const node &b) -> bool{\\n            return a.pos < b.pos;\\n        });\\n        stack<node> s; //stores all robots with direction. = R\\n        vector<node> rem; //stores all robots which will always stay alive\\n\\n        //moving from left to right\\n        for(int i=0;i<n;i++){\\n            if(v[i].dir == \\'L\\'){\\n                if(s.empty()){\\n                    //there is no robot in its left which is coming toward it\\n                    //(ie, with direction R)\\n                    //thus this robot will have no collisions.\\n\\n                    rem.push_back(v[i]);\\n                }\\n                else{\\n                    //For this robot with direction L, try moving much as possible, till:\\n                    //a) No robot in its left side is remaining, which has direction R, OR\\n                    //b) This robot has been killed\\n                    while(!s.empty() && v[i].h > s.top().h){\\n                        v[i].h--; //our robot killed one, so its health decreases by 1\\n                        s.pop();\\n                        if(v[i].h == 0) break;\\n                    }\\n                    if(s.empty()){\\n                        //No robot is remaining in its left side, which has direction = R\\n                        if(v[i].h > 0){\\n                            rem.push_back(v[i]);\\n                        }\\n                    }\\n                    else if(v[i].h == s.top().h){\\n                        //both are removed\\n                        s.pop();\\n                    }\\n                    else{\\n                        //there is a right moving robot which killed our robot v[i]\\n                        //But, its strength also decreases by 1\\n                        s.top().h--;\\n                    }\\n                    \\n                }\\n            }\\n            else{\\n                s.push(v[i]);\\n            }\\n        }\\n        \\n        //all robots remaining in stack are moving in right direction and hence\\n        //will always be alive\\n        while(!s.empty()) {\\n            rem.push_back(s.top());\\n            s.pop();\\n        }\\n\\n        //sort the robots by original Index\\n        sort(rem.begin(), rem.end(), [](const node & a, const node & b) -> bool{\\n            return a.originalIdx < b.originalIdx; \\n        });\\n        vector<int> ans;\\n        for(auto n : rem){\\n            ans.push_back(n.h);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706281,
                "title": "easy-solution-beats-95-c-sorting-stack-vectors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution basis is Ateroid collison .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreating the vector pair for , index and the position . Positiion is actually not needed here . \\nWe then create stack pair , so that at last when we sort by indices , we will be able to return the healths original order .\\nOther wise everything is quite similar to asteroid collison problem .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        vector<pair<int, int>> hd;\\n        for (int i = 0; i < p.size(); i++) {\\n            hd.emplace_back(p[i], i);\\n        }\\n\\n        int k = 0 ; \\n        sort(hd.begin(), hd.end());\\n        stack<pair<int, int>> c;\\n        int i = 0;\\n        while (i < p.size()) {\\n            int robotIndex = hd[i].second;\\n            char robotDirection = d[robotIndex];\\n            \\n            if (!c.empty() && robotDirection == \\'L\\' && d[c.top().second] == \\'R\\') {\\n                int robotHealth = h[robotIndex];\\n                int topHealth = c.top().first;\\n                k=robotHealth;\\n                if (robotHealth > topHealth) {\\n                    \\n                    while(!c.empty() && k>0 && k>c.top().first && robotDirection == \\'L\\' && d[c.top().second] == \\'R\\' ){\\n                        c.pop();\\n                        \\n                        k -= 1;\\n                    }\\n   \\n                }  if (!c.empty() && k == c.top().first  && robotDirection == \\'L\\' && d[c.top().second] == \\'R\\' ) {\\n                    c.pop();\\n                   \\n                } else if (!c.empty() && k < c.top().first && robotDirection == \\'L\\' && d[c.top().second] == \\'R\\' ) {\\n                    c.top().first--;\\n                    \\n                }else{\\n                    c.push(make_pair(k, robotIndex));\\n                   \\n                }\\n                \\n        \\n            } else {\\n                c.push(make_pair(h[robotIndex], robotIndex));\\n                \\n            }\\n            i++;\\n        }\\n        \\n        if (c.size() == p.size()) {\\n            return h;\\n        }\\n        \\n        vector<pair<int,int>> h1;\\n        vector<int>h2;\\n        while (!c.empty()) {\\n            h1.push_back(make_pair (c.top().second,c.top().first));\\n            c.pop();\\n        }\\n        sort(h1.begin(),h1.end());\\n        for(int i = 0 ; i < h1.size();i++){\\n            h2.push_back(h1[i].second);\\n        }\\n        return h2;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        vector<pair<int, int>> hd;\\n        for (int i = 0; i < p.size(); i++) {\\n            hd.emplace_back(p[i], i);\\n        }\\n\\n        int k = 0 ; \\n        sort(hd.begin(), hd.end());\\n        stack<pair<int, int>> c;\\n        int i = 0;\\n        while (i < p.size()) {\\n            int robotIndex = hd[i].second;\\n            char robotDirection = d[robotIndex];\\n            \\n            if (!c.empty() && robotDirection == \\'L\\' && d[c.top().second] == \\'R\\') {\\n                int robotHealth = h[robotIndex];\\n                int topHealth = c.top().first;\\n                k=robotHealth;\\n                if (robotHealth > topHealth) {\\n                    \\n                    while(!c.empty() && k>0 && k>c.top().first && robotDirection == \\'L\\' && d[c.top().second] == \\'R\\' ){\\n                        c.pop();\\n                        \\n                        k -= 1;\\n                    }\\n   \\n                }  if (!c.empty() && k == c.top().first  && robotDirection == \\'L\\' && d[c.top().second] == \\'R\\' ) {\\n                    c.pop();\\n                   \\n                } else if (!c.empty() && k < c.top().first && robotDirection == \\'L\\' && d[c.top().second] == \\'R\\' ) {\\n                    c.top().first--;\\n                    \\n                }else{\\n                    c.push(make_pair(k, robotIndex));\\n                   \\n                }\\n                \\n        \\n            } else {\\n                c.push(make_pair(h[robotIndex], robotIndex));\\n                \\n            }\\n            i++;\\n        }\\n        \\n        if (c.size() == p.size()) {\\n            return h;\\n        }\\n        \\n        vector<pair<int,int>> h1;\\n        vector<int>h2;\\n        while (!c.empty()) {\\n            h1.push_back(make_pair (c.top().second,c.top().first));\\n            c.pop();\\n        }\\n        sort(h1.begin(),h1.end());\\n        for(int i = 0 ; i < h1.size();i++){\\n            h2.push_back(h1[i].second);\\n        }\\n        return h2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705806,
                "title": "easiest-simple-solution-using-sorting-and-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the position and then using stack find the remaining robots using asteroids collision and then again resort the ans according to the initian position\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLOG(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        vector<pair<int,pair<int,pair<char,int>>>>v;\\n        int n=p.size();\\n        //storing the position and other thing for future use\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({p[i],{h[i],{d[i],i}}});\\n        }\\n        //sorting with respect to position \\n        sort(v.begin(),v.end());\\n        h.clear();\\n        d=\"\";\\n        vector<int>id;\\n        for(int i=0;i<n;i++)\\n        {\\n            //storing the initIAL ID \\n            id.push_back(v[i].second.second.second);\\n            //new health array after sorting\\n            h.push_back(v[i].second.first);\\n            //new string after sorting according to position\\n            d.push_back(v[i].second.second.first);\\n        }\\n        stack<pair<int,int>>st;\\n        int i=0;\\n        vector<pair<int,int>>ans;\\n        while(i<n)\\n        {\\n            if(d[i]==\\'R\\')break;\\n            ans.push_back({h[i],i});\\n            i++;\\n        }\\n        int j=n-1;\\n        while(j>=0)\\n        {\\n            if(d[j]==\\'L\\')break;\\n            j--;\\n        }\\n        int e=j+1;\\n       // if(i>=j)return h;\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(d[k]==\\'R\\')\\n            {\\n               st.push({h[k],k}); \\n            }\\n            else\\n            {\\n                if(st.empty())\\n                {\\n                    ans.push_back({h[k],k});\\n                }\\n                else\\n                {\\n                    while(!st.empty()&&st.top().first<h[k])\\n                    {\\n                        st.pop();\\n                        h[k]--;\\n                    }\\n                    if(!st.empty()&&st.top().first==h[k])\\n                    {\\n                        st.pop();\\n                        continue;\\n                    }\\n                    else if(!st.empty()&&st.top().first>h[k])\\n                    {\\n                        st.top().first--;\\n                        continue;\\n                    }\\n                    else if(st.empty())\\n                    {\\n                        ans.push_back({h[k],k});\\n                    }\\n                }\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back({st.top().first,st.top().second});\\n            st.pop();\\n        }\\n        for(int k=e;k<n;k++)\\n        {\\n            ans.push_back({h[k],k});\\n        }\\n        vector<int>temp(n,-1);\\n        for(int k=0;k<ans.size();k++)\\n        {\\n            temp[id[ans[k].second]]=ans[k].first;\\n        }\\n        vector<int>res;\\n        for(int k=0;k<n;k++)\\n        {\\n            if(temp[k]!=-1)\\n            {\\n                res.push_back(temp[k]);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        vector<pair<int,pair<int,pair<char,int>>>>v;\\n        int n=p.size();\\n        //storing the position and other thing for future use\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({p[i],{h[i],{d[i],i}}});\\n        }\\n        //sorting with respect to position \\n        sort(v.begin(),v.end());\\n        h.clear();\\n        d=\"\";\\n        vector<int>id;\\n        for(int i=0;i<n;i++)\\n        {\\n            //storing the initIAL ID \\n            id.push_back(v[i].second.second.second);\\n            //new health array after sorting\\n            h.push_back(v[i].second.first);\\n            //new string after sorting according to position\\n            d.push_back(v[i].second.second.first);\\n        }\\n        stack<pair<int,int>>st;\\n        int i=0;\\n        vector<pair<int,int>>ans;\\n        while(i<n)\\n        {\\n            if(d[i]==\\'R\\')break;\\n            ans.push_back({h[i],i});\\n            i++;\\n        }\\n        int j=n-1;\\n        while(j>=0)\\n        {\\n            if(d[j]==\\'L\\')break;\\n            j--;\\n        }\\n        int e=j+1;\\n       // if(i>=j)return h;\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(d[k]==\\'R\\')\\n            {\\n               st.push({h[k],k}); \\n            }\\n            else\\n            {\\n                if(st.empty())\\n                {\\n                    ans.push_back({h[k],k});\\n                }\\n                else\\n                {\\n                    while(!st.empty()&&st.top().first<h[k])\\n                    {\\n                        st.pop();\\n                        h[k]--;\\n                    }\\n                    if(!st.empty()&&st.top().first==h[k])\\n                    {\\n                        st.pop();\\n                        continue;\\n                    }\\n                    else if(!st.empty()&&st.top().first>h[k])\\n                    {\\n                        st.top().first--;\\n                        continue;\\n                    }\\n                    else if(st.empty())\\n                    {\\n                        ans.push_back({h[k],k});\\n                    }\\n                }\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back({st.top().first,st.top().second});\\n            st.pop();\\n        }\\n        for(int k=e;k<n;k++)\\n        {\\n            ans.push_back({h[k],k});\\n        }\\n        vector<int>temp(n,-1);\\n        for(int k=0;k<ans.size();k++)\\n        {\\n            temp[id[ans[k].second]]=ans[k].first;\\n        }\\n        vector<int>res;\\n        for(int k=0;k<n;k++)\\n        {\\n            if(temp[k]!=-1)\\n            {\\n                res.push_back(temp[k]);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705494,
                "title": "c-solution-using-stack-faster-and-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void performOperations(stack<int>&st,vector<int>&healths,int i){\\n        while(!st.empty()){\\n            if(healths[st.top()] == healths[i]){\\n                healths[i] = 0;\\n                healths[st.top()] = 0;\\n                st.pop();\\n                return;\\n            }\\n            else if(healths[st.top()] < healths[i]){\\n                healths[st.top()] = 0;\\n                healths[i]--;\\n                st.pop();\\n            }\\n            else{\\n                healths[i] = 0;\\n                healths[st.top()]--;\\n                return;\\n            }\\n        }\\n    }\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        stack<int> st;\\n        int n = positions.size();\\n\\n        vector<int> idx(n);\\n        for(int i=0;i<n;i++) idx[i] = i;\\n        sort(idx.begin(),idx.end(),[&](int i,int j){\\n            return positions[i] < positions[j];\\n        });\\n        \\n        for(int j=0;j<n;j++){\\n            int i = idx[j];\\n            if(directions[i] == \\'L\\' && st.empty()) continue;\\n            else if(directions[i] == \\'R\\') st.push(i);\\n            else performOperations(st,healths,i);\\n        }\\n\\n        vector<int> ans;\\n        for(int i : healths){\\n            if(i > 0) ans.push_back(i);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void performOperations(stack<int>&st,vector<int>&healths,int i){\\n        while(!st.empty()){\\n            if(healths[st.top()] == healths[i]){\\n                healths[i] = 0;\\n                healths[st.top()] = 0;\\n                st.pop();\\n                return;\\n            }\\n            else if(healths[st.top()] < healths[i]){\\n                healths[st.top()] = 0;\\n                healths[i]--;\\n                st.pop();\\n            }\\n            else{\\n                healths[i] = 0;\\n                healths[st.top()]--;\\n                return;\\n            }\\n        }\\n    }\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        stack<int> st;\\n        int n = positions.size();\\n\\n        vector<int> idx(n);\\n        for(int i=0;i<n;i++) idx[i] = i;\\n        sort(idx.begin(),idx.end(),[&](int i,int j){\\n            return positions[i] < positions[j];\\n        });\\n        \\n        for(int j=0;j<n;j++){\\n            int i = idx[j];\\n            if(directions[i] == \\'L\\' && st.empty()) continue;\\n            else if(directions[i] == \\'R\\') st.push(i);\\n            else performOperations(st,healths,i);\\n        }\\n\\n        vector<int> ans;\\n        for(int i : healths){\\n            if(i > 0) ans.push_back(i);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704739,
                "title": "red-stack-application",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos,vector<int>& h,string d) \\n    {\\n        vector<pair<int,int>>v;\\n        int n = pos.size();\\n         \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({pos[i],i});                //storing the position with index\\n        }\\n\\n        sort(v.begin(),v.end());                     //sort acc to pos\\n        stack<int>st;                                // store the index of remaining robot whose surviving till now\\n        vector<int>ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int ind =  v[i].second;                  // finding respective index of that pos           \\n            \\n            if(d[ind] ==\\'L\\')                         // check the dir if it is left \\n            {                                       \\n                if(st.empty()) ans.push_back(ind);   // if there is nothing to collide for a particle that moving in left direction so it never collide to anyone  so its health never decrease, so push into our final ans  \\n                else\\n                {\\n                    while(!st.empty() && h[st.top()] <  h[ind])    // check if anyone going to right dir and with min health with current robot which moving in Left\\n                    {                                          \\n                        st.pop();   //removing right moving robot with min health \\n                        h[ind]--;   //health of cur robot decrease by one\\n                    }\\n                    if(st.empty()) ans.push_back(ind);  // if there no right moving robot remain so again push into our final ans \\n                    else\\n                    {\\n                        if(h[st.top()] == h[ind]) st.pop();   // if left and right moving robot have same health then remove both robot \\n                        else\\n                        {\\n                            h[st.top()]--;                  //if right moving element having more health than left ,then health of right moving decrease by one  \\n                            if(h[st.top()]== 0) st.pop();   // if( health of right moving become zero which at the top of stack them removing from stack )\\n                        }\\n                    }\\n                }\\n            }\\n            else \\n            {\\n                st.push(ind);  // if cur robot is right moving so it don\\'t collide with previous right moving robots so simply store the index of this one  \\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());   // now storing tha index of remaining right moving robot whose survive till the end and present in stack\\n            st.pop();\\n        }\\n        sort(ans.begin(),ans.end());    // acc to question result store in intial given state  \\n        \\n        for(int i=0;i<ans.size();i++)\\n        ans[i] = h[ans[i]];   // now assigning  health of robot with index ans[i] \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos,vector<int>& h,string d) \\n    {\\n        vector<pair<int,int>>v;\\n        int n = pos.size();\\n         \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({pos[i],i});                //storing the position with index\\n        }\\n\\n        sort(v.begin(),v.end());                     //sort acc to pos\\n        stack<int>st;                                // store the index of remaining robot whose surviving till now\\n        vector<int>ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int ind =  v[i].second;                  // finding respective index of that pos           \\n            \\n            if(d[ind] ==\\'L\\')                         // check the dir if it is left \\n            {                                       \\n                if(st.empty()) ans.push_back(ind);   // if there is nothing to collide for a particle that moving in left direction so it never collide to anyone  so its health never decrease, so push into our final ans  \\n                else\\n                {\\n                    while(!st.empty() && h[st.top()] <  h[ind])    // check if anyone going to right dir and with min health with current robot which moving in Left\\n                    {                                          \\n                        st.pop();   //removing right moving robot with min health \\n                        h[ind]--;   //health of cur robot decrease by one\\n                    }\\n                    if(st.empty()) ans.push_back(ind);  // if there no right moving robot remain so again push into our final ans \\n                    else\\n                    {\\n                        if(h[st.top()] == h[ind]) st.pop();   // if left and right moving robot have same health then remove both robot \\n                        else\\n                        {\\n                            h[st.top()]--;                  //if right moving element having more health than left ,then health of right moving decrease by one  \\n                            if(h[st.top()]== 0) st.pop();   // if( health of right moving become zero which at the top of stack them removing from stack )\\n                        }\\n                    }\\n                }\\n            }\\n            else \\n            {\\n                st.push(ind);  // if cur robot is right moving so it don\\'t collide with previous right moving robots so simply store the index of this one  \\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());   // now storing tha index of remaining right moving robot whose survive till the end and present in stack\\n            st.pop();\\n        }\\n        sort(ans.begin(),ans.end());    // acc to question result store in intial given state  \\n        \\n        for(int i=0;i<ans.size();i++)\\n        ans[i] = h[ans[i]];   // now assigning  health of robot with index ans[i] \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703890,
                "title": "c-stack-solution-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain a stack to simulate the robot collisions. Since the speed for all the robots are the same, the collision only happens when the new robot is going left and the last robot is going right.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<array<int, 4>> robots;\\n        int n = positions.size();\\n        for (int i = 0; i < n; i++) {\\n            array<int, 4> robot {positions[i], healths[i], directions[i] == \\'R\\', i};\\n            robots.emplace_back(robot);\\n        }\\n        \\n        sort(robots.begin(), robots.end(), [](auto & a, auto & b) -> bool {\\n            return a[0] < b[0]; \\n        });\\n        \\n        vector<array<int, 4>> stk;\\n        \\n        for (int i = 0; i < n; i++) {\\n            bool insert = true;\\n            while (!stk.empty()) {\\n                array<int, 4> & top = stk.back();\\n                if (top[2] == 1 && robots[i][2] == 0) {\\n                    if (top[1] == robots[i][1]) {\\n                        stk.pop_back();\\n                        insert = false;\\n                        break;\\n                    }\\n                    else if (top[1] > robots[i][1]) {\\n                        top[1]--;\\n                        insert = false;\\n                        break;\\n                    }\\n                    else {\\n                        stk.pop_back();\\n                        robots[i][1]--;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            \\n            if (insert) {\\n                stk.emplace_back(robots[i]);   \\n            }\\n            \\n        }\\n        \\n        sort(stk.begin(), stk.end(), [](auto & a, auto & b) -> bool {\\n            return a[3] < b[3]; \\n        });\\n        \\n        vector<int> ans;\\n        for (int i = 0; i < stk.size(); i++) {\\n            ans.emplace_back(stk[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<array<int, 4>> robots;\\n        int n = positions.size();\\n        for (int i = 0; i < n; i++) {\\n            array<int, 4> robot {positions[i], healths[i], directions[i] == \\'R\\', i};\\n            robots.emplace_back(robot);\\n        }\\n        \\n        sort(robots.begin(), robots.end(), [](auto & a, auto & b) -> bool {\\n            return a[0] < b[0]; \\n        });\\n        \\n        vector<array<int, 4>> stk;\\n        \\n        for (int i = 0; i < n; i++) {\\n            bool insert = true;\\n            while (!stk.empty()) {\\n                array<int, 4> & top = stk.back();\\n                if (top[2] == 1 && robots[i][2] == 0) {\\n                    if (top[1] == robots[i][1]) {\\n                        stk.pop_back();\\n                        insert = false;\\n                        break;\\n                    }\\n                    else if (top[1] > robots[i][1]) {\\n                        top[1]--;\\n                        insert = false;\\n                        break;\\n                    }\\n                    else {\\n                        stk.pop_back();\\n                        robots[i][1]--;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            \\n            if (insert) {\\n                stk.emplace_back(robots[i]);   \\n            }\\n            \\n        }\\n        \\n        sort(stk.begin(), stk.end(), [](auto & a, auto & b) -> bool {\\n            return a[3] < b[3]; \\n        });\\n        \\n        vector<int> ans;\\n        for (int i = 0; i < stk.size(); i++) {\\n            ans.emplace_back(stk[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702878,
                "title": "javascript-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you lay out all the possible combinations and see which ones lead to collisions and which ones don\\'t, the problem becomes a bit more clear to solve in linear time.\\n\\n    // R L => Collision\\n    // L R => No collision\\n    // L L => No collision\\n    // R R => No collision\\n\\nOnce you see this, the problem becomes something like: How can we keep the pattern of direction in the array to not have any \"L\"s that come after \"R\"s\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem describes an object with multiple properties so it made sense to create a robot class.\\n\\nWe then loop through and add all the robots to an array. We sort the array so that the robots are in their relative position next to each other. Now something to note here is that before we sort, there\\'s this `customSort` hashmap. This will be used to re-sort the array at the end because we need to send in our solution in the order that it came in. \\n\\nWe use a stack to keep the solution. We loop through the robots and keep adding them to the array as long as there\\'s no case where a left comes after a right. \\n\\nIn the case where this does happen, we keep popping off the solution array as long as the current robot keeps having more health that the robot on our solution stack. After this is done, if our current robot still has healt, then we push it on to the stack.\\n\\nAt the end, we re-sort using the customSort hash we created at the beginning and extract out the health from out array of robots and return that.\\n\\n# Complexity\\n- n represents the number of robots\\n- Time complexity: O(nlogn) for sorting => the deletion can happen at most O(2*n) times which is still O(n) hence the final time complexity is O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} positions\\n * @param {number[]} healths\\n * @param {string} directions\\n * @return {number[]}\\n */\\n\\nclass Robot {\\n    constructor(position, health, direction){\\n    this.position = position;\\n    this.health = health;\\n    this.direction = direction;\\n    }\\n}\\n\\nconst top = arr => arr[arr.length - 1]\\n\\nvar survivedRobotsHealths = function(positions, healths, directions) {\\n    let solution = []\\n    let robots = []\\n    let customSort = {} // Use this to re-sort at the end\\n    for(let i = 0; i < positions.length; i++){\\n        let robot = new Robot(positions[i], healths[i], directions[i]);\\n        customSort[positions[i]] = i;\\n        robots.push(robot);\\n    }\\n\\n    robots.sort((a, b) => a.position - b.position);\\n\\n    // R L => Collision\\n\\n    // L R => No collision\\n    // L L => No collision\\n    // R R => No collision\\n\\n    let seenRight = false;\\n    for(let robot of robots){\\n        if(robot.direction == \\'R\\') seenRight = true;\\n        if(seenRight == true && robot.direction == \\'L\\'){\\n            while(solution.length != 0 && top(solution).direction == \\'R\\'){\\n                let nextRobot = top(solution);\\n                if(nextRobot.health == robot.health){ \\n                    solution.pop(); robot.health = 0; break;\\n                }\\n\\n                if(nextRobot.health > robot.health){\\n                    nextRobot.health -= 1; robot.health = 0; break;\\n                }\\n\\n                solution.pop();\\n                robot.health -= 1;\\n            }\\n\\n            if(robot.health > 0) solution.push(robot); // What we were missing \\uD83D\\uDE05\\n        } else {\\n            solution.push(robot);\\n        }\\n    }\\n\\n    solution.sort((a, b) => customSort[a.position] - customSort[b.position]);\\n    return solution.map((robot) => robot.health);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} positions\\n * @param {number[]} healths\\n * @param {string} directions\\n * @return {number[]}\\n */\\n\\nclass Robot {\\n    constructor(position, health, direction){\\n    this.position = position;\\n    this.health = health;\\n    this.direction = direction;\\n    }\\n}\\n\\nconst top = arr => arr[arr.length - 1]\\n\\nvar survivedRobotsHealths = function(positions, healths, directions) {\\n    let solution = []\\n    let robots = []\\n    let customSort = {} // Use this to re-sort at the end\\n    for(let i = 0; i < positions.length; i++){\\n        let robot = new Robot(positions[i], healths[i], directions[i]);\\n        customSort[positions[i]] = i;\\n        robots.push(robot);\\n    }\\n\\n    robots.sort((a, b) => a.position - b.position);\\n\\n    // R L => Collision\\n\\n    // L R => No collision\\n    // L L => No collision\\n    // R R => No collision\\n\\n    let seenRight = false;\\n    for(let robot of robots){\\n        if(robot.direction == \\'R\\') seenRight = true;\\n        if(seenRight == true && robot.direction == \\'L\\'){\\n            while(solution.length != 0 && top(solution).direction == \\'R\\'){\\n                let nextRobot = top(solution);\\n                if(nextRobot.health == robot.health){ \\n                    solution.pop(); robot.health = 0; break;\\n                }\\n\\n                if(nextRobot.health > robot.health){\\n                    nextRobot.health -= 1; robot.health = 0; break;\\n                }\\n\\n                solution.pop();\\n                robot.health -= 1;\\n            }\\n\\n            if(robot.health > 0) solution.push(robot); // What we were missing \\uD83D\\uDE05\\n        } else {\\n            solution.push(robot);\\n        }\\n    }\\n\\n    solution.sort((a, b) => customSort[a.position] - customSort[b.position]);\\n    return solution.map((robot) => robot.health);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702771,
                "title": "sort-stack-approach",
                "content": "```\\nclass Item {\\n  int idx, pos, health;\\n  bool left;\\n  Item(int idx, pos, hea, left) : idx = idx, pos = pos, health = hea, left = left;\\n}\\n\\nclass Solution {\\n  List<int> survivedRobotsHealths(List<int> positions, List<int> healths, String directions) {\\n    List<Item> work = [];\\n    for (int i = 0; i < positions.length; i++)\\n      work.add(Item(i, positions[i], healths[i], directions[i] == \\'L\\'));\\n    work.sort((a, b) => a.pos - b.pos);\\n    List<Item> stack = [];\\n    List<Item> lefts = [];\\n    \\n    for (final each in work) {\\n      if (each.left) {\\n        \\n        var destroyed = false;\\n        while (!destroyed && stack.isNotEmpty) {\\n          Item enemy = stack.removeLast();\\n          if (enemy.health < each.health) {\\n            each.health--;\\n          } else if (enemy.health == each.health) {\\n            destroyed = true;\\n          } else {\\n            destroyed = true;\\n            enemy.health--;\\n            stack.add(enemy);\\n          }\\n        }\\n        if (!destroyed)\\n          lefts.add(each);\\n      } else {\\n        stack.add(each);\\n      }\\n    }\\n    \\n    lefts.addAll(stack);\\n    lefts.sort((a, b) => a.idx - b.idx);\\n    return lefts.map((e) => e.health).toList();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Item {\\n  int idx, pos, health;\\n  bool left;\\n  Item(int idx, pos, hea, left) : idx = idx, pos = pos, health = hea, left = left;\\n}\\n\\nclass Solution {\\n  List<int> survivedRobotsHealths(List<int> positions, List<int> healths, String directions) {\\n    List<Item> work = [];\\n    for (int i = 0; i < positions.length; i++)\\n      work.add(Item(i, positions[i], healths[i], directions[i] == \\'L\\'));\\n    work.sort((a, b) => a.pos - b.pos);\\n    List<Item> stack = [];\\n    List<Item> lefts = [];\\n    \\n    for (final each in work) {\\n      if (each.left) {\\n        \\n        var destroyed = false;\\n        while (!destroyed && stack.isNotEmpty) {\\n          Item enemy = stack.removeLast();\\n          if (enemy.health < each.health) {\\n            each.health--;\\n          } else if (enemy.health == each.health) {\\n            destroyed = true;\\n          } else {\\n            destroyed = true;\\n            enemy.health--;\\n            stack.add(enemy);\\n          }\\n        }\\n        if (!destroyed)\\n          lefts.add(each);\\n      } else {\\n        stack.add(each);\\n      }\\n    }\\n    \\n    lefts.addAll(stack);\\n    lefts.sort((a, b) => a.idx - b.idx);\\n    return lefts.map((e) => e.health).toList();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701719,
                "title": "easy-c-soln",
                "content": "# Intuition\\nIterate over aaray to check any collision, for any robot facing left(<-) check if there exists a robot immediate left to current one facing right(->).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe collosion will happen when two robot will face each other(-> <-), after collsion there will be three case:\\n(1) Both robot disappear, continue iterating\\n(2) Robot facing left disappear, continue iterating\\n(3) Robot facing right disappear, there may possibilities robot in left of right facing robot(->) will also hit the current one, we need to check in left of robot facing right(->) until available/it hit back to current robot(<-)/both disappear.\\nUse a set to keep track record of available robots, which will be helpful in finding previous available robot.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        map<int,int>mp;\\n        int n=p.size(),j;\\n        vector<vector<int>>v;\\n        for(int i=0;i<n;i++){\\n            mp[i]=p[i];\\n            v.push_back({p[i],h[i],d[i]==\\'L\\'?0:1});\\n        }\\n        sort(v.begin(),v.end());\\n        set<int>s;\\n        for(int i=0;i<n;i++)s.insert(i+1);\\n        for(int i=1;i<n;i++){\\n            j=n-*s.upper_bound(n-i);\\n            if(v[j][2]==1 && v[i][2]==0){\\n                if(v[j][1]>v[i][1]){\\n                    s.erase(n-i);\\n                    v[j][1]--;\\n                }else if(v[j][1]<v[i][1]){\\n                    s.erase(n-j);\\n                    v[i][1]--;\\n                    while(s.upper_bound(n-i)!=s.end()){\\n                        j=n-*s.upper_bound(n-i);\\n                        if(v[j][2]==0){\\n                            break;\\n                        }else if(v[j][1]>v[i][1]){\\n                            s.erase(n-i);\\n                            v[j][1]--;\\n                            break;\\n                        }else if(v[j][1]==v[i][1]){\\n                            s.erase(n-i);\\n                            s.erase(n-j);\\n                            break;\\n                        }\\n                        else{\\n                            s.erase(n-j);\\n                            v[i][1]--;\\n                        }\\n                    }\\n                }else{\\n                    s.erase(n-i);\\n                    s.erase(n-j);\\n                }\\n            }\\n        }\\n        map<int,int>w;\\n        vector<int>q;\\n        for(auto i:s){\\n            w[v[n-i][0]]=v[n-i][1];\\n        }\\n        for(auto i:mp){\\n            if(w.find(i.second)!=w.end()){\\n                q.push_back(w[i.second]);\\n            }\\n        }\\n        return q;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& p, vector<int>& h, string d) {\\n        map<int,int>mp;\\n        int n=p.size(),j;\\n        vector<vector<int>>v;\\n        for(int i=0;i<n;i++){\\n            mp[i]=p[i];\\n            v.push_back({p[i],h[i],d[i]==\\'L\\'?0:1});\\n        }\\n        sort(v.begin(),v.end());\\n        set<int>s;\\n        for(int i=0;i<n;i++)s.insert(i+1);\\n        for(int i=1;i<n;i++){\\n            j=n-*s.upper_bound(n-i);\\n            if(v[j][2]==1 && v[i][2]==0){\\n                if(v[j][1]>v[i][1]){\\n                    s.erase(n-i);\\n                    v[j][1]--;\\n                }else if(v[j][1]<v[i][1]){\\n                    s.erase(n-j);\\n                    v[i][1]--;\\n                    while(s.upper_bound(n-i)!=s.end()){\\n                        j=n-*s.upper_bound(n-i);\\n                        if(v[j][2]==0){\\n                            break;\\n                        }else if(v[j][1]>v[i][1]){\\n                            s.erase(n-i);\\n                            v[j][1]--;\\n                            break;\\n                        }else if(v[j][1]==v[i][1]){\\n                            s.erase(n-i);\\n                            s.erase(n-j);\\n                            break;\\n                        }\\n                        else{\\n                            s.erase(n-j);\\n                            v[i][1]--;\\n                        }\\n                    }\\n                }else{\\n                    s.erase(n-i);\\n                    s.erase(n-j);\\n                }\\n            }\\n        }\\n        map<int,int>w;\\n        vector<int>q;\\n        for(auto i:s){\\n            w[v[n-i][0]]=v[n-i][1];\\n        }\\n        for(auto i:mp){\\n            if(w.find(i.second)!=w.end()){\\n                q.push_back(w[i.second]);\\n            }\\n        }\\n        return q;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700683,
                "title": "simplest-code-in-c-using-stack",
                "content": "# Intuition\\nI take a stack and keep checking the elements that if it collides with prev. element or not \\n\\n# Approach\\nI have applied the same approach of stack used in parenthesis problem\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCollision(string d1, string d2){\\n\\tif(d1 == \"R\" and d2 == \"L\") return true;\\n\\treturn false;\\n}\\n\\nvector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n\\tunordered_map<int, int>posTohealth, posToindx;\\n\\tunordered_map<int, string>posTodir;\\n\\tvector<int>ans1(positions.size(), -1), ans2;\\n\\tstack<pair<int, pair<string,int>>>s;\\n\\n\\tfor (int i = 0; i < positions.size(); i++)\\n\\t{\\n\\t\\tposTohealth[positions[i]] = healths[i];\\n\\t\\tposToindx[positions[i]] = i;\\n\\t\\tposTodir[positions[i]] = directions[i];\\n\\t}\\n\\t\\n\\tsort(positions.begin(), positions.end());\\n\\n\\tfor (int i = 0; i < positions.size(); i++)\\n\\t{\\n\\t\\tint indx = posToindx[positions[i]];\\n\\t\\tif(s.size()){\\n\\t\\t\\tstring currDir = posTodir[positions[i]];\\n\\t\\t\\tint currHeal = posTohealth[positions[i]];\\n\\n\\t\\t\\tauto pr = s.top();\\n\\n\\t\\t\\tif(!isCollision(pr.second.first, currDir)) s.push({currHeal, {currDir, indx}});\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(currHeal == pr.first){\\n\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbool flag = true;\\n\\t\\t\\t\\twhile(s.size()){\\n\\t\\t\\t\\t\\tif(currHeal > s.top().first and isCollision(s.top().second.first, currDir)){\\n\\t\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\t\\tcurrHeal--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(currHeal < s.top().first and isCollision(s.top().second.first, currDir)){\\n\\t\\t\\t\\t\\t\\tauto top = s.top();\\n\\t\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\t\\ttop.first -= 1;\\n\\t\\t\\t\\t\\t\\ts.push(top);\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}else if (currHeal == s.top().first and isCollision(s.top().second.first, currDir)){\\n\\t\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(!isCollision(s.top().second.first, currDir)){\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(flag) \\n\\t\\t\\t\\ts.push({currHeal , {currDir, indx}});\\n\\t\\t\\t}\\n\\t\\t}else s.push({posTohealth[positions[i]], {posTodir[positions[i]], indx}});\\n\\t}\\n\\n\\twhile (s.size())\\n\\t{\\n\\t\\tauto pr = s.top();\\n\\t\\ts.pop();\\n\\t\\tans1[pr.second.second] = pr.first;\\n\\t}\\n\\t\\n\\tfor(auto &elem : ans1){\\n\\t\\tif(elem != -1) ans2.push_back(elem);\\n\\t}\\n\\n\\treturn ans2;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCollision(string d1, string d2){\\n\\tif(d1 == \"R\" and d2 == \"L\") return true;\\n\\treturn false;\\n}\\n\\nvector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n\\tunordered_map<int, int>posTohealth, posToindx;\\n\\tunordered_map<int, string>posTodir;\\n\\tvector<int>ans1(positions.size(), -1), ans2;\\n\\tstack<pair<int, pair<string,int>>>s;\\n\\n\\tfor (int i = 0; i < positions.size(); i++)\\n\\t{\\n\\t\\tposTohealth[positions[i]] = healths[i];\\n\\t\\tposToindx[positions[i]] = i;\\n\\t\\tposTodir[positions[i]] = directions[i];\\n\\t}\\n\\t\\n\\tsort(positions.begin(), positions.end());\\n\\n\\tfor (int i = 0; i < positions.size(); i++)\\n\\t{\\n\\t\\tint indx = posToindx[positions[i]];\\n\\t\\tif(s.size()){\\n\\t\\t\\tstring currDir = posTodir[positions[i]];\\n\\t\\t\\tint currHeal = posTohealth[positions[i]];\\n\\n\\t\\t\\tauto pr = s.top();\\n\\n\\t\\t\\tif(!isCollision(pr.second.first, currDir)) s.push({currHeal, {currDir, indx}});\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(currHeal == pr.first){\\n\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbool flag = true;\\n\\t\\t\\t\\twhile(s.size()){\\n\\t\\t\\t\\t\\tif(currHeal > s.top().first and isCollision(s.top().second.first, currDir)){\\n\\t\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\t\\tcurrHeal--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(currHeal < s.top().first and isCollision(s.top().second.first, currDir)){\\n\\t\\t\\t\\t\\t\\tauto top = s.top();\\n\\t\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\t\\ttop.first -= 1;\\n\\t\\t\\t\\t\\t\\ts.push(top);\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}else if (currHeal == s.top().first and isCollision(s.top().second.first, currDir)){\\n\\t\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(!isCollision(s.top().second.first, currDir)){\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(flag) \\n\\t\\t\\t\\ts.push({currHeal , {currDir, indx}});\\n\\t\\t\\t}\\n\\t\\t}else s.push({posTohealth[positions[i]], {posTodir[positions[i]], indx}});\\n\\t}\\n\\n\\twhile (s.size())\\n\\t{\\n\\t\\tauto pr = s.top();\\n\\t\\ts.pop();\\n\\t\\tans1[pr.second.second] = pr.first;\\n\\t}\\n\\t\\n\\tfor(auto &elem : ans1){\\n\\t\\tif(elem != -1) ans2.push_back(elem);\\n\\t}\\n\\n\\treturn ans2;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700081,
                "title": "solution-using-priority-queue-c",
                "content": "# Intuition\\nUsing priority queue to solve the problem\\n\\n# Approach\\nUse Min Priority Queue, pick robots with lesser distance.\\nThen if their powers match\\n- Delete them. Push the left and right live robots to the queue that are moving towards each other.\\n- Else remove the dead robot. Bring the robot thats following it and moving towards the survived robot.\\n\\n# Complexity\\n- Time complexity:\\n- O(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    struct distMap\\n    {\\n        long int left, right, distance;\\n    };\\n    \\n    struct distMapCompare {\\n        \\n        bool operator()(distMap const& p1, distMap const& p2)\\n        {\\n            // return \"true\" if \"p1\" is ordered\\n            // before \"p2\", for example:\\n            return p1.distance < p2.distance;\\n        }\\n    };\\n    \\n    struct robot\\n    {\\n        long int position, health, direction, origPos;\\n    };\\n    \\n    bool static orderRobots(const robot &a, const robot &b)\\n    {\\n        return a.position < b.position;\\n    }\\n    \\n    bool static isValidDirection(char l, char r)\\n    {\\n        if(l == \\'R\\' && r == \\'L\\') return true;\\n        return false;\\n    }\\n    \\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        \\n        long int n = positions.size();\\n        \\n        vector<robot> robots;\\n        for(long int i = 0; i< n; i++)\\n        {\\n            robot r; \\n            r.position = positions[i]; r.health = healths[i]; r.direction = directions[i]; r.origPos = i;\\n            robots.push_back(r);\\n        }\\n        \\n        sort(robots.begin(), robots.end(), orderRobots);\\n        \\n        map<long int, long int> posMap;\\n        \\n        for(long int i = 0; i<n ;i++)\\n        {\\n            posMap[ robots[i].origPos ] = i;\\n            //printf(\"[%d %d] \", robots[i].position, robots[i].health);\\n        }\\n        \\n        priority_queue<distMap, vector<distMap>, distMapCompare> Q;\\n        \\n        \\n        for(long int i = 0; i< n-1; i++)\\n        {\\n            // if((i-1 >= 0) && ( isValidDirection(robots[i-1].direction, robots[i].direction)))\\n            // {\\n            //     distMap d;\\n            //     d.left = i-1;\\n            //     d.right = i;\\n            //     d.distance = ceil(abs((robots[i].position - robots[i-1].position) / 2.0));\\n            //     Q.push(d);\\n            // }\\n            \\n            if((i+1 < n) &&  ( isValidDirection(robots[i].direction, robots[i+1].direction)) )\\n            {\\n                distMap d;\\n                d.left = i;\\n                d.right = i+1;\\n                d.distance = ceil( abs( ceil((robots[i+1].position - robots[i].position) / 2.0)));\\n                Q.push(d);\\n            }\\n        }\\n        \\n    \\n        \\n        long int clockTicker = 0;\\n        while(!Q.empty())\\n        {\\n            distMap d = Q.top();\\n            Q.pop();\\n            \\n            // Dont touch.\\n            if( robots[d.left].health == 0 || robots[d.right].health == 0 ) continue;\\n            \\n            clockTicker+= (d.distance+1);\\n            \\n            if(robots[d.left].health == robots[d.right].health)\\n            {\\n                // same powers. Reduce both powers.\\n                robots[d.left].health = robots[d.right].health = 0;\\n                \\n                // Add left one to the picture.\\n                long int j = d.left, nextLeft = -1;\\n                while(j>=0 && robots[j].health == 0) j--;\\n                if( j >= 0 && robots[j].health > 0 &&  ( robots[j].direction == robots[d.left].direction))\\n                {\\n                    nextLeft = j;              \\n                }\\n\\n                // Add next Right one to the picture.\\n                long int nextRight = -1;\\n                j = d.right;\\n                while(j< n && robots[j].health == 0) j++;\\n                if( j < n && robots[j].health > 0 &&  ( robots[j].direction == robots[d.right].direction))\\n                {\\n                    nextRight = j;              \\n                }\\n                \\n                if(nextLeft == -1 || nextRight == -1) continue;\\n                \\n                distMap dd;\\n                dd.left = nextLeft; dd.right = nextRight; \\n\\n                robots[nextLeft].position+=d.distance;\\n                robots[nextRight].position-=d.distance;\\n\\n                dd.distance = ceil( abs (  abs(robots[nextLeft].position - robots[nextRight].position) )/2.0 );\\n                \\n                Q.push(dd);\\n            }\\n            else if(robots[d.left].health < robots[d.right].health)\\n            {\\n                // Right robot consumes left one.\\n                robots[d.right].health -= 1;\\n                robots[d.left].health = 0;\\n                robots[d.left].position += d.distance;\\n                robots[d.right].position -= d.distance;\\n                \\n                \\n                // Add left one to the picture.\\n                long int j = d.left, nextLeft = -1;\\n                while(j>=0 && robots[j].health == 0) j--;\\n                if( j >= 0 && robots[j].health > 0 &&  ( robots[j].direction == robots[d.left].direction))\\n                {\\n                    nextLeft = j;              \\n                }\\n\\n                if(nextLeft == -1) continue;\\n                \\n                distMap dd;\\n                \\n                dd.left = nextLeft; dd.right = d.right;\\n                robots[nextLeft].position+= d.distance;\\n                dd.distance = ceil(abs (  abs(robots[nextLeft].position - robots[d.right].position))/2);\\n                \\n                Q.push(dd);\\n            }\\n            \\n            else \\n            {\\n                // left robot consumes right one.\\n                robots[d.left].health -= 1;\\n                robots[d.right].health = 0;\\n                robots[d.right].position -= d.distance;\\n                robots[d.left].position += d.distance;\\n                \\n                // Add next Right one to the picture.\\n                long int nextRight = -1, j = d.right;\\n                while(j<n && robots[j].health == 0) j++;\\n                if( j < n && robots[j].health > 0 &&  ( robots[j].direction == robots[d.right].direction))\\n                {\\n                    nextRight = j;              \\n                }\\n\\n                if(nextRight == -1) continue;\\n                \\n                distMap dd;\\n                dd.left = d.left; dd.right = nextRight;\\n                robots[nextRight].position-= d.distance;\\n                dd.distance =ceil( abs ( abs(robots[nextRight].position - robots[d.left].position) )/2);\\n                \\n                Q.push(dd);\\n            }\\n            \\n        }\\n        \\n        vector<int> result;\\n        bool survival= false;\\n        for(long int i = 0; i< n; i++)\\n        {\\n            long int actPos = posMap[i];\\n            \\n            if(robots[actPos].health > 0) \\n            {\\n                survival = true;\\n                result.push_back((int) robots[actPos].health);\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct distMap\\n    {\\n        long int left, right, distance;\\n    };\\n    \\n    struct distMapCompare {\\n        \\n        bool operator()(distMap const& p1, distMap const& p2)\\n        {\\n            // return \"true\" if \"p1\" is ordered\\n            // before \"p2\", for example:\\n            return p1.distance < p2.distance;\\n        }\\n    };\\n    \\n    struct robot\\n    {\\n        long int position, health, direction, origPos;\\n    };\\n    \\n    bool static orderRobots(const robot &a, const robot &b)\\n    {\\n        return a.position < b.position;\\n    }\\n    \\n    bool static isValidDirection(char l, char r)\\n    {\\n        if(l == \\'R\\' && r == \\'L\\') return true;\\n        return false;\\n    }\\n    \\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        \\n        long int n = positions.size();\\n        \\n        vector<robot> robots;\\n        for(long int i = 0; i< n; i++)\\n        {\\n            robot r; \\n            r.position = positions[i]; r.health = healths[i]; r.direction = directions[i]; r.origPos = i;\\n            robots.push_back(r);\\n        }\\n        \\n        sort(robots.begin(), robots.end(), orderRobots);\\n        \\n        map<long int, long int> posMap;\\n        \\n        for(long int i = 0; i<n ;i++)\\n        {\\n            posMap[ robots[i].origPos ] = i;\\n            //printf(\"[%d %d] \", robots[i].position, robots[i].health);\\n        }\\n        \\n        priority_queue<distMap, vector<distMap>, distMapCompare> Q;\\n        \\n        \\n        for(long int i = 0; i< n-1; i++)\\n        {\\n            // if((i-1 >= 0) && ( isValidDirection(robots[i-1].direction, robots[i].direction)))\\n            // {\\n            //     distMap d;\\n            //     d.left = i-1;\\n            //     d.right = i;\\n            //     d.distance = ceil(abs((robots[i].position - robots[i-1].position) / 2.0));\\n            //     Q.push(d);\\n            // }\\n            \\n            if((i+1 < n) &&  ( isValidDirection(robots[i].direction, robots[i+1].direction)) )\\n            {\\n                distMap d;\\n                d.left = i;\\n                d.right = i+1;\\n                d.distance = ceil( abs( ceil((robots[i+1].position - robots[i].position) / 2.0)));\\n                Q.push(d);\\n            }\\n        }\\n        \\n    \\n        \\n        long int clockTicker = 0;\\n        while(!Q.empty())\\n        {\\n            distMap d = Q.top();\\n            Q.pop();\\n            \\n            // Dont touch.\\n            if( robots[d.left].health == 0 || robots[d.right].health == 0 ) continue;\\n            \\n            clockTicker+= (d.distance+1);\\n            \\n            if(robots[d.left].health == robots[d.right].health)\\n            {\\n                // same powers. Reduce both powers.\\n                robots[d.left].health = robots[d.right].health = 0;\\n                \\n                // Add left one to the picture.\\n                long int j = d.left, nextLeft = -1;\\n                while(j>=0 && robots[j].health == 0) j--;\\n                if( j >= 0 && robots[j].health > 0 &&  ( robots[j].direction == robots[d.left].direction))\\n                {\\n                    nextLeft = j;              \\n                }\\n\\n                // Add next Right one to the picture.\\n                long int nextRight = -1;\\n                j = d.right;\\n                while(j< n && robots[j].health == 0) j++;\\n                if( j < n && robots[j].health > 0 &&  ( robots[j].direction == robots[d.right].direction))\\n                {\\n                    nextRight = j;              \\n                }\\n                \\n                if(nextLeft == -1 || nextRight == -1) continue;\\n                \\n                distMap dd;\\n                dd.left = nextLeft; dd.right = nextRight; \\n\\n                robots[nextLeft].position+=d.distance;\\n                robots[nextRight].position-=d.distance;\\n\\n                dd.distance = ceil( abs (  abs(robots[nextLeft].position - robots[nextRight].position) )/2.0 );\\n                \\n                Q.push(dd);\\n            }\\n            else if(robots[d.left].health < robots[d.right].health)\\n            {\\n                // Right robot consumes left one.\\n                robots[d.right].health -= 1;\\n                robots[d.left].health = 0;\\n                robots[d.left].position += d.distance;\\n                robots[d.right].position -= d.distance;\\n                \\n                \\n                // Add left one to the picture.\\n                long int j = d.left, nextLeft = -1;\\n                while(j>=0 && robots[j].health == 0) j--;\\n                if( j >= 0 && robots[j].health > 0 &&  ( robots[j].direction == robots[d.left].direction))\\n                {\\n                    nextLeft = j;              \\n                }\\n\\n                if(nextLeft == -1) continue;\\n                \\n                distMap dd;\\n                \\n                dd.left = nextLeft; dd.right = d.right;\\n                robots[nextLeft].position+= d.distance;\\n                dd.distance = ceil(abs (  abs(robots[nextLeft].position - robots[d.right].position))/2);\\n                \\n                Q.push(dd);\\n            }\\n            \\n            else \\n            {\\n                // left robot consumes right one.\\n                robots[d.left].health -= 1;\\n                robots[d.right].health = 0;\\n                robots[d.right].position -= d.distance;\\n                robots[d.left].position += d.distance;\\n                \\n                // Add next Right one to the picture.\\n                long int nextRight = -1, j = d.right;\\n                while(j<n && robots[j].health == 0) j++;\\n                if( j < n && robots[j].health > 0 &&  ( robots[j].direction == robots[d.right].direction))\\n                {\\n                    nextRight = j;              \\n                }\\n\\n                if(nextRight == -1) continue;\\n                \\n                distMap dd;\\n                dd.left = d.left; dd.right = nextRight;\\n                robots[nextRight].position-= d.distance;\\n                dd.distance =ceil( abs ( abs(robots[nextRight].position - robots[d.left].position) )/2);\\n                \\n                Q.push(dd);\\n            }\\n            \\n        }\\n        \\n        vector<int> result;\\n        bool survival= false;\\n        for(long int i = 0; i< n; i++)\\n        {\\n            long int actPos = posMap[i];\\n            \\n            if(robots[actPos].health > 0) \\n            {\\n                survival = true;\\n                result.push_back((int) robots[actPos].health);\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699832,
                "title": "using-stack-311-ms",
                "content": "# Intuition\\nIt looks like some sort of brackets problem\\n\\n# Approach\\nAll what is coming ```right``` can\\'t conflict with anything, ```left``` can conflct with anything going ```right```, so we using stack for this type of problem. ```positionsWithIndex``` will be used as dictionaty to have access for other arrays.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ - quick sort\\n\\n- Space complexity:\\n$$O(n)$$ - positionsWithIndex and stack\\n\\n# Code\\n```\\n/**\\n * @param {number[]} positions\\n * @param {number[]} healths\\n * @param {string} directions\\n * @return {number[]}\\n */\\nvar survivedRobotsHealths = function(positions, healths, directions) {\\n    const positionsWithIndex = new Array(positions.length);\\n    for (let i = 0; i < positions.length; ++i) {\\n        positionsWithIndex[i] = [i, positions[i]];\\n    }\\n\\n    positionsWithIndex.sort((a, b) => a[1] - b[1]);\\n    const stack = [];\\n    let lastIndex;\\n    let current;\\n\\n    for (let i = 0; i < positions.length; ++i) {\\n        if (directions[positionsWithIndex[i][0]] === \"R\") {\\n            stack.push(positionsWithIndex[i]);\\n        } else {\\n            current = positionsWithIndex[i];\\n            while (stack.length && current && directions[stack[(lastIndex = stack.length - 1)][0]] === \"R\") {\\n                if (healths[stack[lastIndex][0]] === healths[current[0]]) {\\n                    current = null;\\n                    stack.pop();\\n                } else if (healths[stack[lastIndex][0]] < healths[current[0]]) {\\n                    if (--healths[current[0]] === 0) current = null;\\n                    stack.pop();\\n                } else {\\n                    if (--healths[stack[lastIndex][0]] === 0) stack.pop();\\n                    current = null;\\n                }\\n            }\\n\\n            if (current) stack.push(current);\\n        }\\n    }\\n\\n    stack.sort((a, b) => a[0] - b[0]);\\n    return stack.map(o => healths[o[0]]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```right```\n```left```\n```right```\n```positionsWithIndex```\n```\\n/**\\n * @param {number[]} positions\\n * @param {number[]} healths\\n * @param {string} directions\\n * @return {number[]}\\n */\\nvar survivedRobotsHealths = function(positions, healths, directions) {\\n    const positionsWithIndex = new Array(positions.length);\\n    for (let i = 0; i < positions.length; ++i) {\\n        positionsWithIndex[i] = [i, positions[i]];\\n    }\\n\\n    positionsWithIndex.sort((a, b) => a[1] - b[1]);\\n    const stack = [];\\n    let lastIndex;\\n    let current;\\n\\n    for (let i = 0; i < positions.length; ++i) {\\n        if (directions[positionsWithIndex[i][0]] === \"R\") {\\n            stack.push(positionsWithIndex[i]);\\n        } else {\\n            current = positionsWithIndex[i];\\n            while (stack.length && current && directions[stack[(lastIndex = stack.length - 1)][0]] === \"R\") {\\n                if (healths[stack[lastIndex][0]] === healths[current[0]]) {\\n                    current = null;\\n                    stack.pop();\\n                } else if (healths[stack[lastIndex][0]] < healths[current[0]]) {\\n                    if (--healths[current[0]] === 0) current = null;\\n                    stack.pop();\\n                } else {\\n                    if (--healths[stack[lastIndex][0]] === 0) stack.pop();\\n                    current = null;\\n                }\\n            }\\n\\n            if (current) stack.push(current);\\n        }\\n    }\\n\\n    stack.sort((a, b) => a[0] - b[0]);\\n    return stack.map(o => healths[o[0]]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3699218,
                "title": "java-easy-double-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n    int n = positions.length;\\n    int t[][] = new int[n][4];\\n    for(int i = 0; i != n; ++i){\\n      t[i][0] = positions[i];\\n      t[i][1] = healths[i];\\n      t[i][2] = directions.charAt(i);\\n      t[i][3] = i;\\n    }\\n\\n    Arrays.sort(t, (int[] o1, int[] o2) -> o1[0] - o2[0]);\\n    LinkedList<int[]> ans = new LinkedList<>();\\n\\n    for(int x[]: t)\\n      if(x[2] == \\'R\\') ans.addLast(x); \\n      else \\n        while(true){\\n          if(ans.isEmpty() || ans.getLast()[2] == \\'L\\') {ans.addLast(x); break;}\\n          if(ans.getLast()[1] == x[1]){ans.pollLast(); break;}\\n          if(ans.getLast()[1]  > x[1]){ans.getLast()[1]--; break;}\\n          x[1]--;\\n          ans.pollLast(); \\n        }\\n    \\n    List<Integer> answer = new LinkedList<>();\\n    Collections.sort(ans, (int[] o1, int[] o2) -> o1[3] - o2[3]);\\n    while( !ans.isEmpty()) answer.add(ans.pollFirst()[1]);\\n\\n    return answer;      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n    int n = positions.length;\\n    int t[][] = new int[n][4];\\n    for(int i = 0; i != n; ++i){\\n      t[i][0] = positions[i];\\n      t[i][1] = healths[i];\\n      t[i][2] = directions.charAt(i);\\n      t[i][3] = i;\\n    }\\n\\n    Arrays.sort(t, (int[] o1, int[] o2) -> o1[0] - o2[0]);\\n    LinkedList<int[]> ans = new LinkedList<>();\\n\\n    for(int x[]: t)\\n      if(x[2] == \\'R\\') ans.addLast(x); \\n      else \\n        while(true){\\n          if(ans.isEmpty() || ans.getLast()[2] == \\'L\\') {ans.addLast(x); break;}\\n          if(ans.getLast()[1] == x[1]){ans.pollLast(); break;}\\n          if(ans.getLast()[1]  > x[1]){ans.getLast()[1]--; break;}\\n          x[1]--;\\n          ans.pollLast(); \\n        }\\n    \\n    List<Integer> answer = new LinkedList<>();\\n    Collections.sort(ans, (int[] o1, int[] o2) -> o1[3] - o2[3]);\\n    while( !ans.isEmpty()) answer.add(ans.pollFirst()[1]);\\n\\n    return answer;      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695972,
                "title": "o-nlogn-detailed-solution-approach-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) store index of robots going left and right along with their index and health\\n2) start from robots going left and find the first robot that collides using lower_bound function since we store index in set we can use binary search\\n3)if health is greater keep removing the robots till this robo reaches 0,else if health is equal both get removed else remove the one going right \\n4) the robots left are your answer \\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        set<int>left;\\n        set<int>right;\\n        unordered_map<int,pair<int,int>>right_val;\\n        unordered_map<int,pair<int,int>>left_val;\\n        for(int i=0;i<positions.size();i++){\\n            if(directions[i]==\\'L\\'){\\n                left.insert(positions[i]);\\n                left_val[positions[i]]={healths[i],i};\\n            }\\n            else{\\n                right.insert(positions[i]);\\n                right_val[positions[i]]={healths[i],i};\\n            }\\n        }\\n        vector<int>ans;\\n        for(auto i:left){\\n            if(right.empty()){\\n                break;\\n            }\\n            // cout<<i<<\" \";\\n            auto it = right.lower_bound(i);\\n            if(it==right.begin()){\\n                continue;\\n            }\\n            it--;\\n            pair<int,int>l=left_val[i];\\n            pair<int,int>r=right_val[*it];\\n            //cout<<i<<\" \"<<*it<<\" \"<<l.first<<\" \"<<r.first<<endl;\\n            if(l.first>r.first){\\n                while(true){\\n                    if(right.size()==0){\\n                        break;\\n                    }\\n                    auto it1 = right.lower_bound(i);\\n                    if(it1==right.begin()){\\n                        break;\\n                    }\\n                    it1--;\\n                    pair<int,int>r1=right_val[*it1];\\n                    pair<int,int>l1=left_val[i];\\n                    // cout<<i<<\" \"<<*it1<<\" \"<<l1.first<<\" \"<<r1.first<<endl;\\n                    // cout<<left.size()<<\" \"<<right.size()<<endl;\\n                    if(l1.first>r1.first){\\n                        left_val[i].first--;\\n                        right_val.erase(*it1);   \\n                        right.erase(*it1);\\n                    }\\n                    else if(l1.first==r1.first){\\n                        int val=*it1;\\n                        right_val.erase(val);\\n                        right.erase(val);\\n                        left_val.erase(i);\\n                        break;\\n                    }\\n                    else{\\n                        right_val[*it1].first--;\\n                        left_val.erase(i);\\n                        break;\\n                    }\\n                    //cout<<left.size()<<\" \"<<right.size()<<endl;\\n                }\\n            }\\n            else if(l.first==r.first){\\n                int val=*it;\\n                right_val.erase(val);\\n                right.erase(val);\\n                left_val.erase(i);\\n            }\\n            else{\\n                //cout<<i<<\" \"<<*it<<\" \"<<right_val[*it].first<<\" \";\\n                right_val[*it].first--;\\n                left_val.erase(i);\\n                //cout<<right_val[*it].first<<endl; \\n            }\\n        }\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        for(auto i:left_val){\\n            pq.push({i.second.second,i.second.first});\\n        }\\n        for(auto i:right_val){\\n            pq.push({i.second.second,i.second.first});\\n        }\\n        while(!pq.empty()){\\n            ans.push_back(pq.top()[1]);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        set<int>left;\\n        set<int>right;\\n        unordered_map<int,pair<int,int>>right_val;\\n        unordered_map<int,pair<int,int>>left_val;\\n        for(int i=0;i<positions.size();i++){\\n            if(directions[i]==\\'L\\'){\\n                left.insert(positions[i]);\\n                left_val[positions[i]]={healths[i],i};\\n            }\\n            else{\\n                right.insert(positions[i]);\\n                right_val[positions[i]]={healths[i],i};\\n            }\\n        }\\n        vector<int>ans;\\n        for(auto i:left){\\n            if(right.empty()){\\n                break;\\n            }\\n            // cout<<i<<\" \";\\n            auto it = right.lower_bound(i);\\n            if(it==right.begin()){\\n                continue;\\n            }\\n            it--;\\n            pair<int,int>l=left_val[i];\\n            pair<int,int>r=right_val[*it];\\n            //cout<<i<<\" \"<<*it<<\" \"<<l.first<<\" \"<<r.first<<endl;\\n            if(l.first>r.first){\\n                while(true){\\n                    if(right.size()==0){\\n                        break;\\n                    }\\n                    auto it1 = right.lower_bound(i);\\n                    if(it1==right.begin()){\\n                        break;\\n                    }\\n                    it1--;\\n                    pair<int,int>r1=right_val[*it1];\\n                    pair<int,int>l1=left_val[i];\\n                    // cout<<i<<\" \"<<*it1<<\" \"<<l1.first<<\" \"<<r1.first<<endl;\\n                    // cout<<left.size()<<\" \"<<right.size()<<endl;\\n                    if(l1.first>r1.first){\\n                        left_val[i].first--;\\n                        right_val.erase(*it1);   \\n                        right.erase(*it1);\\n                    }\\n                    else if(l1.first==r1.first){\\n                        int val=*it1;\\n                        right_val.erase(val);\\n                        right.erase(val);\\n                        left_val.erase(i);\\n                        break;\\n                    }\\n                    else{\\n                        right_val[*it1].first--;\\n                        left_val.erase(i);\\n                        break;\\n                    }\\n                    //cout<<left.size()<<\" \"<<right.size()<<endl;\\n                }\\n            }\\n            else if(l.first==r.first){\\n                int val=*it;\\n                right_val.erase(val);\\n                right.erase(val);\\n                left_val.erase(i);\\n            }\\n            else{\\n                //cout<<i<<\" \"<<*it<<\" \"<<right_val[*it].first<<\" \";\\n                right_val[*it].first--;\\n                left_val.erase(i);\\n                //cout<<right_val[*it].first<<endl; \\n            }\\n        }\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        for(auto i:left_val){\\n            pq.push({i.second.second,i.second.first});\\n        }\\n        for(auto i:right_val){\\n            pq.push({i.second.second,i.second.first});\\n        }\\n        while(!pq.empty()){\\n            ans.push_back(pq.top()[1]);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3694126,
                "title": "simple-java-code",
                "content": "# Intuition\\nSorting and Stack\\n\\n# Approach\\nJust sort the positions array and perform the collisions one by one by using stack.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        int[][] arr = new int[n][2];\\n        for(int i=0;i<n;i++){\\n            arr[i][0] = positions[i];\\n            arr[i][1] = i;\\n        }\\n        Arrays.sort(arr,(a,b) -> a[0] - b[0]);\\n\\n        Stack<Integer> st = new Stack<>();\\n        for(int i=0;i<n;i++){\\n            int index = arr[i][1];\\n            char dir = directions.charAt(index);\\n            int health = healths[index];\\n\\n            if(st.isEmpty() || dir == \\'R\\'){\\n                st.push(index);\\n            }\\n            else{\\n                while(!st.isEmpty() && directions.charAt(st.peek()) == \\'R\\'){\\n                    int top = st.peek();\\n                    if(healths[top] == healths[index]){\\n                        healths[top] = 0;\\n                        healths[index] = 0;\\n                        st.pop();\\n                        break;\\n                    }\\n                    else if(healths[top] > healths[index]){\\n                        healths[top] -= 1;\\n                        healths[index] = 0;\\n                        break;\\n                    }\\n                    else{\\n                        healths[index] -= 1;\\n                        healths[top] = 0;\\n                        st.pop();\\n                    }\\n                }\\n                if(healths[index] > 0) st.push(index);\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for(int it:healths){\\n            if(it > 0){\\n                result.add(it);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        int[][] arr = new int[n][2];\\n        for(int i=0;i<n;i++){\\n            arr[i][0] = positions[i];\\n            arr[i][1] = i;\\n        }\\n        Arrays.sort(arr,(a,b) -> a[0] - b[0]);\\n\\n        Stack<Integer> st = new Stack<>();\\n        for(int i=0;i<n;i++){\\n            int index = arr[i][1];\\n            char dir = directions.charAt(index);\\n            int health = healths[index];\\n\\n            if(st.isEmpty() || dir == \\'R\\'){\\n                st.push(index);\\n            }\\n            else{\\n                while(!st.isEmpty() && directions.charAt(st.peek()) == \\'R\\'){\\n                    int top = st.peek();\\n                    if(healths[top] == healths[index]){\\n                        healths[top] = 0;\\n                        healths[index] = 0;\\n                        st.pop();\\n                        break;\\n                    }\\n                    else if(healths[top] > healths[index]){\\n                        healths[top] -= 1;\\n                        healths[index] = 0;\\n                        break;\\n                    }\\n                    else{\\n                        healths[index] -= 1;\\n                        healths[top] = 0;\\n                        st.pop();\\n                    }\\n                }\\n                if(healths[index] > 0) st.push(index);\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for(int it:healths){\\n            if(it > 0){\\n                result.add(it);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692954,
                "title": "using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        stack = []\\n        robots = []\\n        for i in range(len(positions)):\\n            robots.append([positions[i], healths[i], directions[i]])\\n        \\n        robots.sort(key = lambda x : x[0])\\n        opt = []\\n        left = []\\n        i = 0\\n        #rint(robots)\\n        while i < len(healths):\\n            #print(stack)\\n            if robots[i][2] == \"R\": \\n                stack.append(robots[i])\\n            elif robots[i][2] == \"L\":\\n                #print(robots[i], stack)\\n                if stack:\\n                    right = stack.pop()\\n                    if right[1] == robots[i][1]:\\n                        i += 1\\n                        continue\\n                    if right[1] > robots[i][1]:\\n                        right[1] -= 1\\n                        stack.append(right)\\n                    else:\\n                        while right[1] < robots[i][1] and stack:\\n                            right = stack.pop()\\n                            robots[i][1] -= 1\\n                        if not stack and right[1] < robots[i][1]:\\n                            robots[i][1] -= 1\\n                            left.append(robots[i])\\n                        elif right[1] > robots[i][1]:\\n                            right[1] -= 1\\n                            stack.append(right)\\n                else:\\n                    left.append(robots[i])\\n                \\n            i += 1\\n        opt = []\\n        opt += stack\\n        opt += left\\n        dp = {}\\n        for i in opt:\\n            dp[i[0]] = i[1]\\n        #print(stack, left)\\n        ans = []\\n        for i in positions:\\n            if i in dp:\\n                ans.append(dp[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        stack = []\\n        robots = []\\n        for i in range(len(positions)):\\n            robots.append([positions[i], healths[i], directions[i]])\\n        \\n        robots.sort(key = lambda x : x[0])\\n        opt = []\\n        left = []\\n        i = 0\\n        #rint(robots)\\n        while i < len(healths):\\n            #print(stack)\\n            if robots[i][2] == \"R\": \\n                stack.append(robots[i])\\n            elif robots[i][2] == \"L\":\\n                #print(robots[i], stack)\\n                if stack:\\n                    right = stack.pop()\\n                    if right[1] == robots[i][1]:\\n                        i += 1\\n                        continue\\n                    if right[1] > robots[i][1]:\\n                        right[1] -= 1\\n                        stack.append(right)\\n                    else:\\n                        while right[1] < robots[i][1] and stack:\\n                            right = stack.pop()\\n                            robots[i][1] -= 1\\n                        if not stack and right[1] < robots[i][1]:\\n                            robots[i][1] -= 1\\n                            left.append(robots[i])\\n                        elif right[1] > robots[i][1]:\\n                            right[1] -= 1\\n                            stack.append(right)\\n                else:\\n                    left.append(robots[i])\\n                \\n            i += 1\\n        opt = []\\n        opt += stack\\n        opt += left\\n        dp = {}\\n        for i in opt:\\n            dp[i[0]] = i[1]\\n        #print(stack, left)\\n        ans = []\\n        for i in positions:\\n            if i in dp:\\n                ans.append(dp[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692431,
                "title": "using-stack-and-pair-class",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    class Pair{\\n        int pos, health, sno;\\n        char dir;\\n\\n        Pair(int pos, int health, char dir, int sno){\\n            this.pos  = pos;\\n            this.health = health;\\n            this.dir = dir;\\n            this.sno = sno;\\n        }\\n    }\\n\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        Pair arr[] = new Pair[n];\\n        \\n        Stack<Pair> s = new Stack<>();\\n        char[] way = directions.toCharArray();\\n\\n        for(int i = 0; i < n; i++){\\n            arr[i] =  new Pair(positions[i], healths[i], way[i], i + 1);\\n        }\\n\\n        Arrays.sort(arr, (a,b) ->{\\n            return a.pos - b.pos;\\n        });\\n\\n        for(Pair ele : arr){\\n            if(ele.dir == \\'L\\' && s.isEmpty()) s.push(ele);\\n            else if(ele.dir == \\'R\\') s.push(ele);\\n            else{\\n                if(s.peek().dir == ele.dir){\\n                    s.push(ele);\\n                    continue;\\n                }\\n                performOperations(s, ele);\\n            }\\n\\n        }\\n        List<Pair> list = new ArrayList<>();\\n        while(!s.isEmpty()){\\n            list.add(s.pop());\\n        }\\n        Collections.sort(list, (a,b) ->{\\n            return a.sno - b.sno;\\n        });\\n\\n        List<Integer> ans = new ArrayList<>();\\n        for(Pair ele : list)\\n            ans.add(ele.health);\\n\\n        return ans;\\n    }\\n\\n    private void performOperations(Stack<Pair> s, Pair ele){\\n        while(!s.isEmpty()){\\n            Pair temp = s.pop();\\n            if(ele.health < temp.health){\\n                temp.health -= 1;\\n                s.push(temp);\\n                return;\\n            }else if(ele.health == temp.health){\\n                return;\\n            }else{\\n                ele.health -= 1;\\n                if(s.isEmpty() || s.peek().dir == ele.dir){\\n                    s.push(ele);\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    class Pair{\\n        int pos, health, sno;\\n        char dir;\\n\\n        Pair(int pos, int health, char dir, int sno){\\n            this.pos  = pos;\\n            this.health = health;\\n            this.dir = dir;\\n            this.sno = sno;\\n        }\\n    }\\n\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        Pair arr[] = new Pair[n];\\n        \\n        Stack<Pair> s = new Stack<>();\\n        char[] way = directions.toCharArray();\\n\\n        for(int i = 0; i < n; i++){\\n            arr[i] =  new Pair(positions[i], healths[i], way[i], i + 1);\\n        }\\n\\n        Arrays.sort(arr, (a,b) ->{\\n            return a.pos - b.pos;\\n        });\\n\\n        for(Pair ele : arr){\\n            if(ele.dir == \\'L\\' && s.isEmpty()) s.push(ele);\\n            else if(ele.dir == \\'R\\') s.push(ele);\\n            else{\\n                if(s.peek().dir == ele.dir){\\n                    s.push(ele);\\n                    continue;\\n                }\\n                performOperations(s, ele);\\n            }\\n\\n        }\\n        List<Pair> list = new ArrayList<>();\\n        while(!s.isEmpty()){\\n            list.add(s.pop());\\n        }\\n        Collections.sort(list, (a,b) ->{\\n            return a.sno - b.sno;\\n        });\\n\\n        List<Integer> ans = new ArrayList<>();\\n        for(Pair ele : list)\\n            ans.add(ele.health);\\n\\n        return ans;\\n    }\\n\\n    private void performOperations(Stack<Pair> s, Pair ele){\\n        while(!s.isEmpty()){\\n            Pair temp = s.pop();\\n            if(ele.health < temp.health){\\n                temp.health -= 1;\\n                s.push(temp);\\n                return;\\n            }else if(ele.health == temp.health){\\n                return;\\n            }else{\\n                ele.health -= 1;\\n                if(s.isEmpty() || s.peek().dir == ele.dir){\\n                    s.push(ele);\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692290,
                "title": "python-sorting-stack-solution",
                "content": "It is not hard to figure out that this is a Stack-based problem since we have to repeatedly check collisions of the current robot with previous robots. And we can do that efficiently using a Stack.\\n\\nNow the thing is, the positions on which robots are placed on a line is not provided in a sorted order. It means, to correctly check the collisions, we have to first place the robots in right order. In other words, we have to sort the robots based on their positions in increasing order. And since we have three different lists, it is not a good idea to sort each separately as that will not give us the correct data.\\n\\nWe have to merge the three lists into one such that at each index, we have each robot\\'s position, health, direction and also the original index.\\n\\nThen, we can sort by position.\\n\\nThe reason why we have the original index in this merged list is because later when we have to return the output, we have to return the robots in the same order in which they initially were. In that case, we will again have to sort the list but that time, we will sort based on the original index values.\\n\\n\\n```\\ndef survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        # Count of robots\\n        n = len(positions)\\n        \\n        # Keep the data in a single list for each robot\\n        # And also keep track of original indices since we will sort\\n        robots = [[positions[i], healths[i], directions[i], i] for i in range(n)]\\n        \\n        # Since positions can be unsorted, sort the robots by their positions\\n        robots.sort()\\n        \\n        # Stack to simulate the collisions\\n        stack = []\\n        \\n        # Go through each robot\\n        for robot in robots:\\n            \\n            # Flag to check if collision occured or not\\n            collision = False\\n            \\n            while stack:\\n                # If the direction of current robot is same as previous\\n                # Or, if current robot is going left and previous is going right\\n                # Then there won\\'t be any collision so exit\\n                if robot[2] == stack[-1][2] or (robot[2] == \"R\" and stack[-1][2] == \"L\"):\\n                    collision = False\\n                    break\\n                    \\n                # Otherwise, there is a collision with previous robot\\n                collision = True\\n                \\n                # If the health is same, then pop from stack\\n                # And we don\\'t continue because both robots will be removed now from line\\n                if robot[1] == stack[-1][1]: \\n                    stack.pop()\\n                    break\\n                else:\\n                    # If the current robot has a higher health than robot on top of stack\\n                    if robot[1] > stack[-1][1]:\\n                        # The robot will be popped from stack\\n                        stack.pop()\\n                        \\n                        # If stack is empty, then there won\\'t be any more collisions\\n                        if not stack: collision = False\\n                        \\n                        # Also, the health of current robot will decrease by 1\\n                        robot[1] -= 1\\n                        \\n                    # If the current robot has a lower health than robot on top of stack\\n                    else:\\n                        # The health of robot on top of stack will decrease by 1\\n                        # And current robot will be removed from line\\n                        stack[-1][1] -= 1\\n                        \\n                        # Break since we have removed current robot from the line\\n                        break\\n\\n            # If collision flag is False, put this robot in the stack\\n            if not collision: stack.append(robot)\\n        \\n        # Sort the stack based on original indices to get the order correct\\n        stack.sort(key=lambda x:x[3])\\n        \\n        # We just want the health so just keep that data in the stack\\n        stack = [pair[1] for pair in stack]\\n        \\n        # Finally, return the stack\\n        return stack\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\ndef survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        # Count of robots\\n        n = len(positions)\\n        \\n        # Keep the data in a single list for each robot\\n        # And also keep track of original indices since we will sort\\n        robots = [[positions[i], healths[i], directions[i], i] for i in range(n)]\\n        \\n        # Since positions can be unsorted, sort the robots by their positions\\n        robots.sort()\\n        \\n        # Stack to simulate the collisions\\n        stack = []\\n        \\n        # Go through each robot\\n        for robot in robots:\\n            \\n            # Flag to check if collision occured or not\\n            collision = False\\n            \\n            while stack:\\n                # If the direction of current robot is same as previous\\n                # Or, if current robot is going left and previous is going right\\n                # Then there won\\'t be any collision so exit\\n                if robot[2] == stack[-1][2] or (robot[2] == \"R\" and stack[-1][2] == \"L\"):\\n                    collision = False\\n                    break\\n                    \\n                # Otherwise, there is a collision with previous robot\\n                collision = True\\n                \\n                # If the health is same, then pop from stack\\n                # And we don\\'t continue because both robots will be removed now from line\\n                if robot[1] == stack[-1][1]: \\n                    stack.pop()\\n                    break\\n                else:\\n                    # If the current robot has a higher health than robot on top of stack\\n                    if robot[1] > stack[-1][1]:\\n                        # The robot will be popped from stack\\n                        stack.pop()\\n                        \\n                        # If stack is empty, then there won\\'t be any more collisions\\n                        if not stack: collision = False\\n                        \\n                        # Also, the health of current robot will decrease by 1\\n                        robot[1] -= 1\\n                        \\n                    # If the current robot has a lower health than robot on top of stack\\n                    else:\\n                        # The health of robot on top of stack will decrease by 1\\n                        # And current robot will be removed from line\\n                        stack[-1][1] -= 1\\n                        \\n                        # Break since we have removed current robot from the line\\n                        break\\n\\n            # If collision flag is False, put this robot in the stack\\n            if not collision: stack.append(robot)\\n        \\n        # Sort the stack based on original indices to get the order correct\\n        stack.sort(key=lambda x:x[3])\\n        \\n        # We just want the health so just keep that data in the stack\\n        stack = [pair[1] for pair in stack]\\n        \\n        # Finally, return the stack\\n        return stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3691387,
                "title": "c-o-n-log-n-sorting-stack-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort and iterate the bots from left to right, and use a stack to keep track of remaining right-going bots on the left-hand-side. If a bot is heading left, then collide it with the right-going bot as more as possible.\\n\\nSince the bot all move at the same speed and collision takes no extra time, so the actual distance between bots does not matters. We can always handle the collision from left to right.\\n\\nEach collision will eliminate at least one bot. Since each bot can be placed in the stack and eliminated at most once, so aside from sorting (O(nlog n)), the collision part is strictly O(n) in time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSorting + Stack\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSorting: $$O(n\\\\log n)$$\\nCollision: $O(n)$, each bot can at most be put into the stack and removed once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n) + O(quicksort)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions,\\n                                      vector<int>& healths,\\n                                      string directions) {\\n        int n = positions.size();\\n        \\n        // Sort the bot with position in increasing order.\\n        vector<int> v(n);\\n        std::iota(begin(v), end(v), 0);\\n        std::sort(v.begin(), v.end(), [&positions](int i, int j){\\n            return positions[i] < positions[j];\\n        });\\n\\n        // The stack \"right\" stores the bots going rightward and\\n        // are on the left-hand-side of the current bot.\\n        vector<int> right;\\n        // Iterate through the bot from left to right.\\n        for (int i = 0; i < n; ++i) {\\n            // If it goes rightward, then push it to the \"right\" stack.\\n            char d = directions[v[i]];\\n            if (directions[v[i]] == \\'R\\') {\\n                right.push_back(v[i]);\\n                continue;\\n            }\\n            // If it goes leftward, it collides with bots going\\n            // rightward on the left-hand-side.\\n            int & h = healths[v[i]];\\n            while (!right.empty()) {\\n                // Health of right-going bot.\\n                int & rhealth = healths[right.back()];\\n                if (rhealth == h) {\\n                    // Equal health, then both are eliminated.\\n                    rhealth = 0;\\n                    right.pop_back();\\n                    h = 0;\\n                    break;\\n                } else if (rhealth > h) {\\n                    // Right-going bot wins. Eliminate left-going bot.\\n                    --rhealth;\\n                    h = 0;\\n                    break;\\n                } else {\\n                    // Left-going bot wins. Eliminate right-going bot.\\n                    rhealth = 0;\\n                    right.pop_back();\\n                    --h;\\n                }\\n            }\\n        }\\n        // Collect all the survived bot with health greater than 0\\n        // in the order specified by the problem.\\n        vector<int> res;\\n        for (int i = 0; i < n; ++i) {\\n            if (healths[i] != 0)\\n                res.push_back(healths[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions,\\n                                      vector<int>& healths,\\n                                      string directions) {\\n        int n = positions.size();\\n        \\n        // Sort the bot with position in increasing order.\\n        vector<int> v(n);\\n        std::iota(begin(v), end(v), 0);\\n        std::sort(v.begin(), v.end(), [&positions](int i, int j){\\n            return positions[i] < positions[j];\\n        });\\n\\n        // The stack \"right\" stores the bots going rightward and\\n        // are on the left-hand-side of the current bot.\\n        vector<int> right;\\n        // Iterate through the bot from left to right.\\n        for (int i = 0; i < n; ++i) {\\n            // If it goes rightward, then push it to the \"right\" stack.\\n            char d = directions[v[i]];\\n            if (directions[v[i]] == \\'R\\') {\\n                right.push_back(v[i]);\\n                continue;\\n            }\\n            // If it goes leftward, it collides with bots going\\n            // rightward on the left-hand-side.\\n            int & h = healths[v[i]];\\n            while (!right.empty()) {\\n                // Health of right-going bot.\\n                int & rhealth = healths[right.back()];\\n                if (rhealth == h) {\\n                    // Equal health, then both are eliminated.\\n                    rhealth = 0;\\n                    right.pop_back();\\n                    h = 0;\\n                    break;\\n                } else if (rhealth > h) {\\n                    // Right-going bot wins. Eliminate left-going bot.\\n                    --rhealth;\\n                    h = 0;\\n                    break;\\n                } else {\\n                    // Left-going bot wins. Eliminate right-going bot.\\n                    rhealth = 0;\\n                    right.pop_back();\\n                    --h;\\n                }\\n            }\\n        }\\n        // Collect all the survived bot with health greater than 0\\n        // in the order specified by the problem.\\n        vector<int> res;\\n        for (int i = 0; i < n; ++i) {\\n            if (healths[i] != 0)\\n                res.push_back(healths[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690449,
                "title": "c-beginner-friendly-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    struct Robot\\n    {\\n        int position;\\n        int health;\\n        char direction;\\n        int index;\\n    };\\n\\n \\n       vector<int> survivedRobotsHealths(vector<int> &positions, vector<int> &healths, string directions)\\n    {\\n        int n = positions.size();\\n\\n        vector<Robot> nums;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            nums.push_back({positions[i], healths[i], directions[i], i});\\n        }\\n        sort(begin(nums), end(nums), [&](const Robot &a, const Robot &b)\\n             { return a.position < b.position; });\\n\\n        stack<Robot> st;\\n        int i = 0;\\n\\n        while (i < n)\\n        {\\n\\n            if (!st.empty() and st.top().direction == \\'R\\' and nums[i].direction == \\'L\\')\\n            {\\n\\n                if (st.top().health == nums[i].health)\\n                {\\n                    st.pop();\\n                }\\n                else if (st.top().health > nums[i].health)\\n                {\\n                    st.top().health--;\\n                }\\n                else\\n                {\\n                    nums[i].health--;\\n                    st.pop();\\n                    continue;\\n                }\\n            }\\n            else\\n            {\\n                st.push(nums[i]);\\n            }\\n\\n            i++;\\n        }\\n        vector<Robot> ans;\\n\\n        while (!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        sort(begin(ans), end(ans), [&](const Robot &a, const Robot &b)\\n             { return a.index < b.index; });\\n\\n        vector<int> res;\\n        for (auto itr : ans)\\n        {\\n            res.push_back(itr.health);\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    struct Robot\\n    {\\n        int position;\\n        int health;\\n        char direction;\\n        int index;\\n    };\\n\\n \\n       vector<int> survivedRobotsHealths(vector<int> &positions, vector<int> &healths, string directions)\\n    {\\n        int n = positions.size();\\n\\n        vector<Robot> nums;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            nums.push_back({positions[i], healths[i], directions[i], i});\\n        }\\n        sort(begin(nums), end(nums), [&](const Robot &a, const Robot &b)\\n             { return a.position < b.position; });\\n\\n        stack<Robot> st;\\n        int i = 0;\\n\\n        while (i < n)\\n        {\\n\\n            if (!st.empty() and st.top().direction == \\'R\\' and nums[i].direction == \\'L\\')\\n            {\\n\\n                if (st.top().health == nums[i].health)\\n                {\\n                    st.pop();\\n                }\\n                else if (st.top().health > nums[i].health)\\n                {\\n                    st.top().health--;\\n                }\\n                else\\n                {\\n                    nums[i].health--;\\n                    st.pop();\\n                    continue;\\n                }\\n            }\\n            else\\n            {\\n                st.push(nums[i]);\\n            }\\n\\n            i++;\\n        }\\n        vector<Robot> ans;\\n\\n        while (!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        sort(begin(ans), end(ans), [&](const Robot &a, const Robot &b)\\n             { return a.index < b.index; });\\n\\n        vector<int> res;\\n        for (auto itr : ans)\\n        {\\n            res.push_back(itr.health);\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690412,
                "title": "easy-c-code",
                "content": "# Intuition\\nwe have to keep the track of directions of robots which is visited in the past so that we can tackle future robots\\n\\n# Approach\\nsort and stack simple\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<pair<pair<int,int>,pair<int,char>>> vt;\\n        int n = healths.size();\\n        bool flag = false;\\n        for(int i = 0; i<n; i++)\\n        {\\n            vt.push_back({{positions[i],i},{healths[i],directions[i]}});\\n        }\\n        sort(vt.begin(),vt.end());\\n        stack<pair<int,int>> st;\\n        vector<pair<int,int>> ans;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(vt[i].second.second == \\'R\\') st.push(make_pair(vt[i].first.second,vt[i].second.first));\\n            else if(vt[i].second.second == \\'L\\')\\n            {\\n                int val = vt[i].second.first;\\n                int index = vt[i].first.second;\\n                if(st.size() == 0) ans.push_back({index,val});\\n                else\\n                {\\n                     int tp = st.top().second;\\n                    int id = st.top().first;\\n                    // return {tp};\\n                    if(tp == val)\\n                    {\\n                        st.pop();\\n                    }\\n                    else if(tp > val)\\n                    {\\n                          \\n                        st.pop();\\n                        st.push({id,tp-1});\\n                      \\n                    }\\n                    else\\n                    {\\n                         \\n                        while(st.size() != 0 && tp < val)\\n                        {\\n                            val = val-1;\\n                            st.pop();\\n                          \\n                            if(st.empty()) break;\\n                             tp = st.top().second;\\n                            if(tp == val) \\n                            {\\n                                st.pop();\\n                                flag = true;\\n                                break;\\n                            }\\n                               \\n                        }\\n                        if(flag)\\n                        {\\n                            flag = false;\\n                            continue;\\n                        }\\n                        if(st.size() == 0 && val > 0) ans.push_back({index,val});\\n                        else \\n                        {\\n                           \\n                            int tp = st.top().second;\\n                            int id = st.top().first;\\n                            st.pop();\\n                            st.push({id,tp-1});\\n                        }\\n                    }\\n                        \\n                }\\n            }\\n        }\\n        // int size = st.size();\\n        // return {size};\\n        // if(st.size() == 0) return ans;\\n        // else \\n        // {\\n             while(!st.empty())\\n            {\\n                int tp  = st.top().second;\\n                int id = st.top().first;\\n                ans.push_back({id,tp});\\n                st.pop();\\n            }\\n        //}\\n        sort(ans.begin(),ans.end());\\n        vector<int> res;\\n        // int w = ans.size();\\n        // return {ans[0].second};\\n        for(int i = 0; i<ans.size(); i++)\\n        {\\n            // return {ans[2].second};\\n            res.push_back(ans[i].second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<pair<pair<int,int>,pair<int,char>>> vt;\\n        int n = healths.size();\\n        bool flag = false;\\n        for(int i = 0; i<n; i++)\\n        {\\n            vt.push_back({{positions[i],i},{healths[i],directions[i]}});\\n        }\\n        sort(vt.begin(),vt.end());\\n        stack<pair<int,int>> st;\\n        vector<pair<int,int>> ans;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(vt[i].second.second == \\'R\\') st.push(make_pair(vt[i].first.second,vt[i].second.first));\\n            else if(vt[i].second.second == \\'L\\')\\n            {\\n                int val = vt[i].second.first;\\n                int index = vt[i].first.second;\\n                if(st.size() == 0) ans.push_back({index,val});\\n                else\\n                {\\n                     int tp = st.top().second;\\n                    int id = st.top().first;\\n                    // return {tp};\\n                    if(tp == val)\\n                    {\\n                        st.pop();\\n                    }\\n                    else if(tp > val)\\n                    {\\n                          \\n                        st.pop();\\n                        st.push({id,tp-1});\\n                      \\n                    }\\n                    else\\n                    {\\n                         \\n                        while(st.size() != 0 && tp < val)\\n                        {\\n                            val = val-1;\\n                            st.pop();\\n                          \\n                            if(st.empty()) break;\\n                             tp = st.top().second;\\n                            if(tp == val) \\n                            {\\n                                st.pop();\\n                                flag = true;\\n                                break;\\n                            }\\n                               \\n                        }\\n                        if(flag)\\n                        {\\n                            flag = false;\\n                            continue;\\n                        }\\n                        if(st.size() == 0 && val > 0) ans.push_back({index,val});\\n                        else \\n                        {\\n                           \\n                            int tp = st.top().second;\\n                            int id = st.top().first;\\n                            st.pop();\\n                            st.push({id,tp-1});\\n                        }\\n                    }\\n                        \\n                }\\n            }\\n        }\\n        // int size = st.size();\\n        // return {size};\\n        // if(st.size() == 0) return ans;\\n        // else \\n        // {\\n             while(!st.empty())\\n            {\\n                int tp  = st.top().second;\\n                int id = st.top().first;\\n                ans.push_back({id,tp});\\n                st.pop();\\n            }\\n        //}\\n        sort(ans.begin(),ans.end());\\n        vector<int> res;\\n        // int w = ans.size();\\n        // return {ans[0].second};\\n        for(int i = 0; i<ans.size(); i++)\\n        {\\n            // return {ans[2].second};\\n            res.push_back(ans[i].second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689631,
                "title": "sorting-stack-based-approach-java-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n * logn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        int mat[][] = new int[n][2];\\n        for(int i = 0;i < n;i++){\\n            mat[i][0] = positions[i];\\n            mat[i][1] = i;\\n        } \\n        Arrays.sort(mat,(a,b) -> Integer.compare(a[0],b[0]));\\n        int tmp[] = new int[n]; \\n        Stack<Integer> st = new Stack<>();\\n        for(int i = 0;i < n;i++){\\n            if(st.isEmpty()){\\n                st.add(i);\\n                continue;\\n            }\\n            int peekIdx = mat[st.peek()][1];\\n            int currIdx = mat[i][1];\\n            if(directions.charAt(peekIdx) == \\'R\\' && directions.charAt(currIdx) == \\'L\\'){\\n                for(;!st.isEmpty() && healths[peekIdx] < healths[currIdx] && \\n                    directions.charAt(peekIdx) == \\'R\\' && directions.charAt(currIdx) == \\'L\\';){\\n                    tmp[peekIdx] = -1;\\n                    healths[currIdx]--;\\n                    st.pop();\\n                    if(!st.isEmpty()) peekIdx = mat[st.peek()][1];\\n                }\\n                if(st.isEmpty()){\\n                    st.add(i);\\n                }\\n                else{\\n                    if(directions.charAt(peekIdx) == \\'R\\' && directions.charAt(currIdx) == \\'L\\'){\\n                        if(healths[peekIdx] == healths[currIdx]){\\n                            tmp[peekIdx] = -1;\\n                            tmp[currIdx] = -1;\\n                            st.pop();\\n                        }\\n                        else{\\n                            tmp[currIdx] = -1;\\n                            healths[peekIdx]--;\\n                        }\\n                    }\\n                }\\n            }\\n            else st.add(i);\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0;i < n;i++){\\n            if(tmp[i] == -1) continue;\\n            ans.add(healths[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        int mat[][] = new int[n][2];\\n        for(int i = 0;i < n;i++){\\n            mat[i][0] = positions[i];\\n            mat[i][1] = i;\\n        } \\n        Arrays.sort(mat,(a,b) -> Integer.compare(a[0],b[0]));\\n        int tmp[] = new int[n]; \\n        Stack<Integer> st = new Stack<>();\\n        for(int i = 0;i < n;i++){\\n            if(st.isEmpty()){\\n                st.add(i);\\n                continue;\\n            }\\n            int peekIdx = mat[st.peek()][1];\\n            int currIdx = mat[i][1];\\n            if(directions.charAt(peekIdx) == \\'R\\' && directions.charAt(currIdx) == \\'L\\'){\\n                for(;!st.isEmpty() && healths[peekIdx] < healths[currIdx] && \\n                    directions.charAt(peekIdx) == \\'R\\' && directions.charAt(currIdx) == \\'L\\';){\\n                    tmp[peekIdx] = -1;\\n                    healths[currIdx]--;\\n                    st.pop();\\n                    if(!st.isEmpty()) peekIdx = mat[st.peek()][1];\\n                }\\n                if(st.isEmpty()){\\n                    st.add(i);\\n                }\\n                else{\\n                    if(directions.charAt(peekIdx) == \\'R\\' && directions.charAt(currIdx) == \\'L\\'){\\n                        if(healths[peekIdx] == healths[currIdx]){\\n                            tmp[peekIdx] = -1;\\n                            tmp[currIdx] = -1;\\n                            st.pop();\\n                        }\\n                        else{\\n                            tmp[currIdx] = -1;\\n                            healths[peekIdx]--;\\n                        }\\n                    }\\n                }\\n            }\\n            else st.add(i);\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0;i < n;i++){\\n            if(tmp[i] == -1) continue;\\n            ans.add(healths[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689034,
                "title": "c-stack-solution-self-explanatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        //0 ->left, 1->right\\n        vector<vector<int>>vc;\\n        vector<pair<int,int>>temp;\\n        for(int i=0;i<positions.size();i++){\\n            vc.push_back({positions[i],i,healths[i],directions[i]==\\'L\\'?0:1});\\n        };\\n        sort(vc.begin(),vc.end());\\n        int i=0;\\n        int j=positions.size()-1;\\n        while(i<=j&&vc[i][3]==0){\\n            temp.push_back({vc[i][1],vc[i][2]});\\n            i++;\\n        }\\n         while(j>=0&&vc[j][3]==1){\\n            temp.push_back({vc[j][1],vc[j][2]});\\n            j--;\\n        }\\n        \\n    stack<vector<int>>st;\\n \\n    while(i<=j){\\n        if(!st.empty())\\n        {\\n        vector<int>t=st.top();\\n        if(t[3]==vc[i][3]) {\\n            st.push(vc[i]);\\n            i++;\\n        }\\n        else {\\n            st.pop();\\n            if(t[2]>vc[i][2]) {\\n                st.push({t[0],t[1],t[2]-1,t[3]});\\n                i++;\\n            }\\n            else if(t[2]<vc[i][2]){\\n                vc[i][2]--;\\n            }\\n            else {\\n                  i++;\\n              }\\n        }\\n        }\\n        else \\n        {\\n            if(vc[i][3]==0){\\n                temp.push_back({vc[i][1],vc[i][2]});\\n            }\\n            else st.push(vc[i]);\\n            i++;\\n        }\\n    }\\n        \\n        \\n        while(!st.empty()){\\n            vector<int>ss=st.top();\\n            st.pop();\\n            temp.push_back({ss[1],ss[2]});\\n        }\\n     sort(temp.begin(),temp.end());\\n        vector<int>ans;\\n        for(int i=0;i<temp.size();i++) ans.push_back(temp[i].second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        //0 ->left, 1->right\\n        vector<vector<int>>vc;\\n        vector<pair<int,int>>temp;\\n        for(int i=0;i<positions.size();i++){\\n            vc.push_back({positions[i],i,healths[i],directions[i]==\\'L\\'?0:1});\\n        };\\n        sort(vc.begin(),vc.end());\\n        int i=0;\\n        int j=positions.size()-1;\\n        while(i<=j&&vc[i][3]==0){\\n            temp.push_back({vc[i][1],vc[i][2]});\\n            i++;\\n        }\\n         while(j>=0&&vc[j][3]==1){\\n            temp.push_back({vc[j][1],vc[j][2]});\\n            j--;\\n        }\\n        \\n    stack<vector<int>>st;\\n \\n    while(i<=j){\\n        if(!st.empty())\\n        {\\n        vector<int>t=st.top();\\n        if(t[3]==vc[i][3]) {\\n            st.push(vc[i]);\\n            i++;\\n        }\\n        else {\\n            st.pop();\\n            if(t[2]>vc[i][2]) {\\n                st.push({t[0],t[1],t[2]-1,t[3]});\\n                i++;\\n            }\\n            else if(t[2]<vc[i][2]){\\n                vc[i][2]--;\\n            }\\n            else {\\n                  i++;\\n              }\\n        }\\n        }\\n        else \\n        {\\n            if(vc[i][3]==0){\\n                temp.push_back({vc[i][1],vc[i][2]});\\n            }\\n            else st.push(vc[i]);\\n            i++;\\n        }\\n    }\\n        \\n        \\n        while(!st.empty()){\\n            vector<int>ss=st.top();\\n            st.pop();\\n            temp.push_back({ss[1],ss[2]});\\n        }\\n     sort(temp.begin(),temp.end());\\n        vector<int>ans;\\n        for(int i=0;i<temp.size();i++) ans.push_back(temp[i].second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688647,
                "title": "simple-c-code-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define pb push_back\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string s) {\\n        vector<pair<int,pair<int,char>>> v;\\n        int n=positions.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.pb({positions[i],{healths[i],s[i]}});\\n        }\\n        sort(v.begin(),v.end());\\n stack<pair<int,pair<int,char>>> st;\\n for(int i=0;i<n;i++)\\n {\\n     if(st.empty())\\n     st.push({v[i].first,{v[i].second.first,v[i].second.second}});\\n     else if(st.top().second.second==\\'R\\' && v[i].second.second==\\'L\\')\\n     {\\n         int h=v[i].second.first;\\n        while(!st.empty() && st.top().second.second==\\'R\\' && st.top().second.first<h)\\n        {\\n           st.pop();\\n           h--;\\n        }\\n        if(st.empty())\\n        {\\n            st.push({v[i].first,{h,v[i].second.second}});\\n        }\\n        else if(st.top().second.second==\\'L\\')\\n        {\\n            st.push({v[i].first,{h,v[i].second.second}});\\n        }\\n        else if(st.top().second.first==h)\\n        {\\n         st.pop();\\n        }\\n        else\\n        {\\n            int p=st.top().first;\\n         int x=st.top().second.first;\\n         st.pop();\\n         x--;\\n         st.push({p,{x,\\'R\\'}});\\n        }\\n     }\\n     else\\n     {\\n       st.push({v[i].first,{v[i].second.first,v[i].second.second}});  \\n     }\\n }\\n vector<int> ans;\\n map<int,int> mp;\\n while(!st.empty())\\n {\\n     mp[st.top().first]=st.top().second.first;\\n     st.pop();\\n }\\n for(int i=0;i<n;i++)\\n {\\n     if(mp[positions[i]])\\n     ans.pb(mp[positions[i]]);\\n }\\n return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define pb push_back\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string s) {\\n        vector<pair<int,pair<int,char>>> v;\\n        int n=positions.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.pb({positions[i],{healths[i],s[i]}});\\n        }\\n        sort(v.begin(),v.end());\\n stack<pair<int,pair<int,char>>> st;\\n for(int i=0;i<n;i++)\\n {\\n     if(st.empty())\\n     st.push({v[i].first,{v[i].second.first,v[i].second.second}});\\n     else if(st.top().second.second==\\'R\\' && v[i].second.second==\\'L\\')\\n     {\\n         int h=v[i].second.first;\\n        while(!st.empty() && st.top().second.second==\\'R\\' && st.top().second.first<h)\\n        {\\n           st.pop();\\n           h--;\\n        }\\n        if(st.empty())\\n        {\\n            st.push({v[i].first,{h,v[i].second.second}});\\n        }\\n        else if(st.top().second.second==\\'L\\')\\n        {\\n            st.push({v[i].first,{h,v[i].second.second}});\\n        }\\n        else if(st.top().second.first==h)\\n        {\\n         st.pop();\\n        }\\n        else\\n        {\\n            int p=st.top().first;\\n         int x=st.top().second.first;\\n         st.pop();\\n         x--;\\n         st.push({p,{x,\\'R\\'}});\\n        }\\n     }\\n     else\\n     {\\n       st.push({v[i].first,{v[i].second.first,v[i].second.second}});  \\n     }\\n }\\n vector<int> ans;\\n map<int,int> mp;\\n while(!st.empty())\\n {\\n     mp[st.top().first]=st.top().second.first;\\n     st.pop();\\n }\\n for(int i=0;i<n;i++)\\n {\\n     if(mp[positions[i]])\\n     ans.pb(mp[positions[i]]);\\n }\\n return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688429,
                "title": "scala-recursion",
                "content": "# Code\\n```\\nobject Solution {\\n  \\n  case class Robot(pos: Int, health: Int, isRight: Boolean, index: Int)\\n\\n  def survivedRobotsHealths(positions: Array[Int], healths: Array[Int], directions: String): List[Int] = {\\n    val raw = positions.zip(healths).zip(directions).zipWithIndex\\n    val robots = raw.map { case (((pos, h), dir), ind) => Robot(pos, h, dir == \\'R\\', ind) }\\n    go(robots.sortBy(_.pos).toList, List.empty, List.empty).sortBy(_.index).map(_.health)\\n  }\\n\\n  def go(robots: List[Robot], goRight: List[Robot], goLeft: List[Robot]): List[Robot] =\\n    robots match {\\n      case Nil => (goLeft ++ goRight)\\n      case robot :: tail =>\\n        if (robot.isRight) go(tail, robot :: goRight, goLeft)\\n        else {\\n          val (nRight, nLeft) = collide(goRight, robot)\\n          go(tail, nRight, List.from(nLeft) ::: goLeft)\\n        }\\n    }\\n\\n  def collide(goRight: List[Robot], robot: Robot): (List[Robot], Option[Robot]) =\\n    goRight match {\\n      case Nil => (Nil, Some(robot))\\n      case other :: tail =>\\n        if (other.health < robot.health) collide(tail, robot.copy(health = robot.health - 1))\\n        else if (other.health == robot.health) (tail, None)\\n        else (other.copy(health = other.health - 1) :: tail, None)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  \\n  case class Robot(pos: Int, health: Int, isRight: Boolean, index: Int)\\n\\n  def survivedRobotsHealths(positions: Array[Int], healths: Array[Int], directions: String): List[Int] = {\\n    val raw = positions.zip(healths).zip(directions).zipWithIndex\\n    val robots = raw.map { case (((pos, h), dir), ind) => Robot(pos, h, dir == \\'R\\', ind) }\\n    go(robots.sortBy(_.pos).toList, List.empty, List.empty).sortBy(_.index).map(_.health)\\n  }\\n\\n  def go(robots: List[Robot], goRight: List[Robot], goLeft: List[Robot]): List[Robot] =\\n    robots match {\\n      case Nil => (goLeft ++ goRight)\\n      case robot :: tail =>\\n        if (robot.isRight) go(tail, robot :: goRight, goLeft)\\n        else {\\n          val (nRight, nLeft) = collide(goRight, robot)\\n          go(tail, nRight, List.from(nLeft) ::: goLeft)\\n        }\\n    }\\n\\n  def collide(goRight: List[Robot], robot: Robot): (List[Robot], Option[Robot]) =\\n    goRight match {\\n      case Nil => (Nil, Some(robot))\\n      case other :: tail =>\\n        if (other.health < robot.health) collide(tail, robot.copy(health = robot.health - 1))\\n        else if (other.health == robot.health) (tail, None)\\n        else (other.copy(health = other.health - 1) :: tail, None)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688278,
                "title": "c-simple-intuition",
                "content": "\\n# Simple approach C++\\n# Intuition\\n\\n**We will not try to simulate the actual collisions**\\nThus in our entire approach we will not change positions of robots rather we only care about the final health of robots remaining.\\n\\nCollision criteria :  -> <-\\n\\nso there will be collision if and only if a two robots adjacent to each other are facing each other , with the robot on the left side going RIGHT and robot on the right going LEFT\\n\\n\\n# Approach\\nI have used a map<int,int> storing position and index of the robot to have positions in sorted order also the index will help us return the health of remaining robots in the order in which it was given\\n\\nUse a stack to store the positions of robots that are supposed to not collide till now \\nfor example :\\n-> -> -> ->   Has no robots collisions\\n<- <- <- <-   No collions\\n<- <- -> ->   Still has no robots collions\\n \\nif next robot is <- (lets call him rex)\\nthen in the first case this robot will collide with the topmost robot in the stack and if rex has greater health we pop the topmost robot in the stack and so on\\n\\nIn second case there is no collison and rex is simply pushed into the stack .\\n\\nAfter checking for all robots in order of their position the stack will have the last standing robots . \\n\\n# Complexity\\nWE are taking extra space $$O(n)$$ to store the positions in map\\ntime complexity is $$O(nlogn)$$\\nI think its similar to sorting , because we are using a map to get all positions in sorted order.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& hel, string dir) {\\n        int n = pos.size();\\n        map<int,int> rob;\\n        for(int i= 0;i<n; i++){\\n            rob[pos[i]] = i;\\n        }\\n        stack<int> st;\\n        for(auto r:rob){\\n            int posi = r.first;\\n            int ind = r.second;\\n            if(st.empty() || dir[ind]==\\'R\\'){\\n                st.push(posi);\\n            }\\n            else{\\n                int flag = 1;// meaning push posi into stack\\n                while(!st.empty()){\\n                    int tp = st.top();\\n                    int ti = rob[tp];\\n                    if(dir[ti]==\\'L\\')\\n                        break;\\n                    if(hel[ti]>hel[ind]){\\n                        flag = 0;\\n                        hel[ti]--;\\n                        break;\\n                    }\\n                    else if(hel[ti]==hel[ind]){\\n                        flag = 0;\\n                        st.pop();\\n                        break;\\n                    }\\n                    else{\\n                        st.pop();\\n                        hel[ind]--;\\n                    }\\n                }\\n                if(flag==1)\\n                    st.push(posi);\\n            }\\n        }\\n        set<int> indexes;\\n        while(st.size()){\\n            indexes.insert(rob[st.top()]);\\n            st.pop();\\n        }\\n        vector<int> ans;\\n        for(auto i:indexes)\\n            ans.push_back(hel[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& hel, string dir) {\\n        int n = pos.size();\\n        map<int,int> rob;\\n        for(int i= 0;i<n; i++){\\n            rob[pos[i]] = i;\\n        }\\n        stack<int> st;\\n        for(auto r:rob){\\n            int posi = r.first;\\n            int ind = r.second;\\n            if(st.empty() || dir[ind]==\\'R\\'){\\n                st.push(posi);\\n            }\\n            else{\\n                int flag = 1;// meaning push posi into stack\\n                while(!st.empty()){\\n                    int tp = st.top();\\n                    int ti = rob[tp];\\n                    if(dir[ti]==\\'L\\')\\n                        break;\\n                    if(hel[ti]>hel[ind]){\\n                        flag = 0;\\n                        hel[ti]--;\\n                        break;\\n                    }\\n                    else if(hel[ti]==hel[ind]){\\n                        flag = 0;\\n                        st.pop();\\n                        break;\\n                    }\\n                    else{\\n                        st.pop();\\n                        hel[ind]--;\\n                    }\\n                }\\n                if(flag==1)\\n                    st.push(posi);\\n            }\\n        }\\n        set<int> indexes;\\n        while(st.size()){\\n            indexes.insert(rob[st.top()]);\\n            st.pop();\\n        }\\n        vector<int> ans;\\n        for(auto i:indexes)\\n            ans.push_back(hel[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688030,
                "title": "simple-stack-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        \\n        vector<int> indexes;\\n        for(int i = 0; i < n; i++)\\n            indexes.push_back(i);\\n        \\n        sort(indexes.begin(), indexes.end(), [&](int a, int b) {\\n            return positions[a] < positions[b];\\n        });\\n\\n        stack<int> s;\\n        for(int i = 0; i < n; i++) {\\n            int ind = indexes[i];\\n            char d = directions[ind];\\n\\n            if(d == \\'L\\') {\\n                if(s.empty())\\n                    s.push(ind);\\n                else {\\n\\n                    if(!s.empty() and directions[s.top()] == \\'R\\' and healths[s.top()] == healths[ind]) {\\n                        healths[s.top()] = 0;\\n                        healths[ind] = 0;\\n                        s.pop();\\n                    } \\n                    \\n                    else {\\n                        while(!s.empty() and directions[s.top()] == \\'R\\' and healths[s.top()] < healths[ind]) {\\n                            healths[s.top()] = 0;\\n                            healths[ind]--;\\n                            s.pop();\\n                        }\\n\\n                        if(!s.empty() and directions[s.top()] == \\'R\\' and healths[s.top()] > healths[ind]) {\\n                            healths[s.top()]--;\\n                            healths[ind] = 0;\\n                        }\\n\\n                        else if(!s.empty() and directions[s.top()] == \\'R\\' and healths[s.top()] == healths[ind]) { // suppose heatlhs are equal\\n                            healths[s.top()] = 0;\\n                            healths[ind] = 0;\\n                            s.pop();\\n                        }\\n                    }\\n                }\\n            } else\\n                s.push(ind);\\n        }\\n\\n        vector<int> ans;\\n        for(auto h: healths)\\n            if(h != 0) \\n                ans.push_back(h);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        \\n        vector<int> indexes;\\n        for(int i = 0; i < n; i++)\\n            indexes.push_back(i);\\n        \\n        sort(indexes.begin(), indexes.end(), [&](int a, int b) {\\n            return positions[a] < positions[b];\\n        });\\n\\n        stack<int> s;\\n        for(int i = 0; i < n; i++) {\\n            int ind = indexes[i];\\n            char d = directions[ind];\\n\\n            if(d == \\'L\\') {\\n                if(s.empty())\\n                    s.push(ind);\\n                else {\\n\\n                    if(!s.empty() and directions[s.top()] == \\'R\\' and healths[s.top()] == healths[ind]) {\\n                        healths[s.top()] = 0;\\n                        healths[ind] = 0;\\n                        s.pop();\\n                    } \\n                    \\n                    else {\\n                        while(!s.empty() and directions[s.top()] == \\'R\\' and healths[s.top()] < healths[ind]) {\\n                            healths[s.top()] = 0;\\n                            healths[ind]--;\\n                            s.pop();\\n                        }\\n\\n                        if(!s.empty() and directions[s.top()] == \\'R\\' and healths[s.top()] > healths[ind]) {\\n                            healths[s.top()]--;\\n                            healths[ind] = 0;\\n                        }\\n\\n                        else if(!s.empty() and directions[s.top()] == \\'R\\' and healths[s.top()] == healths[ind]) { // suppose heatlhs are equal\\n                            healths[s.top()] = 0;\\n                            healths[ind] = 0;\\n                            s.pop();\\n                        }\\n                    }\\n                }\\n            } else\\n                s.push(ind);\\n        }\\n\\n        vector<int> ans;\\n        for(auto h: healths)\\n            if(h != 0) \\n                ans.push_back(h);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687999,
                "title": "simple-simulation-java",
                "content": "# Intuition\\nSimulation\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimulation of collisions using sorting and stack.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Integer> res = new ArrayList<>();\\n        Stack<int[]> st = new Stack<>();\\n        int n = healths.length;\\n        int arr[][] = new int[n][4];\\n        for(int i = 0; i < n ; i++){\\n            arr[i][0] = positions[i];\\n            arr[i][1] = healths[i];\\n            if(directions.charAt(i) == \\'R\\') arr[i][2] = 1;\\n            arr[i][3] = i;\\n        }\\n        Arrays.sort(arr,(a,b)->{return a[0] - b[0];});\\n        List<int[]> bots = new ArrayList<>();\\n        for(int i = 0; i < n ; i++){\\n            if(arr[i][2] == 1){\\n                st.push(new int[]{arr[i][1],arr[i][3]});\\n            }\\n            else{\\n                int val = arr[i][1];\\n                while(!st.isEmpty() && val > 0){\\n                    int temp[] = st.pop();\\n                    if(val > temp[0]){\\n                        val--;\\n                    }\\n                    else if(val == temp[0]){\\n                        val = 0;\\n                    }\\n                    else{\\n                        temp[0] --;\\n                        val = 0;\\n                        st.push(temp);\\n                    }\\n                }\\n                if(val > 0) bots.add(new int[]{val,arr[i][3]});\\n            }\\n        }\\n        for(int a[]:st) bots.add(a);\\n        Collections.sort(bots,(a,b)->{return a[1]-b[1];});\\n        for(int a[]:bots) res.add(a[0]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Integer> res = new ArrayList<>();\\n        Stack<int[]> st = new Stack<>();\\n        int n = healths.length;\\n        int arr[][] = new int[n][4];\\n        for(int i = 0; i < n ; i++){\\n            arr[i][0] = positions[i];\\n            arr[i][1] = healths[i];\\n            if(directions.charAt(i) == \\'R\\') arr[i][2] = 1;\\n            arr[i][3] = i;\\n        }\\n        Arrays.sort(arr,(a,b)->{return a[0] - b[0];});\\n        List<int[]> bots = new ArrayList<>();\\n        for(int i = 0; i < n ; i++){\\n            if(arr[i][2] == 1){\\n                st.push(new int[]{arr[i][1],arr[i][3]});\\n            }\\n            else{\\n                int val = arr[i][1];\\n                while(!st.isEmpty() && val > 0){\\n                    int temp[] = st.pop();\\n                    if(val > temp[0]){\\n                        val--;\\n                    }\\n                    else if(val == temp[0]){\\n                        val = 0;\\n                    }\\n                    else{\\n                        temp[0] --;\\n                        val = 0;\\n                        st.push(temp);\\n                    }\\n                }\\n                if(val > 0) bots.add(new int[]{val,arr[i][3]});\\n            }\\n        }\\n        for(int a[]:st) bots.add(a);\\n        Collections.sort(bots,(a,b)->{return a[1]-b[1];});\\n        for(int a[]:bots) res.add(a[0]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687734,
                "title": "c-solution-using-stack",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsort the indices vector based on positions and traverse the index array.\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& h, string directions) {\\n        int n = positions.size();\\n        vector<int> ind(n), res;\\n        stack<int>st;\\n        for (int i = 0; i < n; i++)\\n            ind[i] = i;\\n        sort(ind.begin(), ind.end(), [&](int a, int b) {\\n            return positions[a] < positions[b];\\n        });\\n        for (int i : ind) {\\n            if(directions[i]==\\'R\\'){\\n                st.push(i);\\n            }\\n            else if(st.empty()&& directions[i]==\\'L\\'){\\n                continue;\\n            }\\n            else{\\n                while(!st.empty()){\\n                    int p=st.top();\\n                    st.pop();\\n                    if(h[i]==h[p]){\\n                        h[i]=0;\\n                        h[p]=0;\\n                        break;\\n                    }\\n                    else if(h[i]>h[p]){\\n                        h[p]=0;\\n                        h[i]-=1;\\n                    }\\n                    else{\\n                        h[p]-=1;\\n                        h[i]=0;\\n                        st.push(p);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        for (int v : h) {\\n            if (v > 0) {\\n                res.push_back(v);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& h, string directions) {\\n        int n = positions.size();\\n        vector<int> ind(n), res;\\n        stack<int>st;\\n        for (int i = 0; i < n; i++)\\n            ind[i] = i;\\n        sort(ind.begin(), ind.end(), [&](int a, int b) {\\n            return positions[a] < positions[b];\\n        });\\n        for (int i : ind) {\\n            if(directions[i]==\\'R\\'){\\n                st.push(i);\\n            }\\n            else if(st.empty()&& directions[i]==\\'L\\'){\\n                continue;\\n            }\\n            else{\\n                while(!st.empty()){\\n                    int p=st.top();\\n                    st.pop();\\n                    if(h[i]==h[p]){\\n                        h[i]=0;\\n                        h[p]=0;\\n                        break;\\n                    }\\n                    else if(h[i]>h[p]){\\n                        h[p]=0;\\n                        h[i]-=1;\\n                    }\\n                    else{\\n                        h[p]-=1;\\n                        h[i]=0;\\n                        st.push(p);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        for (int v : h) {\\n            if (v > 0) {\\n                res.push_back(v);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687634,
                "title": "detail-expanation-with-image-solution-stack-c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/6873f71a-1a33-4441-b396-8cfbbb772155_1687845618.792059.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/767ce017-fce7-41b2-9ad7-1c9351d95892_1687845000.786946.jpeg)\\n\\n\\n\\n\\nclass Solution {\\n\\npublic:\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n\\n        const int n = positions.size();\\n\\n        vector<int> ind(n);\\n\\n        for (int i = 0; i < n; ++i) {\\n\\n            ind[i] = i;\\n\\n        }\\n\\n        sort(ind.begin(), ind.end(), [&](const int x, const int y) {\\n\\n            return positions[x] < positions[y];\\n\\n        });\\n\\n        stack<int> s;\\n\\n        for (int x : ind) {\\n\\n            if (directions[x] == \\'L\\') {\\n\\n                while (!s.empty()) {\\n\\n                    const int y = s.top();\\n\\n                    if (healths[x] == healths[y]) {\\n\\n                        healths[x] = healths[y] = 0;\\n\\n                        s.pop();\\n\\n                        break;\\n\\n                    }\\n\\n                    if (healths[x] > healths[y]) {\\n\\n                        --healths[x];\\n\\n                        healths[y] = 0;\\n\\n                        s.pop();\\n\\n                    } else {\\n\\n                        healths[x] = 0;\\n\\n                        --healths[y];\\n\\n                        break;\\n\\n                    }\\n\\n                }  \\n\\n            } else {\\n\\n                s.push(x);\\n\\n            }\\n\\n        }\\n\\n        vector<int> r;\\n\\n        for (int x : healths) {\\n\\n            if (x) {\\n\\n                r.push_back(x);\\n\\n            }\\n\\n        }\\n\\n        return r;\\n\\n    }\\n\\n};\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n\\n        const int n = positions.size();\\n\\n        vector<int> ind(n);\\n\\n        for (int i = 0; i < n; ++i) {\\n\\n            ind[i] = i;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3687534,
                "title": "python-runtime-o-nlog-n-memory-o-n",
                "content": "Idea inspired here - https://leetcode.com/problems/robot-collisions/solutions/3679112/cpp-sorting-stack/\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        N = len(positions)\\n        newPositions = []\\n        for i in range(N):\\n            newPositions.append((positions[i], i))\\n        newPositions.sort()\\n        stack = []\\n        survived = []\\n        for p, i in newPositions:\\n            if directions[i] == \\'R\\':\\n                stack.append(i)\\n            else:\\n                rightRobot = i\\n                while stack:\\n                    leftRobot = stack.pop()\\n                    if healths[leftRobot] < healths[rightRobot]:\\n                        healths[rightRobot] -= 1\\n                        healths[leftRobot] = 0\\n                    elif healths[leftRobot] == healths[rightRobot]:\\n                        healths[rightRobot] = 0\\n                        healths[leftRobot] = 0\\n                    else:\\n                        stack.append(leftRobot)\\n                        healths[rightRobot] = 0\\n                        healths[leftRobot] -= 1\\n                    if healths[rightRobot] == 0:\\n                        break\\n                if healths[rightRobot]:\\n                    survived.append(rightRobot)\\n        for i in stack:\\n            survived.append(i)\\n        survived.sort()\\n        return [healths[i] for i in survived]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        N = len(positions)\\n        newPositions = []\\n        for i in range(N):\\n            newPositions.append((positions[i], i))\\n        newPositions.sort()\\n        stack = []\\n        survived = []\\n        for p, i in newPositions:\\n            if directions[i] == \\'R\\':\\n                stack.append(i)\\n            else:\\n                rightRobot = i\\n                while stack:\\n                    leftRobot = stack.pop()\\n                    if healths[leftRobot] < healths[rightRobot]:\\n                        healths[rightRobot] -= 1\\n                        healths[leftRobot] = 0\\n                    elif healths[leftRobot] == healths[rightRobot]:\\n                        healths[rightRobot] = 0\\n                        healths[leftRobot] = 0\\n                    else:\\n                        stack.append(leftRobot)\\n                        healths[rightRobot] = 0\\n                        healths[leftRobot] -= 1\\n                    if healths[rightRobot] == 0:\\n                        break\\n                if healths[rightRobot]:\\n                    survived.append(rightRobot)\\n        for i in stack:\\n            survived.append(i)\\n        survived.sort()\\n        return [healths[i] for i in survived]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686797,
                "title": "javascript-asteroid-collision-extension-567ms",
                "content": "prerequisite: https://leetcode.com/problems/asteroid-collision/\\n```\\nconst survivedRobotsHealths = (p, h, d) => {\\n    let m = {}, res = Array(p.length).fill(0);\\n    p.map((x, i) => m[x] = d[i] == \\'R\\' ? [h[i], i] : [-h[i], i]);\\n    let a = [];\\n    for (const k in m) a.push(m[k])\\n    let v = asteroidCollision(a);\\n    for (const [x, i] of v) res[i] = Math.abs(x);\\n    return res.filter(x => x != 0);\\n};\\n\\n/*\\nmodified code from\\nhttps://leetcode.com/problems/asteroid-collision/solutions/1136947/javascript-stack-88ms-90.34\\n*/\\nconst asteroidCollision = (a) => {\\n    let st = [];\\n    for (const [x, i] of a) {\\n        st.push([x, i]);\\n        let l, li, sl, sli;\\n        if (st.length >= 1) [l, li] = st[st.length - 1];\\n        if (st.length >= 2) [sl, sli] = st[st.length - 2];\\n        while (st.length >= 2 && l < 0 && sl > 0) {\\n            st.pop();\\n            st.pop();\\n            let add, idx;\\n            if (-l > sl) {\\n                add = -(-l - 1);\\n                idx = li;\\n            } else if (-l < sl) {\\n                add = sl - 1;\\n                idx = sli;\\n            }\\n            if (add) st.push([add, idx]);\\n            if (st.length >= 1) [l, li] = st[st.length - 1];\\n            if (st.length >= 2) [sl, sli] = st[st.length - 2];\\n        }\\n    }\\n    return st;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nconst survivedRobotsHealths = (p, h, d) => {\\n    let m = {}, res = Array(p.length).fill(0);\\n    p.map((x, i) => m[x] = d[i] == \\'R\\' ? [h[i], i] : [-h[i], i]);\\n    let a = [];\\n    for (const k in m) a.push(m[k])\\n    let v = asteroidCollision(a);\\n    for (const [x, i] of v) res[i] = Math.abs(x);\\n    return res.filter(x => x != 0);\\n};\\n\\n/*\\nmodified code from\\nhttps://leetcode.com/problems/asteroid-collision/solutions/1136947/javascript-stack-88ms-90.34\\n*/\\nconst asteroidCollision = (a) => {\\n    let st = [];\\n    for (const [x, i] of a) {\\n        st.push([x, i]);\\n        let l, li, sl, sli;\\n        if (st.length >= 1) [l, li] = st[st.length - 1];\\n        if (st.length >= 2) [sl, sli] = st[st.length - 2];\\n        while (st.length >= 2 && l < 0 && sl > 0) {\\n            st.pop();\\n            st.pop();\\n            let add, idx;\\n            if (-l > sl) {\\n                add = -(-l - 1);\\n                idx = li;\\n            } else if (-l < sl) {\\n                add = sl - 1;\\n                idx = sli;\\n            }\\n            if (add) st.push([add, idx]);\\n            if (st.length >= 1) [l, li] = st[st.length - 1];\\n            if (st.length >= 2) [sl, sli] = st[st.length - 2];\\n        }\\n    }\\n    return st;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3686337,
                "title": "java-python-c-beats-100-o-n-stack-simple-beginners",
                "content": "# Intuition \\u2728\\uD83D\\uDD0D\\nAh, we have an interesting problem here: finding the health of the surviving robots after collisions. Let\\'s gear up and solve it together with some \\uD83E\\uDD16 power! \\uD83D\\uDCAA\\uD83D\\uDCA5\\n\\n# Approach \\uD83D\\uDE80\\uD83D\\uDCA1\\n1\\uFE0F\\u20E3 **Creating a Robot Brigade**: We\\'ll start by creating an empty stack to form our brigade of robots moving to the right (R). \\uD83E\\uDD16\\uD83D\\uDD3D\\n\\n2\\uFE0F\\u20E3 **Sorting the Marching Order**: To ensure orderly collisions, we\\'ll sort the indices of the robots based on their positions in ascending order. Now, they\\'ll march in synchronized harmony. \\uD83D\\uDEB6\\u200D\\u2642\\uFE0F\\uD83D\\uDEB6\\u200D\\u2640\\uFE0F\\uD83D\\uDD04\\n\\n3\\uFE0F\\u20E3 **Simulating Collisions**: As the robots march forward, we\\'ll iterate through the sorted indices. If a robot is moving to the left (L) and the stack is empty, we\\'ll let it continue its peaceful journey. However, if it\\'s moving to the right (R), we\\'ll welcome it to our brigade by adding its index to the stack. \\uD83E\\uDD16\\uD83D\\uDD00\\uD83D\\uDD01\\n\\n4\\uFE0F\\u20E3 **Collision Resolution**: When a robot moving to the left (L) encounters a robot moving to the right (R), a collision occurs! \\uD83D\\uDCA5 We\\'ll handle the collision by comparing the health of the two robots:\\n   - If the robot moving to the right (R) has higher health, we\\'ll decrease its health by 1 and set the health of the robot moving to the left (L) to 0. The weaker robot falls, while the stronger one marches on. \\uD83D\\uDCAA\\uD83D\\uDC94\\n   - If both robots have the same health, they both fall in an honorable clash, and we set their health to 0. Farewell, brave warriors. \\u2694\\uFE0F\\uD83D\\uDC94\\n   - If the robot moving to the left (L) has higher health, we\\'ll decrease its health by 1 and set the health of the robot moving to the right (R) to 0. The leftward robot triumphs, while the rightward one is vanquished. \\uD83D\\uDCAA\\uD83D\\uDC94\\n\\n5\\uFE0F\\u20E3 **Saluting the Survivors**: Once the march and collisions are over, we\\'ll gather the health values of the surviving robots (health > 0) and present them as the triumphant survivors of the battle. \\uD83C\\uDFE5\\u2705\\n\\n# Complexity Analysis \\uD83D\\uDCCA\\n- Time complexity: O(nlogn), where n is the number of robots. The sorting operation takes O(nlogn) time, and the iteration through the indices takes O(n) time.\\n- Space complexity: O(n), as we use a stack to store the indices of robots moving to the right.\\n\\n# Let the Battle Begin! \\u2694\\uFE0F\\uD83D\\uDCA5\\n# Java\\n```java\\nclass Solution {\\n    static Stack<Integer> s = new Stack<>();\\n\\n    private static void performOperations(int[] healths, int i) {\\n        while(s.isEmpty()){\\n        int t = s.peek();\\n            s.pop();\\n        if (healths[t] > healths[i]) {\\n            healths[t] -= 1;\\n            healths[i] = 0;\\n            s.push(t);\\n            return;\\n        } else if (healths[t] == healths[i]) {\\n            healths[t] = 0;\\n            healths[i] = 0;\\n            return;\\n        } else {\\n            healths[i] -= 1;\\n            healths[t] = 0;\\n        }\\n        }\\n    }\\n\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String dir) {\\n        Integer\\n\\n[] indices = IntStream.range(0, positions.length).boxed().toArray(Integer[]::new);\\n        Arrays.sort(indices, Comparator.comparingInt(a -> positions[a]));\\n\\n        for (Integer i : indices) {\\n            if (dir.charAt(i) == \\'R\\') {\\n                s.push(i);\\n            } else {\\n                if (s.isEmpty())\\n                    continue;\\n                performOperations(healths, i);\\n            }\\n        }\\n\\n        List<Integer> survivors = new ArrayList<>();\\n        for (int i = 0; i < healths.length; i++) {\\n            if (healths[i] > 0) {\\n                survivors.add(healths[i]);\\n            }\\n        }\\n        return survivors;\\n    }\\n}\\n```\\n## Python\\n```python\\nclass Solution:\\n    def survivedRobotsHealths(self, positions, healths, directions):\\n        stack = []\\n        \\n        def performOperations(healths, i):\\n            while stack:\\n                t = stack[-1]\\n                stack.pop()\\n                if healths[t] > healths[i]:\\n                    healths[t] -= 1\\n                    healths[i] = 0\\n                    stack.append(t)\\n                    return\\n                elif healths[t] == healths[i]:\\n                    healths[t] = 0\\n                    healths[i] = 0\\n                    return\\n                else:\\n                    healths[i] -= 1\\n                    healths[t] = 0\\n        \\n        indices = sorted(range(len(positions)), key=lambda x: positions[x])\\n        \\n        for i in indices:\\n            if directions[i] == \\'R\\':\\n                stack.append(i)\\n            else:\\n                if not stack:\\n                    continue\\n                performOperations(healths, i)\\n        \\n        survivors = [health for health in healths if health > 0]\\n        return survivors\\n```\\n\\n## C++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        stack<int> s;\\n        \\n        auto performOperations = [&](vector<int>& healths, int i) {\\n            while (!s.empty()) {\\n                int t = s.top();\\n                s.pop();\\n                if (healths[t] > healths[i]) {\\n                    healths[t] -= 1;\\n                    healths[i] = 0;\\n                    s.push(t);\\n                    return;\\n                } else if (healths[t] == healths[i]) {\\n                    healths[t] = 0;\\n                    healths[i] = 0;\\n                    return;\\n                } else {\\n                    healths[i] -= 1;\\n                    healths[t] = 0;\\n                }\\n            }\\n        };\\n        \\n        vector<int> indices(positions.size());\\n        iota(indices.begin(), indices.end(), 0);\\n        sort(indices.begin(), indices.end(), [&](int a, int b) { return positions[a] < positions[b]; });\\n        \\n        for (int i : indices) {\\n            if (directions[i] == \\'R\\') {\\n                s.push(i);\\n            } else {\\n                if (s.empty())\\n                    continue;\\n                performOperations(healths, i);\\n            }\\n        }\\n        \\n        vector<int> survivors;\\n        for (int health : healths) {\\n            if (health > 0) {\\n                survivors.push_back(health);\\n            }\\n        }\\n        return survivors;\\n    }\\n};\\n```\\n\\n\\nLet me know if there\\'s anything else I can help you with!\\n\\nif you found this answer helpful please upvote it.",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\nclass Solution {\\n    static Stack<Integer> s = new Stack<>();\\n\\n    private static void performOperations(int[] healths, int i) {\\n        while(s.isEmpty()){\\n        int t = s.peek();\\n            s.pop();\\n        if (healths[t] > healths[i]) {\\n            healths[t] -= 1;\\n            healths[i] = 0;\\n            s.push(t);\\n            return;\\n        } else if (healths[t] == healths[i]) {\\n            healths[t] = 0;\\n            healths[i] = 0;\\n            return;\\n        } else {\\n            healths[i] -= 1;\\n            healths[t] = 0;\\n        }\\n        }\\n    }\\n\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String dir) {\\n        Integer\\n\\n[] indices = IntStream.range(0, positions.length).boxed().toArray(Integer[]::new);\\n        Arrays.sort(indices, Comparator.comparingInt(a -> positions[a]));\\n\\n        for (Integer i : indices) {\\n            if (dir.charAt(i) == \\'R\\') {\\n                s.push(i);\\n            } else {\\n                if (s.isEmpty())\\n                    continue;\\n                performOperations(healths, i);\\n            }\\n        }\\n\\n        List<Integer> survivors = new ArrayList<>();\\n        for (int i = 0; i < healths.length; i++) {\\n            if (healths[i] > 0) {\\n                survivors.add(healths[i]);\\n            }\\n        }\\n        return survivors;\\n    }\\n}\\n```\n```python\\nclass Solution:\\n    def survivedRobotsHealths(self, positions, healths, directions):\\n        stack = []\\n        \\n        def performOperations(healths, i):\\n            while stack:\\n                t = stack[-1]\\n                stack.pop()\\n                if healths[t] > healths[i]:\\n                    healths[t] -= 1\\n                    healths[i] = 0\\n                    stack.append(t)\\n                    return\\n                elif healths[t] == healths[i]:\\n                    healths[t] = 0\\n                    healths[i] = 0\\n                    return\\n                else:\\n                    healths[i] -= 1\\n                    healths[t] = 0\\n        \\n        indices = sorted(range(len(positions)), key=lambda x: positions[x])\\n        \\n        for i in indices:\\n            if directions[i] == \\'R\\':\\n                stack.append(i)\\n            else:\\n                if not stack:\\n                    continue\\n                performOperations(healths, i)\\n        \\n        survivors = [health for health in healths if health > 0]\\n        return survivors\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        stack<int> s;\\n        \\n        auto performOperations = [&](vector<int>& healths, int i) {\\n            while (!s.empty()) {\\n                int t = s.top();\\n                s.pop();\\n                if (healths[t] > healths[i]) {\\n                    healths[t] -= 1;\\n                    healths[i] = 0;\\n                    s.push(t);\\n                    return;\\n                } else if (healths[t] == healths[i]) {\\n                    healths[t] = 0;\\n                    healths[i] = 0;\\n                    return;\\n                } else {\\n                    healths[i] -= 1;\\n                    healths[t] = 0;\\n                }\\n            }\\n        };\\n        \\n        vector<int> indices(positions.size());\\n        iota(indices.begin(), indices.end(), 0);\\n        sort(indices.begin(), indices.end(), [&](int a, int b) { return positions[a] < positions[b]; });\\n        \\n        for (int i : indices) {\\n            if (directions[i] == \\'R\\') {\\n                s.push(i);\\n            } else {\\n                if (s.empty())\\n                    continue;\\n                performOperations(healths, i);\\n            }\\n        }\\n        \\n        vector<int> survivors;\\n        for (int health : healths) {\\n            if (health > 0) {\\n                survivors.push_back(health);\\n            }\\n        }\\n        return survivors;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686044,
                "title": "java-optimal-solution-o-nlogn-n-beats-best-explanation-you-could-get-stack",
                "content": "# Intuition\\nThought of starting this solution by first sorting the robots by position, So as to get them collide if the travel towards each other.\\n\\n# Approach\\nTraversing from left to right, maintain a Stack containing index of the robots information, if we encounter right going robot add to the STACK, if we encounter left going robot check if there are any right going robots in the stack to collide with, while stack is empty check the collision.\\n\\n**USING STACK AS THE LEFT GOING ROBOT WILL COLLIDE WITH THE MOST RECENT RIGHT GOING ROBOT FOUND**\\n\\n****CASE 1:** Left going Robot\\'s health >  Right going Robot\\'s health:**\\n            POP the Right going robot from the stack \\n            Change its health to 0\\n            Decrease health of Left going robot\\'s health by 1\\n\\n****CASE 2:** Right going Robot\\'s health > Left going Robot\\'s health:**\\n            DONT POP the robot as it can collide with more left going robots\\n            Change left going robot\\'s health to 0\\n            Decrease health of Right going robot\\'s health by 1\\n\\n****CASE 3:** Left going Robot\\'s health ==  Right going Robot\\'s health:**\\n            POP the Right going robot from the stack as it is removed\\n            Change right going robot\\'s health to 0\\n            Change left going robot\\'s health to 0\\n\\n\\n\\n# Complexity \\n- Time complexity: **O(nLogn + n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# PLEASE UPVOTE FOR 100 YEARS OF GOOD LUCK !!!\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Integer> res=new ArrayList();     //final ans\\n        char[] dir=directions.toCharArray();   //to fetch direction char\\n        int n=positions.length;\\n        int[][] rob=new int[n][3];             //to store index , direction and position of the robot\\n        for(int i=0;i<n;i++){\\n            rob[i][0]=i;                      //index to fetch info\\n            rob[i][1]=dir[i]==\\'R\\'?1:0;        //1 for Right 0 for left\\n            rob[i][2]=positions[i];           //position to sort\\n        }\\n        Arrays.sort(rob,(a,b)->a[2]-b[2]);   //sort according to position\\n        Stack<Integer> st=new Stack<>();     //storing index for information\\n        for(int i=0;i<n;i++){\\n            if(rob[i][1]==1){\\n                st.add(rob[i][0]);         //if R going robot add to stack\\n            }else{\\n                //if left if stack is not empty\\n                while(!st.isEmpty()){\\n                    int nr=st.peek();   //get index of right going robot\\n                    int nl=rob[i][0];   //get index of left going robot\\n                    if(healths[nr]==healths[nl]){\\n                        //if healths are equal\\n                        healths[nr]=0;   //make right going robots health 0\\n                        healths[nl]=0;   //make left going robots health 0\\n                        //pop right going index and break cause left is also removed\\n                        st.pop();\\n                        break;\\n                    }else if(healths[nr]>healths[nl]){\\n                        healths[nr]--;   //reduce right going health by 1\\n                        healths[nl]=0;   //make left going robots health 0\\n                        //break as left going robot is removed\\n                        break;\\n                    }else{\\n                        healths[nr]=0;     //make right going robots health 0\\n                        healths[nl]--;    //reduce left going health by 1\\n                        st.pop();         //pop the right and continue the loop as left is still alive\\n                    }\\n                }\\n            }\\n        }\\n        for(int num:healths){\\n            //add healths greater than 0 to the result\\n            if(num>0)res.add(num);\\n        }\\n        return res;\\n    }\\n}\\n```\\n# Code Without Comments\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Integer> res=new ArrayList();\\n        char[] dir=directions.toCharArray();\\n        int n=positions.length;\\n        int[][] rob=new int[n][3];\\n        for(int i=0;i<n;i++){\\n            rob[i][0]=i;\\n            rob[i][1]=dir[i]==\\'R\\'?1:0;\\n            rob[i][2]=positions[i];\\n        }\\n        Arrays.sort(rob,(a,b)->a[2]-b[2]);\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<n;i++){\\n            if(rob[i][1]==1){\\n                st.add(rob[i][0]);\\n            }else{\\n                while(!st.isEmpty()){\\n                    int nr=st.peek();\\n                    int nl=rob[i][0];\\n                    if(healths[nr]==healths[nl]){\\n                        healths[nr]=0;\\n                        healths[nl]=0;\\n                        st.pop();\\n                        break;\\n                    }else if(healths[nr]>healths[nl]){\\n                        healths[nr]--;\\n                        healths[nl]=0;\\n                        \\n                        break;\\n                    }else{\\n                        healths[nr]=0;\\n                        healths[nl]--;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n        for(int num:healths){\\n            if(num>0)res.add(num);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Integer> res=new ArrayList();     //final ans\\n        char[] dir=directions.toCharArray();   //to fetch direction char\\n        int n=positions.length;\\n        int[][] rob=new int[n][3];             //to store index , direction and position of the robot\\n        for(int i=0;i<n;i++){\\n            rob[i][0]=i;                      //index to fetch info\\n            rob[i][1]=dir[i]==\\'R\\'?1:0;        //1 for Right 0 for left\\n            rob[i][2]=positions[i];           //position to sort\\n        }\\n        Arrays.sort(rob,(a,b)->a[2]-b[2]);   //sort according to position\\n        Stack<Integer> st=new Stack<>();     //storing index for information\\n        for(int i=0;i<n;i++){\\n            if(rob[i][1]==1){\\n                st.add(rob[i][0]);         //if R going robot add to stack\\n            }else{\\n                //if left if stack is not empty\\n                while(!st.isEmpty()){\\n                    int nr=st.peek();   //get index of right going robot\\n                    int nl=rob[i][0];   //get index of left going robot\\n                    if(healths[nr]==healths[nl]){\\n                        //if healths are equal\\n                        healths[nr]=0;   //make right going robots health 0\\n                        healths[nl]=0;   //make left going robots health 0\\n                        //pop right going index and break cause left is also removed\\n                        st.pop();\\n                        break;\\n                    }else if(healths[nr]>healths[nl]){\\n                        healths[nr]--;   //reduce right going health by 1\\n                        healths[nl]=0;   //make left going robots health 0\\n                        //break as left going robot is removed\\n                        break;\\n                    }else{\\n                        healths[nr]=0;     //make right going robots health 0\\n                        healths[nl]--;    //reduce left going health by 1\\n                        st.pop();         //pop the right and continue the loop as left is still alive\\n                    }\\n                }\\n            }\\n        }\\n        for(int num:healths){\\n            //add healths greater than 0 to the result\\n            if(num>0)res.add(num);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Integer> res=new ArrayList();\\n        char[] dir=directions.toCharArray();\\n        int n=positions.length;\\n        int[][] rob=new int[n][3];\\n        for(int i=0;i<n;i++){\\n            rob[i][0]=i;\\n            rob[i][1]=dir[i]==\\'R\\'?1:0;\\n            rob[i][2]=positions[i];\\n        }\\n        Arrays.sort(rob,(a,b)->a[2]-b[2]);\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<n;i++){\\n            if(rob[i][1]==1){\\n                st.add(rob[i][0]);\\n            }else{\\n                while(!st.isEmpty()){\\n                    int nr=st.peek();\\n                    int nl=rob[i][0];\\n                    if(healths[nr]==healths[nl]){\\n                        healths[nr]=0;\\n                        healths[nl]=0;\\n                        st.pop();\\n                        break;\\n                    }else if(healths[nr]>healths[nl]){\\n                        healths[nr]--;\\n                        healths[nl]=0;\\n                        \\n                        break;\\n                    }else{\\n                        healths[nr]=0;\\n                        healths[nl]--;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n        for(int num:healths){\\n            if(num>0)res.add(num);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684934,
                "title": "stack-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n=positions.size();\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            ans[i]=-7;\\n        }\\n        map<int,int>m;\\n        for(int i=0;i<positions.size();i++){\\n            m[positions[i]]=i;\\n        }\\n\\n      vector<pair<int,pair<int,char>>>v;\\n      for(int i=0;i<healths.size();i++){\\n          v.push_back({positions[i],{healths[i],directions[i]}});\\n      }\\n      sort(v.begin(),v.end());\\n      for(int i=0;i<positions.size();i++){\\n          v[i].first=m[v[i].first];\\n      }\\n\\n      stack<pair<int,pair<int,char>>>st;\\n      st.push(v[0]);\\n        for(int i=1;i<v.size();i++){\\n            if(st.empty()){\\n                st.push(v[i]);\\n                continue;\\n            }\\n            // cout<<v[i].second.first<<\" \"<<st.top().second.first<<endl;\\n            if(st.top().second.second==v[i].second.second){\\n                st.push(v[i]);\\n                continue;\\n            }\\n            \\n            else{\\n                bool to=true;\\n                int a=0;\\n               \\n                 a=st.top().second.first;\\n                \\n                int b=v[i].second.first;\\n\\n                while(!st.empty()&&st.top().second.second!=v[i].second.second&&v[i].second.second==\\'L\\'){\\n                    \\n                    a=st.top().second.first;\\n                \\n                    \\n                    if(a>b){\\n                        \\n                        st.top().second.first--;\\n                        \\n                        to=false;\\n                        break;\\n                    }\\n                     else if(a<b){\\n                        // st.pop();\\n                        v[i].second.first--;\\n                        b--;\\n                        // cout<<v[i].second.first<<endl;\\n                    }\\n                    else{\\n                        //  cout<<a<<endl;\\n                         st.pop();\\n                        to=false;\\n                        break;\\n\\n                    }\\n                    st.pop();\\n                    \\n                }\\n                if(to){\\n                    st.push(v[i]);\\n                }\\n            }\\n        }\\n\\n        while(!st.empty()){\\n            int x=st.top().second.first;\\n            int y=st.top().first;\\n            \\n             ans[y]=x;\\n            st.pop();\\n\\n        }\\n        vector<int>final;\\n        \\n        for(int i=0;i<positions.size();i++){\\n            if(ans[i]==-7){\\n                continue;\\n            }\\n\\n            \\n            else{\\n                \\n                 final.push_back(ans[i]);\\n            }\\n        }\\n        return final;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n=positions.size();\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            ans[i]=-7;\\n        }\\n        map<int,int>m;\\n        for(int i=0;i<positions.size();i++){\\n            m[positions[i]]=i;\\n        }\\n\\n      vector<pair<int,pair<int,char>>>v;\\n      for(int i=0;i<healths.size();i++){\\n          v.push_back({positions[i],{healths[i],directions[i]}});\\n      }\\n      sort(v.begin(),v.end());\\n      for(int i=0;i<positions.size();i++){\\n          v[i].first=m[v[i].first];\\n      }\\n\\n      stack<pair<int,pair<int,char>>>st;\\n      st.push(v[0]);\\n        for(int i=1;i<v.size();i++){\\n            if(st.empty()){\\n                st.push(v[i]);\\n                continue;\\n            }\\n            // cout<<v[i].second.first<<\" \"<<st.top().second.first<<endl;\\n            if(st.top().second.second==v[i].second.second){\\n                st.push(v[i]);\\n                continue;\\n            }\\n            \\n            else{\\n                bool to=true;\\n                int a=0;\\n               \\n                 a=st.top().second.first;\\n                \\n                int b=v[i].second.first;\\n\\n                while(!st.empty()&&st.top().second.second!=v[i].second.second&&v[i].second.second==\\'L\\'){\\n                    \\n                    a=st.top().second.first;\\n                \\n                    \\n                    if(a>b){\\n                        \\n                        st.top().second.first--;\\n                        \\n                        to=false;\\n                        break;\\n                    }\\n                     else if(a<b){\\n                        // st.pop();\\n                        v[i].second.first--;\\n                        b--;\\n                        // cout<<v[i].second.first<<endl;\\n                    }\\n                    else{\\n                        //  cout<<a<<endl;\\n                         st.pop();\\n                        to=false;\\n                        break;\\n\\n                    }\\n                    st.pop();\\n                    \\n                }\\n                if(to){\\n                    st.push(v[i]);\\n                }\\n            }\\n        }\\n\\n        while(!st.empty()){\\n            int x=st.top().second.first;\\n            int y=st.top().first;\\n            \\n             ans[y]=x;\\n            st.pop();\\n\\n        }\\n        vector<int>final;\\n        \\n        for(int i=0;i<positions.size();i++){\\n            if(ans[i]==-7){\\n                continue;\\n            }\\n\\n            \\n            else{\\n                \\n                 final.push_back(ans[i]);\\n            }\\n        }\\n        return final;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3684416,
                "title": "c-stack-approach-shorting-somewhat-similar-to-asteroid-collision",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string str) {\\n        \\n        vector<pair<int,int>>vp; \\n        int n=str.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vp.push_back({positions[i],i});\\n        }\\n        sort(vp.begin(),vp.end());\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[i]=vp[i].second;\\n        }\\n        vector<int>v1,v2;\\n        string s=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            int idx=vp[i].second;\\n            v1.push_back(vp[i].first);\\n            v2.push_back(healths[idx]);\\n            s.push_back(str[idx]);\\n        }\\n        positions=v1;\\n        healths=v2;\\n        str=s;\\n        stack<pair<char,int>>st;        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(st.empty() || st.top().first==str[i])\\n            {\\n                st.push({str[i],i});\\n            }\\n            else\\n            {   \\n                bool f=0;\\n                while(st.empty()==false)\\n                {\\n                    auto curr=st.top();\\n                    st.pop();\\n                    char ch=curr.first;\\n                    int idx=curr.second;\\n                    int pos1=positions[idx];\\n                    int pos2=positions[i];\\n                    int hlth1=healths[idx];\\n                    int hlth2=healths[i];\\n                    if(ch==\\'R\\' && str[i]==\\'L\\')\\n                    {    \\n                        \\n                        if(pos1<pos2)\\n                        {    \\n                          \\n                            if(hlth1>hlth2)\\n                            {    \\n                                f=1;\\n                                st.push({ch,idx});\\n                                healths[idx]--;\\n                                break;\\n                            }\\n                            else if(hlth1<hlth2)\\n                            {\\n                                healths[i]--;\\n                            }\\n                            else\\n                            {   \\n                                f=1;\\n                                break;\\n                            }\\n                        } \\n                        else\\n                        {   \\n                            st.push({ch,idx});\\n                            break;\\n                        }\\n                    }\\n                    else if(ch==\\'L\\' && str[i]==\\'R\\')\\n                    {\\n                        if(pos1<pos2)\\n                        {   \\n                            st.push({ch,idx});\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            if(hlth1>hlth2)\\n                            {    \\n                                f=1;\\n                                st.push({ch,idx});\\n                                healths[idx]--;\\n                                break;\\n                            }\\n                            else if(hlth1<hlth2)\\n                            {\\n                                healths[i]--;\\n                            }\\n                            else\\n                            {   \\n                                f=1;\\n                                break;\\n                            }\\n                        }\\n                    }\\n                    else\\n                    {\\n                        st.push({ch,idx});\\n                        break;\\n                    }\\n                }\\n                if(f==0)\\n                {\\n                    if(healths[i]>0) st.push({str[i],i});\\n                }\\n            }\\n        }\\n        vector<int>ans(n,0);\\n        while(st.empty()==false)\\n        {\\n            auto curr=st.top();\\n            st.pop();\\n            int idx=curr.second;\\n            ans[mp[idx]]=healths[idx];\\n        }\\n        vector<int>v;\\n        for(auto x:ans)\\n        {\\n            if(x!=0) v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string str) {\\n        \\n        vector<pair<int,int>>vp; \\n        int n=str.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vp.push_back({positions[i],i});\\n        }\\n        sort(vp.begin(),vp.end());\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[i]=vp[i].second;\\n        }\\n        vector<int>v1,v2;\\n        string s=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            int idx=vp[i].second;\\n            v1.push_back(vp[i].first);\\n            v2.push_back(healths[idx]);\\n            s.push_back(str[idx]);\\n        }\\n        positions=v1;\\n        healths=v2;\\n        str=s;\\n        stack<pair<char,int>>st;        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(st.empty() || st.top().first==str[i])\\n            {\\n                st.push({str[i],i});\\n            }\\n            else\\n            {   \\n                bool f=0;\\n                while(st.empty()==false)\\n                {\\n                    auto curr=st.top();\\n                    st.pop();\\n                    char ch=curr.first;\\n                    int idx=curr.second;\\n                    int pos1=positions[idx];\\n                    int pos2=positions[i];\\n                    int hlth1=healths[idx];\\n                    int hlth2=healths[i];\\n                    if(ch==\\'R\\' && str[i]==\\'L\\')\\n                    {    \\n                        \\n                        if(pos1<pos2)\\n                        {    \\n                          \\n                            if(hlth1>hlth2)\\n                            {    \\n                                f=1;\\n                                st.push({ch,idx});\\n                                healths[idx]--;\\n                                break;\\n                            }\\n                            else if(hlth1<hlth2)\\n                            {\\n                                healths[i]--;\\n                            }\\n                            else\\n                            {   \\n                                f=1;\\n                                break;\\n                            }\\n                        } \\n                        else\\n                        {   \\n                            st.push({ch,idx});\\n                            break;\\n                        }\\n                    }\\n                    else if(ch==\\'L\\' && str[i]==\\'R\\')\\n                    {\\n                        if(pos1<pos2)\\n                        {   \\n                            st.push({ch,idx});\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            if(hlth1>hlth2)\\n                            {    \\n                                f=1;\\n                                st.push({ch,idx});\\n                                healths[idx]--;\\n                                break;\\n                            }\\n                            else if(hlth1<hlth2)\\n                            {\\n                                healths[i]--;\\n                            }\\n                            else\\n                            {   \\n                                f=1;\\n                                break;\\n                            }\\n                        }\\n                    }\\n                    else\\n                    {\\n                        st.push({ch,idx});\\n                        break;\\n                    }\\n                }\\n                if(f==0)\\n                {\\n                    if(healths[i]>0) st.push({str[i],i});\\n                }\\n            }\\n        }\\n        vector<int>ans(n,0);\\n        while(st.empty()==false)\\n        {\\n            auto curr=st.top();\\n            st.pop();\\n            int idx=curr.second;\\n            ans[mp[idx]]=healths[idx];\\n        }\\n        vector<int>v;\\n        for(auto x:ans)\\n        {\\n            if(x!=0) v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683793,
                "title": "c-easy-solution-stack-sorting-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans;\\n        for(int i=0;i<positions.size();i++){\\n            mp[positions[i]]=i;\\n        }\\n        sort(positions.begin(),positions.end());\\n        stack<int> st;\\n        for(int i=0;i<positions.size();i++){\\n            if(directions[mp[positions[i]]]==\\'R\\'){\\n                st.push(positions[i]);\\n            }else{\\n                if(!st.empty()){\\n                    if(!st.empty() && healths[mp[st.top()]]==healths[mp[positions[i]]]){\\n                        healths[mp[st.top()]]=0;\\n                        healths[mp[positions[i]]]=0;\\n                        st.pop();\\n                    }\\n                    else if(healths[mp[st.top()]]<healths[mp[positions[i]]]){\\n                        while(!st.empty() && healths[mp[st.top()]]<healths[mp[positions[i]]]){\\n                            healths[mp[st.top()]]=0;\\n                            st.pop();\\n                            healths[mp[positions[i]]]--;\\n                        }\\n                        if(!st.empty() && healths[mp[st.top()]]>healths[mp[positions[i]]]){\\n                            healths[mp[st.top()]]--;\\n                            healths[mp[positions[i]]]=0;\\n                        }else if(!st.empty() && healths[mp[st.top()]]==healths[mp[positions[i]]]){\\n                            healths[mp[st.top()]]=0;\\n                            st.pop();\\n                            healths[mp[positions[i]]]=0;\\n                        }\\n                    }\\n                    else if(!st.empty() && healths[mp[st.top()]]>healths[mp[positions[i]]]){\\n                        healths[mp[positions[i]]]=0;\\n                       healths[mp[st.top()]]--;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<healths.size();i++){\\n            if(healths[i]!=0){\\n                ans.push_back(healths[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans;\\n        for(int i=0;i<positions.size();i++){\\n            mp[positions[i]]=i;\\n        }\\n        sort(positions.begin(),positions.end());\\n        stack<int> st;\\n        for(int i=0;i<positions.size();i++){\\n            if(directions[mp[positions[i]]]==\\'R\\'){\\n                st.push(positions[i]);\\n            }else{\\n                if(!st.empty()){\\n                    if(!st.empty() && healths[mp[st.top()]]==healths[mp[positions[i]]]){\\n                        healths[mp[st.top()]]=0;\\n                        healths[mp[positions[i]]]=0;\\n                        st.pop();\\n                    }\\n                    else if(healths[mp[st.top()]]<healths[mp[positions[i]]]){\\n                        while(!st.empty() && healths[mp[st.top()]]<healths[mp[positions[i]]]){\\n                            healths[mp[st.top()]]=0;\\n                            st.pop();\\n                            healths[mp[positions[i]]]--;\\n                        }\\n                        if(!st.empty() && healths[mp[st.top()]]>healths[mp[positions[i]]]){\\n                            healths[mp[st.top()]]--;\\n                            healths[mp[positions[i]]]=0;\\n                        }else if(!st.empty() && healths[mp[st.top()]]==healths[mp[positions[i]]]){\\n                            healths[mp[st.top()]]=0;\\n                            st.pop();\\n                            healths[mp[positions[i]]]=0;\\n                        }\\n                    }\\n                    else if(!st.empty() && healths[mp[st.top()]]>healths[mp[positions[i]]]){\\n                        healths[mp[positions[i]]]=0;\\n                       healths[mp[st.top()]]--;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<healths.size();i++){\\n            if(healths[i]!=0){\\n                ans.push_back(healths[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683574,
                "title": "stack-baby",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, p: List[int], h: List[int], d: str) -> List[int]:\\n        robots=sorted([[p[i],h[i],d[i],i] for i in range(len(p))])\\n        left,right,kick=[],[],[]\\n        for i in range(len(robots)):\\n            if robots[i][2]==\"R\":\\n                right.append(robots[i])\\n                if len(left)>0:\\n                    kick+=left\\n                    left=[]\\n            elif len(right)>0:\\n                    left.append(robots[i])\\n                    while len(right)!=0:\\n                        if right[-1][1]>left[0][1]:\\n                            left.pop(0)\\n                            right[-1][1]-=1\\n                            if len(left)==0 or len(right):break\\n                        elif right[-1][1]==left[0][1]:\\n                            left.pop(0)\\n                            right.pop()\\n                            break\\n                        else:\\n                            left[0][1]-=1\\n                            right.pop()\\n            else:kick.append(robots[i])\\n        return [i[1] for i in sorted(left+right+kick,key=lambda x:x[-1])]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, p: List[int], h: List[int], d: str) -> List[int]:\\n        robots=sorted([[p[i],h[i],d[i],i] for i in range(len(p))])\\n        left,right,kick=[],[],[]\\n        for i in range(len(robots)):\\n            if robots[i][2]==\"R\":\\n                right.append(robots[i])\\n                if len(left)>0:\\n                    kick+=left\\n                    left=[]\\n            elif len(right)>0:\\n                    left.append(robots[i])\\n                    while len(right)!=0:\\n                        if right[-1][1]>left[0][1]:\\n                            left.pop(0)\\n                            right[-1][1]-=1\\n                            if len(left)==0 or len(right):break\\n                        elif right[-1][1]==left[0][1]:\\n                            left.pop(0)\\n                            right.pop()\\n                            break\\n                        else:\\n                            left[0][1]-=1\\n                            right.pop()\\n            else:kick.append(robots[i])\\n        return [i[1] for i in sorted(left+right+kick,key=lambda x:x[-1])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683540,
                "title": "java-easy-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        List<Integer> ind = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            ind.add(i);\\n        }\\n        Collections.sort(ind, (x, y) -> Integer.compare(positions[x], positions[y]));\\n        Stack<Integer> s = new Stack<>();\\n        for (int x : ind) {\\n            if (directions.charAt(x) == \\'L\\') {\\n                while (!s.empty()) {\\n                    int y = s.peek();\\n                    if (healths[x] == healths[y]) {\\n                        healths[x] = 0;\\n                        healths[y] = 0;\\n                        s.pop();\\n                        break;\\n                    }\\n                    if (healths[x] > healths[y]) {\\n                        healths[x]--;\\n                        healths[y] = 0;\\n                        s.pop();\\n                    } else {\\n                        healths[x] = 0;\\n                        healths[y]--;\\n                        break;\\n                    }\\n                }  \\n            } else {\\n                s.push(x);\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for (int x : healths) {\\n            if (x != 0) {\\n                result.add(x);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        List<Integer> ind = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            ind.add(i);\\n        }\\n        Collections.sort(ind, (x, y) -> Integer.compare(positions[x], positions[y]));\\n        Stack<Integer> s = new Stack<>();\\n        for (int x : ind) {\\n            if (directions.charAt(x) == \\'L\\') {\\n                while (!s.empty()) {\\n                    int y = s.peek();\\n                    if (healths[x] == healths[y]) {\\n                        healths[x] = 0;\\n                        healths[y] = 0;\\n                        s.pop();\\n                        break;\\n                    }\\n                    if (healths[x] > healths[y]) {\\n                        healths[x]--;\\n                        healths[y] = 0;\\n                        s.pop();\\n                    } else {\\n                        healths[x] = 0;\\n                        healths[y]--;\\n                        break;\\n                    }\\n                }  \\n            } else {\\n                s.push(x);\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for (int x : healths) {\\n            if (x != 0) {\\n                result.add(x);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683136,
                "title": "python-stack",
                "content": "# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        stack = []\\n        res = []\\n        n = len(positions)\\n        for p, h, d, i in list(sorted(zip(positions, healths, directions, range(n)))):\\n            if d == \\'R\\':\\n                stack.append((h,d,i))\\n            else:\\n                while stack and stack[-1][1] == \\'R\\':\\n                    toph, topd, topi = stack.pop()\\n                    if toph == h:\\n                        h = 0 \\n                        break \\n                    elif toph > h: \\n                        h = 0\\n                        stack.append((toph-1, topd, topi))\\n                        break\\n                    else:\\n                        h -= 1\\n                if h:\\n                    stack.append((h,d,i))\\n        stack.sort(key = lambda e: e[2])\\n        return [stack[i][0] for i in range(len(stack))]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        stack = []\\n        res = []\\n        n = len(positions)\\n        for p, h, d, i in list(sorted(zip(positions, healths, directions, range(n)))):\\n            if d == \\'R\\':\\n                stack.append((h,d,i))\\n            else:\\n                while stack and stack[-1][1] == \\'R\\':\\n                    toph, topd, topi = stack.pop()\\n                    if toph == h:\\n                        h = 0 \\n                        break \\n                    elif toph > h: \\n                        h = 0\\n                        stack.append((toph-1, topd, topi))\\n                        break\\n                    else:\\n                        h -= 1\\n                if h:\\n                    stack.append((h,d,i))\\n        stack.sort(key = lambda e: e[2])\\n        return [stack[i][0] for i in range(len(stack))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683077,
                "title": "stack-python",
                "content": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        \\n        arr = []\\n        n = len(positions)\\n        ans = [0 for i in range(n)]\\n        hashmap ={}\\n        for i in range(n):\\n            hashmap[positions[i]] = i\\n        \\n        for i in range(n):\\n            arr.append([positions[i],healths[i],directions[i]])\\n        \\n        arr.sort()\\n        \\n        stack =[]\\n        for i in range(len(arr)):\\n            pos,health,direction = arr[i]\\n            if direction == \"L\":\\n                while len(stack) > 0:\\n                    if health > stack[-1][1]:\\n                        ans[hashmap[stack[-1][0]]] = 0\\n                        stack.pop()\\n                        health -= 1\\n                    elif health == stack[-1][1]:\\n                        ans[hashmap[stack[-1][0]]] = 0\\n                        stack.pop()\\n                        health = 0\\n                        break\\n                    else:\\n                        stack[-1][1] -= 1\\n                        health = 0\\n                        break\\n                \\n                ans[hashmap[pos]] = health\\n            else:\\n                stack.append(arr[i])\\n        \\n        while len(stack)>0:\\n            x = stack.pop()\\n            \\n            ans[hashmap[x[0]]] = x[1]\\n        \\n        new_ans = []\\n        for i in range(len(ans)):\\n            if ans[i] != 0:\\n                new_ans.append(ans[i])\\n        \\n    \\n        return new_ans\\n                        \\n                        \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        \\n        arr = []\\n        n = len(positions)\\n        ans = [0 for i in range(n)]\\n        hashmap ={}\\n        for i in range(n):\\n            hashmap[positions[i]] = i\\n        \\n        for i in range(n):\\n            arr.append([positions[i],healths[i],directions[i]])\\n        \\n        arr.sort()\\n        \\n        stack =[]\\n        for i in range(len(arr)):\\n            pos,health,direction = arr[i]\\n            if direction == \"L\":\\n                while len(stack) > 0:\\n                    if health > stack[-1][1]:\\n                        ans[hashmap[stack[-1][0]]] = 0\\n                        stack.pop()\\n                        health -= 1\\n                    elif health == stack[-1][1]:\\n                        ans[hashmap[stack[-1][0]]] = 0\\n                        stack.pop()\\n                        health = 0\\n                        break\\n                    else:\\n                        stack[-1][1] -= 1\\n                        health = 0\\n                        break\\n                \\n                ans[hashmap[pos]] = health\\n            else:\\n                stack.append(arr[i])\\n        \\n        while len(stack)>0:\\n            x = stack.pop()\\n            \\n            ans[hashmap[x[0]]] = x[1]\\n        \\n        new_ans = []\\n        for i in range(len(ans)):\\n            if ans[i] != 0:\\n                new_ans.append(ans[i])\\n        \\n    \\n        return new_ans\\n                        \\n                        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682821,
                "title": "python-stack",
                "content": "\\n**Idea:**\\n   -  The problem itself if simple stack problem you just have to carefully do what\\'s told\\n   -  sort arrays by robots positions and order (we need order because we asked to return in the same order)\\n   -  add postion, index, health, direction into stack (after sorting you actually may skip adding postion that would not change anything)\\n   -  if stack and direction of stack[-1] if \\'R\\' and current robot is \\'L\\' resolve collisions\\n   -  return what\\'s left in stack sorted by original index\\n\\n```python\\nclass Solution:\\n    def survivedRobotsHealths(self, P: List[int], H: List[int], D: str) -> List[int]:\\n        \\n        stack = []\\n        A = [(p,i,h,d) for i,(p,h,d) in enumerate(zip(P,H,D))]\\n        A.sort(key = lambda x: (x[0],x[1]))\\n        \\n        for p,i,h,d in A:\\n            if stack:\\n\\n                if stack and stack[-1][-1] == \\'R\\' and d == \\'L\\' and stack[-1][-2] < h:\\n                    while stack and stack[-1][-1] == \\'R\\' and d == \\'L\\' and stack[-1][-2] < h:\\n                        p0,i0,h0,d0 = stack.pop()\\n                        h -= 1\\n\\n                if stack and  stack[-1][-1] == \\'R\\' and d == \\'L\\' and stack[-1][-2] == h:\\n                    stack.pop()\\n                    continue\\n                \\n                if stack and  stack[-1][-1] == \\'R\\' and d == \\'L\\' and stack[-1][-2] > h:\\n                    p0,i0, h0,d0 = stack.pop()\\n                    stack.append((p0,i0,h0-1,d0))\\n                    continue\\n                \\n                stack.append((p,i,h,d))\\n            else:\\n                stack.append((p,i,h,d))\\n        \\n        stack.sort(key = lambda x: x[1])\\n        return [h for _,_,h,_ in stack]\\n```\\n\\nTime: `O(NlogN)`\\nSpace: `O(N)`\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def survivedRobotsHealths(self, P: List[int], H: List[int], D: str) -> List[int]:\\n        \\n        stack = []\\n        A = [(p,i,h,d) for i,(p,h,d) in enumerate(zip(P,H,D))]\\n        A.sort(key = lambda x: (x[0],x[1]))\\n        \\n        for p,i,h,d in A:\\n            if stack:\\n\\n                if stack and stack[-1][-1] == \\'R\\' and d == \\'L\\' and stack[-1][-2] < h:\\n                    while stack and stack[-1][-1] == \\'R\\' and d == \\'L\\' and stack[-1][-2] < h:\\n                        p0,i0,h0,d0 = stack.pop()\\n                        h -= 1\\n\\n                if stack and  stack[-1][-1] == \\'R\\' and d == \\'L\\' and stack[-1][-2] == h:\\n                    stack.pop()\\n                    continue\\n                \\n                if stack and  stack[-1][-1] == \\'R\\' and d == \\'L\\' and stack[-1][-2] > h:\\n                    p0,i0, h0,d0 = stack.pop()\\n                    stack.append((p0,i0,h0-1,d0))\\n                    continue\\n                \\n                stack.append((p,i,h,d))\\n            else:\\n                stack.append((p,i,h,d))\\n        \\n        stack.sort(key = lambda x: x[1])\\n        return [h for _,_,h,_ in stack]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682706,
                "title": "c-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving th\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct robot{\\n        int p,h,ind;\\n        char d;\\n    };\\n    struct comp1{\\n        bool operator()(robot a, robot b)\\n        {return a.p < b.p;}\\n    };\\n    struct comp2{\\n        bool operator()(robot a, robot b)\\n        {return a.ind < b.ind;}\\n    };\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& health, string dir) \\n    {\\n        int n = pos.size();\\n        vector<robot>robo(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            robo[i].p = pos[i];\\n            robo[i].h = health[i];\\n            robo[i].ind = i;\\n            robo[i].d = dir[i];\\n        }\\n        sort(robo.begin(),robo.end(),comp1());\\n        \\n        stack<robot>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(robo[i].d == \\'R\\')\\n                st.push(robo[i]);\\n            else if(st.empty() || st.top().d==\\'L\\')\\n                st.push(robo[i]);\\n            else\\n            {\\n                bool flag = false;\\n                while(!st.empty() && st.top().d==\\'R\\')\\n                {\\n                    robot temp = st.top();\\n                    st.pop();\\n                    if(temp.h==robo[i].h)\\n                    {\\n                        flag = true;\\n                        break;\\n                    }\\n                    else if(temp.h>robo[i].h)\\n                    {\\n                        flag = true;\\n                        temp.h = temp.h - 1;\\n                        st.push(temp);\\n                        break;\\n                    }\\n                    else\\n                        robo[i].h = robo[i].h - 1;\\n                }\\n                if(!flag)\\n                    st.push(robo[i]);\\n            }\\n        }\\n        vector<robot>ansTemp;\\n        while(!st.empty())\\n        {\\n            ansTemp.push_back(st.top());\\n            st.pop();\\n        }\\n        int n2 = ansTemp.size();\\n        sort(ansTemp.begin(),ansTemp.end(),comp2());\\n        vector<int>ans;\\n        for(int i=0;i<n2;i++)\\n            ans.push_back(ansTemp[i].h);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct robot{\\n        int p,h,ind;\\n        char d;\\n    };\\n    struct comp1{\\n        bool operator()(robot a, robot b)\\n        {return a.p < b.p;}\\n    };\\n    struct comp2{\\n        bool operator()(robot a, robot b)\\n        {return a.ind < b.ind;}\\n    };\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& health, string dir) \\n    {\\n        int n = pos.size();\\n        vector<robot>robo(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            robo[i].p = pos[i];\\n            robo[i].h = health[i];\\n            robo[i].ind = i;\\n            robo[i].d = dir[i];\\n        }\\n        sort(robo.begin(),robo.end(),comp1());\\n        \\n        stack<robot>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(robo[i].d == \\'R\\')\\n                st.push(robo[i]);\\n            else if(st.empty() || st.top().d==\\'L\\')\\n                st.push(robo[i]);\\n            else\\n            {\\n                bool flag = false;\\n                while(!st.empty() && st.top().d==\\'R\\')\\n                {\\n                    robot temp = st.top();\\n                    st.pop();\\n                    if(temp.h==robo[i].h)\\n                    {\\n                        flag = true;\\n                        break;\\n                    }\\n                    else if(temp.h>robo[i].h)\\n                    {\\n                        flag = true;\\n                        temp.h = temp.h - 1;\\n                        st.push(temp);\\n                        break;\\n                    }\\n                    else\\n                        robo[i].h = robo[i].h - 1;\\n                }\\n                if(!flag)\\n                    st.push(robo[i]);\\n            }\\n        }\\n        vector<robot>ansTemp;\\n        while(!st.empty())\\n        {\\n            ansTemp.push_back(st.top());\\n            st.pop();\\n        }\\n        int n2 = ansTemp.size();\\n        sort(ansTemp.begin(),ansTemp.end(),comp2());\\n        vector<int>ans;\\n        for(int i=0;i<n2;i++)\\n            ans.push_back(ansTemp[i].h);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682667,
                "title": "same-as-asteroid-collison-readable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct Robot {\\n        int position;\\n        int health;\\n        char direction;\\n        int index;\\n    };\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string& directions) {\\n        int n = positions.size();\\n        vector<Robot> vals;\\n        for (int i = 0; i < n; i++) {\\n            vals.push_back({positions[i], healths[i], directions[i], i});\\n        }\\n        sort(vals.begin(), vals.end(), [](const Robot& a, const Robot& b) {\\n            return a.position < b.position;\\n        });\\n        stack<Robot>st;\\n        for(auto x:vals)\\n        {\\n            if( x.direction==\\'R\\') \\n            {\\n                st.push(x);\\n                continue;\\n\\n            }\\n              while(st.size()>0 && st.top().direction==\\'R\\' && x.direction==\\'L\\' && st.top().health<x.health)\\n              {\\n                 x.health--;\\n                 st.pop();\\n              }\\n                  if(!st.empty() and st.top().direction==\\'R\\' && x.direction==\\'L\\' && st.top().health == x.health) \\n                   {\\n                       st.pop();\\n                       continue;\\n                   }\\n                   if(st.empty() || st.top().direction==\\'L\\') \\n                    {\\n                        st.push(x);\\n                         continue;\\n                    }\\n                   if(!st.empty() && st.top().direction==\\'R\\' && st.top().health>x.health)\\n                    {\\n\\n                        st.top().health--;\\n                    }\\n    \\n            \\n            }\\n            vector<pair<int,int>>ans;\\n            vector<int>res;\\n            while(!st.empty())\\n            {\\n                ans.push_back({st.top().index,st.top().health});\\n                st.pop();\\n            }\\n            sort(ans.begin(),ans.end());\\n            for(auto x:ans)\\n            {\\n                res.push_back(x.second);\\n            }\\n            return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Robot {\\n        int position;\\n        int health;\\n        char direction;\\n        int index;\\n    };\\n\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string& directions) {\\n        int n = positions.size();\\n        vector<Robot> vals;\\n        for (int i = 0; i < n; i++) {\\n            vals.push_back({positions[i], healths[i], directions[i], i});\\n        }\\n        sort(vals.begin(), vals.end(), [](const Robot& a, const Robot& b) {\\n            return a.position < b.position;\\n        });\\n        stack<Robot>st;\\n        for(auto x:vals)\\n        {\\n            if( x.direction==\\'R\\') \\n            {\\n                st.push(x);\\n                continue;\\n\\n            }\\n              while(st.size()>0 && st.top().direction==\\'R\\' && x.direction==\\'L\\' && st.top().health<x.health)\\n              {\\n                 x.health--;\\n                 st.pop();\\n              }\\n                  if(!st.empty() and st.top().direction==\\'R\\' && x.direction==\\'L\\' && st.top().health == x.health) \\n                   {\\n                       st.pop();\\n                       continue;\\n                   }\\n                   if(st.empty() || st.top().direction==\\'L\\') \\n                    {\\n                        st.push(x);\\n                         continue;\\n                    }\\n                   if(!st.empty() && st.top().direction==\\'R\\' && st.top().health>x.health)\\n                    {\\n\\n                        st.top().health--;\\n                    }\\n    \\n            \\n            }\\n            vector<pair<int,int>>ans;\\n            vector<int>res;\\n            while(!st.empty())\\n            {\\n                ans.push_back({st.top().index,st.top().health});\\n                st.pop();\\n            }\\n            sort(ans.begin(),ans.end());\\n            for(auto x:ans)\\n            {\\n                res.push_back(x.second);\\n            }\\n            return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682481,
                "title": "easy-clean-c-code-a-bit-lengthy",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<int> ans;\\n        using p = pair<pair<int,int>,pair<char,int>>;\\n        vector<p> vec;\\n        for(int i=0;i<n;i++)\\n            vec.push_back({{positions[i],healths[i]},{directions[i],i}});\\n        sort(vec.begin(),vec.end());\\n        stack<pair<pair<int,int>,char>> sta;\\n        for(auto it:vec){\\n            int heal = it.first.second, pos = it.second.second;\\n            char dir = it.second.first;\\n            if(sta.size() == 0){\\n                sta.push({{pos,heal},dir});\\n                continue;\\n            }\\n            int s_heal = sta.top().first.second, s_pos = sta.top().first.first;\\n            char s_dir = sta.top().second;\\n            if((s_dir == \\'L\\' && dir == \\'R\\') || (s_dir == dir))\\n                sta.push({{pos,heal},dir});\\n            else if(s_heal == heal)\\n                sta.pop();\\n            else if(s_heal > heal){\\n                sta.pop();\\n                sta.push({{s_pos,s_heal - 1},s_dir});\\n            }\\n            else{\\n                while(sta.size() > 0 && sta.top().first.second < heal && sta.top().second == \\'R\\'){\\n                    heal--;\\n                    sta.pop();\\n                }\\n                if(sta.size()){\\n                    if(sta.top().second == \\'L\\')\\n                        sta.push({{pos,heal},dir});\\n                    else{\\n                        if(heal == sta.top().first.second)\\n                            sta.pop();\\n                        else{\\n                            int x = sta.top().first.second, n_pos = sta.top().first.first;\\n                            char y = sta.top().second;\\n                            sta.pop();\\n                            sta.push({{n_pos,x-1},y});\\n                        }\\n                    }\\n                }\\n                else\\n                    sta.push({{pos,heal},dir});\\n            }\\n        }\\n        vector<pair<int,int>> v;\\n        while(sta.size()){\\n            v.push_back({sta.top().first.first,sta.top().first.second});\\n            sta.pop();\\n        }\\n        sort(v.begin(),v.end());\\n        for(auto it:v)\\n            ans.push_back(it.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        vector<int> ans;\\n        using p = pair<pair<int,int>,pair<char,int>>;\\n        vector<p> vec;\\n        for(int i=0;i<n;i++)\\n            vec.push_back({{positions[i],healths[i]},{directions[i],i}});\\n        sort(vec.begin(),vec.end());\\n        stack<pair<pair<int,int>,char>> sta;\\n        for(auto it:vec){\\n            int heal = it.first.second, pos = it.second.second;\\n            char dir = it.second.first;\\n            if(sta.size() == 0){\\n                sta.push({{pos,heal},dir});\\n                continue;\\n            }\\n            int s_heal = sta.top().first.second, s_pos = sta.top().first.first;\\n            char s_dir = sta.top().second;\\n            if((s_dir == \\'L\\' && dir == \\'R\\') || (s_dir == dir))\\n                sta.push({{pos,heal},dir});\\n            else if(s_heal == heal)\\n                sta.pop();\\n            else if(s_heal > heal){\\n                sta.pop();\\n                sta.push({{s_pos,s_heal - 1},s_dir});\\n            }\\n            else{\\n                while(sta.size() > 0 && sta.top().first.second < heal && sta.top().second == \\'R\\'){\\n                    heal--;\\n                    sta.pop();\\n                }\\n                if(sta.size()){\\n                    if(sta.top().second == \\'L\\')\\n                        sta.push({{pos,heal},dir});\\n                    else{\\n                        if(heal == sta.top().first.second)\\n                            sta.pop();\\n                        else{\\n                            int x = sta.top().first.second, n_pos = sta.top().first.first;\\n                            char y = sta.top().second;\\n                            sta.pop();\\n                            sta.push({{n_pos,x-1},y});\\n                        }\\n                    }\\n                }\\n                else\\n                    sta.push({{pos,heal},dir});\\n            }\\n        }\\n        vector<pair<int,int>> v;\\n        while(sta.size()){\\n            v.push_back({sta.top().first.first,sta.top().first.second});\\n            sta.pop();\\n        }\\n        sort(v.begin(),v.end());\\n        for(auto it:v)\\n            ans.push_back(it.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682470,
                "title": "readable-python-stack-solution",
                "content": "# Intuition\\nhttps://leetcode.com/problems/asteroid-collision/ same intuition as this. Watch neetcode\\'s video!\\n\\n# Approach\\nappend all the info together into a 2d array for easy access later.\\nPush the robots to the stack, popping the top one and replacing it with the winner. Robots that are moving right get ignored and robots that are moving the same direction are ignored.\\n\\n# Complexity\\n- Time complexity:\\no(n)logn\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n\\n        stack = []\\n        robotInfo = []\\n\\n        for i, position in enumerate(positions):\\n            robotInfo.append((position, healths[i], i, directions[i]))\\n        \\n        robotInfo.sort()\\n\\n        for currentRobotPosition, currentRobotHealth, currentRobotIndex, currentRobotDirection in robotInfo:\\n\\n            while stack and currentRobotDirection != \\'R\\' and currentRobotHealth > 0 and stack[-1][3] != \\'L\\':\\n                robotInFront = stack.pop()\\n                robotInFrontPosition = robotInFront[0]\\n                robotInFrontHealth = robotInFront[1]\\n                robotInFrontIndex = robotInFront[2]\\n                robotInFrontDirection = robotInFront[3]\\n\\n                if  robotInFrontHealth == currentRobotHealth:\\n                    currentRobotHealth = 0\\n                \\n                elif currentRobotHealth < robotInFrontHealth:\\n                    currentRobotPosition = robotInFrontPosition\\n                    currentRobotHealth = robotInFrontHealth - 1\\n                    currentRobotDirection = robotInFrontDirection\\n                    currentRobotIndex = robotInFrontIndex\\n                else:\\n                    currentRobotHealth -= 1\\n\\n            if currentRobotHealth != 0:\\n                stack.append((currentRobotPosition, currentRobotHealth, currentRobotIndex, currentRobotDirection))\\n\\n        \\n        stack.sort(key=lambda pair: pair[2])\\n\\n        sol = []\\n        for robot in stack:\\n                sol.append(robot[1])\\n\\n\\n        return sol\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n\\n        stack = []\\n        robotInfo = []\\n\\n        for i, position in enumerate(positions):\\n            robotInfo.append((position, healths[i], i, directions[i]))\\n        \\n        robotInfo.sort()\\n\\n        for currentRobotPosition, currentRobotHealth, currentRobotIndex, currentRobotDirection in robotInfo:\\n\\n            while stack and currentRobotDirection != \\'R\\' and currentRobotHealth > 0 and stack[-1][3] != \\'L\\':\\n                robotInFront = stack.pop()\\n                robotInFrontPosition = robotInFront[0]\\n                robotInFrontHealth = robotInFront[1]\\n                robotInFrontIndex = robotInFront[2]\\n                robotInFrontDirection = robotInFront[3]\\n\\n                if  robotInFrontHealth == currentRobotHealth:\\n                    currentRobotHealth = 0\\n                \\n                elif currentRobotHealth < robotInFrontHealth:\\n                    currentRobotPosition = robotInFrontPosition\\n                    currentRobotHealth = robotInFrontHealth - 1\\n                    currentRobotDirection = robotInFrontDirection\\n                    currentRobotIndex = robotInFrontIndex\\n                else:\\n                    currentRobotHealth -= 1\\n\\n            if currentRobotHealth != 0:\\n                stack.append((currentRobotPosition, currentRobotHealth, currentRobotIndex, currentRobotDirection))\\n\\n        \\n        stack.sort(key=lambda pair: pair[2])\\n\\n        sol = []\\n        for robot in stack:\\n                sol.append(robot[1])\\n\\n\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682430,
                "title": "c-java-python-clean-code-with-good-readability-no-index-hack",
                "content": "# Intuition\\n\\nSee collision -> using stack.\\n\\n# Approach\\n\\nUse `Robot` struct to represent a running robot on the line.\\n\\n# Complexity\\n\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n\\n```cpp []\\nstruct Robot {\\n  int index;\\n  int position;\\n  int health;\\n  char direction;\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> survivedRobotsHealths(vector<int>& positions,\\n                                    vector<int>& healths, string directions) {\\n    vector<int> ans;\\n    vector<Robot> robots;\\n    vector<Robot> stack;  // store runnnig robots\\n\\n    for (int i = 0; i < positions.size(); ++i)\\n      robots.push_back(Robot{i, positions[i], healths[i], directions[i]});\\n\\n    sort(robots.begin(), robots.end(), [](const Robot& a, const Robot& b) {\\n      return a.position < b.position;\\n    });\\n\\n    for (Robot& robot : robots) {\\n      if (robot.direction == \\'R\\') {\\n        stack.push_back(robot);\\n        continue;\\n      }\\n      // Collide with robots going right if any.\\n      while (!stack.empty() && stack.back().direction == \\'R\\' &&\\n             robot.health > 0) {\\n        if (stack.back().health == robot.health) {\\n          stack.pop_back();\\n          robot.health = 0;\\n        } else if (stack.back().health < robot.health) {\\n          stack.pop_back();\\n          robot.health -= 1;\\n        } else {  // stack.back().health > robot.health\\n          stack.back().health -= 1;\\n          robot.health = 0;\\n        }\\n      }\\n      if (robot.health > 0)\\n        stack.push_back(robot);\\n    }\\n\\n    sort(stack.begin(), stack.end(),\\n         [](const Robot& a, const Robot& b) { return a.index < b.index; });\\n\\n    for (const Robot& robot : stack)\\n      ans.push_back(robot.health);\\n\\n    return ans;\\n  }\\n};\\n```\\n```java []\\nclass Robot {\\n  public int index;\\n  public int position;\\n  public int health;\\n  public char direction;\\n  public Robot(int index, int position, int health, char direction) {\\n    this.index = index;\\n    this.position = position;\\n    this.health = health;\\n    this.direction = direction;\\n  }\\n}\\n\\nclass Solution {\\n  public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n    List<Integer> ans = new ArrayList<>();\\n    Robot[] robots = new Robot[positions.length];\\n    List<Robot> stack = new ArrayList<>(); // store running robots\\n\\n    for (int i = 0; i < positions.length; ++i)\\n      robots[i] = new Robot(i, positions[i], healths[i], directions.charAt(i));\\n\\n    Arrays.sort(robots, (a, b) -> a.position - b.position);\\n\\n    for (Robot robot : robots) {\\n      if (robot.direction == \\'R\\') {\\n        stack.add(robot);\\n        continue;\\n      }\\n      // Collide with robots going right if any.\\n      while (!stack.isEmpty() && stack.get(stack.size() - 1).direction == \\'R\\' && robot.health > 0) {\\n        if (stack.get(stack.size() - 1).health == robot.health) {\\n          stack.remove(stack.size() - 1);\\n          robot.health = 0;\\n        } else if (stack.get(stack.size() - 1).health < robot.health) {\\n          stack.remove(stack.size() - 1);\\n          robot.health -= 1;\\n        } else { // stack[-1].health > robot.health\\n          stack.get(stack.size() - 1).health -= 1;\\n          robot.health = 0;\\n        }\\n      }\\n      if (robot.health > 0)\\n        stack.add(robot);\\n    }\\n\\n    stack.sort((a, b) -> a.index - b.index);\\n\\n    for (Robot robot : stack)\\n      ans.add(robot.health);\\n\\n    return ans;\\n  }\\n}\\n```\\n```python []\\n@dataclass\\nclass Robot:\\n  index: int\\n  position: int\\n  health: int\\n  direction: str\\n\\n\\nclass Solution:\\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n    robots = sorted([Robot(index, position, health, direction)\\n                     for index, (position, health, direction) in\\n                     enumerate(zip(positions, healths, directions))],\\n                    key=lambda robot: robot.position)\\n    stack: List[Robot] = []  # store running robots\\n\\n    for robot in robots:\\n      if robot.direction == \\'R\\':\\n        stack.append(robot)\\n        continue\\n      # Collide with robots going right if any.\\n      while stack and stack[-1].direction == \\'R\\' and robot.health > 0:\\n        if stack[-1].health == robot.health:\\n          stack.pop()\\n          robot.health = 0\\n        elif stack[-1].health < robot.health:\\n          stack.pop()\\n          robot.health -= 1\\n        else:  # stack[-1].health > robot.health\\n          stack[-1].health -= 1\\n          robot.health = 0\\n      if robot.health > 0:\\n        stack.append(robot)\\n\\n    stack.sort(key=lambda robot: robot.index)\\n    return [robot.health for robot in stack]\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```cpp []\\nstruct Robot {\\n  int index;\\n  int position;\\n  int health;\\n  char direction;\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> survivedRobotsHealths(vector<int>& positions,\\n                                    vector<int>& healths, string directions) {\\n    vector<int> ans;\\n    vector<Robot> robots;\\n    vector<Robot> stack;  // store runnnig robots\\n\\n    for (int i = 0; i < positions.size(); ++i)\\n      robots.push_back(Robot{i, positions[i], healths[i], directions[i]});\\n\\n    sort(robots.begin(), robots.end(), [](const Robot& a, const Robot& b) {\\n      return a.position < b.position;\\n    });\\n\\n    for (Robot& robot : robots) {\\n      if (robot.direction == \\'R\\') {\\n        stack.push_back(robot);\\n        continue;\\n      }\\n      // Collide with robots going right if any.\\n      while (!stack.empty() && stack.back().direction == \\'R\\' &&\\n             robot.health > 0) {\\n        if (stack.back().health == robot.health) {\\n          stack.pop_back();\\n          robot.health = 0;\\n        } else if (stack.back().health < robot.health) {\\n          stack.pop_back();\\n          robot.health -= 1;\\n        } else {  // stack.back().health > robot.health\\n          stack.back().health -= 1;\\n          robot.health = 0;\\n        }\\n      }\\n      if (robot.health > 0)\\n        stack.push_back(robot);\\n    }\\n\\n    sort(stack.begin(), stack.end(),\\n         [](const Robot& a, const Robot& b) { return a.index < b.index; });\\n\\n    for (const Robot& robot : stack)\\n      ans.push_back(robot.health);\\n\\n    return ans;\\n  }\\n};\\n```\n```java []\\nclass Robot {\\n  public int index;\\n  public int position;\\n  public int health;\\n  public char direction;\\n  public Robot(int index, int position, int health, char direction) {\\n    this.index = index;\\n    this.position = position;\\n    this.health = health;\\n    this.direction = direction;\\n  }\\n}\\n\\nclass Solution {\\n  public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n    List<Integer> ans = new ArrayList<>();\\n    Robot[] robots = new Robot[positions.length];\\n    List<Robot> stack = new ArrayList<>(); // store running robots\\n\\n    for (int i = 0; i < positions.length; ++i)\\n      robots[i] = new Robot(i, positions[i], healths[i], directions.charAt(i));\\n\\n    Arrays.sort(robots, (a, b) -> a.position - b.position);\\n\\n    for (Robot robot : robots) {\\n      if (robot.direction == \\'R\\') {\\n        stack.add(robot);\\n        continue;\\n      }\\n      // Collide with robots going right if any.\\n      while (!stack.isEmpty() && stack.get(stack.size() - 1).direction == \\'R\\' && robot.health > 0) {\\n        if (stack.get(stack.size() - 1).health == robot.health) {\\n          stack.remove(stack.size() - 1);\\n          robot.health = 0;\\n        } else if (stack.get(stack.size() - 1).health < robot.health) {\\n          stack.remove(stack.size() - 1);\\n          robot.health -= 1;\\n        } else { // stack[-1].health > robot.health\\n          stack.get(stack.size() - 1).health -= 1;\\n          robot.health = 0;\\n        }\\n      }\\n      if (robot.health > 0)\\n        stack.add(robot);\\n    }\\n\\n    stack.sort((a, b) -> a.index - b.index);\\n\\n    for (Robot robot : stack)\\n      ans.add(robot.health);\\n\\n    return ans;\\n  }\\n}\\n```\n```python []\\n@dataclass\\nclass Robot:\\n  index: int\\n  position: int\\n  health: int\\n  direction: str\\n\\n\\nclass Solution:\\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n    robots = sorted([Robot(index, position, health, direction)\\n                     for index, (position, health, direction) in\\n                     enumerate(zip(positions, healths, directions))],\\n                    key=lambda robot: robot.position)\\n    stack: List[Robot] = []  # store running robots\\n\\n    for robot in robots:\\n      if robot.direction == \\'R\\':\\n        stack.append(robot)\\n        continue\\n      # Collide with robots going right if any.\\n      while stack and stack[-1].direction == \\'R\\' and robot.health > 0:\\n        if stack[-1].health == robot.health:\\n          stack.pop()\\n          robot.health = 0\\n        elif stack[-1].health < robot.health:\\n          stack.pop()\\n          robot.health -= 1\\n        else:  # stack[-1].health > robot.health\\n          stack[-1].health -= 1\\n          robot.health = 0\\n      if robot.health > 0:\\n        stack.append(robot)\\n\\n    stack.sort(key=lambda robot: robot.index)\\n    return [robot.health for robot in stack]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682422,
                "title": "clean-oops-with-priority-queue",
                "content": "# Intuition\\nConditions for the robo to be colliding\\n1)The Left robo should have Direction \"R\" and right robo should have Direction \"L\". And they should be neighboring\\n\\nCondition for the robot to be non colliding\\n1)The robo walks in Direction \"L\" and there is no robo left to it walks in  Direction \"R\". Viceversa applies for robo walks in Direction \"R\".\\n2)The Configuration Like \"RR\", \"LL\", \"LR\"lies inbetween colliding robos.They must wait till the colliding robos look on their new neighbor to decide on collision For eg in Configuration ```\"RLLL\"``` The Fate of the robos in index 2,3 can be decided only after the collision hence they must wait for it\\n\\n# Approach\\nLets say a robo and their characterstics to be ```Node```\\nLets simulate the collision of each ```Node``` by choosing all ```NodePais```according to their nearest distance between them\\nWe can use \"MinHeap\" for storing all NodePairs\\nWhile poping each nodepais 3 Conditions arise\\n1) ```leftNode``` and ```rightNode``` has same health\\n2) ```leftNode``` has greater health\\n3) ```rightNode``` has greater health\\n\\nIn all Cases delete their appropirate nodes and find for new Colliding neighbor\\n\\n# Complexity\\n- Time complexity:\\nBest Case : N (When there are no colliding robos)\\nWorst Case : (N-1)*log(N-1) (When there are N-1 Collisions Possible)\\n\\n- Space complexity:\\nO(N) Heap Space\\n\\n# Code\\n```\\nclass Solution {\\n\\n    enum Directions{\\n        LEFT,\\n        RIGHT\\n    }\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Node> sortedRobotList = IntStream.range(0, positions.length)\\n                .mapToObj(i -> new Node(positions[i], directions.charAt(i), i))\\n                .sorted()\\n                .collect(Collectors.toList());\\n\\n        LinkedListOptimized<Node> optimizedLinkedList = new LinkedListOptimized<>();\\n        for(Node node:sortedRobotList){\\n            optimizedLinkedList.add(node);\\n        }\\n\\n        PriorityQueue<NodePair> minHeap = new PriorityQueue<>();\\n        int currentIndex = 0;\\n\\n        //populating the minHeap Inititally\\n        while (currentIndex<positions.length-1){\\n            Node firstNode = sortedRobotList.get(currentIndex);\\n            if(firstNode.direction.equals(Directions.LEFT)){\\n                currentIndex++;\\n                continue;\\n            }\\n            Node secondNode = sortedRobotList.get(currentIndex+1);\\n            if(secondNode.direction.equals(Directions.RIGHT)){\\n                currentIndex++;\\n                continue;\\n            }\\n            minHeap.add(new NodePair(firstNode,secondNode));\\n            currentIndex++;\\n        }\\n\\n\\n        while (!minHeap.isEmpty()){\\n            NodePair nodePair = minHeap.poll();\\n            Node rightNode = nodePair.rightNode;\\n            Node leftNode = nodePair.leftNode;\\n\\n            BiConsumer<Node,Node> biConsumerWhenLeftRemoval = (leftNode1, rightNode1) -> {\\n                rightNode1.position = (rightNode.position + leftNode.position)/2;\\n                if(leftNode1 !=null && leftNode1.direction.equals(Directions.RIGHT)\\n                        && rightNode1 !=null && rightNode1.direction.equals(Directions.LEFT)){\\n                    minHeap.add(new NodePair(leftNode1, rightNode1));\\n                }\\n            };\\n            BiConsumer<Node,Node> biConsumerWhenRightRemoval = (leftNode1, rightNode1) -> {\\n                leftNode1.position = (rightNode.position + leftNode.position)/2;\\n                if(leftNode1 !=null && leftNode1.direction.equals(Directions.RIGHT)\\n                        && rightNode1 !=null && rightNode1.direction.equals(Directions.LEFT)){\\n                    minHeap.add(new NodePair(leftNode1, rightNode1));\\n                }\\n            };\\n            BiConsumer<Node,Node> biConsumerWhenLeftAndRightRemoval = (leftNode1, rightNode1) -> {\\n                if(leftNode1 !=null && leftNode1.direction.equals(Directions.RIGHT)\\n                        && rightNode1 !=null && rightNode1.direction.equals(Directions.LEFT)){\\n                    minHeap.add(new NodePair(leftNode1, rightNode1));\\n                }\\n            };\\n\\n\\n            int leftNodeHealth = healths[leftNode.index];\\n            int rightNodeHealth = healths[rightNode.index];\\n\\n            if(leftNodeHealth==rightNodeHealth){\\n                optimizedLinkedList.remove(leftNode,(o1,o2)->{});\\n                optimizedLinkedList.remove(rightNode,biConsumerWhenLeftAndRightRemoval);\\n\\n                healths[leftNode.index] = 0;\\n                healths[rightNode.index] = 0;\\n            }\\n            if(leftNodeHealth>rightNodeHealth){\\n                optimizedLinkedList.remove(rightNode,biConsumerWhenRightRemoval);\\n                healths[leftNode.index]--;\\n                healths[rightNode.index]=0;\\n            }\\n            if(rightNodeHealth>leftNodeHealth){\\n                optimizedLinkedList.remove(leftNode,biConsumerWhenLeftRemoval);\\n                healths[rightNode.index]--;\\n                healths[leftNode.index]=0;\\n            }\\n        }\\n\\n\\n        List<Integer> resultList = new ArrayList<>();\\n        for(int i:healths){\\n            if(i!=0){\\n                resultList.add(i);\\n            }\\n        }\\n        return resultList;\\n    }\\n\\n}\\n\\n/**\\n * Optimized linked list to perfrom O(1) Addition and O(1) removal of any node\\n * @param <T>\\n */\\nclass LinkedListOptimized<T>{\\n    private LinkedListNode<T> head;\\n    private LinkedListNode<T> tail;\\n\\n    Map<T,LinkedListNode<T>> mapToNode = new HashMap<>();\\n\\n    public T getLeft(){\\n        if(head!=null){\\n            return head.item;\\n        }\\n        return null;\\n    }\\n\\n    public T getRight(){\\n        if(tail!=null){\\n            return tail.item;\\n        }\\n        return null;\\n    }\\n\\n    public void add(T node){\\n        if (head==null && tail==null){\\n            LinkedListNode<T> linkedListNode = makeLinkedListNode(node,null,null);\\n            this.head = linkedListNode;\\n            this.tail = linkedListNode;\\n            return;\\n        }\\n\\n        LinkedListNode<T> linkedListNode = makeLinkedListNode(node,null,tail);\\n        tail.next = linkedListNode;\\n        linkedListNode.before = tail;\\n        tail = linkedListNode;\\n    }\\n\\n    /**\\n     * Modified removal that accepts a CallBack to be operated on two new joining nodes\\n     * @param node\\n     * @param biConsumer\\n     */\\n    public void remove(T node,BiConsumer<T,T> biConsumer){\\n        LinkedListNode<T> linkedListNode = mapToNode.get(node);\\n        if (linkedListNode==null){\\n            return;\\n        }\\n        LinkedListNode<T> before = linkedListNode.before;\\n        LinkedListNode<T> next = linkedListNode.next;\\n        if(before!=null){\\n            before.next = next;\\n        }\\n        if(next!=null){\\n            next.before = before;\\n        }\\n        mapToNode.remove(node);\\n\\n        T beforeItem = before != null ? before.item : null;\\n        T nextItem = next != null ? next.item : null;\\n        biConsumer.accept(beforeItem,nextItem);\\n    }\\n\\n    private LinkedListNode<T> makeLinkedListNode(T node,LinkedListNode<T> next,LinkedListNode<T> before){\\n        LinkedListNode<T> linkedListNode = new LinkedListNode<>(node,next,before);\\n        mapToNode.put(node,linkedListNode);\\n        return linkedListNode;\\n    }\\n}\\n\\n/**\\n * Represents the Node in LinkedList\\n * All the Operations on the LinkedList is performed in this\\n * @param <T>\\n */\\nclass LinkedListNode<T>{\\n    public T item;\\n    public LinkedListNode<T> next;\\n    public LinkedListNode<T> before;\\n\\n    public LinkedListNode(T item, LinkedListNode<T> next, LinkedListNode<T> before) {\\n        this.item = item;\\n        this.next = next;\\n        this.before = before;\\n    }\\n}\\n\\n/**\\n * Represents a Robot with their Information\\n */\\nclass Node implements Comparable<Node>{\\n    public float position;\\n    public Solution.Directions direction;\\n    public int index;\\n\\n    public Node(int position, char direction, int index) {\\n        this.position = position;\\n        this.direction = direction == \\'L\\'? Solution.Directions.LEFT: Solution.Directions.RIGHT;\\n        this.index = index;\\n    }\\n\\n    @Override\\n    public int compareTo(Node o) {\\n        return (int) (this.position - o.position);\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"Node{\" +\\n                \"position=\" + position +\\n                \", direction=\" + direction +\\n                \", index=\" + index +\\n                \\'}\\';\\n    }\\n}\\n\\n/**\\n * This represents a Pair of robots that can Collide\\n */\\nclass NodePair implements Comparable<NodePair>{\\n    public Node leftNode;\\n\\n    public NodePair(Node leftNode, Node rightNode) {\\n        this.leftNode = leftNode;\\n        this.rightNode = rightNode;\\n    }\\n\\n    public Node rightNode;\\n\\n    @Override\\n    public int compareTo(NodePair o) {\\n        float thisDifference = rightNode.position - leftNode.position;\\n        float thatDifference = o.rightNode.position - o.leftNode.position;\\n\\n        return (int)(thisDifference - thatDifference);\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"NodePair{\" +\\n                \"leftNode=\" + leftNode +\\n                \", rightNode=\" + rightNode +\\n                \\'}\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\"RLLL\"```\n```Node```\n```Node```\n```NodePais```\n```leftNode```\n```rightNode```\n```leftNode```\n```rightNode```\n```\\nclass Solution {\\n\\n    enum Directions{\\n        LEFT,\\n        RIGHT\\n    }\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Node> sortedRobotList = IntStream.range(0, positions.length)\\n                .mapToObj(i -> new Node(positions[i], directions.charAt(i), i))\\n                .sorted()\\n                .collect(Collectors.toList());\\n\\n        LinkedListOptimized<Node> optimizedLinkedList = new LinkedListOptimized<>();\\n        for(Node node:sortedRobotList){\\n            optimizedLinkedList.add(node);\\n        }\\n\\n        PriorityQueue<NodePair> minHeap = new PriorityQueue<>();\\n        int currentIndex = 0;\\n\\n        //populating the minHeap Inititally\\n        while (currentIndex<positions.length-1){\\n            Node firstNode = sortedRobotList.get(currentIndex);\\n            if(firstNode.direction.equals(Directions.LEFT)){\\n                currentIndex++;\\n                continue;\\n            }\\n            Node secondNode = sortedRobotList.get(currentIndex+1);\\n            if(secondNode.direction.equals(Directions.RIGHT)){\\n                currentIndex++;\\n                continue;\\n            }\\n            minHeap.add(new NodePair(firstNode,secondNode));\\n            currentIndex++;\\n        }\\n\\n\\n        while (!minHeap.isEmpty()){\\n            NodePair nodePair = minHeap.poll();\\n            Node rightNode = nodePair.rightNode;\\n            Node leftNode = nodePair.leftNode;\\n\\n            BiConsumer<Node,Node> biConsumerWhenLeftRemoval = (leftNode1, rightNode1) -> {\\n                rightNode1.position = (rightNode.position + leftNode.position)/2;\\n                if(leftNode1 !=null && leftNode1.direction.equals(Directions.RIGHT)\\n                        && rightNode1 !=null && rightNode1.direction.equals(Directions.LEFT)){\\n                    minHeap.add(new NodePair(leftNode1, rightNode1));\\n                }\\n            };\\n            BiConsumer<Node,Node> biConsumerWhenRightRemoval = (leftNode1, rightNode1) -> {\\n                leftNode1.position = (rightNode.position + leftNode.position)/2;\\n                if(leftNode1 !=null && leftNode1.direction.equals(Directions.RIGHT)\\n                        && rightNode1 !=null && rightNode1.direction.equals(Directions.LEFT)){\\n                    minHeap.add(new NodePair(leftNode1, rightNode1));\\n                }\\n            };\\n            BiConsumer<Node,Node> biConsumerWhenLeftAndRightRemoval = (leftNode1, rightNode1) -> {\\n                if(leftNode1 !=null && leftNode1.direction.equals(Directions.RIGHT)\\n                        && rightNode1 !=null && rightNode1.direction.equals(Directions.LEFT)){\\n                    minHeap.add(new NodePair(leftNode1, rightNode1));\\n                }\\n            };\\n\\n\\n            int leftNodeHealth = healths[leftNode.index];\\n            int rightNodeHealth = healths[rightNode.index];\\n\\n            if(leftNodeHealth==rightNodeHealth){\\n                optimizedLinkedList.remove(leftNode,(o1,o2)->{});\\n                optimizedLinkedList.remove(rightNode,biConsumerWhenLeftAndRightRemoval);\\n\\n                healths[leftNode.index] = 0;\\n                healths[rightNode.index] = 0;\\n            }\\n            if(leftNodeHealth>rightNodeHealth){\\n                optimizedLinkedList.remove(rightNode,biConsumerWhenRightRemoval);\\n                healths[leftNode.index]--;\\n                healths[rightNode.index]=0;\\n            }\\n            if(rightNodeHealth>leftNodeHealth){\\n                optimizedLinkedList.remove(leftNode,biConsumerWhenLeftRemoval);\\n                healths[rightNode.index]--;\\n                healths[leftNode.index]=0;\\n            }\\n        }\\n\\n\\n        List<Integer> resultList = new ArrayList<>();\\n        for(int i:healths){\\n            if(i!=0){\\n                resultList.add(i);\\n            }\\n        }\\n        return resultList;\\n    }\\n\\n}\\n\\n/**\\n * Optimized linked list to perfrom O(1) Addition and O(1) removal of any node\\n * @param <T>\\n */\\nclass LinkedListOptimized<T>{\\n    private LinkedListNode<T> head;\\n    private LinkedListNode<T> tail;\\n\\n    Map<T,LinkedListNode<T>> mapToNode = new HashMap<>();\\n\\n    public T getLeft(){\\n        if(head!=null){\\n            return head.item;\\n        }\\n        return null;\\n    }\\n\\n    public T getRight(){\\n        if(tail!=null){\\n            return tail.item;\\n        }\\n        return null;\\n    }\\n\\n    public void add(T node){\\n        if (head==null && tail==null){\\n            LinkedListNode<T> linkedListNode = makeLinkedListNode(node,null,null);\\n            this.head = linkedListNode;\\n            this.tail = linkedListNode;\\n            return;\\n        }\\n\\n        LinkedListNode<T> linkedListNode = makeLinkedListNode(node,null,tail);\\n        tail.next = linkedListNode;\\n        linkedListNode.before = tail;\\n        tail = linkedListNode;\\n    }\\n\\n    /**\\n     * Modified removal that accepts a CallBack to be operated on two new joining nodes\\n     * @param node\\n     * @param biConsumer\\n     */\\n    public void remove(T node,BiConsumer<T,T> biConsumer){\\n        LinkedListNode<T> linkedListNode = mapToNode.get(node);\\n        if (linkedListNode==null){\\n            return;\\n        }\\n        LinkedListNode<T> before = linkedListNode.before;\\n        LinkedListNode<T> next = linkedListNode.next;\\n        if(before!=null){\\n            before.next = next;\\n        }\\n        if(next!=null){\\n            next.before = before;\\n        }\\n        mapToNode.remove(node);\\n\\n        T beforeItem = before != null ? before.item : null;\\n        T nextItem = next != null ? next.item : null;\\n        biConsumer.accept(beforeItem,nextItem);\\n    }\\n\\n    private LinkedListNode<T> makeLinkedListNode(T node,LinkedListNode<T> next,LinkedListNode<T> before){\\n        LinkedListNode<T> linkedListNode = new LinkedListNode<>(node,next,before);\\n        mapToNode.put(node,linkedListNode);\\n        return linkedListNode;\\n    }\\n}\\n\\n/**\\n * Represents the Node in LinkedList\\n * All the Operations on the LinkedList is performed in this\\n * @param <T>\\n */\\nclass LinkedListNode<T>{\\n    public T item;\\n    public LinkedListNode<T> next;\\n    public LinkedListNode<T> before;\\n\\n    public LinkedListNode(T item, LinkedListNode<T> next, LinkedListNode<T> before) {\\n        this.item = item;\\n        this.next = next;\\n        this.before = before;\\n    }\\n}\\n\\n/**\\n * Represents a Robot with their Information\\n */\\nclass Node implements Comparable<Node>{\\n    public float position;\\n    public Solution.Directions direction;\\n    public int index;\\n\\n    public Node(int position, char direction, int index) {\\n        this.position = position;\\n        this.direction = direction == \\'L\\'? Solution.Directions.LEFT: Solution.Directions.RIGHT;\\n        this.index = index;\\n    }\\n\\n    @Override\\n    public int compareTo(Node o) {\\n        return (int) (this.position - o.position);\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"Node{\" +\\n                \"position=\" + position +\\n                \", direction=\" + direction +\\n                \", index=\" + index +\\n                \\'}\\';\\n    }\\n}\\n\\n/**\\n * This represents a Pair of robots that can Collide\\n */\\nclass NodePair implements Comparable<NodePair>{\\n    public Node leftNode;\\n\\n    public NodePair(Node leftNode, Node rightNode) {\\n        this.leftNode = leftNode;\\n        this.rightNode = rightNode;\\n    }\\n\\n    public Node rightNode;\\n\\n    @Override\\n    public int compareTo(NodePair o) {\\n        float thisDifference = rightNode.position - leftNode.position;\\n        float thatDifference = o.rightNode.position - o.leftNode.position;\\n\\n        return (int)(thisDifference - thatDifference);\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"NodePair{\" +\\n                \"leftNode=\" + leftNode +\\n                \", rightNode=\" + rightNode +\\n                \\'}\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682408,
                "title": "detailed-explanation-easy-to-understand-stack-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI reccomend solving the problem - 735. Asteroid Collision before doing this. If you know that problem, this is very similar. We use the concept of relative velocity. We can assume the robots moving towards right are at rest. And robots moving to left are moving with twice the velocity. (however we aren\\'t concered about velocity).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Start moving in increasing order of positions\\n2. If you find a robot moving right, just push it in stack. \\n3. If you find robot moving to left, keep poping the stack until that robot moving to left can destroy the robot present in stack. Here pop means we destroy a robot already present in the stack. On popping, decrease the health of current robot by 1, and make the health of popped robot as 0 (as it gets destroyed)\\n4. If the stack gets empty or you find that last robot was moving left, insert the current robot in stack. Don\\'t forget to update the new health of current robot.\\n5. If stack is non empty and top robot is moving right and has health greater than current robot, current robot will get destroyed, so update it\\'s health to 0. Also the health of top robot in stack will decrease by one.\\n6. If stack is non empty and top robot is moving right and has health equal to current robot, destroy both robots, i.e., update health of both to zero and remove the top robot from stack.\\n7. At last, push the health of those robots which has health greater than 0 (in the order of elements in positions vector)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) \\n    {\\n        int n=positions.size();\\n        stack <int> st;\\n        map <int,int> mp;\\n        map <int,char> dir;\\n        for (int i=0; i<n; i++)\\n        {\\n            mp[positions[i]]=healths[i];\\n            dir[positions[i]]=directions[i];\\n        }\\n        \\n        for (auto it:mp)\\n        {\\n            int pos = it.first;\\n            int hp = it.second;\\n            char d = dir[it.first];\\n\\n            if (d==\\'R\\')\\n            {\\n                st.push(pos);\\n            }\\n\\n            else\\n            {\\n                while(!st.empty() && dir[st.top()]==\\'R\\' && mp[st.top()]<hp)\\n                {\\n                    hp--;\\n                    mp[st.top()]=0;\\n                    st.pop();\\n                }\\n\\n                if (st.empty() || dir[st.top()]==\\'L\\')\\n                {\\n                    st.push(pos);\\n                    mp[pos]=hp;\\n                }\\n                    \\n                else if (mp[st.top()]>hp)\\n                {\\n                    mp[st.top()]--;\\n                    mp[pos]=0;\\n                }\\n                else\\n                {\\n                    mp[st.top()]=0;\\n                    mp[pos]=0;\\n                    st.pop();\\n                }\\n                \\n            }\\n        }\\n\\n        vector<int>ans;\\n        for (auto it:positions)\\n        {\\n            if (mp[it]!=0)\\n                ans.push_back(mp[it]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nIf you have any doubts, ask me i comments. \\nIf you found it helpful, do give it an upvote.\\nThank you!",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) \\n    {\\n        int n=positions.size();\\n        stack <int> st;\\n        map <int,int> mp;\\n        map <int,char> dir;\\n        for (int i=0; i<n; i++)\\n        {\\n            mp[positions[i]]=healths[i];\\n            dir[positions[i]]=directions[i];\\n        }\\n        \\n        for (auto it:mp)\\n        {\\n            int pos = it.first;\\n            int hp = it.second;\\n            char d = dir[it.first];\\n\\n            if (d==\\'R\\')\\n            {\\n                st.push(pos);\\n            }\\n\\n            else\\n            {\\n                while(!st.empty() && dir[st.top()]==\\'R\\' && mp[st.top()]<hp)\\n                {\\n                    hp--;\\n                    mp[st.top()]=0;\\n                    st.pop();\\n                }\\n\\n                if (st.empty() || dir[st.top()]==\\'L\\')\\n                {\\n                    st.push(pos);\\n                    mp[pos]=hp;\\n                }\\n                    \\n                else if (mp[st.top()]>hp)\\n                {\\n                    mp[st.top()]--;\\n                    mp[pos]=0;\\n                }\\n                else\\n                {\\n                    mp[st.top()]=0;\\n                    mp[pos]=0;\\n                    st.pop();\\n                }\\n                \\n            }\\n        }\\n\\n        vector<int>ans;\\n        for (auto it:positions)\\n        {\\n            if (mp[it]!=0)\\n                ans.push_back(mp[it]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682339,
                "title": "sort-and-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, P: List[int], H: List[int], D: str) -> List[int]:\\n        REM = []\\n        for i in sorted(list(range(len(P))), key = lambda x: P[x]):\\n            EQ = False\\n            while REM and D[REM[-1]] == \\'R\\' and D[i] == \\'L\\':\\n                j = REM.pop()\\n                a, b = H[i], H[j]\\n                if a == b:\\n                    H[i], H[j], EQ = 0, 0, True\\n                    break\\n                elif a > b:\\n                    H[i], H[j] = H[i] - 1, 0\\n                else:\\n                    H[i], H[j] = 0, H[j] - 1\\n                    i = j\\n            if not EQ: REM.append(i)\\n        return [H[i] for i in sorted(REM)] if REM else []\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, P: List[int], H: List[int], D: str) -> List[int]:\\n        REM = []\\n        for i in sorted(list(range(len(P))), key = lambda x: P[x]):\\n            EQ = False\\n            while REM and D[REM[-1]] == \\'R\\' and D[i] == \\'L\\':\\n                j = REM.pop()\\n                a, b = H[i], H[j]\\n                if a == b:\\n                    H[i], H[j], EQ = 0, 0, True\\n                    break\\n                elif a > b:\\n                    H[i], H[j] = H[i] - 1, 0\\n                else:\\n                    H[i], H[j] = 0, H[j] - 1\\n                    i = j\\n            if not EQ: REM.append(i)\\n        return [H[i] for i in sorted(REM)] if REM else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682305,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nprerequisite: https://leetcode.com/problems/movement-of-robots/description/\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere the problem is with **position and index**, meaning positions are not in order of index, so sort it and store it corresponding position which will help you to solve normally\\n- Then store the idx of robots according to their sorted position in another vector, lets say **v**\\n- Traverse according to **v** and update the values in health (taking help of a stack ) \\n- finally store the non zero values in another result vector \\n \\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string dir) {\\n        map<int,int>m;\\n        for(int i=0;i<pos.size();i++){\\n            m[pos[i]]=i;\\n        }\\n        vector<int>v;//wchich idx robot\\n        for(auto it:m)\\n        v.push_back(it.second);\\n\\n        int i=0;\\n        stack<int>st;\\n        while(i<pos.size()){\\n            if(!st.empty() && dir[v[i]]==\\'L\\' && dir[st.top()]==\\'R\\'){\\n                if(h[st.top()]==h[v[i]]){\\n                 h[st.top()]=0; h[v[i]]=0;  \\n                st.pop();\\n                i++;\\n                }else if(h[st.top()]>h[v[i]]){\\n                h[st.top()]--;\\n                h[v[i]]=0;\\n                i++;\\n                }else{\\n                    h[st.top()]=0;\\n                    st.pop();\\n                    h[v[i]]--;\\n                }\\n            }else{\\n                st.push(v[i]);\\n                i++;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int j=0;j<h.size();j++){\\n            if(h[j])\\n            ans.push_back(h[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Brainteaser",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& h, string dir) {\\n        map<int,int>m;\\n        for(int i=0;i<pos.size();i++){\\n            m[pos[i]]=i;\\n        }\\n        vector<int>v;//wchich idx robot\\n        for(auto it:m)\\n        v.push_back(it.second);\\n\\n        int i=0;\\n        stack<int>st;\\n        while(i<pos.size()){\\n            if(!st.empty() && dir[v[i]]==\\'L\\' && dir[st.top()]==\\'R\\'){\\n                if(h[st.top()]==h[v[i]]){\\n                 h[st.top()]=0; h[v[i]]=0;  \\n                st.pop();\\n                i++;\\n                }else if(h[st.top()]>h[v[i]]){\\n                h[st.top()]--;\\n                h[v[i]]=0;\\n                i++;\\n                }else{\\n                    h[st.top()]=0;\\n                    st.pop();\\n                    h[v[i]]--;\\n                }\\n            }else{\\n                st.push(v[i]);\\n                i++;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int j=0;j<h.size();j++){\\n            if(h[j])\\n            ans.push_back(h[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682242,
                "title": "clean-code-and-easy-way-to-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        \\n        \\n        List<Integer>res=new ArrayList<>();\\n        \\n        List<Integer>robots=new ArrayList<>();\\n        \\n        for(int i=0;i<positions.length;i++){\\n            \\n            robots.add(i);\\n        }\\n        \\n        // sort the array in such a way that less positions robots will lie left side and greater positions value lie in right side\\n        Collections.sort(robots,(a,b)->{\\n            \\n            return  positions[a]-positions[b];\\n        });\\n        \\n        \\n        Stack<Integer>st=new Stack<>();\\n        \\n        \\n        \\n        for(int i=0;i<robots.size();i++){\\n            \\n            \\n            int curr_robot_index=robots.get(i);\\n            \\n            int prev_robot_index=curr_robot_index;\\n            \\n            boolean check=true;\\n            \\n            // now check while this is alive \\n            \\n            \\n            while(!st.isEmpty()){\\n                \\n                 prev_robot_index=st.pop();\\n            \\n                char prev_robot_dir=directions.charAt(prev_robot_index);\\n            \\n               int prev_robot_health=healths[prev_robot_index];\\n                \\n                \\n                char curr_robot_dir=directions.charAt(curr_robot_index);\\n                int curr_robot_health=healths[curr_robot_index];\\n                \\n                \\n                if(curr_robot_dir==\\'L\\'  && prev_robot_dir==\\'R\\'){\\n                    \\n                    // now if both have equal headlth capacity both will be destroy\\n                    \\n                    if(curr_robot_health==prev_robot_health){\\n                        check=false;  // means we don\\'t have to add you will be feel after seeing the next line of codes\\n                        break;\\n                    }\\n                    \\n                    // if left has more capacity then decremanet by 1\\n                    else if(curr_robot_health>prev_robot_health){\\n                        healths[curr_robot_index]--;\\n                    }\\n                    // if right has more  capacity \\n                    else if(curr_robot_health<prev_robot_health){\\n                        healths[prev_robot_index]--;\\n                        // now this will become prev\\n                        curr_robot_index=prev_robot_index;\\n                    }\\n                    \\n                    \\n                }\\n                \\n                // now all three case when collsions is not possible\\n                \\n                else{\\n                    \\n                    st.add(prev_robot_index);\\n                    break;\\n                }\\n            }\\n            \\n            \\n            if(check==true){\\n                \\n                st.add(curr_robot_index);\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        robots.clear();\\n        \\n        while(!st.isEmpty()){\\n            \\n            robots.add(st.pop());\\n        }\\n        \\n        Collections.sort(robots,(a,b)->{\\n            return a-b;\\n        });\\n        \\n        for(int i=0;i<robots.size();i++){\\n            \\n            res.add(healths[robots.get(i)]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        \\n        \\n        List<Integer>res=new ArrayList<>();\\n        \\n        List<Integer>robots=new ArrayList<>();\\n        \\n        for(int i=0;i<positions.length;i++){\\n            \\n            robots.add(i);\\n        }\\n        \\n        // sort the array in such a way that less positions robots will lie left side and greater positions value lie in right side\\n        Collections.sort(robots,(a,b)->{\\n            \\n            return  positions[a]-positions[b];\\n        });\\n        \\n        \\n        Stack<Integer>st=new Stack<>();\\n        \\n        \\n        \\n        for(int i=0;i<robots.size();i++){\\n            \\n            \\n            int curr_robot_index=robots.get(i);\\n            \\n            int prev_robot_index=curr_robot_index;\\n            \\n            boolean check=true;\\n            \\n            // now check while this is alive \\n            \\n            \\n            while(!st.isEmpty()){\\n                \\n                 prev_robot_index=st.pop();\\n            \\n                char prev_robot_dir=directions.charAt(prev_robot_index);\\n            \\n               int prev_robot_health=healths[prev_robot_index];\\n                \\n                \\n                char curr_robot_dir=directions.charAt(curr_robot_index);\\n                int curr_robot_health=healths[curr_robot_index];\\n                \\n                \\n                if(curr_robot_dir==\\'L\\'  && prev_robot_dir==\\'R\\'){\\n                    \\n                    // now if both have equal headlth capacity both will be destroy\\n                    \\n                    if(curr_robot_health==prev_robot_health){\\n                        check=false;  // means we don\\'t have to add you will be feel after seeing the next line of codes\\n                        break;\\n                    }\\n                    \\n                    // if left has more capacity then decremanet by 1\\n                    else if(curr_robot_health>prev_robot_health){\\n                        healths[curr_robot_index]--;\\n                    }\\n                    // if right has more  capacity \\n                    else if(curr_robot_health<prev_robot_health){\\n                        healths[prev_robot_index]--;\\n                        // now this will become prev\\n                        curr_robot_index=prev_robot_index;\\n                    }\\n                    \\n                    \\n                }\\n                \\n                // now all three case when collsions is not possible\\n                \\n                else{\\n                    \\n                    st.add(prev_robot_index);\\n                    break;\\n                }\\n            }\\n            \\n            \\n            if(check==true){\\n                \\n                st.add(curr_robot_index);\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        robots.clear();\\n        \\n        while(!st.isEmpty()){\\n            \\n            robots.add(st.pop());\\n        }\\n        \\n        Collections.sort(robots,(a,b)->{\\n            return a-b;\\n        });\\n        \\n        for(int i=0;i<robots.size();i++){\\n            \\n            res.add(healths[robots.get(i)]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682152,
                "title": "c-commented-solution-asteroid-collision-variation-easy-and-understandable",
                "content": "# Intuition\\nBasic intution that \"Asteroid collision\" problem follows . If you haven\\'t solved it yet then, solve it first. This problem has the same approach but has slightly more implementation.\\n\\nWe choos \\'R\\' character in direction as +ve, and \\'L\\' as -ve. And we compare the opposite directioned robots and push or pop according to constraints given.\\n\\nWe use hashtable to store the pos and health of robots.\\n\\n# Approach\\nStore the pos and health value in the hash table.\\n\\nTraverse the map.\\n\\nPush the current if the stack is empty. And keep a check of the sign of the current health value, if +ve push and continue else we check for 3 conditions:\\n\\n1) We pop out the stack top elements that are positive and are less than the curren health. We increment current health as it will be negative. (to decrease the val of abs(health) we need to add 1 which will decrement the mod of health).\\n\\n2) We then check if the top element is equal to current abs health value. If yes , pop the element out and continue as both robots are to moved away.\\n\\n3) If the top element is greater than abs value of health, we decrement the top element health val by 1 as it is +ve and push it with its position back into the stack.\\n\\nIf the element current element followed 1st condition we just push it with its position.\\n\\nNote:\\nWe have to return the final health values in the order of given positon values, so we take a map and store the position and final health from the stack.\\n\\nThen return array according to the required order.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the size of positions vector.\\n\\n- Space complexity:\\nO(n) where n is the size of positions vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n\\n        // map to store initial {pos, health} values\\n        map<int,int>mp;\\n        int n = positions.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            // storing according to the given direction\\n            if(directions[i]==\\'R\\')mp[positions[i]] = healths[i];\\n            else  mp[positions[i]] = -healths[i];\\n        }\\n\\n        stack<pair<int,int>>st;\\n        for(auto it : mp)\\n        {\\n            int pos = it.first;\\n            int hlth = it.second;\\n\\n            if(st.empty())\\n            {\\n                st.push({pos, hlth});\\n            }else{\\n                if(hlth>0)\\n                {\\n                    //positive health values are only pushed\\n                    st.push({pos, hlth});\\n                }else{\\n\\n                    // Remove elements that are less than the current absolute health value.\\n                    // 1st condition\\n                    while(!st.empty() and st.top().second>0 and st.top().second<abs(hlth)){\\n                        st.pop();\\n                        // Decrement the value of current health (as the val will be -ve ++ is to be done)\\n                        hlth++;\\n                    }\\n\\n                    // 2nd condition\\n                    if(!st.empty() and st.top().second==abs(hlth)){\\n                        st.pop();\\n                        continue;\\n                    }\\n\\n                    // 3rd condition\\n                    if(!st.empty() and st.top().second>abs(hlth)){\\n                        int nval = st.top().second;\\n                        int npos = st.top().first;\\n                        st.pop();\\n                        nval--;\\n                        st.push({npos, nval});\\n                        continue;\\n                    }\\n                    // push if the curr value follows 1st condition\\n                    st.push({pos, hlth});\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        //map to store according to required order.\\n        unordered_map<int,int>m1;\\n        while(!st.empty())\\n        {\\n            m1[st.top().first]=abs(st.top().second);\\n            st.pop();\\n        }\\n\\n        for(auto it : positions)\\n        {\\n            if(m1.find(it)!=m1.end())\\n            {\\n                ans.push_back(m1[it]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n\\n        // map to store initial {pos, health} values\\n        map<int,int>mp;\\n        int n = positions.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            // storing according to the given direction\\n            if(directions[i]==\\'R\\')mp[positions[i]] = healths[i];\\n            else  mp[positions[i]] = -healths[i];\\n        }\\n\\n        stack<pair<int,int>>st;\\n        for(auto it : mp)\\n        {\\n            int pos = it.first;\\n            int hlth = it.second;\\n\\n            if(st.empty())\\n            {\\n                st.push({pos, hlth});\\n            }else{\\n                if(hlth>0)\\n                {\\n                    //positive health values are only pushed\\n                    st.push({pos, hlth});\\n                }else{\\n\\n                    // Remove elements that are less than the current absolute health value.\\n                    // 1st condition\\n                    while(!st.empty() and st.top().second>0 and st.top().second<abs(hlth)){\\n                        st.pop();\\n                        // Decrement the value of current health (as the val will be -ve ++ is to be done)\\n                        hlth++;\\n                    }\\n\\n                    // 2nd condition\\n                    if(!st.empty() and st.top().second==abs(hlth)){\\n                        st.pop();\\n                        continue;\\n                    }\\n\\n                    // 3rd condition\\n                    if(!st.empty() and st.top().second>abs(hlth)){\\n                        int nval = st.top().second;\\n                        int npos = st.top().first;\\n                        st.pop();\\n                        nval--;\\n                        st.push({npos, nval});\\n                        continue;\\n                    }\\n                    // push if the curr value follows 1st condition\\n                    st.push({pos, hlth});\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        //map to store according to required order.\\n        unordered_map<int,int>m1;\\n        while(!st.empty())\\n        {\\n            m1[st.top().first]=abs(st.top().second);\\n            st.pop();\\n        }\\n\\n        for(auto it : positions)\\n        {\\n            if(m1.find(it)!=m1.end())\\n            {\\n                ans.push_back(m1[it]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682092,
                "title": "simple-binary-search-and-sorting-stack-solution-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n\\n    def binary_search(self,arr, target):\\n        l = 0\\n        r= len(arr) - 1\\n\\n        while l<=r:\\n            mid = (l + r) // 2\\n            if arr[mid] == target:\\n                return mid\\n            elif arr[mid] < target:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return -1 \\n\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        stack=[]\\n        dirstack=[]\\n        cp=[]\\n        directions=[c for c in directions]\\n        healths = [x for _,x in sorted(zip(positions,healths))]\\n        directions = [x for _,x in sorted(zip(positions,directions))]\\n        np=positions[:]\\n        np.sort()\\n        i=0\\n        while(i<len(positions)):\\n            if(len(stack)==0 or directions[i]==dirstack[-1] or directions[i]==\\'R\\'):\\n                stack.append(healths[i])\\n                dirstack.append(directions[i])\\n                cp.append(np[i])\\n            elif(stack[-1]<healths[i]):\\n                stack.pop()\\n                dirstack.pop()\\n                cp.pop()\\n                healths[i]-=1\\n                i-=1\\n            elif(stack[-1]==healths[i]):\\n                stack.pop()\\n                dirstack.pop()\\n                cp.pop()\\n            else:\\n                stack[-1]-=1\\n            i+=1\\n        ans=[]\\n        for i in positions:\\n            p=self.binary_search(cp,i)\\n            if(p!=-1):ans.append(stack[p])\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Stack",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n\\n    def binary_search(self,arr, target):\\n        l = 0\\n        r= len(arr) - 1\\n\\n        while l<=r:\\n            mid = (l + r) // 2\\n            if arr[mid] == target:\\n                return mid\\n            elif arr[mid] < target:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return -1 \\n\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        stack=[]\\n        dirstack=[]\\n        cp=[]\\n        directions=[c for c in directions]\\n        healths = [x for _,x in sorted(zip(positions,healths))]\\n        directions = [x for _,x in sorted(zip(positions,directions))]\\n        np=positions[:]\\n        np.sort()\\n        i=0\\n        while(i<len(positions)):\\n            if(len(stack)==0 or directions[i]==dirstack[-1] or directions[i]==\\'R\\'):\\n                stack.append(healths[i])\\n                dirstack.append(directions[i])\\n                cp.append(np[i])\\n            elif(stack[-1]<healths[i]):\\n                stack.pop()\\n                dirstack.pop()\\n                cp.pop()\\n                healths[i]-=1\\n                i-=1\\n            elif(stack[-1]==healths[i]):\\n                stack.pop()\\n                dirstack.pop()\\n                cp.pop()\\n            else:\\n                stack[-1]-=1\\n            i+=1\\n        ans=[]\\n        for i in positions:\\n            p=self.binary_search(cp,i)\\n            if(p!=-1):ans.append(stack[p])\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682022,
                "title": "python-sorting-stack-and-sorting",
                "content": "# Intuition\\nsort by position, then put \\'R\\'s on stack and process stack when \\'L\\'s\\n\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        A, stack = sorted((p, h, d, index) for index, (p, h, d) in enumerate(zip(positions, healths, directions))), []\\n        for p, h, d, index in A:\\n            if d == \\'L\\' and  stack:\\n                while stack and h and stack[-1][1] <= h and stack[-1][2] == \\'R\\':\\n                    p2, h2, d2, index2 = stack.pop()\\n                    if h == h2: \\n                        h = 0\\n                        break\\n                    h -= 1\\n                if h > 0 and stack and stack[-1][2] == \\'R\\':\\n                    p2, h2, d2, index2 = stack.pop()\\n                    if h2 > 1: stack.append((p2, h2 - 1, d2 , index2))\\n                    h = 0                                    \\n                if h: stack.append((p, h, d, index))   \\n            else: stack.append((p, h, d, index))\\n        return list(map(lambda x: x[1], sorted(stack, key=lambda x: x[3]))) if stack else []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        A, stack = sorted((p, h, d, index) for index, (p, h, d) in enumerate(zip(positions, healths, directions))), []\\n        for p, h, d, index in A:\\n            if d == \\'L\\' and  stack:\\n                while stack and h and stack[-1][1] <= h and stack[-1][2] == \\'R\\':\\n                    p2, h2, d2, index2 = stack.pop()\\n                    if h == h2: \\n                        h = 0\\n                        break\\n                    h -= 1\\n                if h > 0 and stack and stack[-1][2] == \\'R\\':\\n                    p2, h2, d2, index2 = stack.pop()\\n                    if h2 > 1: stack.append((p2, h2 - 1, d2 , index2))\\n                    h = 0                                    \\n                if h: stack.append((p, h, d, index))   \\n            else: stack.append((p, h, d, index))\\n        return list(map(lambda x: x[1], sorted(stack, key=lambda x: x[3]))) if stack else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681927,
                "title": "java-sorting-stack-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String s) {\\n        int n = healths.length;\\n\\n        Robot[] arr = new Robot[n];\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            map.put(positions[i], i);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int dir = s.charAt(i) == \\'L\\' ? - 1 : 1;\\n            arr[i] = new Robot(positions[i], healths[i], dir);\\n        }\\n\\n        Arrays.sort(arr, (r1, r2) -> Integer.compare(r1.pos, r2.pos));\\n\\n        Stack<Robot> stack = new Stack<>();\\n\\n        for (Robot r : arr) {\\n\\n            if (!stack.isEmpty() && r.direction == -1) {\\n                boolean isEqual = false;\\n                while (!stack.isEmpty() && stack.peek().health <= r.health) {\\n                    if (r.health == stack.peek().health) {\\n                        isEqual = true;\\n                        r.health = 0;\\n                        stack.pop().health = 0;\\n                        break;\\n                    }\\n                    r.health -= 1;\\n                    stack.peek().health = 0;\\n                    stack.pop();\\n                }\\n                if (isEqual) \\n                    continue;\\n\\n                if (!stack.isEmpty()) {\\n                    r.health = 0;\\n                    stack.peek().health -= 1;\\n                }\\n\\n            }\\n            else if (r.direction == 1) {\\n                stack.push(r);\\n            }\\n        }\\n\\n        List<Robot> list = new ArrayList<>();\\n\\n        for (Robot r : arr) {\\n            System.out.println(r.pos + \" \" + r.health);\\n            if (r.health != 0)\\n                list.add(r);\\n        }\\n        \\n        Collections.sort(list, (r1, r2) -> Integer.compare(map.get(r1.pos), map.get(r2.pos)));\\n\\n        List<Integer> ans = new ArrayList<>();\\n        for (Robot r : list)\\n            ans.add(r.health);\\n        \\n        return ans;\\n    }\\n}\\n\\n\\nclass Robot {\\n    int pos;\\n    int health;\\n    int direction;\\n    \\n    public Robot(int  pos, int health, int direction) {\\n        this.pos = pos;\\n        this.health = health;\\n        this.direction = direction;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String s) {\\n        int n = healths.length;\\n\\n        Robot[] arr = new Robot[n];\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            map.put(positions[i], i);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int dir = s.charAt(i) == \\'L\\' ? - 1 : 1;\\n            arr[i] = new Robot(positions[i], healths[i], dir);\\n        }\\n\\n        Arrays.sort(arr, (r1, r2) -> Integer.compare(r1.pos, r2.pos));\\n\\n        Stack<Robot> stack = new Stack<>();\\n\\n        for (Robot r : arr) {\\n\\n            if (!stack.isEmpty() && r.direction == -1) {\\n                boolean isEqual = false;\\n                while (!stack.isEmpty() && stack.peek().health <= r.health) {\\n                    if (r.health == stack.peek().health) {\\n                        isEqual = true;\\n                        r.health = 0;\\n                        stack.pop().health = 0;\\n                        break;\\n                    }\\n                    r.health -= 1;\\n                    stack.peek().health = 0;\\n                    stack.pop();\\n                }\\n                if (isEqual) \\n                    continue;\\n\\n                if (!stack.isEmpty()) {\\n                    r.health = 0;\\n                    stack.peek().health -= 1;\\n                }\\n\\n            }\\n            else if (r.direction == 1) {\\n                stack.push(r);\\n            }\\n        }\\n\\n        List<Robot> list = new ArrayList<>();\\n\\n        for (Robot r : arr) {\\n            System.out.println(r.pos + \" \" + r.health);\\n            if (r.health != 0)\\n                list.add(r);\\n        }\\n        \\n        Collections.sort(list, (r1, r2) -> Integer.compare(map.get(r1.pos), map.get(r2.pos)));\\n\\n        List<Integer> ans = new ArrayList<>();\\n        for (Robot r : list)\\n            ans.add(r.health);\\n        \\n        return ans;\\n    }\\n}\\n\\n\\nclass Robot {\\n    int pos;\\n    int health;\\n    int direction;\\n    \\n    public Robot(int  pos, int health, int direction) {\\n        this.pos = pos;\\n        this.health = health;\\n        this.direction = direction;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681897,
                "title": "line-by-line-comments-high-readability-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        // use a 2D array to store robot\\'s information\\n        int[][] a = new int[n][4];\\n        for (int i = 0; i < n; ++i) {\\n            a[i][0] = i; // index of robot, 0-indexed, used to restore the order for the answer\\n            a[i][1] = positions[i]; // position of robot\\n            a[i][2] = healths[i]; // health of robot\\n            a[i][3] = directions.charAt(i) == \\'L\\' ? 0 : 1; // movement direction: 0: left, 1: right\\n        }\\n        // sort all the robots according to their position,\\n        // so that we can handle robot one by one from left to right\\n        Arrays.sort(a, ((o1, o2) -> o1[1] - o2[1]));\\n        // store robots that move right. The robot moving left will encounter\\n        // the right most robot before it that move right,\\n        // so we use a stack to store these robots.\\n        // After we handle all robots, the robots remained in the stack are survived robots.\\n        Stack<int[]> moveRight = new Stack<>();\\n        // store survived robots that move left\\n        List<int[]> moveLeft = new ArrayList<>();\\n        for (int[] robot : a) { // handle all robots one by one from left to right\\n            if (robot[3] == 1) { // robot move right\\n                moveRight.push(robot); // simply push to the stack\\n            } else { // robot move left, will encounter zero or more robots moving right\\n                while (!moveRight.empty()) {\\n                    int[] peek = moveRight.peek();\\n                    if (peek[2] == robot[2]) {\\n                        // both robots have the same health, they are both removed from the line\\n                        robot[2] = 0;\\n                        moveRight.pop();\\n                        break;\\n                    } else if (peek[2] < robot[2]) {\\n                        // the left robot has lower health, it\\'s remove from the line(the stack)\\n                        // the health of right robot decreases by one\\n                        // the right robot will encounter one or more robot if it\\'s health is greater than zero\\n                        --robot[2];\\n                        moveRight.pop();\\n                    } else {\\n                        // the right robot has lower health,\\n                        robot[2] = 0;\\n                        --peek[2];\\n                        // if the health of the left robot becomes zero, it\\'s dead, remove it from the stack\\n                        if (peek[2] == 0) moveRight.pop();\\n                        break;\\n                    }\\n                }\\n                // the robot moving left kill all robots moving right, it will survive\\n                if (moveRight.empty() && robot[2] > 0) moveLeft.add(robot);\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        if (!moveRight.empty()) {\\n            moveLeft.addAll(moveRight); // add all survived robots moving right to the result set\\n        }\\n        if (!moveLeft.isEmpty()) {\\n            // sort the result set according to robot\\'s index\\n            Collections.sort(moveLeft, ((o1, o2) -> o1[0] - o2[0]));\\n            for (int i = 0; i < moveLeft.size(); ++i) ans.add(moveLeft.get(i)[2]);\\n            return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = positions.length;\\n        // use a 2D array to store robot\\'s information\\n        int[][] a = new int[n][4];\\n        for (int i = 0; i < n; ++i) {\\n            a[i][0] = i; // index of robot, 0-indexed, used to restore the order for the answer\\n            a[i][1] = positions[i]; // position of robot\\n            a[i][2] = healths[i]; // health of robot\\n            a[i][3] = directions.charAt(i) == \\'L\\' ? 0 : 1; // movement direction: 0: left, 1: right\\n        }\\n        // sort all the robots according to their position,\\n        // so that we can handle robot one by one from left to right\\n        Arrays.sort(a, ((o1, o2) -> o1[1] - o2[1]));\\n        // store robots that move right. The robot moving left will encounter\\n        // the right most robot before it that move right,\\n        // so we use a stack to store these robots.\\n        // After we handle all robots, the robots remained in the stack are survived robots.\\n        Stack<int[]> moveRight = new Stack<>();\\n        // store survived robots that move left\\n        List<int[]> moveLeft = new ArrayList<>();\\n        for (int[] robot : a) { // handle all robots one by one from left to right\\n            if (robot[3] == 1) { // robot move right\\n                moveRight.push(robot); // simply push to the stack\\n            } else { // robot move left, will encounter zero or more robots moving right\\n                while (!moveRight.empty()) {\\n                    int[] peek = moveRight.peek();\\n                    if (peek[2] == robot[2]) {\\n                        // both robots have the same health, they are both removed from the line\\n                        robot[2] = 0;\\n                        moveRight.pop();\\n                        break;\\n                    } else if (peek[2] < robot[2]) {\\n                        // the left robot has lower health, it\\'s remove from the line(the stack)\\n                        // the health of right robot decreases by one\\n                        // the right robot will encounter one or more robot if it\\'s health is greater than zero\\n                        --robot[2];\\n                        moveRight.pop();\\n                    } else {\\n                        // the right robot has lower health,\\n                        robot[2] = 0;\\n                        --peek[2];\\n                        // if the health of the left robot becomes zero, it\\'s dead, remove it from the stack\\n                        if (peek[2] == 0) moveRight.pop();\\n                        break;\\n                    }\\n                }\\n                // the robot moving left kill all robots moving right, it will survive\\n                if (moveRight.empty() && robot[2] > 0) moveLeft.add(robot);\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        if (!moveRight.empty()) {\\n            moveLeft.addAll(moveRight); // add all survived robots moving right to the result set\\n        }\\n        if (!moveLeft.isEmpty()) {\\n            // sort the result set according to robot\\'s index\\n            Collections.sort(moveLeft, ((o1, o2) -> o1[0] - o2[0]));\\n            for (int i = 0; i < moveLeft.size(); ++i) ans.add(moveLeft.get(i)[2]);\\n            return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681837,
                "title": "c-easy-stack-similar-to-asteroid-collision",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        \\n        vector<vector<int>> robots;\\n        \\n        for(int i=0; i<n; i++){\\n            robots.push_back({positions[i], healths[i], directions[i] ==\\'R\\' ? 1: -1, i});\\n        }\\n        \\n        sort(robots.begin(), robots.end());\\n        \\n        stack<vector<int>> s;\\n        \\n        for(int i=0; i<n; i++){\\n            if(robots[i][2] == 1) s.push(robots[i]);\\n            \\n            else{\\n                while(!s.empty() && robots[i][2]==-1 && s.top()[2]==1 && robots[i][1] > s.top()[1]){\\n                    s.pop();\\n                    robots[i][1]--;\\n                }\\n            \\n                if(!s.empty() && robots[i][2] == -1 && s.top()[2]==1 && robots[i][1] < s.top()[1]){\\n                    s.top()[1]--;\\n                }\\n            \\n                else if(!s.empty() && robots[i][2]==-1 && s.top()[2]==1 && robots[i][1] == s.top()[1]){\\n                    s.pop();\\n                }\\n            \\n                else s.push(robots[i]);\\n            }\\n        }\\n        \\n        robots.clear();\\n        \\n        while(!s.empty()){\\n            robots.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        sort(robots.begin(), robots.end(), [](auto &v1, auto &v2){return v1[3] < v2[3]; });\\n        \\n        vector<int> ans;\\n        \\n        for(int i=0; i<robots.size();  i++){\\n            ans.push_back(robots[i][1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        int n = positions.size();\\n        \\n        vector<vector<int>> robots;\\n        \\n        for(int i=0; i<n; i++){\\n            robots.push_back({positions[i], healths[i], directions[i] ==\\'R\\' ? 1: -1, i});\\n        }\\n        \\n        sort(robots.begin(), robots.end());\\n        \\n        stack<vector<int>> s;\\n        \\n        for(int i=0; i<n; i++){\\n            if(robots[i][2] == 1) s.push(robots[i]);\\n            \\n            else{\\n                while(!s.empty() && robots[i][2]==-1 && s.top()[2]==1 && robots[i][1] > s.top()[1]){\\n                    s.pop();\\n                    robots[i][1]--;\\n                }\\n            \\n                if(!s.empty() && robots[i][2] == -1 && s.top()[2]==1 && robots[i][1] < s.top()[1]){\\n                    s.top()[1]--;\\n                }\\n            \\n                else if(!s.empty() && robots[i][2]==-1 && s.top()[2]==1 && robots[i][1] == s.top()[1]){\\n                    s.pop();\\n                }\\n            \\n                else s.push(robots[i]);\\n            }\\n        }\\n        \\n        robots.clear();\\n        \\n        while(!s.empty()){\\n            robots.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        sort(robots.begin(), robots.end(), [](auto &v1, auto &v2){return v1[3] < v2[3]; });\\n        \\n        vector<int> ans;\\n        \\n        for(int i=0; i<robots.size();  i++){\\n            ans.push_back(robots[i][1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681678,
                "title": "c-std-list-simulation",
                "content": "# Intuition\\nThis problem can be solved by simulating robot collision process. We use std::list to support fast deletion of robots.\\n\\n# Approach\\nSort robots by position, iterate through list to find pairs of robots that move towards each other. Update robot health and eliminate robots according to problem rules.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        const int sz = positions.size();\\n        struct Robot {\\n            int pos;\\n            int h;\\n            char dir;\\n            int idx;\\n        };\\n        list<Robot> rlist;\\n        for (int i = 0; i < sz; ++i) {\\n            rlist.push_back({positions[i], healths[i], directions[i], i});\\n        }\\n        rlist.sort([&](const auto a, const auto b) {\\n            return a.pos < b.pos;\\n        });\\n\\n        auto iter = rlist.begin();\\n        while (iter != rlist.end()) {\\n            auto next_iter = next(iter);\\n            if (next_iter == rlist.end()) {\\n                break;\\n            }\\n            if (iter->dir == \\'R\\' && next_iter->dir == \\'L\\') {\\n                if (iter->h > next_iter->h) {\\n                    iter->h--;\\n                    rlist.erase(next_iter);\\n                } else if (iter->h < next_iter->h) {\\n                    next_iter->h--;\\n                    const auto prev_iter = iter == rlist.begin() ? next_iter : prev(iter);\\n                    rlist.erase(iter);\\n                    iter = prev_iter;\\n                } else {\\n                    const auto prev_iter = iter == rlist.begin() ? next(next_iter) : prev(iter);\\n                    rlist.erase(iter);\\n                    rlist.erase(next_iter);\\n                    iter = prev_iter;\\n                }\\n            } else {\\n                iter = next_iter;\\n            }\\n        }\\n\\n        rlist.sort([&](const auto a, const auto b) {\\n            return a.idx < b.idx;\\n        });\\n        vector<int> res;\\n        for (const auto& r : rlist) {\\n            res.push_back(r.h);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Simulation",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        const int sz = positions.size();\\n        struct Robot {\\n            int pos;\\n            int h;\\n            char dir;\\n            int idx;\\n        };\\n        list<Robot> rlist;\\n        for (int i = 0; i < sz; ++i) {\\n            rlist.push_back({positions[i], healths[i], directions[i], i});\\n        }\\n        rlist.sort([&](const auto a, const auto b) {\\n            return a.pos < b.pos;\\n        });\\n\\n        auto iter = rlist.begin();\\n        while (iter != rlist.end()) {\\n            auto next_iter = next(iter);\\n            if (next_iter == rlist.end()) {\\n                break;\\n            }\\n            if (iter->dir == \\'R\\' && next_iter->dir == \\'L\\') {\\n                if (iter->h > next_iter->h) {\\n                    iter->h--;\\n                    rlist.erase(next_iter);\\n                } else if (iter->h < next_iter->h) {\\n                    next_iter->h--;\\n                    const auto prev_iter = iter == rlist.begin() ? next_iter : prev(iter);\\n                    rlist.erase(iter);\\n                    iter = prev_iter;\\n                } else {\\n                    const auto prev_iter = iter == rlist.begin() ? next(next_iter) : prev(iter);\\n                    rlist.erase(iter);\\n                    rlist.erase(next_iter);\\n                    iter = prev_iter;\\n                }\\n            } else {\\n                iter = next_iter;\\n            }\\n        }\\n\\n        rlist.sort([&](const auto a, const auto b) {\\n            return a.idx < b.idx;\\n        });\\n        vector<int> res;\\n        for (const auto& r : rlist) {\\n            res.push_back(r.h);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681654,
                "title": "java-solution",
                "content": "```\\nclass Robot {\\n    char dir;\\n    int pos;\\n    int health;\\n    int index;\\n    \\n    public Robot(char dir, int pos, int health, int index) {\\n        this.dir = dir;\\n        this.pos = pos;\\n        this.health = health;\\n        this.index = index;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    boolean willCollide(Robot r1, Robot r2) {\\n        return r1.dir == \\'R\\' && r2.dir == \\'L\\';    \\n    }\\n    \\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = healths.length;\\n        Robot[] robots = new Robot[n];\\n        \\n        List<Robot> robotList = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        \\n        for (int i=0; i < n; i++) {\\n            robots[i] = new Robot(directions.charAt(i), positions[i], healths[i], i);\\n        }\\n        \\n        Arrays.sort(robots, (a, b) -> a.pos - b.pos);\\n        \\n        Stack<Robot> stack = new Stack<>();\\n        \\n        for (int i=0; i < n; i++) {\\n            if (robots[i].dir == \\'R\\') {\\n                stack.push(robots[i]);\\n                continue;\\n            } else {\\n                // clash\\n                while (!stack.isEmpty() && robots[i].health != 0) {\\n                    Robot top = stack.pop();\\n\\n                    if (top.health > robots[i].health) {\\n                        top.health -= 1;\\n                        robots[i].health = 0;\\n                        stack.push(top);\\n                    } else if (top.health < robots[i].health) {\\n                        robots[i].health -= 1;\\n                    } else {\\n                        robots[i].health = 0;\\n                        break;\\n                    }\\n                }\\n\\n                \\n                if (robots[i].health != 0) {\\n                    robotList.add(robots[i]);   \\n                }\\n            }\\n        }\\n        \\n        \\n        while (!stack.empty()) {\\n            robotList.add(stack.pop());    \\n        }\\n        \\n        Collections.sort(robotList, (a, b) -> a.index - b.index);\\n        for (Robot r : robotList) {\\n            ans.add(r.health);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Robot {\\n    char dir;\\n    int pos;\\n    int health;\\n    int index;\\n    \\n    public Robot(char dir, int pos, int health, int index) {\\n        this.dir = dir;\\n        this.pos = pos;\\n        this.health = health;\\n        this.index = index;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    boolean willCollide(Robot r1, Robot r2) {\\n        return r1.dir == \\'R\\' && r2.dir == \\'L\\';    \\n    }\\n    \\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        int n = healths.length;\\n        Robot[] robots = new Robot[n];\\n        \\n        List<Robot> robotList = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        \\n        for (int i=0; i < n; i++) {\\n            robots[i] = new Robot(directions.charAt(i), positions[i], healths[i], i);\\n        }\\n        \\n        Arrays.sort(robots, (a, b) -> a.pos - b.pos);\\n        \\n        Stack<Robot> stack = new Stack<>();\\n        \\n        for (int i=0; i < n; i++) {\\n            if (robots[i].dir == \\'R\\') {\\n                stack.push(robots[i]);\\n                continue;\\n            } else {\\n                // clash\\n                while (!stack.isEmpty() && robots[i].health != 0) {\\n                    Robot top = stack.pop();\\n\\n                    if (top.health > robots[i].health) {\\n                        top.health -= 1;\\n                        robots[i].health = 0;\\n                        stack.push(top);\\n                    } else if (top.health < robots[i].health) {\\n                        robots[i].health -= 1;\\n                    } else {\\n                        robots[i].health = 0;\\n                        break;\\n                    }\\n                }\\n\\n                \\n                if (robots[i].health != 0) {\\n                    robotList.add(robots[i]);   \\n                }\\n            }\\n        }\\n        \\n        \\n        while (!stack.empty()) {\\n            robotList.add(stack.pop());    \\n        }\\n        \\n        Collections.sort(robotList, (a, b) -> a.index - b.index);\\n        for (Robot r : robotList) {\\n            ans.add(r.health);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681400,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& position, vector<int>& health, string direction) {\\n        stack<int> s;\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<position.size();i++){\\n            v.push_back({position[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<position.size();i++){\\n            if(s.empty()){\\n                int index = v[i].second;\\n                s.push({index});\\n            }else{\\n                auto it = s.top();\\n                int index = v[i].second;\\n                if(direction[it]==\\'R\\' and direction[index]==\\'L\\'){\\n                    if(health[it]==health[index]){\\n                        s.pop();\\n                    }else if(health[it]>health[index]){\\n                        s.pop();\\n                        s.push(it);\\n                        health[it]--;\\n                    }else{\\n                        s.pop();\\n                        // s.push(index);\\n                        health[index]--;\\n                        i--;\\n                        // direction[index]=\\'L\\';\\n                    }\\n                }else\\n                    s.push(index);\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        while(s.size()){\\n            int id = s.top();\\n            ans.push_back(id);\\n            s.pop();\\n        }\\n        sort(ans.begin(),ans.end());\\n        vector<int> temp;\\n        for(auto i : ans){\\n            temp.push_back(health[i]);\\n        }\\n        \\n            // reverse(ans.begin(),ans.end());\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& position, vector<int>& health, string direction) {\\n        stack<int> s;\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<position.size();i++){\\n            v.push_back({position[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<position.size();i++){\\n            if(s.empty()){\\n                int index = v[i].second;\\n                s.push({index});\\n            }else{\\n                auto it = s.top();\\n                int index = v[i].second;\\n                if(direction[it]==\\'R\\' and direction[index]==\\'L\\'){\\n                    if(health[it]==health[index]){\\n                        s.pop();\\n                    }else if(health[it]>health[index]){\\n                        s.pop();\\n                        s.push(it);\\n                        health[it]--;\\n                    }else{\\n                        s.pop();\\n                        // s.push(index);\\n                        health[index]--;\\n                        i--;\\n                        // direction[index]=\\'L\\';\\n                    }\\n                }else\\n                    s.push(index);\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        while(s.size()){\\n            int id = s.top();\\n            ans.push_back(id);\\n            s.pop();\\n        }\\n        sort(ans.begin(),ans.end());\\n        vector<int> temp;\\n        for(auto i : ans){\\n            temp.push_back(health[i]);\\n        }\\n        \\n            // reverse(ans.begin(),ans.end());\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681271,
                "title": "beats-100-runtime-memory-easy-solution-stack",
                "content": "\\n```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        Stack<Triplet> stack = new Stack<>();\\n        Triplet[] arr = new Triplet[positions.length];\\n        for(int i=0;i<positions.length;i++){\\n            arr[i]= new Triplet(positions[i],healths[i],directions.charAt(i),i);\\n        }\\n        Arrays.sort(arr,new Comparator<Triplet>(){\\n            public int compare(Triplet a , Triplet b){\\n                return a.position - b.position;\\n            }\\n        });\\n        for(int i =0;i<positions.length;i++){\\n            if(stack.isEmpty()){\\n                stack.add(arr[i]);\\n            }\\n            else{\\n                while(i<positions.length && (stack.peek().direction==arr[i].direction || (stack.peek().direction==\\'L\\' && arr[i].direction==\\'R\\') )){\\n                    stack.add(arr[i]);\\n                    i++;\\n                }\\n                if(i==positions.length)\\n                    break;\\n                boolean val = false;\\n                while(stack.size()>0 && stack.peek().direction==\\'R\\' && arr[i].direction==\\'L\\'){\\n                    Triplet x = stack.pop();\\n                    val = false;\\n                    if(x.health==arr[i].health){\\n                        healths[x.index]=0;\\n                        healths[arr[i].index]=0;\\n                        break;\\n                    }\\n                    else if(x.health>arr[i].health){\\n                        x.health--;\\n                        healths[x.index]--;\\n                        healths[arr[i].index]=0;\\n                        stack.add(x);\\n                        break;\\n                    }\\n                    else{\\n                        healths[arr[i].index]--;\\n                        healths[x.index]=0;\\n                        arr[i].health--;\\n                        val = true;\\n                        continue;\\n                    }\\n                }\\n                if(val){\\n                    stack.add(arr[i]);\\n                }\\n               \\n            }\\n        }\\n        for(int i =0;i<healths.length;i++){\\n            if(healths[i]!=0)\\n            ans.add(healths[i]);\\n        }\\n        return ans;\\n\\n    }\\n}\\nclass Triplet{\\n    int position;\\n    int health;\\n    char direction;\\n    int index;\\n    Triplet(int position, int health, char direction,int index){\\n        this.position = position;\\n        this.health=health;\\n        this.direction = direction;\\n        this.index=index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        Stack<Triplet> stack = new Stack<>();\\n        Triplet[] arr = new Triplet[positions.length];\\n        for(int i=0;i<positions.length;i++){\\n            arr[i]= new Triplet(positions[i],healths[i],directions.charAt(i),i);\\n        }\\n        Arrays.sort(arr,new Comparator<Triplet>(){\\n            public int compare(Triplet a , Triplet b){\\n                return a.position - b.position;\\n            }\\n        });\\n        for(int i =0;i<positions.length;i++){\\n            if(stack.isEmpty()){\\n                stack.add(arr[i]);\\n            }\\n            else{\\n                while(i<positions.length && (stack.peek().direction==arr[i].direction || (stack.peek().direction==\\'L\\' && arr[i].direction==\\'R\\') )){\\n                    stack.add(arr[i]);\\n                    i++;\\n                }\\n                if(i==positions.length)\\n                    break;\\n                boolean val = false;\\n                while(stack.size()>0 && stack.peek().direction==\\'R\\' && arr[i].direction==\\'L\\'){\\n                    Triplet x = stack.pop();\\n                    val = false;\\n                    if(x.health==arr[i].health){\\n                        healths[x.index]=0;\\n                        healths[arr[i].index]=0;\\n                        break;\\n                    }\\n                    else if(x.health>arr[i].health){\\n                        x.health--;\\n                        healths[x.index]--;\\n                        healths[arr[i].index]=0;\\n                        stack.add(x);\\n                        break;\\n                    }\\n                    else{\\n                        healths[arr[i].index]--;\\n                        healths[x.index]=0;\\n                        arr[i].health--;\\n                        val = true;\\n                        continue;\\n                    }\\n                }\\n                if(val){\\n                    stack.add(arr[i]);\\n                }\\n               \\n            }\\n        }\\n        for(int i =0;i<healths.length;i++){\\n            if(healths[i]!=0)\\n            ans.add(healths[i]);\\n        }\\n        return ans;\\n\\n    }\\n}\\nclass Triplet{\\n    int position;\\n    int health;\\n    char direction;\\n    int index;\\n    Triplet(int position, int health, char direction,int index){\\n        this.position = position;\\n        this.health=health;\\n        this.direction = direction;\\n        this.index=index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681245,
                "title": "simple-solution-using-stack-beginner-friendly-c",
                "content": "# Intuition\\nTHE ALL LEFT DIRECTION COLLIDE WITH  ALL SMALLER POSITION WITH RIGHT DIRECTION.\\n\\n# Approach\\n* all given right direction position collide with left postion which is greater than right position. so we simply sort the position vector and store the all value who have right direction if we encounter with the left direction position than compare with stack top element.\\n* health[top_element]>health[left_direction]\\n        make it  health of health [left_position]=0 and health[top_element]-=1 \\n* health[top_element]<health[left_direction]\\n        make it  health of health [left_position]-=1 and health[top_element]=0\\n* health[top_element]==health[left_direction]\\n        make it  health of health [left_position]=0 and health[top_element]=0 \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& heal, string &dir) {\\n        unordered_map<int,int> mp;\\n        stack<int> st;\\n        int n=pos.size();\\n        for(int i=0;i<n;i++){\\n            mp[pos[i]]=i;\\n        }\\n        sort(pos.begin(),pos.end());\\n        for(int i=0;i<n;i++){\\n            \\n            if(dir[mp[pos[i]]]==\\'R\\') {st.push(pos[i]);}\\n\\n            else{\\n                \\n                while(!st.empty()){\\n                    int rpos=mp[st.top()], lpos=mp[pos[i]];\\n                    int rhlth=heal[rpos],  lhlth=heal[lpos];\\n\\n                    if(rhlth<lhlth){ st.pop(); heal[rpos]=0; heal[lpos]-=1; }\\n\\n                    else if(rhlth>lhlth){ heal[lpos]=0;  heal[rpos]-=1;  break;}\\n\\n                    else if(rhlth==lhlth){ st.pop(); heal[rpos]=0; heal[lpos]=0; break;}\\n                }\\n\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(heal[i]!=0) ans.push_back(heal[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sorting",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& pos, vector<int>& heal, string &dir) {\\n        unordered_map<int,int> mp;\\n        stack<int> st;\\n        int n=pos.size();\\n        for(int i=0;i<n;i++){\\n            mp[pos[i]]=i;\\n        }\\n        sort(pos.begin(),pos.end());\\n        for(int i=0;i<n;i++){\\n            \\n            if(dir[mp[pos[i]]]==\\'R\\') {st.push(pos[i]);}\\n\\n            else{\\n                \\n                while(!st.empty()){\\n                    int rpos=mp[st.top()], lpos=mp[pos[i]];\\n                    int rhlth=heal[rpos],  lhlth=heal[lpos];\\n\\n                    if(rhlth<lhlth){ st.pop(); heal[rpos]=0; heal[lpos]-=1; }\\n\\n                    else if(rhlth>lhlth){ heal[lpos]=0;  heal[rpos]-=1;  break;}\\n\\n                    else if(rhlth==lhlth){ st.pop(); heal[rpos]=0; heal[lpos]=0; break;}\\n                }\\n\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(heal[i]!=0) ans.push_back(heal[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680950,
                "title": "c-stack-greedy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<pair<pair<int,int>,pair<int,char>>>p;\\n        for(int i=0; i<positions.size(); i++){\\n            p.push_back({{positions[i],i},{healths[i],directions[i]}});\\n        }\\n        sort(p.begin(),p.end());\\n        stack<pair<pair<int,int>,char>>st;\\n        for(int i=0; i<p.size(); i++){\\n            if(st.size()==0){\\n                st.push({{p[i].first.second,p[i].second.first},p[i].second.second});\\n            }\\n            else{\\n                if(p[i].second.second==\\'R\\'){\\n                    st.push({{p[i].first.second,p[i].second.first},p[i].second.second});\\n                    continue;\\n                }\\n                if(st.size() && st.top().second==\\'R\\'){\\n                    if(p[i].second.second==\\'L\\'){\\n                        if(p[i].second.first==st.top().first.second){\\n                            st.pop();\\n                        }\\n                        else if(p[i].second.first>st.top().first.second){\\n                            while(st.size() && st.top().second==\\'R\\' && p[i].second.first>st.top().first.second){\\n                                p[i].second.first--;\\n                                st.pop();\\n                            }\\n                            if(st.size() && st.top().second==\\'R\\'){\\n                                if(p[i].second.first==st.top().first.second) st.pop();\\n                                else{\\n                                    st.top().first.second--;\\n                                }\\n                            }\\n                            else{\\n                                st.push({{p[i].first.second,p[i].second.first},p[i].second.second});\\n                            }\\n                        }\\n                        else{\\n                            st.top().first.second--;\\n                        }\\n                    }\\n                    else{\\n                        st.push({{p[i].first.second,p[i].second.first},p[i].second.second});\\n                    }\\n                }\\n                else{\\n                    st.push({{p[i].first.second,p[i].second.first},p[i].second.second});\\n                }\\n            }\\n        }\\n        vector<pair<int,int>>ans;\\n        while(st.size()){\\n            ans.push_back({st.top().first.first,st.top().first.second});\\n            st.pop();\\n        }\\n        sort(ans.begin(),ans.end());\\n        vector<int>a;\\n        for(auto it:ans){\\n            a.push_back(it.second);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\\n        vector<pair<pair<int,int>,pair<int,char>>>p;\\n        for(int i=0; i<positions.size(); i++){\\n            p.push_back({{positions[i],i},{healths[i],directions[i]}});\\n        }\\n        sort(p.begin(),p.end());\\n        stack<pair<pair<int,int>,char>>st;\\n        for(int i=0; i<p.size(); i++){\\n            if(st.size()==0){\\n                st.push({{p[i].first.second,p[i].second.first},p[i].second.second});\\n            }\\n            else{\\n                if(p[i].second.second==\\'R\\'){\\n                    st.push({{p[i].first.second,p[i].second.first},p[i].second.second});\\n                    continue;\\n                }\\n                if(st.size() && st.top().second==\\'R\\'){\\n                    if(p[i].second.second==\\'L\\'){\\n                        if(p[i].second.first==st.top().first.second){\\n                            st.pop();\\n                        }\\n                        else if(p[i].second.first>st.top().first.second){\\n                            while(st.size() && st.top().second==\\'R\\' && p[i].second.first>st.top().first.second){\\n                                p[i].second.first--;\\n                                st.pop();\\n                            }\\n                            if(st.size() && st.top().second==\\'R\\'){\\n                                if(p[i].second.first==st.top().first.second) st.pop();\\n                                else{\\n                                    st.top().first.second--;\\n                                }\\n                            }\\n                            else{\\n                                st.push({{p[i].first.second,p[i].second.first},p[i].second.second});\\n                            }\\n                        }\\n                        else{\\n                            st.top().first.second--;\\n                        }\\n                    }\\n                    else{\\n                        st.push({{p[i].first.second,p[i].second.first},p[i].second.second});\\n                    }\\n                }\\n                else{\\n                    st.push({{p[i].first.second,p[i].second.first},p[i].second.second});\\n                }\\n            }\\n        }\\n        vector<pair<int,int>>ans;\\n        while(st.size()){\\n            ans.push_back({st.top().first.first,st.top().first.second});\\n            st.pop();\\n        }\\n        sort(ans.begin(),ans.end());\\n        vector<int>a;\\n        for(auto it:ans){\\n            a.push_back(it.second);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1943412,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "It is generic stack implementation(like bracket balancing), nothing tough. Just handling the data type is pain in the ***."
                    },
                    {
                        "username": "rogerwln",
                        "content": "Agree. This should be medium at most "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Started Leetcode around 2 months ago, and contests around last month. This is the first hard I ever solved in a contest, just wanted to say that and I feel really proud of myself. I had studied multikey sorting, stacks, and mod math which were all needed for my implementation. Finally I feel like all the pieces are coming together for me to pass interviews!"
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "[@MdoingIt](/MdoingIt) us bro us"
                    },
                    {
                        "username": "8800AB",
                        "content": "[@MdoingIt](/MdoingIt) relatable ;("
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@Prajju22](/Prajju22) i try but it doesnt seem to work"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@MdoingIt](/MdoingIt) do not worry bro try to find pattern in question"
                    },
                    {
                        "username": "Prajju22",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "i have been doing it for 1.5 years and i still have not solved any hards in contests\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Sometimes I wonder if i am even Employable\\uD83D\\uDE13"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "First Hard I\\'ve encountered in a contest that\\'s actually entertaining and solvable in a reasonable amount of time."
                    },
                    {
                        "username": "tor_es",
                        "content": "This doesn\\'t seem to be a hard problem, even though a beginner here, the 2nd problem in the contest was tougher than this, i should have spent time here instead of the 2nd one :("
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I\\'ve submitted the answer correctly LeetCode is not allowing me to post the solution and saying please submit at least 1 AC to post the solution. Can anyone tell me why this is so?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@aadarshpndey](/aadarshpndey) okay."
                    },
                    {
                        "username": "aadarshpndey",
                        "content": "Same is happening with me as well, probably they only have allowed people with premium subscription to upload solution as of now."
                    },
                    {
                        "username": "Finesse",
                        "content": "Am I the only one who solved using heap and binary search tree (tracking the soonest collisions)?\n\nSolving 175 hard problems changes mind such way that you stop looking for simple solutions..."
                    },
                    {
                        "username": "karthik1996",
                        "content": "Did with Min Heap Need to start from scratch to learn patterns since this made it too complex."
                    },
                    {
                        "username": "brinuke",
                        "content": "That\\'s an overkill."
                    },
                    {
                        "username": "abhi-",
                        "content": "implementation and finding the edge cases are difficult."
                    }
                ]
            },
            {
                "id": 1943356,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "It is generic stack implementation(like bracket balancing), nothing tough. Just handling the data type is pain in the ***."
                    },
                    {
                        "username": "rogerwln",
                        "content": "Agree. This should be medium at most "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Started Leetcode around 2 months ago, and contests around last month. This is the first hard I ever solved in a contest, just wanted to say that and I feel really proud of myself. I had studied multikey sorting, stacks, and mod math which were all needed for my implementation. Finally I feel like all the pieces are coming together for me to pass interviews!"
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "[@MdoingIt](/MdoingIt) us bro us"
                    },
                    {
                        "username": "8800AB",
                        "content": "[@MdoingIt](/MdoingIt) relatable ;("
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@Prajju22](/Prajju22) i try but it doesnt seem to work"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@MdoingIt](/MdoingIt) do not worry bro try to find pattern in question"
                    },
                    {
                        "username": "Prajju22",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "i have been doing it for 1.5 years and i still have not solved any hards in contests\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Sometimes I wonder if i am even Employable\\uD83D\\uDE13"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "First Hard I\\'ve encountered in a contest that\\'s actually entertaining and solvable in a reasonable amount of time."
                    },
                    {
                        "username": "tor_es",
                        "content": "This doesn\\'t seem to be a hard problem, even though a beginner here, the 2nd problem in the contest was tougher than this, i should have spent time here instead of the 2nd one :("
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I\\'ve submitted the answer correctly LeetCode is not allowing me to post the solution and saying please submit at least 1 AC to post the solution. Can anyone tell me why this is so?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@aadarshpndey](/aadarshpndey) okay."
                    },
                    {
                        "username": "aadarshpndey",
                        "content": "Same is happening with me as well, probably they only have allowed people with premium subscription to upload solution as of now."
                    },
                    {
                        "username": "Finesse",
                        "content": "Am I the only one who solved using heap and binary search tree (tracking the soonest collisions)?\n\nSolving 175 hard problems changes mind such way that you stop looking for simple solutions..."
                    },
                    {
                        "username": "karthik1996",
                        "content": "Did with Min Heap Need to start from scratch to learn patterns since this made it too complex."
                    },
                    {
                        "username": "brinuke",
                        "content": "That\\'s an overkill."
                    },
                    {
                        "username": "abhi-",
                        "content": "implementation and finding the edge cases are difficult."
                    }
                ]
            },
            {
                "id": 1943933,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "It is generic stack implementation(like bracket balancing), nothing tough. Just handling the data type is pain in the ***."
                    },
                    {
                        "username": "rogerwln",
                        "content": "Agree. This should be medium at most "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Started Leetcode around 2 months ago, and contests around last month. This is the first hard I ever solved in a contest, just wanted to say that and I feel really proud of myself. I had studied multikey sorting, stacks, and mod math which were all needed for my implementation. Finally I feel like all the pieces are coming together for me to pass interviews!"
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "[@MdoingIt](/MdoingIt) us bro us"
                    },
                    {
                        "username": "8800AB",
                        "content": "[@MdoingIt](/MdoingIt) relatable ;("
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@Prajju22](/Prajju22) i try but it doesnt seem to work"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@MdoingIt](/MdoingIt) do not worry bro try to find pattern in question"
                    },
                    {
                        "username": "Prajju22",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "i have been doing it for 1.5 years and i still have not solved any hards in contests\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Sometimes I wonder if i am even Employable\\uD83D\\uDE13"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "First Hard I\\'ve encountered in a contest that\\'s actually entertaining and solvable in a reasonable amount of time."
                    },
                    {
                        "username": "tor_es",
                        "content": "This doesn\\'t seem to be a hard problem, even though a beginner here, the 2nd problem in the contest was tougher than this, i should have spent time here instead of the 2nd one :("
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I\\'ve submitted the answer correctly LeetCode is not allowing me to post the solution and saying please submit at least 1 AC to post the solution. Can anyone tell me why this is so?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@aadarshpndey](/aadarshpndey) okay."
                    },
                    {
                        "username": "aadarshpndey",
                        "content": "Same is happening with me as well, probably they only have allowed people with premium subscription to upload solution as of now."
                    },
                    {
                        "username": "Finesse",
                        "content": "Am I the only one who solved using heap and binary search tree (tracking the soonest collisions)?\n\nSolving 175 hard problems changes mind such way that you stop looking for simple solutions..."
                    },
                    {
                        "username": "karthik1996",
                        "content": "Did with Min Heap Need to start from scratch to learn patterns since this made it too complex."
                    },
                    {
                        "username": "brinuke",
                        "content": "That\\'s an overkill."
                    },
                    {
                        "username": "abhi-",
                        "content": "implementation and finding the edge cases are difficult."
                    }
                ]
            },
            {
                "id": 1943456,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "It is generic stack implementation(like bracket balancing), nothing tough. Just handling the data type is pain in the ***."
                    },
                    {
                        "username": "rogerwln",
                        "content": "Agree. This should be medium at most "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Started Leetcode around 2 months ago, and contests around last month. This is the first hard I ever solved in a contest, just wanted to say that and I feel really proud of myself. I had studied multikey sorting, stacks, and mod math which were all needed for my implementation. Finally I feel like all the pieces are coming together for me to pass interviews!"
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "[@MdoingIt](/MdoingIt) us bro us"
                    },
                    {
                        "username": "8800AB",
                        "content": "[@MdoingIt](/MdoingIt) relatable ;("
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@Prajju22](/Prajju22) i try but it doesnt seem to work"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@MdoingIt](/MdoingIt) do not worry bro try to find pattern in question"
                    },
                    {
                        "username": "Prajju22",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "i have been doing it for 1.5 years and i still have not solved any hards in contests\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Sometimes I wonder if i am even Employable\\uD83D\\uDE13"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "First Hard I\\'ve encountered in a contest that\\'s actually entertaining and solvable in a reasonable amount of time."
                    },
                    {
                        "username": "tor_es",
                        "content": "This doesn\\'t seem to be a hard problem, even though a beginner here, the 2nd problem in the contest was tougher than this, i should have spent time here instead of the 2nd one :("
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I\\'ve submitted the answer correctly LeetCode is not allowing me to post the solution and saying please submit at least 1 AC to post the solution. Can anyone tell me why this is so?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@aadarshpndey](/aadarshpndey) okay."
                    },
                    {
                        "username": "aadarshpndey",
                        "content": "Same is happening with me as well, probably they only have allowed people with premium subscription to upload solution as of now."
                    },
                    {
                        "username": "Finesse",
                        "content": "Am I the only one who solved using heap and binary search tree (tracking the soonest collisions)?\n\nSolving 175 hard problems changes mind such way that you stop looking for simple solutions..."
                    },
                    {
                        "username": "karthik1996",
                        "content": "Did with Min Heap Need to start from scratch to learn patterns since this made it too complex."
                    },
                    {
                        "username": "brinuke",
                        "content": "That\\'s an overkill."
                    },
                    {
                        "username": "abhi-",
                        "content": "implementation and finding the edge cases are difficult."
                    }
                ]
            },
            {
                "id": 1944135,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "It is generic stack implementation(like bracket balancing), nothing tough. Just handling the data type is pain in the ***."
                    },
                    {
                        "username": "rogerwln",
                        "content": "Agree. This should be medium at most "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Started Leetcode around 2 months ago, and contests around last month. This is the first hard I ever solved in a contest, just wanted to say that and I feel really proud of myself. I had studied multikey sorting, stacks, and mod math which were all needed for my implementation. Finally I feel like all the pieces are coming together for me to pass interviews!"
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "[@MdoingIt](/MdoingIt) us bro us"
                    },
                    {
                        "username": "8800AB",
                        "content": "[@MdoingIt](/MdoingIt) relatable ;("
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@Prajju22](/Prajju22) i try but it doesnt seem to work"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@MdoingIt](/MdoingIt) do not worry bro try to find pattern in question"
                    },
                    {
                        "username": "Prajju22",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "i have been doing it for 1.5 years and i still have not solved any hards in contests\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Sometimes I wonder if i am even Employable\\uD83D\\uDE13"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "First Hard I\\'ve encountered in a contest that\\'s actually entertaining and solvable in a reasonable amount of time."
                    },
                    {
                        "username": "tor_es",
                        "content": "This doesn\\'t seem to be a hard problem, even though a beginner here, the 2nd problem in the contest was tougher than this, i should have spent time here instead of the 2nd one :("
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I\\'ve submitted the answer correctly LeetCode is not allowing me to post the solution and saying please submit at least 1 AC to post the solution. Can anyone tell me why this is so?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@aadarshpndey](/aadarshpndey) okay."
                    },
                    {
                        "username": "aadarshpndey",
                        "content": "Same is happening with me as well, probably they only have allowed people with premium subscription to upload solution as of now."
                    },
                    {
                        "username": "Finesse",
                        "content": "Am I the only one who solved using heap and binary search tree (tracking the soonest collisions)?\n\nSolving 175 hard problems changes mind such way that you stop looking for simple solutions..."
                    },
                    {
                        "username": "karthik1996",
                        "content": "Did with Min Heap Need to start from scratch to learn patterns since this made it too complex."
                    },
                    {
                        "username": "brinuke",
                        "content": "That\\'s an overkill."
                    },
                    {
                        "username": "abhi-",
                        "content": "implementation and finding the edge cases are difficult."
                    }
                ]
            },
            {
                "id": 1943517,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "It is generic stack implementation(like bracket balancing), nothing tough. Just handling the data type is pain in the ***."
                    },
                    {
                        "username": "rogerwln",
                        "content": "Agree. This should be medium at most "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Started Leetcode around 2 months ago, and contests around last month. This is the first hard I ever solved in a contest, just wanted to say that and I feel really proud of myself. I had studied multikey sorting, stacks, and mod math which were all needed for my implementation. Finally I feel like all the pieces are coming together for me to pass interviews!"
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "[@MdoingIt](/MdoingIt) us bro us"
                    },
                    {
                        "username": "8800AB",
                        "content": "[@MdoingIt](/MdoingIt) relatable ;("
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@Prajju22](/Prajju22) i try but it doesnt seem to work"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@MdoingIt](/MdoingIt) do not worry bro try to find pattern in question"
                    },
                    {
                        "username": "Prajju22",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "i have been doing it for 1.5 years and i still have not solved any hards in contests\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Sometimes I wonder if i am even Employable\\uD83D\\uDE13"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "First Hard I\\'ve encountered in a contest that\\'s actually entertaining and solvable in a reasonable amount of time."
                    },
                    {
                        "username": "tor_es",
                        "content": "This doesn\\'t seem to be a hard problem, even though a beginner here, the 2nd problem in the contest was tougher than this, i should have spent time here instead of the 2nd one :("
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I\\'ve submitted the answer correctly LeetCode is not allowing me to post the solution and saying please submit at least 1 AC to post the solution. Can anyone tell me why this is so?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@aadarshpndey](/aadarshpndey) okay."
                    },
                    {
                        "username": "aadarshpndey",
                        "content": "Same is happening with me as well, probably they only have allowed people with premium subscription to upload solution as of now."
                    },
                    {
                        "username": "Finesse",
                        "content": "Am I the only one who solved using heap and binary search tree (tracking the soonest collisions)?\n\nSolving 175 hard problems changes mind such way that you stop looking for simple solutions..."
                    },
                    {
                        "username": "karthik1996",
                        "content": "Did with Min Heap Need to start from scratch to learn patterns since this made it too complex."
                    },
                    {
                        "username": "brinuke",
                        "content": "That\\'s an overkill."
                    },
                    {
                        "username": "abhi-",
                        "content": "implementation and finding the edge cases are difficult."
                    }
                ]
            },
            {
                "id": 1943432,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "It is generic stack implementation(like bracket balancing), nothing tough. Just handling the data type is pain in the ***."
                    },
                    {
                        "username": "rogerwln",
                        "content": "Agree. This should be medium at most "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Started Leetcode around 2 months ago, and contests around last month. This is the first hard I ever solved in a contest, just wanted to say that and I feel really proud of myself. I had studied multikey sorting, stacks, and mod math which were all needed for my implementation. Finally I feel like all the pieces are coming together for me to pass interviews!"
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "[@MdoingIt](/MdoingIt) us bro us"
                    },
                    {
                        "username": "8800AB",
                        "content": "[@MdoingIt](/MdoingIt) relatable ;("
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@Prajju22](/Prajju22) i try but it doesnt seem to work"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@MdoingIt](/MdoingIt) do not worry bro try to find pattern in question"
                    },
                    {
                        "username": "Prajju22",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "i have been doing it for 1.5 years and i still have not solved any hards in contests\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Sometimes I wonder if i am even Employable\\uD83D\\uDE13"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "First Hard I\\'ve encountered in a contest that\\'s actually entertaining and solvable in a reasonable amount of time."
                    },
                    {
                        "username": "tor_es",
                        "content": "This doesn\\'t seem to be a hard problem, even though a beginner here, the 2nd problem in the contest was tougher than this, i should have spent time here instead of the 2nd one :("
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I\\'ve submitted the answer correctly LeetCode is not allowing me to post the solution and saying please submit at least 1 AC to post the solution. Can anyone tell me why this is so?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@aadarshpndey](/aadarshpndey) okay."
                    },
                    {
                        "username": "aadarshpndey",
                        "content": "Same is happening with me as well, probably they only have allowed people with premium subscription to upload solution as of now."
                    },
                    {
                        "username": "Finesse",
                        "content": "Am I the only one who solved using heap and binary search tree (tracking the soonest collisions)?\n\nSolving 175 hard problems changes mind such way that you stop looking for simple solutions..."
                    },
                    {
                        "username": "karthik1996",
                        "content": "Did with Min Heap Need to start from scratch to learn patterns since this made it too complex."
                    },
                    {
                        "username": "brinuke",
                        "content": "That\\'s an overkill."
                    },
                    {
                        "username": "abhi-",
                        "content": "implementation and finding the edge cases are difficult."
                    }
                ]
            },
            {
                "id": 1990928,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "It is generic stack implementation(like bracket balancing), nothing tough. Just handling the data type is pain in the ***."
                    },
                    {
                        "username": "rogerwln",
                        "content": "Agree. This should be medium at most "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Started Leetcode around 2 months ago, and contests around last month. This is the first hard I ever solved in a contest, just wanted to say that and I feel really proud of myself. I had studied multikey sorting, stacks, and mod math which were all needed for my implementation. Finally I feel like all the pieces are coming together for me to pass interviews!"
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "[@MdoingIt](/MdoingIt) us bro us"
                    },
                    {
                        "username": "8800AB",
                        "content": "[@MdoingIt](/MdoingIt) relatable ;("
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@Prajju22](/Prajju22) i try but it doesnt seem to work"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@MdoingIt](/MdoingIt) do not worry bro try to find pattern in question"
                    },
                    {
                        "username": "Prajju22",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "i have been doing it for 1.5 years and i still have not solved any hards in contests\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Sometimes I wonder if i am even Employable\\uD83D\\uDE13"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "First Hard I\\'ve encountered in a contest that\\'s actually entertaining and solvable in a reasonable amount of time."
                    },
                    {
                        "username": "tor_es",
                        "content": "This doesn\\'t seem to be a hard problem, even though a beginner here, the 2nd problem in the contest was tougher than this, i should have spent time here instead of the 2nd one :("
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I\\'ve submitted the answer correctly LeetCode is not allowing me to post the solution and saying please submit at least 1 AC to post the solution. Can anyone tell me why this is so?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@aadarshpndey](/aadarshpndey) okay."
                    },
                    {
                        "username": "aadarshpndey",
                        "content": "Same is happening with me as well, probably they only have allowed people with premium subscription to upload solution as of now."
                    },
                    {
                        "username": "Finesse",
                        "content": "Am I the only one who solved using heap and binary search tree (tracking the soonest collisions)?\n\nSolving 175 hard problems changes mind such way that you stop looking for simple solutions..."
                    },
                    {
                        "username": "karthik1996",
                        "content": "Did with Min Heap Need to start from scratch to learn patterns since this made it too complex."
                    },
                    {
                        "username": "brinuke",
                        "content": "That\\'s an overkill."
                    },
                    {
                        "username": "abhi-",
                        "content": "implementation and finding the edge cases are difficult."
                    }
                ]
            }
        ]
    },
    {
        "title": "Prime Pairs With Target Sum",
        "question_content": "<p>You are given an integer <code>n</code>. We say that two integers <code>x</code> and <code>y</code> form a prime number pair if:</p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= y &lt;= n</code></li>\n\t<li><code>x + y == n</code></li>\n\t<li><code>x</code> and <code>y</code> are prime numbers</li>\n</ul>\n\n<p>Return <em>the 2D sorted list of prime number pairs</em> <code>[x<sub>i</sub>, y<sub>i</sub>]</code>. The list should be sorted in <strong>increasing</strong> order of <code>x<sub>i</sub></code>. If there are no prime number pairs at all, return <em>an empty array</em>.</p>\n\n<p><strong>Note:</strong> A prime number is a natural number greater than <code>1</code> with only two factors, itself and <code>1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> [[3,7],[5,5]]\n<strong>Explanation:</strong> In this example, there are two prime pairs that satisfy the criteria. \nThese pairs are [3,7] and [5,5], and we return them in the sorted order as described in the problem statement.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> []\n<strong>Explanation:</strong> We can show that there is no prime number pair that gives a sum of 2, so we return an empty array. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3706637,
                "title": "c-java-python-beat-100-easy-intuition-sieve-of-eratosthenes-algorithm",
                "content": "# Intuition\\nuse seive Algorithm to find prime numbers and then chek the given condition\\n\\n# Complexity\\n- Time complexity: O(n log log n)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        bool prime[n + 1]; // Array to store whether a number is prime or not\\n        memset(prime, true, sizeof(prime)); // Initializing all numbers as prime\\n        prime[1] = false; // 1 is not a prime number\\n        prime[0] = false; // 0 is not a prime number\\n\\n        // Finding prime numbers using Sieve of Eratosthenes algorithm\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                // Marking multiples of p as non-prime\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        vector<vector<int>> ans; // Vector to store the pairs of prime numbers\\n        for(int i=2;i <= (n-1);i++){\\n            int j = n - i; // Finding the complement of i to make the sum n\\n            if(prime[i] && prime[j] && i <= j){\\n                vector<int> temp = {i,j}; // Creating a pair of prime numbers\\n                ans.push_back(temp); // Adding the pair to the result vector\\n            }\\n        }\\n        return ans; // Returning the vector of prime pairs\\n    }\\n};\\n```\\n# Java Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] prime = new boolean[n + 1]; // Array to store whether a number is prime or not\\n        List<List<Integer>> ans = new ArrayList<>(); // List to store the pairs of prime numbers\\n        \\n        // Initializing all numbers as prime\\n        for (int i = 2; i <= n; i++) {\\n            prime[i] = true;\\n        }\\n        \\n        prime[1] = false; // 1 is not a prime number\\n        prime[0] = false; // 0 is not a prime number\\n        \\n        // Finding prime numbers using the Sieve of Eratosthenes algorithm\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p]) {\\n                // Marking multiples of p as non-prime\\n                for (int i = p * p; i <= n; i += p) {\\n                    prime[i] = false;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 2; i <= n - 1; i++) {\\n            int j = n - i; // Finding the complement of i to make the sum n\\n            if (prime[i] && prime[j] && i <= j) {\\n                List<Integer> temp = new ArrayList<>(); // Creating a pair of prime numbers\\n                temp.add(i);\\n                temp.add(j);\\n                ans.add(temp); // Adding the pair to the result list\\n            }\\n        }\\n        \\n        return ans; // Returning the list of prime pairs\\n    }\\n}\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def findPrimePairs(self, n):\\n        prime = [True] * (n + 1)  # List to store whether a number is prime or not\\n        ans = []  # List to store the pairs of prime numbers\\n        \\n        # Initializing all numbers as prime\\n        for i in range(2, n + 1):\\n            prime[i] = True\\n        \\n        prime[1] = False  # 1 is not a prime number\\n        prime[0] = False  # 0 is not a prime number\\n        \\n        # Finding prime numbers using the Sieve of Eratosthenes algorithm\\n        p = 2\\n        while p * p <= n:\\n            if prime[p]:\\n                # Marking multiples of p as non-prime\\n                for i in range(p * p, n + 1, p):\\n                    prime[i] = False\\n            p += 1\\n        \\n        for i in range(2, n):\\n            j = n - i  # Finding the complement of i to make the sum n\\n            if prime[i] and prime[j] and i <= j:\\n                temp = [i, j]  # Creating a pair of prime numbers\\n                ans.append(temp)  # Adding the pair to the result list\\n        \\n        return ans  # Returning the list of prime pairs\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        bool prime[n + 1]; // Array to store whether a number is prime or not\\n        memset(prime, true, sizeof(prime)); // Initializing all numbers as prime\\n        prime[1] = false; // 1 is not a prime number\\n        prime[0] = false; // 0 is not a prime number\\n\\n        // Finding prime numbers using Sieve of Eratosthenes algorithm\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                // Marking multiples of p as non-prime\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        vector<vector<int>> ans; // Vector to store the pairs of prime numbers\\n        for(int i=2;i <= (n-1);i++){\\n            int j = n - i; // Finding the complement of i to make the sum n\\n            if(prime[i] && prime[j] && i <= j){\\n                vector<int> temp = {i,j}; // Creating a pair of prime numbers\\n                ans.push_back(temp); // Adding the pair to the result vector\\n            }\\n        }\\n        return ans; // Returning the vector of prime pairs\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] prime = new boolean[n + 1]; // Array to store whether a number is prime or not\\n        List<List<Integer>> ans = new ArrayList<>(); // List to store the pairs of prime numbers\\n        \\n        // Initializing all numbers as prime\\n        for (int i = 2; i <= n; i++) {\\n            prime[i] = true;\\n        }\\n        \\n        prime[1] = false; // 1 is not a prime number\\n        prime[0] = false; // 0 is not a prime number\\n        \\n        // Finding prime numbers using the Sieve of Eratosthenes algorithm\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p]) {\\n                // Marking multiples of p as non-prime\\n                for (int i = p * p; i <= n; i += p) {\\n                    prime[i] = false;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 2; i <= n - 1; i++) {\\n            int j = n - i; // Finding the complement of i to make the sum n\\n            if (prime[i] && prime[j] && i <= j) {\\n                List<Integer> temp = new ArrayList<>(); // Creating a pair of prime numbers\\n                temp.add(i);\\n                temp.add(j);\\n                ans.add(temp); // Adding the pair to the result list\\n            }\\n        }\\n        \\n        return ans; // Returning the list of prime pairs\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def findPrimePairs(self, n):\\n        prime = [True] * (n + 1)  # List to store whether a number is prime or not\\n        ans = []  # List to store the pairs of prime numbers\\n        \\n        # Initializing all numbers as prime\\n        for i in range(2, n + 1):\\n            prime[i] = True\\n        \\n        prime[1] = False  # 1 is not a prime number\\n        prime[0] = False  # 0 is not a prime number\\n        \\n        # Finding prime numbers using the Sieve of Eratosthenes algorithm\\n        p = 2\\n        while p * p <= n:\\n            if prime[p]:\\n                # Marking multiples of p as non-prime\\n                for i in range(p * p, n + 1, p):\\n                    prime[i] = False\\n            p += 1\\n        \\n        for i in range(2, n):\\n            j = n - i  # Finding the complement of i to make the sum n\\n            if prime[i] and prime[j] and i <= j:\\n                temp = [i, j]  # Creating a pair of prime numbers\\n                ans.append(temp)  # Adding the pair to the result list\\n        \\n        return ans  # Returning the list of prime pairs\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706410,
                "title": "explained-diff-technique-very-simple-and-easy-to-understand",
                "content": "# Approach\\nThis problem can be converted to the typical [two sum problem](https://leetcode.com/problems/two-sum/), where the elements are the primes number less then n. Solve this two sum if you have not done it before.\\n\\nNow to find the primes we can do it in two ways :\\n## Solution 1:\\nThis solution is a bit different then Sieve of Eratosthenes algo, lets discuss this first.\\n \\nHere we will keep on finding primes and use the same prime set to check if the next number is prime or not.\\n\\nFollowing solution beats 100% on memory as well as runtime. I know many of the folks argue that here the primes are evaluated only one due to which this is more optimised and this something more practical in real application developments.\\n\\n```\\nunordered_set<int> st;\\nvector<int> primes;\\n\\nclass Solution {\\npublic:\\n    void getPrimes(){\\n        primes.push_back(2); primes.push_back(3); \\n        for(int i = 6; i < 1000000; i += 6){\\n            int f1 = 1, f2 = 1;\\n            for(int j = 0; primes[j] <= sqrt(i+1) && j < primes.size(); ++j ){\\n               if((i - 1) % primes[j] == 0) { f1 = 0; }\\n               if((i + 1) % primes[j] == 0) { f2 = 0; }\\n            }\\n            if(f1) primes.push_back(i-1);\\n            if(f2) primes.push_back(i+1);\\n        }\\n        for(auto p: primes) st.insert(p);\\n    }\\n   \\n    vector<vector<int>> findPrimePairs(int n) {\\n        if(st.size() == 0) getPrimes();\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < primes.size() && primes[i] <= n/2; ++i){\\n            if(st.find(n - primes[i]) != st.end()) {  ans.push_back({primes[i], n - primes[i]});  }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Soltuion 2: Sieve of Eratosthenes\\nFor more details : https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\\n\\nHere I have used the previous set and vector to evaluate two sum, but as we are evaluating all the values till n are prime or not, we can do this with out even using set. Here is a simple solution that do not use set : https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706625/two-sum-sieve/\\n\\n```\\nunordered_set<int> st;\\nvector<int> primes;\\n    \\nclass Solution {\\npublic:\\n    void getPrimes(int n ){\\n        vector<bool> isPrime(n, 1);\\n        for(int i = 2; i <= sqrt(n); ++i){\\n          if(isPrime[i]){\\n            for(int j = i*i; j < n; j += i ) isPrime[j] = false;\\n          }\\n        }\\n        for(int i = 2; i < isPrime.size(); ++i) {\\n          if(isPrime[i]) { st.insert(i); primes.push_back(i); }\\n        }\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        if(st.size() == 0) getPrimes(1000000); cout<<primes.size();\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < primes.size() && primes[i] <= n/2; ++i){\\n            if(st.find(n - primes[i]) != st.end()) {  ans.push_back({primes[i], n - primes[i]});  }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nunordered_set<int> st;\\nvector<int> primes;\\n\\nclass Solution {\\npublic:\\n    void getPrimes(){\\n        primes.push_back(2); primes.push_back(3); \\n        for(int i = 6; i < 1000000; i += 6){\\n            int f1 = 1, f2 = 1;\\n            for(int j = 0; primes[j] <= sqrt(i+1) && j < primes.size(); ++j ){\\n               if((i - 1) % primes[j] == 0) { f1 = 0; }\\n               if((i + 1) % primes[j] == 0) { f2 = 0; }\\n            }\\n            if(f1) primes.push_back(i-1);\\n            if(f2) primes.push_back(i+1);\\n        }\\n        for(auto p: primes) st.insert(p);\\n    }\\n   \\n    vector<vector<int>> findPrimePairs(int n) {\\n        if(st.size() == 0) getPrimes();\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < primes.size() && primes[i] <= n/2; ++i){\\n            if(st.find(n - primes[i]) != st.end()) {  ans.push_back({primes[i], n - primes[i]});  }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nunordered_set<int> st;\\nvector<int> primes;\\n    \\nclass Solution {\\npublic:\\n    void getPrimes(int n ){\\n        vector<bool> isPrime(n, 1);\\n        for(int i = 2; i <= sqrt(n); ++i){\\n          if(isPrime[i]){\\n            for(int j = i*i; j < n; j += i ) isPrime[j] = false;\\n          }\\n        }\\n        for(int i = 2; i < isPrime.size(); ++i) {\\n          if(isPrime[i]) { st.insert(i); primes.push_back(i); }\\n        }\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        if(st.size() == 0) getPrimes(1000000); cout<<primes.size();\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < primes.size() && primes[i] <= n/2; ++i){\\n            if(st.find(n - primes[i]) != st.end()) {  ans.push_back({primes[i], n - primes[i]});  }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3707406,
                "title": "sieve-of-eratosthenes-explaned",
                "content": "First thought - we may think that we can brute force by Iterating $x$ and iterating $y$, then checking if $x + y == n$ and if $x$ and $y$ is prime. \\n\\n```\\nfor (int x = 1; x <= n; x++) {\\n    for (int y = x; y <= n; y++) {\\n        if (x + y == n && isPrime(x) && isPrime(y)) {\\n            // now we got [x, y]\\n        }\\n    }\\n}\\n```\\n\\nHowever, $n$ can be up to $10^6$ and O(n ^ 2) solution is a no go. Also checking if a number is a prime number on the fly is expensive. \\n\\nHence, now we have two things to think about\\n\\n1. how to optimize the solution without Iterating $x$ and $y$ \\n2. how to check if $x$ and $y$ are prime numbers efficiently\\n\\nTo solve the first problem, by looking at Example 1, we know that we don\\'t need to output $[7, 3]$ since it is covered with $[3, 7]$. Also, it is easy to see $y == n - x$ by deriving from $x + y == n$. With these info, we don\\'t need to iterate in $O(n^2)$. We just need to check $i$ in $[1 .. n / 2]$. The pair is simply $i$ and $n - i$.\\n\\n```cpp\\nfor (int i = 1; i <= n / 2; i++) {\\n    int x = i;\\n    int y = n - i;\\n    if (isPrime(x) && isPrime(y)) {\\n        // we got [x, y]\\n    }\\n}\\n```\\n\\nTo solve the second problem we can pre-compute all prime numbers up to $n$ by using Sieve of Eatosthenes so that we don\\'t need to calculate each time on the fly. \\n\\n> The Sieve of Eratosthenes is an algorithm used to find all prime numbers up to a given limit. It works by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with 2. The algorithm starts by creating a list of all integers from 2 to the limit. It then marks the first number, 2, as prime and removes all multiples of 2 from the list. The next unmarked number in the list is 3, which is also prime, so it marks it and removes all multiples of 3 from the list. This process continues until all numbers in the list have been marked as prime or composite. The remaining unmarked numbers are the prime numbers up to the given limit.\\n\\nHere\\'s a sample template. \\n\\n```cpp\\nvector<bool> sieveOfEratosthenes(const int n) {\\n  assert(n >= 2 && \"N must be greater or equal to 2\");\\n  vector<bool> isPrime(n + 1, true);\\n  isPrime[0] = isPrime[1] = false;\\n  for (int i = 2; i * i <= n; i++) {\\n\\tif (isPrime[i]) {\\n\\t  for (int j = i * i; j <= n; j += i) {\\n\\t\\tisPrime[j] = false;\\n\\t  }\\n\\t}\\n  }\\n  return isPrime;\\n}\\n```\\n\\nHere\\'s the full solution.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<bool> sieveOfEratosthenes(const int n) {\\n      assert(n >= 2 && \"N must be greater or equal to 2\");\\n      vector<bool> isPrime(n + 1, true);\\n      isPrime[0] = isPrime[1] = false;\\n      for (int i = 2; i * i <= n; i++) {\\n        if (isPrime[i]) {\\n          for (int j = i * i; j <= n; j += i) {\\n            isPrime[j] = false;\\n          }\\n        }\\n      }\\n      return isPrime;\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if (n == 1) return ans;\\n        vector<bool> p = sieveOfEratosthenes(n);\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (p[i] && p[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**p.s. Join us on the LeetCode The Hard Way Discord Study Group for timely discussion! Link in bio.**",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nfor (int x = 1; x <= n; x++) {\\n    for (int y = x; y <= n; y++) {\\n        if (x + y == n && isPrime(x) && isPrime(y)) {\\n            // now we got [x, y]\\n        }\\n    }\\n}\\n```\n```cpp\\nfor (int i = 1; i <= n / 2; i++) {\\n    int x = i;\\n    int y = n - i;\\n    if (isPrime(x) && isPrime(y)) {\\n        // we got [x, y]\\n    }\\n}\\n```\n```cpp\\nvector<bool> sieveOfEratosthenes(const int n) {\\n  assert(n >= 2 && \"N must be greater or equal to 2\");\\n  vector<bool> isPrime(n + 1, true);\\n  isPrime[0] = isPrime[1] = false;\\n  for (int i = 2; i * i <= n; i++) {\\n\\tif (isPrime[i]) {\\n\\t  for (int j = i * i; j <= n; j += i) {\\n\\t\\tisPrime[j] = false;\\n\\t  }\\n\\t}\\n  }\\n  return isPrime;\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<bool> sieveOfEratosthenes(const int n) {\\n      assert(n >= 2 && \"N must be greater or equal to 2\");\\n      vector<bool> isPrime(n + 1, true);\\n      isPrime[0] = isPrime[1] = false;\\n      for (int i = 2; i * i <= n; i++) {\\n        if (isPrime[i]) {\\n          for (int j = i * i; j <= n; j += i) {\\n            isPrime[j] = false;\\n          }\\n        }\\n      }\\n      return isPrime;\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if (n == 1) return ans;\\n        vector<bool> p = sieveOfEratosthenes(n);\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (p[i] && p[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720278,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> nm=new ArrayList<>();\\n        if(n<=2)\\n        {\\n            return nm;\\n        }\\n        boolean k[]=new boolean[n+1];\\n        Arrays.fill(k,true);\\n        k[0]=k[1]=false;\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(k[i])\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    k[j]=false;\\n                }\\n            }\\n        }\\n        List<Integer> kk=new ArrayList<>();\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(k[i])\\n            {\\n                kk.add(i);\\n            }\\n        }\\n        for(int i=0;i<kk.size();i++)\\n        {\\n            int a=kk.get(i);\\n            int b=n-a;\\n            boolean value = binary_search(kk,b);\\n            if(value && a<=b)\\n            {\\n                nm.add(new ArrayList<>(Arrays.asList(a,b)));\\n            }\\n        }\\n        return nm;\\n    }\\n    public boolean binary_search(List<Integer> nm, int val)\\n    {\\n        int i=0,j=nm.size()-1;\\n        while(i<=j)\\n        {\\n            int mid=i+(j-i)/2;\\n            if(nm.get(mid) == val)\\n            {\\n                return true;\\n            }\\n            else if(nm.get(mid) > val)\\n            {\\n                j=mid-1;\\n            }\\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> nm=new ArrayList<>();\\n        if(n<=2)\\n        {\\n            return nm;\\n        }\\n        boolean k[]=new boolean[n+1];\\n        Arrays.fill(k,true);\\n        k[0]=k[1]=false;\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(k[i])\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    k[j]=false;\\n                }\\n            }\\n        }\\n        List<Integer> kk=new ArrayList<>();\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(k[i])\\n            {\\n                kk.add(i);\\n            }\\n        }\\n        for(int i=0;i<kk.size();i++)\\n        {\\n            int a=kk.get(i);\\n            int b=n-a;\\n            boolean value = binary_search(kk,b);\\n            if(value && a<=b)\\n            {\\n                nm.add(new ArrayList<>(Arrays.asList(a,b)));\\n            }\\n        }\\n        return nm;\\n    }\\n    public boolean binary_search(List<Integer> nm, int val)\\n    {\\n        int i=0,j=nm.size()-1;\\n        while(i<=j)\\n        {\\n            int mid=i+(j-i)/2;\\n            if(nm.get(mid) == val)\\n            {\\n                return true;\\n            }\\n            else if(nm.get(mid) > val)\\n            {\\n                j=mid-1;\\n            }\\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707394,
                "title": "python-3-sieve-eratosthenes-algorithms-two-sum",
                "content": "# Intuition\\nUsing Eratosthenes to find the primes number in a range with low time complexity $$O(Nlog(logN))$$\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(Nlog(logN))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        res = []\\n        \\n        primes = [1 for _ in range(n + 1)]\\n        primes[0] = primes[1] = 0\\n        p = 2\\n        while p ** 2 <= n:\\n            if primes[p]:\\n                for i in range(p ** 2, n + 1, p): primes[i] = 0\\n            p += 1\\n        \\n        for p in range(2, n // 2 + 1):\\n            if primes[p] and primes[n - p]:\\n                res.append([p, n - p])\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        res = []\\n        \\n        primes = [1 for _ in range(n + 1)]\\n        primes[0] = primes[1] = 0\\n        p = 2\\n        while p ** 2 <= n:\\n            if primes[p]:\\n                for i in range(p ** 2, n + 1, p): primes[i] = 0\\n            p += 1\\n        \\n        for p in range(2, n // 2 + 1):\\n            if primes[p] and primes[n - p]:\\n                res.append([p, n - p])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706625,
                "title": "two-sum-sieve",
                "content": "# Similar Question:\\n+ [1. Two Sum](https://leetcode.com/problems/two-sum/)\\n# C++\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> prime(n + 1);\\n        for(int i = 2;i <= n; ++i)\\n            if(!prime[i]) \\n                for(int j = 2 * i;j <= n; j += i)\\n                    prime[j] = true;\\n        \\n        vector<vector<int>> ans;\\n        for(int i = 2;i + i <= n; ++i) {\\n            if(!prime[i]) {\\n                int key = n - i;\\n                if(key > 1 && !prime[key]) \\n                    ans.push_back({i, key});\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "# Similar Question:\\n+ [1. Two Sum](https://leetcode.com/problems/two-sum/)\\n# C++\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> prime(n + 1);\\n        for(int i = 2;i <= n; ++i)\\n            if(!prime[i]) \\n                for(int j = 2 * i;j <= n; j += i)\\n                    prime[j] = true;\\n        \\n        vector<vector<int>> ans;\\n        for(int i = 2;i + i <= n; ++i) {\\n            if(!prime[i]) {\\n                int key = n - i;\\n                if(key > 1 && !prime[key]) \\n                    ans.push_back({i, key});\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3709427,
                "title": "sieve-of-eratosthenes-with-similar-problems-beat-100",
                "content": "# Intuition\\n\\nThis is a variation of the Sieve of Eratosthenes algorithm.\\n\\nThe Sieve of Eratosthenes is one of the oldest-known algorithms to human civilization, used to find the **prime numbers** up to any given limit. The algorithm is attributed to a third-century BCE Greek astronomer, mathematician, geographer, and historian, Eratosthenes. The way the algorithm works is pretty intuitive.\\n\\n<a href=\"//upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif\"><img alt=\"File:Sieve of Eratosthenes animation.gif\" src=\"//upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif\" decoding=\"async\" width=\"445\" height=\"369\" data-file-width=\"445\" data-file-height=\"369\"></a>\\n**Image Reference: Wikipedia**\\n\\n# Similar Problems:\\n- [204. Count Primes](https://leetcode.com/problems/count-primes/)\\n- [263. Ugly Number](https://leetcode.com/problems/ugly-number/)\\n- [264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/)\\n- [279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)\\n- [2427. Number of Common Factors](https://leetcode.com/problems/number-of-common-factors/)\\n\\n# Complexity\\n- Time complexity: $$O(N\\\\log(\\\\log N))$$\\nThe time complexity to define Sieve prime array is $$O(N\\\\log(\\\\log N))$$.\\nTwo sum calculation array iterates for $$O(\\\\frac{N}{2}+1)$$ time.\\nTotal, $$O(N\\\\log(\\\\log N))$$ is required.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\nWe have declared an array of size $$N$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` Java []\\nclass Solution {    \\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] prime = new boolean[n + 1];\\n        // by initialization they are all false, so need to make true\\n        Arrays.fill(prime, true);\\n  \\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        // start from 2 because, 1 cannot be prime\\n        // end before n/2+1 because, then we will have repeating pairs\\n        for(int i=2; i<n/2+1; i++) {\\n            if(prime[i] && prime[n-i]){\\n                ans.add(Arrays.asList(i, n-i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Enumeration",
                    "Number Theory"
                ],
                "code": "``` Java []\\nclass Solution {    \\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] prime = new boolean[n + 1];\\n        // by initialization they are all false, so need to make true\\n        Arrays.fill(prime, true);\\n  \\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        // start from 2 because, 1 cannot be prime\\n        // end before n/2+1 because, then we will have repeating pairs\\n        for(int i=2; i<n/2+1; i++) {\\n            if(prime[i] && prime[n-i]){\\n                ans.add(Arrays.asList(i, n-i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706537,
                "title": "java-easy-to-understand-using-sieveoferatosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n            List<List<Integer>> ans=new ArrayList<>();\\n            boolean[]primes=sieveOfEratosthenes(n);\\n            int[]vis=new int[n+1];\\n        for(int i=1;i<=n;i++)\\n        {\\n                if((n-i)<=n && (n-i)>0 && primes[i] && primes[n-i] && vis[i]!=1 && vis[n-i]!=1)\\n                {\\n                        ans.add(new ArrayList<>(Arrays.asList(i,n-i)));\\n                        vis[i]=1;\\n                        vis[n-i]=1;\\n                }\\n        }\\n            Collections.sort(ans, (a, b) -> Integer.compare(a.get(0),b.get(0)));\\n            return ans;\\n            \\n        }\\n\\n    public static boolean[] sieveOfEratosthenes(int n) \\n     {\\n         boolean[] primes = new boolean[n + 1];\\n         Arrays.fill(primes, true);\\n         primes[0] = primes[1] = false;\\n\\n        for (int p = 2;p <= n; p++) {\\n          if (primes[p] && (long)p*p<=n) {\\n            for (int  i = p * p; i <= n; i += p) {\\n                 primes[i] = false;\\n                       }\\n                 }\\n           }\\n\\n    return primes;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n            List<List<Integer>> ans=new ArrayList<>();\\n            boolean[]primes=sieveOfEratosthenes(n);\\n            int[]vis=new int[n+1];\\n        for(int i=1;i<=n;i++)\\n        {\\n                if((n-i)<=n && (n-i)>0 && primes[i] && primes[n-i] && vis[i]!=1 && vis[n-i]!=1)\\n                {\\n                        ans.add(new ArrayList<>(Arrays.asList(i,n-i)));\\n                        vis[i]=1;\\n                        vis[n-i]=1;\\n                }\\n        }\\n            Collections.sort(ans, (a, b) -> Integer.compare(a.get(0),b.get(0)));\\n            return ans;\\n            \\n        }\\n\\n    public static boolean[] sieveOfEratosthenes(int n) \\n     {\\n         boolean[] primes = new boolean[n + 1];\\n         Arrays.fill(primes, true);\\n         primes[0] = primes[1] = false;\\n\\n        for (int p = 2;p <= n; p++) {\\n          if (primes[p] && (long)p*p<=n) {\\n            for (int  i = p * p; i <= n; i += p) {\\n                 primes[i] = false;\\n                       }\\n                 }\\n           }\\n\\n    return primes;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706527,
                "title": "better-than-100-easy-to-understand-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck for prime numbers till n/2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check for the prime number till n/2, as we need the sum to be n, therefore to be a pair of prime numbers, one number should be <= n/2.\\n2. If i and n - i both are prime, then push them in the answer vector.\\n3. Return the ans.\\n4. The prime no function: We will deal with a few numbers such as 1, 2, 3, and the numbers which are divisible by 2 and 3 in separate cases and for remaining numbers. Iterate from 5 to sqrt(n) and check for each iteration whether (that value) or (that value + 2) divides n or not and increment the value by 6 [**because any prime can be expressed as 6n+1 or 6n-1**]. If we find any number that divides, we return false.\\n\\n\\n# Complexity\\n- Time complexity: **O(n sqrt(n))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n)\\n    {\\n        if (n <= 1)\\n            return 0;\\n        if (n == 2 || n == 3)\\n            return 1;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return 0;\\n        for (int i = 5; i * i <= n; i = i + 6)\\n        {\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int i = 2; i <= n/2; i++)\\n        {\\n            if (isPrime(i) && isPrime(n - i)) \\n            {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n)\\n    {\\n        if (n <= 1)\\n            return 0;\\n        if (n == 2 || n == 3)\\n            return 1;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return 0;\\n        for (int i = 5; i * i <= n; i = i + 6)\\n        {\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int i = 2; i <= n/2; i++)\\n        {\\n            if (isPrime(i) && isPrime(n - i)) \\n            {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709717,
                "title": "python-3-9-lines-sieve-t-m-100-56",
                "content": "\\n```\\nprimes = [False,False] + [True] * 999_999               #\\n                                                        #\\nfor i in range(2, 1001):                                # <-- sieve construction\\n    if primes[i]:                                       # \\n        for j in range(i + i, 1000_000, i):             #\\n            primes[j] = False                           #\\n\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n\\n        if n < 4: return []                             # \\n                                                        # <-- edge cases\\n        if n%2 or n == 4:                               #\\n            return [[2,n-2]] if primes[n-2] else []     #\\n\\n        return [[i, n - i] for i in range(3,(n+3)//2)   # <-- find pairs\\n                       if primes[i] and primes[n - i]]  #\\n```\\n[https://leetcode.com/problems/prime-pairs-with-target-sum/submissions/984727574/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*loglog*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nprimes = [False,False] + [True] * 999_999               #\\n                                                        #\\nfor i in range(2, 1001):                                # <-- sieve construction\\n    if primes[i]:                                       # \\n        for j in range(i + i, 1000_000, i):             #\\n            primes[j] = False                           #\\n\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n\\n        if n < 4: return []                             # \\n                                                        # <-- edge cases\\n        if n%2 or n == 4:                               #\\n            return [[2,n-2]] if primes[n-2] else []     #\\n\\n        return [[i, n - i] for i in range(3,(n+3)//2)   # <-- find pairs\\n                       if primes[i] and primes[n - i]]  #\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707448,
                "title": "easy-c-very-detailed-explanation-of-approach-and-sieve-of-eratosthenes",
                "content": "# Intuition\\nWe need to find all the prime numbers within the range 2 to n, and then find the pair. But there are 10^5 numbers so brute force way of finding prime numbers will result in TLE so we need to use Sieve of Eratosthenes to find the primes in range 1 to n. \\n\\n**Sieve of Eratosthenes** : \\nThere is a property that a number N can be exactly divisible by X then X must be less than or equal to sqrt(N).\\nThe Sieve of Eratosthenes is an algorithm that efficiently finds all prime numbers up to a given limit by iteratively marking the multiples of each prime number as composite, thereby identifying the primes. So overall time complexity difference of brute force way of finding all prime numbers between 1 to N vs Sieve of Eratosthenes approach is:\\nBrute Force : `O(N * sqrt(N))`\\nSieve of Eratosthenes : `O(N * log(log N))`\\n\\n# Approach\\n1. First we find all the primes numbers from 0 to n using Sieve of Eratosthenes algorithm and store it in a vector \"primes\". \\n2. Primes is a boolean vector of size n + 1 and stores True in primes[i] if i is prime else False. \\n3. Since 0 and 1 are not primes we give a initialze primes[0] and primes[1] to false.\\n4. After finding all the primes now we traverse through primes vector to find all the pairs from `i = 2 -> n/2`. We assume ibe the first number and j be the second number. If i be any number then requried second number j becomes `j = n - i`\\n5. Say `n = 10`, if `i = 3` then second number j becomes `j = 10 - 3 = 7`. Now after getting the values of i and j we check if i and j are prime numbers using the boolean vector primes if both `primes [i] && primes[j]` are true that means both i and j are prime numbers thus we get requried pair and store it in ans vector.\\n\\n# Complexity\\n- Time complexity:\\nO(N + (N * log(log N)))\\nN * log(log N) -> for finding all the primes\\nN -> traversing through all the primes\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        vector<bool> primes(n + 1, true);\\n        primes[0] = false; // initalizing 0 and 1 numbers to False \\n        primes[1] = false;\\n\\n        for (int i = 2; i * i <= n; i++) // Prime numbers checking using Sieve\\n        { \\n            if (primes[i]) \\n            {\\n                for (int j = i * i; j <= n; j += i) \\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n\\n        \\n        for (int i = 2; i <= n / 2; i++) // checking for pairs\\n        {\\n            int j = n - i;\\n            if (primes[i] && primes[j]) {\\n                ans.push_back({i, j});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote if found helpful",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        vector<bool> primes(n + 1, true);\\n        primes[0] = false; // initalizing 0 and 1 numbers to False \\n        primes[1] = false;\\n\\n        for (int i = 2; i * i <= n; i++) // Prime numbers checking using Sieve\\n        { \\n            if (primes[i]) \\n            {\\n                for (int j = i * i; j <= n; j += i) \\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n\\n        \\n        for (int i = 2; i <= n / 2; i++) // checking for pairs\\n        {\\n            int j = n - i;\\n            if (primes[i] && primes[j]) {\\n                ans.push_back({i, j});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706713,
                "title": "two-sum",
                "content": "We can use two pointers to find all pais that sum to `n`, like in [1. Two Sum](https://leetcode.com/problems/two-sum/).\\n\\nTo do that, we need to prepare an array with prime numbers. We can use Sieve of Eratosthenes to do it efficiently.\\n\\nNote that we populate primes into global `p` vector once, and then reuse for all test cases.\\n\\n**C++**\\n```cpp\\nvector<int> p;\\nclass Solution {\\npublic:\\nvector<vector<int>> findPrimePairs(int n) {\\n    if (p.empty()) {\\n        bool sieve[1000000] = {};\\n        for (long long i = 2; i < 1000000; ++i)\\n            if (!sieve[i]) {\\n                p.push_back(i);\\n                for (long long j = i * i; j < 1000000; j += i)\\n                    sieve[j] = true;\\n            }\\n    }\\n    vector<vector<int>> res;\\n    int i = 0, j = upper_bound(begin(p), end(p), n) - begin(p) - 1;\\n    while (i <= j) {\\n        if (p[i] + p[j] == n) {\\n            res.push_back({p[i], p[j]});\\n            ++i, --j;\\n        }\\n        else if (p[i] + p[j] < n)\\n            ++i;\\n        else\\n            --j;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> p;\\nclass Solution {\\npublic:\\nvector<vector<int>> findPrimePairs(int n) {\\n    if (p.empty()) {\\n        bool sieve[1000000] = {};\\n        for (long long i = 2; i < 1000000; ++i)\\n            if (!sieve[i]) {\\n                p.push_back(i);\\n                for (long long j = i * i; j < 1000000; j += i)\\n                    sieve[j] = true;\\n            }\\n    }\\n    vector<vector<int>> res;\\n    int i = 0, j = upper_bound(begin(p), end(p), n) - begin(p) - 1;\\n    while (i <= j) {\\n        if (p[i] + p[j] == n) {\\n            res.push_back({p[i], p[j]});\\n            ++i, --j;\\n        }\\n        else if (p[i] + p[j] < n)\\n            ++i;\\n        else\\n            --j;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706596,
                "title": "110-understandable-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n     \\n    vector<vector<int>> findPrimePairs(int n) {\\n     \\n        vector<vector<int>> ans;\\n        if(n<=2) return ans;\\n        int x=2;\\n        while(x<=(n/2))\\n        {\\n            if(isPrime(x))\\n            {\\n                if(isPrime(n-x))\\n                ans.push_back({x,n-x});\\n            }\\n            x++;\\n        }\\n        return ans;\\n        \\n    }\\n     bool isPrime(int val)\\n      {\\n          \\n          int x=2;\\n          int y=sqrt(val);\\n          while(x<=y)\\n          {\\n              if(val%x==0) return false;\\n              x++;\\n          }\\n          return true;\\n      }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     \\n    vector<vector<int>> findPrimePairs(int n) {\\n     \\n        vector<vector<int>> ans;\\n        if(n<=2) return ans;\\n        int x=2;\\n        while(x<=(n/2))\\n        {\\n            if(isPrime(x))\\n            {\\n                if(isPrime(n-x))\\n                ans.push_back({x,n-x});\\n            }\\n            x++;\\n        }\\n        return ans;\\n        \\n    }\\n     bool isPrime(int val)\\n      {\\n          \\n          int x=2;\\n          int y=sqrt(val);\\n          while(x<=y)\\n          {\\n              if(val%x==0) return false;\\n              x++;\\n          }\\n          return true;\\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706430,
                "title": "easy-c-solution-brute-force-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        for(int i=2;i<=n;i++) \\n        {\\n          if(prime[i] && (long long)i*i<=n) \\n          {\\n           for(int j=i*i;j<=n;j+=i)   prime[j] = false;\\n           }\\n         }\\n        set<int> st;\\n        for(int i=2;i<n+1;i++)\\n        {\\n            if(prime[i])  st.insert(i);\\n        }\\n         map<int,int> mp;\\n         for(auto it:st)\\n         {\\n             int req=n-it;\\n             if(mp.find(req)!=mp.end())  continue;\\n             if(st.find(req)!=st.end())  mp[it]=req;\\n         }\\n        vector<vector<int>> ans;\\n        for(auto it:mp)     ans.push_back({it.first,it.second});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        for(int i=2;i<=n;i++) \\n        {\\n          if(prime[i] && (long long)i*i<=n) \\n          {\\n           for(int j=i*i;j<=n;j+=i)   prime[j] = false;\\n           }\\n         }\\n        set<int> st;\\n        for(int i=2;i<n+1;i++)\\n        {\\n            if(prime[i])  st.insert(i);\\n        }\\n         map<int,int> mp;\\n         for(auto it:st)\\n         {\\n             int req=n-it;\\n             if(mp.find(req)!=mp.end())  continue;\\n             if(st.find(req)!=st.end())  mp[it]=req;\\n         }\\n        vector<vector<int>> ans;\\n        for(auto it:mp)     ans.push_back({it.first,it.second});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752698,
                "title": "beats-99-27-math-explain-c-variant-sieve-of-eratosthenes-algorithm-finding-odd-primes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses the Sieve of Eratosthenes algorithm to find and store a list of odd prime numbers up to a given number n. The sieve function is responsible for generating this list. It marks multiples of primes as non-prime in the oddPrime vector. When oddPrime[i]=true, the odd number 2i+1 is a prime!\\n[https://youtu.be/7GGhURLPnIs](https://youtu.be/7GGhURLPnIs)\\n\\nIt is crucial to take n_2sqrt=int(sqrt(n)/2); it saves much time.\\n\\n[Please the English subtitles if necceassray]\\n[https://youtu.be/GxoMWxXLKMc](https://youtu.be/GxoMWxXLKMc)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function findPrimePairs first checks some base cases and returns appropriate results for n less than or equal to 3 or equal to 4. For other values of n, it calls the sieve function to generate the list of odd primes.\\n\\nIf n is odd, it checks if n - 2 is an odd prime number. If it is, the function returns a vector containing the pair {2, n - 2}. Otherwise, it returns an empty vector.\\n\\nIf n is even, the function iterates through odd numbers from 3 to n / 2 and checks if both i  and (n - i)  are prime numbers. If they are, it adds the pair {i, n - i} to the ans vector.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> oddPrime;\\n\\n    void sieve(int n)\\n    {\\n        int n_2=n>>1;\\n        oddPrime.assign(n_2, 1);\\n        oddPrime[0]=0;\\n        int n_2sqrt=int(sqrt(n)/2);\\n        for(int i=1; i<=n_2sqrt; i++){\\n            if (oddPrime[i]){\\n                int p=2*i+1;\\n                for(int j=p*p/2 ; j<n_2; j+=p)\\n                    oddPrime[j]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        if (n<=3) return {};\\n        if (n==4) return {{2, 2}};\\n        sieve(n);\\n        if (n%2==1){\\n            if (oddPrime[(n-2)/2]){\\n                return {{2, n-2}};\\n            }\\n            else return {};\\n        }\\n        vector<vector<int>> ans;\\n        for (int i=3; i<=n/2; i+=2){\\n            if (oddPrime[i/2] && oddPrime[(n-i)/2])\\n                ans.push_back({i, n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code with Explanation in Comments\\n```\\nclass Solution {\\npublic:\\n    vector<bool> oddPrime;\\n\\n    void sieve(int n)\\n    {\\n        // Dividing n by 2\\n        int n_2 = n >> 1;\\n        \\n        // Assigning n_2 elements with value true (1)\\n        oddPrime.assign(n_2, 1);\\n        \\n        // Marking the first element as false (0)\\n        oddPrime[0] = 0;\\n        \\n        // Calculating the square root of n divided by 2\\n        int n_2sqrt = int(sqrt(n) / 2);\\n        \\n        // Sieve of Eratosthenes algorithm\\n        for (int i = 1; i <= n_2sqrt; i++) {\\n            if (oddPrime[i]) {\\n                // Current prime number\\n                int p = 2 * i + 1;\\n                \\n                // Marking multiples of p as false (0)\\n                for (int j = p * p / 2; j < n_2; j += p)\\n                    oddPrime[j] = 0;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findPrimePairs(int n) {\\n        // If n is less than or equal to 3, return an empty vector\\n        if (n <= 3)\\n            return {};\\n        \\n        // If n is 4, return a vector containing the pair {2, 2}\\n        if (n == 4)\\n            return {{2, 2}};\\n        \\n        // Use the sieve method to generate a list of odd primes\\n        sieve(n);\\n        \\n        // If n is odd\\n        if (n % 2 == 1) {\\n            if (oddPrime[(n - 2) / 2]) {\\n                // If (n-2)/2 is a prime, return a vector containing the pair {2, n-2}\\n                return {{2, n - 2}};\\n            } else {\\n                // Otherwise, return an empty vector\\n                return {};\\n            }\\n        }\\n        \\n        // n is even\\n        vector<vector<int>> ans;\\n        \\n        // Iterate through odd numbers from 3 to n/2\\n        for (int i = 3; i <= n / 2; i += 2) {\\n            // Check if both i/2 and (n-i)/2 are primes\\n            if (oddPrime[i / 2] && oddPrime[(n - i) / 2])\\n                ans.push_back({i, n - i});\\n        }\\n        \\n        // Return the vector containing the prime pairs\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> oddPrime;\\n\\n    void sieve(int n)\\n    {\\n        int n_2=n>>1;\\n        oddPrime.assign(n_2, 1);\\n        oddPrime[0]=0;\\n        int n_2sqrt=int(sqrt(n)/2);\\n        for(int i=1; i<=n_2sqrt; i++){\\n            if (oddPrime[i]){\\n                int p=2*i+1;\\n                for(int j=p*p/2 ; j<n_2; j+=p)\\n                    oddPrime[j]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        if (n<=3) return {};\\n        if (n==4) return {{2, 2}};\\n        sieve(n);\\n        if (n%2==1){\\n            if (oddPrime[(n-2)/2]){\\n                return {{2, n-2}};\\n            }\\n            else return {};\\n        }\\n        vector<vector<int>> ans;\\n        for (int i=3; i<=n/2; i+=2){\\n            if (oddPrime[i/2] && oddPrime[(n-i)/2])\\n                ans.push_back({i, n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<bool> oddPrime;\\n\\n    void sieve(int n)\\n    {\\n        // Dividing n by 2\\n        int n_2 = n >> 1;\\n        \\n        // Assigning n_2 elements with value true (1)\\n        oddPrime.assign(n_2, 1);\\n        \\n        // Marking the first element as false (0)\\n        oddPrime[0] = 0;\\n        \\n        // Calculating the square root of n divided by 2\\n        int n_2sqrt = int(sqrt(n) / 2);\\n        \\n        // Sieve of Eratosthenes algorithm\\n        for (int i = 1; i <= n_2sqrt; i++) {\\n            if (oddPrime[i]) {\\n                // Current prime number\\n                int p = 2 * i + 1;\\n                \\n                // Marking multiples of p as false (0)\\n                for (int j = p * p / 2; j < n_2; j += p)\\n                    oddPrime[j] = 0;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findPrimePairs(int n) {\\n        // If n is less than or equal to 3, return an empty vector\\n        if (n <= 3)\\n            return {};\\n        \\n        // If n is 4, return a vector containing the pair {2, 2}\\n        if (n == 4)\\n            return {{2, 2}};\\n        \\n        // Use the sieve method to generate a list of odd primes\\n        sieve(n);\\n        \\n        // If n is odd\\n        if (n % 2 == 1) {\\n            if (oddPrime[(n - 2) / 2]) {\\n                // If (n-2)/2 is a prime, return a vector containing the pair {2, n-2}\\n                return {{2, n - 2}};\\n            } else {\\n                // Otherwise, return an empty vector\\n                return {};\\n            }\\n        }\\n        \\n        // n is even\\n        vector<vector<int>> ans;\\n        \\n        // Iterate through odd numbers from 3 to n/2\\n        for (int i = 3; i <= n / 2; i += 2) {\\n            // Check if both i/2 and (n-i)/2 are primes\\n            if (oddPrime[i / 2] && oddPrime[(n - i) / 2])\\n                ans.push_back({i, n - i});\\n        }\\n        \\n        // Return the vector containing the prime pairs\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706406,
                "title": "c-simple-sieve-of-eratosthenes",
                "content": "# Intuition\\n1. Create a list of size n.  \\n2. Mark all the numbers which are divisible by 2 and are greater than or equal to the square of it. \\n3. Now move to next unmarked number 3 and mark all the numbers which are multiples of 3 and are greater than or equal to the square of it. \\n4. Above proccess continues till the square root of n.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(log(n)))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    vector<bool> primes;\\n    void SieveOfEratosthenes(int n)\\n    {\\n        for (int p = 2; p * p <= n; p++) \\n        {\\n            if (primes[p] == true) \\n            {\\n                for (int i = p * p; i <= n; i += p)\\n                    primes[i] = false;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) \\n    {\\n        primes.resize(n+1, true);\\n        SieveOfEratosthenes(n);\\n        vector<vector<int>> ans;\\n        for(int i=2; i<=(n/2); i++)\\n        {\\n            if(primes[i] && primes[n-i]) ans.push_back({i, n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<bool> primes;\\n    void SieveOfEratosthenes(int n)\\n    {\\n        for (int p = 2; p * p <= n; p++) \\n        {\\n            if (primes[p] == true) \\n            {\\n                for (int i = p * p; i <= n; i += p)\\n                    primes[i] = false;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) \\n    {\\n        primes.resize(n+1, true);\\n        SieveOfEratosthenes(n);\\n        vector<vector<int>> ans;\\n        for(int i=2; i<=(n/2); i++)\\n        {\\n            if(primes[i] && primes[n-i]) ans.push_back({i, n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871261,
                "title": "simple-solution-using-mathematics",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isprime(int n)\\n    {\\n        int y = sqrt(n);\\n        int i=2;\\n        while(i<=y)\\n        {\\n            if(n%i==0)return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if(n<=2)\\n        return ans;\\n\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(isprime(i) && isprime(n-i))\\n            ans.push_back({i,n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isprime(int n)\\n    {\\n        int y = sqrt(n);\\n        int i=2;\\n        while(i<=y)\\n        {\\n            if(n%i==0)return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if(n<=2)\\n        return ans;\\n\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(isprime(i) && isprime(n-i))\\n            ans.push_back({i,n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714041,
                "title": "easiest-approach-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n sqrt(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n     bool checkPrime(int a){\\n        int b=sqrt(a);\\n        int c=2;\\n        while(c<=b){\\n        if(a%c==0) return false;\\n        c++;\\n        }\\n        return true;\\n}\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>res;\\n        for(int i=2;i<=n/2;i++){\\n            int temp=n-i;\\n            if(checkPrime(i) && checkPrime(temp)) res.push_back({i,temp});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     bool checkPrime(int a){\\n        int b=sqrt(a);\\n        int c=2;\\n        while(c<=b){\\n        if(a%c==0) return false;\\n        c++;\\n        }\\n        return true;\\n}\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>res;\\n        for(int i=2;i<=n/2;i++){\\n            int temp=n-i;\\n            if(checkPrime(i) && checkPrime(temp)) res.push_back({i,temp});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706498,
                "title": "easiest-c-solution-easy-to-undertand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the prime numbers that sum upto n. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to calculate the integer x for which x and n-x both are primes . How can we check if an integer is prime and that too in log(log(n)) yes its sieve of eratosthenes. So we will use it to calculate the primes before starting our calculation and then will check if x and n-x are primes ,if then they are part of our answer. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n log(log n)) As we are iterating for N/2 elements and for each element we are checking if its prime in O(Log(log(N))).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) as we are using a vector that can have atmost N/2 elements\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>v;\\n        if(n==1)return v;\\n        vector<int>prime(n+1,true);\\n        prime[0]=0;\\n        prime[1]=0;\\n        \\n        for(int i=2;i*i<=n;i++){\\n            if(prime[i]==1){\\n                for (int j = i * i; j <= n; j += i) {\\n                    prime[j] =0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(prime[i] && prime[n-i])\\n            {\\n                vector<int>temp;\\n                temp.push_back(i);\\n                temp.push_back(n-i);\\n                v.push_back(temp);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>v;\\n        if(n==1)return v;\\n        vector<int>prime(n+1,true);\\n        prime[0]=0;\\n        prime[1]=0;\\n        \\n        for(int i=2;i*i<=n;i++){\\n            if(prime[i]==1){\\n                for (int j = i * i; j <= n; j += i) {\\n                    prime[j] =0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(prime[i] && prime[n-i])\\n            {\\n                vector<int>temp;\\n                temp.push_back(i);\\n                temp.push_back(n-i);\\n                v.push_back(temp);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706412,
                "title": "easy-c-sieve-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> prime;\\n    void SieveOfEratosthenes(int n)\\n    {\\n\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        prime.resize(n+1,true);\\n        SieveOfEratosthenes(n);\\n        for(int i=2;i<=(n/2);i++)\\n        {\\n            if(prime[i] && prime[n-i])\\n                ans.push_back({i,n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> prime;\\n    void SieveOfEratosthenes(int n)\\n    {\\n\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        prime.resize(n+1,true);\\n        SieveOfEratosthenes(n);\\n        for(int i=2;i<=(n/2);i++)\\n        {\\n            if(prime[i] && prime[n-i])\\n                ans.push_back({i,n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709149,
                "title": "c-fast-solution-o-n-easy-to-understand",
                "content": "\\n# Intuition\\n\\n**The sieve of Eratosthenes is one of the most efficient ways to find all primes smaller than n**\\n\\nWe use sieve of Eratosthenes for filling the vector isPrime.\\nThe time complexity of filling this vector will be O(n).\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fill(vector<bool>& isPrime, int n) {\\n        for (int i=2;i<n;i++) {\\n            if (isPrime[i]==true) \\n                for (int j=2;i*j<=n;j++) {\\n                    isPrime[i*j]=false;\\n                }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> res;\\n        vector<bool> isPrime(n+1,true);\\n        fill(isPrime,n);\\n        for (int i=2;i<=n/2;i++) {\\n            if (isPrime[i] && isPrime[n-i]) {\\n                res.push_back({i,n-i});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\n\\n\\n![LeetCode](https://assets.leetcode.com/users/images/6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg){:style=\\'border-radius:5px;width:300px;margin:auto;\\'}",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fill(vector<bool>& isPrime, int n) {\\n        for (int i=2;i<n;i++) {\\n            if (isPrime[i]==true) \\n                for (int j=2;i*j<=n;j++) {\\n                    isPrime[i*j]=false;\\n                }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> res;\\n        vector<bool> isPrime(n+1,true);\\n        fill(isPrime,n);\\n        for (int i=2;i<=n/2;i++) {\\n            if (isPrime[i] && isPrime[n-i]) {\\n                res.push_back({i,n-i});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708531,
                "title": "simplest-sieve-solution-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        def SOE(num):\\n            isPrime = [True] * (num+1)\\n            isPrime[0] = isPrime[1] = False\\n            for p in range(isqrt(num)+1):\\n                if isPrime[p]:\\n                    for j in range(p*p, num+1, p):\\n                        isPrime[j] = False\\n            return isPrime\\n\\n        isPrime = SOE(n)\\n\\n        a = []\\n        for i in range(2,n//2+1):\\n            if isPrime[i] and isPrime[n-i]:\\n                a.append([i, n-i])\\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        def SOE(num):\\n            isPrime = [True] * (num+1)\\n            isPrime[0] = isPrime[1] = False\\n            for p in range(isqrt(num)+1):\\n                if isPrime[p]:\\n                    for j in range(p*p, num+1, p):\\n                        isPrime[j] = False\\n            return isPrime\\n\\n        isPrime = SOE(n)\\n\\n        a = []\\n        for i in range(2,n//2+1):\\n            if isPrime[i] and isPrime[n-i]:\\n                a.append([i, n-i])\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708227,
                "title": "c-easy-to-understand-map-and-sieve-of-eratosthenes",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCommented\\n\\n# Complexity\\n- Time complexity: O( n log(log n) + m (log m) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere n is the input number and m is the number of primes found.\\n\\n- Space complexity:O(n/2 + n/log(n) + m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere n is the input number and m is the number of primes found.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> res;\\n        unordered_map<int,int> mp; // Make access fast\\n        \\n        primeSeive(n,mp); // Function call\\n        \\n        vector<int> prime; // For traversing prime\\n        for(auto it : mp)\\n            prime.push_back(it.first);\\n        sort(prime.begin(),prime.end());  // To get res in sorted form\\n    \\n        \\n        for(int i = 0; i<prime.size(); i++){\\n            int req = n - prime[i]; // find if req exists in map and mp[req] > 0\\n            \\n            if(mp.find(req) != mp.end() && mp[req] > 0){\\n                res.push_back({prime[i],req});\\n                mp[prime[i]]--; // Make frequency of grouped prime[i] == 0 , as every key of map has freq = 1. \\n                //due to unique prime numbers in prime array\\n                // as for next iteration current prime[i] could become req so make mp[prime[i]]--\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\nprivate:\\n    // sieve of eratosthenes\\n    void primeSeive(int n, unordered_map<int,int>& mp){\\n        vector<int> temp(n+1,0);\\n        \\n        for (long long i = 2; i <= n; i++)\\n            if (temp[i] == 0)\\n                for (long long j = i * i; j <= n; j = j + i)\\n                    temp[j] = 1;\\n           \\n        for (int i = 2; i <= n; i++)\\n            if (temp[i] == 0)\\n                mp[i]++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> res;\\n        unordered_map<int,int> mp; // Make access fast\\n        \\n        primeSeive(n,mp); // Function call\\n        \\n        vector<int> prime; // For traversing prime\\n        for(auto it : mp)\\n            prime.push_back(it.first);\\n        sort(prime.begin(),prime.end());  // To get res in sorted form\\n    \\n        \\n        for(int i = 0; i<prime.size(); i++){\\n            int req = n - prime[i]; // find if req exists in map and mp[req] > 0\\n            \\n            if(mp.find(req) != mp.end() && mp[req] > 0){\\n                res.push_back({prime[i],req});\\n                mp[prime[i]]--; // Make frequency of grouped prime[i] == 0 , as every key of map has freq = 1. \\n                //due to unique prime numbers in prime array\\n                // as for next iteration current prime[i] could become req so make mp[prime[i]]--\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\nprivate:\\n    // sieve of eratosthenes\\n    void primeSeive(int n, unordered_map<int,int>& mp){\\n        vector<int> temp(n+1,0);\\n        \\n        for (long long i = 2; i <= n; i++)\\n            if (temp[i] == 0)\\n                for (long long j = i * i; j <= n; j = j + i)\\n                    temp[j] = 1;\\n           \\n        for (int i = 2; i <= n; i++)\\n            if (temp[i] == 0)\\n                mp[i]++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707266,
                "title": "python-solution-two-pointer-approach",
                "content": "# Approach\\nstep 1: Generate all prime numbers in an efficient way\\nstep 2: Apply two pointer method then add prime numbers in ans[]\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        def generate_primes(n):\\n            prime = [True]*(n+1)\\n            prime[0] = prime[1] = False\\n            p = 2\\n            while p*p<=n:\\n                if prime[p]:\\n                    for num in range(p*p,n+1,p):\\n                        prime[num] = False               \\n                p+=1\\n        \\n            ans = []\\n            for i in range(2,n+1):\\n                if prime[i]:\\n                    ans.append(i)\\n            return ans\\n        \\n        prime = generate_primes(n)\\n        l,r=0,len(prime)-1\\n        ans =[]\\n        while(l<=r):\\n            if prime[l]+ prime[r] == n:\\n                ans.append([prime[l],prime[r]])\\n                l+=1\\n                r-=1\\n            elif prime[l]+ prime[r] <n:\\n                l+=1\\n            else:\\n                r-=1\\n        return ans\\n```        \\n![Upvote.png](https://assets.leetcode.com/users/images/04c807e9-4167-4b0e-a922-38d56ba02f92_1688281684.0394893.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        def generate_primes(n):\\n            prime = [True]*(n+1)\\n            prime[0] = prime[1] = False\\n            p = 2\\n            while p*p<=n:\\n                if prime[p]:\\n                    for num in range(p*p,n+1,p):\\n                        prime[num] = False               \\n                p+=1\\n        \\n            ans = []\\n            for i in range(2,n+1):\\n                if prime[i]:\\n                    ans.append(i)\\n            return ans\\n        \\n        prime = generate_primes(n)\\n        l,r=0,len(prime)-1\\n        ans =[]\\n        while(l<=r):\\n            if prime[l]+ prime[r] == n:\\n                ans.append([prime[l],prime[r]])\\n                l+=1\\n                r-=1\\n            elif prime[l]+ prime[r] <n:\\n                l+=1\\n            else:\\n                r-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706999,
                "title": "sieve-algorithm",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        //sieve Algo\\n       vector<bool>isPrime(n+1,true);\\n       isPrime[0]=isPrime[1]=false;\\n        for(int i=2;i<=n;i++){\\n            if(isPrime[i]==true){\\n                for(int j=i*2;j<=n;j+=i)\\n                    isPrime[j]=false;\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>>res;\\n        for(int i=2;i<=n/2;i++){\\n            if(isPrime[i]==true){\\n                int target=n-i;\\n                if(isPrime[target]==true)\\n                    res.push_back({i,target});\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        //sieve Algo\\n       vector<bool>isPrime(n+1,true);\\n       isPrime[0]=isPrime[1]=false;\\n        for(int i=2;i<=n;i++){\\n            if(isPrime[i]==true){\\n                for(int j=i*2;j<=n;j+=i)\\n                    isPrime[j]=false;\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>>res;\\n        for(int i=2;i<=n/2;i++){\\n            if(isPrime[i]==true){\\n                int target=n-i;\\n                if(isPrime[target]==true)\\n                    res.push_back({i,target});\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706618,
                "title": "c-optimised-beats-100-memory-for-beginners-easy",
                "content": "**PLEASE UPVOTE IF YOU FOUND THIS HELPFUL!**\\n\\n# Approach\\n\\nIterating until sqrt(n) by checking remainders will give TLE. So we need to optimize further. It can be proven that prime numbers (> 3 of course) are of the form 6x+1 or 6x-1. So it is enough to check remainders by numbers of this form.\\nWe just check for cases of remainders with 2 and 3 and iterate from here.\\n\\n       1. Here i is of the form 5 + 6K where K>=0\\n       2. i+1, i+3, i+5 are even numbers (6 + 6K). N is not \\n          an even number\\n       3. Because N%2 and N%3 checks are done in the before step\\n       4. Hence i+1, i+3, i+5 can\\'t be N\\'s divisors.\\n       5. i+4 is 9 + 6K which is a 3 multiple. \\n       6. N is not a 3 multiple hence i+4 can\\'t be it\\'s divisor\\n    Hence we only check if N is a divisor of i or i+2.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n$O(1)$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPrime(int n){\\n        if (n <= 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n\\n        return true;\\n    }\\n\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if(n <= 3)  return ans;\\n        for(int i=2; i<= n/2; ++i){\\n            if(isPrime(i) and isPrime(n-i)) ans.push_back({i, n-i});\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPrime(int n){\\n        if (n <= 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n\\n        return true;\\n    }\\n\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if(n <= 3)  return ans;\\n        for(int i=2; i<= n/2; ++i){\\n            if(isPrime(i) and isPrime(n-i)) ans.push_back({i, n-i});\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851799,
                "title": "c-solution-using-sieve-of-eratosthenes",
                "content": "# Complexity\\n- Time complexity:\\nO(n*log(log(n)))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        bool prime[n + 1];\\n        memset(prime , true , sizeof(prime));\\n\\n        prime[0] = false;\\n        prime[1] = false;\\n\\n        for(int i = 2 ; i * i <= n ; i++) {\\n            if(prime[i]) {\\n                for(int j = i * i ; j <= n ; j += i) \\n                prime[j] = false;\\n            }\\n        }\\n\\n        vector<vector<int>> ans;\\n\\n        for(int i = 2 ; i <= n / 2 ; i++) {\\n            if(prime[i] && prime[n - i])\\n            ans.push_back({i , n - i});\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        bool prime[n + 1];\\n        memset(prime , true , sizeof(prime));\\n\\n        prime[0] = false;\\n        prime[1] = false;\\n\\n        for(int i = 2 ; i * i <= n ; i++) {\\n            if(prime[i]) {\\n                for(int j = i * i ; j <= n ; j += i) \\n                prime[j] = false;\\n            }\\n        }\\n\\n        vector<vector<int>> ans;\\n\\n        for(int i = 2 ; i <= n / 2 ; i++) {\\n            if(prime[i] && prime[n - i])\\n            ans.push_back({i , n - i});\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724246,
                "title": "c-sieve-of-eratosthenes-two-pointers",
                "content": "# Intuition\\nTo find all the prime numbers till n and then find the sum pair\\n\\n# Approach\\nWe will be finding the prime nunbers till n by using the concept of sieve of eratosthenes. And then we will use two pointers to find the sum pair.\\nIn seive of eratosthenes we mark all the number which is divisble by 2 and are greater than or equal to square of it. We continue this process for all the numbers till n. \\nThe numbers which are unmarked are the prime numbers till n.\\n\\nWe will then store these prime numbers in a new vector and apply two pointer approach to find the pair of sum equal to n;\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int> temp(n,0);\\n\\n        for(int i=2;i*i<n;i++){\\n            if(temp[i]==0){\\n                for(int j=i*i;j<n;j+=i){\\n                    temp[j]=1;\\n                }\\n            }\\n        }\\n        vector<int> prime;\\n        for(int i=2;i<n;i++){\\n            if(temp[i]==0){\\n                prime.push_back(i);\\n            }\\n        }\\n\\n        vector<vector<int>> ans;\\n        int i=0;\\n        int j=prime.size()-1;\\n        while(i<=j){\\n            vector<int> t;\\n            if((prime[i]+prime[j])==n){\\n                \\n                ans.push_back({prime[i],prime[j]});\\n                i++;\\n                j--;\\n            }\\n            else if((prime[i]+prime[j])<n){\\n                i++;\\n            }\\n            else\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int> temp(n,0);\\n\\n        for(int i=2;i*i<n;i++){\\n            if(temp[i]==0){\\n                for(int j=i*i;j<n;j+=i){\\n                    temp[j]=1;\\n                }\\n            }\\n        }\\n        vector<int> prime;\\n        for(int i=2;i<n;i++){\\n            if(temp[i]==0){\\n                prime.push_back(i);\\n            }\\n        }\\n\\n        vector<vector<int>> ans;\\n        int i=0;\\n        int j=prime.size()-1;\\n        while(i<=j){\\n            vector<int> t;\\n            if((prime[i]+prime[j])==n){\\n                \\n                ans.push_back({prime[i],prime[j]});\\n                i++;\\n                j--;\\n            }\\n            else if((prime[i]+prime[j])<n){\\n                i++;\\n            }\\n            else\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719136,
                "title": "linear-sieve-o-1-primality-check-prunning-beats-99-76-by-runtime-small-code",
                "content": "# Approach\\nUse linear sieve to find all prime upto `10^6`, `p` contains primes and `isp[i]` to check if number `i` is prime or not. In function `findPrimePairs(int n)` iterate just over prime less than n and for each prime `e` check if `n-e` is prime or not by using array `isp[i]`, if yes push `[e, n-e]` if not go to next prime, and if `(n-e)<e` then break because for the later primes that satisfy the above condition `e` would be greater than `(n-e)`, but for the valid pairs first number should be smaller than or equal to second number.\\n\\n# Complexity\\n- Time complexity: $$O(no.\\\\:of\\\\:primes < n)$$ or $$O(\\u03C0(n))$$\\n\\n- Space complexity: $$O(1)$$ for each testcase.\\n\\n# Code\\n```\\n#define pb push_back\\nusing ll = long long;\\nusing vi = vector<int>;\\nconst int mxn = 1e6 + 10;\\nvi p, isp(mxn, 1);\\n\\nvoid init(){\\n    if(isp[0]==0)return;\\n    isp[0] = isp[1] = 0;\\n    for(int i=2;i<mxn;i++){\\n        if(isp[i])p.pb(i);\\n        for(int j=0;j<p.size() && (i*1ll*p[j])<(mxn*1ll);j++){\\n            isp[p[j] * i] = 0;\\n            if(i % p[j])continue;\\n            break;\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        init();\\n        vector<vi> ans;\\n        for(auto e: p){\\n            if((n-e)<e)break;\\n            if(isp[n-e])ans.pb({e, n-e});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pb push_back\\nusing ll = long long;\\nusing vi = vector<int>;\\nconst int mxn = 1e6 + 10;\\nvi p, isp(mxn, 1);\\n\\nvoid init(){\\n    if(isp[0]==0)return;\\n    isp[0] = isp[1] = 0;\\n    for(int i=2;i<mxn;i++){\\n        if(isp[i])p.pb(i);\\n        for(int j=0;j<p.size() && (i*1ll*p[j])<(mxn*1ll);j++){\\n            isp[p[j] * i] = 0;\\n            if(i % p[j])continue;\\n            break;\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        init();\\n        vector<vi> ans;\\n        for(auto e: p){\\n            if((n-e)<e)break;\\n            if(isp[n-e])ans.pb({e, n-e});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718688,
                "title": "sieve-of-eratosthenes-two-pointers-c",
                "content": "```\\nclass Solution {\\n    vector<int> findPrimes(int n) {\\n        vector<int> v(n + 1), ans;\\n        \\n        for(int i=2; i<=sqrt(n); i++) {\\n            if(!v[i]) {\\n                for(int j=i*i; j<=n; j+=i) v[j] = 1;\\n            }\\n        }\\n        \\n        for(int i=2; i<=n; i++) {\\n            if(!v[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int> primes = findPrimes(n);\\n        \\n        vector<vector<int>> ans;\\n        int s = 0, e = primes.size() - 1;\\n        \\n        while(s <= e) {\\n            if(primes[s] + primes[e] == n) ans.push_back({primes[s], primes[e]}), s++;\\n            else if(primes[s] + primes[e] < n) s++;\\n            else e--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> findPrimes(int n) {\\n        vector<int> v(n + 1), ans;\\n        \\n        for(int i=2; i<=sqrt(n); i++) {\\n            if(!v[i]) {\\n                for(int j=i*i; j<=n; j+=i) v[j] = 1;\\n            }\\n        }\\n        \\n        for(int i=2; i<=n; i++) {\\n            if(!v[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int> primes = findPrimes(n);\\n        \\n        vector<vector<int>> ans;\\n        int s = 0, e = primes.size() - 1;\\n        \\n        while(s <= e) {\\n            if(primes[s] + primes[e] == n) ans.push_back({primes[s], primes[e]}), s++;\\n            else if(primes[s] + primes[e] < n) s++;\\n            else e--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715220,
                "title": "easy-solution-using-sieve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever there are a series of prime numbers required, the first thing that comes to mind is the sieve of eratosthenes and that is what I have used here. \\nThe sieve filters oyt the prime numbers out of the composite numbers.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe find all the prime numbers upto $$n$$ (using the sieve) then iterate over the sieve to find all such pairs that sum up to $$n$$.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince we are making use of sieve, we require an extra array of size $$n$$. Therefore, space complexity is $$O(n)$$.\\n\\n# Python3 Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        ans = []\\n        \\n        prime = [True for _ in range(n+1)]\\n        prime[0] = prime[1] = False\\n        \\n        for i in range(2, n+1):\\n            if prime[i]:\\n                j = i*i\\n                \\n                while j<=n:\\n                    prime[j] = False\\n                    j += i\\n        for i in range(2,n):\\n            if i+i>n: break\\n            if prime[i] and prime[n-i]:\\n                ans.append([i,n-i])\\n        return ans\\n    \\n```\\n# C++ Code\\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> findPrimePairs(int n) {\\n        std::vector<std::vector<int>> ans;\\n        \\n        std::vector<bool> prime(n+1, true);\\n        prime[0] = prime[1] = false;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            if (prime[i]) {\\n                int j = i * i;\\n                \\n                while (j <= n) {\\n                    prime[j] = false;\\n                    j += i;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 2; i < n; i++) {\\n            if (i + i > n) break;\\n            if (prime[i] && prime[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n# Java Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        boolean[] prime = new boolean[n+1];\\n        Arrays.fill(prime, true);\\n        prime[0] = prime[1] = false;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            if (prime[i]) {\\n                int j = i * i;\\n                \\n                while (j <= n) {\\n                    prime[j] = false;\\n                    j += i;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 2; i < n; i++) {\\n            if (i + i > n) break;\\n            if (prime[i] && prime[n - i]) {\\n                ans.add(Arrays.asList(i, n - i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        ans = []\\n        \\n        prime = [True for _ in range(n+1)]\\n        prime[0] = prime[1] = False\\n        \\n        for i in range(2, n+1):\\n            if prime[i]:\\n                j = i*i\\n                \\n                while j<=n:\\n                    prime[j] = False\\n                    j += i\\n        for i in range(2,n):\\n            if i+i>n: break\\n            if prime[i] and prime[n-i]:\\n                ans.append([i,n-i])\\n        return ans\\n    \\n```\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> findPrimePairs(int n) {\\n        std::vector<std::vector<int>> ans;\\n        \\n        std::vector<bool> prime(n+1, true);\\n        prime[0] = prime[1] = false;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            if (prime[i]) {\\n                int j = i * i;\\n                \\n                while (j <= n) {\\n                    prime[j] = false;\\n                    j += i;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 2; i < n; i++) {\\n            if (i + i > n) break;\\n            if (prime[i] && prime[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        boolean[] prime = new boolean[n+1];\\n        Arrays.fill(prime, true);\\n        prime[0] = prime[1] = false;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            if (prime[i]) {\\n                int j = i * i;\\n                \\n                while (j <= n) {\\n                    prime[j] = false;\\n                    j += i;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 2; i < n; i++) {\\n            if (i + i > n) break;\\n            if (prime[i] && prime[n - i]) {\\n                ans.add(Arrays.asList(i, n - i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3712523,
                "title": "easy-to-understand-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nObtain all the prime numbers less than n using sieve of eratosthenes. Iterate on all numbers less than n, say x. Check if x and n-x are primes. If they both are prime add it to list of answers.  \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    static boolean[] sieve=new boolean[1000001];\\n\\n    //function to build Prime Sieve \\n    public void buildSieve(int n){\\n        for(int i=0;i<n;i++){\\n            if(i%2==0)\\n                sieve[i]=false;\\n            else\\n                sieve[i]=true;\\n        }\\n        sieve[2]=true;\\n        sieve[0]=false;\\n        sieve[1]=false;\\n        \\n        for(int i=3;i*i<=n;i+=2){\\n            if(sieve[i]==true){\\n                for(int j=i*i;j<=n;j+=i){\\n                    sieve[j]=false;\\n                }\\n            }\\n        }\\n    }\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        \\n        List<List<Integer>> ans=new ArrayList<>();\\n        buildSieve(n);\\n        for(int i=2;i<=n/2;i++){\\n            if(sieve[i] && sieve[n-i]){\\n                List<Integer> a=new ArrayList<>();\\n                a.add(i);\\n                a.add(n-i);\\n                ans.add(a);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static boolean[] sieve=new boolean[1000001];\\n\\n    //function to build Prime Sieve \\n    public void buildSieve(int n){\\n        for(int i=0;i<n;i++){\\n            if(i%2==0)\\n                sieve[i]=false;\\n            else\\n                sieve[i]=true;\\n        }\\n        sieve[2]=true;\\n        sieve[0]=false;\\n        sieve[1]=false;\\n        \\n        for(int i=3;i*i<=n;i+=2){\\n            if(sieve[i]==true){\\n                for(int j=i*i;j<=n;j+=i){\\n                    sieve[j]=false;\\n                }\\n            }\\n        }\\n    }\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        \\n        List<List<Integer>> ans=new ArrayList<>();\\n        buildSieve(n);\\n        for(int i=2;i<=n/2;i++){\\n            if(sieve[i] && sieve[n-i]){\\n                List<Integer> a=new ArrayList<>();\\n                a.add(i);\\n                a.add(n-i);\\n                ans.add(a);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712072,
                "title": "c-two-pointer-sieve-of-eratosthenes",
                "content": "# Code\\n```\\nclass Solution {\\n    private:\\n            void findSubSet( vector<vector<int>>&ans, vector<int>&nums, int n){\\n        int i=0,j=nums.size()-1;\\n        while(i<=j){\\n            if(nums[i]+nums[j]==n){\\n                ans.push_back({nums[i],nums[j]});\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i]+nums[j]<n)\\n            i++;\\n            else\\n            j--;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        vector<int>store;\\n               vector<bool>prime(n+1,true);\\n            prime[0]=prime[1]=false;\\n        \\n             for(int i=2;i<n;i++){\\n             if(prime[i])\\n             v.push_back(i);\\n             for(int j=2*i;j<n;j+=i)   \\n             prime[j]=false;\\n             }\\n                \\n        // sort(v.begin(),v.end());\\n       findSubSet(ans,v, n);\\n        return ans;\\n        \\n    }\\n};\\n```\\n# Please Upvote!",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n            void findSubSet( vector<vector<int>>&ans, vector<int>&nums, int n){\\n        int i=0,j=nums.size()-1;\\n        while(i<=j){\\n            if(nums[i]+nums[j]==n){\\n                ans.push_back({nums[i],nums[j]});\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i]+nums[j]<n)\\n            i++;\\n            else\\n            j--;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        vector<int>store;\\n               vector<bool>prime(n+1,true);\\n            prime[0]=prime[1]=false;\\n        \\n             for(int i=2;i<n;i++){\\n             if(prime[i])\\n             v.push_back(i);\\n             for(int j=2*i;j<n;j+=i)   \\n             prime[j]=false;\\n             }\\n                \\n        // sort(v.begin(),v.end());\\n       findSubSet(ans,v, n);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710691,
                "title": "sieve-of-eratosthenes-java-c-python-solution",
                "content": "# C++ Solution\\n```\\nclass Solution {\\npublic:\\n  vector<vector<int>> findPrimePairs(int n) {\\n        // steive of eratharos\\n        vector<bool> vis(n + 1, true);\\n        for (int i = 2; i * i <= n; i++){\\n            if (vis[i]){\\n                for (int j = 2 * i; j <= n; j += i){\\n                    vis[j] = false;\\n                }\\n            }        \\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        for (int i = 2; i <= n / 2; i++){\\n            int x = i;\\n            int y = n - i;\\n            \\n            if (vis[x] && vis[y] && x <= y){\\n                ans.push_back({x, y});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# Java Solution\\n```\\nclass Solution {\\n    public static List<List<Integer>> findPrimePairs(int n) {\\n        // sieve of Eratosthenes\\n        boolean[] vis = new boolean[n + 1];\\n        for (int i = 2; i * i <= n; i++) {\\n            if (!vis[i]) {\\n                for (int j = 2 * i; j <= n; j += i) {\\n                    vis[j] = true;\\n                }\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for (int i = 2; i <= n / 2; i++) {\\n            int x = i;\\n            int y = n - i;\\n\\n            if (!vis[x] && !vis[y] && x <= y) {\\n                List<Integer> pair = new ArrayList<>();\\n                pair.add(x);\\n                pair.add(y);\\n                ans.add(pair);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n# Python3 Solution \\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        # sieve of Eratosthenes\\n        vis = [False] * (n + 1)\\n        for i in range(2, int(n**0.5) + 1):\\n            if not vis[i]:\\n                for j in range(2 * i, n + 1, i):\\n                    vis[j] = True\\n\\n        ans = []\\n\\n        for i in range(2, n // 2 + 1):\\n            x = i\\n            y = n - i\\n\\n            if not vis[x] and not vis[y] and x <= y:\\n                ans.append([x, y])\\n\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<vector<int>> findPrimePairs(int n) {\\n        // steive of eratharos\\n        vector<bool> vis(n + 1, true);\\n        for (int i = 2; i * i <= n; i++){\\n            if (vis[i]){\\n                for (int j = 2 * i; j <= n; j += i){\\n                    vis[j] = false;\\n                }\\n            }        \\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        for (int i = 2; i <= n / 2; i++){\\n            int x = i;\\n            int y = n - i;\\n            \\n            if (vis[x] && vis[y] && x <= y){\\n                ans.push_back({x, y});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public static List<List<Integer>> findPrimePairs(int n) {\\n        // sieve of Eratosthenes\\n        boolean[] vis = new boolean[n + 1];\\n        for (int i = 2; i * i <= n; i++) {\\n            if (!vis[i]) {\\n                for (int j = 2 * i; j <= n; j += i) {\\n                    vis[j] = true;\\n                }\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for (int i = 2; i <= n / 2; i++) {\\n            int x = i;\\n            int y = n - i;\\n\\n            if (!vis[x] && !vis[y] && x <= y) {\\n                List<Integer> pair = new ArrayList<>();\\n                pair.add(x);\\n                pair.add(y);\\n                ans.add(pair);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        # sieve of Eratosthenes\\n        vis = [False] * (n + 1)\\n        for i in range(2, int(n**0.5) + 1):\\n            if not vis[i]:\\n                for j in range(2 * i, n + 1, i):\\n                    vis[j] = True\\n\\n        ans = []\\n\\n        for i in range(2, n // 2 + 1):\\n            x = i\\n            y = n - i\\n\\n            if not vis[x] and not vis[y] and x <= y:\\n                ans.append([x, y])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708487,
                "title": "simple-and-faster-using-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> li=new ArrayList<>();\\n        if(n<4){\\n            return li;\\n        }\\n        boolean[] ans=prime(n+1);\\n        for(int i=2;i<=n/2+1;i++){\\n            if(!ans[i]){\\n                int a=n-i;\\n                if(!ans[a]&&i<=a){\\n                    li.add(new ArrayList<>(Arrays.asList(i,a)));\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n    public static boolean[] prime(int n) {\\n\\tboolean[]arr=new boolean[n+1];\\n\\tarr[0]=arr[1]=true;\\n\\tfor(int i=2;i<arr.length;i++) {\\n\\t\\tif(!arr[i]) {\\n\\t\\t\\tfor(int k=2;k*i<arr.length;k++) {\\n\\t\\t\\t\\tarr[i*k]=true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn arr;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> li=new ArrayList<>();\\n        if(n<4){\\n            return li;\\n        }\\n        boolean[] ans=prime(n+1);\\n        for(int i=2;i<=n/2+1;i++){\\n            if(!ans[i]){\\n                int a=n-i;\\n                if(!ans[a]&&i<=a){\\n                    li.add(new ArrayList<>(Arrays.asList(i,a)));\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n    public static boolean[] prime(int n) {\\n\\tboolean[]arr=new boolean[n+1];\\n\\tarr[0]=arr[1]=true;\\n\\tfor(int i=2;i<arr.length;i++) {\\n\\t\\tif(!arr[i]) {\\n\\t\\t\\tfor(int k=2;k*i<arr.length;k++) {\\n\\t\\t\\t\\tarr[i*k]=true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn arr;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708096,
                "title": "easy-c-solution-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Mark those numbers who are prime using boolean ```ifPrime``` array.\\n- Now check for pair ```{ i, n-i }``` if they both are prime then took that pair into your answer vector.\\n\\n![Screenshot 2023-07-02 161008.png](https://assets.leetcode.com/users/images/be94939d-d0d7-47ca-8ea4-621cd2bb9afd_1688294439.3024561.png)\\n\\nPlease Upvote if you like the solution\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n\\t\\tvector<bool> ifPrime(n, true);\\n        vector<vector<int>> v;\\n\\t\\tifPrime[0] = ifPrime[1] = false;\\n\\t\\tfor(int i = 0; i < sqrt(n); i++) {\\n\\t\\t\\tif(ifPrime[i]) {\\n\\t\\t\\t\\tfor(int j = 2; i*j < n; j++) {\\n                    ifPrime[i*j] = false;\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n        for(int i = 0; i <= n/2; i++) {\\n            if(ifPrime[i] == true && ifPrime[n-i] == true) {\\n                v.push_back({i, n-i});\\n            }\\n        }\\n\\t\\treturn v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```ifPrime```\n```{ i, n-i }```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n\\t\\tvector<bool> ifPrime(n, true);\\n        vector<vector<int>> v;\\n\\t\\tifPrime[0] = ifPrime[1] = false;\\n\\t\\tfor(int i = 0; i < sqrt(n); i++) {\\n\\t\\t\\tif(ifPrime[i]) {\\n\\t\\t\\t\\tfor(int j = 2; i*j < n; j++) {\\n                    ifPrime[i*j] = false;\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n        for(int i = 0; i <= n/2; i++) {\\n            if(ifPrime[i] == true && ifPrime[n-i] == true) {\\n                v.push_back({i, n-i});\\n            }\\n        }\\n\\t\\treturn v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707632,
                "title": "100-fast-solution-266ms-runtime-special-odd-optimization-sieve-of-eratosthenes",
                "content": "# Intuition\\nWe first store all prime numbers till n in a boolean vector\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log(log n))\\n\\nThe time complexity of the given code is O(n log log n), where n represents the input limit.\\n\\nLet\\'s analyze the code step by step:\\n\\n1. The line `isPrime.resize(limit + 1, true);` takes O(n) time, as it resizes the `isPrime` vector to accommodate the numbers from 0 to `limit` and initializes all elements to `true`.\\n\\n2. The lines `isPrime[0] = isPrime[1] = false;` take constant time, as they update the values of the first two elements in the `isPrime` vector.\\n\\n3. The loop `for (int num = 2; num * num <= limit; ++num)` runs from 2 to the square root of `limit`. The number of iterations for this loop is approximately \\u221An, which gives it a time complexity of O(\\u221An).\\n\\n4. Inside the outer loop, there is an inner loop `for (int multiple = num * num; multiple <= limit; multiple += num)` that iterates from `num * num` to `limit` with a step size of `num`. This loop marks all multiples of `num` as non-prime by setting `isPrime[multiple]` to `false`. The number of iterations for this loop can be approximated as `limit / num`, which gives it a time complexity of O(n/num).\\n\\n5. Combining the time complexity of the outer loop (O(\\u221An)) and the inner loop (O(n/num)) gives the overall time complexity of the code.\\n\\nTo find the total time complexity, we can calculate the sum of the time complexity for each iteration of the outer loop:\\n\\n\\u221An + \\u221An/2 + \\u221An/3 + ... + \\u221An/\\u221An\\n\\nThis sum can be simplified to O(n log log n) using mathematical analysis. Therefore, the overall time complexity of the code is O(n log log n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# PLEASE UPVOTE if you understood\\n\\nAs odd numbers can only be split up into (odd + even), there can only be once possible pair that we need to check that is (2, n-2). As 2 is the only even prime number. This reduces complexity way too much.\\n\\n# Code\\n```\\nclass Solution {\\n    vector<bool> isPrime;\\npublic:\\n    void setPrime(const int limit) {\\n        // resize the vector to fit values\\n        isPrime.resize(limit + 1, true);\\n        // 0 and 1 are not prime\\n        isPrime[0] = isPrime[1] = false;\\n\\n        // applying Sieve of Eratosthenes\\n        for (int num = 2; num * num <= limit; ++num)\\n            if (isPrime[num]) \\n                for (int multiple = num * num; multiple <= limit; multiple += num) \\n                    isPrime[multiple] = false;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        if(n <= 3) return {};\\n        vector<vector<int>> ans;\\n        setPrime(n);\\n        \\n        // check for n-2 separately, as it will be the only even \\'i\\'\\n        if(isPrime[n-2]) \\n            ans.push_back({2, n-2});\\n        if(n & 1) return ans;\\n        // we check for only odd \\'i\\'s, starting from 3\\n        // as even \\'i\\'s won\\'t be prime, obviously\\n        for(int i=3; i<=n/2; i+=2)\\n            if(isPrime[i] && isPrime[n-i]) \\n                ans.push_back({i, n-i});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    vector<bool> isPrime;\\npublic:\\n    void setPrime(const int limit) {\\n        // resize the vector to fit values\\n        isPrime.resize(limit + 1, true);\\n        // 0 and 1 are not prime\\n        isPrime[0] = isPrime[1] = false;\\n\\n        // applying Sieve of Eratosthenes\\n        for (int num = 2; num * num <= limit; ++num)\\n            if (isPrime[num]) \\n                for (int multiple = num * num; multiple <= limit; multiple += num) \\n                    isPrime[multiple] = false;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        if(n <= 3) return {};\\n        vector<vector<int>> ans;\\n        setPrime(n);\\n        \\n        // check for n-2 separately, as it will be the only even \\'i\\'\\n        if(isPrime[n-2]) \\n            ans.push_back({2, n-2});\\n        if(n & 1) return ans;\\n        // we check for only odd \\'i\\'s, starting from 3\\n        // as even \\'i\\'s won\\'t be prime, obviously\\n        for(int i=3; i<=n/2; i+=2)\\n            if(isPrime[i] && isPrime[n-i]) \\n                ans.push_back({i, n-i});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707407,
                "title": "sieve-of-eratosthenes-prime-pair-with-target-sum-c-easy",
                "content": "# Approach\\nFirst we have generated all the prime number from the Algorithm\\n\"sieve of eratosthenes\" using a boolean array of prime numbers...and then used for loop to iterate over the prime numbers and marked the prime number as false which are used...\\n\\n# Time Complexity\\n- Time complexity: TC for generating Sieve of Eratosthenes-->O(nlog(logn))\\n- TC->O(n) for iterating over the sieve for integer n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\nvoid sieve(int n,vector<bool>&isPrime){\\n    \\n    isPrime[0]=isPrime[1]=false;\\n    \\n    for (int p = 2; p * p <= n; p++) {\\n      \\n        if (isPrime[p] == true) {\\n            for (int i = p * p; i <= n; i += p)\\n                isPrime[i] = false;\\n        }\\n    }\\n}\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n        vector<bool> isPrime(n+1, true);\\n          vector<vector<int>>ans;\\n    \\n        sieve(n,isPrime);\\n        \\n        for(int i=2;i<=n;i++){\\n            if(isPrime[i] && isPrime[n-i]){\\n                isPrime[i]=false;\\n                isPrime[n-i]=false;\\n                ans.push_back({i,n-i});\\n            }\\n        }\\n      \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nvoid sieve(int n,vector<bool>&isPrime){\\n    \\n    isPrime[0]=isPrime[1]=false;\\n    \\n    for (int p = 2; p * p <= n; p++) {\\n      \\n        if (isPrime[p] == true) {\\n            for (int i = p * p; i <= n; i += p)\\n                isPrime[i] = false;\\n        }\\n    }\\n}\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n        vector<bool> isPrime(n+1, true);\\n          vector<vector<int>>ans;\\n    \\n        sieve(n,isPrime);\\n        \\n        for(int i=2;i<=n;i++){\\n            if(isPrime[i] && isPrime[n-i]){\\n                isPrime[i]=false;\\n                isPrime[n-i]=false;\\n                ans.push_back({i,n-i});\\n            }\\n        }\\n      \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707170,
                "title": "beats-100-easy-to-understand-intuition-approach-explained",
                "content": "# Intuition\\nSimple function to find prime would give TLE. Hence we need a more optimised solution to pass prime numbers and then perform the given conditions on the question. \\n\\nThe **Sieve of Eratosthenes** is an efficient algorithm for finding all prime numbers up to a given limit n. Here\\'s a three-line description of the algorithm:\\n\\n1. Initialize a boolean array of size n+1 and mark all elements as true.\\n2. Starting from the first prime number, iterate through the array and mark all multiples of each prime as false, as they cannot be prime numbers.\\n3. The remaining unmarked numbers in the array are prime numbers.\\n\\n\\n# Approach\\nWe first generate a boolean array isPrime of size n + 1, where each index represents a number and the value at that index indicates whether it\\'s prime or not. We initialize all elements as true initially. Then we use the Sieve of Eratosthenes algorithm to mark non-prime numbers as false. This step has a time complexity of O(n log log n).\\n\\nAfter generating the primes, we iterate from 2 to n / 2 and check if both i and n - i are prime using the isPrime array. If they are both prime, we add them to the ans vector.\\n\\nThe line **isPrime[0] = isPrime[1] = false**; is used to explicitly mark the numbers 0 and 1 as non-prime. In most number theory conventions, 0 and 1 are not considered prime numbers. By setting isPrime[0] and isPrime[1] to false, we indicate that these numbers should be treated as non-prime.\\n\\nIn the Sieve of Eratosthenes algorithm, the loop starts from i = 2, so explicitly marking isPrime[0] and isPrime[1] as false ensures that they are not mistakenly considered as prime numbers during the algorithm execution.\\n\\n# Complexity\\n- Time complexity: ***O(n log log n).***\\n\\n\\n- Space complexity: ***O(n)*** since it requires an additional boolean array of size n+1 to store the prime flags. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> isPrime(n + 1, true);\\n        isPrime[0] = isPrime[1] = false;\\n\\n        for (int i = 2; i * i <= n; i++) {\\n            if (isPrime[i]) {\\n                for (int j = i * i; j <= n; j += i) {\\n                    isPrime[j] = false;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> ans;\\n        for (int i = 2; i <= n / 2; i++) {\\n            if (isPrime[i] && isPrime[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> isPrime(n + 1, true);\\n        isPrime[0] = isPrime[1] = false;\\n\\n        for (int i = 2; i * i <= n; i++) {\\n            if (isPrime[i]) {\\n                for (int j = i * i; j <= n; j += i) {\\n                    isPrime[j] = false;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> ans;\\n        for (int i = 2; i <= n / 2; i++) {\\n            if (isPrime[i] && isPrime[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707052,
                "title": "c-straightforward-solution-no-set-map-required",
                "content": "# Intuition\\nUse \\'sieve of eratosthenes\\' algorithm to find the vector of all primes less than equal to \\'n\\'.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n// sieve of eratosthenes -> to get all primes from 2 to n (n<=1e6);\\n        vector<int> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n\\n        for(int i=2; i*i<=n; i++){\\n\\n            if(prime[i]==true){\\n                for(int j=i*i; j<=n; j=j+i){\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n// checking the \\'prime\\' vector to obtain i and j where (i+j==n)\\n        vector<vector<int>>ans;\\n\\n        for(int i=2; i<n; i++){\\n            int j = n-i;\\n            if(prime[i]&&prime[j]&&i<=j){\\n                ans.push_back({i,j});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n// sieve of eratosthenes -> to get all primes from 2 to n (n<=1e6);\\n        vector<int> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n\\n        for(int i=2; i*i<=n; i++){\\n\\n            if(prime[i]==true){\\n                for(int j=i*i; j<=n; j=j+i){\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n// checking the \\'prime\\' vector to obtain i and j where (i+j==n)\\n        vector<vector<int>>ans;\\n\\n        for(int i=2; i<n; i++){\\n            int j = n-i;\\n            if(prime[i]&&prime[j]&&i<=j){\\n                ans.push_back({i,j});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706958,
                "title": "python-find-all-primes-and-then-two-sum",
                "content": "# Intuition\\nFind all primes with sieve and then two sum\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log \\\\log n)$\\n\\n- Space complexity: $n / \\\\log n$\\n\\n# Code\\n```\\nclass Solution:\\n\\n  def eratosthenes_sieve(self, n):\\n    prime, result, sqrt_n = [True] * n, [2], (int(n ** .5) + 1) | 1\\n    for p in range(3, sqrt_n, 2):\\n      if prime[p]:\\n        result.append(p)\\n        prime[p * p::p << 1] = [False] * ((n - p * p - 1) // (p << 1) + 1)\\n\\n    return result + [p for p in range(sqrt_n, n, 2) if prime[p]]\\n\\n  def findPrimePairs(self, n: int) -> List[List[int]]:\\n    primes_list = self.eratosthenes_sieve(n + 1)\\n    primes_set = set(primes_list)\\n    res = []\\n    for p in primes_list:\\n      if p > n - p:\\n        break\\n      if n - p in primes_set:\\n        res.append([p, n - p])\\n    return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n  def eratosthenes_sieve(self, n):\\n    prime, result, sqrt_n = [True] * n, [2], (int(n ** .5) + 1) | 1\\n    for p in range(3, sqrt_n, 2):\\n      if prime[p]:\\n        result.append(p)\\n        prime[p * p::p << 1] = [False] * ((n - p * p - 1) // (p << 1) + 1)\\n\\n    return result + [p for p in range(sqrt_n, n, 2) if prime[p]]\\n\\n  def findPrimePairs(self, n: int) -> List[List[int]]:\\n    primes_list = self.eratosthenes_sieve(n + 1)\\n    primes_set = set(primes_list)\\n    res = []\\n    for p in primes_list:\\n      if p > n - p:\\n        break\\n      if n - p in primes_set:\\n        res.append([p, n - p])\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706785,
                "title": "c-simple-approach-beginner-friendly-sieve-of-eratosthenes-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck all the pairs of that sum up to n whether they are prime or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a vector of size (n+1) initialized true to represent whether the number at that index is prime or not.\\n2. Mark the mulitples of the prime numbers to be false in that vector.\\n3. Take two variables i and j to represent the two numbers that sum up to be n.\\n4. Run a loop from i = 2 to n/2 and calculate corresponding value of j = n-i in each loop.\\n5. Check if both i and j are prime then add the pair to ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn) for finding prime numbers\\n    O(n) for finding pairs\\n\\n    So, finally\\n    O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        //if n<4 then it can\\'t be sum of two prime nos.\\n        if (n<4) return {};\\n\\n        //a vector to indicate prime nos. <= n\\n        vector<bool> prime(n+1,true);\\n\\n        // 0 and 1 are not prime\\n        prime[0]=prime[1]=false;\\n\\n        // 2 onwards marking all the numbers that are multiples of\\n        // prime number to be not prime by marking them false\\n        for(int i=2;i<=n;i++)\\n          if(prime[i] && (long long)i*i<=n)\\n              for(int j=i*i;j<=n;j+=i) prime[j] = false;\\n\\n        vector<vector<int>> ans;\\n        int i=2,j;\\n\\n        // starting a loop form i=2 i.e. first prime no.\\n        // taking loop till n/2 since pairs will start repeating in\\n        //opposite order after that\\n        while(i<=n/2){\\n            j=n-i;\\n\\n            //if i and j are prime, push the pair in ans\\n            if(prime[i] && prime[j]) ans.push_back({i,j});\\n\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        //if n<4 then it can\\'t be sum of two prime nos.\\n        if (n<4) return {};\\n\\n        //a vector to indicate prime nos. <= n\\n        vector<bool> prime(n+1,true);\\n\\n        // 0 and 1 are not prime\\n        prime[0]=prime[1]=false;\\n\\n        // 2 onwards marking all the numbers that are multiples of\\n        // prime number to be not prime by marking them false\\n        for(int i=2;i<=n;i++)\\n          if(prime[i] && (long long)i*i<=n)\\n              for(int j=i*i;j<=n;j+=i) prime[j] = false;\\n\\n        vector<vector<int>> ans;\\n        int i=2,j;\\n\\n        // starting a loop form i=2 i.e. first prime no.\\n        // taking loop till n/2 since pairs will start repeating in\\n        //opposite order after that\\n        while(i<=n/2){\\n            j=n-i;\\n\\n            //if i and j are prime, push the pair in ans\\n            if(prime[i] && prime[j]) ans.push_back({i,j});\\n\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706660,
                "title": "java-fast-solution",
                "content": "```\\nclass Solution {\\n    private static HashSet<Integer> primes = new HashSet<>();\\n    private static List<Integer> list = new ArrayList<>();\\n    static {\\n        int m = 1_000_001;\\n        boolean[] visited = new boolean[m];\\n        for(int i=2;i<m;i++) {\\n            if(!visited[i]){\\n                primes.add(i);\\n                list.add(i);\\n                for(int j=i;j<m;j+=i) visited[j] = true;\\n            }\\n        }\\n    }\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        for(int a: list){\\n            int other = n-a;\\n            if(other<n/2 || a>n/2) break;\\n            if(primes.contains(other)) answer.add(List.of(a,other));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static HashSet<Integer> primes = new HashSet<>();\\n    private static List<Integer> list = new ArrayList<>();\\n    static {\\n        int m = 1_000_001;\\n        boolean[] visited = new boolean[m];\\n        for(int i=2;i<m;i++) {\\n            if(!visited[i]){\\n                primes.add(i);\\n                list.add(i);\\n                for(int j=i;j<m;j+=i) visited[j] = true;\\n            }\\n        }\\n    }\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        for(int a: list){\\n            int other = n-a;\\n            if(other<n/2 || a>n/2) break;\\n            if(primes.contains(other)) answer.add(List.of(a,other));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706640,
                "title": "c-99-optimal-beginner-friendly",
                "content": "\\n* **Optimal Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> primePairs;\\n        if (n < 4) {\\n            return primePairs;\\n        }\\n\\n        // Check for even numbers\\n        if (n % 2 == 0) {\\n            int x = n / 2;\\n            if (isPrime(x) && isPrime(n - x)) {\\n                primePairs.push_back({x, n - x});\\n            }\\n        }\\n\\n        // Check for odd numbers\\n        for (int x = 2; x <= n / 2; ++x) {\\n            int y = n - x;\\n            if (isPrime(x) && isPrime(y) && x < y) {\\n                primePairs.push_back({x, y});\\n            }\\n        }\\n\\n        sort(primePairs.begin(), primePairs.end());\\n        return primePairs;\\n    }\\n\\nprivate:\\n    bool isPrime(int x) {\\n        if (x < 2) {\\n            return false;\\n        }\\n        for (int i = 2; i * i <= x; ++i) {\\n            if (x % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n\\n* **TLE: BruteForce approach**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> primePairs;\\n        for (int x = 2; x <= n / 2; ++x) {\\n            int y = n - x;\\n            if (isPrime(x) && isPrime(y)) {\\n                primePairs.push_back({x, y});\\n            }\\n        }\\n        return primePairs;\\n    }\\n\\nprivate:\\n    bool isPrime(int x) {\\n        if (x < 2) {\\n            return false;\\n        }\\n        for (int i = 2; i <= sqrt(x); ++i) {\\n            if (x % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/322e34c3-9dd1-4ec4-946c-788e892db3d4_1688274024.5974.gif)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> primePairs;\\n        if (n < 4) {\\n            return primePairs;\\n        }\\n\\n        // Check for even numbers\\n        if (n % 2 == 0) {\\n            int x = n / 2;\\n            if (isPrime(x) && isPrime(n - x)) {\\n                primePairs.push_back({x, n - x});\\n            }\\n        }\\n\\n        // Check for odd numbers\\n        for (int x = 2; x <= n / 2; ++x) {\\n            int y = n - x;\\n            if (isPrime(x) && isPrime(y) && x < y) {\\n                primePairs.push_back({x, y});\\n            }\\n        }\\n\\n        sort(primePairs.begin(), primePairs.end());\\n        return primePairs;\\n    }\\n\\nprivate:\\n    bool isPrime(int x) {\\n        if (x < 2) {\\n            return false;\\n        }\\n        for (int i = 2; i * i <= x; ++i) {\\n            if (x % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> primePairs;\\n        for (int x = 2; x <= n / 2; ++x) {\\n            int y = n - x;\\n            if (isPrime(x) && isPrime(y)) {\\n                primePairs.push_back({x, y});\\n            }\\n        }\\n        return primePairs;\\n    }\\n\\nprivate:\\n    bool isPrime(int x) {\\n        if (x < 2) {\\n            return false;\\n        }\\n        for (int i = 2; i <= sqrt(x); ++i) {\\n            if (x % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706628,
                "title": "sieve-of-erathosthenes",
                "content": "# Intuition\\nIf we can quickly check whether a number up to `n` is prime, we can solve this problem.\\n\\nThere are many ways to check if a number is prime, but two of the important prime checking algorithms are\\n1. Finding the factors of `n` in $$O(1)$$ preprocessing and $$O(\\\\sqrt n)$$ query time.\\n2. Using a Sieve of Erathosthenes in $$O(n\\\\lg\\\\lg n)$$ preprocessing and $$O(1)$$ query time.\\n\\nWe need to check if `n` numbers are prime if we loop through all values of `x`, so we will be making `n` prime-checking queries. As such, approach (1) will take $$O(n\\\\sqrt n)$$ total time; using a sieve seems like a better approach.\\n\\n# Approach\\nUse a Sieve of Erathosthenes to get which numbers are prime or not prime up to `n`. Test all values of `x` from `2` to `n // 2 - 1` (dividing by `2` so that `x <= y = n - x`).\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\lg\\\\lg n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        # sieve\\n        prime = [False, False] + [True] * (n - 1)\\n        for i in range(2, n + 1):\\n            if prime[i]:\\n                for j in range(i * i, n + 1, i):\\n                    prime[j] = False\\n        \\n        return [[i, n - i] for i in range(2, n // 2 + 1) if prime[i] and prime[n - i]]\\n```",
                "solutionTags": [
                    "Python3",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        # sieve\\n        prime = [False, False] + [True] * (n - 1)\\n        for i in range(2, n + 1):\\n            if prime[i]:\\n                for j in range(i * i, n + 1, i):\\n                    prime[j] = False\\n        \\n        return [[i, n - i] for i in range(2, n // 2 + 1) if prime[i] and prime[n - i]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706600,
                "title": "best-c-code-sieve-of-eratosthenes",
                "content": "### Connect on LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if(n == 1 || n == 2)\\n            return ans;\\n        vector<bool> findPrime(n+1,true);\\n        for(int i=2;i<sqrt(n);i++){\\n            for(int j=i*i;j<=n;j+=i){\\n                findPrime[j]=false;\\n            }\\n        }\\n        for(int i = 2; i < n; i++){\\n            if(findPrime[i]){\\n                int x = i, y = n - x;\\n                if(y < x)\\n                    break;\\n                if(findPrime[y])\\n                    ans.push_back({x,y});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/ee60bc65-95f3-44df-a05f-3e8d64696b9d_1688273441.7786038.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if(n == 1 || n == 2)\\n            return ans;\\n        vector<bool> findPrime(n+1,true);\\n        for(int i=2;i<sqrt(n);i++){\\n            for(int j=i*i;j<=n;j+=i){\\n                findPrime[j]=false;\\n            }\\n        }\\n        for(int i = 2; i < n; i++){\\n            if(findPrime[i]){\\n                int x = i, y = n - x;\\n                if(y < x)\\n                    break;\\n                if(findPrime[y])\\n                    ans.push_back({x,y});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706569,
                "title": "java-beats-100-sieve-of-eratosthenes-simple-explanation",
                "content": "---\\n\\n## Problem: Prime Number Pairs\\n\\nYou are given an integer `n`. You need to find all the prime number pairs `[x, y]` such that `x + y = n`.\\n\\n**Approach:**\\n\\nTo solve this problem, we can generate prime numbers up to `n` using the Sieve of Eratosthenes algorithm. We initialize a boolean array `isPrime` of size `n+1` and mark all elements as prime initially. Then, starting from `2`, we iterate up to `n/2` and check if both `p` and `n - p` are prime numbers. If they are prime, we add them as a pair `[p, n-p]` to the result list.\\n\\n**Java Solution:**\\n\\n```java\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] isPrime = sieveOfEratosthenes(n); // Generate prime numbers up to n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        for (int p = 2; p <= n / 2; p++) {\\n            if (isPrime[p] && isPrime[n - p]) {\\n                res.add(List.of(p, n - p));\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private boolean[] sieveOfEratosthenes(int n) {\\n        boolean[] isPrime = new boolean[n + 1];\\n        Arrays.fill(isPrime, true);\\n        isPrime[0] = isPrime[1] = false;\\n\\n        for (int p = 2; p * p <= n; p++) {\\n            if (isPrime[p]) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    isPrime[i] = false;\\n                }\\n            }\\n        }\\n\\n        return isPrime;\\n    }\\n}\\n```\\n\\n**Python Solution:**\\n\\n```python\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        is_prime = self.sieveOfEratosthenes(n)  # Generate prime numbers up to n\\n        res = []\\n\\n        for p in range(2, n // 2 + 1):\\n            if is_prime[p] and is_prime[n - p]:\\n                res.append([p, n - p])\\n\\n        return res\\n\\n    def sieveOfEratosthenes(self, n: int) -> List[bool]:\\n        is_prime = [True] * (n + 1)\\n        is_prime[0] = is_prime[1] = False\\n\\n        p = 2\\n        while p * p <= n:\\n            if is_prime[p]:\\n                for i in range(p * p, n + 1, p):\\n                    is_prime[i] = False\\n            p += 1\\n\\n        return is_prime\\n```\\n\\n**C++ Solution:**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> isPrime = sieveOfEratosthenes(n); // Generate prime numbers up to n\\n        vector<vector<int>> res;\\n\\n        for (int p = 2; p <= n / 2; p++) {\\n            if (isPrime[p] && isPrime[n - p]) {\\n                res.push_back({p, n - p});\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    vector<bool> sieveOfEratosthenes(int n) {\\n        vector<bool> isPrime(n + 1, true);\\n        isPrime[0] = isPrime[1] = false;\\n\\n        for (int p =\\n\\n 2; p * p <= n; p++) {\\n            if (isPrime[p]) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    isPrime[i] = false;\\n                }\\n            }\\n        }\\n\\n        return isPrime;\\n    }\\n};\\n```\\n\\n**Complexity Analysis:**\\n\\nThe time complexity of the solution is O(n log log n) as we use the Sieve of Eratosthenes algorithm to generate prime numbers. The space complexity is O(n) to store the boolean array `isPrime`.\\n\\n---\\n![leetcode.jpeg](https://assets.leetcode.com/users/images/9cad87c7-0187-43ba-b53e-547ed77944a4_1688273254.9208426.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] isPrime = sieveOfEratosthenes(n); // Generate prime numbers up to n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        for (int p = 2; p <= n / 2; p++) {\\n            if (isPrime[p] && isPrime[n - p]) {\\n                res.add(List.of(p, n - p));\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private boolean[] sieveOfEratosthenes(int n) {\\n        boolean[] isPrime = new boolean[n + 1];\\n        Arrays.fill(isPrime, true);\\n        isPrime[0] = isPrime[1] = false;\\n\\n        for (int p = 2; p * p <= n; p++) {\\n            if (isPrime[p]) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    isPrime[i] = false;\\n                }\\n            }\\n        }\\n\\n        return isPrime;\\n    }\\n}\\n```\n```python\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        is_prime = self.sieveOfEratosthenes(n)  # Generate prime numbers up to n\\n        res = []\\n\\n        for p in range(2, n // 2 + 1):\\n            if is_prime[p] and is_prime[n - p]:\\n                res.append([p, n - p])\\n\\n        return res\\n\\n    def sieveOfEratosthenes(self, n: int) -> List[bool]:\\n        is_prime = [True] * (n + 1)\\n        is_prime[0] = is_prime[1] = False\\n\\n        p = 2\\n        while p * p <= n:\\n            if is_prime[p]:\\n                for i in range(p * p, n + 1, p):\\n                    is_prime[i] = False\\n            p += 1\\n\\n        return is_prime\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> isPrime = sieveOfEratosthenes(n); // Generate prime numbers up to n\\n        vector<vector<int>> res;\\n\\n        for (int p = 2; p <= n / 2; p++) {\\n            if (isPrime[p] && isPrime[n - p]) {\\n                res.push_back({p, n - p});\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    vector<bool> sieveOfEratosthenes(int n) {\\n        vector<bool> isPrime(n + 1, true);\\n        isPrime[0] = isPrime[1] = false;\\n\\n        for (int p =\\n\\n 2; p * p <= n; p++) {\\n            if (isPrime[p]) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    isPrime[i] = false;\\n                }\\n            }\\n        }\\n\\n        return isPrime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706510,
                "title": "optimised-easy-c-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n == 1) return false;\\n        if (n == 2 || n == 3 || n == 5) return true;\\n        if (n % 2 == 0 || n % 3 == 0 || n % 5 == 0) return false;\\n        for (int i = 5; i <= sqrt(n); i += 6) {\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>ans;\\n        int low=1,high=n-1;\\n        while(low<=high){\\n            //cout<<low<<\" \"<<high<<\"\\\\n\";\\n            if(isPrime(low)==true and isPrime(high)==true){\\n                ans.push_back({low,high});\\n            }          \\n            low++,high--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n == 1) return false;\\n        if (n == 2 || n == 3 || n == 5) return true;\\n        if (n % 2 == 0 || n % 3 == 0 || n % 5 == 0) return false;\\n        for (int i = 5; i <= sqrt(n); i += 6) {\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>ans;\\n        int low=1,high=n-1;\\n        while(low<=high){\\n            //cout<<low<<\" \"<<high<<\"\\\\n\";\\n            if(isPrime(low)==true and isPrime(high)==true){\\n                ans.push_back({low,high});\\n            }          \\n            low++,high--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3706440,
                "title": "prime-list-till-n",
                "content": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        N = 1 + n\\n        sp = [1] * N\\n        v = [False] * N\\n        for i in range(2, N, 2):\\n            sp[i] = 2\\n        for i in range(3, N, 2):\\n            if not v[i]:\\n                sp[i] = i\\n                j = i\\n                while j * i < N:\\n                    v[j * i] = True\\n                    sp[j * i] = i\\n                    j += 2\\n        plist = [i for i in range(2, n + 1) if sp[i] == i]\\n        res = []\\n        seen = set()\\n        for p in plist:\\n            seen.add(p)\\n            if n - p in seen:\\n                res.append((n - p, p))\\n        res.sort()\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        N = 1 + n\\n        sp = [1] * N\\n        v = [False] * N\\n        for i in range(2, N, 2):\\n            sp[i] = 2\\n        for i in range(3, N, 2):\\n            if not v[i]:\\n                sp[i] = i\\n                j = i\\n                while j * i < N:\\n                    v[j * i] = True\\n                    sp[j * i] = i\\n                    j += 2\\n        plist = [i for i in range(2, n + 1) if sp[i] == i]\\n        res = []\\n        seen = set()\\n        for p in plist:\\n            seen.add(p)\\n            if n - p in seen:\\n                res.append((n - p, p))\\n        res.sort()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706429,
                "title": "c-sieve-of-eratosthenes",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> res;\\n\\n        // Hash prime numbers till n to check in O(1) time\\n        vector<bool> sieveIsPrime(n + 1, 0);\\n        \\n        // Sieve of Eratosthenes\\n        vector<bool> seen(n + 1);\\n        for (int i = 2; i <= n; i++) {\\n            if(!seen[i]) {\\n                sieveIsPrime[i] = 1;\\n            }\\n            for (int j = i * i; j <= n; j += i) {\\n                seen[j] = 1;\\n            }\\n        }\\n        \\n        // Check for pairs\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if(sieveIsPrime[i] && sieveIsPrime[n - i]) {\\n                res.push_back({i, n - i});\\n                // To not count same pair twice\\n                sieveIsPrime[i] = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> res;\\n\\n        // Hash prime numbers till n to check in O(1) time\\n        vector<bool> sieveIsPrime(n + 1, 0);\\n        \\n        // Sieve of Eratosthenes\\n        vector<bool> seen(n + 1);\\n        for (int i = 2; i <= n; i++) {\\n            if(!seen[i]) {\\n                sieveIsPrime[i] = 1;\\n            }\\n            for (int j = i * i; j <= n; j += i) {\\n                seen[j] = 1;\\n            }\\n        }\\n        \\n        // Check for pairs\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if(sieveIsPrime[i] && sieveIsPrime[n - i]) {\\n                res.push_back({i, n - i});\\n                // To not count same pair twice\\n                sieveIsPrime[i] = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706414,
                "title": "c-very-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>ans;\\n        vector<bool> v(n+1,1);\\n        v[0]=v[1]=0;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(v[i]){\\n                for(int j=i*i;j<=n;j+=i){\\n                    v[j]=0;\\n                }\\n            }\\n        }\\n        for(int x=2;x<=n/2;x++){\\n            int y=n-x;\\n            if(v[x]&& v[y]){\\n                if(x+y == n)ans.push_back({x,y});      \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>ans;\\n        vector<bool> v(n+1,1);\\n        v[0]=v[1]=0;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(v[i]){\\n                for(int j=i*i;j<=n;j+=i){\\n                    v[j]=0;\\n                }\\n            }\\n        }\\n        for(int x=2;x<=n/2;x++){\\n            int y=n-x;\\n            if(v[x]&& v[y]){\\n                if(x+y == n)ans.push_back({x,y});      \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706408,
                "title": "java-cache-all-seen-prime-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust check every pair with cache.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCache all prime numbers in the static field.\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  // [seen, prime]\\n  private static final boolean[][] mark = new boolean[1000000][2];\\n\\n  public List<List<Integer>> findPrimePairs(int n) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    for (int i = 2; i <= n - 2 && i <= n - i; i++) {\\n      if (!mark[i][0]) {\\n        mark[i][0] = true;\\n        mark[i][1] = prime(i);\\n      }\\n\\n      if (!mark[n - i][0]) {\\n        mark[n - i][0] = true;\\n        mark[n - i][1] = prime(n - i);\\n      }\\n\\n      if (mark[i][1] && mark[n - i][1]) {\\n        result.add(List.of(i, n - i));\\n      }\\n    }\\n\\n    return result;\\n  }\\n\\n  private boolean prime(int n) {\\n    for (int i = 2; i * i <= n; i++) {\\n      if (n % i == 0) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n  // [seen, prime]\\n  private static final boolean[][] mark = new boolean[1000000][2];\\n\\n  public List<List<Integer>> findPrimePairs(int n) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    for (int i = 2; i <= n - 2 && i <= n - i; i++) {\\n      if (!mark[i][0]) {\\n        mark[i][0] = true;\\n        mark[i][1] = prime(i);\\n      }\\n\\n      if (!mark[n - i][0]) {\\n        mark[n - i][0] = true;\\n        mark[n - i][1] = prime(n - i);\\n      }\\n\\n      if (mark[i][1] && mark[n - i][1]) {\\n        result.add(List.of(i, n - i));\\n      }\\n    }\\n\\n    return result;\\n  }\\n\\n  private boolean prime(int n) {\\n    for (int i = 2; i * i <= n; i++) {\\n      if (n % i == 0) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080476,
                "title": "simple-sieve-and-then-two-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool>v(n+1,true);\\n        v[0]=false;\\n        v[1]=false;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(v[i]==true)\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    v[j]=false;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i =0;i<n+1;i++)\\n        {\\n            if(v[i]==true)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        vector<vector<int>>aans;\\n        for(int i=0,j=ans.size()-1;i<=j;)\\n        {\\n            if(ans[i]+ans[j]==n)\\n            {\\n                vector<int>temp;\\n                temp.push_back(ans[i]);\\n                temp.push_back(ans[j]);\\n                aans.push_back(temp);\\n                i++;\\n                j--;\\n            }\\n            else if(ans[i]+ans[j]<n)\\n            {\\n                i++;\\n            }\\n            else\\n                j--;\\n        }\\n        return aans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool>v(n+1,true);\\n        v[0]=false;\\n        v[1]=false;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(v[i]==true)\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    v[j]=false;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i =0;i<n+1;i++)\\n        {\\n            if(v[i]==true)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        vector<vector<int>>aans;\\n        for(int i=0,j=ans.size()-1;i<=j;)\\n        {\\n            if(ans[i]+ans[j]==n)\\n            {\\n                vector<int>temp;\\n                temp.push_back(ans[i]);\\n                temp.push_back(ans[j]);\\n                aans.push_back(temp);\\n                i++;\\n                j--;\\n            }\\n            else if(ans[i]+ans[j]<n)\\n            {\\n                i++;\\n            }\\n            else\\n                j--;\\n        }\\n        return aans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073841,
                "title": "c-super-easy-super-small-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void twoSum(int n, vector<bool> &arr, vector<vector<int>> &ans){\\n        for(int i=2;i<=n/2;i++){\\n            if(arr[i] && arr[n-i]){\\n                ans.push_back({i, n-i});\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> arr(n+1, true);\\n        arr[0] = false;\\n        arr[1] = false;\\n        vector<vector<int>> ans;\\n        for(int i=2;i<=n;i++){\\n            if(arr[i]){\\n                if((long long)i*i<=n){\\n                    int j=i*i;\\n                    while(j<=n){\\n                        arr[j] = false;\\n                        j+=i;\\n                    }\\n                }\\n            }\\n        }\\n\\n        twoSum(n, arr, ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void twoSum(int n, vector<bool> &arr, vector<vector<int>> &ans){\\n        for(int i=2;i<=n/2;i++){\\n            if(arr[i] && arr[n-i]){\\n                ans.push_back({i, n-i});\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> arr(n+1, true);\\n        arr[0] = false;\\n        arr[1] = false;\\n        vector<vector<int>> ans;\\n        for(int i=2;i<=n;i++){\\n            if(arr[i]){\\n                if((long long)i*i<=n){\\n                    int j=i*i;\\n                    while(j<=n){\\n                        arr[j] = false;\\n                        j+=i;\\n                    }\\n                }\\n            }\\n        }\\n\\n        twoSum(n, arr, ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055580,
                "title": "simplest-10-lines-best-code-in-java",
                "content": "# Intuition\\nWe just need to find prime numbers till n\\n# Approach\\nWe find all the prime numbers till n, then we check if any number x is prime or not and (n-x) is prime or not (till n/2), if both are prime, then we add it to our answer.\\n\\n# Complexity\\n- Time complexity:\\nn*log(log(n)) - Sieve of Eratosthenes\\n\\n- Space complexity:\\nO(n) - For storing prime boolean values\\no(n) - For return answer list\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean prime[] = new boolean[n + 1];\\n        for (int i = 0; i <= n; i++)\\n            prime[i] = true;\\n  \\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        List<List<Integer>> ans = new ArrayList();\\n        for(int i = 2; i <= n/2 ; i++){\\n            if(prime[i] && prime[n-i]) ans.add(List.of(i, n-i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean prime[] = new boolean[n + 1];\\n        for (int i = 0; i <= n; i++)\\n            prime[i] = true;\\n  \\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        List<List<Integer>> ans = new ArrayList();\\n        for(int i = 2; i <= n/2 ; i++){\\n            if(prime[i] && prime[n-i]) ans.add(List.of(i, n-i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994496,
                "title": "java-easy-to-understand-using-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSieve of Eratosthenes is the only concept that you need to apply when ever you see a question with primes \\n\\n# Complexity\\n- Time complexity:\\n\\n        O(nlog(logn))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n          O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] primes=new boolean[n+1];\\n        sieve(n,primes);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=2;i<=n/2;i++){\\n            if(primes[i]==false && primes[n-i]==false){\\n                List<Integer> a=new ArrayList<>();\\n                a.add(i);\\n                a.add(n-i);\\n                ans.add(a);\\n            }\\n        }\\n        return ans;\\n    }\\n     public void sieve(int n, boolean[] primes) {\\n        for (int i = 2; i*i <= n; i++) {\\n            if (!primes[i]) {\\n                for (int j = i*2; j <= n; j+=i) {\\n                    //if a number is not prime it is true in primes array\\n                    primes[j] = true;\\n                }\\n            }\\n        }\\n     }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] primes=new boolean[n+1];\\n        sieve(n,primes);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=2;i<=n/2;i++){\\n            if(primes[i]==false && primes[n-i]==false){\\n                List<Integer> a=new ArrayList<>();\\n                a.add(i);\\n                a.add(n-i);\\n                ans.add(a);\\n            }\\n        }\\n        return ans;\\n    }\\n     public void sieve(int n, boolean[] primes) {\\n        for (int i = 2; i*i <= n; i++) {\\n            if (!primes[i]) {\\n                for (int j = i*2; j <= n; j+=i) {\\n                    //if a number is not prime it is true in primes array\\n                    primes[j] = true;\\n                }\\n            }\\n        }\\n     }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991315,
                "title": "c-solution-73-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        bool prime[n + 1];\\n\\t    memset(prime, true, sizeof(prime));\\n\\n\\t    for (int p = 2; p * p <= n; p++) {\\n\\t\\t    if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p){\\n                    prime[i] = false;\\n                }\\n            }\\n\\t\\t}\\n\\n        vector<int> arr;\\n        for (int p = 2; p <= n; p++){\\n            if (prime[p]){\\n                arr.push_back(p);\\n            }\\n        }\\n\\n        int i = 0;\\n        int j = arr.size()-1;\\n        vector<vector<int>> ans;\\n        while(i<=j){\\n            if(arr[i]+arr[j] == n){\\n                vector<int> dem(2);\\n                dem[0] = arr[i];\\n                dem[1] = arr[j];\\n                ans.push_back(dem);\\n                i++;\\n                j--;\\n            }\\n            else if(arr[i]+arr[j] > n){\\n                j--;\\n            }\\n            else if(arr[i]+arr[j] < n){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        bool prime[n + 1];\\n\\t    memset(prime, true, sizeof(prime));\\n\\n\\t    for (int p = 2; p * p <= n; p++) {\\n\\t\\t    if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p){\\n                    prime[i] = false;\\n                }\\n            }\\n\\t\\t}\\n\\n        vector<int> arr;\\n        for (int p = 2; p <= n; p++){\\n            if (prime[p]){\\n                arr.push_back(p);\\n            }\\n        }\\n\\n        int i = 0;\\n        int j = arr.size()-1;\\n        vector<vector<int>> ans;\\n        while(i<=j){\\n            if(arr[i]+arr[j] == n){\\n                vector<int> dem(2);\\n                dem[0] = arr[i];\\n                dem[1] = arr[j];\\n                ans.push_back(dem);\\n                i++;\\n                j--;\\n            }\\n            else if(arr[i]+arr[j] > n){\\n                j--;\\n            }\\n            else if(arr[i]+arr[j] < n){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974232,
                "title": "by-07chrono-c-new-approach-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> check(n+1, 1);\\n        check[0] = 0;\\n        check[1] = 0;\\n        vector<vector<int>> prime;\\n\\n        for(int i = 2; i <= n; ++i)\\n        {\\n            if(check[i])\\n            {\\n                for(int j = 2*i; j <= n; j+=i)\\n                {\\n                    check[j] = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i = 2; i <= n; ++i)\\n        {\\n            if(!check[i])\\n                continue;\\n            else\\n            {\\n                if(check[n - i])\\n                {\\n                    prime.push_back({i, n-i});\\n                    check[n - i] = 0;\\n                }\\n            }\\n        }\\n        return prime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> check(n+1, 1);\\n        check[0] = 0;\\n        check[1] = 0;\\n        vector<vector<int>> prime;\\n\\n        for(int i = 2; i <= n; ++i)\\n        {\\n            if(check[i])\\n            {\\n                for(int j = 2*i; j <= n; j+=i)\\n                {\\n                    check[j] = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i = 2; i <= n; ++i)\\n        {\\n            if(!check[i])\\n                continue;\\n            else\\n            {\\n                if(check[n - i])\\n                {\\n                    prime.push_back({i, n-i});\\n                    check[n - i] = 0;\\n                }\\n            }\\n        }\\n        return prime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946137,
                "title": "simple-sieve-approach-c-solution",
                "content": "# Intuition\\nSieve of Eratosthenes\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(logn))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void createSieve(vector<bool>& sieve,int n){\\n        for(int i=2;i<=n;i++){\\n            sieve[i] = true;\\n        }\\n\\n        for(int i=2;i*i<=n;i++){\\n            if(sieve[i]==true){\\n                for(int j=i*i;j<=n;j+=i){\\n                    sieve[j] = false;\\n                }\\n            }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if(n<=3){\\n            return ans;\\n        }\\n\\n        vector<bool> sieve(n+1);\\n        createSieve(sieve,n);\\n\\n        for(int i=2;i<=n/2;i++){\\n            if(sieve[i] && sieve[n-i]){\\n                ans.push_back({i,n-i});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void createSieve(vector<bool>& sieve,int n){\\n        for(int i=2;i<=n;i++){\\n            sieve[i] = true;\\n        }\\n\\n        for(int i=2;i*i<=n;i++){\\n            if(sieve[i]==true){\\n                for(int j=i*i;j<=n;j+=i){\\n                    sieve[j] = false;\\n                }\\n            }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if(n<=3){\\n            return ans;\\n        }\\n\\n        vector<bool> sieve(n+1);\\n        createSieve(sieve,n);\\n\\n        for(int i=2;i<=n/2;i++){\\n            if(sieve[i] && sieve[n-i]){\\n                ans.push_back({i,n-i});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940746,
                "title": "op-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n)\\n     {\\n         List<Integer> l=new ArrayList<>();\\n         HashSet<Integer> set=new HashSet<>();\\n         HashSet<Integer> set2=new HashSet<>();\\n           //seieve\\n           boolean prime[]=new boolean[n+1];\\n             Arrays.fill(prime,true);\\n               prime[0]=false;\\n               prime[1]=false;\\n            for(int i=2;i*i<=n;i++)\\n            {\\n                if(prime[i])\\n                {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    prime[j]=false;\\n                }\\n                }\\n\\n            }\\n            for(int i=2;i<=n;i++)\\n            {\\n                if(prime[i])\\n                {\\n                  l.add(i);\\n                  set.add(i);\\n\\n                }\\n            }\\n             List<List<Integer>> A=new ArrayList<List<Integer>>();\\n            for(int i=0;i<l.size();i++)\\n            {\\n                \\n                    int diff=n-l.get(i);\\n                    if(set.contains(diff)&&!set2.contains(Math.abs(diff-l.get(i))))\\n                    {\\n                     List<Integer> pair = new ArrayList<>(); // Inner list for pair\\n                    pair.add(l.get(i));\\n                    pair.add(diff);\\n                    A.add(pair);\\n                    set2.add(Math.abs(diff-l.get(i)));\\n                    }\\n\\n                    }\\n                \\n            return A;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n)\\n     {\\n         List<Integer> l=new ArrayList<>();\\n         HashSet<Integer> set=new HashSet<>();\\n         HashSet<Integer> set2=new HashSet<>();\\n           //seieve\\n           boolean prime[]=new boolean[n+1];\\n             Arrays.fill(prime,true);\\n               prime[0]=false;\\n               prime[1]=false;\\n            for(int i=2;i*i<=n;i++)\\n            {\\n                if(prime[i])\\n                {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    prime[j]=false;\\n                }\\n                }\\n\\n            }\\n            for(int i=2;i<=n;i++)\\n            {\\n                if(prime[i])\\n                {\\n                  l.add(i);\\n                  set.add(i);\\n\\n                }\\n            }\\n             List<List<Integer>> A=new ArrayList<List<Integer>>();\\n            for(int i=0;i<l.size();i++)\\n            {\\n                \\n                    int diff=n-l.get(i);\\n                    if(set.contains(diff)&&!set2.contains(Math.abs(diff-l.get(i))))\\n                    {\\n                     List<Integer> pair = new ArrayList<>(); // Inner list for pair\\n                    pair.add(l.get(i));\\n                    pair.add(diff);\\n                    A.add(pair);\\n                    set2.add(Math.abs(diff-l.get(i)));\\n                    }\\n\\n                    }\\n                \\n            return A;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917401,
                "title": "java-simple-solution-pre-computation-of-primes-sieve-of-eratosthenes",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean[] primes;\\n    private void createPrimes(int n){\\n        primes = new boolean[n + 1];\\n        Arrays.fill(primes,true);\\n        for(int i = 2;i <= n;i++){\\n            if(primes[i]){\\n                for(int j = i * 2; j <= n;j += i){\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n    }\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        createPrimes(n);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i = 2;i <= n / 2;i++){\\n            if(primes[i] && primes[n - i]){\\n                ans.add(Arrays.asList(i,n - i));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean[] primes;\\n    private void createPrimes(int n){\\n        primes = new boolean[n + 1];\\n        Arrays.fill(primes,true);\\n        for(int i = 2;i <= n;i++){\\n            if(primes[i]){\\n                for(int j = i * 2; j <= n;j += i){\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n    }\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        createPrimes(n);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i = 2;i <= n / 2;i++){\\n            if(primes[i] && primes[n - i]){\\n                ans.add(Arrays.asList(i,n - i));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903491,
                "title": "go-golang-fast",
                "content": "```\\nfunc findPrimePairs(n int) [][]int {\\n    ans := make([]int, 0)\\n\\tres := make([][]int, 0)\\n\\tarr := make([]bool, n+1)\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tarr[i] = true\\n\\t}\\n\\tfor i := 2; i*i < len(arr); i++ {\\n\\t\\tif arr[i] {\\n\\t\\t\\tj := 2\\n\\t\\t\\tfor i*j <= n {\\n\\t\\t\\t\\tarr[i*j] = false\\n\\t\\t\\t\\tj++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor i := 2; i <= n/2; i++ {\\n\\t\\tif arr[i] && arr[n-i] {\\n\\t\\t\\tans = append(ans, i)\\n\\t\\t\\tans = append(ans, n-i)\\n\\t\\t\\tres = append(res, append([]int{}, ans...))\\n\\t\\t\\tans = []int{}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findPrimePairs(n int) [][]int {\\n    ans := make([]int, 0)\\n\\tres := make([][]int, 0)\\n\\tarr := make([]bool, n+1)\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tarr[i] = true\\n\\t}\\n\\tfor i := 2; i*i < len(arr); i++ {\\n\\t\\tif arr[i] {\\n\\t\\t\\tj := 2\\n\\t\\t\\tfor i*j <= n {\\n\\t\\t\\t\\tarr[i*j] = false\\n\\t\\t\\t\\tj++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor i := 2; i <= n/2; i++ {\\n\\t\\tif arr[i] && arr[n-i] {\\n\\t\\t\\tans = append(ans, i)\\n\\t\\t\\tans = append(ans, n-i)\\n\\t\\t\\tres = append(res, append([]int{}, ans...))\\n\\t\\t\\tans = []int{}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3898458,
                "title": "sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool>p(n+1,1);\\n        vector<vector<int>>ans;\\n        p[0]=p[1]=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(p[i]==1)\\n            {\\n                for(int j=i*i;j<=n;j+=i)p[j]=0;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(p[i]==1 && p[n-i]==1)\\n            {\\n                ans.push_back({i,n-i});\\n                p[n-i]=0;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool>p(n+1,1);\\n        vector<vector<int>>ans;\\n        p[0]=p[1]=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(p[i]==1)\\n            {\\n                for(int j=i*i;j<=n;j+=i)p[j]=0;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(p[i]==1 && p[n-i]==1)\\n            {\\n                ans.push_back({i,n-i});\\n                p[n-i]=0;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894294,
                "title": "prime-pairs-with-target-sum-java-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n\\n        boolean []arr=new boolean[n+1];\\n        arr[0]=true;\\n        arr[1]=true;\\n\\n        for(int i=2;i*i<=n;i++){\\n            int j=2;\\n\\n            while(i*j<=n){\\n                arr[i*j]=true;\\n                j++;\\n            }\\n        }\\n\\n        List<List<Integer>> ls=new ArrayList<>();\\n\\n        for(int i=2;i<=n/2;i++){\\n            if(!arr[i] && !arr[n-i]){\\n                ls.add(Arrays.asList(i,n-i));\\n            }\\n        }\\n\\n        return ls;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n\\n        boolean []arr=new boolean[n+1];\\n        arr[0]=true;\\n        arr[1]=true;\\n\\n        for(int i=2;i*i<=n;i++){\\n            int j=2;\\n\\n            while(i*j<=n){\\n                arr[i*j]=true;\\n                j++;\\n            }\\n        }\\n\\n        List<List<Integer>> ls=new ArrayList<>();\\n\\n        for(int i=2;i<=n/2;i++){\\n            if(!arr[i] && !arr[n-i]){\\n                ls.add(Arrays.asList(i,n-i));\\n            }\\n        }\\n\\n        return ls;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893345,
                "title": "c-easy-solution-combination-of-two-sum-and-prime-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe simply check is there is any combinations avaliable which gives sum equals to given n, and then we check for the number is prime or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis implementation uses a loop to iterate through possible values of x and calculates the corresponding y such that x + y == n. It checks whether both x and y are prime using the isprime function and adds them to the result ans if they meet the criteria.\\n\\nFor example, if n = 10, the output should be [[3, 7], [5, 5]], and if there are no prime number pairs for a specific value of n, the function will return an empty array.\\n\\nPlease note that this solution assumes n is a positive integer greater than 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet\\'s analyze the time complexity of the provided solution:\\n\\nPrime Check (isprime function):\\nThe isprime function checks whether a given number x is prime or not. It runs a loop from 2 up to the square root of x, performing a constant amount of work (primarily modulo operation and comparison) at each step. Therefore, the time complexity of the isprime function is O(sqrt(x)).\\n\\nMain Loop (findPrimePairs function):\\nThe main loop runs from 2 to n / 2. For each iteration, it calculates the corresponding y such that x + y == n and then checks whether both x and y are prime using the isprime function. This loop will run n / 2 times, and for each iteration, the prime check takes O(sqrt(x)) time.\\n\\nOverall, the time complexity of the solution can be approximated as O(n * sqrt(n)) in the worst case. This is because the loop in the findPrimePairs function runs n / 2 times and, for each iteration, the prime check operation (isprime) takes O(sqrt(n)) time.\\n\\nThe space complexity of the solution is relatively low, mainly influenced by the storage of the ans vector and some constant space required for variables and function call overhead. Therefore, the space complexity can be considered O(n) or even less, depending on the implementation details.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isprime( int x){\\n        if (x <= 1) {\\n            return false;\\n        }\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n        vector<vector<int>>ans;\\n       \\n        for( int i=2; i<=n/2; i++){\\n         int num=n-i;\\n            if( isprime(num) && isprime(i)){\\n          \\n              ans.push_back( {i,num});\\n            }\\n           \\n                \\n        }\\n            \\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isprime( int x){\\n        if (x <= 1) {\\n            return false;\\n        }\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n        vector<vector<int>>ans;\\n       \\n        for( int i=2; i<=n/2; i++){\\n         int num=n-i;\\n            if( isprime(num) && isprime(i)){\\n          \\n              ans.push_back( {i,num});\\n            }\\n           \\n                \\n        }\\n            \\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888959,
                "title": "java-sieve-of-eratosthenes-fast",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<Integer> ans= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        boolean []arr = new boolean[n+1];\\n        Arrays.fill(arr, true);\\n        for(int i=2; i*i<arr.length;i++){\\n            if(arr[i]==true){\\n                int j =2;\\n                while(i*j<=n){\\n                    arr[i*j] = false;\\n                    j++;\\n                }\\n            }\\n        }\\n        for(int i=2; i<=n/2; i++){\\n            if(arr[i]==true && arr[n-i]==true){\\n                ans.add(i);\\n                ans.add(n-i);\\n                res.add(ans);\\n                ans= new ArrayList<>();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<Integer> ans= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        boolean []arr = new boolean[n+1];\\n        Arrays.fill(arr, true);\\n        for(int i=2; i*i<arr.length;i++){\\n            if(arr[i]==true){\\n                int j =2;\\n                while(i*j<=n){\\n                    arr[i*j] = false;\\n                    j++;\\n                }\\n            }\\n        }\\n        for(int i=2; i<=n/2; i++){\\n            if(arr[i]==true && arr[n-i]==true){\\n                ans.add(i);\\n                ans.add(n-i);\\n                res.add(ans);\\n                ans= new ArrayList<>();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862657,
                "title": "c-solution-using-sieve-of-eratosthenes-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        set<vector<int>> death;\\n        vector<int> primes(n+1, 1);\\n        primes[0]= 0;\\n        primes[1]= 0;\\n\\n         for (int p = 2; p * p <= n; ++p) {\\n            if (primes[p] == 1) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    primes[i] = 0;\\n                }\\n            }\\n        }\\n        for(int x=2;x<n;x++){\\n            int f = min(x, n-x);\\n            int s = max(x, n-x);\\n            if(primes[f]==1 && primes[s] == 1)\\n                death.insert({f,s});\\n        }\\n\\t\\n        vector<vector<int>> ans(death.begin(), death.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        set<vector<int>> death;\\n        vector<int> primes(n+1, 1);\\n        primes[0]= 0;\\n        primes[1]= 0;\\n\\n         for (int p = 2; p * p <= n; ++p) {\\n            if (primes[p] == 1) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    primes[i] = 0;\\n                }\\n            }\\n        }\\n        for(int x=2;x<n;x++){\\n            int f = min(x, n-x);\\n            int s = max(x, n-x);\\n            if(primes[f]==1 && primes[s] == 1)\\n                death.insert({f,s});\\n        }\\n\\t\\n        vector<vector<int>> ans(death.begin(), death.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851446,
                "title": "typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isPrime(x: number): boolean {\\n    for(let i: number = 2; i <= Math.sqrt(x); i++) \\n        if (x % i === 0) return false;\\n    return true;\\n}\\n\\nfunction findPrimePairs(n: number): number[][] {\\n    let arr: number[][] = [];\\n    for (let i: number = 2; i <= n / 2; i++) \\n        if (isPrime(i) && isPrime(n - i)) arr.push([i, n - i]);\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isPrime(x: number): boolean {\\n    for(let i: number = 2; i <= Math.sqrt(x); i++) \\n        if (x % i === 0) return false;\\n    return true;\\n}\\n\\nfunction findPrimePairs(n: number): number[][] {\\n    let arr: number[][] = [];\\n    for (let i: number = 2; i <= n / 2; i++) \\n        if (isPrime(i) && isPrime(n - i)) arr.push([i, n - i]);\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848414,
                "title": "sieve-of-eratosthenes-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool>sieve(n+1,true);\\n        vector<vector<int>>ans;\\n        sieve[0]=sieve[1]=false;\\n        for(int i=2; i*i<=n; i++){\\n            if (sieve[i]){\\n                for(int j=i*i; j<=n; j+=i){\\n                    sieve[j]=false;\\n                }\\n            }\\n        }\\n\\n        for(int i=2;i<=n/2;i++){\\n            if (sieve[i] && sieve[n-i]){\\n                ans.push_back({i,n-i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool>sieve(n+1,true);\\n        vector<vector<int>>ans;\\n        sieve[0]=sieve[1]=false;\\n        for(int i=2; i*i<=n; i++){\\n            if (sieve[i]){\\n                for(int j=i*i; j<=n; j+=i){\\n                    sieve[j]=false;\\n                }\\n            }\\n        }\\n\\n        for(int i=2;i<=n/2;i++){\\n            if (sieve[i] && sieve[n-i]){\\n                ans.push_back({i,n-i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846849,
                "title": "c-prime-most-easy-solution",
                "content": "If u like please Upvote my solution :)\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(Nlog(log(N)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n          \\n          //prime seive\\n\\n          vector<int> primesieve(n+1,0);\\n          primesieve[0]=1;\\n          primesieve[1]=1;\\n      \\n          for(int i=2;i*i<=n;i++)\\n          {\\n              if(primesieve[i]==0)\\n              {\\n                  for(int j=i*i;j<=n;j+=i)\\n                  {\\n                      primesieve[j]=1;\\n                  }\\n              }\\n               \\n          }\\n\\n        vector<vector<int>> ans;\\n        \\n\\n        // After the half of the n it will start making repetative pairs\\n        for(int i=2;i<n/2+1;i++)\\n        {\\n        \\n    \\n             if(primesieve[i]==0  and primesieve[n-i]==0)\\n             {\\n                \\n                ans.push_back({i,n-i});\\n             }   \\n\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n          \\n          //prime seive\\n\\n          vector<int> primesieve(n+1,0);\\n          primesieve[0]=1;\\n          primesieve[1]=1;\\n      \\n          for(int i=2;i*i<=n;i++)\\n          {\\n              if(primesieve[i]==0)\\n              {\\n                  for(int j=i*i;j<=n;j+=i)\\n                  {\\n                      primesieve[j]=1;\\n                  }\\n              }\\n               \\n          }\\n\\n        vector<vector<int>> ans;\\n        \\n\\n        // After the half of the n it will start making repetative pairs\\n        for(int i=2;i<n/2+1;i++)\\n        {\\n        \\n    \\n             if(primesieve[i]==0  and primesieve[n-i]==0)\\n             {\\n                \\n                ans.push_back({i,n-i});\\n             }   \\n\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845471,
                "title": "python-decent-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUses Sieve of Eratosthenes algorithm, and two pointers to solve.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        \\n        sieve = [True] * (n+1)\\n\\n        sieve[0:2] = [False, False]\\n        \\n        for current in range(2, int(n**0.5) + 1):\\n            if sieve[current]:\\n                for multiple in range(current*current, n+1, current):\\n                    sieve[multiple] = False\\n\\n        primes = [num for num in range(2,n+1) if sieve[num]]\\n\\n        pairs = []\\n\\n        start, end = 0, len(primes) - 1\\n        \\n        while start <= end:\\n            val = primes[start] + primes[end]\\n\\n            if val == n:\\n                pairs.append([primes[start], primes[end]])\\n                start += 1\\n                end -= 1\\n            elif val < n:\\n                start += 1\\n            else:\\n                end -= 1\\n\\n        return pairs\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        \\n        sieve = [True] * (n+1)\\n\\n        sieve[0:2] = [False, False]\\n        \\n        for current in range(2, int(n**0.5) + 1):\\n            if sieve[current]:\\n                for multiple in range(current*current, n+1, current):\\n                    sieve[multiple] = False\\n\\n        primes = [num for num in range(2,n+1) if sieve[num]]\\n\\n        pairs = []\\n\\n        start, end = 0, len(primes) - 1\\n        \\n        while start <= end:\\n            val = primes[start] + primes[end]\\n\\n            if val == n:\\n                pairs.append([primes[start], primes[end]])\\n                start += 1\\n                end -= 1\\n            elif val < n:\\n                start += 1\\n            else:\\n                end -= 1\\n\\n        return pairs\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842055,
                "title": "kotlin-solution-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    fun findPrimePairs(n: Int): List<List<Int>> {\\n        if (n <= 1) {\\n            return emptyList()\\n        }\\n        var res = ArrayList<List<Int>>();\\n        for (i in 2 until n / 2 + 1) {\\n            if (isPrime(n - i) && isPrime(i)) {\\n                var arr = listOf(i, n - i);\\n                Collections.sort(arr);\\n                if (!res.contains(arr)) res.add(arr)\\n            }\\n        }\\n        return res\\n    }\\n\\n    private fun isPrime(number: Int): Boolean {\\n        var indx = 2;\\n        while (indx <= Math.sqrt(number.toDouble())) {\\n            if (number % indx == 0) {\\n                return false\\n            }\\n            indx++\\n        }\\n        return true\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findPrimePairs(n: Int): List<List<Int>> {\\n        if (n <= 1) {\\n            return emptyList()\\n        }\\n        var res = ArrayList<List<Int>>();\\n        for (i in 2 until n / 2 + 1) {\\n            if (isPrime(n - i) && isPrime(i)) {\\n                var arr = listOf(i, n - i);\\n                Collections.sort(arr);\\n                if (!res.contains(arr)) res.add(arr)\\n            }\\n        }\\n        return res\\n    }\\n\\n    private fun isPrime(number: Int): Boolean {\\n        var indx = 2;\\n        while (indx <= Math.sqrt(number.toDouble())) {\\n            if (number % indx == 0) {\\n                return false\\n            }\\n            indx++\\n        }\\n        return true\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837831,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> list  =  new ArrayList<>();\\n        if(n<=3){\\n            return list;\\n        }\\n        boolean[] arr =  new boolean[n+1];\\n        for(int i=2; i*i<n; i++){\\n            if(arr[i] ==  false){\\n                for(int j=i*i; j<n; j+=i){\\n                    arr[j] = true;\\n                }\\n            }\\n        }\\n        for(int i=2; i<=n/2; i++){\\n            if(!arr[i] && !arr[n-i]){\\n                list.add(List.of(i,n-i));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> list  =  new ArrayList<>();\\n        if(n<=3){\\n            return list;\\n        }\\n        boolean[] arr =  new boolean[n+1];\\n        for(int i=2; i*i<n; i++){\\n            if(arr[i] ==  false){\\n                for(int j=i*i; j<n; j+=i){\\n                    arr[j] = true;\\n                }\\n            }\\n        }\\n        for(int i=2; i<=n/2; i++){\\n            if(!arr[i] && !arr[n-i]){\\n                list.add(List.of(i,n-i));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834608,
                "title": "easy-c-with-sieve-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int primeN[1000001];\\n   // finding prime using sieve \\n    void findPrime(int n)\\n    {\\n      for(int i=2;i<=n;i++)\\n      {\\n          if(primeN[i]==0)\\n          {\\n              for(int j=2*i;j<=n;j+=i)\\n                  primeN[j]=1;\\n          }\\n      }\\n    }\\n    \\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n     memset(primeN,0,sizeof(primeN));\\n     findPrime(n);\\n        \\n        vector<vector<int>>ans;\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(primeN[i]==0 && primeN[n-i]==0)\\n            {\\n                ans.push_back({i,n-i});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int primeN[1000001];\\n   // finding prime using sieve \\n    void findPrime(int n)\\n    {\\n      for(int i=2;i<=n;i++)\\n      {\\n          if(primeN[i]==0)\\n          {\\n              for(int j=2*i;j<=n;j+=i)\\n                  primeN[j]=1;\\n          }\\n      }\\n    }\\n    \\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n     memset(primeN,0,sizeof(primeN));\\n     findPrime(n);\\n        \\n        vector<vector<int>>ans;\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(primeN[i]==0 && primeN[n-i]==0)\\n            {\\n                ans.push_back({i,n-i});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826964,
                "title": "c-solution-with-sieve-of-eratothenes",
                "content": "## Please upvote if you like the solution\\n# Code\\n```\\nclass Solution {\\n    vector<bool> check;\\n    void calc(int n){\\n        check.assign(n+1, true);\\n        for(int i = 2;i*i <=n;i++){\\n            if(check[i]){\\n                for(int j = i*i;j <= n;j += i)\\n                    check[j] = false;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        calc(n);\\n        vector<vector<int>> ans;\\n        for(int i = 2;i <= n/2;i++){\\n            if(check[i] && check[n-i]) ans.push_back({i, n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<bool> check;\\n    void calc(int n){\\n        check.assign(n+1, true);\\n        for(int i = 2;i*i <=n;i++){\\n            if(check[i]){\\n                for(int j = i*i;j <= n;j += i)\\n                    check[j] = false;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        calc(n);\\n        vector<vector<int>> ans;\\n        for(int i = 2;i <= n/2;i++){\\n            if(check[i] && check[n-i]) ans.push_back({i, n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825156,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar findPrimePairs = function(n) {\\n  let res=[];\\n  for(let i=1; i<=n/2; i++){\\n      if(isPrime(i) && isPrime(n-i)){\\n          res.push([i, n-i]);\\n      }\\n  }  \\n  return res;\\n};\\nfunction isPrime(number) {\\n  if (number <= 1) {\\n    return false;\\n  }\\n  if (number <= 3) {\\n    return true;\\n  }\\n\\n  if (number % 2 === 0 || number % 3 === 0) {\\n    return false;\\n  }\\n\\n  let i = 5;\\n  while (i * i <= number) {\\n    if (number % i === 0 || number % (i + 2) === 0) {\\n      return false;\\n    }\\n    i += 6;\\n  }\\n\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar findPrimePairs = function(n) {\\n  let res=[];\\n  for(let i=1; i<=n/2; i++){\\n      if(isPrime(i) && isPrime(n-i)){\\n          res.push([i, n-i]);\\n      }\\n  }  \\n  return res;\\n};\\nfunction isPrime(number) {\\n  if (number <= 1) {\\n    return false;\\n  }\\n  if (number <= 3) {\\n    return true;\\n  }\\n\\n  if (number % 2 === 0 || number % 3 === 0) {\\n    return false;\\n  }\\n\\n  let i = 5;\\n  while (i * i <= number) {\\n    if (number % i === 0 || number % (i + 2) === 0) {\\n      return false;\\n    }\\n    i += 6;\\n  }\\n\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823575,
                "title": "sieve-of-eratosthenes-primes-numbers-under-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\nThis algorithm gives all the prime numbers under n. \\nLogic : Create an array of n+1 size to mark all the visited numbers. \\nfor i in range ( 2 to n ) , mark all the multiples of i as they cannot be the primes numbers . \\nNow all the unmarked numbers are prime numbers. \\nBut complexity will be high i.e ~ O$(n^2)$\\nObserve when i = 2, the multiples 4, 6, 8, 10, 12, 14, 16, .. get marked. \\nwhen i = 3, the multiples 6, 9, 12, 15, ... get marked \\nwhen i = 4, the multiples 8, 12, 16, 20.. get marked. \\nwhen i = 5, the multiples 10, 15, 20, 25....\\nBut 10 (2*5) is already marked by 2, 15 (3*5) is already marked by 3 and 20 (4*5) is already marked by 4. So its enough to start from 25 i.e (5^2) .\\nSo for each i, start from i^2 till n mark all the multiples. \\n\\n# Complexity\\n- Time complexity: $O(n *log (log n) ) $ \\n= \\u221An + n/2 + n/3 + n/4 + .... \\n= n * (1/\\u221An + 1/2 + 1/4 + ...) \\n= n log log n \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int[] primes = new int[n+1];\\n        for(int i=2;i<=(int)Math.sqrt(n);i++){\\n            if(primes[i]==0){\\n                for(int j = i*i;j<=n;j+=i){\\n                    primes[j] = 1;\\n                }\\n            }\\n        }\\n        for(int i=2;i<=n/2;i++){\\n            if(primes[i]==0 && primes[n-i]==0){\\n                ans.add(new ArrayList<>(Arrays.asList(i,n-i)));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int[] primes = new int[n+1];\\n        for(int i=2;i<=(int)Math.sqrt(n);i++){\\n            if(primes[i]==0){\\n                for(int j = i*i;j<=n;j+=i){\\n                    primes[j] = 1;\\n                }\\n            }\\n        }\\n        for(int i=2;i<=n/2;i++){\\n            if(primes[i]==0 && primes[n-i]==0){\\n                ans.add(new ArrayList<>(Arrays.asList(i,n-i)));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810938,
                "title": "java-using-pre-compute-primes",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(Integer sum) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        boolean prime[] = new boolean[1000001];\\n        Arrays.fill(prime,true);\\n\\n        for(int i=2;i*i<=prime.length;i++){\\n            if(prime[i] && isPrime(i)){\\n                for(int j=i*i;j<prime.length;j=j+i){\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n\\n        for(int i=2;i<=sum/2;i++){\\n            if(prime[i] && prime[sum-i]){\\n                List<Integer> list = new ArrayList<>(Arrays.asList(i,sum-i));\\n                res.add(list);\\n            }\\n        }\\n     return res;\\n    }\\n\\n    private boolean isPrime(int num){\\n        for(int i=2;i*i<=num;i++){\\n            if(num%i==0)\\n            return false;\\n        }\\n       return true; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(Integer sum) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        boolean prime[] = new boolean[1000001];\\n        Arrays.fill(prime,true);\\n\\n        for(int i=2;i*i<=prime.length;i++){\\n            if(prime[i] && isPrime(i)){\\n                for(int j=i*i;j<prime.length;j=j+i){\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n\\n        for(int i=2;i<=sum/2;i++){\\n            if(prime[i] && prime[sum-i]){\\n                List<Integer> list = new ArrayList<>(Arrays.asList(i,sum-i));\\n                res.add(list);\\n            }\\n        }\\n     return res;\\n    }\\n\\n    private boolean isPrime(int num){\\n        for(int i=2;i*i<=num;i++){\\n            if(num%i==0)\\n            return false;\\n        }\\n       return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809082,
                "title": "sieve-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int >prime;\\npublic:\\n     void generating_prime(int n)\\n    {\\n        int status[n+1];\\n        for(int i=2;i<=n;i++)\\n        {\\n            status[i]=0;\\n        }\\n        int l=sqrt(n);\\n        for(int i=2;i<=l;i++)\\n        {\\n            if(status[i]==0)\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    status[j]=1;\\n                }\\n            }\\n\\n        }\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(status[i]==0)\\n            {\\n                prime.push_back(i);\\n            }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n\\n        generating_prime(n);\\n\\n        vector<vector<int>>ans;\\n        int l=prime.size();\\n        int i=0,j=l-1;\\n        while(i<=j)\\n        {\\n            if(prime[i]+prime[j]==n)\\n            {\\n                ans.push_back({prime[i],prime[j]});\\n                i++;\\n                j--;\\n            }\\n            else if(prime[i]+prime[j]<n)\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int >prime;\\npublic:\\n     void generating_prime(int n)\\n    {\\n        int status[n+1];\\n        for(int i=2;i<=n;i++)\\n        {\\n            status[i]=0;\\n        }\\n        int l=sqrt(n);\\n        for(int i=2;i<=l;i++)\\n        {\\n            if(status[i]==0)\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    status[j]=1;\\n                }\\n            }\\n\\n        }\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(status[i]==0)\\n            {\\n                prime.push_back(i);\\n            }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        \\n\\n        generating_prime(n);\\n\\n        vector<vector<int>>ans;\\n        int l=prime.size();\\n        int i=0,j=l-1;\\n        while(i<=j)\\n        {\\n            if(prime[i]+prime[j]==n)\\n            {\\n                ans.push_back({prime[i],prime[j]});\\n                i++;\\n                j--;\\n            }\\n            else if(prime[i]+prime[j]<n)\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808178,
                "title": "c-java-python-sieve-eratosthenes-simplest-solution",
                "content": "\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> sieve(n + 1, true);\\n        vector<vector<int>> ans;\\n        sieve[0] = false;\\n        sieve[1] = false;\\n        for (int i = 2; i * i < n; ++i) {\\n            if (sieve[i] == true) {\\n                for (int p = i + i; p < n; p += i) {\\n                    sieve[p] = false;\\n                }\\n            }\\n        }\\n\\n        for (int i = 2; i < n; ++i) {\\n            if (i <= n - i && sieve[i] && sieve[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        Boolean[] sieve = new Boolean[n + 1];\\n        Arrays.fill(sieve, true);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        sieve[0] = false;\\n        sieve[1] = false;\\n        for (int i = 2; i * i < n; ++i) {\\n            if (sieve[i] == true) {\\n                for (int p = i + i; p < n; p += i) {\\n                    sieve[p] = false;\\n                }\\n            }\\n        }\\n\\n        for (int i = 2; i < n; ++i) {\\n            if (i <= n - i && sieve[i] && sieve[n - i]) {\\n                List<Integer> temp = new ArrayList<>();\\n                temp.add(i);\\n                temp.add(n - i);\\n                ans.add(temp);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        sieve = [True for _ in range(n + 1)]\\n        sieve[0] = False\\n        sieve[1] = False\\n        ans = []\\n        for i in range(2, int(math.sqrt(n)) + 1):\\n            if sieve[i] == True:\\n                for p in range(i + i, n, i):\\n                    sieve[p] = False\\n        \\n        for i in range(2, n):\\n            if i <= n - i and sieve[i] and sieve[n - i]:\\n                ans.append([i, n - i])\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> sieve(n + 1, true);\\n        vector<vector<int>> ans;\\n        sieve[0] = false;\\n        sieve[1] = false;\\n        for (int i = 2; i * i < n; ++i) {\\n            if (sieve[i] == true) {\\n                for (int p = i + i; p < n; p += i) {\\n                    sieve[p] = false;\\n                }\\n            }\\n        }\\n\\n        for (int i = 2; i < n; ++i) {\\n            if (i <= n - i && sieve[i] && sieve[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        Boolean[] sieve = new Boolean[n + 1];\\n        Arrays.fill(sieve, true);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        sieve[0] = false;\\n        sieve[1] = false;\\n        for (int i = 2; i * i < n; ++i) {\\n            if (sieve[i] == true) {\\n                for (int p = i + i; p < n; p += i) {\\n                    sieve[p] = false;\\n                }\\n            }\\n        }\\n\\n        for (int i = 2; i < n; ++i) {\\n            if (i <= n - i && sieve[i] && sieve[n - i]) {\\n                List<Integer> temp = new ArrayList<>();\\n                temp.add(i);\\n                temp.add(n - i);\\n                ans.add(temp);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        sieve = [True for _ in range(n + 1)]\\n        sieve[0] = False\\n        sieve[1] = False\\n        ans = []\\n        for i in range(2, int(math.sqrt(n)) + 1):\\n            if sieve[i] == True:\\n                for p in range(i + i, n, i):\\n                    sieve[p] = False\\n        \\n        for i in range(2, n):\\n            if i <= n - i and sieve[i] and sieve[n - i]:\\n                ans.append([i, n - i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802355,
                "title": "simple-java-solution",
                "content": "# Simple JAVA Solution!!!\\n\\n# Code\\n```\\nclass Solution {\\n\\t  boolean prime[]; \\n    public List<List<Integer>> findPrimePairs(int n) {\\n        allPrime(n);\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\t\\n\\t\\tfor(int i=0;i<=n/2;i++)\\n\\t\\t{\\n\\t\\t\\tint j = n-i;\\n\\t\\t\\t\\n\\t\\t\\tif(prime[i] && prime[j]) ans.add(List.of(i,j));\\n\\t\\t}\\n        return ans;\\n    }\\n    public void allPrime(int n)\\n\\t{\\n\\t\\tprime = new boolean[n+1];\\n\\t\\tArrays.fill(prime, true);\\n\\t\\tprime[0] = false;\\n\\t\\tprime[1] = false;\\n\\t\\t\\n\\t\\tfor(int i=2;i<Math.sqrt(n);i++)\\n\\t\\t{\\n\\t\\t\\tif(prime[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=2;j<n;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif((i*j)>n) break;\\n\\t\\t\\t\\t\\t\\tprime[i*j] = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List",
                    "Math",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n\\t  boolean prime[]; \\n    public List<List<Integer>> findPrimePairs(int n) {\\n        allPrime(n);\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\t\\n\\t\\tfor(int i=0;i<=n/2;i++)\\n\\t\\t{\\n\\t\\t\\tint j = n-i;\\n\\t\\t\\t\\n\\t\\t\\tif(prime[i] && prime[j]) ans.add(List.of(i,j));\\n\\t\\t}\\n        return ans;\\n    }\\n    public void allPrime(int n)\\n\\t{\\n\\t\\tprime = new boolean[n+1];\\n\\t\\tArrays.fill(prime, true);\\n\\t\\tprime[0] = false;\\n\\t\\tprime[1] = false;\\n\\t\\t\\n\\t\\tfor(int i=2;i<Math.sqrt(n);i++)\\n\\t\\t{\\n\\t\\t\\tif(prime[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=2;j<n;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif((i*j)>n) break;\\n\\t\\t\\t\\t\\t\\tprime[i*j] = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797246,
                "title": "simple-java-sieve-of-eratosthenes",
                "content": "# Approach\\nUse Sieve of Eratosthenes for getting all the primes. Then check for the conditions as mentioned\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean prime[] = new boolean[n + 1];\\n        for(int i=0;i<=n;i++)   prime[i] = true;\\n        for(int p = 2; p*p <= n; p++)\\n        {\\n            if(prime[p] == true){\\n                for(int i = p*p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        List<List<Integer>> sol = new ArrayList();\\n        if(n==1)    return sol;\\n        for(int i=2;i<=n/2;++i){\\n            List<Integer> temp = new ArrayList();\\n            if(prime[i] && prime[n-i]){\\n                temp.add(i);\\n                temp.add(n-i);\\n                sol.add(temp);\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```\\n\\n*Kindly upvote if you find it helpful !*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean prime[] = new boolean[n + 1];\\n        for(int i=0;i<=n;i++)   prime[i] = true;\\n        for(int p = 2; p*p <= n; p++)\\n        {\\n            if(prime[p] == true){\\n                for(int i = p*p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        List<List<Integer>> sol = new ArrayList();\\n        if(n==1)    return sol;\\n        for(int i=2;i<=n/2;++i){\\n            List<Integer> temp = new ArrayList();\\n            if(prime[i] && prime[n-i]){\\n                temp.add(i);\\n                temp.add(n-i);\\n                sol.add(temp);\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793240,
                "title": "python-beats-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef sieve_of_eratosthenes(limit):\\n    sieve = [True] * (limit + 1)\\n    sieve[0] = sieve[1] = False\\n\\n    for num in range(2, int(limit**0.5) + 1):\\n        if sieve[num]:\\n            for multiple in range(num * num, limit + 1, num):\\n                sieve[multiple] = False\\n\\n    return sieve\\n\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        sieve = sieve_of_eratosthenes(n)\\n        result = []\\n        compliment = n - 2\\n        for number in range(2, n // 2 + 1):\\n            if sieve[number] and sieve[compliment]:\\n                result.append([number, compliment])\\n            compliment -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef sieve_of_eratosthenes(limit):\\n    sieve = [True] * (limit + 1)\\n    sieve[0] = sieve[1] = False\\n\\n    for num in range(2, int(limit**0.5) + 1):\\n        if sieve[num]:\\n            for multiple in range(num * num, limit + 1, num):\\n                sieve[multiple] = False\\n\\n    return sieve\\n\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        sieve = sieve_of_eratosthenes(n)\\n        result = []\\n        compliment = n - 2\\n        for number in range(2, n // 2 + 1):\\n            if sieve[number] and sieve[compliment]:\\n                result.append([number, compliment])\\n            compliment -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792933,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] prime = new boolean[n + 1]; \\n        List<List<Integer>> ans = new ArrayList<>(); \\n        for (int i = 2; i <= n; i++) {\\n            prime[i] = true;\\n        }\\n        \\n        prime[1] = false;\\n        prime[0] = false; \\n        \\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p]) {\\n                \\n                for (int i = p * p; i <= n; i += p) {\\n                    prime[i] = false;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 2; i <= n - 1; i++) {\\n            int j = n - i; \\n            if (prime[i] && prime[j] && i <= j) {\\n                \\n                ans.add(Arrays.asList(i,n-i));\\n            }\\n        }\\n        \\n        return ans; \\n    }\\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] prime = new boolean[n + 1]; \\n        List<List<Integer>> ans = new ArrayList<>(); \\n        for (int i = 2; i <= n; i++) {\\n            prime[i] = true;\\n        }\\n        \\n        prime[1] = false;\\n        prime[0] = false; \\n        \\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p]) {\\n                \\n                for (int i = p * p; i <= n; i += p) {\\n                    prime[i] = false;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 2; i <= n - 1; i++) {\\n            int j = n - i; \\n            if (prime[i] && prime[j] && i <= j) {\\n                \\n                ans.add(Arrays.asList(i,n-i));\\n            }\\n        }\\n        \\n        return ans; \\n    }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791288,
                "title": "python-bit-optomization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        ans = []\\n        primes = [1] * ((n >> 1) + 1)\\n        print(10 >> 1)\\n        is_prime = lambda x: x == 2 or (x & 1 and primes[x >> 1])\\n\\n        p = 3\\n        while p * p <= n:\\n            if not primes[p >> 1]:\\n                p += 2\\n                continue\\n            \\n            \\n            for i in range(p * p, n + 1, p * 2):\\n                primes[i >> 1] = 0\\n  \\n            p += 2\\n\\n        if n >= 4 and is_prime(n - 2): ans.append([2, n - 2])\\n        \\n        for num in range(3, n // 2 + 1, 2):\\n            target = n - num\\n\\n            if is_prime(num) and is_prime(target):\\n                ans.append([num, target])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        ans = []\\n        primes = [1] * ((n >> 1) + 1)\\n        print(10 >> 1)\\n        is_prime = lambda x: x == 2 or (x & 1 and primes[x >> 1])\\n\\n        p = 3\\n        while p * p <= n:\\n            if not primes[p >> 1]:\\n                p += 2\\n                continue\\n            \\n            \\n            for i in range(p * p, n + 1, p * 2):\\n                primes[i >> 1] = 0\\n  \\n            p += 2\\n\\n        if n >= 4 and is_prime(n - 2): ans.append([2, n - 2])\\n        \\n        for num in range(3, n // 2 + 1, 2):\\n            target = n - num\\n\\n            if is_prime(num) and is_prime(target):\\n                ans.append([num, target])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791112,
                "title": "most-optimal-solution-using-sieve-of-eratosthenes-and-two-pointers-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the Sieve of Eratosthenes algorithm to find all the Prime numbers till \\'n\\' and store them in an array.\\nUse the Two Pointers Algorithm to find the desired pair of prime numbers(i.e. Prime no. with sum equals to n).\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m) where m = number of prime numbers from 1 - n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> sieveOfEratosthenes(int n)\\n\\t{\\n\\t\\tboolean prime[] = new boolean[n + 1];\\n        Arrays.fill(prime, true);\\n\\n\\t\\tfor (int p = 2; p * p <= n; p++) {\\n\\t\\t\\tif (prime[p] == true) {\\n\\t\\t\\t\\tfor (int i = p * p; i <= n; i += p)\\n\\t\\t\\t\\t\\tprime[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n        //Storing all the prime numbers in an array.\\n        List<Integer> ans = new ArrayList<>();\\n\\t\\tfor (int i = 2; i <= n; i++) {\\n\\t\\t\\tif (prime[i] == true)\\n                ans.add(i);\\n\\t\\t}\\n        return ans;\\n    }\\n    \\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<Integer> primes = new ArrayList<>();\\n        primes = sieveOfEratosthenes(n);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        //Using the Two Pointers algorithm to find the desired pair of prime numbers.\\n        int i=0, j=primes.size()-1;\\n        while(i<=j){\\n            if(primes.get(i) + primes.get(j) == n){\\n                List<Integer> pair = new ArrayList<>();\\n                pair.add(primes.get(i));\\n                pair.add(primes.get(j));\\n                ans.add(pair);\\n                i++;\\n                j--;\\n            }\\n            else if(primes.get(i) + primes.get(j) < n){\\n                i++;\\n            }\\n            else j--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> sieveOfEratosthenes(int n)\\n\\t{\\n\\t\\tboolean prime[] = new boolean[n + 1];\\n        Arrays.fill(prime, true);\\n\\n\\t\\tfor (int p = 2; p * p <= n; p++) {\\n\\t\\t\\tif (prime[p] == true) {\\n\\t\\t\\t\\tfor (int i = p * p; i <= n; i += p)\\n\\t\\t\\t\\t\\tprime[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n        //Storing all the prime numbers in an array.\\n        List<Integer> ans = new ArrayList<>();\\n\\t\\tfor (int i = 2; i <= n; i++) {\\n\\t\\t\\tif (prime[i] == true)\\n                ans.add(i);\\n\\t\\t}\\n        return ans;\\n    }\\n    \\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<Integer> primes = new ArrayList<>();\\n        primes = sieveOfEratosthenes(n);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        //Using the Two Pointers algorithm to find the desired pair of prime numbers.\\n        int i=0, j=primes.size()-1;\\n        while(i<=j){\\n            if(primes.get(i) + primes.get(j) == n){\\n                List<Integer> pair = new ArrayList<>();\\n                pair.add(primes.get(i));\\n                pair.add(primes.get(j));\\n                ans.add(pair);\\n                i++;\\n                j--;\\n            }\\n            else if(primes.get(i) + primes.get(j) < n){\\n                i++;\\n            }\\n            else j--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786694,
                "title": "sieve-of-eratosthenes-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void makeSieve(vector<bool>& sieve,int n)\\n    {\\n        for(int i=2;i*i <= n;i++)\\n        {\\n            if(sieve[i])\\n            {\\n                for(int j=2*i;j<=n;j+=i)\\n                {\\n                    if(sieve[j])\\n                    sieve[j]=false;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n       vector<bool> sieve(n+1,true);\\n     \\n       makeSieve(sieve,n); \\n        vector<vector<int>> ans;\\n        set<int> s;\\n       for(int i=2;i<=n;i++)\\n       {\\n           int req=n-i;\\n           if(sieve[i] && sieve[req] && req > 1)\\n           {\\n               if(s.find(i) == s.end() && s.find(req) == s.end()){\\n                    ans.push_back({i,req});\\n                    s.insert(i);\\n                    s.insert(req);\\n               }\\n           }\\n       }\\n    if(ans.size() == 0)\\n    return {};\\n    return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void makeSieve(vector<bool>& sieve,int n)\\n    {\\n        for(int i=2;i*i <= n;i++)\\n        {\\n            if(sieve[i])\\n            {\\n                for(int j=2*i;j<=n;j+=i)\\n                {\\n                    if(sieve[j])\\n                    sieve[j]=false;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n       vector<bool> sieve(n+1,true);\\n     \\n       makeSieve(sieve,n); \\n        vector<vector<int>> ans;\\n        set<int> s;\\n       for(int i=2;i<=n;i++)\\n       {\\n           int req=n-i;\\n           if(sieve[i] && sieve[req] && req > 1)\\n           {\\n               if(s.find(i) == s.end() && s.find(req) == s.end()){\\n                    ans.push_back({i,req});\\n                    s.insert(i);\\n                    s.insert(req);\\n               }\\n           }\\n       }\\n    if(ans.size() == 0)\\n    return {};\\n    return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784714,
                "title": "solution-using-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n    List<List<Integer>> pairs = new ArrayList<>();\\n    if(n<=3){\\n     return pairs;\\n     }\\n   boolean prime[] = new boolean[n+1];\\n      sieve(n, prime);\\n\\n        for(int i=2;i<=n;i++){\\n            if(!prime[i]){\\n                List<Integer> pair = new ArrayList<>();\\n                if(!prime[n-i] && n-i>1){\\n                    pair.add(i);\\n                    pair.add(n-i);\\n                    prime[n-i]=true;\\n                    pairs.add(pair);\\n                }\\n               \\n            }\\n        }\\n        return pairs;\\n      \\n    }\\n     static void sieve(int x , boolean[] prime){\\n        int c=0;\\n        for(int i=2;i*i<=x;i++){\\n            if(!prime[i]){\\n                for(int j=i*2;j<=x;j=j+i){\\n                    prime[j]=true;\\n                }\\n            }\\n\\n        }\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n    List<List<Integer>> pairs = new ArrayList<>();\\n    if(n<=3){\\n     return pairs;\\n     }\\n   boolean prime[] = new boolean[n+1];\\n      sieve(n, prime);\\n\\n        for(int i=2;i<=n;i++){\\n            if(!prime[i]){\\n                List<Integer> pair = new ArrayList<>();\\n                if(!prime[n-i] && n-i>1){\\n                    pair.add(i);\\n                    pair.add(n-i);\\n                    prime[n-i]=true;\\n                    pairs.add(pair);\\n                }\\n               \\n            }\\n        }\\n        return pairs;\\n      \\n    }\\n     static void sieve(int x , boolean[] prime){\\n        int c=0;\\n        for(int i=2;i*i<=x;i++){\\n            if(!prime[i]){\\n                for(int j=i*2;j<=x;j=j+i){\\n                    prime[j]=true;\\n                }\\n            }\\n\\n        }\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778551,
                "title": "c-sieve-of-eratosthenes",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>res;\\n        unordered_set<int>hash;\\n        vector<bool>isPrime(n+1,true);\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(isPrime[i] == true)\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    isPrime[j] = false;\\n                }\\n            }\\n        }\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(isPrime[i] == true)\\n            {\\n                if(hash.find(n-i) != hash.end())\\n                { \\n                    res.push_back({n-i,i});\\n                }\\n                if(2 * i == n)\\n                    res.push_back({i,i});\\n                hash.insert(i);\\n            }\\n        }\\n        sort(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>>res;\\n        unordered_set<int>hash;\\n        vector<bool>isPrime(n+1,true);\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(isPrime[i] == true)\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    isPrime[j] = false;\\n                }\\n            }\\n        }\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(isPrime[i] == true)\\n            {\\n                if(hash.find(n-i) != hash.end())\\n                { \\n                    res.push_back({n-i,i});\\n                }\\n                if(2 * i == n)\\n                    res.push_back({i,i});\\n                hash.insert(i);\\n            }\\n        }\\n        sort(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770685,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> FindPrimePairs(int n) {\\n        var res = new List<IList<int>>();\\n        var left = 2;\\n        var right = n - 2;\\n        while(left <= right){\\n            if(IsPrime(left) && IsPrime(right))\\n                res.Add(new List<int>(){left, right});           \\n            left++;\\n            right--;\\n        }\\n        return res;\\n    }\\n\\n     public static bool IsPrime(int n){\\n        if (n < 2)\\n            return false;\\n        for (int i = 2; i <= Math.Sqrt(n); i++){\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FindPrimePairs(int n) {\\n        var res = new List<IList<int>>();\\n        var left = 2;\\n        var right = n - 2;\\n        while(left <= right){\\n            if(IsPrime(left) && IsPrime(right))\\n                res.Add(new List<int>(){left, right});           \\n            left++;\\n            right--;\\n        }\\n        return res;\\n    }\\n\\n     public static bool IsPrime(int n){\\n        if (n < 2)\\n            return false;\\n        for (int i = 2; i <= Math.Sqrt(n); i++){\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768638,
                "title": "sieve-of-eratosthenes-and-then-two-pointers-beats-44-66",
                "content": "# Intuition\\n  We will mark all prime numbers less than given numbers and then use two pointers techniques two find  all pairs with both elements as prime number and sums to given number.\\n\\n# Approach\\nFirst create an bool array of size n+1 and  then use segmented sieve technique , two mark all numbers which are prime as true and not prime as false.\\nthen apply two pointers on bool array , if both numbers are prime then do same like \"two sum\" problem.\\n\\n# Complexity\\n- Time complexity:\\nFor segmented sieve it will O(nlogn) and for finding pairs whose sum is given number O(n)  overall complexity O(n).\\n\\n- Space complexity:\\nIt will be O(n) only.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool>prime(n+1,true);\\n        for(int i=2;i*i<n;i++){\\n            if(prime[i]){\\n                for(int j=i*i;j<n;j+=i)\\n                prime[j]=false;\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        int i=2,j=n-2;\\n        while(i<=j)\\n        {\\n            if(prime[i] and prime[j]){\\n                if(i+j==n){\\n                    vector<int>semi={i,j};\\n                    ans.push_back(semi);\\n                    i++;\\n                    j--;\\n                }\\n                else if(i+j>n)\\n                j--;\\n                else\\n                i++;\\n\\n            }\\n            if(!prime[i] and !prime[j]){\\n                i++;\\n                j--;\\n            }\\n            if(!prime[i] and prime[j])\\n            i++;\\n            if(prime[i] and !prime[j])\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool>prime(n+1,true);\\n        for(int i=2;i*i<n;i++){\\n            if(prime[i]){\\n                for(int j=i*i;j<n;j+=i)\\n                prime[j]=false;\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        int i=2,j=n-2;\\n        while(i<=j)\\n        {\\n            if(prime[i] and prime[j]){\\n                if(i+j==n){\\n                    vector<int>semi={i,j};\\n                    ans.push_back(semi);\\n                    i++;\\n                    j--;\\n                }\\n                else if(i+j>n)\\n                j--;\\n                else\\n                i++;\\n\\n            }\\n            if(!prime[i] and !prime[j]){\\n                i++;\\n                j--;\\n            }\\n            if(!prime[i] and prime[j])\\n            i++;\\n            if(prime[i] and !prime[j])\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768309,
                "title": "cpp-solution-using-sieve-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> primeSieve(int n){\\n        vector<int> prime(n+1,0);\\n        for(int i=2;i*i<=n;i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=n;j+=i){\\n                    prime[j]=1;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=2;i<=n;i++){\\n            if(prime[i]==0){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        vector<int> a = primeSieve(n);\\n        // for(int i=0;i<a.size();i++){\\n            // cout<<a[i]<<\" \";\\n        // }\\n        int i = 0;\\n        int j = a.size()-1;\\n        while(i<=j){\\n            if(a[i]+a[j]==n){\\n                ans.push_back({a[i],a[j]});\\n                i++;\\n                j--;\\n            }\\n            else if(a[i]+a[j]<n){\\n                i++;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> primeSieve(int n){\\n        vector<int> prime(n+1,0);\\n        for(int i=2;i*i<=n;i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=n;j+=i){\\n                    prime[j]=1;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=2;i<=n;i++){\\n            if(prime[i]==0){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        vector<int> a = primeSieve(n);\\n        // for(int i=0;i<a.size();i++){\\n            // cout<<a[i]<<\" \";\\n        // }\\n        int i = 0;\\n        int j = a.size()-1;\\n        while(i<=j){\\n            if(a[i]+a[j]==n){\\n                ans.push_back({a[i],a[j]});\\n                i++;\\n                j--;\\n            }\\n            else if(a[i]+a[j]<n){\\n                i++;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3761288,
                "title": "prime-pairs-with-target-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar findPrimePairs = function(n) {\\n  // Function to check if a number is prime\\n  function isPrime(num) {\\n    if (num < 2) return false;\\n    for (let i = 2; i <= Math.sqrt(num); i++) {\\n      if (num % i === 0) return false;\\n    }\\n    return true;\\n  }\\n  const result = [];\\n  for (let x = 2; x <= n / 2; x++) {\\n    const y = n - x;\\n    if (isPrime(x) && isPrime(y)) {\\n      result.push([x, y]);\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar findPrimePairs = function(n) {\\n  // Function to check if a number is prime\\n  function isPrime(num) {\\n    if (num < 2) return false;\\n    for (let i = 2; i <= Math.sqrt(num); i++) {\\n      if (num % i === 0) return false;\\n    }\\n    return true;\\n  }\\n  const result = [];\\n  for (let x = 2; x <= n / 2; x++) {\\n    const y = n - x;\\n    if (isPrime(x) && isPrime(y)) {\\n      result.push([x, y]);\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3761131,
                "title": "simple-java-solution-using-sieve-of-eratosthenes-algorithm",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] prime = new boolean[n + 1];\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 2; i <= n; i++) {\\n            prime[i] = true;\\n        }\\n        \\n        prime[1] = false; \\n        prime[0] = false;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p]) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    prime[i] = false;\\n                }\\n            }\\n        }        \\n        for (int i = 2; i <= n - 1; i++) {\\n            int j = n - i; \\n            if (prime[i] && prime[j] && i <= j) {\\n                List<Integer> temp = new ArrayList<>(); \\n                temp.add(i);\\n                temp.add(j);\\n                ans.add(temp); \\n            }\\n        }\\n        \\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] prime = new boolean[n + 1];\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 2; i <= n; i++) {\\n            prime[i] = true;\\n        }\\n        \\n        prime[1] = false; \\n        prime[0] = false;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p]) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    prime[i] = false;\\n                }\\n            }\\n        }        \\n        for (int i = 2; i <= n - 1; i++) {\\n            int j = n - i; \\n            if (prime[i] && prime[j] && i <= j) {\\n                List<Integer> temp = new ArrayList<>(); \\n                temp.add(i);\\n                temp.add(j);\\n                ans.add(temp); \\n            }\\n        }\\n        \\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759494,
                "title": "java-2-sum",
                "content": "```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Set;\\n\\nimport static java.lang.Math.sqrt;\\nimport static java.util.Arrays.asList;\\n\\n\\nclass Solution {\\n    private static final Set<Integer> PRIMES = generatePrimes(1_000_000);\\n\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        return PRIMES.stream()\\n                     .filter(p -> p <= n / 2)\\n                     .filter(p -> PRIMES.contains(n - p))\\n                     .sorted()\\n                     .map(p -> asList(p, n - p))\\n                     .toList();\\n    }\\n\\n    private static Set<Integer> generatePrimes(int n) {\\n        List<Integer> primes = new ArrayList<>(n);\\n\\n        for (int i = 2; i <= n; i++) {\\n            int pLessThanI = (int) sqrt(i);\\n\\n            boolean isPrime = true;\\n\\n            for (int p : primes)\\n                if (p > pLessThanI)\\n                    break;\\n                else if (i % p == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n\\n            if (isPrime)\\n                primes.add(i);\\n\\n        }\\n\\n        return new HashSet<>(primes);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Set;\\n\\nimport static java.lang.Math.sqrt;\\nimport static java.util.Arrays.asList;\\n\\n\\nclass Solution {\\n    private static final Set<Integer> PRIMES = generatePrimes(1_000_000);\\n\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        return PRIMES.stream()\\n                     .filter(p -> p <= n / 2)\\n                     .filter(p -> PRIMES.contains(n - p))\\n                     .sorted()\\n                     .map(p -> asList(p, n - p))\\n                     .toList();\\n    }\\n\\n    private static Set<Integer> generatePrimes(int n) {\\n        List<Integer> primes = new ArrayList<>(n);\\n\\n        for (int i = 2; i <= n; i++) {\\n            int pLessThanI = (int) sqrt(i);\\n\\n            boolean isPrime = true;\\n\\n            for (int p : primes)\\n                if (p > pLessThanI)\\n                    break;\\n                else if (i % p == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n\\n            if (isPrime)\\n                primes.add(i);\\n\\n        }\\n\\n        return new HashSet<>(primes);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758617,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::*;\\n\\nfn sieve(a:usize) -> HashSet<i32> {\\n  let mut is_prime = vec![true;a+1];\\n  let mut set = HashSet::new();\\n  for i in 2..=a {\\n    if is_prime[i] {\\n      is_prime[i] = false;\\n      set.insert(i as i32);\\n      for j in 2..=a/i {\\n        is_prime[i * j] = false;\\n      }\\n    }\\n  }\\n  set\\n}\\n\\nimpl Solution {\\n  pub fn find_prime_pairs(n: i32) -> Vec<Vec<i32>> {\\n    let primes = sieve(n as usize);\\n\\n    let mut memo = HashSet::new();\\n    for &v in &primes {\\n      let hv = n - v;\\n      if primes.contains(&hv) {\\n        if hv < v {\\n          memo.insert(vec![hv, v]);\\n        } else {\\n          memo.insert(vec![v, hv]);\\n        }\\n      }\\n    }\\n    let mut result = memo.into_iter().collect::<Vec<Vec<i32>>>();\\n    result.sort_by(|a,b| a[0].cmp(&b[0]));\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nfn sieve(a:usize) -> HashSet<i32> {\\n  let mut is_prime = vec![true;a+1];\\n  let mut set = HashSet::new();\\n  for i in 2..=a {\\n    if is_prime[i] {\\n      is_prime[i] = false;\\n      set.insert(i as i32);\\n      for j in 2..=a/i {\\n        is_prime[i * j] = false;\\n      }\\n    }\\n  }\\n  set\\n}\\n\\nimpl Solution {\\n  pub fn find_prime_pairs(n: i32) -> Vec<Vec<i32>> {\\n    let primes = sieve(n as usize);\\n\\n    let mut memo = HashSet::new();\\n    for &v in &primes {\\n      let hv = n - v;\\n      if primes.contains(&hv) {\\n        if hv < v {\\n          memo.insert(vec![hv, v]);\\n        } else {\\n          memo.insert(vec![v, hv]);\\n        }\\n      }\\n    }\\n    let mut result = memo.into_iter().collect::<Vec<Vec<i32>>>();\\n    result.sort_by(|a,b| a[0].cmp(&b[0]));\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757666,
                "title": "sieve-of-eratosthenes-method-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> sieveOfEratosthenes(const int n) {\\n      \\n      vector<bool> isPrime(n + 1, true);\\n      isPrime[0] = isPrime[1] = false;\\n      for (int i = 2; i * i <= n; i++) {\\n        if (isPrime[i]) {\\n          for (int j = i * i; j <= n; j += i) {\\n            isPrime[j] = false;\\n          }\\n        }\\n      }\\n      return isPrime;\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if (n == 1) return ans;\\n        vector<bool> p = sieveOfEratosthenes(n);\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (p[i] && p[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> sieveOfEratosthenes(const int n) {\\n      \\n      vector<bool> isPrime(n + 1, true);\\n      isPrime[0] = isPrime[1] = false;\\n      for (int i = 2; i * i <= n; i++) {\\n        if (isPrime[i]) {\\n          for (int j = i * i; j <= n; j += i) {\\n            isPrime[j] = false;\\n          }\\n        }\\n      }\\n      return isPrime;\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if (n == 1) return ans;\\n        vector<bool> p = sieveOfEratosthenes(n);\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (p[i] && p[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753062,
                "title": "c-solution-using-sieve-of-eratosthenes-method",
                "content": "# Complexity\\n- Time complexity:\\nO(n*log(log(n)))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void seive(vector<bool>& arr, int n)\\n    {\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(arr[i])\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                    arr[j]=false;\\n            }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {  \\n        vector<vector<int>>ans;\\n        vector<bool>arr(n+1,true);\\n\\n        seive(arr,n);\\n        \\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(arr[i] && arr[n-i])\\n                ans.push_back({i,n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```\\nHope you find the code easy to understand.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Enumeration",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void seive(vector<bool>& arr, int n)\\n    {\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(arr[i])\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                    arr[j]=false;\\n            }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {  \\n        vector<vector<int>>ans;\\n        vector<bool>arr(n+1,true);\\n\\n        seive(arr,n);\\n        \\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(arr[i] && arr[n-i])\\n                ans.push_back({i,n-i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745573,
                "title": "no-tle-c",
                "content": "# Intuition\\nJust check all integers for **prime or not** with knowing the fact that we can search till \\'i <= n/2\\' and find the other pair element simply by (target - current integer) to avoid **TLE**!\\nThis is a property for prime pairs!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(int n){\\n    if(n<2 || (!(n&1) && n!=2))\\n        return 0;\\n    // To check if a number n is prime or not, **check n % integers == 0** or not till sqrt(n); If some number makes % == 0, n is not prime as it is divisible with some other number!\\n    for(int i=3; i*i<=n; i+=2){\\n        if(!(n%i))\\n            return 0;\\n    }\\n    return 1;\\n}\\n    vector<vector<int>> findPrimePairs(int n) \\n    {\\n        vector<vector<int>>ans = {};\\n        for(int i = 2; i <= n/2; i++)\\n        {\\n            if(i != 2 && i % 2 == 0)continue;\\n            if(fun(i) == 1 && fun(n-i) == 1 && i <= n-i)ans.push_back({i, n-i});\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int n){\\n    if(n<2 || (!(n&1) && n!=2))\\n        return 0;\\n    // To check if a number n is prime or not, **check n % integers == 0** or not till sqrt(n); If some number makes % == 0, n is not prime as it is divisible with some other number!\\n    for(int i=3; i*i<=n; i+=2){\\n        if(!(n%i))\\n            return 0;\\n    }\\n    return 1;\\n}\\n    vector<vector<int>> findPrimePairs(int n) \\n    {\\n        vector<vector<int>>ans = {};\\n        for(int i = 2; i <= n/2; i++)\\n        {\\n            if(i != 2 && i % 2 == 0)continue;\\n            if(fun(i) == 1 && fun(n-i) == 1 && i <= n-i)ans.push_back({i, n-i});\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745272,
                "title": "c-solution-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<int> primesNos;\\n\\n    void sieveOfErathotness(int n) {\\n        vector<int> primes(n + 1, true);\\n        primes[0] = primes[1] = false;\\n\\n        for(int i = 2; i <= sqrt(n); i++) {\\n            if(primes[i]) {\\n                for(int j = 2 * i; j <= n; j += i)\\n                    primes[j] = false;\\n            }\\n        }\\n\\n        for(int i = 0; i <= n; i++)\\n            if(primes[i])\\n                primesNos.insert(i);\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> res;\\n        sieveOfErathotness(n); \\n        map<int, int> mp;\\n\\n        for(auto i: primesNos) {\\n            if(primesNos.count(n - i)) {\\n                if(mp.count(n - i))\\n                    continue;\\n                else\\n                    mp[i] = n - i;\\n            }\\n        }\\n\\n        for(auto i: mp)\\n            res.push_back({i.first, i.second});\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> primesNos;\\n\\n    void sieveOfErathotness(int n) {\\n        vector<int> primes(n + 1, true);\\n        primes[0] = primes[1] = false;\\n\\n        for(int i = 2; i <= sqrt(n); i++) {\\n            if(primes[i]) {\\n                for(int j = 2 * i; j <= n; j += i)\\n                    primes[j] = false;\\n            }\\n        }\\n\\n        for(int i = 0; i <= n; i++)\\n            if(primes[i])\\n                primesNos.insert(i);\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> res;\\n        sieveOfErathotness(n); \\n        map<int, int> mp;\\n\\n        for(auto i: primesNos) {\\n            if(primesNos.count(n - i)) {\\n                if(mp.count(n - i))\\n                    continue;\\n                else\\n                    mp[i] = n - i;\\n            }\\n        }\\n\\n        for(auto i: mp)\\n            res.push_back({i.first, i.second});\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744014,
                "title": "trial-division-prime-factorization-2-approaches",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1)\\n            return false;\\n        if (n <= 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for (int i = 5; i * i <= n; i += 6) {\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        for (int x = 2; x <= n / 2; x++) {\\n            if (isPrime(x) && isPrime(n - x))\\n                ans.push_back({x, n - x});\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        for (int x = 2; x <= n / 2; x++) {\\n            if (isPrime(x) && isPrime(n - x))\\n                ans.push_back({x, n - x});\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    bool isPrime(int num) {\\n        if (num <= 1)\\n            return false;\\n        for (int i = 2; i * i <= num; i++) {\\n            if (num % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1)\\n            return false;\\n        if (n <= 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for (int i = 5; i * i <= n; i += 6) {\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        for (int x = 2; x <= n / 2; x++) {\\n            if (isPrime(x) && isPrime(n - x))\\n                ans.push_back({x, n - x});\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        for (int x = 2; x <= n / 2; x++) {\\n            if (isPrime(x) && isPrime(n - x))\\n                ans.push_back({x, n - x});\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    bool isPrime(int num) {\\n        if (num <= 1)\\n            return false;\\n        for (int i = 2; i * i <= num; i++) {\\n            if (num % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742720,
                "title": "use-sieve-of-eratosthenes-to-find-prime-and-avoid-tle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) \\n    {\\n        vector<bool>primes(n+1,true); \\n        primes[0]= primes[1]= false; \\n        for(int i=2; i*i<=n;i++) \\n        {\\n            if(primes[i]) \\n            {\\n                for (int j =i*i;j<=n;j+=i)\\n                 {\\n                    primes[j] =false;\\n                 }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        for (int x=2; x<=n/2; x++) {\\n            int y=n-x;\\n            if (primes[x] && primes[y])\\n             {\\n                result.push_back({x,y});\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) \\n    {\\n        vector<bool>primes(n+1,true); \\n        primes[0]= primes[1]= false; \\n        for(int i=2; i*i<=n;i++) \\n        {\\n            if(primes[i]) \\n            {\\n                for (int j =i*i;j<=n;j+=i)\\n                 {\\n                    primes[j] =false;\\n                 }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        for (int x=2; x<=n/2; x++) {\\n            int y=n-x;\\n            if (primes[x] && primes[y])\\n             {\\n                result.push_back({x,y});\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740999,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[]isPrime = new boolean[n+1];\\n        isPrime[0] = true;\\n        isPrime[1] = true;\\n       \\n        for(int i = 2;i<=n;i++){\\n            if(isPrime[i] == false){\\n                for(int j = 2*i;j<=n;j=j+i)\\n                    isPrime[j] = true;\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i = 2;i <= n/2;i++){\\n            if(isPrime[i] == false && isPrime[n-i] == false){\\n                List<Integer>a = new ArrayList<>();\\n                a.add(i);\\n                a.add(n-i);\\n                ans.add(new ArrayList(a));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[]isPrime = new boolean[n+1];\\n        isPrime[0] = true;\\n        isPrime[1] = true;\\n       \\n        for(int i = 2;i<=n;i++){\\n            if(isPrime[i] == false){\\n                for(int j = 2*i;j<=n;j=j+i)\\n                    isPrime[j] = true;\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i = 2;i <= n/2;i++){\\n            if(isPrime[i] == false && isPrime[n-i] == false){\\n                List<Integer>a = new ArrayList<>();\\n                a.add(i);\\n                a.add(n-i);\\n                ans.add(new ArrayList(a));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739453,
                "title": "sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhy leetcode create `Solution` object for each testcase now?\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n static std::vector<bool> primes_;\\n static bool inited_;\\n public:\\n  Solution() { Eratosthenes(); }\\n\\n  void Eratosthenes() {\\n    if (inited_) {\\n      return;\\n    }\\n    primes_[0] = false;\\n    primes_[1] = false;\\n    for (int i = 2; i < primes_.size(); ++i) {\\n      if (i < std::sqrt(1000000 + 1) && primes_[i]) {\\n        for (int j = i + i; j < primes_.size(); j += i) {\\n          primes_[j] = false;\\n        }\\n      }\\n    }\\n    inited_ = true;\\n  }\\n  std::vector<std::vector<int>> findPrimePairs(int n) {\\n    std::vector<std::vector<int>> result;\\n    if ((n % 2) && n < 5) {\\n      return {};\\n    }\\n    for (int i = 2; i <= n / 2; ++i) {\\n      if (primes_[i] && primes_[n - i]) {\\n        result.push_back({i, n - i});\\n      }\\n    }\\n    return result;\\n  }\\n};\\nbool Solution::inited_ = false;\\nstd::vector<bool> Solution::primes_(1000000 + 1 , true);\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n static std::vector<bool> primes_;\\n static bool inited_;\\n public:\\n  Solution() { Eratosthenes(); }\\n\\n  void Eratosthenes() {\\n    if (inited_) {\\n      return;\\n    }\\n    primes_[0] = false;\\n    primes_[1] = false;\\n    for (int i = 2; i < primes_.size(); ++i) {\\n      if (i < std::sqrt(1000000 + 1) && primes_[i]) {\\n        for (int j = i + i; j < primes_.size(); j += i) {\\n          primes_[j] = false;\\n        }\\n      }\\n    }\\n    inited_ = true;\\n  }\\n  std::vector<std::vector<int>> findPrimePairs(int n) {\\n    std::vector<std::vector<int>> result;\\n    if ((n % 2) && n < 5) {\\n      return {};\\n    }\\n    for (int i = 2; i <= n / 2; ++i) {\\n      if (primes_[i] && primes_[n - i]) {\\n        result.push_back({i, n - i});\\n      }\\n    }\\n    return result;\\n  }\\n};\\nbool Solution::inited_ = false;\\nstd::vector<bool> Solution::primes_(1000000 + 1 , true);\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738896,
                "title": "c-easy-faster-than-96-5-seive",
                "content": "***Good code fetches you money, better codes will impact lives***\\n```\\nvector<bool>seive=vector<bool>(1e6+1,true);\\nvector<int>primes;\\nclass Solution {\\npublic:\\n    void filler(){\\n        seive[0]=false;seive[1]=false;\\n        for(int i=2;i<seive.size()/2+1;i++){\\n            for(int j=i*2;j<seive.size();j+=i)seive[j]=false;\\n        }for(int i=0;i<seive.size();i++)if(seive[i])primes.push_back(i);\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        if(primes.size()==0)filler();\\n        vector<vector<int>>res;\\n        for(auto &prime:primes){\\n            if(prime>n/2)break;\\n            if(seive[n-prime])res.push_back({prime,n-prime});\\n        }return res;\\n    }\\n};\\n```\\n**logik**\\n0. before we start, we must know seive of eratosthenes so little insight about it is it is an array in which firstly all numbers are marked true. Then starting from 2 we mark multiples(starting from 2nd multiple of any number) of 2 to be false, and then do same for 3 and 4 and so on.Once done, only the numbers which are multiples of none remain true thus if arr[i]==true then i is prime and iterating over the seive , we can collect the numbers which are true in a seperate primes array. \\n1. first we pre-compute seive of eratosthenes and store it for use \\n2. now we can access the next smaller prime number from array primes and check if a number is prime or not from seive both in O(1) \\n3.iterate over primes from start till n/2 and check if [n-x] is prime or not using seive , if it is true then add {x,n-x} to our res (result array) \\n4.return the result array.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<bool>seive=vector<bool>(1e6+1,true);\\nvector<int>primes;\\nclass Solution {\\npublic:\\n    void filler(){\\n        seive[0]=false;seive[1]=false;\\n        for(int i=2;i<seive.size()/2+1;i++){\\n            for(int j=i*2;j<seive.size();j+=i)seive[j]=false;\\n        }for(int i=0;i<seive.size();i++)if(seive[i])primes.push_back(i);\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        if(primes.size()==0)filler();\\n        vector<vector<int>>res;\\n        for(auto &prime:primes){\\n            if(prime>n/2)break;\\n            if(seive[n-prime])res.push_back({prime,n-prime});\\n        }return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736036,
                "title": "c-easy-solution-2-pointer-easy-solutione",
                "content": "# Intuition\\nSimple 2 - Pointer Approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Implementation of coad what written in question\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n<2) return false;\\n\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> v;\\n        for(int x=2; x<=n/2; x++){\\n            int y = n-x;\\n\\n            if(isPrime(x) && isPrime(y)){\\n                vector<int> pair = {x,y};\\n                v.push_back(pair);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n<2) return false;\\n\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> v;\\n        for(int x=2; x<=n/2; x++){\\n            int y = n-x;\\n\\n            if(isPrime(x) && isPrime(y)){\\n                vector<int> pair = {x,y};\\n                v.push_back(pair);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735756,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> ans=new ArrayList<>();;\\n        for(int i=2;i<=n/2; i++){\\n            if(isPrime(i) && isPrime(n-i)){\\n                ans.add(Arrays.asList(i,n-i));\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean isPrime(int n){\\n        if (n<=1)\\n            return false;\\n        if (n == 2 || n == 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for(int i=5;i*i<=n;i=i+6){\\n            if (n%i==0|| n%(i+2)==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> ans=new ArrayList<>();;\\n        for(int i=2;i<=n/2; i++){\\n            if(isPrime(i) && isPrime(n-i)){\\n                ans.add(Arrays.asList(i,n-i));\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean isPrime(int n){\\n        if (n<=1)\\n            return false;\\n        if (n == 2 || n == 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for(int i=5;i*i<=n;i=i+6){\\n            if (n%i==0|| n%(i+2)==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734330,
                "title": "easy-solution-sieve-of-eratosthenes-eas-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWE HAVE TO FIND THAT THE GIVEN NUMBER IS PRIME OR NOT AND THIS CAN BE ACHIEVE BY SIEVE OF ERATOSTHENES\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCREATE A SEIVE ARRAY OF SIZE 10^6+1 THEN FIND THAT I AND N-I IS PRIME OR NOT AND PUSH OT INTO ANSWER 2D VECTOR\\n# Complexity\\n- Time complexity:O(N(LOG(LOG(N)))) + O(N/2) FOR CREATING THE SEIEVE AND O(N) IS FOR CHECEKING THE CONDITIONS\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst int N=1000000;\\n\\nclass Solution {\\npublic:\\nbool sieve[N+1];\\nvoid createSieve(){\\n    for(int i=2; i<N; i++){\\n        sieve[i]=true;\\n    }\\n\\n    for(int i=2; i*i<=N; i++){\\n        if(sieve[i]==true){\\n            for(int j=i*i; j<=N; j+=i){\\n                 sieve[j]=false;\\n            }\\n        }\\n    }\\n}\\n    vector<vector<int>> findPrimePairs(int n) {\\n        createSieve();\\n        vector<vector<int>>ans;\\n        for(int i=1;i<=n/2;i++){\\n            if(sieve[i]==true){\\n                int diff=n-i;\\n                if(sieve[diff]==true){\\n                    vector<int>temp;\\n                    temp.push_back(i);\\n                    temp.push_back(diff);\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N=1000000;\\n\\nclass Solution {\\npublic:\\nbool sieve[N+1];\\nvoid createSieve(){\\n    for(int i=2; i<N; i++){\\n        sieve[i]=true;\\n    }\\n\\n    for(int i=2; i*i<=N; i++){\\n        if(sieve[i]==true){\\n            for(int j=i*i; j<=N; j+=i){\\n                 sieve[j]=false;\\n            }\\n        }\\n    }\\n}\\n    vector<vector<int>> findPrimePairs(int n) {\\n        createSieve();\\n        vector<vector<int>>ans;\\n        for(int i=1;i<=n/2;i++){\\n            if(sieve[i]==true){\\n                int diff=n-i;\\n                if(sieve[diff]==true){\\n                    vector<int>temp;\\n                    temp.push_back(i);\\n                    temp.push_back(diff);\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733899,
                "title": "golang-93-ms-7-2-mb-primes-precomputing",
                "content": "```\\nvar primes []uint32\\n\\nfunc init() {\\n\\tprimes = make([]uint32, 0, 78499)\\n\\tprimes = append(primes, 2, 3)\\nNumsLoop:\\n\\tfor i := uint32(5); i <= 1_000_003; i += 2 {\\n\\t\\tfor j, iSqrt := 0, uint32(math.Sqrt(float64(i))); primes[j] <= iSqrt; j++ {\\n\\t\\t\\tif i%primes[j] == 0 {\\n\\t\\t\\t\\tcontinue NumsLoop\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprimes = append(primes, i)\\n\\t}\\n}\\n\\nfunc findPrimePairs(n int) [][]int {\\n\\tif n <= 3 {\\n\\t\\treturn nil\\n\\t}\\n\\tvar result [][]int\\n\\tr := sort.Search(len(primes), func(i int) bool {\\n\\t\\treturn primes[i] >= uint32(n-2)\\n\\t})\\n\\tfor l := 0; l <= r; {\\n\\t\\tsum := primes[l] + primes[r]\\n\\t\\tif sum > uint32(n) {\\n\\t\\t\\tr--\\n\\t\\t} else if sum < uint32(n) {\\n\\t\\t\\tl++\\n\\t\\t} else {\\n\\t\\t\\tresult = append(result, []int{int(primes[l]), int(primes[r])})\\n\\t\\t\\tl++\\n\\t\\t\\tr--\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nvar primes []uint32\\n\\nfunc init() {\\n\\tprimes = make([]uint32, 0, 78499)\\n\\tprimes = append(primes, 2, 3)\\nNumsLoop:\\n\\tfor i := uint32(5); i <= 1_000_003; i += 2 {\\n\\t\\tfor j, iSqrt := 0, uint32(math.Sqrt(float64(i))); primes[j] <= iSqrt; j++ {\\n\\t\\t\\tif i%primes[j] == 0 {\\n\\t\\t\\t\\tcontinue NumsLoop\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprimes = append(primes, i)\\n\\t}\\n}\\n\\nfunc findPrimePairs(n int) [][]int {\\n\\tif n <= 3 {\\n\\t\\treturn nil\\n\\t}\\n\\tvar result [][]int\\n\\tr := sort.Search(len(primes), func(i int) bool {\\n\\t\\treturn primes[i] >= uint32(n-2)\\n\\t})\\n\\tfor l := 0; l <= r; {\\n\\t\\tsum := primes[l] + primes[r]\\n\\t\\tif sum > uint32(n) {\\n\\t\\t\\tr--\\n\\t\\t} else if sum < uint32(n) {\\n\\t\\t\\tl++\\n\\t\\t} else {\\n\\t\\t\\tresult = append(result, []int{int(primes[l]), int(primes[r])})\\n\\t\\t\\tl++\\n\\t\\t\\tr--\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733509,
                "title": "python-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        a = [True for i in range(n + 1)]\\n        b = 2\\n        while b * b <= n:\\n            if a[b] == True:\\n                for i in range(b * 2, n + 1, b): \\n                    a[i] = False\\n            b += 1\\n        res = []\\n        for j in range(2, n // 2 + 1):\\n            if a[j] and a[n - j]:\\n                res.append([j, n - j])\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        a = [True for i in range(n + 1)]\\n        b = 2\\n        while b * b <= n:\\n            if a[b] == True:\\n                for i in range(b * 2, n + 1, b): \\n                    a[i] = False\\n            b += 1\\n        res = []\\n        for j in range(2, n // 2 + 1):\\n            if a[j] and a[n - j]:\\n                res.append([j, n - j])\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733495,
                "title": "easy-java-solution-sieveoferatosthenes",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        \\n        int[] prime = new int[n+1];\\n\\n        for(int i=2;i*i<=n;i++){\\n\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=n;j=j+i){\\n                    prime[j]=1;\\n                }\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for(int i=2;i<=n/2;i++){\\n\\n            if(prime[i]==0 && prime[n-i]==0){\\n                List<Integer> list = new ArrayList<>();\\n                list.add(i);\\n                list.add(n-i);\\n                ans.add(list);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        \\n        int[] prime = new int[n+1];\\n\\n        for(int i=2;i*i<=n;i++){\\n\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=n;j=j+i){\\n                    prime[j]=1;\\n                }\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for(int i=2;i<=n/2;i++){\\n\\n            if(prime[i]==0 && prime[n-i]==0){\\n                List<Integer> list = new ArrayList<>();\\n                list.add(i);\\n                list.add(n-i);\\n                ans.add(list);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733323,
                "title": "sieve-of-eratosthenes-two-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBecause this problem is to find the prime pairs, what we are looking for below:\\n1. prime number\\n2. sum(primeX, primeY) = n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe efficient approach to find all of the primes in the range of n is the \"Sieve of Eratosthenes\"[1].\\n\\nAfter find all the primes, we can use the approach like \"Two Sum\"[2], however, we only need to iterate [2, n / 2], because the numbers are [x, n - x].\\n\\nFinally, the result will be in the natural order.\\n\\n[1] https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\\n[2] https://leetcode.com/problems/two-sum/\\n\\n# Complexity\\n- Time complexity: O(n*Sqrt(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] isPrimeArr = new boolean[n + 1];\\n        Arrays.fill(isPrimeArr, true);\\n        int sqrt = (int) Math.sqrt(n);\\n        for (int i = 2; i <= sqrt; i++) {\\n            if (isPrimeArr[i]) {\\n                for (int j = 2; i * j <= n; j++) {\\n                    isPrimeArr[i * j] = false;\\n                }\\n            }\\n        }\\n        List<List<Integer>> resList = new ArrayList<>();\\n        for (int i = 2; i <= n / 2; i++) {\\n            if (isPrimeArr[i] && isPrimeArr[n - i]) {\\n                resList.add(Arrays.asList(i, n - i));\\n            }\\n        }\\n        return resList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[] isPrimeArr = new boolean[n + 1];\\n        Arrays.fill(isPrimeArr, true);\\n        int sqrt = (int) Math.sqrt(n);\\n        for (int i = 2; i <= sqrt; i++) {\\n            if (isPrimeArr[i]) {\\n                for (int j = 2; i * j <= n; j++) {\\n                    isPrimeArr[i * j] = false;\\n                }\\n            }\\n        }\\n        List<List<Integer>> resList = new ArrayList<>();\\n        for (int i = 2; i <= n / 2; i++) {\\n            if (isPrimeArr[i] && isPrimeArr[n - i]) {\\n                resList.add(Arrays.asList(i, n - i));\\n            }\\n        }\\n        return resList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732811,
                "title": "java-solution-easy-to-understand-sieve-method",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        List<List<Integer>> ans=new ArrayList<>();\\n        PriorityQueue<int[]> q=new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        ArrayList<Integer> list=new ArrayList<>();\\n        boolean[] prime=new boolean[n+1];\\n        // prime[1]=true;\\n        for(int i=1;i<=n;i++){\\n            prime[i]=true;\\n        }\\n        for(int i=2;i<=n;i++){\\n            if(prime[i]==true){\\n                for(int j=i+i;j<=n;j=j+i){\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n        for(int i=2;i<=n;i++){\\n            if(prime[i])list.add(i);\\n        }\\n        for(int i:list){\\n            if(i>n/2)break;\\n            if(i+(n-i)==n&&(prime[n-i])){\\n                int[] temp=new int[2];\\n                temp[0]=i;\\n                temp[1]=n-i;\\n                Arrays.sort(temp);\\n                q.add(temp);\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            List<Integer> temp=new ArrayList<>();\\n            int[] t=q.poll();\\n            temp.add(t[0]);\\n            temp.add(t[1]);\\n            ans.add(temp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        List<List<Integer>> ans=new ArrayList<>();\\n        PriorityQueue<int[]> q=new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        ArrayList<Integer> list=new ArrayList<>();\\n        boolean[] prime=new boolean[n+1];\\n        // prime[1]=true;\\n        for(int i=1;i<=n;i++){\\n            prime[i]=true;\\n        }\\n        for(int i=2;i<=n;i++){\\n            if(prime[i]==true){\\n                for(int j=i+i;j<=n;j=j+i){\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n        for(int i=2;i<=n;i++){\\n            if(prime[i])list.add(i);\\n        }\\n        for(int i:list){\\n            if(i>n/2)break;\\n            if(i+(n-i)==n&&(prime[n-i])){\\n                int[] temp=new int[2];\\n                temp[0]=i;\\n                temp[1]=n-i;\\n                Arrays.sort(temp);\\n                q.add(temp);\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            List<Integer> temp=new ArrayList<>();\\n            int[] t=q.poll();\\n            temp.add(t[0]);\\n            temp.add(t[1]);\\n            ans.add(temp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731975,
                "title": "sieve-of-eratosthenes-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sieve(int n){\\n        vector<bool> isPrime(n+1, true);\\n        vector<int> v;\\n        for(int i = 2; i < n; i++){\\n            if(isPrime[i]){\\n                v.push_back(i);\\n                for(int j = i*2; j < n; j+=i){\\n                    isPrime[j] = false;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int> primes = sieve(n);\\n        vector<vector<int>> ans;\\n        int s = 0;\\n        int e = primes.size()-1;\\n        while(s <= e){\\n            if((primes[s] + primes[e]) < n) s++;\\n            else if((primes[s] + primes[e]) > n) e--;\\n            else {\\n                ans.push_back({primes[s],primes[e]});\\n                s++;\\n                e--;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sieve(int n){\\n        vector<bool> isPrime(n+1, true);\\n        vector<int> v;\\n        for(int i = 2; i < n; i++){\\n            if(isPrime[i]){\\n                v.push_back(i);\\n                for(int j = i*2; j < n; j+=i){\\n                    isPrime[j] = false;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int> primes = sieve(n);\\n        vector<vector<int>> ans;\\n        int s = 0;\\n        int e = primes.size()-1;\\n        while(s <= e){\\n            if((primes[s] + primes[e]) < n) s++;\\n            else if((primes[s] + primes[e]) > n) e--;\\n            else {\\n                ans.push_back({primes[s],primes[e]});\\n                s++;\\n                e--;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731171,
                "title": "using-sieve-of-eratosthenes-method-and-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, we would need to have all the prime numbers between 1 to n, in an array.\\nWith that we will check for the following three conditions using Two Pointer Approach --:\\n- 1 <= x <= y <= n\\n- x + y == n\\n- x and y are prime numbers\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFollowing are the steps required to solve the problem --:\\n1. Store all the prime numbers in an array using the Sieve of Eratosthenes Algorithm.\\n2. Use two pointer approach to find pairs of prime numbers which satisfies the given conditions.\\n3. Return the ans matrix\\n# Complexity\\n- Time complexity: O(n*log(log n)) for Sieve of Eratosthenes Algorithm\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for extra arrays used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n[ Note: you can refer to GFG editorial for Sieve of Erastosthenes Algorithm ]\\n\\nSome Helpful Links -:\\nhttps://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\\nhttps://brilliant.org/wiki/sieve-of-eratosthenes/\\n\\n**Comment, if you have any doubts! Also Upvote.**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if(n==1) return ans;\\n        bool prime[n / 2];\\n        vector<int> primeNums;\\n        memset(prime, false, sizeof(prime));\\n    \\n        // 2 is the only even prime so we can\\n        // ignore that. Loop starts from 3.\\n        for (int i = 3; i * i < n; i += 2) {\\n            // If i is prime, mark all its\\n            // multiples as composite\\n            if (prime[i / 2] == false)\\n                for (int j = i * i; j < n; j += i * 2)\\n                    prime[j / 2] = true;\\n        };\\n    \\n        // writing 2 separately\\n        primeNums.push_back(2);\\n    \\n        // Printing other primes\\n        for (int i = 3; i < n; i += 2)\\n            if (prime[i / 2] == false)\\n                primeNums.push_back(i);\\n        \\n        int i = 0, j = primeNums.size()-1;\\n        \\n        while(i <= j){\\n            if(primeNums[i]+primeNums[j]==n){\\n                vector<int> temp;\\n                temp.push_back(primeNums[i++]);\\n                temp.push_back(primeNums[j--]);\\n                ans.push_back(temp);\\n            } else if(primeNums[i]+primeNums[j]>n) j--;\\n            else i++;\\n        };\\n        return ans;\\n    };\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ans;\\n        if(n==1) return ans;\\n        bool prime[n / 2];\\n        vector<int> primeNums;\\n        memset(prime, false, sizeof(prime));\\n    \\n        // 2 is the only even prime so we can\\n        // ignore that. Loop starts from 3.\\n        for (int i = 3; i * i < n; i += 2) {\\n            // If i is prime, mark all its\\n            // multiples as composite\\n            if (prime[i / 2] == false)\\n                for (int j = i * i; j < n; j += i * 2)\\n                    prime[j / 2] = true;\\n        };\\n    \\n        // writing 2 separately\\n        primeNums.push_back(2);\\n    \\n        // Printing other primes\\n        for (int i = 3; i < n; i += 2)\\n            if (prime[i / 2] == false)\\n                primeNums.push_back(i);\\n        \\n        int i = 0, j = primeNums.size()-1;\\n        \\n        while(i <= j){\\n            if(primeNums[i]+primeNums[j]==n){\\n                vector<int> temp;\\n                temp.push_back(primeNums[i++]);\\n                temp.push_back(primeNums[j--]);\\n                ans.push_back(temp);\\n            } else if(primeNums[i]+primeNums[j]>n) j--;\\n            else i++;\\n        };\\n        return ans;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730966,
                "title": "simple-sieve-prime-number-straight-forward-easy-c",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e9 + 7;\\ntemplate<typename T>\\n \\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\nint maxn = 1e6 + 5;\\nvi sieve(maxn, true);\\n\\n\\nvoid cal(){\\n    for(int i = 2;i * i < maxn;i++){\\n        if(sieve[i] == false) continue;\\n        for(int j = i * i;j < maxn;j += i) sieve[j] = false;\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> findPrimePairs(int n) {\\n        cal();\\n        vvi output;\\n        for(int i = 2;i <= n / 2;i++){\\n            if(sieve[i] and sieve[n - i]){\\n                vi temp;\\n                temp.pb(i);\\n                temp.pb(n - i);\\n                output.pb(temp);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e9 + 7;\\ntemplate<typename T>\\n \\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\nint maxn = 1e6 + 5;\\nvi sieve(maxn, true);\\n\\n\\nvoid cal(){\\n    for(int i = 2;i * i < maxn;i++){\\n        if(sieve[i] == false) continue;\\n        for(int j = i * i;j < maxn;j += i) sieve[j] = false;\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> findPrimePairs(int n) {\\n        cal();\\n        vvi output;\\n        for(int i = 2;i <= n / 2;i++){\\n            if(sieve[i] and sieve[n - i]){\\n                vi temp;\\n                temp.pb(i);\\n                temp.pb(n - i);\\n                output.pb(temp);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3729403,
                "title": "c-sieve-of-eratosthenes",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> prime(n + 1, true);\\n        for (int p = 2; p * p <= n; p++){\\n            if (prime[p] == true){\\n                for (int i = p * 2; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        vector<vector<int>> res;\\n        for (int p = 2; p <= n/2; p++)\\n            if (prime[p] && prime[n - p])\\n                res.push_back({p, n - p});\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> prime(n + 1, true);\\n        for (int p = 2; p * p <= n; p++){\\n            if (prime[p] == true){\\n                for (int i = p * 2; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        vector<vector<int>> res;\\n        for (int p = 2; p <= n/2; p++)\\n            if (prime[p] && prime[n - p])\\n                res.push_back({p, n - p});\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729283,
                "title": "sieve-of-eratosthenes-2-sum-o-n-log-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        saw = []\\n        seen = []\\n        xs = [True for i in range(n+1)]\\n        a = 2\\n        while (a * a  <= n):\\n            if xs[a] == True:\\n                for j in range(a*a, n+1, a):\\n                    xs[j] = False\\n            a += 1\\n    \\n        for a in range(2, n+1):\\n            if xs[a]:\\n                saw.append(a)\\n    \\n        for x in range(2, n // 2 + 1):\\n            if xs[x] and xs[n-x]:\\n                seen.append([x, n-x])\\n        return seen\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        saw = []\\n        seen = []\\n        xs = [True for i in range(n+1)]\\n        a = 2\\n        while (a * a  <= n):\\n            if xs[a] == True:\\n                for j in range(a*a, n+1, a):\\n                    xs[j] = False\\n            a += 1\\n    \\n        for a in range(2, n+1):\\n            if xs[a]:\\n                saw.append(a)\\n    \\n        for x in range(2, n // 2 + 1):\\n            if xs[x] and xs[n-x]:\\n                seen.append([x, n-x])\\n        return seen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728616,
                "title": "sieve-of-erastothenes-easy-understanding-c-with-comments",
                "content": "### Sieve of Erastothenes \\nSieve Method is a method to Generate Prime Numbers.\\nExplained as follows with code.\\n``` cpp \\n\\t//Sieve Method to Generate Prime Numbers\\n    vector<bool> isPrimeSieve(int number){\\n        //Step 1: \\n        /*\\n        Store the bool value initially to true \\n        (considering all numbers to be prime ) \\n        for all a possible numbers till n including n.\\n        (size is taken as n+1 instead of n).\\n        */\\n        vector<bool>sieve(number+1,true);\\n        //Step 2:\\n        /*\\n        Making 0 and 1 to be false as they can\\'t be prime \\n        by fundamental theorm of arithmetic and definition of prime numbers.\\n        */\\n        sieve[0]=sieve[1]=false;\\n        //Step 3:\\n        /*\\n        This step consist of three minor steps:\\n        1.First Minor step\\n        (```cpp  for(long long i=2;(long long)(i*i)<=number;i++) ```)\\n        Take the initial prime numbers only till sqrt(number) or i^2<=number\\n        This comes from the major improvement of observation that any number \\n        n=a*b where a and b are two factors of n but it can be seen that any\\n        of a or b can definitely be less than or equal to sqrt of n or square\\n        of the number must be less than n.So if we found out that factor there m\\n        might not be need to re-calculate till next factor.\\n        \\n        2.Second minor step(```cpp for(long long j=i*i;j<=number;j+=i)```) \\n        Check if the number we are checking is prime or not if so make all of\\n        its multiples whose square is less than or equal to n as false.This \\n        optimisation can be easily proven by the example like\\n        taking multiples of 5 for example ie. 5,10,15 etc.\\n        10 = 2*5\\n        15 = 3*5\\n        20 = 4*5\\n        and so on.\\n        As can be seen the multiples of 5 that are less than or equal to square \\n        of number are already accounted by smaller factors like 2,3 and 4 \\n        so no need to again make it check for 5.\\n        \\n        3.Third minor step(```cpp sieve[j]=false;```) \\n        It is to make the items that are following minor step 2\\n        as false .\\n        */\\n        for(long long i=2;(long long)(i*i)<=number;i++){\\n            if(sieve[i]==true){\\n                for(long long j=i*i;j<=number;j+=i){\\n                    sieve[j]=false;\\n                }\\n            }\\n            \\n        }\\n        return sieve;\\n    \\n    }\\n   \\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> result;\\n        vector<bool> primeSieve=isPrimeSieve(n);\\n        for(int i =2;i<=n/2;i++){\\n            // Only checking till n/2 as we only want the increasing values of x\\n            if(primeSieve[i]==true and primeSieve[n-i]==true){\\n                // if both i and number - i ie if 3 is prime and 7 is prime\\n                // then as sieve consist of only prime numbers then it \\n                // becomes part of result.\\n                 result.push_back({i,n-i});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` cpp \\n\\t//Sieve Method to Generate Prime Numbers\\n    vector<bool> isPrimeSieve(int number){\\n        //Step 1: \\n        /*\\n        Store the bool value initially to true \\n        (considering all numbers to be prime ) \\n        for all a possible numbers till n including n.\\n        (size is taken as n+1 instead of n).\\n        */\\n        vector<bool>sieve(number+1,true);\\n        //Step 2:\\n        /*\\n        Making 0 and 1 to be false as they can\\'t be prime \\n        by fundamental theorm of arithmetic and definition of prime numbers.\\n        */\\n        sieve[0]=sieve[1]=false;\\n        //Step 3:\\n        /*\\n        This step consist of three minor steps:\\n        1.First Minor step\\n        (```\n```)\\n        Take the initial prime numbers only till sqrt(number) or i^2<=number\\n        This comes from the major improvement of observation that any number \\n        n=a*b where a and b are two factors of n but it can be seen that any\\n        of a or b can definitely be less than or equal to sqrt of n or square\\n        of the number must be less than n.So if we found out that factor there m\\n        might not be need to re-calculate till next factor.\\n        \\n        2.Second minor step(```\n```) \\n        Check if the number we are checking is prime or not if so make all of\\n        its multiples whose square is less than or equal to n as false.This \\n        optimisation can be easily proven by the example like\\n        taking multiples of 5 for example ie. 5,10,15 etc.\\n        10 = 2*5\\n        15 = 3*5\\n        20 = 4*5\\n        and so on.\\n        As can be seen the multiples of 5 that are less than or equal to square \\n        of number are already accounted by smaller factors like 2,3 and 4 \\n        so no need to again make it check for 5.\\n        \\n        3.Third minor step(```\n```) \\n        It is to make the items that are following minor step 2\\n        as false .\\n        */\\n        for(long long i=2;(long long)(i*i)<=number;i++){\\n            if(sieve[i]==true){\\n                for(long long j=i*i;j<=number;j+=i){\\n                    sieve[j]=false;\\n                }\\n            }\\n            \\n        }\\n        return sieve;\\n    \\n    }\\n   \\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> result;\\n        vector<bool> primeSieve=isPrimeSieve(n);\\n        for(int i =2;i<=n/2;i++){\\n            // Only checking till n/2 as we only want the increasing values of x\\n            if(primeSieve[i]==true and primeSieve[n-i]==true){\\n                // if both i and number - i ie if 3 is prime and 7 is prime\\n                // then as sieve consist of only prime numbers then it \\n                // becomes part of result.\\n                 result.push_back({i,n-i});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3727834,
                "title": "easy-c-seive-algo-with-100-time-complexity",
                "content": "# Intuition\\nSieve algorithm + easy sum calculation\\n# Approach\\n* Finding all prime numbers till \\'n\\' using Sieve\\'s algorithm\\n* going through each prime number between 2-n range and adding  prime number i and n-i if i<=n-i.\\n* pushing the result to the vector\\n\\n# Complexity\\n- Time complexity:\\nO(n log log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        bool prime[n+1];\\n    memset(prime, true, sizeof(prime));\\n    for (int p=2; p*p<=n; p++)\\n    {\\n        if (prime[p] == true)\\n        {\\n            for (int i=p*2; i<=n; i += p)\\n                prime[i] = false;\\n        }\\n    }\\n    vector<vector<int>>v;\\n    vector<int>v1;\\n        int anothernum;\\n        for(int i=2;i<=n;i++){\\n            if(prime[i]==true){\\n                anothernum=n-i;\\n                if(anothernum>=i&&prime[anothernum]==true){\\n                    v1={i,anothernum};\\n                    v.push_back(v1);\\n                }\\n            }\\n            \\n        }\\n       return v; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        bool prime[n+1];\\n    memset(prime, true, sizeof(prime));\\n    for (int p=2; p*p<=n; p++)\\n    {\\n        if (prime[p] == true)\\n        {\\n            for (int i=p*2; i<=n; i += p)\\n                prime[i] = false;\\n        }\\n    }\\n    vector<vector<int>>v;\\n    vector<int>v1;\\n        int anothernum;\\n        for(int i=2;i<=n;i++){\\n            if(prime[i]==true){\\n                anothernum=n-i;\\n                if(anothernum>=i&&prime[anothernum]==true){\\n                    v1={i,anothernum};\\n                    v.push_back(v1);\\n                }\\n            }\\n            \\n        }\\n       return v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727716,
                "title": "masum-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int>data(n+1,1);\\n        data[0]=data[1]=0;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(data[i])\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    data[j]=0;\\n                }\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(data[i] && data[n-i])\\n            {\\n                ans.push_back({i,n-i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int>data(n+1,1);\\n        data[0]=data[1]=0;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(data[i])\\n            {\\n                for(int j=i*i;j<=n;j+=i)\\n                {\\n                    data[j]=0;\\n                }\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(data[i] && data[n-i])\\n            {\\n                ans.push_back({i,n-i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727658,
                "title": "prime-pairs-with-target-sum-python-sieve-of-eratosthenes-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Use Sieve of Eratosthenes to generate all prime no from 1 to n.\\n\\n2. Next, we initialize two pointers, i and j, at the beginning and end of the prime numbers list, respectively. We iterate until i is less than or equal to j. If the sum of the numbers at positions i and j is equal to n, we add the pair to the result list and move both pointers inward. If the sum is less than n, we increment i, and if the sum is greater than n, we decrement j. This approach allows us to find prime number pairs efficiently without checking unnecessary pairs.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*log(log(n))) + O(n) $$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n\\n        // Generating prime no \\n        // Sieve of Eratosthenes\\n\\n        prime=[0]*(n+1)\\n        for i in range(2,n+1):\\n            if prime[i]==0:\\n                j=i*i\\n                while(j<=n):\\n                    prime[j]=1 \\n                    j+=i\\n        p=[]\\n        for i in range(2,n+1):\\n            if prime[i]==0:\\n                p.append(i)\\n        \\n\\n        result=[]\\n\\n        i, j = 0, len(p) - 1\\n        while i <= j:\\n            if p[i] + p[j] == n:\\n                result.append([p[i], p[j]])\\n                i += 1\\n                j -= 1\\n            elif p[i] + p[j] < n:\\n                i += 1\\n            else:\\n                j -= 1\\n        \\n        return result\\n    \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n\\n        // Generating prime no \\n        // Sieve of Eratosthenes\\n\\n        prime=[0]*(n+1)\\n        for i in range(2,n+1):\\n            if prime[i]==0:\\n                j=i*i\\n                while(j<=n):\\n                    prime[j]=1 \\n                    j+=i\\n        p=[]\\n        for i in range(2,n+1):\\n            if prime[i]==0:\\n                p.append(i)\\n        \\n\\n        result=[]\\n\\n        i, j = 0, len(p) - 1\\n        while i <= j:\\n            if p[i] + p[j] == n:\\n                result.append([p[i], p[j]])\\n                i += 1\\n                j -= 1\\n            elif p[i] + p[j] < n:\\n                i += 1\\n            else:\\n                j -= 1\\n        \\n        return result\\n    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727101,
                "title": "simple-java-solution-using-sieveoferatosthenes-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n       List<List<Integer>> outerList = new ArrayList<>();\\n       List<Integer> primes = primesList(n);\\n       int len = primes.size();\\n       int i=0,j=len-1;\\n       while(i<=j) {\\n           List<Integer> innerList = new ArrayList<>();\\n           if(primes.get(i) + primes.get(j) == n) {\\n               innerList.add(primes.get(i));\\n               innerList.add(primes.get(j));\\n               outerList.add(innerList);\\n               i++;\\n               j--;\\n           } else if(primes.get(i) + primes.get(j) > n) j--;\\n           else i++;\\n       }\\n       return outerList;\\n    }\\n    public List<Integer> primesList(int n) {\\n        List<Integer> primeList = new ArrayList<>();\\n        boolean[] primes = new boolean[n+1];\\n        for(int i=0;i<n;i++) primes[i] = true;\\n        for(int i=2; i*i <= n; i++) {\\n            if(primes[i] == true) {\\n                for(int j=i*i;j<=n;j+=i) {\\n                    primes[j]=false;\\n                }\\n            }\\n        }\\n        for(int i=2;i<=n;i++) {\\n            if(primes[i] == true) {\\n                primeList.add(i);\\n            }\\n        }\\n        return primeList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n       List<List<Integer>> outerList = new ArrayList<>();\\n       List<Integer> primes = primesList(n);\\n       int len = primes.size();\\n       int i=0,j=len-1;\\n       while(i<=j) {\\n           List<Integer> innerList = new ArrayList<>();\\n           if(primes.get(i) + primes.get(j) == n) {\\n               innerList.add(primes.get(i));\\n               innerList.add(primes.get(j));\\n               outerList.add(innerList);\\n               i++;\\n               j--;\\n           } else if(primes.get(i) + primes.get(j) > n) j--;\\n           else i++;\\n       }\\n       return outerList;\\n    }\\n    public List<Integer> primesList(int n) {\\n        List<Integer> primeList = new ArrayList<>();\\n        boolean[] primes = new boolean[n+1];\\n        for(int i=0;i<n;i++) primes[i] = true;\\n        for(int i=2; i*i <= n; i++) {\\n            if(primes[i] == true) {\\n                for(int j=i*i;j<=n;j+=i) {\\n                    primes[j]=false;\\n                }\\n            }\\n        }\\n        for(int i=2;i<=n;i++) {\\n            if(primes[i] == true) {\\n                primeList.add(i);\\n            }\\n        }\\n        return primeList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726727,
                "title": "c-solution-easy-using-sieve-of-eratosthenes-91-faster",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> prime ;\\n    void allprime(int n) \\n    {\\n        this->prime[0] = this->prime[1] = false ;\\n        for(int i = 2 ; i*i < n+1 ; i++)\\n        {\\n            if(this->prime[i])\\n            {\\n                for(int j = i*i ; j < n+1 ; j += i)\\n                {\\n                    this->prime[j] = false ;\\n                }\\n            }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        this->prime.resize(n+1 , true) ;\\n        allprime(n) ;\\n        vector<vector<int>> res ;\\n        for(int i = 2 ; i <= n/2 ; i++ )\\n        {\\n            if(this->prime[i] && this->prime[n-i])\\n            {\\n                res.push_back({i , n-i}) ;\\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> prime ;\\n    void allprime(int n) \\n    {\\n        this->prime[0] = this->prime[1] = false ;\\n        for(int i = 2 ; i*i < n+1 ; i++)\\n        {\\n            if(this->prime[i])\\n            {\\n                for(int j = i*i ; j < n+1 ; j += i)\\n                {\\n                    this->prime[j] = false ;\\n                }\\n            }\\n        }\\n    }\\n    vector<vector<int>> findPrimePairs(int n) {\\n        this->prime.resize(n+1 , true) ;\\n        allprime(n) ;\\n        vector<vector<int>> res ;\\n        for(int i = 2 ; i <= n/2 ; i++ )\\n        {\\n            if(this->prime[i] && this->prime[n-i])\\n            {\\n                res.push_back({i , n-i}) ;\\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726490,
                "title": "sieve-and-check-two-sum-of-prime-c",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int> prime(n + 1, 1);\\n        vector<vector<int>> res;\\n\\n        for(int i = 2; i <= n; i++) \\n            if(prime[i]) \\n                for(int j = i * 2; j < n; j += i) \\n                    prime[j] = 0;\\n\\n        for(int i = 2; i <= n / 2; i++) {\\n            if(prime[i] && prime[n - i])\\n                res.push_back({i, n - i});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int> prime(n + 1, 1);\\n        vector<vector<int>> res;\\n\\n        for(int i = 2; i <= n; i++) \\n            if(prime[i]) \\n                for(int j = i * 2; j < n; j += i) \\n                    prime[j] = 0;\\n\\n        for(int i = 2; i <= n / 2; i++) {\\n            if(prime[i] && prime[n - i])\\n                res.push_back({i, n - i});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725871,
                "title": "simple-solution-using-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind primes till N using sieve of Eratosthenes and check i and n-i from 2 to n/2\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTC NloglogN\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<unsigned long> isPrime(n+1,0);\\n        for(int i=2;i<=n;i++){\\n            if(isPrime[i]==0){\\n                for(unsigned long j=(unsigned long)i*i;j<=n;j+=i){\\n                    isPrime[j]=1;\\n                }\\n            }\\n        }\\n        vector<vector<int>>v;\\n        for(int i=2;i<=n/2;i++){\\n            if(isPrime[i]==0 and isPrime[n-i]==0 ){\\n                v.push_back({i,n-i});\\n            }   \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<unsigned long> isPrime(n+1,0);\\n        for(int i=2;i<=n;i++){\\n            if(isPrime[i]==0){\\n                for(unsigned long j=(unsigned long)i*i;j<=n;j+=i){\\n                    isPrime[j]=1;\\n                }\\n            }\\n        }\\n        vector<vector<int>>v;\\n        for(int i=2;i<=n/2;i++){\\n            if(isPrime[i]==0 and isPrime[n-i]==0 ){\\n                v.push_back({i,n-i});\\n            }   \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724465,
                "title": "python-just-sieve-of-eratosthenes",
                "content": "```\\nclass Solution\\n    def findPrimePairs(self, n):\\n        # 1 <= n <= 10^6\\n        # sieve of erastos.\\n        nmin = max(n, 3)\\n        prime = [True] * (nmin + 1)\\n        prime[0] = prime[1] = False\\n\\n        if n <= 3:\\n            return []\\n\\n        i = 2\\n        while i * i <= n:\\n            if prime[i]:\\n                # update all the following numbers that have factor of i\\n                for j in range(i * i, n + 1, i):\\n                    prime[j] = False\\n            i += 1\\n\\n        ans = []\\n        for i in range(2, (n // 2) + 1):\\n            if prime[i] and prime[n - i]:\\n                ans.append([i, n - i])\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n    def findPrimePairs(self, n):\\n        # 1 <= n <= 10^6\\n        # sieve of erastos.\\n        nmin = max(n, 3)\\n        prime = [True] * (nmin + 1)\\n        prime[0] = prime[1] = False\\n\\n        if n <= 3:\\n            return []\\n\\n        i = 2\\n        while i * i <= n:\\n            if prime[i]:\\n                # update all the following numbers that have factor of i\\n                for j in range(i * i, n + 1, i):\\n                    prime[j] = False\\n            i += 1\\n\\n        ans = []\\n        for i in range(2, (n // 2) + 1):\\n            if prime[i] and prime[n - i]:\\n                ans.append([i, n - i])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723582,
                "title": "php-solution-in-3154ms",
                "content": "# Code\\n```\\nclass Solution {\\n    /**\\n     * @param Integer $n\\n     * @return Integer[][]\\n     */\\n    public function findPrimePairs($n) {\\n        $primes = [2];\\n        $is_primes = array_pad([false, false, true], $n + 1, true);\\n        for ($i=4; $i<=$n; $i+=2) {\\n            $is_primes[$i] = false;\\n        }\\n        for ($i=3; $i<=$n; $i+=2) {\\n            if ($is_primes[$i]) {\\n                $primes[] = $i;\\n                for ($j=$i*$i; $j<=$n; $j+=$i) {\\n                    $is_primes[$j] = false;\\n                }\\n            }\\n        }        \\n        \\n        $output = [];\\n        foreach ($primes as $x) {\\n            $y = $n - $x;\\n            if ($x > $y) {\\n                break;\\n            }\\n            if ($is_primes[$y]) {\\n                $output[] = [$x, $y];\\n            }\\n        }\\n        return $output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * @param Integer $n\\n     * @return Integer[][]\\n     */\\n    public function findPrimePairs($n) {\\n        $primes = [2];\\n        $is_primes = array_pad([false, false, true], $n + 1, true);\\n        for ($i=4; $i<=$n; $i+=2) {\\n            $is_primes[$i] = false;\\n        }\\n        for ($i=3; $i<=$n; $i+=2) {\\n            if ($is_primes[$i]) {\\n                $primes[] = $i;\\n                for ($j=$i*$i; $j<=$n; $j+=$i) {\\n                    $is_primes[$j] = false;\\n                }\\n            }\\n        }        \\n        \\n        $output = [];\\n        foreach ($primes as $x) {\\n            $y = $n - $x;\\n            if ($x > $y) {\\n                break;\\n            }\\n            if ($is_primes[$y]) {\\n                $output[] = [$x, $y];\\n            }\\n        }\\n        return $output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723576,
                "title": "sieve-of-eratosthenes-and-two-sum",
                "content": "# Complexity\\n- Time complexity: O(nloglogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n\\n        primeList = [1]*(n+1)\\n        p = 2\\n        result = list()\\n\\n        while (p*p <= n):\\n            if primeList[p]:\\n                for i in range(p*p, n+1, p):\\n                    primeList[i] = 0\\n            p += 1\\n\\n        for i in range(2, (n//2+1)):\\n            if primeList[i] and primeList[n-i]:\\n                result.append([i, n-i])\\n                \\n        return result\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n\\n        primeList = [1]*(n+1)\\n        p = 2\\n        result = list()\\n\\n        while (p*p <= n):\\n            if primeList[p]:\\n                for i in range(p*p, n+1, p):\\n                    primeList[i] = 0\\n            p += 1\\n\\n        for i in range(2, (n//2+1)):\\n            if primeList[i] and primeList[n-i]:\\n                result.append([i, n-i])\\n                \\n        return result\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723370,
                "title": "sieve-and-brute-checking",
                "content": "\\n# Code\\n```\\ndef findPrimePairs(self, n: int) -> List[List[int]]:\\n    def sieve(n):\\n        isPrime = [True] * n\\n        for x in range(2, int(sqrt(n))+1):\\n            if isPrime[x]:\\n                for y in range(x*2, n, x):\\n                    isPrime[y] = False\\n        return isPrime\\n    isPrime = sieve(n)\\n    ret = []\\n    for x in range(2, n//2+1):\\n        if isPrime[x] and isPrime[n-x]:\\n            ret.append((x, n-x))\\n    return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findPrimePairs(self, n: int) -> List[List[int]]:\\n    def sieve(n):\\n        isPrime = [True] * n\\n        for x in range(2, int(sqrt(n))+1):\\n            if isPrime[x]:\\n                for y in range(x*2, n, x):\\n                    isPrime[y] = False\\n        return isPrime\\n    isPrime = sieve(n)\\n    ret = []\\n    for x in range(2, n//2+1):\\n        if isPrime[x] and isPrime[n-x]:\\n            ret.append((x, n-x))\\n    return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3723324,
                "title": "c-sieve-approach-optimized-for-time-and-space",
                "content": "# Intuition\\n\\nSieve of Eratosthenes approach with a few optimizations to minimize time and memory usage:\\n\\n* If n is odd, the only possible sum is 2 + (n-2), so just check if (n-2) is prime in this case\\n* For the sieve of Eratosthenes, cut the size and time down by half by only representing odd numbers\\n* Use a `vector<bool>` for the sieve, which is optimized in C++ to only use 1 bit per entry (about 8x memory savings)\\n* Use `emplace_back` to add each pair to the results vector\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log\\\\log n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <vector>\\n#include <cmath>\\n\\nbool is_prime(int p) {\\n    // assume: p is odd and >=3\\n    int ulim = int(std::sqrt(p)); // ensures d**2 <= p\\n    for (int d = 3; d <= ulim; d += 2) {\\n        if (p % d == 0) return false;\\n    }\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        std::vector<std::vector<int>> result;\\n        // special cases to handle any results with 2\\n        if (n <= 4) {\\n            if (n == 4) result.emplace_back(std::vector<int>{2, 2});\\n        }\\n        else if (n % 2 == 1) {\\n            if (is_prime(n-2)) result.emplace_back(std::vector<int>{2, n-2});\\n        }\\n        else {\\n            // n is even and >= 6, so can only be sum of 2 odd primes\\n            // use \"sieve of Eratosthenes\" to compute all primes up to n-3\\n            // sieve[i] == 2*i+3 is composite\\n            // p is composite == sieve[(p-3)/2]\\n            int ssize = (n-4) / 2;\\n            vector<bool> sieve(ssize);\\n            int ulim = int((std::sqrt(n-3) - 3) / 2); // ensures (2i+3)**2 <= n-3\\n            for (int i=0, start=3, skip=3; i <= ulim; ++i, start += 3, skip += 2) {\\n                if (!sieve[i]) {\\n                    // start=2i+3 and skip=3i+3, so (2i+3)*(2k+3) = 2*(start + skip*k) + 3, for k=0,1,2,...\\n                    for (int j = start; j < ssize; j += skip)  sieve[j] = true;\\n                }\\n            }\\n            for (int i = 0, j = ssize - 1, p1 = 3, p2 = n - 3;\\n                    p1 <= p2;\\n                    ++i, --j, p1 += 2, p2 -= 2)\\n            {\\n                if (!sieve[i] && !sieve[j]) result.emplace_back(std::vector<int>{p1, p2});\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <cmath>\\n\\nbool is_prime(int p) {\\n    // assume: p is odd and >=3\\n    int ulim = int(std::sqrt(p)); // ensures d**2 <= p\\n    for (int d = 3; d <= ulim; d += 2) {\\n        if (p % d == 0) return false;\\n    }\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        std::vector<std::vector<int>> result;\\n        // special cases to handle any results with 2\\n        if (n <= 4) {\\n            if (n == 4) result.emplace_back(std::vector<int>{2, 2});\\n        }\\n        else if (n % 2 == 1) {\\n            if (is_prime(n-2)) result.emplace_back(std::vector<int>{2, n-2});\\n        }\\n        else {\\n            // n is even and >= 6, so can only be sum of 2 odd primes\\n            // use \"sieve of Eratosthenes\" to compute all primes up to n-3\\n            // sieve[i] == 2*i+3 is composite\\n            // p is composite == sieve[(p-3)/2]\\n            int ssize = (n-4) / 2;\\n            vector<bool> sieve(ssize);\\n            int ulim = int((std::sqrt(n-3) - 3) / 2); // ensures (2i+3)**2 <= n-3\\n            for (int i=0, start=3, skip=3; i <= ulim; ++i, start += 3, skip += 2) {\\n                if (!sieve[i]) {\\n                    // start=2i+3 and skip=3i+3, so (2i+3)*(2k+3) = 2*(start + skip*k) + 3, for k=0,1,2,...\\n                    for (int j = start; j < ssize; j += skip)  sieve[j] = true;\\n                }\\n            }\\n            for (int i = 0, j = ssize - 1, p1 = 3, p2 = n - 3;\\n                    p1 <= p2;\\n                    ++i, --j, p1 += 2, p2 -= 2)\\n            {\\n                if (!sieve[i] && !sieve[j]) result.emplace_back(std::vector<int>{p1, p2});\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3723241,
                "title": "c-sieve",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> isPrime(n + 1, true);\\n        isPrime[0] = isPrime[1] = false;\\n        int m = sqrt(n);\\n        for(int i = 2; i <= m; i++) {\\n            if(isPrime[i]) {\\n                for(int j = i + i; j <= n; j += i) {\\n                    isPrime[j] = false;\\n                }\\n            }   \\n        }\\n        m = n / 2;\\n        vector<vector<int>> ans;\\n        for(int i = 2; i <= m; i++) {\\n            if(isPrime[i] && isPrime[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> isPrime(n + 1, true);\\n        isPrime[0] = isPrime[1] = false;\\n        int m = sqrt(n);\\n        for(int i = 2; i <= m; i++) {\\n            if(isPrime[i]) {\\n                for(int j = i + i; j <= n; j += i) {\\n                    isPrime[j] = false;\\n                }\\n            }   \\n        }\\n        m = n / 2;\\n        vector<vector<int>> ans;\\n        for(int i = 2; i <= m; i++) {\\n            if(isPrime[i] && isPrime[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722910,
                "title": "c-solution-sieve-of-eratosthenes",
                "content": "```\\nclass Solution {\\npublic:\\n    set<int> primes;\\n    void prime(int limit) {\\n  vector<bool> isPrime(limit + 1, true);\\n  isPrime[0] = false;\\n  isPrime[1] = false;\\n  for (int p = 2; p * p <= limit; ++p) {\\n    if (isPrime[p]) {\\n      for (int i = p * p; i <= limit; i += p) {\\n        isPrime[i] = false;\\n      }\\n    }\\n  }\\n    for (int p = 2; p <= limit; ++p) {\\n    if (isPrime[p]) {\\n      primes.insert(p);\\n    }\\n  }\\n}\\n    vector<vector<int>> findPrimePairs(int n) {\\n        prime(n);\\n        vector<vector<int>> ans;\\n        for(auto &x:primes)\\n        {\\n            int tar=n-x;\\n            if(tar>=2)\\n            if(primes.find(tar)!=primes.end()){\\n                ans.push_back({x,tar});\\n                // primes.erase(x);\\n                primes.erase(tar);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> primes;\\n    void prime(int limit) {\\n  vector<bool> isPrime(limit + 1, true);\\n  isPrime[0] = false;\\n  isPrime[1] = false;\\n  for (int p = 2; p * p <= limit; ++p) {\\n    if (isPrime[p]) {\\n      for (int i = p * p; i <= limit; i += p) {\\n        isPrime[i] = false;\\n      }\\n    }\\n  }\\n    for (int p = 2; p <= limit; ++p) {\\n    if (isPrime[p]) {\\n      primes.insert(p);\\n    }\\n  }\\n}\\n    vector<vector<int>> findPrimePairs(int n) {\\n        prime(n);\\n        vector<vector<int>> ans;\\n        for(auto &x:primes)\\n        {\\n            int tar=n-x;\\n            if(tar>=2)\\n            if(primes.find(tar)!=primes.end()){\\n                ans.push_back({x,tar});\\n                // primes.erase(x);\\n                primes.erase(tar);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722724,
                "title": "c-sieve-of-eratosthenes",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> m = vector<bool>(n+1,true);\\n        for (int i=2;i<=n;i++){\\n            if (m[i])\\n            {\\n                for (int j=i+i;j<=n;j+=i){\\n                    m[j]=false;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for (int i=2;i<=n-i;i++){\\n            if (m[i] && m[n-i]) ans.push_back({i,n-i});\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> m = vector<bool>(n+1,true);\\n        for (int i=2;i<=n;i++){\\n            if (m[i])\\n            {\\n                for (int j=i+i;j<=n;j+=i){\\n                    m[j]=false;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for (int i=2;i<=n-i;i++){\\n            if (m[i] && m[n-i]) ans.push_back({i,n-i});\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720979,
                "title": "c-prime-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBuild a prime table\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> prime(n + 1, 1);\\n        prime[1] = false;\\n        for (int i = 2; i <= n; i++) {\\n            if (prime[i]) {\\n                for (ll j = (ll) i * (ll) i; j <= n; j+=i) {\\n                    prime[j] = false;\\n                }   \\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (prime[i] && prime[n - i]) {\\n                ans.emplace_back(vector<int>{i, n - i});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> prime(n + 1, 1);\\n        prime[1] = false;\\n        for (int i = 2; i <= n; i++) {\\n            if (prime[i]) {\\n                for (ll j = (ll) i * (ll) i; j <= n; j+=i) {\\n                    prime[j] = false;\\n                }   \\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (prime[i] && prime[n - i]) {\\n                ans.emplace_back(vector<int>{i, n - i});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719075,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int> primes(n+1, 1);\\n        primes[0] = primes[1] = 0;\\n        \\n        for (int i = 2; i * i <= n; i++) {\\n            if (primes[i] == 1) {\\n                for (int j = i * i; j <= n; j += i) {\\n                    primes[j] = 0;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for (int i = 2; i <= n / 2; i++) {\\n            if (primes[i] && primes[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<int> primes(n+1, 1);\\n        primes[0] = primes[1] = 0;\\n        \\n        for (int i = 2; i * i <= n; i++) {\\n            if (primes[i] == 1) {\\n                for (int j = i * i; j <= n; j += i) {\\n                    primes[j] = 0;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for (int i = 2; i <= n / 2; i++) {\\n            if (primes[i] && primes[n - i]) {\\n                ans.push_back({i, n - i});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718012,
                "title": "very-easy-sieve-of-eratosthenes-two-sum-c",
                "content": "# Intuition and Approach\\n- Use Sieve Of Eratosthenes to generate arrays of prime number up till n.\\n- Generate Result pair using two sum. \\n\\n# Complexity\\n- Time complexity:\\nTwo Sum - O(n)\\n\\n- Space complexity:\\nSieve Of Eratosthenes - O(n) for storing prime number\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> SieveOfEratosthenes(int n) {\\n        vector<bool> prime(n + 1, true);\\n        prime[0] = prime[1] = false;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    prime[i] = false;\\n                }\\n            }\\n        }\\n        return prime;\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> prime = SieveOfEratosthenes(n);\\n        vector<vector<int>> result;\\n\\n        // two sum\\n        for (int x = 2; x <= n - x; x++) {\\n            int y = n - x;\\n            if (prime[x] && prime[y]) {\\n                result.push_back({x, y});\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> SieveOfEratosthenes(int n) {\\n        vector<bool> prime(n + 1, true);\\n        prime[0] = prime[1] = false;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    prime[i] = false;\\n                }\\n            }\\n        }\\n        return prime;\\n    }\\n\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> prime = SieveOfEratosthenes(n);\\n        vector<vector<int>> result;\\n\\n        // two sum\\n        for (int x = 2; x <= n - x; x++) {\\n            int y = n - x;\\n            if (prime[x] && prime[y]) {\\n                result.push_back({x, y});\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717489,
                "title": "java-98-faster-time-complexity-o-n-log-log-n-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst find the prime number form range **2 to n** by using Sieve of Eratosthenes and then find the pair for that.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the all the prime number form **2 to n** and insert it to the array of boolean and then find the **pair so that the sum of that pair is equal to n** and one condition is that both the element must be prime.\\n\\n# Complexity\\n- Time complexity: **O(n log log n)** because of Sieve of Eratosthenes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[]a=new boolean[n+1];\\n        a[0]=a[1]=false;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                for(int j=i*i;j<n;j+=i)\\n                    a[j]=true;\\n            }\\n        }\\n        List<List<Integer>>ans=new ArrayList<List<Integer>>();\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(a[i]==false && a[n-i]==false)\\n            {\\n                List<Integer>k=new ArrayList<>();\\n                k.add(i);\\n                k.add(n-i);\\n                ans.add(k);\\n            }\\n                \\n        }\\n        return ans;\\n    }\\n}\\nfeel free to ask your doubt happy to help..\\nIf it help then plz upvote it....Thanks!!!!\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        boolean[]a=new boolean[n+1];\\n        a[0]=a[1]=false;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                for(int j=i*i;j<n;j+=i)\\n                    a[j]=true;\\n            }\\n        }\\n        List<List<Integer>>ans=new ArrayList<List<Integer>>();\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(a[i]==false && a[n-i]==false)\\n            {\\n                List<Integer>k=new ArrayList<>();\\n                k.add(i);\\n                k.add(n-i);\\n                ans.add(k);\\n            }\\n                \\n        }\\n        return ans;\\n    }\\n}\\nfeel free to ask your doubt happy to help..\\nIf it help then plz upvote it....Thanks!!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717456,
                "title": "c-85-faster-time-complexity-o-n-log-log-n-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst find the prime number form range **2 to n** by using **Sieve of Eratosthenes** and then find the pair for that.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the all the prime number form **2 to n** and insert it to the array of boolean and then find the **pair so that the sum of that pair is equal to n** and one condition is that both the element must be prime.\\n\\n# Complexity\\n- Time complexity: **O(n log log n)** because of Sieve of Eratosthenes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool>a(n+1,true);\\n        a[0]=a[1]=false;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(a[i])\\n            for(int j=i*i;j<n;j+=i)\\n                a[j]=false;\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(a[i]==true && a[n-i]==true)\\n            {\\n                vector<int>a;\\n                a.emplace_back(i);\\n                a.emplace_back(n-i);\\n                ans.emplace_back(a);\\n            }\\n                \\n        }\\n        return ans;\\n    }\\n};\\nfeel free to ask your doubt happy to help.....\\nIf it help then plz upvote it.....Thanks!!!!\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool>a(n+1,true);\\n        a[0]=a[1]=false;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(a[i])\\n            for(int j=i*i;j<n;j+=i)\\n                a[j]=false;\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(a[i]==true && a[n-i]==true)\\n            {\\n                vector<int>a;\\n                a.emplace_back(i);\\n                a.emplace_back(n-i);\\n                ans.emplace_back(a);\\n            }\\n                \\n        }\\n        return ans;\\n    }\\n};\\nfeel free to ask your doubt happy to help.....\\nIf it help then plz upvote it.....Thanks!!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716264,
                "title": "simple-sol-using-the-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst Apply brute force, ull get a TLE. Now try optimizing wherever possible. In this case, finding if \\'i\\' is prime can be optimized.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSieve of Erasthones to find primes between 2 and n/2. (1 is not a prime Number AND, after n/2 the pairs of numbers get repeated(in the reverse order).)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log(log sqrt(n)))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ret;\\n\\n        vector<bool> is_prime(n+1, true);\\n        is_prime[0] = is_prime[1] = false;\\n        for (int i = 2; i * i <= n; i++) {\\n            if (is_prime[i]) {\\n                for (int j = i * i; j <= n; j += i)\\n                    is_prime[j] = false;\\n            }\\n        }\\n        \\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(is_prime[i]&&is_prime[n-i])\\n                ret.push_back({i,n-i});\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<vector<int>> ret;\\n\\n        vector<bool> is_prime(n+1, true);\\n        is_prime[0] = is_prime[1] = false;\\n        for (int i = 2; i * i <= n; i++) {\\n            if (is_prime[i]) {\\n                for (int j = i * i; j <= n; j += i)\\n                    is_prime[j] = false;\\n            }\\n        }\\n        \\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(is_prime[i]&&is_prime[n-i])\\n                ret.push_back({i,n-i});\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716092,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstoring primes in a vector in sorted order and then applying two pointer to get answer .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nINTUTion\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> isPrime(n + 1, true);\\n        vector<int> primes;\\n        vector<vector<int>> ans;\\n\\n        // Sieve of Eratosthenes to find prime numbers\\n        for (int p = 2; p * p <= n; p++) {\\n            if (isPrime[p]) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    isPrime[i] = false;\\n                }\\n            }\\n        }\\n\\n        // Collect prime numbers in the primes vector\\n        for (int p = 2; p <= n; p++) {\\n            if (isPrime[p]) {\\n                primes.push_back(p);\\n            }\\n        }\\n\\n        int i = 0, j = primes.size() - 1;\\n\\n        // Find pairs of primes that add up to n\\n        while (i <= j) {\\n            if (primes[i] + primes[j] == n) {\\n                ans.push_back({primes[i], primes[j]});\\n                i++;\\n            } else if (primes[i] + primes[j] < n) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findPrimePairs(int n) {\\n        vector<bool> isPrime(n + 1, true);\\n        vector<int> primes;\\n        vector<vector<int>> ans;\\n\\n        // Sieve of Eratosthenes to find prime numbers\\n        for (int p = 2; p * p <= n; p++) {\\n            if (isPrime[p]) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    isPrime[i] = false;\\n                }\\n            }\\n        }\\n\\n        // Collect prime numbers in the primes vector\\n        for (int p = 2; p <= n; p++) {\\n            if (isPrime[p]) {\\n                primes.push_back(p);\\n            }\\n        }\\n\\n        int i = 0, j = primes.size() - 1;\\n\\n        // Find pairs of primes that add up to n\\n        while (i <= j) {\\n            if (primes[i] + primes[j] == n) {\\n                ans.push_back({primes[i], primes[j]});\\n                i++;\\n            } else if (primes[i] + primes[j] < n) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714895,
                "title": "97-faster-solution-easy-to-understand",
                "content": "![image.png](https://assets.leetcode.com/users/images/20eef6a8-25cb-46e5-977b-c75da482069d_1688429403.376569.png)\\n\\n# Explanation\\n- first we need to find all the primes, then we loop through these primes, get `n-i` prime elements, and if our small prime number is greater than `n//2`, we break this loop to not get elements again\\n# Code\\n```\\nprimes = []\\nprime = [False, False] + [True for i in range(10**6-2)]\\nfor i in range(2, 10**6):\\n    if prime[i]:\\n        primes.append(i)\\n        j = 2*i\\n        while j<10**6:\\n            prime[j]=False\\n            j+=i\\n\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        ans = []\\n        for i in primes:\\n            if i>n//2: break\\n            if prime[n-i]: ans.append([i, n-i])\\n\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nprimes = []\\nprime = [False, False] + [True for i in range(10**6-2)]\\nfor i in range(2, 10**6):\\n    if prime[i]:\\n        primes.append(i)\\n        j = 2*i\\n        while j<10**6:\\n            prime[j]=False\\n            j+=i\\n\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        ans = []\\n        for i in primes:\\n            if i>n//2: break\\n            if prime[n-i]: ans.append([i, n-i])\\n\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714551,
                "title": "sieve-two-sum-simple-solution-for-beginners",
                "content": "# Intuition\\nJust Pre compute the primes till n and after that simple two sum !\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    void Sieve(int n)\\n    {\\n    \\n    bool prime[n + 1];\\n    memset(prime, true, sizeof(prime));\\n  \\n    for (int p = 2; p * p <= n; p++) \\n    {\\n        if (prime[p] == true) \\n        {\\n            \\n            for (int i = p * p; i <= n; i += p)\\n                prime[i] = false;\\n        }\\n    }\\n    for (int p = 2; p <= n; p++)\\n        if (prime[p])\\n            primes.push_back(p);\\n    }\\n    vector<vector<int>> findPrimePairs(int n) \\n    {\\n        Sieve(n);\\n        vector<vector<int>> ans;\\n        int i=0;\\n        int j=primes.size()-1;\\n        while(i<=j)\\n        {\\n            if(primes[i]+primes[j]==n)\\n            {\\n                ans.push_back({primes[i],primes[j]});\\n                i++;\\n                j--;\\n            }\\n            else if(primes[i]+primes[j]<n)\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    void Sieve(int n)\\n    {\\n    \\n    bool prime[n + 1];\\n    memset(prime, true, sizeof(prime));\\n  \\n    for (int p = 2; p * p <= n; p++) \\n    {\\n        if (prime[p] == true) \\n        {\\n            \\n            for (int i = p * p; i <= n; i += p)\\n                prime[i] = false;\\n        }\\n    }\\n    for (int p = 2; p <= n; p++)\\n        if (prime[p])\\n            primes.push_back(p);\\n    }\\n    vector<vector<int>> findPrimePairs(int n) \\n    {\\n        Sieve(n);\\n        vector<vector<int>> ans;\\n        int i=0;\\n        int j=primes.size()-1;\\n        while(i<=j)\\n        {\\n            if(primes[i]+primes[j]==n)\\n            {\\n                ans.push_back({primes[i],primes[j]});\\n                i++;\\n                j--;\\n            }\\n            else if(primes[i]+primes[j]<n)\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714402,
                "title": "java-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        \\n        if (n<=3)\\n                return res;\\n        \\n\\n        //Sieve of Eratosthenes\\n        List<Integer> primes=new ArrayList<>();\\n        boolean[] arr=new boolean[n+1];\\n        Arrays.fill(arr,true);\\n\\n        for (int i=2;i*i<n;i++)\\n        {\\n            if (arr[i])\\n                for (int j=2*i;j<n;j+=i)\\n                    arr[j]=false;\\n        }\\n\\n        for (int i=2;i<=n;i++)\\n            if (arr[i])\\n                primes.add(i);\\n        \\n        int left=0;\\n        int right=primes.size()-1;\\n        while (left<=right)\\n        {\\n            int sum=primes.get(left)+primes.get(right);\\n            if (sum<n)\\n                left++;\\n            else if (sum>n)\\n                right--;\\n            else\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                temp.add(primes.get(left));\\n                temp.add(primes.get(right));\\n                res.add(temp);\\n                left++;\\n                right--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        \\n        if (n<=3)\\n                return res;\\n        \\n\\n        //Sieve of Eratosthenes\\n        List<Integer> primes=new ArrayList<>();\\n        boolean[] arr=new boolean[n+1];\\n        Arrays.fill(arr,true);\\n\\n        for (int i=2;i*i<n;i++)\\n        {\\n            if (arr[i])\\n                for (int j=2*i;j<n;j+=i)\\n                    arr[j]=false;\\n        }\\n\\n        for (int i=2;i<=n;i++)\\n            if (arr[i])\\n                primes.add(i);\\n        \\n        int left=0;\\n        int right=primes.size()-1;\\n        while (left<=right)\\n        {\\n            int sum=primes.get(left)+primes.get(right);\\n            if (sum<n)\\n                left++;\\n            else if (sum>n)\\n                right--;\\n            else\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                temp.add(primes.get(left));\\n                temp.add(primes.get(right));\\n                res.add(temp);\\n                left++;\\n                right--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714264,
                "title": "100-fast",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/c2d82df8-f228-4c28-89ec-fa041f4416b5_1688409479.3033423.png)\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    n = 10**6 + 1 \\n    \\n    flag = [True] * n\\n    flag[1], flag[0] = False, False\\n    prime = {}\\n\\n    for x in range(2, n):\\n        if flag[x]:\\n            prime[x] = 1\\n            k = 3 if x != 2 else 2\\n            for i in range(k * x, n, (k-1)*x):\\n                flag[i] = False\\n    \\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        res = []\\n        for x in self.prime:\\n            k = n - x\\n            if x > k:\\n                break\\n            if k in self.prime:\\n                res.append([x,k])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    n = 10**6 + 1 \\n    \\n    flag = [True] * n\\n    flag[1], flag[0] = False, False\\n    prime = {}\\n\\n    for x in range(2, n):\\n        if flag[x]:\\n            prime[x] = 1\\n            k = 3 if x != 2 else 2\\n            for i in range(k * x, n, (k-1)*x):\\n                flag[i] = False\\n    \\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        res = []\\n        for x in self.prime:\\n            k = n - x\\n            if x > k:\\n                break\\n            if k in self.prime:\\n                res.append([x,k])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713798,
                "title": "java-clean-code",
                "content": "# Intuition\\nUsing Sieve of Eratosthenes , Get the list of all the prime number \\nin an array. Using two pointer approach get the list of pair of (x,y)\\nof prime number which satisfy the conditions.\\n\\n# Approach\\n1> Use Sieve of Eratosthenes , to get the list of all the prime number less than n and now use the two pointer approach and get \\nthe required pairs\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)*Log(Log(N)) => finding prime numbers\\n+\\nO(N) finding pairs\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)+O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    List<Integer> list;\\n      void sieveOfEratosthenes(int n)\\n    {\\n      \\n        boolean prime[] = new boolean[n + 1];\\n        for (int i = 0; i <= n; i++)\\n            prime[i] = true;\\n  \\n        for (int p = 2; p * p <= n; p++) {\\n            // If prime[p] is not changed, then it is a\\n            // prime\\n            if (prime[p] == true) {\\n                // Update all multiples of p greater than or\\n                // equal to the square of it numbers which\\n                // are multiple of p and are less than p^2\\n                // are already been marked.\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n  \\n        // Print all prime numbers\\n        list = new ArrayList();\\n\\n        for (int i = 2; i <= n; i++) {\\n            if (prime[i] == true)\\n               list.add(i);\\n        }\\n    }\\n   \\n    public List<List<Integer>> findPrimePairs(int n) {\\n        sieveOfEratosthenes(n);\\n\\n        //System.out.println(list);\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        int start =0,end=list.size()-1;\\n        while(start<=end){\\n\\n            if(list.get(start)+list.get(end)==n){\\n                List<Integer> temp = new ArrayList<>();\\n                temp.add(list.get(start));\\n                temp.add(list.get(end));\\n                res.add(temp);\\n                start++;\\n            }else if(list.get(start)+list.get(end)<n){\\n                start++;\\n            }else{\\n                end--;\\n            }\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> list;\\n      void sieveOfEratosthenes(int n)\\n    {\\n      \\n        boolean prime[] = new boolean[n + 1];\\n        for (int i = 0; i <= n; i++)\\n            prime[i] = true;\\n  \\n        for (int p = 2; p * p <= n; p++) {\\n            // If prime[p] is not changed, then it is a\\n            // prime\\n            if (prime[p] == true) {\\n                // Update all multiples of p greater than or\\n                // equal to the square of it numbers which\\n                // are multiple of p and are less than p^2\\n                // are already been marked.\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n  \\n        // Print all prime numbers\\n        list = new ArrayList();\\n\\n        for (int i = 2; i <= n; i++) {\\n            if (prime[i] == true)\\n               list.add(i);\\n        }\\n    }\\n   \\n    public List<List<Integer>> findPrimePairs(int n) {\\n        sieveOfEratosthenes(n);\\n\\n        //System.out.println(list);\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        int start =0,end=list.size()-1;\\n        while(start<=end){\\n\\n            if(list.get(start)+list.get(end)==n){\\n                List<Integer> temp = new ArrayList<>();\\n                temp.add(list.get(start));\\n                temp.add(list.get(end));\\n                res.add(temp);\\n                start++;\\n            }else if(list.get(start)+list.get(end)<n){\\n                start++;\\n            }else{\\n                end--;\\n            }\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713789,
                "title": "prime-sieve-java-simple-solution-clean-code",
                "content": "# Complexity\\nlet $max = 10^6$\\nlet $k$ be number of prime numbers less than $max$\\n- Time complexity: $O(max \\\\cdot \\\\log(\\\\log(max)))$ for preprocessing then $O(k)$ for each $n$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(max)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    static Set<Integer> st;\\n    static{\\n        st = new LinkedHashSet<>();\\n        int n = (int)1e6;\\n        boolean isPrime[] = new boolean[n + 1];\\n        Arrays.fill(isPrime,true);\\n        isPrime[0] = isPrime[1] = false;\\n        for(long i = 2;i <= n;i++){\\n            if(isPrime[(int)i]){\\n                for(long j = i * i ;j <= n;j += i){\\n                    isPrime[(int)j] = false;\\n                }\\n                st.add((int)i);\\n            }\\n        }\\n    }\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(var e:st){\\n            if(st.contains(n - e) && e <= n - e){\\n                ans.add(Arrays.asList(e,n - e));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    static Set<Integer> st;\\n    static{\\n        st = new LinkedHashSet<>();\\n        int n = (int)1e6;\\n        boolean isPrime[] = new boolean[n + 1];\\n        Arrays.fill(isPrime,true);\\n        isPrime[0] = isPrime[1] = false;\\n        for(long i = 2;i <= n;i++){\\n            if(isPrime[(int)i]){\\n                for(long j = i * i ;j <= n;j += i){\\n                    isPrime[(int)j] = false;\\n                }\\n                st.add((int)i);\\n            }\\n        }\\n    }\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(var e:st){\\n            if(st.contains(n - e) && e <= n - e){\\n                ans.add(Arrays.asList(e,n - e));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713585,
                "title": "javascript-sieve-of-eratosthenes",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar findPrimePairs = function(n) {\\n    let p = getPrimesBySieveOfEratosthenes(n)\\n    let r = [];\\n\\n    for (let i=1; i <= n/2; i++)      \\n        if (p[i] && p[n-i]) r.push([i, n-i])\\n\\n    return r\\n};\\n\\n\\nvar getPrimesBySieveOfEratosthenes = function(n) {\\n    let p = new Array(n).fill(true);\\n    p[0] = p[1] = false;\\n\\n    for (let i = 2; i * i<= n; i++) {\\n        if (p[i]) \\n            for (let j = i * i; j < n; j += i)\\n                p[j] = false      \\n    }\\n\\n    return p\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar findPrimePairs = function(n) {\\n    let p = getPrimesBySieveOfEratosthenes(n)\\n    let r = [];\\n\\n    for (let i=1; i <= n/2; i++)      \\n        if (p[i] && p[n-i]) r.push([i, n-i])\\n\\n    return r\\n};\\n\\n\\nvar getPrimesBySieveOfEratosthenes = function(n) {\\n    let p = new Array(n).fill(true);\\n    p[0] = p[1] = false;\\n\\n    for (let i = 2; i * i<= n; i++) {\\n        if (p[i]) \\n            for (let j = i * i; j < n; j += i)\\n                p[j] = false      \\n    }\\n\\n    return p\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713547,
                "title": "python3-sieve-of-eratosthenes",
                "content": "# Intuition\\nWe prepare all primes by algorithm Sieve of Eratosthenes.\\nNumber `x` is prime when `prime[x]` is `1`. \\n\\n# Code\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        answ=[]\\n        prime=[0,0]+[1]*n\\n        sqrtn=int(sqrt(n))\\n        for i in range(2,sqrtn+1):\\n            if prime[i]:\\n                for j in range(i+i,n+1,i):\\n                    prime[j]=0\\n        for i in range(2,n//2+1):\\n            if prime[i] and prime[n-i]:\\n                answ.append([i,n-i])\\n        return answ   \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        answ=[]\\n        prime=[0,0]+[1]*n\\n        sqrtn=int(sqrt(n))\\n        for i in range(2,sqrtn+1):\\n            if prime[i]:\\n                for j in range(i+i,n+1,i):\\n                    prime[j]=0\\n        for i in range(2,n//2+1):\\n            if prime[i] and prime[n-i]:\\n                answ.append([i,n-i])\\n        return answ   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713513,
                "title": "python-sieve-of-eratosthenes-o-n-log-log-n",
                "content": "1. Use the sieve of Eratosthenes to find all primes.\\n2. Check from `2` to `n//2`, if both `i` and `n-i` are primes, append the pair to `ans`.\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        comp = [False]*n\\n        for i in range(2, n):\\n            if not comp[i]:\\n                for x in range(i*i, n, i):\\n                    comp[x] = True\\n        \\n        ans = []\\n        for i in range(2, n//2 + 1):\\n            if not comp[i] and not comp[n-i]:\\n                ans.append([i, n-i])\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Use the sieve of Eratosthenes to find all primes.\\n2. Check from `2` to `n//2`, if both `i` and `n-i` are primes, append the pair to `ans`.\\n```\\nclass Solution:\\n    def findPrimePairs(self, n: int) -> List[List[int]]:\\n        comp = [False]*n\\n        for i in range(2, n):\\n            if not comp[i]:\\n                for x in range(i*i, n, i):\\n                    comp[x] = True\\n        \\n        ans = []\\n        for i in range(2, n//2 + 1):\\n            if not comp[i] and not comp[n-i]:\\n                ans.append([i, n-i])\\n        return ans",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1952870,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1952667,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1952653,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1958118,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1953754,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1953040,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 2032951,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1955085,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1954800,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1954780,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1952870,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1952667,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1952653,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1958118,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1953754,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1953040,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 2032951,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1955085,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1954800,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            },
            {
                "id": 1954780,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Got a TLE in contest :\\') "
                    },
                    {
                        "username": "AlexShch",
                        "content": "You hate python, is that it?"
                    },
                    {
                        "username": "faiq--",
                        "content": "[@AshishLearning](/AshishLearning) alex bhai ko pani pilao"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "are bhai inta gussa"
                    },
                    {
                        "username": "jithu7432",
                        "content": "O(N) [solution](https://leetcode.com/problems/prime-pairs-with-target-sum/solutions/3706592/a-sieve-of-eratosthenes-solution-that-barely-went-in-during-the-contest-giving-tle-now/) is TLE ing, can anyone shed some light?  Thanks!"
                    },
                    {
                        "username": "linded",
                        "content": "  The problem description contains a contradiction.  If x and y must be prime numbers, then x and y must be greater than 1 NOT greater than or equal to 1 which also limits the upper bound  of  y.  I believe the range would be more accurately specified as \\n           1 <  x  <=  y  <  (n - 2)"
                    },
                    {
                        "username": "bishal_722",
                        "content": "I mean...why N x sqrt(N) is not acceptable.....why leetcode why!! \\nI\\'ve written my code with the immense art of my mind, then it got TLE....just because of this 10^6 constraint. \\uD83D\\uDE02"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Today I learnt a new algorithm...Sieve of Eratosthenes!! Let\\'s go"
                    },
                    {
                        "username": "pcRipper",
                        "content": "if you got troubles with this, just solve these two and assemble it together : https://leetcode.com/problems/count-primes/ and https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
                    },
                    {
                        "username": "yusufm09",
                        "content": "This is related to the [Goldbach Conjecture](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture)."
                    },
                    {
                        "username": "najwer23",
                        "content": "204 :)\\nhttps://leetcode.com/problems/count-primes/"
                    },
                    {
                        "username": "keerthanss",
                        "content": "Here\\'s a tip - the pre-computation of the sieve and thereby primes needs to be independent of the exact test case, so that the same result can be used for every test case, than finding the list of primes again and again."
                    }
                ]
            }
        ]
    }
]